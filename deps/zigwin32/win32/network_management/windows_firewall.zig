//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (4)
//--------------------------------------------------------------------------------
pub const NETCON_MAX_NAME_LEN = @as(u32, 256);
pub const S_OBJECT_NO_LONGER_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2));
pub const NETISO_GEID_FOR_WDAG = @as(u32, 1);
pub const NETISO_GEID_FOR_NEUTRAL_AWARE = @as(u32, 2);

//--------------------------------------------------------------------------------
// Section: Types (97)
//--------------------------------------------------------------------------------
const CLSID_UPnPNAT_Value = @import("../zig.zig").Guid.initString("ae1e00aa-3fd5-403c-8a27-2bbdc30cd0e1");
pub const CLSID_UPnPNAT = &CLSID_UPnPNAT_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUPnPNAT_Value = @import("../zig.zig").Guid.initString("b171c812-cc76-485a-94d8-b6b3a2794e99");
pub const IID_IUPnPNAT = &IID_IUPnPNAT_Value;
pub const IUPnPNAT = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StaticPortMappingCollection: fn(
            self: *const IUPnPNAT,
            ppSPMs: ?*?*IStaticPortMappingCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DynamicPortMappingCollection: fn(
            self: *const IUPnPNAT,
            ppDPMs: ?*?*IDynamicPortMappingCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NATEventManager: fn(
            self: *const IUPnPNAT,
            ppNEM: ?*?*INATEventManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPNAT_get_StaticPortMappingCollection(self: *const T, ppSPMs: ?*?*IStaticPortMappingCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUPnPNAT.VTable, self.vtable).get_StaticPortMappingCollection(@ptrCast(*const IUPnPNAT, self), ppSPMs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPNAT_get_DynamicPortMappingCollection(self: *const T, ppDPMs: ?*?*IDynamicPortMappingCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUPnPNAT.VTable, self.vtable).get_DynamicPortMappingCollection(@ptrCast(*const IUPnPNAT, self), ppDPMs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUPnPNAT_get_NATEventManager(self: *const T, ppNEM: ?*?*INATEventManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUPnPNAT.VTable, self.vtable).get_NATEventManager(@ptrCast(*const IUPnPNAT, self), ppNEM);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INATEventManager_Value = @import("../zig.zig").Guid.initString("624bd588-9060-4109-b0b0-1adbbcac32df");
pub const IID_INATEventManager = &IID_INATEventManager_Value;
pub const INATEventManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExternalIPAddressCallback: fn(
            self: *const INATEventManager,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NumberOfEntriesCallback: fn(
            self: *const INATEventManager,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INATEventManager_put_ExternalIPAddressCallback(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INATEventManager.VTable, self.vtable).put_ExternalIPAddressCallback(@ptrCast(*const INATEventManager, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INATEventManager_put_NumberOfEntriesCallback(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INATEventManager.VTable, self.vtable).put_NumberOfEntriesCallback(@ptrCast(*const INATEventManager, self), pUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INATExternalIPAddressCallback_Value = @import("../zig.zig").Guid.initString("9c416740-a34e-446f-ba06-abd04c3149ae");
pub const IID_INATExternalIPAddressCallback = &IID_INATExternalIPAddressCallback_Value;
pub const INATExternalIPAddressCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NewExternalIPAddress: fn(
            self: *const INATExternalIPAddressCallback,
            bstrNewExternalIPAddress: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INATExternalIPAddressCallback_NewExternalIPAddress(self: *const T, bstrNewExternalIPAddress: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INATExternalIPAddressCallback.VTable, self.vtable).NewExternalIPAddress(@ptrCast(*const INATExternalIPAddressCallback, self), bstrNewExternalIPAddress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INATNumberOfEntriesCallback_Value = @import("../zig.zig").Guid.initString("c83a0a74-91ee-41b6-b67a-67e0f00bbd78");
pub const IID_INATNumberOfEntriesCallback = &IID_INATNumberOfEntriesCallback_Value;
pub const INATNumberOfEntriesCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NewNumberOfEntries: fn(
            self: *const INATNumberOfEntriesCallback,
            lNewNumberOfEntries: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INATNumberOfEntriesCallback_NewNumberOfEntries(self: *const T, lNewNumberOfEntries: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INATNumberOfEntriesCallback.VTable, self.vtable).NewNumberOfEntries(@ptrCast(*const INATNumberOfEntriesCallback, self), lNewNumberOfEntries);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicPortMappingCollection_Value = @import("../zig.zig").Guid.initString("b60de00f-156e-4e8d-9ec1-3a2342c10899");
pub const IID_IDynamicPortMappingCollection = &IID_IDynamicPortMappingCollection_Value;
pub const IDynamicPortMappingCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IDynamicPortMappingCollection,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IDynamicPortMappingCollection,
            bstrRemoteHost: ?BSTR,
            lExternalPort: i32,
            bstrProtocol: ?BSTR,
            ppDPM: ?*?*IDynamicPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IDynamicPortMappingCollection,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IDynamicPortMappingCollection,
            bstrRemoteHost: ?BSTR,
            lExternalPort: i32,
            bstrProtocol: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IDynamicPortMappingCollection,
            bstrRemoteHost: ?BSTR,
            lExternalPort: i32,
            bstrProtocol: ?BSTR,
            lInternalPort: i32,
            bstrInternalClient: ?BSTR,
            bEnabled: i16,
            bstrDescription: ?BSTR,
            lLeaseDuration: i32,
            ppDPM: ?*?*IDynamicPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMappingCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMappingCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IDynamicPortMappingCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMappingCollection_get_Item(self: *const T, bstrRemoteHost: ?BSTR, lExternalPort: i32, bstrProtocol: ?BSTR, ppDPM: ?*?*IDynamicPortMapping) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMappingCollection.VTable, self.vtable).get_Item(@ptrCast(*const IDynamicPortMappingCollection, self), bstrRemoteHost, lExternalPort, bstrProtocol, ppDPM);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMappingCollection_get_Count(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMappingCollection.VTable, self.vtable).get_Count(@ptrCast(*const IDynamicPortMappingCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMappingCollection_Remove(self: *const T, bstrRemoteHost: ?BSTR, lExternalPort: i32, bstrProtocol: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMappingCollection.VTable, self.vtable).Remove(@ptrCast(*const IDynamicPortMappingCollection, self), bstrRemoteHost, lExternalPort, bstrProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMappingCollection_Add(self: *const T, bstrRemoteHost: ?BSTR, lExternalPort: i32, bstrProtocol: ?BSTR, lInternalPort: i32, bstrInternalClient: ?BSTR, bEnabled: i16, bstrDescription: ?BSTR, lLeaseDuration: i32, ppDPM: ?*?*IDynamicPortMapping) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMappingCollection.VTable, self.vtable).Add(@ptrCast(*const IDynamicPortMappingCollection, self), bstrRemoteHost, lExternalPort, bstrProtocol, lInternalPort, bstrInternalClient, bEnabled, bstrDescription, lLeaseDuration, ppDPM);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicPortMapping_Value = @import("../zig.zig").Guid.initString("4fc80282-23b6-4378-9a27-cd8f17c9400c");
pub const IID_IDynamicPortMapping = &IID_IDynamicPortMapping_Value;
pub const IDynamicPortMapping = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalIPAddress: fn(
            self: *const IDynamicPortMapping,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteHost: fn(
            self: *const IDynamicPortMapping,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalPort: fn(
            self: *const IDynamicPortMapping,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: fn(
            self: *const IDynamicPortMapping,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalPort: fn(
            self: *const IDynamicPortMapping,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalClient: fn(
            self: *const IDynamicPortMapping,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const IDynamicPortMapping,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IDynamicPortMapping,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LeaseDuration: fn(
            self: *const IDynamicPortMapping,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenewLease: fn(
            self: *const IDynamicPortMapping,
            lLeaseDurationDesired: i32,
            pLeaseDurationReturned: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EditInternalClient: fn(
            self: *const IDynamicPortMapping,
            bstrInternalClient: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const IDynamicPortMapping,
            vb: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EditDescription: fn(
            self: *const IDynamicPortMapping,
            bstrDescription: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EditInternalPort: fn(
            self: *const IDynamicPortMapping,
            lInternalPort: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_get_ExternalIPAddress(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).get_ExternalIPAddress(@ptrCast(*const IDynamicPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_get_RemoteHost(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).get_RemoteHost(@ptrCast(*const IDynamicPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_get_ExternalPort(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).get_ExternalPort(@ptrCast(*const IDynamicPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_get_Protocol(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).get_Protocol(@ptrCast(*const IDynamicPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_get_InternalPort(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).get_InternalPort(@ptrCast(*const IDynamicPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_get_InternalClient(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).get_InternalClient(@ptrCast(*const IDynamicPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_get_Enabled(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).get_Enabled(@ptrCast(*const IDynamicPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_get_Description(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).get_Description(@ptrCast(*const IDynamicPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_get_LeaseDuration(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).get_LeaseDuration(@ptrCast(*const IDynamicPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_RenewLease(self: *const T, lLeaseDurationDesired: i32, pLeaseDurationReturned: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).RenewLease(@ptrCast(*const IDynamicPortMapping, self), lLeaseDurationDesired, pLeaseDurationReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_EditInternalClient(self: *const T, bstrInternalClient: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).EditInternalClient(@ptrCast(*const IDynamicPortMapping, self), bstrInternalClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_Enable(self: *const T, vb: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).Enable(@ptrCast(*const IDynamicPortMapping, self), vb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_EditDescription(self: *const T, bstrDescription: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).EditDescription(@ptrCast(*const IDynamicPortMapping, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicPortMapping_EditInternalPort(self: *const T, lInternalPort: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicPortMapping.VTable, self.vtable).EditInternalPort(@ptrCast(*const IDynamicPortMapping, self), lInternalPort);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStaticPortMappingCollection_Value = @import("../zig.zig").Guid.initString("cd1f3e77-66d6-4664-82c7-36dbb641d0f1");
pub const IID_IStaticPortMappingCollection = &IID_IStaticPortMappingCollection_Value;
pub const IStaticPortMappingCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IStaticPortMappingCollection,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IStaticPortMappingCollection,
            lExternalPort: i32,
            bstrProtocol: ?BSTR,
            ppSPM: ?*?*IStaticPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IStaticPortMappingCollection,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IStaticPortMappingCollection,
            lExternalPort: i32,
            bstrProtocol: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IStaticPortMappingCollection,
            lExternalPort: i32,
            bstrProtocol: ?BSTR,
            lInternalPort: i32,
            bstrInternalClient: ?BSTR,
            bEnabled: i16,
            bstrDescription: ?BSTR,
            ppSPM: ?*?*IStaticPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMappingCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMappingCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IStaticPortMappingCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMappingCollection_get_Item(self: *const T, lExternalPort: i32, bstrProtocol: ?BSTR, ppSPM: ?*?*IStaticPortMapping) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMappingCollection.VTable, self.vtable).get_Item(@ptrCast(*const IStaticPortMappingCollection, self), lExternalPort, bstrProtocol, ppSPM);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMappingCollection_get_Count(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMappingCollection.VTable, self.vtable).get_Count(@ptrCast(*const IStaticPortMappingCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMappingCollection_Remove(self: *const T, lExternalPort: i32, bstrProtocol: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMappingCollection.VTable, self.vtable).Remove(@ptrCast(*const IStaticPortMappingCollection, self), lExternalPort, bstrProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMappingCollection_Add(self: *const T, lExternalPort: i32, bstrProtocol: ?BSTR, lInternalPort: i32, bstrInternalClient: ?BSTR, bEnabled: i16, bstrDescription: ?BSTR, ppSPM: ?*?*IStaticPortMapping) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMappingCollection.VTable, self.vtable).Add(@ptrCast(*const IStaticPortMappingCollection, self), lExternalPort, bstrProtocol, lInternalPort, bstrInternalClient, bEnabled, bstrDescription, ppSPM);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStaticPortMapping_Value = @import("../zig.zig").Guid.initString("6f10711f-729b-41e5-93b8-f21d0f818df1");
pub const IID_IStaticPortMapping = &IID_IStaticPortMapping_Value;
pub const IStaticPortMapping = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalIPAddress: fn(
            self: *const IStaticPortMapping,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalPort: fn(
            self: *const IStaticPortMapping,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalPort: fn(
            self: *const IStaticPortMapping,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: fn(
            self: *const IStaticPortMapping,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalClient: fn(
            self: *const IStaticPortMapping,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const IStaticPortMapping,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IStaticPortMapping,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EditInternalClient: fn(
            self: *const IStaticPortMapping,
            bstrInternalClient: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const IStaticPortMapping,
            vb: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EditDescription: fn(
            self: *const IStaticPortMapping,
            bstrDescription: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EditInternalPort: fn(
            self: *const IStaticPortMapping,
            lInternalPort: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_get_ExternalIPAddress(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).get_ExternalIPAddress(@ptrCast(*const IStaticPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_get_ExternalPort(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).get_ExternalPort(@ptrCast(*const IStaticPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_get_InternalPort(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).get_InternalPort(@ptrCast(*const IStaticPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_get_Protocol(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).get_Protocol(@ptrCast(*const IStaticPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_get_InternalClient(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).get_InternalClient(@ptrCast(*const IStaticPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_get_Enabled(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).get_Enabled(@ptrCast(*const IStaticPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_get_Description(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).get_Description(@ptrCast(*const IStaticPortMapping, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_EditInternalClient(self: *const T, bstrInternalClient: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).EditInternalClient(@ptrCast(*const IStaticPortMapping, self), bstrInternalClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_Enable(self: *const T, vb: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).Enable(@ptrCast(*const IStaticPortMapping, self), vb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_EditDescription(self: *const T, bstrDescription: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).EditDescription(@ptrCast(*const IStaticPortMapping, self), bstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStaticPortMapping_EditInternalPort(self: *const T, lInternalPort: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStaticPortMapping.VTable, self.vtable).EditInternalPort(@ptrCast(*const IStaticPortMapping, self), lInternalPort);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_NetSharingManager_Value = @import("../zig.zig").Guid.initString("5c63c1ad-3956-4ff8-8486-40034758315b");
pub const CLSID_NetSharingManager = &CLSID_NetSharingManager_Value;

const IID_IEnumNetConnection_Value = @import("../zig.zig").Guid.initString("c08956a0-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetConnection = &IID_IEnumNetConnection_Value;
pub const IEnumNetConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumNetConnection,
            celt: u32,
            rgelt: [*]?*INetConnection,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumNetConnection,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumNetConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumNetConnection,
            ppenum: ?*?*IEnumNetConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetConnection_Next(self: *const T, celt: u32, rgelt: [*]?*INetConnection, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetConnection.VTable, self.vtable).Next(@ptrCast(*const IEnumNetConnection, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetConnection_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetConnection.VTable, self.vtable).Skip(@ptrCast(*const IEnumNetConnection, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetConnection_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetConnection.VTable, self.vtable).Reset(@ptrCast(*const IEnumNetConnection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetConnection_Clone(self: *const T, ppenum: ?*?*IEnumNetConnection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetConnection.VTable, self.vtable).Clone(@ptrCast(*const IEnumNetConnection, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NETCON_CHARACTERISTIC_FLAGS = enum(i32) {
    NONE = 0,
    ALL_USERS = 1,
    ALLOW_DUPLICATION = 2,
    ALLOW_REMOVAL = 4,
    ALLOW_RENAME = 8,
    INCOMING_ONLY = 32,
    OUTGOING_ONLY = 64,
    BRANDED = 128,
    SHARED = 256,
    BRIDGED = 512,
    FIREWALLED = 1024,
    DEFAULT = 2048,
    HOMENET_CAPABLE = 4096,
    SHARED_PRIVATE = 8192,
    QUARANTINED = 16384,
    RESERVED = 32768,
    HOSTED_NETWORK = 65536,
    VIRTUAL_STATION = 131072,
    WIFI_DIRECT = 262144,
    BLUETOOTH_MASK = 983040,
    LAN_MASK = 15728640,
};
pub const NCCF_NONE = NETCON_CHARACTERISTIC_FLAGS.NONE;
pub const NCCF_ALL_USERS = NETCON_CHARACTERISTIC_FLAGS.ALL_USERS;
pub const NCCF_ALLOW_DUPLICATION = NETCON_CHARACTERISTIC_FLAGS.ALLOW_DUPLICATION;
pub const NCCF_ALLOW_REMOVAL = NETCON_CHARACTERISTIC_FLAGS.ALLOW_REMOVAL;
pub const NCCF_ALLOW_RENAME = NETCON_CHARACTERISTIC_FLAGS.ALLOW_RENAME;
pub const NCCF_INCOMING_ONLY = NETCON_CHARACTERISTIC_FLAGS.INCOMING_ONLY;
pub const NCCF_OUTGOING_ONLY = NETCON_CHARACTERISTIC_FLAGS.OUTGOING_ONLY;
pub const NCCF_BRANDED = NETCON_CHARACTERISTIC_FLAGS.BRANDED;
pub const NCCF_SHARED = NETCON_CHARACTERISTIC_FLAGS.SHARED;
pub const NCCF_BRIDGED = NETCON_CHARACTERISTIC_FLAGS.BRIDGED;
pub const NCCF_FIREWALLED = NETCON_CHARACTERISTIC_FLAGS.FIREWALLED;
pub const NCCF_DEFAULT = NETCON_CHARACTERISTIC_FLAGS.DEFAULT;
pub const NCCF_HOMENET_CAPABLE = NETCON_CHARACTERISTIC_FLAGS.HOMENET_CAPABLE;
pub const NCCF_SHARED_PRIVATE = NETCON_CHARACTERISTIC_FLAGS.SHARED_PRIVATE;
pub const NCCF_QUARANTINED = NETCON_CHARACTERISTIC_FLAGS.QUARANTINED;
pub const NCCF_RESERVED = NETCON_CHARACTERISTIC_FLAGS.RESERVED;
pub const NCCF_HOSTED_NETWORK = NETCON_CHARACTERISTIC_FLAGS.HOSTED_NETWORK;
pub const NCCF_VIRTUAL_STATION = NETCON_CHARACTERISTIC_FLAGS.VIRTUAL_STATION;
pub const NCCF_WIFI_DIRECT = NETCON_CHARACTERISTIC_FLAGS.WIFI_DIRECT;
pub const NCCF_BLUETOOTH_MASK = NETCON_CHARACTERISTIC_FLAGS.BLUETOOTH_MASK;
pub const NCCF_LAN_MASK = NETCON_CHARACTERISTIC_FLAGS.LAN_MASK;

pub const NETCON_STATUS = enum(i32) {
    DISCONNECTED = 0,
    CONNECTING = 1,
    CONNECTED = 2,
    DISCONNECTING = 3,
    HARDWARE_NOT_PRESENT = 4,
    HARDWARE_DISABLED = 5,
    HARDWARE_MALFUNCTION = 6,
    MEDIA_DISCONNECTED = 7,
    AUTHENTICATING = 8,
    AUTHENTICATION_SUCCEEDED = 9,
    AUTHENTICATION_FAILED = 10,
    INVALID_ADDRESS = 11,
    CREDENTIALS_REQUIRED = 12,
    ACTION_REQUIRED = 13,
    ACTION_REQUIRED_RETRY = 14,
    CONNECT_FAILED = 15,
};
pub const NCS_DISCONNECTED = NETCON_STATUS.DISCONNECTED;
pub const NCS_CONNECTING = NETCON_STATUS.CONNECTING;
pub const NCS_CONNECTED = NETCON_STATUS.CONNECTED;
pub const NCS_DISCONNECTING = NETCON_STATUS.DISCONNECTING;
pub const NCS_HARDWARE_NOT_PRESENT = NETCON_STATUS.HARDWARE_NOT_PRESENT;
pub const NCS_HARDWARE_DISABLED = NETCON_STATUS.HARDWARE_DISABLED;
pub const NCS_HARDWARE_MALFUNCTION = NETCON_STATUS.HARDWARE_MALFUNCTION;
pub const NCS_MEDIA_DISCONNECTED = NETCON_STATUS.MEDIA_DISCONNECTED;
pub const NCS_AUTHENTICATING = NETCON_STATUS.AUTHENTICATING;
pub const NCS_AUTHENTICATION_SUCCEEDED = NETCON_STATUS.AUTHENTICATION_SUCCEEDED;
pub const NCS_AUTHENTICATION_FAILED = NETCON_STATUS.AUTHENTICATION_FAILED;
pub const NCS_INVALID_ADDRESS = NETCON_STATUS.INVALID_ADDRESS;
pub const NCS_CREDENTIALS_REQUIRED = NETCON_STATUS.CREDENTIALS_REQUIRED;
pub const NCS_ACTION_REQUIRED = NETCON_STATUS.ACTION_REQUIRED;
pub const NCS_ACTION_REQUIRED_RETRY = NETCON_STATUS.ACTION_REQUIRED_RETRY;
pub const NCS_CONNECT_FAILED = NETCON_STATUS.CONNECT_FAILED;

pub const NETCON_TYPE = enum(i32) {
    DIRECT_CONNECT = 0,
    INBOUND = 1,
    INTERNET = 2,
    LAN = 3,
    PHONE = 4,
    TUNNEL = 5,
    BRIDGE = 6,
};
pub const NCT_DIRECT_CONNECT = NETCON_TYPE.DIRECT_CONNECT;
pub const NCT_INBOUND = NETCON_TYPE.INBOUND;
pub const NCT_INTERNET = NETCON_TYPE.INTERNET;
pub const NCT_LAN = NETCON_TYPE.LAN;
pub const NCT_PHONE = NETCON_TYPE.PHONE;
pub const NCT_TUNNEL = NETCON_TYPE.TUNNEL;
pub const NCT_BRIDGE = NETCON_TYPE.BRIDGE;

pub const NETCON_MEDIATYPE = enum(i32) {
    NONE = 0,
    DIRECT = 1,
    ISDN = 2,
    LAN = 3,
    PHONE = 4,
    TUNNEL = 5,
    PPPOE = 6,
    BRIDGE = 7,
    SHAREDACCESSHOST_LAN = 8,
    SHAREDACCESSHOST_RAS = 9,
};
pub const NCM_NONE = NETCON_MEDIATYPE.NONE;
pub const NCM_DIRECT = NETCON_MEDIATYPE.DIRECT;
pub const NCM_ISDN = NETCON_MEDIATYPE.ISDN;
pub const NCM_LAN = NETCON_MEDIATYPE.LAN;
pub const NCM_PHONE = NETCON_MEDIATYPE.PHONE;
pub const NCM_TUNNEL = NETCON_MEDIATYPE.TUNNEL;
pub const NCM_PPPOE = NETCON_MEDIATYPE.PPPOE;
pub const NCM_BRIDGE = NETCON_MEDIATYPE.BRIDGE;
pub const NCM_SHAREDACCESSHOST_LAN = NETCON_MEDIATYPE.SHAREDACCESSHOST_LAN;
pub const NCM_SHAREDACCESSHOST_RAS = NETCON_MEDIATYPE.SHAREDACCESSHOST_RAS;

pub const NETCON_PROPERTIES = extern struct {
    guidId: Guid,
    pszwName: ?PWSTR,
    pszwDeviceName: ?PWSTR,
    Status: NETCON_STATUS,
    MediaType: NETCON_MEDIATYPE,
    dwCharacter: u32,
    clsidThisObject: Guid,
    clsidUiObject: Guid,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetConnection_Value = @import("../zig.zig").Guid.initString("c08956a1-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetConnection = &IID_INetConnection_Value;
pub const INetConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: fn(
            self: *const INetConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const INetConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const INetConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Duplicate: fn(
            self: *const INetConnection,
            pszwDuplicateName: ?[*:0]const u16,
            ppCon: ?*?*INetConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const INetConnection,
            ppProps: ?*?*NETCON_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUiObjectClassId: fn(
            self: *const INetConnection,
            pclsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Rename: fn(
            self: *const INetConnection,
            pszwNewName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnection_Connect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnection.VTable, self.vtable).Connect(@ptrCast(*const INetConnection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnection_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnection.VTable, self.vtable).Disconnect(@ptrCast(*const INetConnection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnection_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnection.VTable, self.vtable).Delete(@ptrCast(*const INetConnection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnection_Duplicate(self: *const T, pszwDuplicateName: ?[*:0]const u16, ppCon: ?*?*INetConnection) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnection.VTable, self.vtable).Duplicate(@ptrCast(*const INetConnection, self), pszwDuplicateName, ppCon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnection_GetProperties(self: *const T, ppProps: ?*?*NETCON_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnection.VTable, self.vtable).GetProperties(@ptrCast(*const INetConnection, self), ppProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnection_GetUiObjectClassId(self: *const T, pclsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnection.VTable, self.vtable).GetUiObjectClassId(@ptrCast(*const INetConnection, self), pclsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnection_Rename(self: *const T, pszwNewName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnection.VTable, self.vtable).Rename(@ptrCast(*const INetConnection, self), pszwNewName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NETCONMGR_ENUM_FLAGS = enum(i32) {
    DEFAULT = 0,
    HIDDEN = 1,
};
pub const NCME_DEFAULT = NETCONMGR_ENUM_FLAGS.DEFAULT;
pub const NCME_HIDDEN = NETCONMGR_ENUM_FLAGS.HIDDEN;

const IID_INetConnectionManager_Value = @import("../zig.zig").Guid.initString("c08956a2-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetConnectionManager = &IID_INetConnectionManager_Value;
pub const INetConnectionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumConnections: fn(
            self: *const INetConnectionManager,
            Flags: NETCONMGR_ENUM_FLAGS,
            ppEnum: ?*?*IEnumNetConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionManager_EnumConnections(self: *const T, Flags: NETCONMGR_ENUM_FLAGS, ppEnum: ?*?*IEnumNetConnection) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionManager.VTable, self.vtable).EnumConnections(@ptrCast(*const INetConnectionManager, self), Flags, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NETCONUI_CONNECT_FLAGS = enum(i32) {
    DEFAULT = 0,
    NO_UI = 1,
    ENABLE_DISABLE = 2,
};
pub const NCUC_DEFAULT = NETCONUI_CONNECT_FLAGS.DEFAULT;
pub const NCUC_NO_UI = NETCONUI_CONNECT_FLAGS.NO_UI;
pub const NCUC_ENABLE_DISABLE = NETCONUI_CONNECT_FLAGS.ENABLE_DISABLE;

const IID_INetConnectionConnectUi_Value = @import("../zig.zig").Guid.initString("c08956a3-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetConnectionConnectUi = &IID_INetConnectionConnectUi_Value;
pub const INetConnectionConnectUi = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetConnection: fn(
            self: *const INetConnectionConnectUi,
            pCon: ?*INetConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Connect: fn(
            self: *const INetConnectionConnectUi,
            hwndParent: ?HWND,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const INetConnectionConnectUi,
            hwndParent: ?HWND,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionConnectUi_SetConnection(self: *const T, pCon: ?*INetConnection) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionConnectUi.VTable, self.vtable).SetConnection(@ptrCast(*const INetConnectionConnectUi, self), pCon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionConnectUi_Connect(self: *const T, hwndParent: ?HWND, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionConnectUi.VTable, self.vtable).Connect(@ptrCast(*const INetConnectionConnectUi, self), hwndParent, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionConnectUi_Disconnect(self: *const T, hwndParent: ?HWND, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionConnectUi.VTable, self.vtable).Disconnect(@ptrCast(*const INetConnectionConnectUi, self), hwndParent, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumNetSharingPortMapping_Value = @import("../zig.zig").Guid.initString("c08956b0-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetSharingPortMapping = &IID_IEnumNetSharingPortMapping_Value;
pub const IEnumNetSharingPortMapping = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumNetSharingPortMapping,
            celt: u32,
            rgVar: [*]VARIANT,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumNetSharingPortMapping,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumNetSharingPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumNetSharingPortMapping,
            ppenum: ?*?*IEnumNetSharingPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPortMapping_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPortMapping.VTable, self.vtable).Next(@ptrCast(*const IEnumNetSharingPortMapping, self), celt, rgVar, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPortMapping_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPortMapping.VTable, self.vtable).Skip(@ptrCast(*const IEnumNetSharingPortMapping, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPortMapping_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPortMapping.VTable, self.vtable).Reset(@ptrCast(*const IEnumNetSharingPortMapping, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPortMapping_Clone(self: *const T, ppenum: ?*?*IEnumNetSharingPortMapping) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPortMapping.VTable, self.vtable).Clone(@ptrCast(*const IEnumNetSharingPortMapping, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPortMappingProps_Value = @import("../zig.zig").Guid.initString("24b7e9b5-e38f-4685-851b-00892cf5f940");
pub const IID_INetSharingPortMappingProps = &IID_INetSharingPortMappingProps_Value;
pub const INetSharingPortMappingProps = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const INetSharingPortMappingProps,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IPProtocol: fn(
            self: *const INetSharingPortMappingProps,
            pucIPProt: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalPort: fn(
            self: *const INetSharingPortMappingProps,
            pusPort: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternalPort: fn(
            self: *const INetSharingPortMappingProps,
            pusPort: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Options: fn(
            self: *const INetSharingPortMappingProps,
            pdwOptions: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetName: fn(
            self: *const INetSharingPortMappingProps,
            pbstrTargetName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetIPAddress: fn(
            self: *const INetSharingPortMappingProps,
            pbstrTargetIPAddress: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const INetSharingPortMappingProps,
            pbool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingProps_get_Name(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingProps.VTable, self.vtable).get_Name(@ptrCast(*const INetSharingPortMappingProps, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingProps_get_IPProtocol(self: *const T, pucIPProt: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingProps.VTable, self.vtable).get_IPProtocol(@ptrCast(*const INetSharingPortMappingProps, self), pucIPProt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingProps_get_ExternalPort(self: *const T, pusPort: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingProps.VTable, self.vtable).get_ExternalPort(@ptrCast(*const INetSharingPortMappingProps, self), pusPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingProps_get_InternalPort(self: *const T, pusPort: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingProps.VTable, self.vtable).get_InternalPort(@ptrCast(*const INetSharingPortMappingProps, self), pusPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingProps_get_Options(self: *const T, pdwOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingProps.VTable, self.vtable).get_Options(@ptrCast(*const INetSharingPortMappingProps, self), pdwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingProps_get_TargetName(self: *const T, pbstrTargetName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingProps.VTable, self.vtable).get_TargetName(@ptrCast(*const INetSharingPortMappingProps, self), pbstrTargetName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingProps_get_TargetIPAddress(self: *const T, pbstrTargetIPAddress: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingProps.VTable, self.vtable).get_TargetIPAddress(@ptrCast(*const INetSharingPortMappingProps, self), pbstrTargetIPAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingProps_get_Enabled(self: *const T, pbool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingProps.VTable, self.vtable).get_Enabled(@ptrCast(*const INetSharingPortMappingProps, self), pbool);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPortMapping_Value = @import("../zig.zig").Guid.initString("c08956b1-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetSharingPortMapping = &IID_INetSharingPortMapping_Value;
pub const INetSharingPortMapping = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Disable: fn(
            self: *const INetSharingPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const INetSharingPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Properties: fn(
            self: *const INetSharingPortMapping,
            ppNSPMP: ?*?*INetSharingPortMappingProps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const INetSharingPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMapping_Disable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMapping.VTable, self.vtable).Disable(@ptrCast(*const INetSharingPortMapping, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMapping_Enable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMapping.VTable, self.vtable).Enable(@ptrCast(*const INetSharingPortMapping, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMapping_get_Properties(self: *const T, ppNSPMP: ?*?*INetSharingPortMappingProps) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMapping.VTable, self.vtable).get_Properties(@ptrCast(*const INetSharingPortMapping, self), ppNSPMP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMapping_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMapping.VTable, self.vtable).Delete(@ptrCast(*const INetSharingPortMapping, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumNetSharingEveryConnection_Value = @import("../zig.zig").Guid.initString("c08956b8-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetSharingEveryConnection = &IID_IEnumNetSharingEveryConnection_Value;
pub const IEnumNetSharingEveryConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumNetSharingEveryConnection,
            celt: u32,
            rgVar: [*]VARIANT,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumNetSharingEveryConnection,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumNetSharingEveryConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumNetSharingEveryConnection,
            ppenum: ?*?*IEnumNetSharingEveryConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingEveryConnection_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingEveryConnection.VTable, self.vtable).Next(@ptrCast(*const IEnumNetSharingEveryConnection, self), celt, rgVar, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingEveryConnection_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingEveryConnection.VTable, self.vtable).Skip(@ptrCast(*const IEnumNetSharingEveryConnection, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingEveryConnection_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingEveryConnection.VTable, self.vtable).Reset(@ptrCast(*const IEnumNetSharingEveryConnection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingEveryConnection_Clone(self: *const T, ppenum: ?*?*IEnumNetSharingEveryConnection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingEveryConnection.VTable, self.vtable).Clone(@ptrCast(*const IEnumNetSharingEveryConnection, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumNetSharingPublicConnection_Value = @import("../zig.zig").Guid.initString("c08956b4-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetSharingPublicConnection = &IID_IEnumNetSharingPublicConnection_Value;
pub const IEnumNetSharingPublicConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumNetSharingPublicConnection,
            celt: u32,
            rgVar: [*]VARIANT,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumNetSharingPublicConnection,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumNetSharingPublicConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumNetSharingPublicConnection,
            ppenum: ?*?*IEnumNetSharingPublicConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPublicConnection_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPublicConnection.VTable, self.vtable).Next(@ptrCast(*const IEnumNetSharingPublicConnection, self), celt, rgVar, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPublicConnection_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPublicConnection.VTable, self.vtable).Skip(@ptrCast(*const IEnumNetSharingPublicConnection, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPublicConnection_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPublicConnection.VTable, self.vtable).Reset(@ptrCast(*const IEnumNetSharingPublicConnection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPublicConnection_Clone(self: *const T, ppenum: ?*?*IEnumNetSharingPublicConnection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPublicConnection.VTable, self.vtable).Clone(@ptrCast(*const IEnumNetSharingPublicConnection, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumNetSharingPrivateConnection_Value = @import("../zig.zig").Guid.initString("c08956b5-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_IEnumNetSharingPrivateConnection = &IID_IEnumNetSharingPrivateConnection_Value;
pub const IEnumNetSharingPrivateConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumNetSharingPrivateConnection,
            celt: u32,
            rgVar: [*]VARIANT,
            pCeltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumNetSharingPrivateConnection,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumNetSharingPrivateConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumNetSharingPrivateConnection,
            ppenum: ?*?*IEnumNetSharingPrivateConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPrivateConnection_Next(self: *const T, celt: u32, rgVar: [*]VARIANT, pCeltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPrivateConnection.VTable, self.vtable).Next(@ptrCast(*const IEnumNetSharingPrivateConnection, self), celt, rgVar, pCeltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPrivateConnection_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPrivateConnection.VTable, self.vtable).Skip(@ptrCast(*const IEnumNetSharingPrivateConnection, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPrivateConnection_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPrivateConnection.VTable, self.vtable).Reset(@ptrCast(*const IEnumNetSharingPrivateConnection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetSharingPrivateConnection_Clone(self: *const T, ppenum: ?*?*IEnumNetSharingPrivateConnection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetSharingPrivateConnection.VTable, self.vtable).Clone(@ptrCast(*const IEnumNetSharingPrivateConnection, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPortMappingCollection_Value = @import("../zig.zig").Guid.initString("02e4a2de-da20-4e34-89c8-ac22275a010b");
pub const IID_INetSharingPortMappingCollection = &IID_INetSharingPortMappingCollection_Value;
pub const INetSharingPortMappingCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const INetSharingPortMappingCollection,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const INetSharingPortMappingCollection,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const INetSharingPortMappingCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPortMappingCollection_get_Count(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPortMappingCollection.VTable, self.vtable).get_Count(@ptrCast(*const INetSharingPortMappingCollection, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetConnectionProps_Value = @import("../zig.zig").Guid.initString("f4277c95-ce5b-463d-8167-5662d9bcaa72");
pub const IID_INetConnectionProps = &IID_INetConnectionProps_Value;
pub const INetConnectionProps = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guid: fn(
            self: *const INetConnectionProps,
            pbstrGuid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const INetConnectionProps,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceName: fn(
            self: *const INetConnectionProps,
            pbstrDeviceName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: fn(
            self: *const INetConnectionProps,
            pStatus: ?*NETCON_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: fn(
            self: *const INetConnectionProps,
            pMediaType: ?*NETCON_MEDIATYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Characteristics: fn(
            self: *const INetConnectionProps,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionProps_get_Guid(self: *const T, pbstrGuid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionProps.VTable, self.vtable).get_Guid(@ptrCast(*const INetConnectionProps, self), pbstrGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionProps_get_Name(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionProps.VTable, self.vtable).get_Name(@ptrCast(*const INetConnectionProps, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionProps_get_DeviceName(self: *const T, pbstrDeviceName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionProps.VTable, self.vtable).get_DeviceName(@ptrCast(*const INetConnectionProps, self), pbstrDeviceName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionProps_get_Status(self: *const T, pStatus: ?*NETCON_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionProps.VTable, self.vtable).get_Status(@ptrCast(*const INetConnectionProps, self), pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionProps_get_MediaType(self: *const T, pMediaType: ?*NETCON_MEDIATYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionProps.VTable, self.vtable).get_MediaType(@ptrCast(*const INetConnectionProps, self), pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetConnectionProps_get_Characteristics(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetConnectionProps.VTable, self.vtable).get_Characteristics(@ptrCast(*const INetConnectionProps, self), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHARINGCONNECTIONTYPE = enum(i32) {
    UBLIC = 0,
    RIVATE = 1,
};
pub const ICSSHARINGTYPE_PUBLIC = SHARINGCONNECTIONTYPE.UBLIC;
pub const ICSSHARINGTYPE_PRIVATE = SHARINGCONNECTIONTYPE.RIVATE;

pub const SHARINGCONNECTION_ENUM_FLAGS = enum(i32) {
    DEFAULT = 0,
    ENABLED = 1,
};
pub const ICSSC_DEFAULT = SHARINGCONNECTION_ENUM_FLAGS.DEFAULT;
pub const ICSSC_ENABLED = SHARINGCONNECTION_ENUM_FLAGS.ENABLED;

pub const ICS_TARGETTYPE = enum(i32) {
    NAME = 0,
    IPADDRESS = 1,
};
pub const ICSTT_NAME = ICS_TARGETTYPE.NAME;
pub const ICSTT_IPADDRESS = ICS_TARGETTYPE.IPADDRESS;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingConfiguration_Value = @import("../zig.zig").Guid.initString("c08956b6-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetSharingConfiguration = &IID_INetSharingConfiguration_Value;
pub const INetSharingConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SharingEnabled: fn(
            self: *const INetSharingConfiguration,
            pbEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SharingConnectionType: fn(
            self: *const INetSharingConfiguration,
            pType: ?*SHARINGCONNECTIONTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableSharing: fn(
            self: *const INetSharingConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableSharing: fn(
            self: *const INetSharingConfiguration,
            Type: SHARINGCONNECTIONTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InternetFirewallEnabled: fn(
            self: *const INetSharingConfiguration,
            pbEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableInternetFirewall: fn(
            self: *const INetSharingConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableInternetFirewall: fn(
            self: *const INetSharingConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumPortMappings: fn(
            self: *const INetSharingConfiguration,
            Flags: SHARINGCONNECTION_ENUM_FLAGS,
            ppColl: ?*?*INetSharingPortMappingCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPortMapping: fn(
            self: *const INetSharingConfiguration,
            bstrName: ?BSTR,
            ucIPProtocol: u8,
            usExternalPort: u16,
            usInternalPort: u16,
            dwOptions: u32,
            bstrTargetNameOrIPAddress: ?BSTR,
            eTargetType: ICS_TARGETTYPE,
            ppMapping: ?*?*INetSharingPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePortMapping: fn(
            self: *const INetSharingConfiguration,
            pMapping: ?*INetSharingPortMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_get_SharingEnabled(self: *const T, pbEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).get_SharingEnabled(@ptrCast(*const INetSharingConfiguration, self), pbEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_get_SharingConnectionType(self: *const T, pType: ?*SHARINGCONNECTIONTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).get_SharingConnectionType(@ptrCast(*const INetSharingConfiguration, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_DisableSharing(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).DisableSharing(@ptrCast(*const INetSharingConfiguration, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_EnableSharing(self: *const T, Type: SHARINGCONNECTIONTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).EnableSharing(@ptrCast(*const INetSharingConfiguration, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_get_InternetFirewallEnabled(self: *const T, pbEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).get_InternetFirewallEnabled(@ptrCast(*const INetSharingConfiguration, self), pbEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_DisableInternetFirewall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).DisableInternetFirewall(@ptrCast(*const INetSharingConfiguration, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_EnableInternetFirewall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).EnableInternetFirewall(@ptrCast(*const INetSharingConfiguration, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_get_EnumPortMappings(self: *const T, Flags: SHARINGCONNECTION_ENUM_FLAGS, ppColl: ?*?*INetSharingPortMappingCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).get_EnumPortMappings(@ptrCast(*const INetSharingConfiguration, self), Flags, ppColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_AddPortMapping(self: *const T, bstrName: ?BSTR, ucIPProtocol: u8, usExternalPort: u16, usInternalPort: u16, dwOptions: u32, bstrTargetNameOrIPAddress: ?BSTR, eTargetType: ICS_TARGETTYPE, ppMapping: ?*?*INetSharingPortMapping) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).AddPortMapping(@ptrCast(*const INetSharingConfiguration, self), bstrName, ucIPProtocol, usExternalPort, usInternalPort, dwOptions, bstrTargetNameOrIPAddress, eTargetType, ppMapping);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingConfiguration_RemovePortMapping(self: *const T, pMapping: ?*INetSharingPortMapping) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingConfiguration.VTable, self.vtable).RemovePortMapping(@ptrCast(*const INetSharingConfiguration, self), pMapping);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingEveryConnectionCollection_Value = @import("../zig.zig").Guid.initString("33c4643c-7811-46fa-a89a-768597bd7223");
pub const IID_INetSharingEveryConnectionCollection = &IID_INetSharingEveryConnectionCollection_Value;
pub const INetSharingEveryConnectionCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const INetSharingEveryConnectionCollection,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const INetSharingEveryConnectionCollection,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingEveryConnectionCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingEveryConnectionCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const INetSharingEveryConnectionCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingEveryConnectionCollection_get_Count(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingEveryConnectionCollection.VTable, self.vtable).get_Count(@ptrCast(*const INetSharingEveryConnectionCollection, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPublicConnectionCollection_Value = @import("../zig.zig").Guid.initString("7d7a6355-f372-4971-a149-bfc927be762a");
pub const IID_INetSharingPublicConnectionCollection = &IID_INetSharingPublicConnectionCollection_Value;
pub const INetSharingPublicConnectionCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const INetSharingPublicConnectionCollection,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const INetSharingPublicConnectionCollection,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPublicConnectionCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPublicConnectionCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const INetSharingPublicConnectionCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPublicConnectionCollection_get_Count(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPublicConnectionCollection.VTable, self.vtable).get_Count(@ptrCast(*const INetSharingPublicConnectionCollection, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingPrivateConnectionCollection_Value = @import("../zig.zig").Guid.initString("38ae69e0-4409-402a-a2cb-e965c727f840");
pub const IID_INetSharingPrivateConnectionCollection = &IID_INetSharingPrivateConnectionCollection_Value;
pub const INetSharingPrivateConnectionCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const INetSharingPrivateConnectionCollection,
            pVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const INetSharingPrivateConnectionCollection,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPrivateConnectionCollection_get__NewEnum(self: *const T, pVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPrivateConnectionCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const INetSharingPrivateConnectionCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingPrivateConnectionCollection_get_Count(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingPrivateConnectionCollection.VTable, self.vtable).get_Count(@ptrCast(*const INetSharingPrivateConnectionCollection, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INetSharingManager_Value = @import("../zig.zig").Guid.initString("c08956b7-1cd3-11d1-b1c5-00805fc1270e");
pub const IID_INetSharingManager = &IID_INetSharingManager_Value;
pub const INetSharingManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SharingInstalled: fn(
            self: *const INetSharingManager,
            pbInstalled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumPublicConnections: fn(
            self: *const INetSharingManager,
            Flags: SHARINGCONNECTION_ENUM_FLAGS,
            ppColl: ?*?*INetSharingPublicConnectionCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumPrivateConnections: fn(
            self: *const INetSharingManager,
            Flags: SHARINGCONNECTION_ENUM_FLAGS,
            ppColl: ?*?*INetSharingPrivateConnectionCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_INetSharingConfigurationForINetConnection: fn(
            self: *const INetSharingManager,
            pNetConnection: ?*INetConnection,
            ppNetSharingConfiguration: ?*?*INetSharingConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumEveryConnection: fn(
            self: *const INetSharingManager,
            ppColl: ?*?*INetSharingEveryConnectionCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetConnectionProps: fn(
            self: *const INetSharingManager,
            pNetConnection: ?*INetConnection,
            ppProps: ?*?*INetConnectionProps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingManager_get_SharingInstalled(self: *const T, pbInstalled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingManager.VTable, self.vtable).get_SharingInstalled(@ptrCast(*const INetSharingManager, self), pbInstalled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingManager_get_EnumPublicConnections(self: *const T, Flags: SHARINGCONNECTION_ENUM_FLAGS, ppColl: ?*?*INetSharingPublicConnectionCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingManager.VTable, self.vtable).get_EnumPublicConnections(@ptrCast(*const INetSharingManager, self), Flags, ppColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingManager_get_EnumPrivateConnections(self: *const T, Flags: SHARINGCONNECTION_ENUM_FLAGS, ppColl: ?*?*INetSharingPrivateConnectionCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingManager.VTable, self.vtable).get_EnumPrivateConnections(@ptrCast(*const INetSharingManager, self), Flags, ppColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingManager_get_INetSharingConfigurationForINetConnection(self: *const T, pNetConnection: ?*INetConnection, ppNetSharingConfiguration: ?*?*INetSharingConfiguration) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingManager.VTable, self.vtable).get_INetSharingConfigurationForINetConnection(@ptrCast(*const INetSharingManager, self), pNetConnection, ppNetSharingConfiguration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingManager_get_EnumEveryConnection(self: *const T, ppColl: ?*?*INetSharingEveryConnectionCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingManager.VTable, self.vtable).get_EnumEveryConnection(@ptrCast(*const INetSharingManager, self), ppColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetSharingManager_get_NetConnectionProps(self: *const T, pNetConnection: ?*INetConnection, ppProps: ?*?*INetConnectionProps) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetSharingManager.VTable, self.vtable).get_NetConnectionProps(@ptrCast(*const INetSharingManager, self), pNetConnection, ppProps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_NetFwRule_Value = @import("../zig.zig").Guid.initString("2c5bc43e-3369-4c33-ab0c-be9469677af4");
pub const CLSID_NetFwRule = &CLSID_NetFwRule_Value;

const CLSID_NetFwOpenPort_Value = @import("../zig.zig").Guid.initString("0ca545c6-37ad-4a6c-bf92-9f7610067ef5");
pub const CLSID_NetFwOpenPort = &CLSID_NetFwOpenPort_Value;

const CLSID_NetFwAuthorizedApplication_Value = @import("../zig.zig").Guid.initString("ec9846b3-2762-4a6b-a214-6acb603462d2");
pub const CLSID_NetFwAuthorizedApplication = &CLSID_NetFwAuthorizedApplication_Value;

const CLSID_NetFwPolicy2_Value = @import("../zig.zig").Guid.initString("e2b3c97f-6ae1-41ac-817a-f6f92166d7dd");
pub const CLSID_NetFwPolicy2 = &CLSID_NetFwPolicy2_Value;

const CLSID_NetFwProduct_Value = @import("../zig.zig").Guid.initString("9d745ed8-c514-4d1d-bf42-751fed2d5ac7");
pub const CLSID_NetFwProduct = &CLSID_NetFwProduct_Value;

const CLSID_NetFwProducts_Value = @import("../zig.zig").Guid.initString("cc19079b-8272-4d73-bb70-cdb533527b61");
pub const CLSID_NetFwProducts = &CLSID_NetFwProducts_Value;

const CLSID_NetFwMgr_Value = @import("../zig.zig").Guid.initString("304ce942-6e39-40d8-943a-b913c40c9cd4");
pub const CLSID_NetFwMgr = &CLSID_NetFwMgr_Value;

pub const NET_FW_POLICY_TYPE = enum(i32) {
    GROUP = 0,
    LOCAL = 1,
    EFFECTIVE = 2,
    TYPE_MAX = 3,
};
pub const NET_FW_POLICY_GROUP = NET_FW_POLICY_TYPE.GROUP;
pub const NET_FW_POLICY_LOCAL = NET_FW_POLICY_TYPE.LOCAL;
pub const NET_FW_POLICY_EFFECTIVE = NET_FW_POLICY_TYPE.EFFECTIVE;
pub const NET_FW_POLICY_TYPE_MAX = NET_FW_POLICY_TYPE.TYPE_MAX;

pub const NET_FW_PROFILE_TYPE = enum(i32) {
    DOMAIN = 0,
    STANDARD = 1,
    CURRENT = 2,
    TYPE_MAX = 3,
};
pub const NET_FW_PROFILE_DOMAIN = NET_FW_PROFILE_TYPE.DOMAIN;
pub const NET_FW_PROFILE_STANDARD = NET_FW_PROFILE_TYPE.STANDARD;
pub const NET_FW_PROFILE_CURRENT = NET_FW_PROFILE_TYPE.CURRENT;
pub const NET_FW_PROFILE_TYPE_MAX = NET_FW_PROFILE_TYPE.TYPE_MAX;

pub const NET_FW_PROFILE_TYPE2 = enum(i32) {
    DOMAIN = 1,
    PRIVATE = 2,
    PUBLIC = 4,
    ALL = 2147483647,
};
pub const NET_FW_PROFILE2_DOMAIN = NET_FW_PROFILE_TYPE2.DOMAIN;
pub const NET_FW_PROFILE2_PRIVATE = NET_FW_PROFILE_TYPE2.PRIVATE;
pub const NET_FW_PROFILE2_PUBLIC = NET_FW_PROFILE_TYPE2.PUBLIC;
pub const NET_FW_PROFILE2_ALL = NET_FW_PROFILE_TYPE2.ALL;

pub const NET_FW_IP_VERSION = enum(i32) {
    V4 = 0,
    V6 = 1,
    ANY = 2,
    MAX = 3,
};
pub const NET_FW_IP_VERSION_V4 = NET_FW_IP_VERSION.V4;
pub const NET_FW_IP_VERSION_V6 = NET_FW_IP_VERSION.V6;
pub const NET_FW_IP_VERSION_ANY = NET_FW_IP_VERSION.ANY;
pub const NET_FW_IP_VERSION_MAX = NET_FW_IP_VERSION.MAX;

pub const NET_FW_SCOPE = enum(i32) {
    ALL = 0,
    LOCAL_SUBNET = 1,
    CUSTOM = 2,
    MAX = 3,
};
pub const NET_FW_SCOPE_ALL = NET_FW_SCOPE.ALL;
pub const NET_FW_SCOPE_LOCAL_SUBNET = NET_FW_SCOPE.LOCAL_SUBNET;
pub const NET_FW_SCOPE_CUSTOM = NET_FW_SCOPE.CUSTOM;
pub const NET_FW_SCOPE_MAX = NET_FW_SCOPE.MAX;

pub const NET_FW_IP_PROTOCOL = enum(i32) {
    TCP = 6,
    UDP = 17,
    ANY = 256,
};
pub const NET_FW_IP_PROTOCOL_TCP = NET_FW_IP_PROTOCOL.TCP;
pub const NET_FW_IP_PROTOCOL_UDP = NET_FW_IP_PROTOCOL.UDP;
pub const NET_FW_IP_PROTOCOL_ANY = NET_FW_IP_PROTOCOL.ANY;

pub const NET_FW_SERVICE_TYPE = enum(i32) {
    FILE_AND_PRINT = 0,
    UPNP = 1,
    REMOTE_DESKTOP = 2,
    NONE = 3,
    TYPE_MAX = 4,
};
pub const NET_FW_SERVICE_FILE_AND_PRINT = NET_FW_SERVICE_TYPE.FILE_AND_PRINT;
pub const NET_FW_SERVICE_UPNP = NET_FW_SERVICE_TYPE.UPNP;
pub const NET_FW_SERVICE_REMOTE_DESKTOP = NET_FW_SERVICE_TYPE.REMOTE_DESKTOP;
pub const NET_FW_SERVICE_NONE = NET_FW_SERVICE_TYPE.NONE;
pub const NET_FW_SERVICE_TYPE_MAX = NET_FW_SERVICE_TYPE.TYPE_MAX;

pub const NET_FW_RULE_DIRECTION = enum(i32) {
    IN = 1,
    OUT = 2,
    MAX = 3,
};
pub const NET_FW_RULE_DIR_IN = NET_FW_RULE_DIRECTION.IN;
pub const NET_FW_RULE_DIR_OUT = NET_FW_RULE_DIRECTION.OUT;
pub const NET_FW_RULE_DIR_MAX = NET_FW_RULE_DIRECTION.MAX;

pub const NET_FW_ACTION = enum(i32) {
    BLOCK = 0,
    ALLOW = 1,
    MAX = 2,
};
pub const NET_FW_ACTION_BLOCK = NET_FW_ACTION.BLOCK;
pub const NET_FW_ACTION_ALLOW = NET_FW_ACTION.ALLOW;
pub const NET_FW_ACTION_MAX = NET_FW_ACTION.MAX;

pub const NET_FW_MODIFY_STATE = enum(i32) {
    OK = 0,
    GP_OVERRIDE = 1,
    INBOUND_BLOCKED = 2,
};
pub const NET_FW_MODIFY_STATE_OK = NET_FW_MODIFY_STATE.OK;
pub const NET_FW_MODIFY_STATE_GP_OVERRIDE = NET_FW_MODIFY_STATE.GP_OVERRIDE;
pub const NET_FW_MODIFY_STATE_INBOUND_BLOCKED = NET_FW_MODIFY_STATE.INBOUND_BLOCKED;

pub const NET_FW_RULE_CATEGORY = enum(i32) {
    BOOT = 0,
    STEALTH = 1,
    FIREWALL = 2,
    CONSEC = 3,
    MAX = 4,
};
pub const NET_FW_RULE_CATEGORY_BOOT = NET_FW_RULE_CATEGORY.BOOT;
pub const NET_FW_RULE_CATEGORY_STEALTH = NET_FW_RULE_CATEGORY.STEALTH;
pub const NET_FW_RULE_CATEGORY_FIREWALL = NET_FW_RULE_CATEGORY.FIREWALL;
pub const NET_FW_RULE_CATEGORY_CONSEC = NET_FW_RULE_CATEGORY.CONSEC;
pub const NET_FW_RULE_CATEGORY_MAX = NET_FW_RULE_CATEGORY.MAX;

pub const NET_FW_EDGE_TRAVERSAL_TYPE = enum(i32) {
    DENY = 0,
    ALLOW = 1,
    DEFER_TO_APP = 2,
    DEFER_TO_USER = 3,
};
pub const NET_FW_EDGE_TRAVERSAL_TYPE_DENY = NET_FW_EDGE_TRAVERSAL_TYPE.DENY;
pub const NET_FW_EDGE_TRAVERSAL_TYPE_ALLOW = NET_FW_EDGE_TRAVERSAL_TYPE.ALLOW;
pub const NET_FW_EDGE_TRAVERSAL_TYPE_DEFER_TO_APP = NET_FW_EDGE_TRAVERSAL_TYPE.DEFER_TO_APP;
pub const NET_FW_EDGE_TRAVERSAL_TYPE_DEFER_TO_USER = NET_FW_EDGE_TRAVERSAL_TYPE.DEFER_TO_USER;

pub const NET_FW_AUTHENTICATE_TYPE = enum(i32) {
    NONE = 0,
    NO_ENCAPSULATION = 1,
    WITH_INTEGRITY = 2,
    AND_NEGOTIATE_ENCRYPTION = 3,
    AND_ENCRYPT = 4,
};
pub const NET_FW_AUTHENTICATE_NONE = NET_FW_AUTHENTICATE_TYPE.NONE;
pub const NET_FW_AUTHENTICATE_NO_ENCAPSULATION = NET_FW_AUTHENTICATE_TYPE.NO_ENCAPSULATION;
pub const NET_FW_AUTHENTICATE_WITH_INTEGRITY = NET_FW_AUTHENTICATE_TYPE.WITH_INTEGRITY;
pub const NET_FW_AUTHENTICATE_AND_NEGOTIATE_ENCRYPTION = NET_FW_AUTHENTICATE_TYPE.AND_NEGOTIATE_ENCRYPTION;
pub const NET_FW_AUTHENTICATE_AND_ENCRYPT = NET_FW_AUTHENTICATE_TYPE.AND_ENCRYPT;

pub const NETISO_FLAG = enum(i32) {
    FORCE_COMPUTE_BINARIES = 1,
    MAX = 2,
};
pub const NETISO_FLAG_FORCE_COMPUTE_BINARIES = NETISO_FLAG.FORCE_COMPUTE_BINARIES;
pub const NETISO_FLAG_MAX = NETISO_FLAG.MAX;

pub const INET_FIREWALL_AC_CREATION_TYPE = enum(i32) {
    NONE = 0,
    PACKAGE_ID_ONLY = 1,
    BINARY = 2,
    MAX = 4,
};
pub const INET_FIREWALL_AC_NONE = INET_FIREWALL_AC_CREATION_TYPE.NONE;
pub const INET_FIREWALL_AC_PACKAGE_ID_ONLY = INET_FIREWALL_AC_CREATION_TYPE.PACKAGE_ID_ONLY;
pub const INET_FIREWALL_AC_BINARY = INET_FIREWALL_AC_CREATION_TYPE.BINARY;
pub const INET_FIREWALL_AC_MAX = INET_FIREWALL_AC_CREATION_TYPE.MAX;

pub const INET_FIREWALL_AC_CHANGE_TYPE = enum(i32) {
    INVALID = 0,
    CREATE = 1,
    DELETE = 2,
    MAX = 3,
};
pub const INET_FIREWALL_AC_CHANGE_INVALID = INET_FIREWALL_AC_CHANGE_TYPE.INVALID;
pub const INET_FIREWALL_AC_CHANGE_CREATE = INET_FIREWALL_AC_CHANGE_TYPE.CREATE;
pub const INET_FIREWALL_AC_CHANGE_DELETE = INET_FIREWALL_AC_CHANGE_TYPE.DELETE;
pub const INET_FIREWALL_AC_CHANGE_MAX = INET_FIREWALL_AC_CHANGE_TYPE.MAX;

pub const INET_FIREWALL_AC_CAPABILITIES = extern struct {
    count: u32,
    capabilities: ?*SID_AND_ATTRIBUTES,
};

pub const INET_FIREWALL_AC_BINARIES = extern struct {
    count: u32,
    binaries: ?*?PWSTR,
};

pub const INET_FIREWALL_AC_CHANGE = extern struct {
    changeType: INET_FIREWALL_AC_CHANGE_TYPE,
    createType: INET_FIREWALL_AC_CREATION_TYPE,
    appContainerSid: ?*SID,
    userSid: ?*SID,
    displayName: ?PWSTR,
    Anonymous: extern union {
        capabilities: INET_FIREWALL_AC_CAPABILITIES,
        binaries: INET_FIREWALL_AC_BINARIES,
    },
};

pub const INET_FIREWALL_APP_CONTAINER = extern struct {
    appContainerSid: ?*SID,
    userSid: ?*SID,
    appContainerName: ?PWSTR,
    displayName: ?PWSTR,
    description: ?PWSTR,
    capabilities: INET_FIREWALL_AC_CAPABILITIES,
    binaries: INET_FIREWALL_AC_BINARIES,
    workingDirectory: ?PWSTR,
    packageFullName: ?PWSTR,
};

pub const PAC_CHANGES_CALLBACK_FN = fn(
    context: ?*anyopaque,
    pChange: ?*const INET_FIREWALL_AC_CHANGE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NETISO_ERROR_TYPE = enum(i32) {
    NONE = 0,
    PRIVATE_NETWORK = 1,
    INTERNET_CLIENT = 2,
    INTERNET_CLIENT_SERVER = 3,
    MAX = 4,
};
pub const NETISO_ERROR_TYPE_NONE = NETISO_ERROR_TYPE.NONE;
pub const NETISO_ERROR_TYPE_PRIVATE_NETWORK = NETISO_ERROR_TYPE.PRIVATE_NETWORK;
pub const NETISO_ERROR_TYPE_INTERNET_CLIENT = NETISO_ERROR_TYPE.INTERNET_CLIENT;
pub const NETISO_ERROR_TYPE_INTERNET_CLIENT_SERVER = NETISO_ERROR_TYPE.INTERNET_CLIENT_SERVER;
pub const NETISO_ERROR_TYPE_MAX = NETISO_ERROR_TYPE.MAX;

pub const PNETISO_EDP_ID_CALLBACK_FN = fn(
    context: ?*anyopaque,
    wszEnterpriseId: ?[*:0]const u16,
    dwErr: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE = enum(i32) {
    INVALID = 0,
    LOCAL = 1,
    MDM = 2,
};
pub const FW_DYNAMIC_KEYWORD_ORIGIN_INVALID = _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE.INVALID;
pub const FW_DYNAMIC_KEYWORD_ORIGIN_LOCAL = _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE.LOCAL;
pub const FW_DYNAMIC_KEYWORD_ORIGIN_MDM = _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE.MDM;

pub const _tag_FW_DYNAMIC_KEYWORD_ADDRESS0 = extern struct {
    id: Guid,
    keyword: ?[*:0]const u16,
    flags: u32,
    addresses: ?[*:0]const u16,
};

pub const _tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0 = extern struct {
    dynamicKeywordAddress: _tag_FW_DYNAMIC_KEYWORD_ADDRESS0,
    next: ?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
    schemaVersion: u16,
    originType: _tag_FW_DYNAMIC_KEYWORD_ORIGIN_TYPE,
};

pub const _tag_FW_DYNAMIC_KEYWORD_ADDRESS_FLAGS = enum(i32) {
    E = 1,
};
pub const FW_DYNAMIC_KEYWORD_ADDRESS_FLAGS_AUTO_RESOLVE = _tag_FW_DYNAMIC_KEYWORD_ADDRESS_FLAGS.E;

pub const _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS = enum(i32) {
    AUTO_RESOLVE = 1,
    NON_AUTO_RESOLVE = 2,
    ALL = 3,
};
pub const FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS_AUTO_RESOLVE = _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS.AUTO_RESOLVE;
pub const FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS_NON_AUTO_RESOLVE = _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS.NON_AUTO_RESOLVE;
pub const FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS_ALL = _tag_FW_DYNAMIC_KEYWORD_ADDRESS_ENUM_FLAGS.ALL;

pub const PFN_FWADDDYNAMICKEYWORDADDRESS0 = fn(
    dynamicKeywordAddress: ?*const _tag_FW_DYNAMIC_KEYWORD_ADDRESS0,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_FWDELETEDYNAMICKEYWORDADDRESS0 = fn(
    dynamicKeywordAddressId: Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_FWENUMDYNAMICKEYWORDADDRESSESBYTYPE0 = fn(
    flags: u32,
    dynamicKeywordAddressData: ?*?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_FWENUMDYNAMICKEYWORDADDRESSBYID0 = fn(
    dynamicKeywordAddressId: Guid,
    dynamicKeywordAddressData: ?*?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_FWFREEDYNAMICKEYWORDADDRESSDATA0 = fn(
    dynamicKeywordAddressData: ?*_tag_FW_DYNAMIC_KEYWORD_ADDRESS_DATA0,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_FWUPDATEDYNAMICKEYWORDADDRESS0 = fn(
    dynamicKeywordAddressId: Guid,
    updatedAddresses: ?[*:0]const u16,
    append: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwRemoteAdminSettings_Value = @import("../zig.zig").Guid.initString("d4becddf-6f73-4a83-b832-9c66874cd20e");
pub const IID_INetFwRemoteAdminSettings = &IID_INetFwRemoteAdminSettings_Value;
pub const INetFwRemoteAdminSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IpVersion: fn(
            self: *const INetFwRemoteAdminSettings,
            ipVersion: ?*NET_FW_IP_VERSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IpVersion: fn(
            self: *const INetFwRemoteAdminSettings,
            ipVersion: NET_FW_IP_VERSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: fn(
            self: *const INetFwRemoteAdminSettings,
            scope: ?*NET_FW_SCOPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Scope: fn(
            self: *const INetFwRemoteAdminSettings,
            scope: NET_FW_SCOPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: fn(
            self: *const INetFwRemoteAdminSettings,
            remoteAddrs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: fn(
            self: *const INetFwRemoteAdminSettings,
            remoteAddrs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const INetFwRemoteAdminSettings,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const INetFwRemoteAdminSettings,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRemoteAdminSettings_get_IpVersion(self: *const T, ipVersion: ?*NET_FW_IP_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRemoteAdminSettings.VTable, self.vtable).get_IpVersion(@ptrCast(*const INetFwRemoteAdminSettings, self), ipVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRemoteAdminSettings_put_IpVersion(self: *const T, ipVersion: NET_FW_IP_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRemoteAdminSettings.VTable, self.vtable).put_IpVersion(@ptrCast(*const INetFwRemoteAdminSettings, self), ipVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRemoteAdminSettings_get_Scope(self: *const T, scope: ?*NET_FW_SCOPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRemoteAdminSettings.VTable, self.vtable).get_Scope(@ptrCast(*const INetFwRemoteAdminSettings, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRemoteAdminSettings_put_Scope(self: *const T, scope: NET_FW_SCOPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRemoteAdminSettings.VTable, self.vtable).put_Scope(@ptrCast(*const INetFwRemoteAdminSettings, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRemoteAdminSettings_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRemoteAdminSettings.VTable, self.vtable).get_RemoteAddresses(@ptrCast(*const INetFwRemoteAdminSettings, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRemoteAdminSettings_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRemoteAdminSettings.VTable, self.vtable).put_RemoteAddresses(@ptrCast(*const INetFwRemoteAdminSettings, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRemoteAdminSettings_get_Enabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRemoteAdminSettings.VTable, self.vtable).get_Enabled(@ptrCast(*const INetFwRemoteAdminSettings, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRemoteAdminSettings_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRemoteAdminSettings.VTable, self.vtable).put_Enabled(@ptrCast(*const INetFwRemoteAdminSettings, self), enabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwIcmpSettings_Value = @import("../zig.zig").Guid.initString("a6207b2e-7cdd-426a-951e-5e1cbc5afead");
pub const IID_INetFwIcmpSettings = &IID_INetFwIcmpSettings_Value;
pub const INetFwIcmpSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundDestinationUnreachable: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundDestinationUnreachable: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowRedirect: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowRedirect: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowInboundEchoRequest: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowInboundEchoRequest: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundTimeExceeded: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundTimeExceeded: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundParameterProblem: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundParameterProblem: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundSourceQuench: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundSourceQuench: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowInboundRouterRequest: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowInboundRouterRequest: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowInboundTimestampRequest: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowInboundTimestampRequest: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowInboundMaskRequest: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowInboundMaskRequest: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowOutboundPacketTooBig: fn(
            self: *const INetFwIcmpSettings,
            allow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowOutboundPacketTooBig: fn(
            self: *const INetFwIcmpSettings,
            allow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowOutboundDestinationUnreachable(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowOutboundDestinationUnreachable(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowOutboundDestinationUnreachable(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowOutboundDestinationUnreachable(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowRedirect(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowRedirect(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowRedirect(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowRedirect(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowInboundEchoRequest(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowInboundEchoRequest(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowInboundEchoRequest(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowInboundEchoRequest(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowOutboundTimeExceeded(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowOutboundTimeExceeded(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowOutboundTimeExceeded(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowOutboundTimeExceeded(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowOutboundParameterProblem(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowOutboundParameterProblem(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowOutboundParameterProblem(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowOutboundParameterProblem(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowOutboundSourceQuench(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowOutboundSourceQuench(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowOutboundSourceQuench(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowOutboundSourceQuench(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowInboundRouterRequest(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowInboundRouterRequest(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowInboundRouterRequest(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowInboundRouterRequest(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowInboundTimestampRequest(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowInboundTimestampRequest(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowInboundTimestampRequest(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowInboundTimestampRequest(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowInboundMaskRequest(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowInboundMaskRequest(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowInboundMaskRequest(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowInboundMaskRequest(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_get_AllowOutboundPacketTooBig(self: *const T, allow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).get_AllowOutboundPacketTooBig(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwIcmpSettings_put_AllowOutboundPacketTooBig(self: *const T, allow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwIcmpSettings.VTable, self.vtable).put_AllowOutboundPacketTooBig(@ptrCast(*const INetFwIcmpSettings, self), allow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwOpenPort_Value = @import("../zig.zig").Guid.initString("e0483ba0-47ff-4d9c-a6d6-7741d0b195f7");
pub const IID_INetFwOpenPort = &IID_INetFwOpenPort_Value;
pub const INetFwOpenPort = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const INetFwOpenPort,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const INetFwOpenPort,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IpVersion: fn(
            self: *const INetFwOpenPort,
            ipVersion: ?*NET_FW_IP_VERSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IpVersion: fn(
            self: *const INetFwOpenPort,
            ipVersion: NET_FW_IP_VERSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: fn(
            self: *const INetFwOpenPort,
            ipProtocol: ?*NET_FW_IP_PROTOCOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Protocol: fn(
            self: *const INetFwOpenPort,
            ipProtocol: NET_FW_IP_PROTOCOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Port: fn(
            self: *const INetFwOpenPort,
            portNumber: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Port: fn(
            self: *const INetFwOpenPort,
            portNumber: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: fn(
            self: *const INetFwOpenPort,
            scope: ?*NET_FW_SCOPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Scope: fn(
            self: *const INetFwOpenPort,
            scope: NET_FW_SCOPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: fn(
            self: *const INetFwOpenPort,
            remoteAddrs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: fn(
            self: *const INetFwOpenPort,
            remoteAddrs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const INetFwOpenPort,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const INetFwOpenPort,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BuiltIn: fn(
            self: *const INetFwOpenPort,
            builtIn: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).get_Name(@ptrCast(*const INetFwOpenPort, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).put_Name(@ptrCast(*const INetFwOpenPort, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_get_IpVersion(self: *const T, ipVersion: ?*NET_FW_IP_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).get_IpVersion(@ptrCast(*const INetFwOpenPort, self), ipVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_put_IpVersion(self: *const T, ipVersion: NET_FW_IP_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).put_IpVersion(@ptrCast(*const INetFwOpenPort, self), ipVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_get_Protocol(self: *const T, ipProtocol: ?*NET_FW_IP_PROTOCOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).get_Protocol(@ptrCast(*const INetFwOpenPort, self), ipProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_put_Protocol(self: *const T, ipProtocol: NET_FW_IP_PROTOCOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).put_Protocol(@ptrCast(*const INetFwOpenPort, self), ipProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_get_Port(self: *const T, portNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).get_Port(@ptrCast(*const INetFwOpenPort, self), portNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_put_Port(self: *const T, portNumber: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).put_Port(@ptrCast(*const INetFwOpenPort, self), portNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_get_Scope(self: *const T, scope: ?*NET_FW_SCOPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).get_Scope(@ptrCast(*const INetFwOpenPort, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_put_Scope(self: *const T, scope: NET_FW_SCOPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).put_Scope(@ptrCast(*const INetFwOpenPort, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).get_RemoteAddresses(@ptrCast(*const INetFwOpenPort, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).put_RemoteAddresses(@ptrCast(*const INetFwOpenPort, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_get_Enabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).get_Enabled(@ptrCast(*const INetFwOpenPort, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).put_Enabled(@ptrCast(*const INetFwOpenPort, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPort_get_BuiltIn(self: *const T, builtIn: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPort.VTable, self.vtable).get_BuiltIn(@ptrCast(*const INetFwOpenPort, self), builtIn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwOpenPorts_Value = @import("../zig.zig").Guid.initString("c0e9d7fa-e07e-430a-b19a-090ce82d92e2");
pub const IID_INetFwOpenPorts = &IID_INetFwOpenPorts_Value;
pub const INetFwOpenPorts = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const INetFwOpenPorts,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const INetFwOpenPorts,
            port: ?*INetFwOpenPort,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const INetFwOpenPorts,
            portNumber: i32,
            ipProtocol: NET_FW_IP_PROTOCOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const INetFwOpenPorts,
            portNumber: i32,
            ipProtocol: NET_FW_IP_PROTOCOL,
            openPort: ?*?*INetFwOpenPort,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const INetFwOpenPorts,
            newEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPorts_get_Count(self: *const T, count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPorts.VTable, self.vtable).get_Count(@ptrCast(*const INetFwOpenPorts, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPorts_Add(self: *const T, port: ?*INetFwOpenPort) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPorts.VTable, self.vtable).Add(@ptrCast(*const INetFwOpenPorts, self), port);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPorts_Remove(self: *const T, portNumber: i32, ipProtocol: NET_FW_IP_PROTOCOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPorts.VTable, self.vtable).Remove(@ptrCast(*const INetFwOpenPorts, self), portNumber, ipProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPorts_Item(self: *const T, portNumber: i32, ipProtocol: NET_FW_IP_PROTOCOL, openPort: ?*?*INetFwOpenPort) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPorts.VTable, self.vtable).Item(@ptrCast(*const INetFwOpenPorts, self), portNumber, ipProtocol, openPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwOpenPorts_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwOpenPorts.VTable, self.vtable).get__NewEnum(@ptrCast(*const INetFwOpenPorts, self), newEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwService_Value = @import("../zig.zig").Guid.initString("79fd57c8-908e-4a36-9888-d5b3f0a444cf");
pub const IID_INetFwService = &IID_INetFwService_Value;
pub const INetFwService = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const INetFwService,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const INetFwService,
            type: ?*NET_FW_SERVICE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Customized: fn(
            self: *const INetFwService,
            customized: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IpVersion: fn(
            self: *const INetFwService,
            ipVersion: ?*NET_FW_IP_VERSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IpVersion: fn(
            self: *const INetFwService,
            ipVersion: NET_FW_IP_VERSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: fn(
            self: *const INetFwService,
            scope: ?*NET_FW_SCOPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Scope: fn(
            self: *const INetFwService,
            scope: NET_FW_SCOPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: fn(
            self: *const INetFwService,
            remoteAddrs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: fn(
            self: *const INetFwService,
            remoteAddrs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const INetFwService,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const INetFwService,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GloballyOpenPorts: fn(
            self: *const INetFwService,
            openPorts: ?*?*INetFwOpenPorts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).get_Name(@ptrCast(*const INetFwService, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_get_Type(self: *const T, type_: ?*NET_FW_SERVICE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).get_Type(@ptrCast(*const INetFwService, self), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_get_Customized(self: *const T, customized: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).get_Customized(@ptrCast(*const INetFwService, self), customized);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_get_IpVersion(self: *const T, ipVersion: ?*NET_FW_IP_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).get_IpVersion(@ptrCast(*const INetFwService, self), ipVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_put_IpVersion(self: *const T, ipVersion: NET_FW_IP_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).put_IpVersion(@ptrCast(*const INetFwService, self), ipVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_get_Scope(self: *const T, scope: ?*NET_FW_SCOPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).get_Scope(@ptrCast(*const INetFwService, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_put_Scope(self: *const T, scope: NET_FW_SCOPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).put_Scope(@ptrCast(*const INetFwService, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).get_RemoteAddresses(@ptrCast(*const INetFwService, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).put_RemoteAddresses(@ptrCast(*const INetFwService, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_get_Enabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).get_Enabled(@ptrCast(*const INetFwService, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).put_Enabled(@ptrCast(*const INetFwService, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwService_get_GloballyOpenPorts(self: *const T, openPorts: ?*?*INetFwOpenPorts) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwService.VTable, self.vtable).get_GloballyOpenPorts(@ptrCast(*const INetFwService, self), openPorts);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwServices_Value = @import("../zig.zig").Guid.initString("79649bb4-903e-421b-94c9-79848e79f6ee");
pub const IID_INetFwServices = &IID_INetFwServices_Value;
pub const INetFwServices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const INetFwServices,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const INetFwServices,
            svcType: NET_FW_SERVICE_TYPE,
            service: ?*?*INetFwService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const INetFwServices,
            newEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwServices_get_Count(self: *const T, count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwServices.VTable, self.vtable).get_Count(@ptrCast(*const INetFwServices, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwServices_Item(self: *const T, svcType: NET_FW_SERVICE_TYPE, service: ?*?*INetFwService) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwServices.VTable, self.vtable).Item(@ptrCast(*const INetFwServices, self), svcType, service);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwServices_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwServices.VTable, self.vtable).get__NewEnum(@ptrCast(*const INetFwServices, self), newEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwAuthorizedApplication_Value = @import("../zig.zig").Guid.initString("b5e64ffa-c2c5-444e-a301-fb5e00018050");
pub const IID_INetFwAuthorizedApplication = &IID_INetFwAuthorizedApplication_Value;
pub const INetFwAuthorizedApplication = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const INetFwAuthorizedApplication,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const INetFwAuthorizedApplication,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProcessImageFileName: fn(
            self: *const INetFwAuthorizedApplication,
            imageFileName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProcessImageFileName: fn(
            self: *const INetFwAuthorizedApplication,
            imageFileName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IpVersion: fn(
            self: *const INetFwAuthorizedApplication,
            ipVersion: ?*NET_FW_IP_VERSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IpVersion: fn(
            self: *const INetFwAuthorizedApplication,
            ipVersion: NET_FW_IP_VERSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: fn(
            self: *const INetFwAuthorizedApplication,
            scope: ?*NET_FW_SCOPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Scope: fn(
            self: *const INetFwAuthorizedApplication,
            scope: NET_FW_SCOPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: fn(
            self: *const INetFwAuthorizedApplication,
            remoteAddrs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: fn(
            self: *const INetFwAuthorizedApplication,
            remoteAddrs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const INetFwAuthorizedApplication,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const INetFwAuthorizedApplication,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).get_Name(@ptrCast(*const INetFwAuthorizedApplication, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).put_Name(@ptrCast(*const INetFwAuthorizedApplication, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_get_ProcessImageFileName(self: *const T, imageFileName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).get_ProcessImageFileName(@ptrCast(*const INetFwAuthorizedApplication, self), imageFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_put_ProcessImageFileName(self: *const T, imageFileName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).put_ProcessImageFileName(@ptrCast(*const INetFwAuthorizedApplication, self), imageFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_get_IpVersion(self: *const T, ipVersion: ?*NET_FW_IP_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).get_IpVersion(@ptrCast(*const INetFwAuthorizedApplication, self), ipVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_put_IpVersion(self: *const T, ipVersion: NET_FW_IP_VERSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).put_IpVersion(@ptrCast(*const INetFwAuthorizedApplication, self), ipVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_get_Scope(self: *const T, scope: ?*NET_FW_SCOPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).get_Scope(@ptrCast(*const INetFwAuthorizedApplication, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_put_Scope(self: *const T, scope: NET_FW_SCOPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).put_Scope(@ptrCast(*const INetFwAuthorizedApplication, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).get_RemoteAddresses(@ptrCast(*const INetFwAuthorizedApplication, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).put_RemoteAddresses(@ptrCast(*const INetFwAuthorizedApplication, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_get_Enabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).get_Enabled(@ptrCast(*const INetFwAuthorizedApplication, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplication_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplication.VTable, self.vtable).put_Enabled(@ptrCast(*const INetFwAuthorizedApplication, self), enabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwAuthorizedApplications_Value = @import("../zig.zig").Guid.initString("644efd52-ccf9-486c-97a2-39f352570b30");
pub const IID_INetFwAuthorizedApplications = &IID_INetFwAuthorizedApplications_Value;
pub const INetFwAuthorizedApplications = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const INetFwAuthorizedApplications,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const INetFwAuthorizedApplications,
            app: ?*INetFwAuthorizedApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const INetFwAuthorizedApplications,
            imageFileName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const INetFwAuthorizedApplications,
            imageFileName: ?BSTR,
            app: ?*?*INetFwAuthorizedApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const INetFwAuthorizedApplications,
            newEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplications_get_Count(self: *const T, count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplications.VTable, self.vtable).get_Count(@ptrCast(*const INetFwAuthorizedApplications, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplications_Add(self: *const T, app: ?*INetFwAuthorizedApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplications.VTable, self.vtable).Add(@ptrCast(*const INetFwAuthorizedApplications, self), app);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplications_Remove(self: *const T, imageFileName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplications.VTable, self.vtable).Remove(@ptrCast(*const INetFwAuthorizedApplications, self), imageFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplications_Item(self: *const T, imageFileName: ?BSTR, app: ?*?*INetFwAuthorizedApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplications.VTable, self.vtable).Item(@ptrCast(*const INetFwAuthorizedApplications, self), imageFileName, app);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwAuthorizedApplications_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwAuthorizedApplications.VTable, self.vtable).get__NewEnum(@ptrCast(*const INetFwAuthorizedApplications, self), newEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwRule_Value = @import("../zig.zig").Guid.initString("af230d27-baba-4e42-aced-f524f22cfce2");
pub const IID_INetFwRule = &IID_INetFwRule_Value;
pub const INetFwRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const INetFwRule,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const INetFwRule,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const INetFwRule,
            desc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const INetFwRule,
            desc: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationName: fn(
            self: *const INetFwRule,
            imageFileName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ApplicationName: fn(
            self: *const INetFwRule,
            imageFileName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceName: fn(
            self: *const INetFwRule,
            serviceName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ServiceName: fn(
            self: *const INetFwRule,
            serviceName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: fn(
            self: *const INetFwRule,
            protocol: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Protocol: fn(
            self: *const INetFwRule,
            protocol: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalPorts: fn(
            self: *const INetFwRule,
            portNumbers: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalPorts: fn(
            self: *const INetFwRule,
            portNumbers: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemotePorts: fn(
            self: *const INetFwRule,
            portNumbers: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemotePorts: fn(
            self: *const INetFwRule,
            portNumbers: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalAddresses: fn(
            self: *const INetFwRule,
            localAddrs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalAddresses: fn(
            self: *const INetFwRule,
            localAddrs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAddresses: fn(
            self: *const INetFwRule,
            remoteAddrs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteAddresses: fn(
            self: *const INetFwRule,
            remoteAddrs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IcmpTypesAndCodes: fn(
            self: *const INetFwRule,
            icmpTypesAndCodes: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IcmpTypesAndCodes: fn(
            self: *const INetFwRule,
            icmpTypesAndCodes: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Direction: fn(
            self: *const INetFwRule,
            dir: ?*NET_FW_RULE_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Direction: fn(
            self: *const INetFwRule,
            dir: NET_FW_RULE_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Interfaces: fn(
            self: *const INetFwRule,
            interfaces: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Interfaces: fn(
            self: *const INetFwRule,
            interfaces: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InterfaceTypes: fn(
            self: *const INetFwRule,
            interfaceTypes: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InterfaceTypes: fn(
            self: *const INetFwRule,
            interfaceTypes: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const INetFwRule,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const INetFwRule,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Grouping: fn(
            self: *const INetFwRule,
            context: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Grouping: fn(
            self: *const INetFwRule,
            context: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Profiles: fn(
            self: *const INetFwRule,
            profileTypesBitmask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Profiles: fn(
            self: *const INetFwRule,
            profileTypesBitmask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EdgeTraversal: fn(
            self: *const INetFwRule,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EdgeTraversal: fn(
            self: *const INetFwRule,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Action: fn(
            self: *const INetFwRule,
            action: ?*NET_FW_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Action: fn(
            self: *const INetFwRule,
            action: NET_FW_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_Name(@ptrCast(*const INetFwRule, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_Name(@ptrCast(*const INetFwRule, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_Description(self: *const T, desc: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_Description(@ptrCast(*const INetFwRule, self), desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_Description(self: *const T, desc: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_Description(@ptrCast(*const INetFwRule, self), desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_ApplicationName(self: *const T, imageFileName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_ApplicationName(@ptrCast(*const INetFwRule, self), imageFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_ApplicationName(self: *const T, imageFileName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_ApplicationName(@ptrCast(*const INetFwRule, self), imageFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_ServiceName(self: *const T, serviceName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_ServiceName(@ptrCast(*const INetFwRule, self), serviceName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_ServiceName(self: *const T, serviceName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_ServiceName(@ptrCast(*const INetFwRule, self), serviceName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_Protocol(self: *const T, protocol: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_Protocol(@ptrCast(*const INetFwRule, self), protocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_Protocol(self: *const T, protocol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_Protocol(@ptrCast(*const INetFwRule, self), protocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_LocalPorts(self: *const T, portNumbers: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_LocalPorts(@ptrCast(*const INetFwRule, self), portNumbers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_LocalPorts(self: *const T, portNumbers: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_LocalPorts(@ptrCast(*const INetFwRule, self), portNumbers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_RemotePorts(self: *const T, portNumbers: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_RemotePorts(@ptrCast(*const INetFwRule, self), portNumbers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_RemotePorts(self: *const T, portNumbers: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_RemotePorts(@ptrCast(*const INetFwRule, self), portNumbers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_LocalAddresses(self: *const T, localAddrs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_LocalAddresses(@ptrCast(*const INetFwRule, self), localAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_LocalAddresses(self: *const T, localAddrs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_LocalAddresses(@ptrCast(*const INetFwRule, self), localAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_RemoteAddresses(self: *const T, remoteAddrs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_RemoteAddresses(@ptrCast(*const INetFwRule, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_RemoteAddresses(self: *const T, remoteAddrs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_RemoteAddresses(@ptrCast(*const INetFwRule, self), remoteAddrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_IcmpTypesAndCodes(self: *const T, icmpTypesAndCodes: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_IcmpTypesAndCodes(@ptrCast(*const INetFwRule, self), icmpTypesAndCodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_IcmpTypesAndCodes(self: *const T, icmpTypesAndCodes: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_IcmpTypesAndCodes(@ptrCast(*const INetFwRule, self), icmpTypesAndCodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_Direction(self: *const T, dir: ?*NET_FW_RULE_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_Direction(@ptrCast(*const INetFwRule, self), dir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_Direction(self: *const T, dir: NET_FW_RULE_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_Direction(@ptrCast(*const INetFwRule, self), dir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_Interfaces(self: *const T, interfaces: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_Interfaces(@ptrCast(*const INetFwRule, self), interfaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_Interfaces(self: *const T, interfaces: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_Interfaces(@ptrCast(*const INetFwRule, self), interfaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_InterfaceTypes(self: *const T, interfaceTypes: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_InterfaceTypes(@ptrCast(*const INetFwRule, self), interfaceTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_InterfaceTypes(self: *const T, interfaceTypes: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_InterfaceTypes(@ptrCast(*const INetFwRule, self), interfaceTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_Enabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_Enabled(@ptrCast(*const INetFwRule, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_Enabled(@ptrCast(*const INetFwRule, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_Grouping(self: *const T, context: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_Grouping(@ptrCast(*const INetFwRule, self), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_Grouping(self: *const T, context: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_Grouping(@ptrCast(*const INetFwRule, self), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_Profiles(self: *const T, profileTypesBitmask: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_Profiles(@ptrCast(*const INetFwRule, self), profileTypesBitmask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_Profiles(self: *const T, profileTypesBitmask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_Profiles(@ptrCast(*const INetFwRule, self), profileTypesBitmask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_EdgeTraversal(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_EdgeTraversal(@ptrCast(*const INetFwRule, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_EdgeTraversal(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_EdgeTraversal(@ptrCast(*const INetFwRule, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_get_Action(self: *const T, action: ?*NET_FW_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).get_Action(@ptrCast(*const INetFwRule, self), action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule_put_Action(self: *const T, action: NET_FW_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule.VTable, self.vtable).put_Action(@ptrCast(*const INetFwRule, self), action);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_INetFwRule2_Value = @import("../zig.zig").Guid.initString("9c27c8da-189b-4dde-89f7-8b39a316782c");
pub const IID_INetFwRule2 = &IID_INetFwRule2_Value;
pub const INetFwRule2 = extern struct {
    pub const VTable = extern struct {
        base: INetFwRule.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EdgeTraversalOptions: fn(
            self: *const INetFwRule2,
            lOptions: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EdgeTraversalOptions: fn(
            self: *const INetFwRule2,
            lOptions: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace INetFwRule.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule2_get_EdgeTraversalOptions(self: *const T, lOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule2.VTable, self.vtable).get_EdgeTraversalOptions(@ptrCast(*const INetFwRule2, self), lOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule2_put_EdgeTraversalOptions(self: *const T, lOptions: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule2.VTable, self.vtable).put_EdgeTraversalOptions(@ptrCast(*const INetFwRule2, self), lOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetFwRule3_Value = @import("../zig.zig").Guid.initString("b21563ff-d696-4222-ab46-4e89b73ab34a");
pub const IID_INetFwRule3 = &IID_INetFwRule3_Value;
pub const INetFwRule3 = extern struct {
    pub const VTable = extern struct {
        base: INetFwRule2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalAppPackageId: fn(
            self: *const INetFwRule3,
            wszPackageId: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalAppPackageId: fn(
            self: *const INetFwRule3,
            wszPackageId: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalUserOwner: fn(
            self: *const INetFwRule3,
            wszUserOwner: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalUserOwner: fn(
            self: *const INetFwRule3,
            wszUserOwner: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalUserAuthorizedList: fn(
            self: *const INetFwRule3,
            wszUserAuthList: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalUserAuthorizedList: fn(
            self: *const INetFwRule3,
            wszUserAuthList: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteUserAuthorizedList: fn(
            self: *const INetFwRule3,
            wszUserAuthList: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteUserAuthorizedList: fn(
            self: *const INetFwRule3,
            wszUserAuthList: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteMachineAuthorizedList: fn(
            self: *const INetFwRule3,
            wszUserAuthList: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RemoteMachineAuthorizedList: fn(
            self: *const INetFwRule3,
            wszUserAuthList: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SecureFlags: fn(
            self: *const INetFwRule3,
            lOptions: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SecureFlags: fn(
            self: *const INetFwRule3,
            lOptions: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace INetFwRule2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_get_LocalAppPackageId(self: *const T, wszPackageId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).get_LocalAppPackageId(@ptrCast(*const INetFwRule3, self), wszPackageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_put_LocalAppPackageId(self: *const T, wszPackageId: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).put_LocalAppPackageId(@ptrCast(*const INetFwRule3, self), wszPackageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_get_LocalUserOwner(self: *const T, wszUserOwner: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).get_LocalUserOwner(@ptrCast(*const INetFwRule3, self), wszUserOwner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_put_LocalUserOwner(self: *const T, wszUserOwner: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).put_LocalUserOwner(@ptrCast(*const INetFwRule3, self), wszUserOwner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_get_LocalUserAuthorizedList(self: *const T, wszUserAuthList: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).get_LocalUserAuthorizedList(@ptrCast(*const INetFwRule3, self), wszUserAuthList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_put_LocalUserAuthorizedList(self: *const T, wszUserAuthList: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).put_LocalUserAuthorizedList(@ptrCast(*const INetFwRule3, self), wszUserAuthList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_get_RemoteUserAuthorizedList(self: *const T, wszUserAuthList: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).get_RemoteUserAuthorizedList(@ptrCast(*const INetFwRule3, self), wszUserAuthList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_put_RemoteUserAuthorizedList(self: *const T, wszUserAuthList: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).put_RemoteUserAuthorizedList(@ptrCast(*const INetFwRule3, self), wszUserAuthList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_get_RemoteMachineAuthorizedList(self: *const T, wszUserAuthList: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).get_RemoteMachineAuthorizedList(@ptrCast(*const INetFwRule3, self), wszUserAuthList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_put_RemoteMachineAuthorizedList(self: *const T, wszUserAuthList: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).put_RemoteMachineAuthorizedList(@ptrCast(*const INetFwRule3, self), wszUserAuthList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_get_SecureFlags(self: *const T, lOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).get_SecureFlags(@ptrCast(*const INetFwRule3, self), lOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRule3_put_SecureFlags(self: *const T, lOptions: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRule3.VTable, self.vtable).put_SecureFlags(@ptrCast(*const INetFwRule3, self), lOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwRules_Value = @import("../zig.zig").Guid.initString("9c4c6277-5027-441e-afae-ca1f542da009");
pub const IID_INetFwRules = &IID_INetFwRules_Value;
pub const INetFwRules = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const INetFwRules,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const INetFwRules,
            rule: ?*INetFwRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const INetFwRules,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const INetFwRules,
            name: ?BSTR,
            rule: ?*?*INetFwRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const INetFwRules,
            newEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRules_get_Count(self: *const T, count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRules.VTable, self.vtable).get_Count(@ptrCast(*const INetFwRules, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRules_Add(self: *const T, rule: ?*INetFwRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRules.VTable, self.vtable).Add(@ptrCast(*const INetFwRules, self), rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRules_Remove(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRules.VTable, self.vtable).Remove(@ptrCast(*const INetFwRules, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRules_Item(self: *const T, name: ?BSTR, rule: ?*?*INetFwRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRules.VTable, self.vtable).Item(@ptrCast(*const INetFwRules, self), name, rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwRules_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwRules.VTable, self.vtable).get__NewEnum(@ptrCast(*const INetFwRules, self), newEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwServiceRestriction_Value = @import("../zig.zig").Guid.initString("8267bbe3-f890-491c-b7b6-2db1ef0e5d2b");
pub const IID_INetFwServiceRestriction = &IID_INetFwServiceRestriction_Value;
pub const INetFwServiceRestriction = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        RestrictService: fn(
            self: *const INetFwServiceRestriction,
            serviceName: ?BSTR,
            appName: ?BSTR,
            restrictService: i16,
            serviceSidRestricted: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ServiceRestricted: fn(
            self: *const INetFwServiceRestriction,
            serviceName: ?BSTR,
            appName: ?BSTR,
            serviceRestricted: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rules: fn(
            self: *const INetFwServiceRestriction,
            rules: ?*?*INetFwRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwServiceRestriction_RestrictService(self: *const T, serviceName: ?BSTR, appName: ?BSTR, restrictService: i16, serviceSidRestricted: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwServiceRestriction.VTable, self.vtable).RestrictService(@ptrCast(*const INetFwServiceRestriction, self), serviceName, appName, restrictService, serviceSidRestricted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwServiceRestriction_ServiceRestricted(self: *const T, serviceName: ?BSTR, appName: ?BSTR, serviceRestricted: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwServiceRestriction.VTable, self.vtable).ServiceRestricted(@ptrCast(*const INetFwServiceRestriction, self), serviceName, appName, serviceRestricted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwServiceRestriction_get_Rules(self: *const T, rules: ?*?*INetFwRules) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwServiceRestriction.VTable, self.vtable).get_Rules(@ptrCast(*const INetFwServiceRestriction, self), rules);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwProfile_Value = @import("../zig.zig").Guid.initString("174a0dda-e9f9-449d-993b-21ab667ca456");
pub const IID_INetFwProfile = &IID_INetFwProfile_Value;
pub const INetFwProfile = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const INetFwProfile,
            type: ?*NET_FW_PROFILE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirewallEnabled: fn(
            self: *const INetFwProfile,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FirewallEnabled: fn(
            self: *const INetFwProfile,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExceptionsNotAllowed: fn(
            self: *const INetFwProfile,
            notAllowed: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExceptionsNotAllowed: fn(
            self: *const INetFwProfile,
            notAllowed: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotificationsDisabled: fn(
            self: *const INetFwProfile,
            disabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NotificationsDisabled: fn(
            self: *const INetFwProfile,
            disabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UnicastResponsesToMulticastBroadcastDisabled: fn(
            self: *const INetFwProfile,
            disabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UnicastResponsesToMulticastBroadcastDisabled: fn(
            self: *const INetFwProfile,
            disabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemoteAdminSettings: fn(
            self: *const INetFwProfile,
            remoteAdminSettings: ?*?*INetFwRemoteAdminSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IcmpSettings: fn(
            self: *const INetFwProfile,
            icmpSettings: ?*?*INetFwIcmpSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GloballyOpenPorts: fn(
            self: *const INetFwProfile,
            openPorts: ?*?*INetFwOpenPorts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Services: fn(
            self: *const INetFwProfile,
            services: ?*?*INetFwServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthorizedApplications: fn(
            self: *const INetFwProfile,
            apps: ?*?*INetFwAuthorizedApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_Type(self: *const T, type_: ?*NET_FW_PROFILE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_Type(@ptrCast(*const INetFwProfile, self), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_FirewallEnabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_FirewallEnabled(@ptrCast(*const INetFwProfile, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_put_FirewallEnabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).put_FirewallEnabled(@ptrCast(*const INetFwProfile, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_ExceptionsNotAllowed(self: *const T, notAllowed: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_ExceptionsNotAllowed(@ptrCast(*const INetFwProfile, self), notAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_put_ExceptionsNotAllowed(self: *const T, notAllowed: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).put_ExceptionsNotAllowed(@ptrCast(*const INetFwProfile, self), notAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_NotificationsDisabled(self: *const T, disabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_NotificationsDisabled(@ptrCast(*const INetFwProfile, self), disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_put_NotificationsDisabled(self: *const T, disabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).put_NotificationsDisabled(@ptrCast(*const INetFwProfile, self), disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_UnicastResponsesToMulticastBroadcastDisabled(self: *const T, disabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_UnicastResponsesToMulticastBroadcastDisabled(@ptrCast(*const INetFwProfile, self), disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_put_UnicastResponsesToMulticastBroadcastDisabled(self: *const T, disabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).put_UnicastResponsesToMulticastBroadcastDisabled(@ptrCast(*const INetFwProfile, self), disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_RemoteAdminSettings(self: *const T, remoteAdminSettings: ?*?*INetFwRemoteAdminSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_RemoteAdminSettings(@ptrCast(*const INetFwProfile, self), remoteAdminSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_IcmpSettings(self: *const T, icmpSettings: ?*?*INetFwIcmpSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_IcmpSettings(@ptrCast(*const INetFwProfile, self), icmpSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_GloballyOpenPorts(self: *const T, openPorts: ?*?*INetFwOpenPorts) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_GloballyOpenPorts(@ptrCast(*const INetFwProfile, self), openPorts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_Services(self: *const T, services: ?*?*INetFwServices) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_Services(@ptrCast(*const INetFwProfile, self), services);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProfile_get_AuthorizedApplications(self: *const T, apps: ?*?*INetFwAuthorizedApplications) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProfile.VTable, self.vtable).get_AuthorizedApplications(@ptrCast(*const INetFwProfile, self), apps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwPolicy_Value = @import("../zig.zig").Guid.initString("d46d2478-9ac9-4008-9dc7-5563ce5536cc");
pub const IID_INetFwPolicy = &IID_INetFwPolicy_Value;
pub const INetFwPolicy = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProfile: fn(
            self: *const INetFwPolicy,
            profile: ?*?*INetFwProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProfileByType: fn(
            self: *const INetFwPolicy,
            profileType: NET_FW_PROFILE_TYPE,
            profile: ?*?*INetFwProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy_get_CurrentProfile(self: *const T, profile: ?*?*INetFwProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy.VTable, self.vtable).get_CurrentProfile(@ptrCast(*const INetFwPolicy, self), profile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy_GetProfileByType(self: *const T, profileType: NET_FW_PROFILE_TYPE, profile: ?*?*INetFwProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy.VTable, self.vtable).GetProfileByType(@ptrCast(*const INetFwPolicy, self), profileType, profile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwPolicy2_Value = @import("../zig.zig").Guid.initString("98325047-c671-4174-8d81-defcd3f03186");
pub const IID_INetFwPolicy2 = &IID_INetFwPolicy2_Value;
pub const INetFwPolicy2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProfileTypes: fn(
            self: *const INetFwPolicy2,
            profileTypesBitmask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirewallEnabled: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FirewallEnabled: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExcludedInterfaces: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            interfaces: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExcludedInterfaces: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            interfaces: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockAllInboundTraffic: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            Block: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockAllInboundTraffic: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            Block: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotificationsDisabled: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            disabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NotificationsDisabled: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            disabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UnicastResponsesToMulticastBroadcastDisabled: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            disabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UnicastResponsesToMulticastBroadcastDisabled: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            disabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rules: fn(
            self: *const INetFwPolicy2,
            rules: ?*?*INetFwRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ServiceRestriction: fn(
            self: *const INetFwPolicy2,
            ServiceRestriction: ?*?*INetFwServiceRestriction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableRuleGroup: fn(
            self: *const INetFwPolicy2,
            profileTypesBitmask: i32,
            group: ?BSTR,
            enable: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRuleGroupEnabled: fn(
            self: *const INetFwPolicy2,
            profileTypesBitmask: i32,
            group: ?BSTR,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreLocalFirewallDefaults: fn(
            self: *const INetFwPolicy2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultInboundAction: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            action: ?*NET_FW_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultInboundAction: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            action: NET_FW_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultOutboundAction: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            action: ?*NET_FW_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultOutboundAction: fn(
            self: *const INetFwPolicy2,
            profileType: NET_FW_PROFILE_TYPE2,
            action: NET_FW_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRuleGroupCurrentlyEnabled: fn(
            self: *const INetFwPolicy2,
            group: ?BSTR,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalPolicyModifyState: fn(
            self: *const INetFwPolicy2,
            modifyState: ?*NET_FW_MODIFY_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_CurrentProfileTypes(self: *const T, profileTypesBitmask: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_CurrentProfileTypes(@ptrCast(*const INetFwPolicy2, self), profileTypesBitmask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_FirewallEnabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_FirewallEnabled(@ptrCast(*const INetFwPolicy2, self), profileType, enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_put_FirewallEnabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).put_FirewallEnabled(@ptrCast(*const INetFwPolicy2, self), profileType, enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_ExcludedInterfaces(self: *const T, profileType: NET_FW_PROFILE_TYPE2, interfaces: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_ExcludedInterfaces(@ptrCast(*const INetFwPolicy2, self), profileType, interfaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_put_ExcludedInterfaces(self: *const T, profileType: NET_FW_PROFILE_TYPE2, interfaces: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).put_ExcludedInterfaces(@ptrCast(*const INetFwPolicy2, self), profileType, interfaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_BlockAllInboundTraffic(self: *const T, profileType: NET_FW_PROFILE_TYPE2, Block: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_BlockAllInboundTraffic(@ptrCast(*const INetFwPolicy2, self), profileType, Block);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_put_BlockAllInboundTraffic(self: *const T, profileType: NET_FW_PROFILE_TYPE2, Block: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).put_BlockAllInboundTraffic(@ptrCast(*const INetFwPolicy2, self), profileType, Block);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_NotificationsDisabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, disabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_NotificationsDisabled(@ptrCast(*const INetFwPolicy2, self), profileType, disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_put_NotificationsDisabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, disabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).put_NotificationsDisabled(@ptrCast(*const INetFwPolicy2, self), profileType, disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_UnicastResponsesToMulticastBroadcastDisabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, disabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_UnicastResponsesToMulticastBroadcastDisabled(@ptrCast(*const INetFwPolicy2, self), profileType, disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_put_UnicastResponsesToMulticastBroadcastDisabled(self: *const T, profileType: NET_FW_PROFILE_TYPE2, disabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).put_UnicastResponsesToMulticastBroadcastDisabled(@ptrCast(*const INetFwPolicy2, self), profileType, disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_Rules(self: *const T, rules: ?*?*INetFwRules) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_Rules(@ptrCast(*const INetFwPolicy2, self), rules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_ServiceRestriction(self: *const T, ServiceRestriction: ?*?*INetFwServiceRestriction) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_ServiceRestriction(@ptrCast(*const INetFwPolicy2, self), ServiceRestriction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_EnableRuleGroup(self: *const T, profileTypesBitmask: i32, group: ?BSTR, enable: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).EnableRuleGroup(@ptrCast(*const INetFwPolicy2, self), profileTypesBitmask, group, enable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_IsRuleGroupEnabled(self: *const T, profileTypesBitmask: i32, group: ?BSTR, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).IsRuleGroupEnabled(@ptrCast(*const INetFwPolicy2, self), profileTypesBitmask, group, enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_RestoreLocalFirewallDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).RestoreLocalFirewallDefaults(@ptrCast(*const INetFwPolicy2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_DefaultInboundAction(self: *const T, profileType: NET_FW_PROFILE_TYPE2, action: ?*NET_FW_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_DefaultInboundAction(@ptrCast(*const INetFwPolicy2, self), profileType, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_put_DefaultInboundAction(self: *const T, profileType: NET_FW_PROFILE_TYPE2, action: NET_FW_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).put_DefaultInboundAction(@ptrCast(*const INetFwPolicy2, self), profileType, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_DefaultOutboundAction(self: *const T, profileType: NET_FW_PROFILE_TYPE2, action: ?*NET_FW_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_DefaultOutboundAction(@ptrCast(*const INetFwPolicy2, self), profileType, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_put_DefaultOutboundAction(self: *const T, profileType: NET_FW_PROFILE_TYPE2, action: NET_FW_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).put_DefaultOutboundAction(@ptrCast(*const INetFwPolicy2, self), profileType, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_IsRuleGroupCurrentlyEnabled(self: *const T, group: ?BSTR, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_IsRuleGroupCurrentlyEnabled(@ptrCast(*const INetFwPolicy2, self), group, enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwPolicy2_get_LocalPolicyModifyState(self: *const T, modifyState: ?*NET_FW_MODIFY_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwPolicy2.VTable, self.vtable).get_LocalPolicyModifyState(@ptrCast(*const INetFwPolicy2, self), modifyState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetFwMgr_Value = @import("../zig.zig").Guid.initString("f7898af5-cac4-4632-a2ec-da06e5111af2");
pub const IID_INetFwMgr = &IID_INetFwMgr_Value;
pub const INetFwMgr = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalPolicy: fn(
            self: *const INetFwMgr,
            localPolicy: ?*?*INetFwPolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProfileType: fn(
            self: *const INetFwMgr,
            profileType: ?*NET_FW_PROFILE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreDefaults: fn(
            self: *const INetFwMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPortAllowed: fn(
            self: *const INetFwMgr,
            imageFileName: ?BSTR,
            ipVersion: NET_FW_IP_VERSION,
            portNumber: i32,
            localAddress: ?BSTR,
            ipProtocol: NET_FW_IP_PROTOCOL,
            allowed: ?*VARIANT,
            restricted: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIcmpTypeAllowed: fn(
            self: *const INetFwMgr,
            ipVersion: NET_FW_IP_VERSION,
            localAddress: ?BSTR,
            type: u8,
            allowed: ?*VARIANT,
            restricted: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwMgr_get_LocalPolicy(self: *const T, localPolicy: ?*?*INetFwPolicy) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwMgr.VTable, self.vtable).get_LocalPolicy(@ptrCast(*const INetFwMgr, self), localPolicy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwMgr_get_CurrentProfileType(self: *const T, profileType: ?*NET_FW_PROFILE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwMgr.VTable, self.vtable).get_CurrentProfileType(@ptrCast(*const INetFwMgr, self), profileType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwMgr_RestoreDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwMgr.VTable, self.vtable).RestoreDefaults(@ptrCast(*const INetFwMgr, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwMgr_IsPortAllowed(self: *const T, imageFileName: ?BSTR, ipVersion: NET_FW_IP_VERSION, portNumber: i32, localAddress: ?BSTR, ipProtocol: NET_FW_IP_PROTOCOL, allowed: ?*VARIANT, restricted: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwMgr.VTable, self.vtable).IsPortAllowed(@ptrCast(*const INetFwMgr, self), imageFileName, ipVersion, portNumber, localAddress, ipProtocol, allowed, restricted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwMgr_IsIcmpTypeAllowed(self: *const T, ipVersion: NET_FW_IP_VERSION, localAddress: ?BSTR, type_: u8, allowed: ?*VARIANT, restricted: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwMgr.VTable, self.vtable).IsIcmpTypeAllowed(@ptrCast(*const INetFwMgr, self), ipVersion, localAddress, type_, allowed, restricted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_INetFwProduct_Value = @import("../zig.zig").Guid.initString("71881699-18f4-458b-b892-3ffce5e07f75");
pub const IID_INetFwProduct = &IID_INetFwProduct_Value;
pub const INetFwProduct = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RuleCategories: fn(
            self: *const INetFwProduct,
            ruleCategories: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RuleCategories: fn(
            self: *const INetFwProduct,
            ruleCategories: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: fn(
            self: *const INetFwProduct,
            displayName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplayName: fn(
            self: *const INetFwProduct,
            displayName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PathToSignedProductExe: fn(
            self: *const INetFwProduct,
            path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProduct_get_RuleCategories(self: *const T, ruleCategories: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProduct.VTable, self.vtable).get_RuleCategories(@ptrCast(*const INetFwProduct, self), ruleCategories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProduct_put_RuleCategories(self: *const T, ruleCategories: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProduct.VTable, self.vtable).put_RuleCategories(@ptrCast(*const INetFwProduct, self), ruleCategories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProduct_get_DisplayName(self: *const T, displayName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProduct.VTable, self.vtable).get_DisplayName(@ptrCast(*const INetFwProduct, self), displayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProduct_put_DisplayName(self: *const T, displayName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProduct.VTable, self.vtable).put_DisplayName(@ptrCast(*const INetFwProduct, self), displayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProduct_get_PathToSignedProductExe(self: *const T, path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProduct.VTable, self.vtable).get_PathToSignedProductExe(@ptrCast(*const INetFwProduct, self), path);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_INetFwProducts_Value = @import("../zig.zig").Guid.initString("39eb36e0-2097-40bd-8af2-63a13b525362");
pub const IID_INetFwProducts = &IID_INetFwProducts_Value;
pub const INetFwProducts = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const INetFwProducts,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Register: fn(
            self: *const INetFwProducts,
            product: ?*INetFwProduct,
            registration: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const INetFwProducts,
            index: i32,
            product: ?*?*INetFwProduct,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const INetFwProducts,
            newEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProducts_get_Count(self: *const T, count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProducts.VTable, self.vtable).get_Count(@ptrCast(*const INetFwProducts, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProducts_Register(self: *const T, product: ?*INetFwProduct, registration: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProducts.VTable, self.vtable).Register(@ptrCast(*const INetFwProducts, self), product, registration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProducts_Item(self: *const T, index: i32, product: ?*?*INetFwProduct) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProducts.VTable, self.vtable).Item(@ptrCast(*const INetFwProducts, self), index, product);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetFwProducts_get__NewEnum(self: *const T, newEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetFwProducts.VTable, self.vtable).get__NewEnum(@ptrCast(*const INetFwProducts, self), newEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (8)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationSetupAppContainerBinaries(
    applicationContainerSid: ?PSID,
    packageFullName: ?[*:0]const u16,
    packageFolder: ?[*:0]const u16,
    displayName: ?[*:0]const u16,
    bBinariesFullyComputed: BOOL,
    binaries: [*]?PWSTR,
    binariesCount: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationRegisterForAppContainerChanges(
    flags: u32,
    callback: ?PAC_CHANGES_CALLBACK_FN,
    context: ?*anyopaque,
    registrationObject: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationUnregisterForAppContainerChanges(
    registrationObject: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationFreeAppContainers(
    pPublicAppCs: ?*INET_FIREWALL_APP_CONTAINER,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationEnumAppContainers(
    Flags: u32,
    pdwNumPublicAppCs: ?*u32,
    ppPublicAppCs: ?*?*INET_FIREWALL_APP_CONTAINER,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationGetAppContainerConfig(
    pdwNumPublicAppCs: ?*u32,
    appContainerSids: ?*?*SID_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationSetAppContainerConfig(
    dwNumPublicAppCs: u32,
    appContainerSids: [*]SID_AND_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-net-isolation-l1-1-0" fn NetworkIsolationDiagnoseConnectFailureAndGetInfo(
    wszServerName: ?[*:0]const u16,
    netIsoError: ?*NETISO_ERROR_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (13)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const PSID = @import("../foundation.zig").PSID;
const PWSTR = @import("../foundation.zig").PWSTR;
const SID = @import("../security.zig").SID;
const SID_AND_ATTRIBUTES = @import("../security.zig").SID_AND_ATTRIBUTES;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PAC_CHANGES_CALLBACK_FN")) { _ = PAC_CHANGES_CALLBACK_FN; }
    if (@hasDecl(@This(), "PNETISO_EDP_ID_CALLBACK_FN")) { _ = PNETISO_EDP_ID_CALLBACK_FN; }
    if (@hasDecl(@This(), "PFN_FWADDDYNAMICKEYWORDADDRESS0")) { _ = PFN_FWADDDYNAMICKEYWORDADDRESS0; }
    if (@hasDecl(@This(), "PFN_FWDELETEDYNAMICKEYWORDADDRESS0")) { _ = PFN_FWDELETEDYNAMICKEYWORDADDRESS0; }
    if (@hasDecl(@This(), "PFN_FWENUMDYNAMICKEYWORDADDRESSESBYTYPE0")) { _ = PFN_FWENUMDYNAMICKEYWORDADDRESSESBYTYPE0; }
    if (@hasDecl(@This(), "PFN_FWENUMDYNAMICKEYWORDADDRESSBYID0")) { _ = PFN_FWENUMDYNAMICKEYWORDADDRESSBYID0; }
    if (@hasDecl(@This(), "PFN_FWFREEDYNAMICKEYWORDADDRESSDATA0")) { _ = PFN_FWFREEDYNAMICKEYWORDADDRESSDATA0; }
    if (@hasDecl(@This(), "PFN_FWUPDATEDYNAMICKEYWORDADDRESS0")) { _ = PFN_FWUPDATEDYNAMICKEYWORDADDRESS0; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
