//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (2)
//--------------------------------------------------------------------------------
pub const NLM_MAX_ADDRESS_LIST_SIZE = @as(u32, 10);
pub const NLM_UNKNOWN_DATAPLAN_STATUS = @as(u32, 4294967295);

//--------------------------------------------------------------------------------
// Section: Types (26)
//--------------------------------------------------------------------------------
const CLSID_NetworkListManager_Value = @import("../zig.zig").Guid.initString("dcb00c01-570f-4a9b-8d69-199fdba5723b");
pub const CLSID_NetworkListManager = &CLSID_NetworkListManager_Value;

pub const NLM_CONNECTION_COST = enum(i32) {
    UNKNOWN = 0,
    UNRESTRICTED = 1,
    FIXED = 2,
    VARIABLE = 4,
    OVERDATALIMIT = 65536,
    CONGESTED = 131072,
    ROAMING = 262144,
    APPROACHINGDATALIMIT = 524288,
};
pub const NLM_CONNECTION_COST_UNKNOWN = NLM_CONNECTION_COST.UNKNOWN;
pub const NLM_CONNECTION_COST_UNRESTRICTED = NLM_CONNECTION_COST.UNRESTRICTED;
pub const NLM_CONNECTION_COST_FIXED = NLM_CONNECTION_COST.FIXED;
pub const NLM_CONNECTION_COST_VARIABLE = NLM_CONNECTION_COST.VARIABLE;
pub const NLM_CONNECTION_COST_OVERDATALIMIT = NLM_CONNECTION_COST.OVERDATALIMIT;
pub const NLM_CONNECTION_COST_CONGESTED = NLM_CONNECTION_COST.CONGESTED;
pub const NLM_CONNECTION_COST_ROAMING = NLM_CONNECTION_COST.ROAMING;
pub const NLM_CONNECTION_COST_APPROACHINGDATALIMIT = NLM_CONNECTION_COST.APPROACHINGDATALIMIT;

pub const NLM_USAGE_DATA = extern struct {
    UsageInMegabytes: u32,
    LastSyncTime: FILETIME,
};

pub const NLM_DATAPLAN_STATUS = extern struct {
    InterfaceGuid: Guid,
    UsageData: NLM_USAGE_DATA,
    DataLimitInMegabytes: u32,
    InboundBandwidthInKbps: u32,
    OutboundBandwidthInKbps: u32,
    NextBillingCycle: FILETIME,
    MaxTransferSizeInMegabytes: u32,
    Reserved: u32,
};

pub const NLM_SOCKADDR = extern struct {
    data: [128]u8,
};

pub const NLM_NETWORK_CLASS = enum(i32) {
    IDENTIFYING = 1,
    IDENTIFIED = 2,
    UNIDENTIFIED = 3,
};
pub const NLM_NETWORK_IDENTIFYING = NLM_NETWORK_CLASS.IDENTIFYING;
pub const NLM_NETWORK_IDENTIFIED = NLM_NETWORK_CLASS.IDENTIFIED;
pub const NLM_NETWORK_UNIDENTIFIED = NLM_NETWORK_CLASS.UNIDENTIFIED;

pub const NLM_SIMULATED_PROFILE_INFO = extern struct {
    ProfileName: [256]u16,
    cost: NLM_CONNECTION_COST,
    UsageInMegabytes: u32,
    DataLimitInMegabytes: u32,
};

pub const NLM_INTERNET_CONNECTIVITY = enum(i32) {
    WEBHIJACK = 1,
    PROXIED = 2,
    CORPORATE = 4,
};
pub const NLM_INTERNET_CONNECTIVITY_WEBHIJACK = NLM_INTERNET_CONNECTIVITY.WEBHIJACK;
pub const NLM_INTERNET_CONNECTIVITY_PROXIED = NLM_INTERNET_CONNECTIVITY.PROXIED;
pub const NLM_INTERNET_CONNECTIVITY_CORPORATE = NLM_INTERNET_CONNECTIVITY.CORPORATE;

pub const NLM_CONNECTIVITY = enum(i32) {
    DISCONNECTED = 0,
    IPV4_NOTRAFFIC = 1,
    IPV6_NOTRAFFIC = 2,
    IPV4_SUBNET = 16,
    IPV4_LOCALNETWORK = 32,
    IPV4_INTERNET = 64,
    IPV6_SUBNET = 256,
    IPV6_LOCALNETWORK = 512,
    IPV6_INTERNET = 1024,
};
pub const NLM_CONNECTIVITY_DISCONNECTED = NLM_CONNECTIVITY.DISCONNECTED;
pub const NLM_CONNECTIVITY_IPV4_NOTRAFFIC = NLM_CONNECTIVITY.IPV4_NOTRAFFIC;
pub const NLM_CONNECTIVITY_IPV6_NOTRAFFIC = NLM_CONNECTIVITY.IPV6_NOTRAFFIC;
pub const NLM_CONNECTIVITY_IPV4_SUBNET = NLM_CONNECTIVITY.IPV4_SUBNET;
pub const NLM_CONNECTIVITY_IPV4_LOCALNETWORK = NLM_CONNECTIVITY.IPV4_LOCALNETWORK;
pub const NLM_CONNECTIVITY_IPV4_INTERNET = NLM_CONNECTIVITY.IPV4_INTERNET;
pub const NLM_CONNECTIVITY_IPV6_SUBNET = NLM_CONNECTIVITY.IPV6_SUBNET;
pub const NLM_CONNECTIVITY_IPV6_LOCALNETWORK = NLM_CONNECTIVITY.IPV6_LOCALNETWORK;
pub const NLM_CONNECTIVITY_IPV6_INTERNET = NLM_CONNECTIVITY.IPV6_INTERNET;

pub const NLM_DOMAIN_TYPE = enum(i32) {
    NON_DOMAIN_NETWORK = 0,
    DOMAIN_NETWORK = 1,
    DOMAIN_AUTHENTICATED = 2,
};
pub const NLM_DOMAIN_TYPE_NON_DOMAIN_NETWORK = NLM_DOMAIN_TYPE.NON_DOMAIN_NETWORK;
pub const NLM_DOMAIN_TYPE_DOMAIN_NETWORK = NLM_DOMAIN_TYPE.DOMAIN_NETWORK;
pub const NLM_DOMAIN_TYPE_DOMAIN_AUTHENTICATED = NLM_DOMAIN_TYPE.DOMAIN_AUTHENTICATED;

pub const NLM_ENUM_NETWORK = enum(i32) {
    CONNECTED = 1,
    DISCONNECTED = 2,
    ALL = 3,
};
pub const NLM_ENUM_NETWORK_CONNECTED = NLM_ENUM_NETWORK.CONNECTED;
pub const NLM_ENUM_NETWORK_DISCONNECTED = NLM_ENUM_NETWORK.DISCONNECTED;
pub const NLM_ENUM_NETWORK_ALL = NLM_ENUM_NETWORK.ALL;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkListManager_Value = @import("../zig.zig").Guid.initString("dcb00000-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkListManager = &IID_INetworkListManager_Value;
pub const INetworkListManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetNetworks: fn(
            self: *const INetworkListManager,
            Flags: NLM_ENUM_NETWORK,
            ppEnumNetwork: ?*?*IEnumNetworks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetwork: fn(
            self: *const INetworkListManager,
            gdNetworkId: Guid,
            ppNetwork: ?*?*INetwork,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkConnections: fn(
            self: *const INetworkListManager,
            ppEnum: ?*?*IEnumNetworkConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkConnection: fn(
            self: *const INetworkListManager,
            gdNetworkConnectionId: Guid,
            ppNetworkConnection: ?*?*INetworkConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnectedToInternet: fn(
            self: *const INetworkListManager,
            pbIsConnected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnected: fn(
            self: *const INetworkListManager,
            pbIsConnected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectivity: fn(
            self: *const INetworkListManager,
            pConnectivity: ?*NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSimulatedProfileInfo: fn(
            self: *const INetworkListManager,
            pSimulatedInfo: ?*NLM_SIMULATED_PROFILE_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearSimulatedProfileInfo: fn(
            self: *const INetworkListManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManager_GetNetworks(self: *const T, Flags: NLM_ENUM_NETWORK, ppEnumNetwork: ?*?*IEnumNetworks) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManager.VTable, self.vtable).GetNetworks(@ptrCast(*const INetworkListManager, self), Flags, ppEnumNetwork);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManager_GetNetwork(self: *const T, gdNetworkId: Guid, ppNetwork: ?*?*INetwork) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManager.VTable, self.vtable).GetNetwork(@ptrCast(*const INetworkListManager, self), gdNetworkId, ppNetwork);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManager_GetNetworkConnections(self: *const T, ppEnum: ?*?*IEnumNetworkConnections) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManager.VTable, self.vtable).GetNetworkConnections(@ptrCast(*const INetworkListManager, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManager_GetNetworkConnection(self: *const T, gdNetworkConnectionId: Guid, ppNetworkConnection: ?*?*INetworkConnection) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManager.VTable, self.vtable).GetNetworkConnection(@ptrCast(*const INetworkListManager, self), gdNetworkConnectionId, ppNetworkConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManager_get_IsConnectedToInternet(self: *const T, pbIsConnected: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManager.VTable, self.vtable).get_IsConnectedToInternet(@ptrCast(*const INetworkListManager, self), pbIsConnected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManager_get_IsConnected(self: *const T, pbIsConnected: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManager.VTable, self.vtable).get_IsConnected(@ptrCast(*const INetworkListManager, self), pbIsConnected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManager_GetConnectivity(self: *const T, pConnectivity: ?*NLM_CONNECTIVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManager.VTable, self.vtable).GetConnectivity(@ptrCast(*const INetworkListManager, self), pConnectivity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManager_SetSimulatedProfileInfo(self: *const T, pSimulatedInfo: ?*NLM_SIMULATED_PROFILE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManager.VTable, self.vtable).SetSimulatedProfileInfo(@ptrCast(*const INetworkListManager, self), pSimulatedInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManager_ClearSimulatedProfileInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManager.VTable, self.vtable).ClearSimulatedProfileInfo(@ptrCast(*const INetworkListManager, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkListManagerEvents_Value = @import("../zig.zig").Guid.initString("dcb00001-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkListManagerEvents = &IID_INetworkListManagerEvents_Value;
pub const INetworkListManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConnectivityChanged: fn(
            self: *const INetworkListManagerEvents,
            newConnectivity: NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkListManagerEvents_ConnectivityChanged(self: *const T, newConnectivity: NLM_CONNECTIVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkListManagerEvents.VTable, self.vtable).ConnectivityChanged(@ptrCast(*const INetworkListManagerEvents, self), newConnectivity);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NLM_NETWORK_CATEGORY = enum(i32) {
    PUBLIC = 0,
    PRIVATE = 1,
    DOMAIN_AUTHENTICATED = 2,
};
pub const NLM_NETWORK_CATEGORY_PUBLIC = NLM_NETWORK_CATEGORY.PUBLIC;
pub const NLM_NETWORK_CATEGORY_PRIVATE = NLM_NETWORK_CATEGORY.PRIVATE;
pub const NLM_NETWORK_CATEGORY_DOMAIN_AUTHENTICATED = NLM_NETWORK_CATEGORY.DOMAIN_AUTHENTICATED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetwork_Value = @import("../zig.zig").Guid.initString("dcb00002-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetwork = &IID_INetwork_Value;
pub const INetwork = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetName: fn(
            self: *const INetwork,
            pszNetworkName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetName: fn(
            self: *const INetwork,
            szNetworkNewName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const INetwork,
            pszDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescription: fn(
            self: *const INetwork,
            szDescription: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkId: fn(
            self: *const INetwork,
            pgdGuidNetworkId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDomainType: fn(
            self: *const INetwork,
            pNetworkType: ?*NLM_DOMAIN_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkConnections: fn(
            self: *const INetwork,
            ppEnumNetworkConnection: ?*?*IEnumNetworkConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeCreatedAndConnected: fn(
            self: *const INetwork,
            pdwLowDateTimeCreated: ?*u32,
            pdwHighDateTimeCreated: ?*u32,
            pdwLowDateTimeConnected: ?*u32,
            pdwHighDateTimeConnected: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnectedToInternet: fn(
            self: *const INetwork,
            pbIsConnected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnected: fn(
            self: *const INetwork,
            pbIsConnected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectivity: fn(
            self: *const INetwork,
            pConnectivity: ?*NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategory: fn(
            self: *const INetwork,
            pCategory: ?*NLM_NETWORK_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCategory: fn(
            self: *const INetwork,
            NewCategory: NLM_NETWORK_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_GetName(self: *const T, pszNetworkName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).GetName(@ptrCast(*const INetwork, self), pszNetworkName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_SetName(self: *const T, szNetworkNewName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).SetName(@ptrCast(*const INetwork, self), szNetworkNewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_GetDescription(self: *const T, pszDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).GetDescription(@ptrCast(*const INetwork, self), pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_SetDescription(self: *const T, szDescription: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).SetDescription(@ptrCast(*const INetwork, self), szDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_GetNetworkId(self: *const T, pgdGuidNetworkId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).GetNetworkId(@ptrCast(*const INetwork, self), pgdGuidNetworkId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_GetDomainType(self: *const T, pNetworkType: ?*NLM_DOMAIN_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).GetDomainType(@ptrCast(*const INetwork, self), pNetworkType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_GetNetworkConnections(self: *const T, ppEnumNetworkConnection: ?*?*IEnumNetworkConnections) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).GetNetworkConnections(@ptrCast(*const INetwork, self), ppEnumNetworkConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_GetTimeCreatedAndConnected(self: *const T, pdwLowDateTimeCreated: ?*u32, pdwHighDateTimeCreated: ?*u32, pdwLowDateTimeConnected: ?*u32, pdwHighDateTimeConnected: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).GetTimeCreatedAndConnected(@ptrCast(*const INetwork, self), pdwLowDateTimeCreated, pdwHighDateTimeCreated, pdwLowDateTimeConnected, pdwHighDateTimeConnected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_get_IsConnectedToInternet(self: *const T, pbIsConnected: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).get_IsConnectedToInternet(@ptrCast(*const INetwork, self), pbIsConnected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_get_IsConnected(self: *const T, pbIsConnected: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).get_IsConnected(@ptrCast(*const INetwork, self), pbIsConnected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_GetConnectivity(self: *const T, pConnectivity: ?*NLM_CONNECTIVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).GetConnectivity(@ptrCast(*const INetwork, self), pConnectivity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_GetCategory(self: *const T, pCategory: ?*NLM_NETWORK_CATEGORY) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).GetCategory(@ptrCast(*const INetwork, self), pCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetwork_SetCategory(self: *const T, NewCategory: NLM_NETWORK_CATEGORY) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetwork.VTable, self.vtable).SetCategory(@ptrCast(*const INetwork, self), NewCategory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumNetworks_Value = @import("../zig.zig").Guid.initString("dcb00003-570f-4a9b-8d69-199fdba5723b");
pub const IID_IEnumNetworks = &IID_IEnumNetworks_Value;
pub const IEnumNetworks = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IEnumNetworks,
            ppEnumVar: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumNetworks,
            celt: u32,
            rgelt: [*]?*INetwork,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumNetworks,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumNetworks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumNetworks,
            ppEnumNetwork: ?*?*IEnumNetworks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworks_get__NewEnum(self: *const T, ppEnumVar: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworks.VTable, self.vtable).get__NewEnum(@ptrCast(*const IEnumNetworks, self), ppEnumVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworks_Next(self: *const T, celt: u32, rgelt: [*]?*INetwork, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworks.VTable, self.vtable).Next(@ptrCast(*const IEnumNetworks, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworks_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworks.VTable, self.vtable).Skip(@ptrCast(*const IEnumNetworks, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworks_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworks.VTable, self.vtable).Reset(@ptrCast(*const IEnumNetworks, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworks_Clone(self: *const T, ppEnumNetwork: ?*?*IEnumNetworks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworks.VTable, self.vtable).Clone(@ptrCast(*const IEnumNetworks, self), ppEnumNetwork);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NLM_NETWORK_PROPERTY_CHANGE = enum(i32) {
    CONNECTION = 1,
    DESCRIPTION = 2,
    NAME = 4,
    ICON = 8,
    CATEGORY_VALUE = 16,
};
pub const NLM_NETWORK_PROPERTY_CHANGE_CONNECTION = NLM_NETWORK_PROPERTY_CHANGE.CONNECTION;
pub const NLM_NETWORK_PROPERTY_CHANGE_DESCRIPTION = NLM_NETWORK_PROPERTY_CHANGE.DESCRIPTION;
pub const NLM_NETWORK_PROPERTY_CHANGE_NAME = NLM_NETWORK_PROPERTY_CHANGE.NAME;
pub const NLM_NETWORK_PROPERTY_CHANGE_ICON = NLM_NETWORK_PROPERTY_CHANGE.ICON;
pub const NLM_NETWORK_PROPERTY_CHANGE_CATEGORY_VALUE = NLM_NETWORK_PROPERTY_CHANGE.CATEGORY_VALUE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkEvents_Value = @import("../zig.zig").Guid.initString("dcb00004-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkEvents = &IID_INetworkEvents_Value;
pub const INetworkEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NetworkAdded: fn(
            self: *const INetworkEvents,
            networkId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NetworkDeleted: fn(
            self: *const INetworkEvents,
            networkId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NetworkConnectivityChanged: fn(
            self: *const INetworkEvents,
            networkId: Guid,
            newConnectivity: NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NetworkPropertyChanged: fn(
            self: *const INetworkEvents,
            networkId: Guid,
            flags: NLM_NETWORK_PROPERTY_CHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkEvents_NetworkAdded(self: *const T, networkId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkEvents.VTable, self.vtable).NetworkAdded(@ptrCast(*const INetworkEvents, self), networkId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkEvents_NetworkDeleted(self: *const T, networkId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkEvents.VTable, self.vtable).NetworkDeleted(@ptrCast(*const INetworkEvents, self), networkId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkEvents_NetworkConnectivityChanged(self: *const T, networkId: Guid, newConnectivity: NLM_CONNECTIVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkEvents.VTable, self.vtable).NetworkConnectivityChanged(@ptrCast(*const INetworkEvents, self), networkId, newConnectivity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkEvents_NetworkPropertyChanged(self: *const T, networkId: Guid, flags: NLM_NETWORK_PROPERTY_CHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkEvents.VTable, self.vtable).NetworkPropertyChanged(@ptrCast(*const INetworkEvents, self), networkId, flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkConnection_Value = @import("../zig.zig").Guid.initString("dcb00005-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkConnection = &IID_INetworkConnection_Value;
pub const INetworkConnection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetNetwork: fn(
            self: *const INetworkConnection,
            ppNetwork: ?*?*INetwork,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnectedToInternet: fn(
            self: *const INetworkConnection,
            pbIsConnected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsConnected: fn(
            self: *const INetworkConnection,
            pbIsConnected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectivity: fn(
            self: *const INetworkConnection,
            pConnectivity: ?*NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectionId: fn(
            self: *const INetworkConnection,
            pgdConnectionId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterId: fn(
            self: *const INetworkConnection,
            pgdAdapterId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDomainType: fn(
            self: *const INetworkConnection,
            pDomainType: ?*NLM_DOMAIN_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnection_GetNetwork(self: *const T, ppNetwork: ?*?*INetwork) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnection.VTable, self.vtable).GetNetwork(@ptrCast(*const INetworkConnection, self), ppNetwork);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnection_get_IsConnectedToInternet(self: *const T, pbIsConnected: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnection.VTable, self.vtable).get_IsConnectedToInternet(@ptrCast(*const INetworkConnection, self), pbIsConnected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnection_get_IsConnected(self: *const T, pbIsConnected: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnection.VTable, self.vtable).get_IsConnected(@ptrCast(*const INetworkConnection, self), pbIsConnected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnection_GetConnectivity(self: *const T, pConnectivity: ?*NLM_CONNECTIVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnection.VTable, self.vtable).GetConnectivity(@ptrCast(*const INetworkConnection, self), pConnectivity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnection_GetConnectionId(self: *const T, pgdConnectionId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnection.VTable, self.vtable).GetConnectionId(@ptrCast(*const INetworkConnection, self), pgdConnectionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnection_GetAdapterId(self: *const T, pgdAdapterId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnection.VTable, self.vtable).GetAdapterId(@ptrCast(*const INetworkConnection, self), pgdAdapterId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnection_GetDomainType(self: *const T, pDomainType: ?*NLM_DOMAIN_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnection.VTable, self.vtable).GetDomainType(@ptrCast(*const INetworkConnection, self), pDomainType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumNetworkConnections_Value = @import("../zig.zig").Guid.initString("dcb00006-570f-4a9b-8d69-199fdba5723b");
pub const IID_IEnumNetworkConnections = &IID_IEnumNetworkConnections_Value;
pub const IEnumNetworkConnections = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IEnumNetworkConnections,
            ppEnumVar: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumNetworkConnections,
            celt: u32,
            rgelt: [*]?*INetworkConnection,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumNetworkConnections,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumNetworkConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumNetworkConnections,
            ppEnumNetwork: ?*?*IEnumNetworkConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworkConnections_get__NewEnum(self: *const T, ppEnumVar: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworkConnections.VTable, self.vtable).get__NewEnum(@ptrCast(*const IEnumNetworkConnections, self), ppEnumVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworkConnections_Next(self: *const T, celt: u32, rgelt: [*]?*INetworkConnection, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworkConnections.VTable, self.vtable).Next(@ptrCast(*const IEnumNetworkConnections, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworkConnections_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworkConnections.VTable, self.vtable).Skip(@ptrCast(*const IEnumNetworkConnections, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworkConnections_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworkConnections.VTable, self.vtable).Reset(@ptrCast(*const IEnumNetworkConnections, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumNetworkConnections_Clone(self: *const T, ppEnumNetwork: ?*?*IEnumNetworkConnections) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumNetworkConnections.VTable, self.vtable).Clone(@ptrCast(*const IEnumNetworkConnections, self), ppEnumNetwork);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NLM_CONNECTION_PROPERTY_CHANGE = enum(i32) {
    N = 1,
};
pub const NLM_CONNECTION_PROPERTY_CHANGE_AUTHENTICATION = NLM_CONNECTION_PROPERTY_CHANGE.N;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkConnectionEvents_Value = @import("../zig.zig").Guid.initString("dcb00007-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkConnectionEvents = &IID_INetworkConnectionEvents_Value;
pub const INetworkConnectionEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NetworkConnectionConnectivityChanged: fn(
            self: *const INetworkConnectionEvents,
            connectionId: Guid,
            newConnectivity: NLM_CONNECTIVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NetworkConnectionPropertyChanged: fn(
            self: *const INetworkConnectionEvents,
            connectionId: Guid,
            flags: NLM_CONNECTION_PROPERTY_CHANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnectionEvents_NetworkConnectionConnectivityChanged(self: *const T, connectionId: Guid, newConnectivity: NLM_CONNECTIVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnectionEvents.VTable, self.vtable).NetworkConnectionConnectivityChanged(@ptrCast(*const INetworkConnectionEvents, self), connectionId, newConnectivity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnectionEvents_NetworkConnectionPropertyChanged(self: *const T, connectionId: Guid, flags: NLM_CONNECTION_PROPERTY_CHANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnectionEvents.VTable, self.vtable).NetworkConnectionPropertyChanged(@ptrCast(*const INetworkConnectionEvents, self), connectionId, flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetworkCostManager_Value = @import("../zig.zig").Guid.initString("dcb00008-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkCostManager = &IID_INetworkCostManager_Value;
pub const INetworkCostManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCost: fn(
            self: *const INetworkCostManager,
            pCost: ?*u32,
            pDestIPAddr: ?*NLM_SOCKADDR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataPlanStatus: fn(
            self: *const INetworkCostManager,
            pDataPlanStatus: ?*NLM_DATAPLAN_STATUS,
            pDestIPAddr: ?*NLM_SOCKADDR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDestinationAddresses: fn(
            self: *const INetworkCostManager,
            length: u32,
            pDestIPAddrList: [*]NLM_SOCKADDR,
            bAppend: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkCostManager_GetCost(self: *const T, pCost: ?*u32, pDestIPAddr: ?*NLM_SOCKADDR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkCostManager.VTable, self.vtable).GetCost(@ptrCast(*const INetworkCostManager, self), pCost, pDestIPAddr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkCostManager_GetDataPlanStatus(self: *const T, pDataPlanStatus: ?*NLM_DATAPLAN_STATUS, pDestIPAddr: ?*NLM_SOCKADDR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkCostManager.VTable, self.vtable).GetDataPlanStatus(@ptrCast(*const INetworkCostManager, self), pDataPlanStatus, pDestIPAddr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkCostManager_SetDestinationAddresses(self: *const T, length: u32, pDestIPAddrList: [*]NLM_SOCKADDR, bAppend: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkCostManager.VTable, self.vtable).SetDestinationAddresses(@ptrCast(*const INetworkCostManager, self), length, pDestIPAddrList, bAppend);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetworkCostManagerEvents_Value = @import("../zig.zig").Guid.initString("dcb00009-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkCostManagerEvents = &IID_INetworkCostManagerEvents_Value;
pub const INetworkCostManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CostChanged: fn(
            self: *const INetworkCostManagerEvents,
            newCost: u32,
            pDestAddr: ?*NLM_SOCKADDR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DataPlanStatusChanged: fn(
            self: *const INetworkCostManagerEvents,
            pDestAddr: ?*NLM_SOCKADDR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkCostManagerEvents_CostChanged(self: *const T, newCost: u32, pDestAddr: ?*NLM_SOCKADDR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkCostManagerEvents.VTable, self.vtable).CostChanged(@ptrCast(*const INetworkCostManagerEvents, self), newCost, pDestAddr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkCostManagerEvents_DataPlanStatusChanged(self: *const T, pDestAddr: ?*NLM_SOCKADDR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkCostManagerEvents.VTable, self.vtable).DataPlanStatusChanged(@ptrCast(*const INetworkCostManagerEvents, self), pDestAddr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetworkConnectionCost_Value = @import("../zig.zig").Guid.initString("dcb0000a-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkConnectionCost = &IID_INetworkConnectionCost_Value;
pub const INetworkConnectionCost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCost: fn(
            self: *const INetworkConnectionCost,
            pCost: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataPlanStatus: fn(
            self: *const INetworkConnectionCost,
            pDataPlanStatus: ?*NLM_DATAPLAN_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnectionCost_GetCost(self: *const T, pCost: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnectionCost.VTable, self.vtable).GetCost(@ptrCast(*const INetworkConnectionCost, self), pCost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnectionCost_GetDataPlanStatus(self: *const T, pDataPlanStatus: ?*NLM_DATAPLAN_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnectionCost.VTable, self.vtable).GetDataPlanStatus(@ptrCast(*const INetworkConnectionCost, self), pDataPlanStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INetworkConnectionCostEvents_Value = @import("../zig.zig").Guid.initString("dcb0000b-570f-4a9b-8d69-199fdba5723b");
pub const IID_INetworkConnectionCostEvents = &IID_INetworkConnectionCostEvents_Value;
pub const INetworkConnectionCostEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConnectionCostChanged: fn(
            self: *const INetworkConnectionCostEvents,
            connectionId: Guid,
            newCost: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectionDataPlanStatusChanged: fn(
            self: *const INetworkConnectionCostEvents,
            connectionId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnectionCostEvents_ConnectionCostChanged(self: *const T, connectionId: Guid, newCost: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnectionCostEvents.VTable, self.vtable).ConnectionCostChanged(@ptrCast(*const INetworkConnectionCostEvents, self), connectionId, newCost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkConnectionCostEvents_ConnectionDataPlanStatusChanged(self: *const T, connectionId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkConnectionCostEvents.VTable, self.vtable).ConnectionDataPlanStatusChanged(@ptrCast(*const INetworkConnectionCostEvents, self), connectionId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BSTR = @import("../foundation.zig").BSTR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumVARIANT = @import("../system/ole.zig").IEnumVARIANT;
const IUnknown = @import("../system/com.zig").IUnknown;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
