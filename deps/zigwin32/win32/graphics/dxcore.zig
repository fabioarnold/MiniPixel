//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (4)
//--------------------------------------------------------------------------------
pub const _FACDXCORE = @as(u32, 2176);
pub const DXCORE_ADAPTER_ATTRIBUTE_D3D11_GRAPHICS = Guid.initString("8c47866b-7583-450d-f0f0-6bada895af4b");
pub const DXCORE_ADAPTER_ATTRIBUTE_D3D12_GRAPHICS = Guid.initString("0c9ece4d-2f6e-4f01-8c96-e89e331b47b1");
pub const DXCORE_ADAPTER_ATTRIBUTE_D3D12_CORE_COMPUTE = Guid.initString("248e2800-a793-4724-abaa-23a6de1be090");

//--------------------------------------------------------------------------------
// Section: Types (13)
//--------------------------------------------------------------------------------
pub const DXCoreAdapterProperty = enum(u32) {
    InstanceLuid = 0,
    DriverVersion = 1,
    DriverDescription = 2,
    HardwareID = 3,
    KmdModelVersion = 4,
    ComputePreemptionGranularity = 5,
    GraphicsPreemptionGranularity = 6,
    DedicatedAdapterMemory = 7,
    DedicatedSystemMemory = 8,
    SharedSystemMemory = 9,
    AcgCompatible = 10,
    IsHardware = 11,
    IsIntegrated = 12,
    IsDetachable = 13,
    HardwareIDParts = 14,
};
pub const InstanceLuid = DXCoreAdapterProperty.InstanceLuid;
pub const DriverVersion = DXCoreAdapterProperty.DriverVersion;
pub const DriverDescription = DXCoreAdapterProperty.DriverDescription;
pub const HardwareID = DXCoreAdapterProperty.HardwareID;
pub const KmdModelVersion = DXCoreAdapterProperty.KmdModelVersion;
pub const ComputePreemptionGranularity = DXCoreAdapterProperty.ComputePreemptionGranularity;
pub const GraphicsPreemptionGranularity = DXCoreAdapterProperty.GraphicsPreemptionGranularity;
pub const DedicatedAdapterMemory = DXCoreAdapterProperty.DedicatedAdapterMemory;
pub const DedicatedSystemMemory = DXCoreAdapterProperty.DedicatedSystemMemory;
pub const SharedSystemMemory = DXCoreAdapterProperty.SharedSystemMemory;
pub const AcgCompatible = DXCoreAdapterProperty.AcgCompatible;
pub const IsHardware = DXCoreAdapterProperty.IsHardware;
pub const IsIntegrated = DXCoreAdapterProperty.IsIntegrated;
pub const IsDetachable = DXCoreAdapterProperty.IsDetachable;
pub const HardwareIDParts = DXCoreAdapterProperty.HardwareIDParts;

pub const DXCoreAdapterState = enum(u32) {
    IsDriverUpdateInProgress = 0,
    AdapterMemoryBudget = 1,
};
pub const IsDriverUpdateInProgress = DXCoreAdapterState.IsDriverUpdateInProgress;
pub const AdapterMemoryBudget = DXCoreAdapterState.AdapterMemoryBudget;

pub const DXCoreSegmentGroup = enum(u32) {
    Local = 0,
    NonLocal = 1,
};
pub const Local = DXCoreSegmentGroup.Local;
pub const NonLocal = DXCoreSegmentGroup.NonLocal;

pub const DXCoreNotificationType = enum(u32) {
    ListStale = 0,
    NoLongerValid = 1,
    BudgetChange = 2,
    HardwareContentProtectionTeardown = 3,
};
pub const AdapterListStale = DXCoreNotificationType.ListStale;
pub const AdapterNoLongerValid = DXCoreNotificationType.NoLongerValid;
pub const AdapterBudgetChange = DXCoreNotificationType.BudgetChange;
pub const AdapterHardwareContentProtectionTeardown = DXCoreNotificationType.HardwareContentProtectionTeardown;

pub const DXCoreAdapterPreference = enum(u32) {
    Hardware = 0,
    MinimumPower = 1,
    HighPerformance = 2,
};
pub const Hardware = DXCoreAdapterPreference.Hardware;
pub const MinimumPower = DXCoreAdapterPreference.MinimumPower;
pub const HighPerformance = DXCoreAdapterPreference.HighPerformance;

pub const DXCoreHardwareID = extern struct {
    vendorID: u32,
    deviceID: u32,
    subSysID: u32,
    revision: u32,
};

pub const DXCoreHardwareIDParts = extern struct {
    vendorID: u32,
    deviceID: u32,
    subSystemID: u32,
    subVendorID: u32,
    revisionID: u32,
};

pub const DXCoreAdapterMemoryBudgetNodeSegmentGroup = extern struct {
    nodeIndex: u32,
    segmentGroup: DXCoreSegmentGroup,
};

pub const DXCoreAdapterMemoryBudget = extern struct {
    budget: u64,
    currentUsage: u64,
    availableForReservation: u64,
    currentReservation: u64,
};

pub const PFN_DXCORE_NOTIFICATION_CALLBACK = fn(
    notificationType: DXCoreNotificationType,
    object: ?*IUnknown,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

const IID_IDXCoreAdapter_Value = @import("../zig.zig").Guid.initString("f0db4c7f-fe5a-42a2-bd62-f2a6cf6fc83e");
pub const IID_IDXCoreAdapter = &IID_IDXCoreAdapter_Value;
pub const IDXCoreAdapter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsValid: fn(
            self: *const IDXCoreAdapter,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        IsAttributeSupported: fn(
            self: *const IDXCoreAdapter,
            attributeGUID: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        IsPropertySupported: fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterProperty,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        GetProperty: fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterProperty,
            bufferSize: usize,
            // TODO: what to do with BytesParamIndex 1?
            propertyData: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertySize: fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterProperty,
            bufferSize: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsQueryStateSupported: fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterState,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        QueryState: fn(
            self: *const IDXCoreAdapter,
            state: DXCoreAdapterState,
            inputStateDetailsSize: usize,
            // TODO: what to do with BytesParamIndex 1?
            inputStateDetails: ?*const anyopaque,
            outputBufferSize: usize,
            // TODO: what to do with BytesParamIndex 3?
            outputBuffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSetStateSupported: fn(
            self: *const IDXCoreAdapter,
            property: DXCoreAdapterState,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        SetState: fn(
            self: *const IDXCoreAdapter,
            state: DXCoreAdapterState,
            inputStateDetailsSize: usize,
            // TODO: what to do with BytesParamIndex 1?
            inputStateDetails: ?*const anyopaque,
            inputDataSize: usize,
            // TODO: what to do with BytesParamIndex 3?
            inputData: ?*const anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFactory: fn(
            self: *const IDXCoreAdapter,
            riid: ?*const Guid,
            ppvFactory: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_IsValid(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).IsValid(@ptrCast(*const IDXCoreAdapter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_IsAttributeSupported(self: *const T, attributeGUID: ?*const Guid) callconv(.Inline) bool {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).IsAttributeSupported(@ptrCast(*const IDXCoreAdapter, self), attributeGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_IsPropertySupported(self: *const T, property: DXCoreAdapterProperty) callconv(.Inline) bool {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).IsPropertySupported(@ptrCast(*const IDXCoreAdapter, self), property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_GetProperty(self: *const T, property: DXCoreAdapterProperty, bufferSize: usize, propertyData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).GetProperty(@ptrCast(*const IDXCoreAdapter, self), property, bufferSize, propertyData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_GetPropertySize(self: *const T, property: DXCoreAdapterProperty, bufferSize: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).GetPropertySize(@ptrCast(*const IDXCoreAdapter, self), property, bufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_IsQueryStateSupported(self: *const T, property: DXCoreAdapterState) callconv(.Inline) bool {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).IsQueryStateSupported(@ptrCast(*const IDXCoreAdapter, self), property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_QueryState(self: *const T, state: DXCoreAdapterState, inputStateDetailsSize: usize, inputStateDetails: ?*const anyopaque, outputBufferSize: usize, outputBuffer: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).QueryState(@ptrCast(*const IDXCoreAdapter, self), state, inputStateDetailsSize, inputStateDetails, outputBufferSize, outputBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_IsSetStateSupported(self: *const T, property: DXCoreAdapterState) callconv(.Inline) bool {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).IsSetStateSupported(@ptrCast(*const IDXCoreAdapter, self), property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_SetState(self: *const T, state: DXCoreAdapterState, inputStateDetailsSize: usize, inputStateDetails: ?*const anyopaque, inputDataSize: usize, inputData: ?*const anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).SetState(@ptrCast(*const IDXCoreAdapter, self), state, inputStateDetailsSize, inputStateDetails, inputDataSize, inputData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapter_GetFactory(self: *const T, riid: ?*const Guid, ppvFactory: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapter.VTable, self.vtable).GetFactory(@ptrCast(*const IDXCoreAdapter, self), riid, ppvFactory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXCoreAdapterList_Value = @import("../zig.zig").Guid.initString("526c7776-40e9-459b-b711-f32ad76dfc28");
pub const IID_IDXCoreAdapterList = &IID_IDXCoreAdapterList_Value;
pub const IDXCoreAdapterList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAdapter: fn(
            self: *const IDXCoreAdapterList,
            index: u32,
            riid: ?*const Guid,
            ppvAdapter: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterCount: fn(
            self: *const IDXCoreAdapterList,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        IsStale: fn(
            self: *const IDXCoreAdapterList,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        GetFactory: fn(
            self: *const IDXCoreAdapterList,
            riid: ?*const Guid,
            ppvFactory: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Sort: fn(
            self: *const IDXCoreAdapterList,
            numPreferences: u32,
            preferences: [*]const DXCoreAdapterPreference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAdapterPreferenceSupported: fn(
            self: *const IDXCoreAdapterList,
            preference: DXCoreAdapterPreference,
        ) callconv(@import("std").os.windows.WINAPI) bool,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterList_GetAdapter(self: *const T, index: u32, riid: ?*const Guid, ppvAdapter: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapterList.VTable, self.vtable).GetAdapter(@ptrCast(*const IDXCoreAdapterList, self), index, riid, ppvAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterList_GetAdapterCount(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IDXCoreAdapterList.VTable, self.vtable).GetAdapterCount(@ptrCast(*const IDXCoreAdapterList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterList_IsStale(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IDXCoreAdapterList.VTable, self.vtable).IsStale(@ptrCast(*const IDXCoreAdapterList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterList_GetFactory(self: *const T, riid: ?*const Guid, ppvFactory: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapterList.VTable, self.vtable).GetFactory(@ptrCast(*const IDXCoreAdapterList, self), riid, ppvFactory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterList_Sort(self: *const T, numPreferences: u32, preferences: [*]const DXCoreAdapterPreference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapterList.VTable, self.vtable).Sort(@ptrCast(*const IDXCoreAdapterList, self), numPreferences, preferences);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterList_IsAdapterPreferenceSupported(self: *const T, preference: DXCoreAdapterPreference) callconv(.Inline) bool {
            return @ptrCast(*const IDXCoreAdapterList.VTable, self.vtable).IsAdapterPreferenceSupported(@ptrCast(*const IDXCoreAdapterList, self), preference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXCoreAdapterFactory_Value = @import("../zig.zig").Guid.initString("78ee5945-c36e-4b13-a669-005dd11c0f06");
pub const IID_IDXCoreAdapterFactory = &IID_IDXCoreAdapterFactory_Value;
pub const IDXCoreAdapterFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateAdapterList: fn(
            self: *const IDXCoreAdapterFactory,
            numAttributes: u32,
            filterAttributes: [*]const Guid,
            riid: ?*const Guid,
            ppvAdapterList: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterByLuid: fn(
            self: *const IDXCoreAdapterFactory,
            adapterLUID: ?*const LUID,
            riid: ?*const Guid,
            ppvAdapter: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsNotificationTypeSupported: fn(
            self: *const IDXCoreAdapterFactory,
            notificationType: DXCoreNotificationType,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        RegisterEventNotification: fn(
            self: *const IDXCoreAdapterFactory,
            dxCoreObject: ?*IUnknown,
            notificationType: DXCoreNotificationType,
            callbackFunction: ?PFN_DXCORE_NOTIFICATION_CALLBACK,
            callbackContext: ?*anyopaque,
            eventCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterEventNotification: fn(
            self: *const IDXCoreAdapterFactory,
            eventCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterFactory_CreateAdapterList(self: *const T, numAttributes: u32, filterAttributes: [*]const Guid, riid: ?*const Guid, ppvAdapterList: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapterFactory.VTable, self.vtable).CreateAdapterList(@ptrCast(*const IDXCoreAdapterFactory, self), numAttributes, filterAttributes, riid, ppvAdapterList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterFactory_GetAdapterByLuid(self: *const T, adapterLUID: ?*const LUID, riid: ?*const Guid, ppvAdapter: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapterFactory.VTable, self.vtable).GetAdapterByLuid(@ptrCast(*const IDXCoreAdapterFactory, self), adapterLUID, riid, ppvAdapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterFactory_IsNotificationTypeSupported(self: *const T, notificationType: DXCoreNotificationType) callconv(.Inline) bool {
            return @ptrCast(*const IDXCoreAdapterFactory.VTable, self.vtable).IsNotificationTypeSupported(@ptrCast(*const IDXCoreAdapterFactory, self), notificationType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterFactory_RegisterEventNotification(self: *const T, dxCoreObject: ?*IUnknown, notificationType: DXCoreNotificationType, callbackFunction: ?PFN_DXCORE_NOTIFICATION_CALLBACK, callbackContext: ?*anyopaque, eventCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapterFactory.VTable, self.vtable).RegisterEventNotification(@ptrCast(*const IDXCoreAdapterFactory, self), dxCoreObject, notificationType, callbackFunction, callbackContext, eventCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXCoreAdapterFactory_UnregisterEventNotification(self: *const T, eventCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXCoreAdapterFactory.VTable, self.vtable).UnregisterEventNotification(@ptrCast(*const IDXCoreAdapterFactory, self), eventCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (1)
//--------------------------------------------------------------------------------
pub extern "DXCORE" fn DXCoreCreateAdapterFactory(
    riid: ?*const Guid,
    ppvFactory: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (4)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const HRESULT = @import("../foundation.zig").HRESULT;
const IUnknown = @import("../system/com.zig").IUnknown;
const LUID = @import("../foundation.zig").LUID;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFN_DXCORE_NOTIFICATION_CALLBACK")) { _ = PFN_DXCORE_NOTIFICATION_CALLBACK; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
