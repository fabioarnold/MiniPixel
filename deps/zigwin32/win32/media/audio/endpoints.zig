//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (14)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioEndpointFormatControl_Value = @import("../../zig.zig").Guid.initString("784cfd40-9f89-456e-a1a6-873b006a664e");
pub const IID_IAudioEndpointFormatControl = &IID_IAudioEndpointFormatControl_Value;
pub const IAudioEndpointFormatControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetToDefault: fn(
            self: *const IAudioEndpointFormatControl,
            ResetFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointFormatControl_ResetToDefault(self: *const T, ResetFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointFormatControl.VTable, self.vtable).ResetToDefault(@ptrCast(*const IAudioEndpointFormatControl, self), ResetFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EndpointConnectorType = enum(i32) {
    HostProcessConnector = 0,
    OffloadConnector = 1,
    LoopbackConnector = 2,
    KeywordDetectorConnector = 3,
    ConnectorCount = 4,
};
pub const eHostProcessConnector = EndpointConnectorType.HostProcessConnector;
pub const eOffloadConnector = EndpointConnectorType.OffloadConnector;
pub const eLoopbackConnector = EndpointConnectorType.LoopbackConnector;
pub const eKeywordDetectorConnector = EndpointConnectorType.KeywordDetectorConnector;
pub const eConnectorCount = EndpointConnectorType.ConnectorCount;

pub const AUDIO_ENDPOINT_SHARED_CREATE_PARAMS = extern struct {
    u32Size: u32,
    u32TSSessionId: u32,
    targetEndpointConnectorType: EndpointConnectorType,
    wfxDeviceFormat: WAVEFORMATEX,
};

const IID_IAudioEndpointOffloadStreamVolume_Value = @import("../../zig.zig").Guid.initString("64f1dd49-71ca-4281-8672-3a9eddd1d0b6");
pub const IID_IAudioEndpointOffloadStreamVolume = &IID_IAudioEndpointOffloadStreamVolume_Value;
pub const IAudioEndpointOffloadStreamVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVolumeChannelCount: fn(
            self: *const IAudioEndpointOffloadStreamVolume,
            pu32ChannelCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolumes: fn(
            self: *const IAudioEndpointOffloadStreamVolume,
            u32ChannelCount: u32,
            pf32Volumes: ?*f32,
            u32CurveType: AUDIO_CURVE_TYPE,
            pCurveDuration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolumes: fn(
            self: *const IAudioEndpointOffloadStreamVolume,
            u32ChannelCount: u32,
            pf32Volumes: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamVolume_GetVolumeChannelCount(self: *const T, pu32ChannelCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointOffloadStreamVolume.VTable, self.vtable).GetVolumeChannelCount(@ptrCast(*const IAudioEndpointOffloadStreamVolume, self), pu32ChannelCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamVolume_SetChannelVolumes(self: *const T, u32ChannelCount: u32, pf32Volumes: ?*f32, u32CurveType: AUDIO_CURVE_TYPE, pCurveDuration: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointOffloadStreamVolume.VTable, self.vtable).SetChannelVolumes(@ptrCast(*const IAudioEndpointOffloadStreamVolume, self), u32ChannelCount, pf32Volumes, u32CurveType, pCurveDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamVolume_GetChannelVolumes(self: *const T, u32ChannelCount: u32, pf32Volumes: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointOffloadStreamVolume.VTable, self.vtable).GetChannelVolumes(@ptrCast(*const IAudioEndpointOffloadStreamVolume, self), u32ChannelCount, pf32Volumes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAudioEndpointOffloadStreamMute_Value = @import("../../zig.zig").Guid.initString("dfe21355-5ec2-40e0-8d6b-710ac3c00249");
pub const IID_IAudioEndpointOffloadStreamMute = &IID_IAudioEndpointOffloadStreamMute_Value;
pub const IAudioEndpointOffloadStreamMute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMute: fn(
            self: *const IAudioEndpointOffloadStreamMute,
            bMuted: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: fn(
            self: *const IAudioEndpointOffloadStreamMute,
            pbMuted: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamMute_SetMute(self: *const T, bMuted: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointOffloadStreamMute.VTable, self.vtable).SetMute(@ptrCast(*const IAudioEndpointOffloadStreamMute, self), bMuted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamMute_GetMute(self: *const T, pbMuted: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointOffloadStreamMute.VTable, self.vtable).GetMute(@ptrCast(*const IAudioEndpointOffloadStreamMute, self), pbMuted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioEndpointOffloadStreamMeter_Value = @import("../../zig.zig").Guid.initString("e1546dce-9dd1-418b-9ab2-348ced161c86");
pub const IID_IAudioEndpointOffloadStreamMeter = &IID_IAudioEndpointOffloadStreamMeter_Value;
pub const IAudioEndpointOffloadStreamMeter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMeterChannelCount: fn(
            self: *const IAudioEndpointOffloadStreamMeter,
            pu32ChannelCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMeteringData: fn(
            self: *const IAudioEndpointOffloadStreamMeter,
            u32ChannelCount: u32,
            pf32PeakValues: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamMeter_GetMeterChannelCount(self: *const T, pu32ChannelCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointOffloadStreamMeter.VTable, self.vtable).GetMeterChannelCount(@ptrCast(*const IAudioEndpointOffloadStreamMeter, self), pu32ChannelCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointOffloadStreamMeter_GetMeteringData(self: *const T, u32ChannelCount: u32, pf32PeakValues: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointOffloadStreamMeter.VTable, self.vtable).GetMeteringData(@ptrCast(*const IAudioEndpointOffloadStreamMeter, self), u32ChannelCount, pf32PeakValues);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAudioEndpointLastBufferControl_Value = @import("../../zig.zig").Guid.initString("f8520dd3-8f9d-4437-9861-62f584c33dd6");
pub const IID_IAudioEndpointLastBufferControl = &IID_IAudioEndpointLastBufferControl_Value;
pub const IAudioEndpointLastBufferControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsLastBufferControlSupported: fn(
            self: *const IAudioEndpointLastBufferControl,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        ReleaseOutputDataPointerForLastBuffer: fn(
            self: *const IAudioEndpointLastBufferControl,
            pConnectionProperty: ?*const APO_CONNECTION_PROPERTY,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointLastBufferControl_IsLastBufferControlSupported(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IAudioEndpointLastBufferControl.VTable, self.vtable).IsLastBufferControlSupported(@ptrCast(*const IAudioEndpointLastBufferControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointLastBufferControl_ReleaseOutputDataPointerForLastBuffer(self: *const T, pConnectionProperty: ?*const APO_CONNECTION_PROPERTY) callconv(.Inline) void {
            return @ptrCast(*const IAudioEndpointLastBufferControl.VTable, self.vtable).ReleaseOutputDataPointerForLastBuffer(@ptrCast(*const IAudioEndpointLastBufferControl, self), pConnectionProperty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAudioLfxControl_Value = @import("../../zig.zig").Guid.initString("076a6922-d802-4f83-baf6-409d9ca11bfe");
pub const IID_IAudioLfxControl = &IID_IAudioLfxControl_Value;
pub const IAudioLfxControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLocalEffectsState: fn(
            self: *const IAudioLfxControl,
            bEnabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalEffectsState: fn(
            self: *const IAudioLfxControl,
            pbEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioLfxControl_SetLocalEffectsState(self: *const T, bEnabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioLfxControl.VTable, self.vtable).SetLocalEffectsState(@ptrCast(*const IAudioLfxControl, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioLfxControl_GetLocalEffectsState(self: *const T, pbEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioLfxControl.VTable, self.vtable).GetLocalEffectsState(@ptrCast(*const IAudioLfxControl, self), pbEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IHardwareAudioEngineBase_Value = @import("../../zig.zig").Guid.initString("eddce3e4-f3c1-453a-b461-223563cbd886");
pub const IID_IHardwareAudioEngineBase = &IID_IHardwareAudioEngineBase_Value;
pub const IHardwareAudioEngineBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableOffloadConnectorCount: fn(
            self: *const IHardwareAudioEngineBase,
            _pwstrDeviceId: ?PWSTR,
            _uConnectorId: u32,
            _pAvailableConnectorInstanceCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngineFormat: fn(
            self: *const IHardwareAudioEngineBase,
            pDevice: ?*IMMDevice,
            _bRequestDeviceFormat: BOOL,
            _ppwfxFormat: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngineDeviceFormat: fn(
            self: *const IHardwareAudioEngineBase,
            pDevice: ?*IMMDevice,
            _pwfxFormat: ?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGfxState: fn(
            self: *const IHardwareAudioEngineBase,
            pDevice: ?*IMMDevice,
            _bEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGfxState: fn(
            self: *const IHardwareAudioEngineBase,
            pDevice: ?*IMMDevice,
            _pbEnable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_GetAvailableOffloadConnectorCount(self: *const T, _pwstrDeviceId: ?PWSTR, _uConnectorId: u32, _pAvailableConnectorInstanceCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHardwareAudioEngineBase.VTable, self.vtable).GetAvailableOffloadConnectorCount(@ptrCast(*const IHardwareAudioEngineBase, self), _pwstrDeviceId, _uConnectorId, _pAvailableConnectorInstanceCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_GetEngineFormat(self: *const T, pDevice: ?*IMMDevice, _bRequestDeviceFormat: BOOL, _ppwfxFormat: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHardwareAudioEngineBase.VTable, self.vtable).GetEngineFormat(@ptrCast(*const IHardwareAudioEngineBase, self), pDevice, _bRequestDeviceFormat, _ppwfxFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_SetEngineDeviceFormat(self: *const T, pDevice: ?*IMMDevice, _pwfxFormat: ?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHardwareAudioEngineBase.VTable, self.vtable).SetEngineDeviceFormat(@ptrCast(*const IHardwareAudioEngineBase, self), pDevice, _pwfxFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_SetGfxState(self: *const T, pDevice: ?*IMMDevice, _bEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHardwareAudioEngineBase.VTable, self.vtable).SetGfxState(@ptrCast(*const IHardwareAudioEngineBase, self), pDevice, _bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHardwareAudioEngineBase_GetGfxState(self: *const T, pDevice: ?*IMMDevice, _pbEnable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHardwareAudioEngineBase.VTable, self.vtable).GetGfxState(@ptrCast(*const IHardwareAudioEngineBase, self), pDevice, _pbEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DEVINTERFACE_AUDIOENDPOINTPLUGIN_Value = @import("../../zig.zig").Guid.initString("9f2f7b66-65ac-4fa6-8ae4-123c78b89313");
pub const CLSID_DEVINTERFACE_AUDIOENDPOINTPLUGIN = &CLSID_DEVINTERFACE_AUDIOENDPOINTPLUGIN_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioEndpointVolumeCallback_Value = @import("../../zig.zig").Guid.initString("657804fa-d6ad-4496-8a60-352752af4f89");
pub const IID_IAudioEndpointVolumeCallback = &IID_IAudioEndpointVolumeCallback_Value;
pub const IAudioEndpointVolumeCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: fn(
            self: *const IAudioEndpointVolumeCallback,
            pNotify: ?*AUDIO_VOLUME_NOTIFICATION_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolumeCallback_OnNotify(self: *const T, pNotify: ?*AUDIO_VOLUME_NOTIFICATION_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolumeCallback.VTable, self.vtable).OnNotify(@ptrCast(*const IAudioEndpointVolumeCallback, self), pNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioEndpointVolume_Value = @import("../../zig.zig").Guid.initString("5cdf2c82-841e-4546-9722-0cf74078229a");
pub const IID_IAudioEndpointVolume = &IID_IAudioEndpointVolume_Value;
pub const IAudioEndpointVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterControlChangeNotify: fn(
            self: *const IAudioEndpointVolume,
            pNotify: ?*IAudioEndpointVolumeCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterControlChangeNotify: fn(
            self: *const IAudioEndpointVolume,
            pNotify: ?*IAudioEndpointVolumeCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelCount: fn(
            self: *const IAudioEndpointVolume,
            pnChannelCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMasterVolumeLevel: fn(
            self: *const IAudioEndpointVolume,
            fLevelDB: f32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMasterVolumeLevelScalar: fn(
            self: *const IAudioEndpointVolume,
            fLevel: f32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMasterVolumeLevel: fn(
            self: *const IAudioEndpointVolume,
            pfLevelDB: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMasterVolumeLevelScalar: fn(
            self: *const IAudioEndpointVolume,
            pfLevel: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolumeLevel: fn(
            self: *const IAudioEndpointVolume,
            nChannel: u32,
            fLevelDB: f32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolumeLevelScalar: fn(
            self: *const IAudioEndpointVolume,
            nChannel: u32,
            fLevel: f32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolumeLevel: fn(
            self: *const IAudioEndpointVolume,
            nChannel: u32,
            pfLevelDB: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolumeLevelScalar: fn(
            self: *const IAudioEndpointVolume,
            nChannel: u32,
            pfLevel: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMute: fn(
            self: *const IAudioEndpointVolume,
            bMute: BOOL,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: fn(
            self: *const IAudioEndpointVolume,
            pbMute: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolumeStepInfo: fn(
            self: *const IAudioEndpointVolume,
            pnStep: ?*u32,
            pnStepCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VolumeStepUp: fn(
            self: *const IAudioEndpointVolume,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VolumeStepDown: fn(
            self: *const IAudioEndpointVolume,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHardwareSupport: fn(
            self: *const IAudioEndpointVolume,
            pdwHardwareSupportMask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolumeRange: fn(
            self: *const IAudioEndpointVolume,
            pflVolumeMindB: ?*f32,
            pflVolumeMaxdB: ?*f32,
            pflVolumeIncrementdB: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_RegisterControlChangeNotify(self: *const T, pNotify: ?*IAudioEndpointVolumeCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).RegisterControlChangeNotify(@ptrCast(*const IAudioEndpointVolume, self), pNotify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_UnregisterControlChangeNotify(self: *const T, pNotify: ?*IAudioEndpointVolumeCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).UnregisterControlChangeNotify(@ptrCast(*const IAudioEndpointVolume, self), pNotify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetChannelCount(self: *const T, pnChannelCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).GetChannelCount(@ptrCast(*const IAudioEndpointVolume, self), pnChannelCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetMasterVolumeLevel(self: *const T, fLevelDB: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).SetMasterVolumeLevel(@ptrCast(*const IAudioEndpointVolume, self), fLevelDB, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetMasterVolumeLevelScalar(self: *const T, fLevel: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).SetMasterVolumeLevelScalar(@ptrCast(*const IAudioEndpointVolume, self), fLevel, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetMasterVolumeLevel(self: *const T, pfLevelDB: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).GetMasterVolumeLevel(@ptrCast(*const IAudioEndpointVolume, self), pfLevelDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetMasterVolumeLevelScalar(self: *const T, pfLevel: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).GetMasterVolumeLevelScalar(@ptrCast(*const IAudioEndpointVolume, self), pfLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetChannelVolumeLevel(self: *const T, nChannel: u32, fLevelDB: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).SetChannelVolumeLevel(@ptrCast(*const IAudioEndpointVolume, self), nChannel, fLevelDB, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetChannelVolumeLevelScalar(self: *const T, nChannel: u32, fLevel: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).SetChannelVolumeLevelScalar(@ptrCast(*const IAudioEndpointVolume, self), nChannel, fLevel, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetChannelVolumeLevel(self: *const T, nChannel: u32, pfLevelDB: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).GetChannelVolumeLevel(@ptrCast(*const IAudioEndpointVolume, self), nChannel, pfLevelDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetChannelVolumeLevelScalar(self: *const T, nChannel: u32, pfLevel: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).GetChannelVolumeLevelScalar(@ptrCast(*const IAudioEndpointVolume, self), nChannel, pfLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_SetMute(self: *const T, bMute: BOOL, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).SetMute(@ptrCast(*const IAudioEndpointVolume, self), bMute, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetMute(self: *const T, pbMute: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).GetMute(@ptrCast(*const IAudioEndpointVolume, self), pbMute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetVolumeStepInfo(self: *const T, pnStep: ?*u32, pnStepCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).GetVolumeStepInfo(@ptrCast(*const IAudioEndpointVolume, self), pnStep, pnStepCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_VolumeStepUp(self: *const T, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).VolumeStepUp(@ptrCast(*const IAudioEndpointVolume, self), pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_VolumeStepDown(self: *const T, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).VolumeStepDown(@ptrCast(*const IAudioEndpointVolume, self), pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_QueryHardwareSupport(self: *const T, pdwHardwareSupportMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).QueryHardwareSupport(@ptrCast(*const IAudioEndpointVolume, self), pdwHardwareSupportMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolume_GetVolumeRange(self: *const T, pflVolumeMindB: ?*f32, pflVolumeMaxdB: ?*f32, pflVolumeIncrementdB: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolume.VTable, self.vtable).GetVolumeRange(@ptrCast(*const IAudioEndpointVolume, self), pflVolumeMindB, pflVolumeMaxdB, pflVolumeIncrementdB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioEndpointVolumeEx_Value = @import("../../zig.zig").Guid.initString("66e11784-f695-4f28-a505-a7080081a78f");
pub const IID_IAudioEndpointVolumeEx = &IID_IAudioEndpointVolumeEx_Value;
pub const IAudioEndpointVolumeEx = extern struct {
    pub const VTable = extern struct {
        base: IAudioEndpointVolume.VTable,
        GetVolumeRangeChannel: fn(
            self: *const IAudioEndpointVolumeEx,
            iChannel: u32,
            pflVolumeMindB: ?*f32,
            pflVolumeMaxdB: ?*f32,
            pflVolumeIncrementdB: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAudioEndpointVolume.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEndpointVolumeEx_GetVolumeRangeChannel(self: *const T, iChannel: u32, pflVolumeMindB: ?*f32, pflVolumeMaxdB: ?*f32, pflVolumeIncrementdB: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEndpointVolumeEx.VTable, self.vtable).GetVolumeRangeChannel(@ptrCast(*const IAudioEndpointVolumeEx, self), iChannel, pflVolumeMindB, pflVolumeMaxdB, pflVolumeIncrementdB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioMeterInformation_Value = @import("../../zig.zig").Guid.initString("c02216f6-8c67-4b5b-9d00-d008e73e0064");
pub const IID_IAudioMeterInformation = &IID_IAudioMeterInformation_Value;
pub const IAudioMeterInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPeakValue: fn(
            self: *const IAudioMeterInformation,
            pfPeak: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMeteringChannelCount: fn(
            self: *const IAudioMeterInformation,
            pnChannelCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelsPeakValues: fn(
            self: *const IAudioMeterInformation,
            u32ChannelCount: u32,
            afPeakValues: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHardwareSupport: fn(
            self: *const IAudioMeterInformation,
            pdwHardwareSupportMask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMeterInformation_GetPeakValue(self: *const T, pfPeak: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMeterInformation.VTable, self.vtable).GetPeakValue(@ptrCast(*const IAudioMeterInformation, self), pfPeak);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMeterInformation_GetMeteringChannelCount(self: *const T, pnChannelCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMeterInformation.VTable, self.vtable).GetMeteringChannelCount(@ptrCast(*const IAudioMeterInformation, self), pnChannelCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMeterInformation_GetChannelsPeakValues(self: *const T, u32ChannelCount: u32, afPeakValues: [*]f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMeterInformation.VTable, self.vtable).GetChannelsPeakValues(@ptrCast(*const IAudioMeterInformation, self), u32ChannelCount, afPeakValues);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMeterInformation_QueryHardwareSupport(self: *const T, pdwHardwareSupportMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMeterInformation.VTable, self.vtable).QueryHardwareSupport(@ptrCast(*const IAudioMeterInformation, self), pdwHardwareSupportMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (10)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const APO_CONNECTION_PROPERTY = @import("../../media/audio/apo.zig").APO_CONNECTION_PROPERTY;
const AUDIO_CURVE_TYPE = @import("../../media/kernel_streaming.zig").AUDIO_CURVE_TYPE;
const AUDIO_VOLUME_NOTIFICATION_DATA = @import("../../media/audio.zig").AUDIO_VOLUME_NOTIFICATION_DATA;
const BOOL = @import("../../foundation.zig").BOOL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IMMDevice = @import("../../media/audio.zig").IMMDevice;
const IUnknown = @import("../../system/com.zig").IUnknown;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
