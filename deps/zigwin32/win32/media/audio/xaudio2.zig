//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (218)
//--------------------------------------------------------------------------------
pub const FXEQ_MIN_FRAMERATE = @as(u32, 22000);
pub const FXEQ_MAX_FRAMERATE = @as(u32, 48000);
pub const FXEQ_MIN_FREQUENCY_CENTER = @as(f32, 20);
pub const FXEQ_MAX_FREQUENCY_CENTER = @as(f32, 20000);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_0 = @as(f32, 100);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_1 = @as(f32, 800);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_2 = @as(f32, 2000);
pub const FXEQ_DEFAULT_FREQUENCY_CENTER_3 = @as(f32, 10000);
pub const FXEQ_MIN_GAIN = @as(f32, 1.26e-01);
pub const FXEQ_MAX_GAIN = @as(f32, 7.94e+00);
pub const FXEQ_DEFAULT_GAIN = @as(f32, 1);
pub const FXEQ_MIN_BANDWIDTH = @as(f32, 1.0e-01);
pub const FXEQ_MAX_BANDWIDTH = @as(f32, 2);
pub const FXEQ_DEFAULT_BANDWIDTH = @as(f32, 1);
pub const FXMASTERINGLIMITER_MIN_RELEASE = @as(u32, 1);
pub const FXMASTERINGLIMITER_MAX_RELEASE = @as(u32, 20);
pub const FXMASTERINGLIMITER_DEFAULT_RELEASE = @as(u32, 6);
pub const FXMASTERINGLIMITER_MIN_LOUDNESS = @as(u32, 1);
pub const FXMASTERINGLIMITER_MAX_LOUDNESS = @as(u32, 1800);
pub const FXMASTERINGLIMITER_DEFAULT_LOUDNESS = @as(u32, 1000);
pub const FXREVERB_MIN_DIFFUSION = @as(f32, 0);
pub const FXREVERB_MAX_DIFFUSION = @as(f32, 1);
pub const FXREVERB_DEFAULT_DIFFUSION = @as(f32, 9.0e-01);
pub const FXREVERB_MIN_ROOMSIZE = @as(f32, 1.0e-04);
pub const FXREVERB_MAX_ROOMSIZE = @as(f32, 1);
pub const FXREVERB_DEFAULT_ROOMSIZE = @as(f32, 6.0e-01);
pub const FXLOUDNESS_DEFAULT_MOMENTARY_MS = @as(u32, 400);
pub const FXLOUDNESS_DEFAULT_SHORTTERM_MS = @as(u32, 3000);
pub const FXECHO_MIN_WETDRYMIX = @as(f32, 0);
pub const FXECHO_MAX_WETDRYMIX = @as(f32, 1);
pub const FXECHO_DEFAULT_WETDRYMIX = @as(f32, 5.0e-01);
pub const FXECHO_MIN_FEEDBACK = @as(f32, 0);
pub const FXECHO_MAX_FEEDBACK = @as(f32, 1);
pub const FXECHO_DEFAULT_FEEDBACK = @as(f32, 5.0e-01);
pub const FXECHO_MIN_DELAY = @as(f32, 1);
pub const FXECHO_MAX_DELAY = @as(f32, 2000);
pub const FXECHO_DEFAULT_DELAY = @as(f32, 500);
pub const XAUDIO2_MAX_BUFFER_BYTES = @as(u32, 2147483648);
pub const XAUDIO2_MAX_QUEUED_BUFFERS = @as(u32, 64);
pub const XAUDIO2_MAX_BUFFERS_SYSTEM = @as(u32, 2);
pub const XAUDIO2_MAX_AUDIO_CHANNELS = @as(u32, 64);
pub const XAUDIO2_MIN_SAMPLE_RATE = @as(u32, 1000);
pub const XAUDIO2_MAX_SAMPLE_RATE = @as(u32, 200000);
pub const XAUDIO2_MAX_VOLUME_LEVEL = @as(f32, 16777216);
pub const XAUDIO2_MAX_FREQ_RATIO = @as(f32, 1024);
pub const XAUDIO2_DEFAULT_FREQ_RATIO = @as(f32, 2);
pub const XAUDIO2_MAX_FILTER_ONEOVERQ = @as(f32, 1.5e+00);
pub const XAUDIO2_MAX_FILTER_FREQUENCY = @as(f32, 1);
pub const XAUDIO2_MAX_LOOP_COUNT = @as(u32, 254);
pub const XAUDIO2_MAX_INSTANCES = @as(u32, 8);
pub const XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MONO = @as(u32, 600000);
pub const XAUDIO2_MAX_RATIO_TIMES_RATE_XMA_MULTICHANNEL = @as(u32, 300000);
pub const XAUDIO2_COMMIT_NOW = @as(u32, 0);
pub const XAUDIO2_COMMIT_ALL = @as(u32, 0);
pub const XAUDIO2_NO_LOOP_REGION = @as(u32, 0);
pub const XAUDIO2_LOOP_INFINITE = @as(u32, 255);
pub const XAUDIO2_DEFAULT_CHANNELS = @as(u32, 0);
pub const XAUDIO2_DEFAULT_SAMPLERATE = @as(u32, 0);
pub const XAUDIO2_DEBUG_ENGINE = @as(u32, 1);
pub const XAUDIO2_VOICE_NOPITCH = @as(u32, 2);
pub const XAUDIO2_VOICE_NOSRC = @as(u32, 4);
pub const XAUDIO2_VOICE_USEFILTER = @as(u32, 8);
pub const XAUDIO2_PLAY_TAILS = @as(u32, 32);
pub const XAUDIO2_END_OF_STREAM = @as(u32, 64);
pub const XAUDIO2_SEND_USEFILTER = @as(u32, 128);
pub const XAUDIO2_VOICE_NOSAMPLESPLAYED = @as(u32, 256);
pub const XAUDIO2_STOP_ENGINE_WHEN_IDLE = @as(u32, 8192);
pub const XAUDIO2_1024_QUANTUM = @as(u32, 32768);
pub const XAUDIO2_NO_VIRTUAL_AUDIO_CLIENT = @as(u32, 65536);
pub const XAUDIO2_DEFAULT_FILTER_FREQUENCY = @as(f32, 1);
pub const XAUDIO2_DEFAULT_FILTER_ONEOVERQ = @as(f32, 1);
pub const XAUDIO2_QUANTUM_NUMERATOR = @as(u32, 1);
pub const XAUDIO2_QUANTUM_DENOMINATOR = @as(u32, 100);
pub const FACILITY_XAUDIO2 = @as(u32, 2198);
pub const XAUDIO2_E_INVALID_CALL = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435519));
pub const XAUDIO2_E_XMA_DECODER_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435518));
pub const XAUDIO2_E_XAPO_CREATION_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435517));
pub const XAUDIO2_E_DEVICE_INVALIDATED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003435516));
pub const Processor1 = @as(u32, 1);
pub const Processor2 = @as(u32, 2);
pub const Processor3 = @as(u32, 4);
pub const Processor4 = @as(u32, 8);
pub const Processor5 = @as(u32, 16);
pub const Processor6 = @as(u32, 32);
pub const Processor7 = @as(u32, 64);
pub const Processor8 = @as(u32, 128);
pub const Processor9 = @as(u32, 256);
pub const Processor10 = @as(u32, 512);
pub const Processor11 = @as(u32, 1024);
pub const Processor12 = @as(u32, 2048);
pub const Processor13 = @as(u32, 4096);
pub const Processor14 = @as(u32, 8192);
pub const Processor15 = @as(u32, 16384);
pub const Processor16 = @as(u32, 32768);
pub const Processor17 = @as(u32, 65536);
pub const Processor18 = @as(u32, 131072);
pub const Processor19 = @as(u32, 262144);
pub const Processor20 = @as(u32, 524288);
pub const Processor21 = @as(u32, 1048576);
pub const Processor22 = @as(u32, 2097152);
pub const Processor23 = @as(u32, 4194304);
pub const Processor24 = @as(u32, 8388608);
pub const Processor25 = @as(u32, 16777216);
pub const Processor26 = @as(u32, 33554432);
pub const Processor27 = @as(u32, 67108864);
pub const Processor28 = @as(u32, 134217728);
pub const Processor29 = @as(u32, 268435456);
pub const Processor30 = @as(u32, 536870912);
pub const Processor31 = @as(u32, 1073741824);
pub const Processor32 = @as(u32, 2147483648);
pub const XAUDIO2_ANY_PROCESSOR = @as(u32, 4294967295);
pub const XAUDIO2_USE_DEFAULT_PROCESSOR = @as(u32, 0);
pub const XAUDIO2_DEFAULT_PROCESSOR = @as(u32, 1);
pub const XAUDIO2_LOG_ERRORS = @as(u32, 1);
pub const XAUDIO2_LOG_WARNINGS = @as(u32, 2);
pub const XAUDIO2_LOG_INFO = @as(u32, 4);
pub const XAUDIO2_LOG_DETAIL = @as(u32, 8);
pub const XAUDIO2_LOG_API_CALLS = @as(u32, 16);
pub const XAUDIO2_LOG_FUNC_CALLS = @as(u32, 32);
pub const XAUDIO2_LOG_TIMING = @as(u32, 64);
pub const XAUDIO2_LOG_LOCKS = @as(u32, 128);
pub const XAUDIO2_LOG_MEMORY = @as(u32, 256);
pub const XAUDIO2_LOG_STREAMING = @as(u32, 4096);
pub const XAUDIO2FX_REVERB_MIN_FRAMERATE = @as(u32, 20000);
pub const XAUDIO2FX_REVERB_MAX_FRAMERATE = @as(u32, 48000);
pub const XAUDIO2FX_REVERB_MIN_WET_DRY_MIX = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MIN_REFLECTIONS_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_REVERB_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_REAR_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_7POINT1_SIDE_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_7POINT1_REAR_DELAY = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_POSITION = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_DIFFUSION = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_LOW_EQ_GAIN = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_LOW_EQ_CUTOFF = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_HIGH_EQ_GAIN = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_HIGH_EQ_CUTOFF = @as(u32, 0);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_FREQ = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_MAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_ROOM_FILTER_HF = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_REFLECTIONS_GAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_REVERB_GAIN = @as(f32, -100);
pub const XAUDIO2FX_REVERB_MIN_DECAY_TIME = @as(f32, 1.0e-01);
pub const XAUDIO2FX_REVERB_MIN_DENSITY = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MIN_ROOM_SIZE = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_WET_DRY_MIX = @as(f32, 100);
pub const XAUDIO2FX_REVERB_MAX_REFLECTIONS_DELAY = @as(u32, 300);
pub const XAUDIO2FX_REVERB_MAX_REVERB_DELAY = @as(u32, 85);
pub const XAUDIO2FX_REVERB_MAX_REAR_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_MAX_7POINT1_SIDE_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_MAX_7POINT1_REAR_DELAY = @as(u32, 20);
pub const XAUDIO2FX_REVERB_MAX_POSITION = @as(u32, 30);
pub const XAUDIO2FX_REVERB_MAX_DIFFUSION = @as(u32, 15);
pub const XAUDIO2FX_REVERB_MAX_LOW_EQ_GAIN = @as(u32, 12);
pub const XAUDIO2FX_REVERB_MAX_LOW_EQ_CUTOFF = @as(u32, 9);
pub const XAUDIO2FX_REVERB_MAX_HIGH_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_MAX_HIGH_EQ_CUTOFF = @as(u32, 14);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_FREQ = @as(f32, 20000);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_MAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_ROOM_FILTER_HF = @as(f32, 0);
pub const XAUDIO2FX_REVERB_MAX_REFLECTIONS_GAIN = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MAX_REVERB_GAIN = @as(f32, 20);
pub const XAUDIO2FX_REVERB_MAX_DENSITY = @as(f32, 100);
pub const XAUDIO2FX_REVERB_MAX_ROOM_SIZE = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_WET_DRY_MIX = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_REFLECTIONS_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_REVERB_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_REAR_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_7POINT1_SIDE_DELAY = @as(u32, 5);
pub const XAUDIO2FX_REVERB_DEFAULT_7POINT1_REAR_DELAY = @as(u32, 20);
pub const XAUDIO2FX_REVERB_DEFAULT_POSITION = @as(u32, 6);
pub const XAUDIO2FX_REVERB_DEFAULT_POSITION_MATRIX = @as(u32, 27);
pub const XAUDIO2FX_REVERB_DEFAULT_EARLY_DIFFUSION = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LATE_DIFFUSION = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LOW_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_LOW_EQ_CUTOFF = @as(u32, 4);
pub const XAUDIO2FX_REVERB_DEFAULT_HIGH_EQ_GAIN = @as(u32, 8);
pub const XAUDIO2FX_REVERB_DEFAULT_HIGH_EQ_CUTOFF = @as(u32, 4);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_FREQ = @as(f32, 5000);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_MAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_FILTER_HF = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_REFLECTIONS_GAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_REVERB_GAIN = @as(f32, 0);
pub const XAUDIO2FX_REVERB_DEFAULT_DECAY_TIME = @as(f32, 1);
pub const XAUDIO2FX_REVERB_DEFAULT_DENSITY = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_ROOM_SIZE = @as(f32, 100);
pub const XAUDIO2FX_REVERB_DEFAULT_DISABLE_LATE_FIELD = @as(u32, 0);
pub const HRTF_MAX_GAIN_LIMIT = @as(f32, 12);
pub const HRTF_MIN_GAIN_LIMIT = @as(f32, -96);
pub const HRTF_MIN_UNITY_GAIN_DISTANCE = @as(f32, 5.0e-02);
pub const HRTF_DEFAULT_UNITY_GAIN_DISTANCE = @as(f32, 1);
pub const FACILITY_XAPO = @as(u32, 2199);
pub const XAPO_E_FORMAT_UNSUPPORTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2003369983));
pub const XAPO_MIN_CHANNELS = @as(u32, 1);
pub const XAPO_MAX_CHANNELS = @as(u32, 64);
pub const XAPO_MIN_FRAMERATE = @as(u32, 1000);
pub const XAPO_MAX_FRAMERATE = @as(u32, 200000);
pub const XAPO_REGISTRATION_STRING_LENGTH = @as(u32, 256);
pub const XAPO_FLAG_CHANNELS_MUST_MATCH = @as(u32, 1);
pub const XAPO_FLAG_FRAMERATE_MUST_MATCH = @as(u32, 2);
pub const XAPO_FLAG_BITSPERSAMPLE_MUST_MATCH = @as(u32, 4);
pub const XAPO_FLAG_BUFFERCOUNT_MUST_MATCH = @as(u32, 8);
pub const XAPO_FLAG_INPLACE_REQUIRED = @as(u32, 32);
pub const XAPO_FLAG_INPLACE_SUPPORTED = @as(u32, 16);
pub const SPEAKER_MONO = @as(u32, 4);
pub const X3DAUDIO_HANDLE_BYTESIZE = @as(u32, 20);
pub const X3DAUDIO_PI = @as(f32, 3.1415927e+00);
pub const X3DAUDIO_2PI = @as(f32, 6.2831855e+00);
pub const X3DAUDIO_SPEED_OF_SOUND = @as(f32, 3.435e+02);
pub const X3DAUDIO_CALCULATE_MATRIX = @as(u32, 1);
pub const X3DAUDIO_CALCULATE_DELAY = @as(u32, 2);
pub const X3DAUDIO_CALCULATE_LPF_DIRECT = @as(u32, 4);
pub const X3DAUDIO_CALCULATE_LPF_REVERB = @as(u32, 8);
pub const X3DAUDIO_CALCULATE_REVERB = @as(u32, 16);
pub const X3DAUDIO_CALCULATE_DOPPLER = @as(u32, 32);
pub const X3DAUDIO_CALCULATE_EMITTER_ANGLE = @as(u32, 64);
pub const X3DAUDIO_CALCULATE_ZEROCENTER = @as(u32, 65536);
pub const X3DAUDIO_CALCULATE_REDIRECT_TO_LFE = @as(u32, 131072);

//--------------------------------------------------------------------------------
// Section: Types (51)
//--------------------------------------------------------------------------------
pub const XAPO_REGISTRATION_PROPERTIES = packed struct {
    clsid: Guid,
    FriendlyName: [256]u16,
    CopyrightInfo: [256]u16,
    MajorVersion: u32,
    MinorVersion: u32,
    Flags: u32,
    MinInputBufferCount: u32,
    MaxInputBufferCount: u32,
    MinOutputBufferCount: u32,
    MaxOutputBufferCount: u32,
};

pub const XAPO_LOCKFORPROCESS_PARAMETERS = packed struct {
    pFormat: ?*const WAVEFORMATEX,
    MaxFrameCount: u32,
};

pub const XAPO_BUFFER_FLAGS = enum(i32) {
    SILENT = 0,
    VALID = 1,
};
pub const XAPO_BUFFER_SILENT = XAPO_BUFFER_FLAGS.SILENT;
pub const XAPO_BUFFER_VALID = XAPO_BUFFER_FLAGS.VALID;

pub const XAPO_PROCESS_BUFFER_PARAMETERS = packed struct {
    pBuffer: ?*anyopaque,
    BufferFlags: XAPO_BUFFER_FLAGS,
    ValidFrameCount: u32,
};

const IID_IXAPO_Value = @import("../../zig.zig").Guid.initString("a410b984-9839-4819-a0be-2856ae6b3adb");
pub const IID_IXAPO = &IID_IXAPO_Value;
pub const IXAPO = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRegistrationProperties: fn(
            self: *const IXAPO,
            ppRegistrationProperties: ?*?*XAPO_REGISTRATION_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInputFormatSupported: fn(
            self: *const IXAPO,
            pOutputFormat: ?*const WAVEFORMATEX,
            pRequestedInputFormat: ?*const WAVEFORMATEX,
            ppSupportedInputFormat: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsOutputFormatSupported: fn(
            self: *const IXAPO,
            pInputFormat: ?*const WAVEFORMATEX,
            pRequestedOutputFormat: ?*const WAVEFORMATEX,
            ppSupportedOutputFormat: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const IXAPO,
            // TODO: what to do with BytesParamIndex 1?
            pData: ?*const anyopaque,
            DataByteSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IXAPO,
        ) callconv(@import("std").os.windows.WINAPI) void,
        LockForProcess: fn(
            self: *const IXAPO,
            InputLockedParameterCount: u32,
            pInputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
            OutputLockedParameterCount: u32,
            pOutputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockForProcess: fn(
            self: *const IXAPO,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Process: fn(
            self: *const IXAPO,
            InputProcessParameterCount: u32,
            pInputProcessParameters: ?[*]const XAPO_PROCESS_BUFFER_PARAMETERS,
            OutputProcessParameterCount: u32,
            pOutputProcessParameters: ?[*]XAPO_PROCESS_BUFFER_PARAMETERS,
            IsEnabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CalcInputFrames: fn(
            self: *const IXAPO,
            OutputFrameCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        CalcOutputFrames: fn(
            self: *const IXAPO,
            InputFrameCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_GetRegistrationProperties(self: *const T, ppRegistrationProperties: ?*?*XAPO_REGISTRATION_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAPO.VTable, self.vtable).GetRegistrationProperties(@ptrCast(*const IXAPO, self), ppRegistrationProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_IsInputFormatSupported(self: *const T, pOutputFormat: ?*const WAVEFORMATEX, pRequestedInputFormat: ?*const WAVEFORMATEX, ppSupportedInputFormat: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAPO.VTable, self.vtable).IsInputFormatSupported(@ptrCast(*const IXAPO, self), pOutputFormat, pRequestedInputFormat, ppSupportedInputFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_IsOutputFormatSupported(self: *const T, pInputFormat: ?*const WAVEFORMATEX, pRequestedOutputFormat: ?*const WAVEFORMATEX, ppSupportedOutputFormat: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAPO.VTable, self.vtable).IsOutputFormatSupported(@ptrCast(*const IXAPO, self), pInputFormat, pRequestedOutputFormat, ppSupportedOutputFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_Initialize(self: *const T, pData: ?*const anyopaque, DataByteSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAPO.VTable, self.vtable).Initialize(@ptrCast(*const IXAPO, self), pData, DataByteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_Reset(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IXAPO.VTable, self.vtable).Reset(@ptrCast(*const IXAPO, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_LockForProcess(self: *const T, InputLockedParameterCount: u32, pInputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS, OutputLockedParameterCount: u32, pOutputLockedParameters: ?[*]const XAPO_LOCKFORPROCESS_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAPO.VTable, self.vtable).LockForProcess(@ptrCast(*const IXAPO, self), InputLockedParameterCount, pInputLockedParameters, OutputLockedParameterCount, pOutputLockedParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_UnlockForProcess(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IXAPO.VTable, self.vtable).UnlockForProcess(@ptrCast(*const IXAPO, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_Process(self: *const T, InputProcessParameterCount: u32, pInputProcessParameters: ?[*]const XAPO_PROCESS_BUFFER_PARAMETERS, OutputProcessParameterCount: u32, pOutputProcessParameters: ?[*]XAPO_PROCESS_BUFFER_PARAMETERS, IsEnabled: BOOL) callconv(.Inline) void {
            return @ptrCast(*const IXAPO.VTable, self.vtable).Process(@ptrCast(*const IXAPO, self), InputProcessParameterCount, pInputProcessParameters, OutputProcessParameterCount, pOutputProcessParameters, IsEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_CalcInputFrames(self: *const T, OutputFrameCount: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IXAPO.VTable, self.vtable).CalcInputFrames(@ptrCast(*const IXAPO, self), OutputFrameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPO_CalcOutputFrames(self: *const T, InputFrameCount: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IXAPO.VTable, self.vtable).CalcOutputFrames(@ptrCast(*const IXAPO, self), InputFrameCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXAPOParameters_Value = @import("../../zig.zig").Guid.initString("26d95c66-80f2-499a-ad54-5ae7f01c6d98");
pub const IID_IXAPOParameters = &IID_IXAPOParameters_Value;
pub const IXAPOParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetParameters: fn(
            self: *const IXAPOParameters,
            // TODO: what to do with BytesParamIndex 1?
            pParameters: ?*const anyopaque,
            ParameterByteSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetParameters: fn(
            self: *const IXAPOParameters,
            // TODO: what to do with BytesParamIndex 1?
            pParameters: ?*anyopaque,
            ParameterByteSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPOParameters_SetParameters(self: *const T, pParameters: ?*const anyopaque, ParameterByteSize: u32) callconv(.Inline) void {
            return @ptrCast(*const IXAPOParameters.VTable, self.vtable).SetParameters(@ptrCast(*const IXAPOParameters, self), pParameters, ParameterByteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPOParameters_GetParameters(self: *const T, pParameters: ?*anyopaque, ParameterByteSize: u32) callconv(.Inline) void {
            return @ptrCast(*const IXAPOParameters.VTable, self.vtable).GetParameters(@ptrCast(*const IXAPOParameters, self), pParameters, ParameterByteSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_FXEQ_Value = @import("../../zig.zig").Guid.initString("f5e01117-d6c4-485a-a3f5-695196f3dbfa");
pub const CLSID_FXEQ = &CLSID_FXEQ_Value;

const CLSID_FXMasteringLimiter_Value = @import("../../zig.zig").Guid.initString("c4137916-2be1-46fd-8599-441536f49856");
pub const CLSID_FXMasteringLimiter = &CLSID_FXMasteringLimiter_Value;

const CLSID_FXReverb_Value = @import("../../zig.zig").Guid.initString("7d9aca56-cb68-4807-b632-b137352e8596");
pub const CLSID_FXReverb = &CLSID_FXReverb_Value;

const CLSID_FXEcho_Value = @import("../../zig.zig").Guid.initString("5039d740-f736-449a-84d3-a56202557b87");
pub const CLSID_FXEcho = &CLSID_FXEcho_Value;

pub const FXEQ_PARAMETERS = packed struct {
    FrequencyCenter0: f32,
    Gain0: f32,
    Bandwidth0: f32,
    FrequencyCenter1: f32,
    Gain1: f32,
    Bandwidth1: f32,
    FrequencyCenter2: f32,
    Gain2: f32,
    Bandwidth2: f32,
    FrequencyCenter3: f32,
    Gain3: f32,
    Bandwidth3: f32,
};

pub const FXMASTERINGLIMITER_PARAMETERS = packed struct {
    Release: u32,
    Loudness: u32,
};

pub const FXREVERB_PARAMETERS = packed struct {
    Diffusion: f32,
    RoomSize: f32,
};

pub const FXECHO_INITDATA = packed struct {
    MaxDelay: f32,
};

pub const FXECHO_PARAMETERS = packed struct {
    WetDryMix: f32,
    Feedback: f32,
    Delay: f32,
};

pub const XAUDIO2_VOICE_DETAILS = packed struct {
    CreationFlags: u32,
    ActiveFlags: u32,
    InputChannels: u32,
    InputSampleRate: u32,
};

pub const XAUDIO2_SEND_DESCRIPTOR = packed struct {
    Flags: u32,
    pOutputVoice: ?*IXAudio2Voice,
};

pub const XAUDIO2_VOICE_SENDS = packed struct {
    SendCount: u32,
    pSends: ?*XAUDIO2_SEND_DESCRIPTOR,
};

pub const XAUDIO2_EFFECT_DESCRIPTOR = packed struct {
    pEffect: ?*IUnknown,
    InitialState: BOOL,
    OutputChannels: u32,
};

pub const XAUDIO2_EFFECT_CHAIN = packed struct {
    EffectCount: u32,
    pEffectDescriptors: ?*XAUDIO2_EFFECT_DESCRIPTOR,
};

pub const XAUDIO2_FILTER_TYPE = enum(i32) {
    LowPassFilter = 0,
    BandPassFilter = 1,
    HighPassFilter = 2,
    NotchFilter = 3,
    LowPassOnePoleFilter = 4,
    HighPassOnePoleFilter = 5,
};
pub const LowPassFilter = XAUDIO2_FILTER_TYPE.LowPassFilter;
pub const BandPassFilter = XAUDIO2_FILTER_TYPE.BandPassFilter;
pub const HighPassFilter = XAUDIO2_FILTER_TYPE.HighPassFilter;
pub const NotchFilter = XAUDIO2_FILTER_TYPE.NotchFilter;
pub const LowPassOnePoleFilter = XAUDIO2_FILTER_TYPE.LowPassOnePoleFilter;
pub const HighPassOnePoleFilter = XAUDIO2_FILTER_TYPE.HighPassOnePoleFilter;

pub const XAUDIO2_FILTER_PARAMETERS = packed struct {
    Type: XAUDIO2_FILTER_TYPE,
    Frequency: f32,
    OneOverQ: f32,
};

pub const XAUDIO2_BUFFER = packed struct {
    Flags: u32,
    AudioBytes: u32,
    pAudioData: ?*const u8,
    PlayBegin: u32,
    PlayLength: u32,
    LoopBegin: u32,
    LoopLength: u32,
    LoopCount: u32,
    pContext: ?*anyopaque,
};

pub const XAUDIO2_BUFFER_WMA = packed struct {
    pDecodedPacketCumulativeBytes: ?*const u32,
    PacketCount: u32,
};

pub const XAUDIO2_VOICE_STATE = packed struct {
    pCurrentBufferContext: ?*anyopaque,
    BuffersQueued: u32,
    SamplesPlayed: u64,
};

pub const XAUDIO2_PERFORMANCE_DATA = packed struct {
    AudioCyclesSinceLastQuery: u64,
    TotalCyclesSinceLastQuery: u64,
    MinimumCyclesPerQuantum: u32,
    MaximumCyclesPerQuantum: u32,
    MemoryUsageInBytes: u32,
    CurrentLatencyInSamples: u32,
    GlitchesSinceEngineStarted: u32,
    ActiveSourceVoiceCount: u32,
    TotalSourceVoiceCount: u32,
    ActiveSubmixVoiceCount: u32,
    ActiveResamplerCount: u32,
    ActiveMatrixMixCount: u32,
    ActiveXmaSourceVoices: u32,
    ActiveXmaStreams: u32,
};

pub const XAUDIO2_DEBUG_CONFIGURATION = packed struct {
    TraceMask: u32,
    BreakMask: u32,
    LogThreadID: BOOL,
    LogFileline: BOOL,
    LogFunctionName: BOOL,
    LogTiming: BOOL,
};

const IID_IXAudio2_Value = @import("../../zig.zig").Guid.initString("2b02e3cf-2e0b-4ec3-be45-1b2a3fe7210d");
pub const IID_IXAudio2 = &IID_IXAudio2_Value;
pub const IXAudio2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterForCallbacks: fn(
            self: *const IXAudio2,
            pCallback: ?*IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterForCallbacks: fn(
            self: *const IXAudio2,
            pCallback: ?*IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CreateSourceVoice: fn(
            self: *const IXAudio2,
            ppSourceVoice: ?*?*IXAudio2SourceVoice,
            pSourceFormat: ?*const WAVEFORMATEX,
            Flags: u32,
            MaxFrequencyRatio: f32,
            pCallback: ?*IXAudio2VoiceCallback,
            pSendList: ?*const XAUDIO2_VOICE_SENDS,
            pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSubmixVoice: fn(
            self: *const IXAudio2,
            ppSubmixVoice: ?*?*IXAudio2SubmixVoice,
            InputChannels: u32,
            InputSampleRate: u32,
            Flags: u32,
            ProcessingStage: u32,
            pSendList: ?*const XAUDIO2_VOICE_SENDS,
            pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMasteringVoice: fn(
            self: *const IXAudio2,
            ppMasteringVoice: ?*?*IXAudio2MasteringVoice,
            InputChannels: u32,
            InputSampleRate: u32,
            Flags: u32,
            szDeviceId: ?[*:0]const u16,
            pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
            StreamCategory: AUDIO_STREAM_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartEngine: fn(
            self: *const IXAudio2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopEngine: fn(
            self: *const IXAudio2,
        ) callconv(@import("std").os.windows.WINAPI) void,
        CommitChanges: fn(
            self: *const IXAudio2,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPerformanceData: fn(
            self: *const IXAudio2,
            pPerfData: ?*XAUDIO2_PERFORMANCE_DATA,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetDebugConfiguration: fn(
            self: *const IXAudio2,
            pDebugConfiguration: ?*const XAUDIO2_DEBUG_CONFIGURATION,
            pReserved: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_RegisterForCallbacks(self: *const T, pCallback: ?*IXAudio2EngineCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).RegisterForCallbacks(@ptrCast(*const IXAudio2, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_UnregisterForCallbacks(self: *const T, pCallback: ?*IXAudio2EngineCallback) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).UnregisterForCallbacks(@ptrCast(*const IXAudio2, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_CreateSourceVoice(self: *const T, ppSourceVoice: ?*?*IXAudio2SourceVoice, pSourceFormat: ?*const WAVEFORMATEX, Flags: u32, MaxFrequencyRatio: f32, pCallback: ?*IXAudio2VoiceCallback, pSendList: ?*const XAUDIO2_VOICE_SENDS, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).CreateSourceVoice(@ptrCast(*const IXAudio2, self), ppSourceVoice, pSourceFormat, Flags, MaxFrequencyRatio, pCallback, pSendList, pEffectChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_CreateSubmixVoice(self: *const T, ppSubmixVoice: ?*?*IXAudio2SubmixVoice, InputChannels: u32, InputSampleRate: u32, Flags: u32, ProcessingStage: u32, pSendList: ?*const XAUDIO2_VOICE_SENDS, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).CreateSubmixVoice(@ptrCast(*const IXAudio2, self), ppSubmixVoice, InputChannels, InputSampleRate, Flags, ProcessingStage, pSendList, pEffectChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_CreateMasteringVoice(self: *const T, ppMasteringVoice: ?*?*IXAudio2MasteringVoice, InputChannels: u32, InputSampleRate: u32, Flags: u32, szDeviceId: ?[*:0]const u16, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN, StreamCategory: AUDIO_STREAM_CATEGORY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).CreateMasteringVoice(@ptrCast(*const IXAudio2, self), ppMasteringVoice, InputChannels, InputSampleRate, Flags, szDeviceId, pEffectChain, StreamCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_StartEngine(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).StartEngine(@ptrCast(*const IXAudio2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_StopEngine(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).StopEngine(@ptrCast(*const IXAudio2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_CommitChanges(self: *const T, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).CommitChanges(@ptrCast(*const IXAudio2, self), OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_GetPerformanceData(self: *const T, pPerfData: ?*XAUDIO2_PERFORMANCE_DATA) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).GetPerformanceData(@ptrCast(*const IXAudio2, self), pPerfData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2_SetDebugConfiguration(self: *const T, pDebugConfiguration: ?*const XAUDIO2_DEBUG_CONFIGURATION, pReserved: ?*anyopaque) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2.VTable, self.vtable).SetDebugConfiguration(@ptrCast(*const IXAudio2, self), pDebugConfiguration, pReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXAudio2Extension_Value = @import("../../zig.zig").Guid.initString("84ac29bb-d619-44d2-b197-e4acf7df3ed6");
pub const IID_IXAudio2Extension = &IID_IXAudio2Extension_Value;
pub const IXAudio2Extension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProcessingQuantum: fn(
            self: *const IXAudio2Extension,
            quantumNumerator: ?*u32,
            quantumDenominator: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetProcessor: fn(
            self: *const IXAudio2Extension,
            processor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Extension_GetProcessingQuantum(self: *const T, quantumNumerator: ?*u32, quantumDenominator: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Extension.VTable, self.vtable).GetProcessingQuantum(@ptrCast(*const IXAudio2Extension, self), quantumNumerator, quantumDenominator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Extension_GetProcessor(self: *const T, processor: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Extension.VTable, self.vtable).GetProcessor(@ptrCast(*const IXAudio2Extension, self), processor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2Voice = extern struct {
    pub const VTable = extern struct {
        GetVoiceDetails: fn(
            self: *const IXAudio2Voice,
            pVoiceDetails: ?*XAUDIO2_VOICE_DETAILS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetOutputVoices: fn(
            self: *const IXAudio2Voice,
            pSendList: ?*const XAUDIO2_VOICE_SENDS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectChain: fn(
            self: *const IXAudio2Voice,
            pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableEffect: fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableEffect: fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectState: fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            pEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetEffectParameters: fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            // TODO: what to do with BytesParamIndex 2?
            pParameters: ?*const anyopaque,
            ParametersByteSize: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectParameters: fn(
            self: *const IXAudio2Voice,
            EffectIndex: u32,
            // TODO: what to do with BytesParamIndex 2?
            pParameters: ?*anyopaque,
            ParametersByteSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilterParameters: fn(
            self: *const IXAudio2Voice,
            pParameters: ?*const XAUDIO2_FILTER_PARAMETERS,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterParameters: fn(
            self: *const IXAudio2Voice,
            pParameters: ?*XAUDIO2_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetOutputFilterParameters: fn(
            self: *const IXAudio2Voice,
            pDestinationVoice: ?*IXAudio2Voice,
            pParameters: ?*const XAUDIO2_FILTER_PARAMETERS,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputFilterParameters: fn(
            self: *const IXAudio2Voice,
            pDestinationVoice: ?*IXAudio2Voice,
            pParameters: ?*XAUDIO2_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetVolume: fn(
            self: *const IXAudio2Voice,
            Volume: f32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolume: fn(
            self: *const IXAudio2Voice,
            pVolume: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetChannelVolumes: fn(
            self: *const IXAudio2Voice,
            Channels: u32,
            pVolumes: [*]const f32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolumes: fn(
            self: *const IXAudio2Voice,
            Channels: u32,
            pVolumes: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetOutputMatrix: fn(
            self: *const IXAudio2Voice,
            pDestinationVoice: ?*IXAudio2Voice,
            SourceChannels: u32,
            DestinationChannels: u32,
            pLevelMatrix: ?*const f32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMatrix: fn(
            self: *const IXAudio2Voice,
            pDestinationVoice: ?*IXAudio2Voice,
            SourceChannels: u32,
            DestinationChannels: u32,
            pLevelMatrix: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DestroyVoice: fn(
            self: *const IXAudio2Voice,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_GetVoiceDetails(self: *const T, pVoiceDetails: ?*XAUDIO2_VOICE_DETAILS) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).GetVoiceDetails(@ptrCast(*const IXAudio2Voice, self), pVoiceDetails);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_SetOutputVoices(self: *const T, pSendList: ?*const XAUDIO2_VOICE_SENDS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).SetOutputVoices(@ptrCast(*const IXAudio2Voice, self), pSendList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_SetEffectChain(self: *const T, pEffectChain: ?*const XAUDIO2_EFFECT_CHAIN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).SetEffectChain(@ptrCast(*const IXAudio2Voice, self), pEffectChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_EnableEffect(self: *const T, EffectIndex: u32, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).EnableEffect(@ptrCast(*const IXAudio2Voice, self), EffectIndex, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_DisableEffect(self: *const T, EffectIndex: u32, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).DisableEffect(@ptrCast(*const IXAudio2Voice, self), EffectIndex, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_GetEffectState(self: *const T, EffectIndex: u32, pEnabled: ?*BOOL) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).GetEffectState(@ptrCast(*const IXAudio2Voice, self), EffectIndex, pEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_SetEffectParameters(self: *const T, EffectIndex: u32, pParameters: ?*const anyopaque, ParametersByteSize: u32, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).SetEffectParameters(@ptrCast(*const IXAudio2Voice, self), EffectIndex, pParameters, ParametersByteSize, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_GetEffectParameters(self: *const T, EffectIndex: u32, pParameters: ?*anyopaque, ParametersByteSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).GetEffectParameters(@ptrCast(*const IXAudio2Voice, self), EffectIndex, pParameters, ParametersByteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_SetFilterParameters(self: *const T, pParameters: ?*const XAUDIO2_FILTER_PARAMETERS, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).SetFilterParameters(@ptrCast(*const IXAudio2Voice, self), pParameters, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_GetFilterParameters(self: *const T, pParameters: ?*XAUDIO2_FILTER_PARAMETERS) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).GetFilterParameters(@ptrCast(*const IXAudio2Voice, self), pParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_SetOutputFilterParameters(self: *const T, pDestinationVoice: ?*IXAudio2Voice, pParameters: ?*const XAUDIO2_FILTER_PARAMETERS, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).SetOutputFilterParameters(@ptrCast(*const IXAudio2Voice, self), pDestinationVoice, pParameters, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_GetOutputFilterParameters(self: *const T, pDestinationVoice: ?*IXAudio2Voice, pParameters: ?*XAUDIO2_FILTER_PARAMETERS) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).GetOutputFilterParameters(@ptrCast(*const IXAudio2Voice, self), pDestinationVoice, pParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_SetVolume(self: *const T, Volume: f32, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).SetVolume(@ptrCast(*const IXAudio2Voice, self), Volume, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_GetVolume(self: *const T, pVolume: ?*f32) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).GetVolume(@ptrCast(*const IXAudio2Voice, self), pVolume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_SetChannelVolumes(self: *const T, Channels: u32, pVolumes: [*]const f32, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).SetChannelVolumes(@ptrCast(*const IXAudio2Voice, self), Channels, pVolumes, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_GetChannelVolumes(self: *const T, Channels: u32, pVolumes: [*]f32) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).GetChannelVolumes(@ptrCast(*const IXAudio2Voice, self), Channels, pVolumes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_SetOutputMatrix(self: *const T, pDestinationVoice: ?*IXAudio2Voice, SourceChannels: u32, DestinationChannels: u32, pLevelMatrix: ?*const f32, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).SetOutputMatrix(@ptrCast(*const IXAudio2Voice, self), pDestinationVoice, SourceChannels, DestinationChannels, pLevelMatrix, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_GetOutputMatrix(self: *const T, pDestinationVoice: ?*IXAudio2Voice, SourceChannels: u32, DestinationChannels: u32, pLevelMatrix: ?*f32) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).GetOutputMatrix(@ptrCast(*const IXAudio2Voice, self), pDestinationVoice, SourceChannels, DestinationChannels, pLevelMatrix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2Voice_DestroyVoice(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2Voice.VTable, self.vtable).DestroyVoice(@ptrCast(*const IXAudio2Voice, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2SourceVoice = extern struct {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
        Start: fn(
            self: *const IXAudio2SourceVoice,
            Flags: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IXAudio2SourceVoice,
            Flags: u32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubmitSourceBuffer: fn(
            self: *const IXAudio2SourceVoice,
            pBuffer: ?*const XAUDIO2_BUFFER,
            pBufferWMA: ?*const XAUDIO2_BUFFER_WMA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushSourceBuffers: fn(
            self: *const IXAudio2SourceVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Discontinuity: fn(
            self: *const IXAudio2SourceVoice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitLoop: fn(
            self: *const IXAudio2SourceVoice,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IXAudio2SourceVoice,
            pVoiceState: ?*XAUDIO2_VOICE_STATE,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetFrequencyRatio: fn(
            self: *const IXAudio2SourceVoice,
            Ratio: f32,
            OperationSet: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrequencyRatio: fn(
            self: *const IXAudio2SourceVoice,
            pRatio: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetSourceSampleRate: fn(
            self: *const IXAudio2SourceVoice,
            NewSourceSampleRate: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXAudio2Voice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_Start(self: *const T, Flags: u32, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).Start(@ptrCast(*const IXAudio2SourceVoice, self), Flags, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_Stop(self: *const T, Flags: u32, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).Stop(@ptrCast(*const IXAudio2SourceVoice, self), Flags, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_SubmitSourceBuffer(self: *const T, pBuffer: ?*const XAUDIO2_BUFFER, pBufferWMA: ?*const XAUDIO2_BUFFER_WMA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).SubmitSourceBuffer(@ptrCast(*const IXAudio2SourceVoice, self), pBuffer, pBufferWMA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_FlushSourceBuffers(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).FlushSourceBuffers(@ptrCast(*const IXAudio2SourceVoice, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_Discontinuity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).Discontinuity(@ptrCast(*const IXAudio2SourceVoice, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_ExitLoop(self: *const T, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).ExitLoop(@ptrCast(*const IXAudio2SourceVoice, self), OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_GetState(self: *const T, pVoiceState: ?*XAUDIO2_VOICE_STATE, Flags: u32) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).GetState(@ptrCast(*const IXAudio2SourceVoice, self), pVoiceState, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_SetFrequencyRatio(self: *const T, Ratio: f32, OperationSet: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).SetFrequencyRatio(@ptrCast(*const IXAudio2SourceVoice, self), Ratio, OperationSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_GetFrequencyRatio(self: *const T, pRatio: ?*f32) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).GetFrequencyRatio(@ptrCast(*const IXAudio2SourceVoice, self), pRatio);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2SourceVoice_SetSourceSampleRate(self: *const T, NewSourceSampleRate: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2SourceVoice.VTable, self.vtable).SetSourceSampleRate(@ptrCast(*const IXAudio2SourceVoice, self), NewSourceSampleRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2SubmixVoice = extern struct {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXAudio2Voice.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2MasteringVoice = extern struct {
    pub const VTable = extern struct {
        base: IXAudio2Voice.VTable,
        GetChannelMask: fn(
            self: *const IXAudio2MasteringVoice,
            pChannelmask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXAudio2Voice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2MasteringVoice_GetChannelMask(self: *const T, pChannelmask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAudio2MasteringVoice.VTable, self.vtable).GetChannelMask(@ptrCast(*const IXAudio2MasteringVoice, self), pChannelmask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2EngineCallback = extern struct {
    pub const VTable = extern struct {
        OnProcessingPassStart: fn(
            self: *const IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnProcessingPassEnd: fn(
            self: *const IXAudio2EngineCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnCriticalError: fn(
            self: *const IXAudio2EngineCallback,
            Error: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2EngineCallback_OnProcessingPassStart(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2EngineCallback.VTable, self.vtable).OnProcessingPassStart(@ptrCast(*const IXAudio2EngineCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2EngineCallback_OnProcessingPassEnd(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2EngineCallback.VTable, self.vtable).OnProcessingPassEnd(@ptrCast(*const IXAudio2EngineCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2EngineCallback_OnCriticalError(self: *const T, Error: HRESULT) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2EngineCallback.VTable, self.vtable).OnCriticalError(@ptrCast(*const IXAudio2EngineCallback, self), Error);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IXAudio2VoiceCallback = extern struct {
    pub const VTable = extern struct {
        OnVoiceProcessingPassStart: fn(
            self: *const IXAudio2VoiceCallback,
            BytesRequired: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnVoiceProcessingPassEnd: fn(
            self: *const IXAudio2VoiceCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnStreamEnd: fn(
            self: *const IXAudio2VoiceCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnBufferStart: fn(
            self: *const IXAudio2VoiceCallback,
            pBufferContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnBufferEnd: fn(
            self: *const IXAudio2VoiceCallback,
            pBufferContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnLoopEnd: fn(
            self: *const IXAudio2VoiceCallback,
            pBufferContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnVoiceError: fn(
            self: *const IXAudio2VoiceCallback,
            pBufferContext: ?*anyopaque,
            Error: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2VoiceCallback_OnVoiceProcessingPassStart(self: *const T, BytesRequired: u32) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2VoiceCallback.VTable, self.vtable).OnVoiceProcessingPassStart(@ptrCast(*const IXAudio2VoiceCallback, self), BytesRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2VoiceCallback_OnVoiceProcessingPassEnd(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2VoiceCallback.VTable, self.vtable).OnVoiceProcessingPassEnd(@ptrCast(*const IXAudio2VoiceCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2VoiceCallback_OnStreamEnd(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2VoiceCallback.VTable, self.vtable).OnStreamEnd(@ptrCast(*const IXAudio2VoiceCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2VoiceCallback_OnBufferStart(self: *const T, pBufferContext: ?*anyopaque) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2VoiceCallback.VTable, self.vtable).OnBufferStart(@ptrCast(*const IXAudio2VoiceCallback, self), pBufferContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2VoiceCallback_OnBufferEnd(self: *const T, pBufferContext: ?*anyopaque) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2VoiceCallback.VTable, self.vtable).OnBufferEnd(@ptrCast(*const IXAudio2VoiceCallback, self), pBufferContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2VoiceCallback_OnLoopEnd(self: *const T, pBufferContext: ?*anyopaque) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2VoiceCallback.VTable, self.vtable).OnLoopEnd(@ptrCast(*const IXAudio2VoiceCallback, self), pBufferContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAudio2VoiceCallback_OnVoiceError(self: *const T, pBufferContext: ?*anyopaque, Error: HRESULT) callconv(.Inline) void {
            return @ptrCast(*const IXAudio2VoiceCallback.VTable, self.vtable).OnVoiceError(@ptrCast(*const IXAudio2VoiceCallback, self), pBufferContext, Error);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_AudioVolumeMeter_Value = @import("../../zig.zig").Guid.initString("4fc3b166-972a-40cf-bc37-7db03db2fba3");
pub const CLSID_AudioVolumeMeter = &CLSID_AudioVolumeMeter_Value;

const CLSID_AudioReverb_Value = @import("../../zig.zig").Guid.initString("c2633b16-471b-4498-b8c5-4f0959e2ec09");
pub const CLSID_AudioReverb = &CLSID_AudioReverb_Value;

pub const XAUDIO2FX_VOLUMEMETER_LEVELS = packed struct {
    pPeakLevels: ?*f32,
    pRMSLevels: ?*f32,
    ChannelCount: u32,
};

pub const XAUDIO2FX_REVERB_PARAMETERS = packed struct {
    WetDryMix: f32,
    ReflectionsDelay: u32,
    ReverbDelay: u8,
    RearDelay: u8,
    SideDelay: u8,
    PositionLeft: u8,
    PositionRight: u8,
    PositionMatrixLeft: u8,
    PositionMatrixRight: u8,
    EarlyDiffusion: u8,
    LateDiffusion: u8,
    LowEQGain: u8,
    LowEQCutoff: u8,
    HighEQGain: u8,
    HighEQCutoff: u8,
    RoomFilterFreq: f32,
    RoomFilterMain: f32,
    RoomFilterHF: f32,
    ReflectionsGain: f32,
    ReverbGain: f32,
    DecayTime: f32,
    Density: f32,
    RoomSize: f32,
    DisableLateField: BOOL,
};

pub const XAUDIO2FX_REVERB_I3DL2_PARAMETERS = packed struct {
    WetDryMix: f32,
    Room: i32,
    RoomHF: i32,
    RoomRolloffFactor: f32,
    DecayTime: f32,
    DecayHFRatio: f32,
    Reflections: i32,
    ReflectionsDelay: f32,
    Reverb: i32,
    ReverbDelay: f32,
    Diffusion: f32,
    Density: f32,
    HFReference: f32,
};

pub const HrtfPosition = extern struct {
    x: f32,
    y: f32,
    z: f32,
};

pub const HrtfOrientation = extern struct {
    element: [9]f32,
};

pub const HrtfDirectivityType = enum(i32) {
    OmniDirectional = 0,
    Cardioid = 1,
    Cone = 2,
};
pub const OmniDirectional = HrtfDirectivityType.OmniDirectional;
pub const Cardioid = HrtfDirectivityType.Cardioid;
pub const Cone = HrtfDirectivityType.Cone;

pub const HrtfEnvironment = enum(i32) {
    Small = 0,
    Medium = 1,
    Large = 2,
    Outdoors = 3,
};
pub const Small = HrtfEnvironment.Small;
pub const Medium = HrtfEnvironment.Medium;
pub const Large = HrtfEnvironment.Large;
pub const Outdoors = HrtfEnvironment.Outdoors;

pub const HrtfDirectivity = extern struct {
    type: HrtfDirectivityType,
    scaling: f32,
};

pub const HrtfDirectivityCardioid = extern struct {
    directivity: HrtfDirectivity,
    order: f32,
};

pub const HrtfDirectivityCone = extern struct {
    directivity: HrtfDirectivity,
    innerAngle: f32,
    outerAngle: f32,
};

pub const HrtfDistanceDecayType = enum(i32) {
    NaturalDecay = 0,
    CustomDecay = 1,
};
pub const NaturalDecay = HrtfDistanceDecayType.NaturalDecay;
pub const CustomDecay = HrtfDistanceDecayType.CustomDecay;

pub const HrtfDistanceDecay = extern struct {
    type: HrtfDistanceDecayType,
    maxGain: f32,
    minGain: f32,
    unityGainDistance: f32,
    cutoffDistance: f32,
};

pub const HrtfApoInit = extern struct {
    distanceDecay: ?*HrtfDistanceDecay,
    directivity: ?*HrtfDirectivity,
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IXAPOHrtfParameters_Value = @import("../../zig.zig").Guid.initString("15b3cd66-e9de-4464-b6e6-2bc3cf63d455");
pub const IID_IXAPOHrtfParameters = &IID_IXAPOHrtfParameters_Value;
pub const IXAPOHrtfParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSourcePosition: fn(
            self: *const IXAPOHrtfParameters,
            position: ?*const HrtfPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceOrientation: fn(
            self: *const IXAPOHrtfParameters,
            orientation: ?*const HrtfOrientation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceGain: fn(
            self: *const IXAPOHrtfParameters,
            gain: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnvironment: fn(
            self: *const IXAPOHrtfParameters,
            environment: HrtfEnvironment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPOHrtfParameters_SetSourcePosition(self: *const T, position: ?*const HrtfPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAPOHrtfParameters.VTable, self.vtable).SetSourcePosition(@ptrCast(*const IXAPOHrtfParameters, self), position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPOHrtfParameters_SetSourceOrientation(self: *const T, orientation: ?*const HrtfOrientation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAPOHrtfParameters.VTable, self.vtable).SetSourceOrientation(@ptrCast(*const IXAPOHrtfParameters, self), orientation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPOHrtfParameters_SetSourceGain(self: *const T, gain: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAPOHrtfParameters.VTable, self.vtable).SetSourceGain(@ptrCast(*const IXAPOHrtfParameters, self), gain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXAPOHrtfParameters_SetEnvironment(self: *const T, environment: HrtfEnvironment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXAPOHrtfParameters.VTable, self.vtable).SetEnvironment(@ptrCast(*const IXAPOHrtfParameters, self), environment);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (5)
//--------------------------------------------------------------------------------
pub extern "XAudio2_8" fn CreateFX(
    clsid: ?*const Guid,
    pEffect: ?*?*IUnknown,
    // TODO: what to do with BytesParamIndex 3?
    pInitDat: ?*const anyopaque,
    InitDataByteSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XAudio2_8" fn XAudio2CreateWithVersionInfo(
    ppXAudio2: ?*?*IXAudio2,
    Flags: u32,
    XAudio2Processor: u32,
    ntddiVersion: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XAudio2_8" fn CreateAudioVolumeMeter(
    ppApo: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XAudio2_8" fn CreateAudioReverb(
    ppApo: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "HrtfApo" fn CreateHrtfApo(
    init: ?*const HrtfApoInit,
    xApo: ?*?*IXAPO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const AUDIO_STREAM_CATEGORY = @import("../../media/audio.zig").AUDIO_STREAM_CATEGORY;
const BOOL = @import("../../foundation.zig").BOOL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IUnknown = @import("../../system/com.zig").IUnknown;
const PWSTR = @import("../../foundation.zig").PWSTR;
const WAVEFORMATEX = @import("../../media/audio.zig").WAVEFORMATEX;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
