//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1007)
//--------------------------------------------------------------------------------
pub const EC_SND_DEVICE_ERROR_BASE = @as(u32, 512);
pub const EC_SNDDEV_IN_ERROR = @as(u32, 512);
pub const EC_SNDDEV_OUT_ERROR = @as(u32, 513);
pub const EC_SYSTEMBASE = @as(u32, 0);
pub const EC_USER = @as(u32, 32768);
pub const EC_COMPLETE = @as(u32, 1);
pub const EC_USERABORT = @as(u32, 2);
pub const EC_ERRORABORT = @as(u32, 3);
pub const EC_TIME = @as(u32, 4);
pub const EC_REPAINT = @as(u32, 5);
pub const EC_STREAM_ERROR_STOPPED = @as(u32, 6);
pub const EC_STREAM_ERROR_STILLPLAYING = @as(u32, 7);
pub const EC_ERROR_STILLPLAYING = @as(u32, 8);
pub const EC_PALETTE_CHANGED = @as(u32, 9);
pub const EC_VIDEO_SIZE_CHANGED = @as(u32, 10);
pub const EC_QUALITY_CHANGE = @as(u32, 11);
pub const EC_SHUTTING_DOWN = @as(u32, 12);
pub const EC_CLOCK_CHANGED = @as(u32, 13);
pub const EC_PAUSED = @as(u32, 14);
pub const EC_OPENING_FILE = @as(u32, 16);
pub const EC_BUFFERING_DATA = @as(u32, 17);
pub const EC_FULLSCREEN_LOST = @as(u32, 18);
pub const EC_ACTIVATE = @as(u32, 19);
pub const EC_NEED_RESTART = @as(u32, 20);
pub const EC_WINDOW_DESTROYED = @as(u32, 21);
pub const EC_DISPLAY_CHANGED = @as(u32, 22);
pub const EC_STARVATION = @as(u32, 23);
pub const EC_OLE_EVENT = @as(u32, 24);
pub const EC_NOTIFY_WINDOW = @as(u32, 25);
pub const EC_STREAM_CONTROL_STOPPED = @as(u32, 26);
pub const EC_STREAM_CONTROL_STARTED = @as(u32, 27);
pub const EC_END_OF_SEGMENT = @as(u32, 28);
pub const EC_SEGMENT_STARTED = @as(u32, 29);
pub const EC_LENGTH_CHANGED = @as(u32, 30);
pub const EC_DEVICE_LOST = @as(u32, 31);
pub const EC_SAMPLE_NEEDED = @as(u32, 32);
pub const EC_PROCESSING_LATENCY = @as(u32, 33);
pub const EC_SAMPLE_LATENCY = @as(u32, 34);
pub const EC_SCRUB_TIME = @as(u32, 35);
pub const EC_STEP_COMPLETE = @as(u32, 36);
pub const EC_TIMECODE_AVAILABLE = @as(u32, 48);
pub const EC_EXTDEVICE_MODE_CHANGE = @as(u32, 49);
pub const EC_STATE_CHANGE = @as(u32, 50);
pub const EC_GRAPH_CHANGED = @as(u32, 80);
pub const EC_CLOCK_UNSET = @as(u32, 81);
pub const EC_VMR_RENDERDEVICE_SET = @as(u32, 83);
pub const VMR_RENDER_DEVICE_OVERLAY = @as(u32, 1);
pub const VMR_RENDER_DEVICE_VIDMEM = @as(u32, 2);
pub const VMR_RENDER_DEVICE_SYSMEM = @as(u32, 4);
pub const EC_VMR_SURFACE_FLIPPED = @as(u32, 84);
pub const EC_VMR_RECONNECTION_FAILED = @as(u32, 85);
pub const EC_PREPROCESS_COMPLETE = @as(u32, 86);
pub const EC_CODECAPI_EVENT = @as(u32, 87);
pub const EC_WMT_EVENT_BASE = @as(u32, 593);
pub const EC_WMT_INDEX_EVENT = @as(u32, 593);
pub const EC_WMT_EVENT = @as(u32, 594);
pub const EC_BUILT = @as(u32, 768);
pub const EC_UNBUILT = @as(u32, 769);
pub const EC_SKIP_FRAMES = @as(u32, 37);
pub const EC_PLEASE_REOPEN = @as(u32, 64);
pub const EC_STATUS = @as(u32, 65);
pub const EC_MARKER_HIT = @as(u32, 66);
pub const EC_LOADSTATUS = @as(u32, 67);
pub const EC_FILE_CLOSED = @as(u32, 68);
pub const EC_ERRORABORTEX = @as(u32, 69);
pub const AM_LOADSTATUS_CLOSED = @as(u32, 0);
pub const AM_LOADSTATUS_LOADINGDESCR = @as(u32, 1);
pub const AM_LOADSTATUS_LOADINGMCAST = @as(u32, 2);
pub const AM_LOADSTATUS_LOCATING = @as(u32, 3);
pub const AM_LOADSTATUS_CONNECTING = @as(u32, 4);
pub const AM_LOADSTATUS_OPENING = @as(u32, 5);
pub const AM_LOADSTATUS_OPEN = @as(u32, 6);
pub const EC_NEW_PIN = @as(u32, 32);
pub const EC_RENDER_FINISHED = @as(u32, 33);
pub const EC_EOS_SOON = @as(u32, 70);
pub const EC_CONTENTPROPERTY_CHANGED = @as(u32, 71);
pub const AM_CONTENTPROPERTY_TITLE = @as(u32, 1);
pub const AM_CONTENTPROPERTY_AUTHOR = @as(u32, 2);
pub const AM_CONTENTPROPERTY_COPYRIGHT = @as(u32, 4);
pub const AM_CONTENTPROPERTY_DESCRIPTION = @as(u32, 8);
pub const EC_BANDWIDTHCHANGE = @as(u32, 72);
pub const EC_VIDEOFRAMEREADY = @as(u32, 73);
pub const EC_DVDBASE = @as(u32, 256);
pub const EC_DVD_DOMAIN_CHANGE = @as(u32, 257);
pub const EC_DVD_TITLE_CHANGE = @as(u32, 258);
pub const EC_DVD_CHAPTER_START = @as(u32, 259);
pub const EC_DVD_AUDIO_STREAM_CHANGE = @as(u32, 260);
pub const EC_DVD_SUBPICTURE_STREAM_CHANGE = @as(u32, 261);
pub const EC_DVD_ANGLE_CHANGE = @as(u32, 262);
pub const EC_DVD_BUTTON_CHANGE = @as(u32, 263);
pub const EC_DVD_VALID_UOPS_CHANGE = @as(u32, 264);
pub const EC_DVD_STILL_ON = @as(u32, 265);
pub const EC_DVD_STILL_OFF = @as(u32, 266);
pub const EC_DVD_CURRENT_TIME = @as(u32, 267);
pub const EC_DVD_ERROR = @as(u32, 268);
pub const EC_DVD_WARNING = @as(u32, 269);
pub const EC_DVD_CHAPTER_AUTOSTOP = @as(u32, 270);
pub const EC_DVD_NO_FP_PGC = @as(u32, 271);
pub const EC_DVD_PLAYBACK_RATE_CHANGE = @as(u32, 272);
pub const EC_DVD_PARENTAL_LEVEL_CHANGE = @as(u32, 273);
pub const EC_DVD_PLAYBACK_STOPPED = @as(u32, 274);
pub const EC_DVD_ANGLES_AVAILABLE = @as(u32, 275);
pub const EC_DVD_PLAYPERIOD_AUTOSTOP = @as(u32, 276);
pub const EC_DVD_BUTTON_AUTO_ACTIVATED = @as(u32, 277);
pub const EC_DVD_CMD_START = @as(u32, 278);
pub const EC_DVD_CMD_END = @as(u32, 279);
pub const EC_DVD_DISC_EJECTED = @as(u32, 280);
pub const EC_DVD_DISC_INSERTED = @as(u32, 281);
pub const EC_DVD_CURRENT_HMSF_TIME = @as(u32, 282);
pub const EC_DVD_KARAOKE_MODE = @as(u32, 283);
pub const EC_DVD_PROGRAM_CELL_CHANGE = @as(u32, 284);
pub const EC_DVD_TITLE_SET_CHANGE = @as(u32, 285);
pub const EC_DVD_PROGRAM_CHAIN_CHANGE = @as(u32, 286);
pub const EC_DVD_VOBU_Offset = @as(u32, 287);
pub const EC_DVD_VOBU_Timestamp = @as(u32, 288);
pub const EC_DVD_GPRM_Change = @as(u32, 289);
pub const EC_DVD_SPRM_Change = @as(u32, 290);
pub const EC_DVD_BeginNavigationCommands = @as(u32, 291);
pub const EC_DVD_NavigationCommand = @as(u32, 292);
pub const AM_AC3_ALTERNATE_AUDIO_1 = @as(u32, 1);
pub const AM_AC3_ALTERNATE_AUDIO_2 = @as(u32, 2);
pub const AM_AC3_ALTERNATE_AUDIO_BOTH = @as(u32, 3);
pub const AM_AC3_SERVICE_MAIN_AUDIO = @as(u32, 0);
pub const AM_AC3_SERVICE_NO_DIALOG = @as(u32, 1);
pub const AM_AC3_SERVICE_VISUALLY_IMPAIRED = @as(u32, 2);
pub const AM_AC3_SERVICE_HEARING_IMPAIRED = @as(u32, 3);
pub const AM_AC3_SERVICE_DIALOG_ONLY = @as(u32, 4);
pub const AM_AC3_SERVICE_COMMENTARY = @as(u32, 5);
pub const AM_AC3_SERVICE_EMERGENCY_FLASH = @as(u32, 6);
pub const AM_AC3_SERVICE_VOICE_OVER = @as(u32, 7);
pub const AM_UseNewCSSKey = @as(u32, 1);
pub const AM_ReverseBlockStart = @as(u32, 2);
pub const AM_ReverseBlockEnd = @as(u32, 4);
pub const AM_DVD_CGMS_RESERVED_MASK = @as(u32, 120);
pub const AM_DVD_CGMS_COPY_PROTECT_MASK = @as(u32, 24);
pub const AM_DVD_CGMS_COPY_PERMITTED = @as(u32, 0);
pub const AM_DVD_CGMS_COPY_ONCE = @as(u32, 16);
pub const AM_DVD_CGMS_NO_COPY = @as(u32, 24);
pub const AM_DVD_COPYRIGHT_MASK = @as(u32, 64);
pub const AM_DVD_NOT_COPYRIGHTED = @as(u32, 0);
pub const AM_DVD_COPYRIGHTED = @as(u32, 64);
pub const AM_DVD_SECTOR_PROTECT_MASK = @as(u32, 32);
pub const AM_DVD_SECTOR_NOT_PROTECTED = @as(u32, 0);
pub const AM_DVD_SECTOR_PROTECTED = @as(u32, 32);
pub const AMINTERLACE_IsInterlaced = @as(u32, 1);
pub const AMINTERLACE_1FieldPerSample = @as(u32, 2);
pub const AMINTERLACE_Field1First = @as(u32, 4);
pub const AMINTERLACE_UNUSED = @as(u32, 8);
pub const AMINTERLACE_FieldPatternMask = @as(u32, 48);
pub const AMINTERLACE_FieldPatField1Only = @as(u32, 0);
pub const AMINTERLACE_FieldPatField2Only = @as(u32, 16);
pub const AMINTERLACE_FieldPatBothRegular = @as(u32, 32);
pub const AMINTERLACE_FieldPatBothIrregular = @as(u32, 48);
pub const AMINTERLACE_DisplayModeMask = @as(u32, 192);
pub const AMINTERLACE_DisplayModeBobOnly = @as(u32, 0);
pub const AMINTERLACE_DisplayModeWeaveOnly = @as(u32, 64);
pub const AMINTERLACE_DisplayModeBobOrWeave = @as(u32, 128);
pub const AMCOPYPROTECT_RestrictDuplication = @as(u32, 1);
pub const AMCONTROL_USED = @as(u32, 1);
pub const AMCONTROL_PAD_TO_4x3 = @as(u32, 2);
pub const AMCONTROL_PAD_TO_16x9 = @as(u32, 4);
pub const AMCONTROL_COLORINFO_PRESENT = @as(u32, 128);
pub const AM_VIDEO_FLAG_FIELD_MASK = @as(i32, 3);
pub const AM_VIDEO_FLAG_INTERLEAVED_FRAME = @as(i32, 0);
pub const AM_VIDEO_FLAG_FIELD1 = @as(i32, 1);
pub const AM_VIDEO_FLAG_FIELD2 = @as(i32, 2);
pub const AM_VIDEO_FLAG_FIELD1FIRST = @as(i32, 4);
pub const AM_VIDEO_FLAG_WEAVE = @as(i32, 8);
pub const AM_VIDEO_FLAG_IPB_MASK = @as(i32, 48);
pub const AM_VIDEO_FLAG_I_SAMPLE = @as(i32, 0);
pub const AM_VIDEO_FLAG_P_SAMPLE = @as(i32, 16);
pub const AM_VIDEO_FLAG_B_SAMPLE = @as(i32, 32);
pub const AM_VIDEO_FLAG_REPEAT_FIELD = @as(i32, 64);
pub const AVIF_HASINDEX = @as(u32, 16);
pub const AVIF_MUSTUSEINDEX = @as(u32, 32);
pub const AVIF_ISINTERLEAVED = @as(u32, 256);
pub const AVIF_TRUSTCKTYPE = @as(u32, 2048);
pub const AVIF_WASCAPTUREFILE = @as(u32, 65536);
pub const AVIF_COPYRIGHTED = @as(u32, 131072);
pub const AVI_HEADERSIZE = @as(u32, 2048);
pub const AVISF_DISABLED = @as(u32, 1);
pub const AVISF_VIDEO_PALCHANGES = @as(u32, 65536);
pub const AVIIF_LIST = @as(i32, 1);
pub const AVIIF_KEYFRAME = @as(i32, 16);
pub const AVIIF_FIRSTPART = @as(i32, 32);
pub const AVIIF_LASTPART = @as(i32, 64);
pub const AVIIF_NOTIME = @as(i32, 256);
pub const AVIIF_COMPUSE = @as(i32, 268369920);
pub const AVIIF_NO_TIME = @as(u32, 256);
pub const AVIIF_COMPRESSOR = @as(u32, 268369920);
pub const TIMECODE_RATE_30DROP = @as(u32, 0);
pub const TIMECODE_SMPTE_BINARY_GROUP = @as(u32, 7);
pub const TIMECODE_SMPTE_COLOR_FRAME = @as(u32, 8);
pub const AVI_INDEX_OF_INDEXES = @as(u32, 0);
pub const AVI_INDEX_OF_CHUNKS = @as(u32, 1);
pub const AVI_INDEX_OF_TIMED_CHUNKS = @as(u32, 2);
pub const AVI_INDEX_OF_SUB_2FIELD = @as(u32, 3);
pub const AVI_INDEX_IS_DATA = @as(u32, 128);
pub const AVI_INDEX_SUB_DEFAULT = @as(u32, 0);
pub const AVI_INDEX_SUB_2FIELD = @as(u32, 1);
pub const STDINDEXSIZE = @as(u32, 16384);
pub const AVISTDINDEX_DELTAFRAME = @as(u32, 2147483648);
pub const AMVA_TYPEINDEX_OUTPUTFRAME = @as(u32, 4294967295);
pub const AMVA_QUERYRENDERSTATUSF_READ = @as(u32, 1);
pub const MIN_DIMENSION = @as(u32, 1);
pub const BDA_PLP_ID_NOT_SET = @as(i32, -1);
pub const CDEF_CLASS_DEFAULT = @as(u32, 1);
pub const CDEF_BYPASS_CLASS_MANAGER = @as(u32, 2);
pub const CDEF_MERIT_ABOVE_DO_NOT_USE = @as(u32, 8);
pub const CDEF_DEVMON_CMGR_DEVICE = @as(u32, 16);
pub const CDEF_DEVMON_DMO = @as(u32, 32);
pub const CDEF_DEVMON_PNP_DEVICE = @as(u32, 64);
pub const CDEF_DEVMON_FILTER = @as(u32, 128);
pub const CDEF_DEVMON_SELECTIVE_MASK = @as(u32, 240);
pub const CHARS_IN_GUID = @as(u32, 39);
pub const MAX_PIN_NAME = @as(u32, 128);
pub const MAX_FILTER_NAME = @as(u32, 128);
pub const AM_GBF_PREVFRAMESKIPPED = @as(u32, 1);
pub const AM_GBF_NOTASYNCPOINT = @as(u32, 2);
pub const AM_GBF_NOWAIT = @as(u32, 4);
pub const AM_GBF_NODDSURFACELOCK = @as(u32, 8);
pub const AMF_AUTOMATICGAIN = @as(f64, -1);
pub const AnalogVideo_NTSC_Mask = @as(u32, 7);
pub const AnalogVideo_PAL_Mask = @as(u32, 1052656);
pub const AnalogVideo_SECAM_Mask = @as(u32, 1044480);
pub const MPEG2_PROGRAM_STREAM_MAP = @as(u32, 0);
pub const MPEG2_PROGRAM_ELEMENTARY_STREAM = @as(u32, 1);
pub const MPEG2_PROGRAM_DIRECTORY_PES_PACKET = @as(u32, 2);
pub const MPEG2_PROGRAM_PACK_HEADER = @as(u32, 3);
pub const MPEG2_PROGRAM_PES_STREAM = @as(u32, 4);
pub const MPEG2_PROGRAM_SYSTEM_HEADER = @as(u32, 5);
pub const SUBSTREAM_FILTER_VAL_NONE = @as(u32, 268435456);
pub const AM_GETDECODERCAP_QUERY_VMR_SUPPORT = @as(u32, 1);
pub const VMR_NOTSUPPORTED = @as(u32, 0);
pub const VMR_SUPPORTED = @as(u32, 1);
pub const AM_QUERY_DECODER_VMR_SUPPORT = @as(u32, 1);
pub const AM_QUERY_DECODER_DXVA_1_SUPPORT = @as(u32, 2);
pub const AM_QUERY_DECODER_DVD_SUPPORT = @as(u32, 3);
pub const AM_QUERY_DECODER_ATSC_SD_SUPPORT = @as(u32, 4);
pub const AM_QUERY_DECODER_ATSC_HD_SUPPORT = @as(u32, 5);
pub const AM_GETDECODERCAP_QUERY_VMR9_SUPPORT = @as(u32, 6);
pub const AM_GETDECODERCAP_QUERY_EVR_SUPPORT = @as(u32, 7);
pub const DECODER_CAP_NOTSUPPORTED = @as(u32, 0);
pub const DECODER_CAP_SUPPORTED = @as(u32, 1);
pub const VMRBITMAP_DISABLE = @as(u32, 1);
pub const VMRBITMAP_HDC = @as(u32, 2);
pub const VMRBITMAP_ENTIREDDS = @as(u32, 4);
pub const VMRBITMAP_SRCCOLORKEY = @as(u32, 8);
pub const VMRBITMAP_SRCRECT = @as(u32, 16);
pub const DVD_TITLE_MENU = @as(u32, 0);
pub const DVD_STREAM_DATA_CURRENT = @as(u32, 2048);
pub const DVD_STREAM_DATA_VMGM = @as(u32, 1024);
pub const DVD_STREAM_DATA_VTSM = @as(u32, 1025);
pub const DVD_DEFAULT_AUDIO_STREAM = @as(u32, 15);
pub const DVD_AUDIO_CAPS_AC3 = @as(u32, 1);
pub const DVD_AUDIO_CAPS_MPEG2 = @as(u32, 2);
pub const DVD_AUDIO_CAPS_LPCM = @as(u32, 4);
pub const DVD_AUDIO_CAPS_DTS = @as(u32, 8);
pub const DVD_AUDIO_CAPS_SDDS = @as(u32, 16);
pub const MEDIATYPE_MPEG2_PACK = Guid.initString("36523b13-8ee5-11d1-8ca3-0060b057664a");
pub const PBDA_AUX_CONNECTOR_TYPE_SVideo = Guid.initString("a0e905f4-24c9-4a54-b761-213355efc13a");
pub const PBDA_AUX_CONNECTOR_TYPE_Composite = Guid.initString("f6298b4c-c725-4d42-849b-410bbb14ea62");
pub const CLSID_PBDA_AUX_DATA_TYPE = Guid.initString("fd456373-3323-4090-adca-8ed45f55cf10");
pub const CLSID_PBDA_Encoder_DATA_TYPE = Guid.initString("728fd6bc-5546-4716-b103-f899f5a1fa68");
pub const PBDA_Encoder_Audio_AlgorithmType_MPEG1LayerII = @as(u32, 0);
pub const PBDA_Encoder_Audio_AlgorithmType_AC3 = @as(u32, 1);
pub const PBDA_Encoder_Video_MPEG2PartII = @as(u32, 0);
pub const PBDA_Encoder_Video_MPEG4Part10 = @as(u32, 1);
pub const PBDA_Encoder_Video_AVC = @as(u32, 1);
pub const PBDA_Encoder_Video_H264 = @as(u32, 1);
pub const PBDA_Encoder_BitrateMode_Constant = @as(u32, 1);
pub const PBDA_Encoder_BitrateMode_Variable = @as(u32, 2);
pub const PBDA_Encoder_BitrateMode_Average = @as(u32, 3);
pub const CLSID_PBDA_FDC_DATA_TYPE = Guid.initString("e7dbf9a0-22ab-4047-8e67-ef9ad504e729");
pub const CLSID_PBDA_GDDS_DATA_TYPE = Guid.initString("c80c0df3-6052-4c16-9f56-c44c21f73c45");
pub const LIBID_QuartzNetTypeLib = Guid.initString("56a868b1-0ad4-11ce-b03a-0020af0ba770");
pub const LIBID_QuartzTypeLib = Guid.initString("56a868b0-0ad4-11ce-b03a-0020af0ba770");
pub const CLSID_AMMultiMediaStream = Guid.initString("49c47ce5-9ba4-11d0-8212-00c04fc32c45");
pub const CLSID_AMDirectDrawStream = Guid.initString("49c47ce4-9ba4-11d0-8212-00c04fc32c45");
pub const CLSID_AMAudioStream = Guid.initString("8496e040-af4c-11d0-8212-00c04fc32c45");
pub const CLSID_AMAudioData = Guid.initString("f2468580-af8a-11d0-8212-00c04fc32c45");
pub const CLSID_AMMediaTypeStream = Guid.initString("cf0f2f7c-f7bf-11d0-900d-00c04fd9189d");
pub const AMDDS_NONE = @as(u32, 0);
pub const AMDDS_DCIPS = @as(u32, 1);
pub const AMDDS_PS = @as(u32, 2);
pub const AMDDS_RGBOVR = @as(u32, 4);
pub const AMDDS_YUVOVR = @as(u32, 8);
pub const AMDDS_RGBOFF = @as(u32, 16);
pub const AMDDS_YUVOFF = @as(u32, 32);
pub const AMDDS_RGBFLP = @as(u32, 64);
pub const AMDDS_YUVFLP = @as(u32, 128);
pub const AMDDS_ALL = @as(u32, 255);
pub const AMDDS_DEFAULT = @as(u32, 255);
pub const MAX_SIZE_MPEG1_SEQUENCE_INFO = @as(u32, 140);
pub const CLSID_DMOWrapperFilter = Guid.initString("94297043-bd82-4dfd-b0de-8177739c6d20");
pub const CLSID_DMOFilterCategory = Guid.initString("bcd5796c-bd52-4d30-ab76-70f975b89199");
pub const AM_MPEG_AUDIO_DUAL_MERGE = @as(u32, 0);
pub const AM_MPEG_AUDIO_DUAL_LEFT = @as(u32, 1);
pub const AM_MPEG_AUDIO_DUAL_RIGHT = @as(u32, 2);
pub const VFW_FIRST_CODE = @as(u32, 512);
pub const MAX_ERROR_TEXT_LEN = @as(u32, 160);
pub const MPBOOL_TRUE = @as(u32, 1);
pub const MPBOOL_FALSE = @as(u32, 0);
pub const DWORD_ALLPARAMS = @as(i32, -1);
pub const GUID_TIME_REFERENCE = Guid.initString("93ad712b-daa0-4ffe-bc81-b0ce500fcdd9");
pub const GUID_TIME_MUSIC = Guid.initString("0574c49d-5b04-4b15-a542-ae282030117b");
pub const GUID_TIME_SAMPLES = Guid.initString("a8593d05-0c43-4984-9a63-97af9e02c4c0");
pub const MPF_ENVLP_STANDARD = @as(u32, 0);
pub const MPF_ENVLP_BEGIN_CURRENTVAL = @as(u32, 1);
pub const MPF_ENVLP_BEGIN_NEUTRALVAL = @as(u32, 2);
pub const MPF_PUNCHIN_REFTIME = @as(u32, 0);
pub const MPF_PUNCHIN_NOW = @as(u32, 1);
pub const MPF_PUNCHIN_STOPPED = @as(u32, 2);
pub const MSPID_PrimaryVideo = Guid.initString("a35ff56a-9fda-11d0-8fdf-00c04fd9189d");
pub const MSPID_PrimaryAudio = Guid.initString("a35ff56b-9fda-11d0-8fdf-00c04fd9189d");
pub const VFW_E_INVALIDMEDIATYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const VFW_E_INVALIDSUBTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const VFW_E_NEED_OWNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const VFW_E_ENUM_OUT_OF_SYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const VFW_E_ALREADY_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const VFW_E_FILTER_ACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const VFW_E_NO_TYPES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const VFW_E_NO_ACCEPTABLE_TYPES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const VFW_E_INVALID_DIRECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const VFW_E_NOT_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const VFW_E_NO_ALLOCATOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const VFW_E_RUNTIME_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const VFW_E_BUFFER_NOTSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const VFW_E_BUFFER_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const VFW_E_BADALIGN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const VFW_E_ALREADY_COMMITTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const VFW_E_BUFFERS_OUTSTANDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const VFW_E_NOT_COMMITTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const VFW_E_SIZENOTSET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const VFW_E_NO_CLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const VFW_E_NO_SINK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const VFW_E_NO_INTERFACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const VFW_E_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const VFW_E_CANNOT_CONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const VFW_E_CANNOT_RENDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220968));
pub const VFW_E_CHANGING_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const VFW_E_NO_COLOR_KEY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220966));
pub const VFW_E_NOT_OVERLAY_CONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const VFW_E_NOT_SAMPLE_CONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220964));
pub const VFW_E_PALETTE_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220963));
pub const VFW_E_COLOR_KEY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220962));
pub const VFW_E_NO_COLOR_KEY_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220961));
pub const VFW_E_NO_PALETTE_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220960));
pub const VFW_E_NO_DISPLAY_PALETTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220959));
pub const VFW_E_TOO_MANY_COLORS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220958));
pub const VFW_E_STATE_CHANGED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220957));
pub const VFW_E_NOT_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220956));
pub const VFW_E_NOT_PAUSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220955));
pub const VFW_E_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220954));
pub const VFW_E_WRONG_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220953));
pub const VFW_E_START_TIME_AFTER_END = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220952));
pub const VFW_E_INVALID_RECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220951));
pub const VFW_E_TYPE_NOT_ACCEPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220950));
pub const VFW_E_SAMPLE_REJECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220949));
pub const VFW_E_SAMPLE_REJECTED_EOS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220948));
pub const VFW_E_DUPLICATE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220947));
pub const VFW_S_DUPLICATE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262701));
pub const VFW_E_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220946));
pub const VFW_E_INVALID_FILE_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220945));
pub const VFW_E_ENUM_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220944));
pub const VFW_E_CIRCULAR_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220943));
pub const VFW_E_NOT_ALLOWED_TO_SAVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220942));
pub const VFW_E_TIME_ALREADY_PASSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220941));
pub const VFW_E_ALREADY_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220940));
pub const VFW_E_CORRUPT_GRAPH_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220939));
pub const VFW_E_ADVISE_ALREADY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220938));
pub const VFW_S_STATE_INTERMEDIATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262711));
pub const VFW_E_NO_MODEX_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220936));
pub const VFW_E_NO_ADVISE_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220935));
pub const VFW_E_NO_FULLSCREEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220934));
pub const VFW_E_IN_FULLSCREEN_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220933));
pub const VFW_E_UNKNOWN_FILE_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220928));
pub const VFW_E_CANNOT_LOAD_SOURCE_FILTER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220927));
pub const VFW_S_PARTIAL_RENDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262722));
pub const VFW_E_FILE_TOO_SHORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220925));
pub const VFW_E_INVALID_FILE_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220924));
pub const VFW_S_SOME_DATA_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262725));
pub const VFW_S_CONNECTIONS_DEFERRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262726));
pub const VFW_E_INVALID_CLSID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220921));
pub const VFW_E_INVALID_MEDIA_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220920));
pub const VFW_E_BAD_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220494));
pub const VFW_S_NO_MORE_ITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262403));
pub const VFW_E_SAMPLE_TIME_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220919));
pub const VFW_S_RESOURCE_NOT_NEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262736));
pub const VFW_E_MEDIA_TIME_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220911));
pub const VFW_E_NO_TIME_FORMAT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220910));
pub const VFW_E_MONO_AUDIO_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220909));
pub const VFW_S_MEDIA_TYPE_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262740));
pub const VFW_E_NO_DECOMPRESSOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220907));
pub const VFW_E_NO_AUDIO_HARDWARE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220906));
pub const VFW_S_VIDEO_NOT_RENDERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262743));
pub const VFW_S_AUDIO_NOT_RENDERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262744));
pub const VFW_E_RPZA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220903));
pub const VFW_S_RPZA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262746));
pub const VFW_E_PROCESSOR_NOT_SUITABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220901));
pub const VFW_E_UNSUPPORTED_AUDIO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220900));
pub const VFW_E_UNSUPPORTED_VIDEO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220899));
pub const VFW_E_MPEG_NOT_CONSTRAINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220898));
pub const VFW_E_NOT_IN_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220897));
pub const VFW_S_ESTIMATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262752));
pub const VFW_E_NO_TIME_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220895));
pub const VFW_E_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220894));
pub const VFW_S_RESERVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262755));
pub const VFW_E_BUFFER_UNDERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220892));
pub const VFW_E_UNSUPPORTED_STREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220891));
pub const VFW_E_NO_TRANSPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220890));
pub const VFW_S_STREAM_OFF = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262759));
pub const VFW_S_CANT_CUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262760));
pub const VFW_E_BAD_VIDEOCD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220887));
pub const VFW_S_NO_STOP_TIME = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262768));
pub const VFW_E_OUT_OF_VIDEO_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220879));
pub const VFW_E_VP_NEGOTIATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220878));
pub const VFW_E_DDRAW_CAPS_NOT_SUITABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220877));
pub const VFW_E_NO_VP_HARDWARE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220876));
pub const VFW_E_NO_CAPTURE_HARDWARE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220875));
pub const VFW_E_DVD_OPERATION_INHIBITED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220874));
pub const VFW_E_DVD_INVALIDDOMAIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220873));
pub const VFW_E_DVD_NO_BUTTON = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220872));
pub const VFW_E_DVD_GRAPHNOTREADY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220871));
pub const VFW_E_DVD_RENDERFAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220870));
pub const VFW_E_DVD_DECNOTENOUGH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220869));
pub const VFW_E_DDRAW_VERSION_NOT_SUITABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220868));
pub const VFW_E_COPYPROT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220867));
pub const VFW_S_NOPREVIEWPIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262782));
pub const VFW_E_TIME_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220865));
pub const VFW_S_DVD_NON_ONE_SEQUENTIAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262784));
pub const VFW_E_DVD_WRONG_SPEED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220863));
pub const VFW_E_DVD_MENU_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220862));
pub const VFW_E_DVD_CMD_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220861));
pub const VFW_E_DVD_STATE_WRONG_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220860));
pub const VFW_E_DVD_STATE_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220859));
pub const VFW_E_DVD_STATE_WRONG_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220858));
pub const VFW_E_DVD_INCOMPATIBLE_REGION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220857));
pub const VFW_E_DVD_NO_ATTRIBUTES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220856));
pub const VFW_E_DVD_NO_GOUP_PGC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220855));
pub const VFW_E_DVD_LOW_PARENTAL_LEVEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220854));
pub const VFW_E_DVD_NOT_IN_KARAOKE_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220853));
pub const VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262796));
pub const VFW_S_DVD_NOT_ACCURATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262797));
pub const VFW_E_FRAME_STEP_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220850));
pub const VFW_E_DVD_STREAM_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220849));
pub const VFW_E_DVD_TITLE_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220848));
pub const VFW_E_DVD_INVALID_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220847));
pub const VFW_E_DVD_NO_RESUME_INFORMATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220846));
pub const VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220845));
pub const VFW_E_PIN_ALREADY_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220844));
pub const VFW_E_CERTIFICATION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220843));
pub const VFW_E_VMR_NOT_IN_MIXER_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220842));
pub const VFW_E_VMR_NO_AP_SUPPLIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220841));
pub const VFW_E_VMR_NO_DEINTERLACE_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220840));
pub const VFW_E_VMR_NO_PROCAMP_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220839));
pub const VFW_E_DVD_VMR9_INCOMPATIBLEDEC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220838));
pub const VFW_E_NO_COPP_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220837));
pub const VFW_E_DVD_NONBLOCKING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220836));
pub const VFW_E_DVD_TOO_MANY_RENDERERS_IN_FILTER_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220835));
pub const VFW_E_DVD_NON_EVR_RENDERER_IN_FILTER_GRAPH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220834));
pub const VFW_E_DVD_RESOLUTION_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220833));
pub const E_PROP_SET_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147023726));
pub const E_PROP_ID_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147023728));
pub const VFW_E_CODECAPI_LINEAR_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220720));
pub const VFW_E_CODECAPI_ENUMERATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220719));
pub const VFW_E_CODECAPI_NO_DEFAULT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220717));
pub const VFW_E_CODECAPI_NO_CURRENT_VALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220716));
pub const VFW_E_DVD_CHAPTER_DOES_NOT_EXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220715));
pub const VFW_S_DVD_RENDER_STATUS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262944));
pub const DXVA_ModeNone = Guid.initString("1b81be00-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH261_A = Guid.initString("1b81be01-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH261_B = Guid.initString("1b81be02-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_A = Guid.initString("1b81be03-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_B = Guid.initString("1b81be04-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_C = Guid.initString("1b81be05-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_D = Guid.initString("1b81be06-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_E = Guid.initString("1b81be07-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_F = Guid.initString("1b81be08-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG1_A = Guid.initString("1b81be09-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG1_VLD = Guid.initString("6f3ec719-3735-42cc-8063-65cc3cb36616");
pub const DXVA_ModeMPEG2_A = Guid.initString("1b81be0a-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2_B = Guid.initString("1b81be0b-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2_C = Guid.initString("1b81be0c-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2_D = Guid.initString("1b81be0d-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2and1_VLD = Guid.initString("86695f12-340e-4f04-9fd3-9253dd327460");
pub const DXVA_ModeH264_A = Guid.initString("1b81be64-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_B = Guid.initString("1b81be65-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_C = Guid.initString("1b81be66-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_D = Guid.initString("1b81be67-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_E = Guid.initString("1b81be68-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_F = Guid.initString("1b81be69-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_VLD_WithFMOASO_NoFGT = Guid.initString("d5f04ff9-3418-45d8-9561-32a76aae2ddd");
pub const DXVA_ModeH264_VLD_Stereo_Progressive_NoFGT = Guid.initString("d79be8da-0cf1-4c81-b82a-69a4e236f43d");
pub const DXVA_ModeH264_VLD_Stereo_NoFGT = Guid.initString("f9aaccbb-c2b6-4cfc-8779-5707b1760552");
pub const DXVA_ModeH264_VLD_Multiview_NoFGT = Guid.initString("705b9d82-76cf-49d6-b7e6-ac8872db013c");
pub const DXVA_ModeWMV8_A = Guid.initString("1b81be80-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV8_B = Guid.initString("1b81be81-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV9_A = Guid.initString("1b81be90-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV9_B = Guid.initString("1b81be91-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV9_C = Guid.initString("1b81be94-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_A = Guid.initString("1b81bea0-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_B = Guid.initString("1b81bea1-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_C = Guid.initString("1b81bea2-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_D = Guid.initString("1b81bea3-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_D2010 = Guid.initString("1b81bea4-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG4pt2_VLD_Simple = Guid.initString("efd64d74-c9e8-41d7-a5e9-e9b0e39fa319");
pub const DXVA_ModeMPEG4pt2_VLD_AdvSimple_NoGMC = Guid.initString("ed418a9f-010d-4eda-9ae3-9a65358d8d2e");
pub const DXVA_ModeMPEG4pt2_VLD_AdvSimple_GMC = Guid.initString("ab998b5b-4258-44a9-9feb-94e597a6baae");
pub const DXVA_ModeHEVC_VLD_Main = Guid.initString("5b11d51b-2f4c-4452-bcc3-09f2a1160cc0");
pub const DXVA_ModeHEVC_VLD_Main10 = Guid.initString("107af0e0-ef1a-4d19-aba8-67a163073d13");
pub const DXVA_ModeVP9_VLD_Profile0 = Guid.initString("463707f8-a1d0-4585-876d-83aa6d60b89e");
pub const DXVA_ModeVP9_VLD_10bit_Profile2 = Guid.initString("a4c749ef-6ecf-48aa-8448-50a7a1165ff7");
pub const DXVA_ModeVP8_VLD = Guid.initString("90b899ea-3a62-4705-88b3-8df04b2744e7");
pub const DXVA_ModeAV1_VLD_Profile0 = Guid.initString("b8be4ccb-cf53-46ba-8d59-d6b8a6da5d2a");
pub const DXVA_ModeAV1_VLD_Profile1 = Guid.initString("6936ff0f-45b1-4163-9cc1-646ef6946108");
pub const DXVA_ModeAV1_VLD_Profile2 = Guid.initString("0c5f2aa1-e541-4089-bb7b-98110a19d7c8");
pub const DXVA_ModeAV1_VLD_12bit_Profile2 = Guid.initString("17127009-a00f-4ce1-994e-bf4081f6f3f0");
pub const DXVA_ModeAV1_VLD_12bit_Profile2_420 = Guid.initString("2d80bed6-9cac-4835-9e91-327bbc4f9ee8");
pub const DXVA_NoEncrypt = Guid.initString("1b81bed0-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_RESTRICTED_MODE_UNRESTRICTED = @as(u32, 65535);
pub const DXVA_RESTRICTED_MODE_H261_A = @as(u32, 1);
pub const DXVA_RESTRICTED_MODE_H261_B = @as(u32, 2);
pub const DXVA_RESTRICTED_MODE_H263_A = @as(u32, 3);
pub const DXVA_RESTRICTED_MODE_H263_B = @as(u32, 4);
pub const DXVA_RESTRICTED_MODE_H263_C = @as(u32, 5);
pub const DXVA_RESTRICTED_MODE_H263_D = @as(u32, 6);
pub const DXVA_RESTRICTED_MODE_H263_E = @as(u32, 7);
pub const DXVA_RESTRICTED_MODE_H263_F = @as(u32, 8);
pub const DXVA_RESTRICTED_MODE_MPEG1_A = @as(u32, 9);
pub const DXVA_RESTRICTED_MODE_MPEG2_A = @as(u32, 10);
pub const DXVA_RESTRICTED_MODE_MPEG2_B = @as(u32, 11);
pub const DXVA_RESTRICTED_MODE_MPEG2_C = @as(u32, 12);
pub const DXVA_RESTRICTED_MODE_MPEG2_D = @as(u32, 13);
pub const DXVA_RESTRICTED_MODE_MPEG1_VLD = @as(u32, 16);
pub const DXVA_RESTRICTED_MODE_MPEG2and1_VLD = @as(u32, 17);
pub const DXVA_RESTRICTED_MODE_H264_A = @as(u32, 100);
pub const DXVA_RESTRICTED_MODE_H264_B = @as(u32, 101);
pub const DXVA_RESTRICTED_MODE_H264_C = @as(u32, 102);
pub const DXVA_RESTRICTED_MODE_H264_D = @as(u32, 103);
pub const DXVA_RESTRICTED_MODE_H264_E = @as(u32, 104);
pub const DXVA_RESTRICTED_MODE_H264_F = @as(u32, 105);
pub const DXVA_RESTRICTED_MODE_H264_VLD_WITHFMOASO_NOFGT = @as(u32, 112);
pub const DXVA_RESTRICTED_MODE_H264_VLD_STEREO_PROGRESSIVE_NOFGT = @as(u32, 113);
pub const DXVA_RESTRICTED_MODE_H264_VLD_STEREO_NOFGT = @as(u32, 114);
pub const DXVA_RESTRICTED_MODE_H264_VLD_MULTIVIEW_NOFGT = @as(u32, 115);
pub const DXVA_RESTRICTED_MODE_WMV8_A = @as(u32, 128);
pub const DXVA_RESTRICTED_MODE_WMV8_B = @as(u32, 129);
pub const DXVA_RESTRICTED_MODE_WMV9_A = @as(u32, 144);
pub const DXVA_RESTRICTED_MODE_WMV9_B = @as(u32, 145);
pub const DXVA_RESTRICTED_MODE_WMV9_C = @as(u32, 148);
pub const DXVA_RESTRICTED_MODE_VC1_A = @as(u32, 160);
pub const DXVA_RESTRICTED_MODE_VC1_B = @as(u32, 161);
pub const DXVA_RESTRICTED_MODE_VC1_C = @as(u32, 162);
pub const DXVA_RESTRICTED_MODE_VC1_D = @as(u32, 163);
pub const DXVA_RESTRICTED_MODE_VC1_D2010 = @as(u32, 164);
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_SIMPLE = @as(u32, 176);
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_ADV_SIMPLE_NOGMC = @as(u32, 177);
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_ADV_SIMPLE_GMC = @as(u32, 178);
pub const DXVA_RESTRICTED_MODE_WMV8_POSTPROC = @as(u32, 128);
pub const DXVA_RESTRICTED_MODE_WMV8_MOCOMP = @as(u32, 129);
pub const DXVA_RESTRICTED_MODE_WMV9_POSTPROC = @as(u32, 144);
pub const DXVA_RESTRICTED_MODE_WMV9_MOCOMP = @as(u32, 145);
pub const DXVA_RESTRICTED_MODE_WMV9_IDCT = @as(u32, 148);
pub const DXVA_RESTRICTED_MODE_VC1_POSTPROC = @as(u32, 160);
pub const DXVA_RESTRICTED_MODE_VC1_MOCOMP = @as(u32, 161);
pub const DXVA_RESTRICTED_MODE_VC1_IDCT = @as(u32, 162);
pub const DXVA_RESTRICTED_MODE_VC1_VLD = @as(u32, 163);
pub const DXVA_RESTRICTED_MODE_H264_MOCOMP_NOFGT = @as(u32, 100);
pub const DXVA_RESTRICTED_MODE_H264_MOCOMP_FGT = @as(u32, 101);
pub const DXVA_RESTRICTED_MODE_H264_IDCT_NOFGT = @as(u32, 102);
pub const DXVA_RESTRICTED_MODE_H264_IDCT_FGT = @as(u32, 103);
pub const DXVA_RESTRICTED_MODE_H264_VLD_NOFGT = @as(u32, 104);
pub const DXVA_RESTRICTED_MODE_H264_VLD_FGT = @as(u32, 105);
pub const DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED = @as(u32, 0);
pub const DXVA_PICTURE_DECODE_BUFFER = @as(u32, 1);
pub const DXVA_MACROBLOCK_CONTROL_BUFFER = @as(u32, 2);
pub const DXVA_RESIDUAL_DIFFERENCE_BUFFER = @as(u32, 3);
pub const DXVA_DEBLOCKING_CONTROL_BUFFER = @as(u32, 4);
pub const DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER = @as(u32, 5);
pub const DXVA_SLICE_CONTROL_BUFFER = @as(u32, 6);
pub const DXVA_BITSTREAM_DATA_BUFFER = @as(u32, 7);
pub const DXVA_AYUV_BUFFER = @as(u32, 8);
pub const DXVA_IA44_SURFACE_BUFFER = @as(u32, 9);
pub const DXVA_DPXD_SURFACE_BUFFER = @as(u32, 10);
pub const DXVA_HIGHLIGHT_BUFFER = @as(u32, 11);
pub const DXVA_DCCMD_SURFACE_BUFFER = @as(u32, 12);
pub const DXVA_ALPHA_BLEND_COMBINATION_BUFFER = @as(u32, 13);
pub const DXVA_PICTURE_RESAMPLE_BUFFER = @as(u32, 14);
pub const DXVA_READ_BACK_BUFFER = @as(u32, 15);
pub const DXVA_MOTION_VECTOR_BUFFER = @as(u32, 16);
pub const DXVA_FILM_GRAIN_BUFFER = @as(u32, 17);
pub const DXVA_NUM_TYPES_COMP_BUFFERS = @as(u32, 18);
pub const DXVA_PICTURE_DECODING_FUNCTION = @as(u32, 1);
pub const DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION = @as(u32, 2);
pub const DXVA_ALPHA_BLEND_COMBINATION_FUNCTION = @as(u32, 3);
pub const DXVA_PICTURE_RESAMPLE_FUNCTION = @as(u32, 4);
pub const DXVA_DEBLOCKING_FILTER_FUNCTION = @as(u32, 5);
pub const DXVA_FILM_GRAIN_SYNTHESIS_FUNCTION = @as(u32, 6);
pub const DXVA_STATUS_REPORTING_FUNCTION = @as(u32, 7);
pub const DXVA_EXECUTE_RETURN_OK = @as(u32, 0);
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR = @as(u32, 1);
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF = @as(u32, 2);
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE = @as(u32, 3);
pub const DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE = @as(u32, 4);
pub const DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY = @as(u32, 16777201);
pub const DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY = @as(u32, 16777205);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY = @as(u32, 16777208);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS = @as(u32, 16777209);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY = @as(u32, 16777212);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS = @as(u32, 16777211);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS = @as(u32, 16777215);
pub const DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST = @as(u32, 16776960);
pub const DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL = @as(u32, 16776968);
pub const DXVA_CHROMA_FORMAT_420 = @as(u32, 1);
pub const DXVA_CHROMA_FORMAT_422 = @as(u32, 2);
pub const DXVA_CHROMA_FORMAT_444 = @as(u32, 3);
pub const DXVA_PICTURE_STRUCTURE_TOP_FIELD = @as(u32, 1);
pub const DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD = @as(u32, 2);
pub const DXVA_PICTURE_STRUCTURE_FRAME = @as(u32, 3);
pub const DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND = @as(u32, 0);
pub const DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC = @as(u32, 1);
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2 = @as(u32, 0);
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263 = @as(u32, 1);
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261 = @as(u32, 2);
pub const DXVA_SCAN_METHOD_ZIG_ZAG = @as(u32, 0);
pub const DXVA_SCAN_METHOD_ALTERNATE_VERTICAL = @as(u32, 1);
pub const DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL = @as(u32, 2);
pub const DXVA_SCAN_METHOD_ARBITRARY = @as(u32, 3);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY = @as(u32, 0);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_MILD = @as(u32, 1);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY = @as(u32, 2);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE = @as(u32, 3);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED = @as(u32, 0);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA = @as(u32, 1);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD = @as(u32, 2);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD = @as(u32, 3);
pub const DXVA_USUAL_BLOCK_WIDTH = @as(u32, 8);
pub const DXVA_USUAL_BLOCK_HEIGHT = @as(u32, 8);
pub const DXVA_NumMV_OBMC_off_BinPBwith4MV_off = @as(u32, 4);
pub const DXVA_NumMV_OBMC_off_BinPBwith4MV_on = @as(u32, 5);
pub const DXVA_NumMV_OBMC_on__BinPB_off = @as(u32, 10);
pub const DXVA_NumMV_OBMC_on__BinPB_on = @as(u32, 11);
pub const DXVA_CONFIG_DATA_TYPE_IA44 = @as(u32, 0);
pub const DXVA_CONFIG_DATA_TYPE_AI44 = @as(u32, 1);
pub const DXVA_CONFIG_DATA_TYPE_DPXD = @as(u32, 2);
pub const DXVA_CONFIG_DATA_TYPE_AYUV = @as(u32, 3);
pub const DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER = @as(u32, 0);
pub const DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE = @as(u32, 1);
pub const DXVA_ExtColorData_ShiftBase = @as(u32, 8);
pub const DXVA_DeinterlaceBobDevice = Guid.initString("335aa36e-7884-43a4-9c91-7f87faf3e37e");
pub const DXVA_DeinterlaceContainerDevice = Guid.initString("0e85cb93-3046-4ff0-aecc-d58cb5f035fd");
pub const MAX_DEINTERLACE_SURFACES = @as(u32, 32);
pub const DXVA_DeinterlaceBltFnCode = @as(u32, 1);
pub const DXVA_DeinterlaceBltExFnCode = @as(u32, 2);
pub const MAX_DEINTERLACE_DEVICE_GUIDS = @as(u32, 32);
pub const DXVA_DeinterlaceQueryAvailableModesFnCode = @as(u32, 1);
pub const DXVA_DeinterlaceQueryModeCapsFnCode = @as(u32, 2);
pub const DXVA_ProcAmpControlDevice = Guid.initString("9f200913-2ffd-4056-9f1e-e1b508f22dcf");
pub const DXVA_ProcAmpControlQueryCapsFnCode = @as(u32, 3);
pub const DXVA_ProcAmpControlQueryRangeFnCode = @as(u32, 4);
pub const DXVA_ProcAmpControlBltFnCode = @as(u32, 1);
pub const DXVA_COPPDevice = Guid.initString("d2457add-8999-45ed-8a8a-d1aa047ba4d5");
pub const DXVA_COPPGetCertificateLengthFnCode = @as(u32, 1);
pub const DXVA_COPPKeyExchangeFnCode = @as(u32, 2);
pub const DXVA_COPPSequenceStartFnCode = @as(u32, 3);
pub const DXVA_COPPCommandFnCode = @as(u32, 4);
pub const DXVA_COPPSetProtectionLevel = Guid.initString("9bb9327c-4eb5-4727-9f00-b42b0919c0da");
pub const COPP_NoProtectionLevelAvailable = @as(i32, -1);
pub const COPP_DefaultProtectionLevel = @as(u32, 0);
pub const DXVA_COPPSetSignaling = Guid.initString("09a631a5-d684-4c60-8e4d-d3bb0f0be3ee");
pub const COPP_ImageAspectRatio_EN300294_Mask = @as(u32, 7);
pub const DXVA_COPPQueryStatusFnCode = @as(u32, 5);
pub const DXVA_COPPQueryConnectorType = Guid.initString("81d0bfd5-6afe-48c2-99c0-95a08f97c5da");
pub const DXVA_COPPQueryProtectionType = Guid.initString("38f2a801-9a6c-48bb-9107-b6696e6f1797");
pub const DXVA_COPPQueryLocalProtectionLevel = Guid.initString("b2075857-3eda-4d5d-88db-748f8c1a0549");
pub const DXVA_COPPQueryGlobalProtectionLevel = Guid.initString("1957210a-7766-452a-b99a-d27aed54f03a");
pub const DXVA_COPPQueryDisplayData = Guid.initString("d7bf1ba3-ad13-4f8e-af98-0dcb3ca204cc");
pub const DXVA_COPPQueryHDCPKeyData = Guid.initString("0db59d74-a992-492e-a0bd-c23fda564e00");
pub const DXVA_COPPQueryBusData = Guid.initString("c6f4d673-6174-4184-8e35-f6db5200bcba");
pub const DXVA_COPPQuerySignaling = Guid.initString("6629a591-3b79-4cf3-924a-11e8e7811671");
pub const DXVA2Trace_Control = Guid.initString("a0386e75-f70c-464c-a9ce-33c44e091623");
pub const DXVA2Trace_DecodeDevCreated = Guid.initString("b4de17a1-c5b2-44fe-86d5-d97a648114ff");
pub const DXVA2Trace_DecodeDevDestroyed = Guid.initString("853ebdf2-4160-421d-8893-63dcea4f18bb");
pub const DXVA2Trace_DecodeDevBeginFrame = Guid.initString("9fd1acf6-44cb-4637-bc62-2c11a9608f90");
pub const DXVA2Trace_DecodeDevExecute = Guid.initString("850aeb4c-d19a-4609-b3b4-bcbf0e22121e");
pub const DXVA2Trace_DecodeDevGetBuffer = Guid.initString("57b128fb-72cb-4137-a575-d91fa3160897");
pub const DXVA2Trace_DecodeDevEndFrame = Guid.initString("9fb3cb33-47dc-4899-98c8-c0c6cd7cd3cb");
pub const DXVA2Trace_VideoProcessDevCreated = Guid.initString("895508c6-540d-4c87-98f8-8dcbf2dabb2a");
pub const DXVA2Trace_VideoProcessDevDestroyed = Guid.initString("f97f30b1-fb49-42c7-8ee8-88bdfa92d4e2");
pub const DXVA2Trace_VideoProcessBlt = Guid.initString("69089cc0-71ab-42d0-953a-2887bf05a8af");
pub const DTV_CardStatus_Inserted = @as(u32, 0);
pub const DTV_CardStatus_Removed = @as(u32, 1);
pub const DTV_CardStatus_Error = @as(u32, 2);
pub const DTV_CardStatus_FirmwareDownload = @as(u32, 3);
pub const OCUR_PAIRING_PROTOCOL_VERSION = @as(u32, 2);
pub const PBDA_PAIRING_PROTOCOL_VERSION = @as(u32, 3);
pub const DTV_MMIMessage_Open = @as(u32, 0);
pub const DTV_MMIMessage_Close = @as(u32, 1);
pub const DTV_Entitlement_CanDecrypt = @as(u32, 0);
pub const DTV_Entitlement_NotEntitled = @as(u32, 1);
pub const DTV_Entitlement_TechnicalFailure = @as(u32, 2);
pub const AudioType_Standard = @as(u32, 0);
pub const AudioType_Music_And_Effects = @as(u32, 1);
pub const AudioType_Visually_Impaired = @as(u32, 2);
pub const AudioType_Hearing_Impaired = @as(u32, 3);
pub const AudioType_Dialogue = @as(u32, 4);
pub const AudioType_Commentary = @as(u32, 5);
pub const AudioType_Emergency = @as(u32, 6);
pub const AudioType_Voiceover = @as(u32, 7);
pub const AudioType_Reserved = @as(i32, -1);
pub const MAX_COUNTRY_CODE_STRING = @as(u32, 3);
pub const PARENTAL_CONTROL_TIME_RANGE = @as(u32, 1);
pub const REQUIRED_PARENTAL_CONTROL_TIME_RANGE = @as(u32, 2);
pub const PARENTAL_CONTROL_CONTENT_RATING = @as(u32, 256);
pub const PARENTAL_CONTROL_ATTRIB_VIOLENCE = @as(u32, 512);
pub const PARENTAL_CONTROL_ATTRIB_LANGUAGE = @as(u32, 513);
pub const PARENTAL_CONTROL_ATTRIB_SEXUAL = @as(u32, 514);
pub const PARENTAL_CONTROL_ATTRIB_DIALOGUE = @as(u32, 515);
pub const PARENTAL_CONTROL_ATTRIB_FANTASY = @as(u32, 516);
pub const PARENTAL_CONTROL_VALUE_UNDEFINED = @as(u32, 0);
pub const MPEG2_FILTER_VERSION_1_SIZE = @as(u32, 124);
pub const MPEG2_FILTER_VERSION_2_SIZE = @as(u32, 133);
pub const SID_MSVidCtl_CurrentAudioEndpoint = Guid.initString("cf9a88f4-abcf-4ed8-9b74-7db33445459e");
pub const STREAMBUFFER_EC_BASE = @as(u32, 806);
pub const EVENTID_SBE2RecControlStarted = Guid.initString("8966a89e-f83e-4c0e-bc3b-bfa7649e04cb");
pub const EVENTID_SBE2RecControlStopped = Guid.initString("454b1ec8-0c9b-4caa-b1a1-1e7a2666f6c3");
pub const SBE2_STREAM_DESC_EVENT = Guid.initString("2313a4ed-bf2d-454f-ad8a-d95ba7f91fee");
pub const SBE2_V1_STREAMS_CREATION_EVENT = Guid.initString("000fcf09-97f5-46ac-9769-7a83b35384fb");
pub const SBE2_V2_STREAMS_CREATION_EVENT = Guid.initString("a72530a3-0344-4cab-a2d0-fe937dbdcab3");
pub const SBE2_STREAM_DESC_VERSION = @as(u32, 1);
pub const SID_DRMSecureServiceChannel = Guid.initString("c4c4c4c4-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_ETFilterEncProperties = Guid.initString("c4c4c481-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_ETFilterTagProperties = Guid.initString("c4c4c491-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_PTFilter = Guid.initString("9cd31617-b303-4f96-8330-2eb173ea4dc6");
pub const CLSID_DTFilterEncProperties = Guid.initString("c4c4c482-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_DTFilterTagProperties = Guid.initString("c4c4c492-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_XDSCodecProperties = Guid.initString("c4c4c483-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_XDSCodecTagProperties = Guid.initString("c4c4c493-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_CPCAFiltersCategory = Guid.initString("c4c4c4fc-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_XDSCodecNewXDSRating = Guid.initString("c4c4c4e0-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_XDSCodecDuplicateXDSRating = Guid.initString("c4c4c4df-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_XDSCodecNewXDSPacket = Guid.initString("c4c4c4e1-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterRatingChange = Guid.initString("c4c4c4e2-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterRatingsBlock = Guid.initString("c4c4c4e3-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterRatingsUnblock = Guid.initString("c4c4c4e4-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterXDSPacket = Guid.initString("c4c4c4e5-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterEncryptionOn = Guid.initString("c4c4c4e6-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterEncryptionOff = Guid.initString("c4c4c4e7-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterCOPPUnblock = Guid.initString("c4c4c4e8-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_EncDecFilterError = Guid.initString("c4c4c4e9-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterCOPPBlock = Guid.initString("c4c4c4ea-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterCopyOnce = Guid.initString("c4c4c4eb-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterCopyNever = Guid.initString("c4c4c4f0-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterDataFormatOK = Guid.initString("c4c4c4ec-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterDataFormatFailure = Guid.initString("c4c4c4ed-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETDTFilterLicenseOK = Guid.initString("c4c4c4ee-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETDTFilterLicenseFailure = Guid.initString("c4c4c4ef-0049-4e2b-98fb-9537f6ce516d");
pub const MEDIASUBTYPE_ETDTFilter_Tagged = Guid.initString("c4c4c4d0-0049-4e2b-98fb-9537f6ce516d");
pub const FORMATTYPE_ETDTFilter_Tagged = Guid.initString("c4c4c4d1-0049-4e2b-98fb-9537f6ce516d");
pub const MEDIASUBTYPE_CPFilters_Processed = Guid.initString("46adbd28-6fd0-4796-93b2-155c51dc048d");
pub const FORMATTYPE_CPFilters_Processed = Guid.initString("6739b36f-1d5f-4ac2-8192-28bb0e73d16a");
pub const EVENTID_EncDecFilterEvent = Guid.initString("4a1b465b-0fb9-4159-afbd-e33006a0f9f4");
pub const EVENTID_FormatNotSupportedEvent = Guid.initString("24b2280a-b2aa-4777-bf65-63f35e7b024a");
pub const EVENTID_DemultiplexerFilterDiscontinuity = Guid.initString("16155770-aed5-475c-bb98-95a33070df0c");
pub const DSATTRIB_WMDRMProtectionInfo = Guid.initString("40749583-6b9d-4eec-b43c-67a1801e1a9b");
pub const DSATTRIB_BadSampleInfo = Guid.initString("e4846dda-5838-42b4-b897-6f7e5faa2f2f");
pub const MPEG_PAT_PID = @as(u32, 0);
pub const MPEG_PAT_TID = @as(u32, 0);
pub const MPEG_CAT_PID = @as(u32, 1);
pub const MPEG_CAT_TID = @as(u32, 1);
pub const MPEG_PMT_TID = @as(u32, 2);
pub const MPEG_TSDT_PID = @as(u32, 2);
pub const MPEG_TSDT_TID = @as(u32, 3);
pub const ATSC_MGT_PID = @as(u32, 8187);
pub const ATSC_MGT_TID = @as(u32, 199);
pub const ATSC_VCT_PID = @as(u32, 8187);
pub const ATSC_VCT_TERR_TID = @as(u32, 200);
pub const ATSC_VCT_CABL_TID = @as(u32, 201);
pub const ATSC_EIT_TID = @as(u32, 203);
pub const ATSC_ETT_TID = @as(u32, 204);
pub const ATSC_RRT_TID = @as(u32, 202);
pub const ATSC_RRT_PID = @as(u32, 8187);
pub const ATSC_STT_PID = @as(u32, 8187);
pub const ATSC_STT_TID = @as(u32, 205);
pub const ATSC_PIT_TID = @as(u32, 208);
pub const DVB_NIT_PID = @as(u32, 16);
pub const DVB_NIT_ACTUAL_TID = @as(u32, 64);
pub const DVB_NIT_OTHER_TID = @as(u32, 65);
pub const DVB_SDT_PID = @as(u32, 17);
pub const DVB_SDT_ACTUAL_TID = @as(u32, 66);
pub const DVB_SDT_OTHER_TID = @as(u32, 70);
pub const DVB_BAT_PID = @as(u32, 17);
pub const DVB_BAT_TID = @as(u32, 74);
pub const DVB_EIT_PID = @as(u32, 18);
pub const DVB_EIT_ACTUAL_TID = @as(u32, 78);
pub const DVB_EIT_OTHER_TID = @as(u32, 79);
pub const DVB_RST_PID = @as(u32, 19);
pub const DVB_RST_TID = @as(u32, 113);
pub const DVB_TDT_PID = @as(u32, 20);
pub const DVB_TDT_TID = @as(u32, 112);
pub const DVB_ST_PID_16 = @as(u32, 16);
pub const DVB_ST_PID_17 = @as(u32, 17);
pub const DVB_ST_PID_18 = @as(u32, 18);
pub const DVB_ST_PID_19 = @as(u32, 19);
pub const DVB_ST_PID_20 = @as(u32, 20);
pub const DVB_ST_TID = @as(u32, 114);
pub const ISDB_ST_TID = @as(u32, 114);
pub const DVB_TOT_PID = @as(u32, 20);
pub const DVB_TOT_TID = @as(u32, 115);
pub const DVB_DIT_PID = @as(u32, 30);
pub const DVB_DIT_TID = @as(u32, 126);
pub const DVB_SIT_PID = @as(u32, 31);
pub const DVB_SIT_TID = @as(u32, 127);
pub const ISDB_EMM_TID = @as(u32, 133);
pub const ISDB_BIT_PID = @as(u32, 36);
pub const ISDB_BIT_TID = @as(u32, 196);
pub const ISDB_NBIT_PID = @as(u32, 37);
pub const ISDB_NBIT_MSG_TID = @as(u32, 197);
pub const ISDB_NBIT_REF_TID = @as(u32, 198);
pub const ISDB_LDT_PID = @as(u32, 37);
pub const ISDB_LDT_TID = @as(u32, 199);
pub const ISDB_SDTT_PID = @as(u32, 35);
pub const ISDB_SDTT_ALT_PID = @as(u32, 40);
pub const ISDB_SDTT_TID = @as(u32, 195);
pub const ISDB_CDT_PID = @as(u32, 41);
pub const ISDB_CDT_TID = @as(u32, 200);
pub const SCTE_EAS_TID = @as(u32, 216);
pub const SCTE_EAS_IB_PID = @as(u32, 8187);
pub const SCTE_EAS_OOB_PID = @as(u32, 8188);
pub const CLSID_Mpeg2TableFilter = Guid.initString("752845f1-758f-4c83-a043-4270c593308e");
pub const ATSC_ETM_LOCATION_NOT_PRESENT = @as(u32, 0);
pub const ATSC_ETM_LOCATION_IN_PTC_FOR_PSIP = @as(u32, 1);
pub const ATSC_ETM_LOCATION_IN_PTC_FOR_EVENT = @as(u32, 2);
pub const ATSC_ETM_LOCATION_RESERVED = @as(u32, 3);
pub const SAMPLE_SEQ_SEQUENCE_HEADER = @as(u32, 1);
pub const SAMPLE_SEQ_GOP_HEADER = @as(u32, 2);
pub const SAMPLE_SEQ_PICTURE_HEADER = @as(u32, 3);
pub const SAMPLE_SEQ_SEQUENCE_START = @as(u32, 1);
pub const SAMPLE_SEQ_SEEK_POINT = @as(u32, 2);
pub const SAMPLE_SEQ_FRAME_START = @as(u32, 3);
pub const SAMPLE_SEQ_CONTENT_UNKNOWN = @as(u32, 0);
pub const SAMPLE_SEQ_CONTENT_I_FRAME = @as(u32, 1);
pub const SAMPLE_SEQ_CONTENT_P_FRAME = @as(u32, 2);
pub const SAMPLE_SEQ_CONTENT_B_FRAME = @as(u32, 3);
pub const SAMPLE_SEQ_CONTENT_STANDALONE_FRAME = @as(u32, 1);
pub const SAMPLE_SEQ_CONTENT_REF_FRAME = @as(u32, 2);
pub const SAMPLE_SEQ_CONTENT_NONREF_FRAME = @as(u32, 3);
pub const COMPONENT_TAG_CAPTION_MIN = @as(u32, 48);
pub const COMPONENT_TAG_CAPTION_MAX = @as(u32, 55);
pub const COMPONENT_TAG_SUPERIMPOSE_MIN = @as(u32, 56);
pub const COMPONENT_TAG_SUPERIMPOSE_MAX = @as(u32, 63);
pub const DVBS_SCAN_TABLE_MAX_SIZE = @as(u32, 400);
pub const g_wszExcludeScriptStreamDeliverySynchronization = "ExcludeScriptStreamDeliverySynchronization";
pub const MPEG2_BASE = @as(u32, 512);
pub const MPEG2_S_MORE_DATA_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const MPEG2_S_NO_MORE_DATA_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const MPEG2_S_SG_INFO_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262658));
pub const MPEG2_S_SG_INFO_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262659));
pub const MPEG2_S_MPE_INFO_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262660));
pub const MPEG2_S_MPE_INFO_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262661));
pub const MPEG2_S_NEW_MODULE_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262662));
pub const MPEG2_E_UNINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const MPEG2_E_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const MPEG2_E_OUT_OF_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const MPEG2_E_MALFORMED_TABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const MPEG2_E_UNDEFINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const MPEG2_E_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const MPEG2_E_SECTION_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const MPEG2_E_TX_STREAM_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const MPEG2_E_SERVICE_ID_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const MPEG2_E_SERVICE_PMT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const MPEG2_E_DSI_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const MPEG2_E_SERVER_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const MPEG2_E_INVALID_CAROUSEL_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const MPEG2_E_MALFORMED_DSMCC_MESSAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const MPEG2_E_INVALID_SG_OBJECT_KIND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const MPEG2_E_OBJECT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const MPEG2_E_OBJECT_KIND_NOT_A_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const MPEG2_E_OBJECT_KIND_NOT_A_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const MPEG2_E_FILE_OFFSET_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const MPEG2_E_STREAM_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const MPEG2_E_REGISTRY_ACCESS_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const MPEG2_E_INVALID_UDP_PORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const MPEG2_E_DATA_SOURCE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const MPEG2_E_DII_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const MPEG2_E_DSHOW_PIN_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220968));
pub const MPEG2_E_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const MPEG2_E_MISSING_SECTIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220966));
pub const MPEG2_E_TOO_MANY_SECTIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const MPEG2_E_NEXT_TABLE_OPS_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220964));
pub const MPEG2_E_INCORRECT_DESCRIPTOR_TAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220963));
pub const MSDRI_S_MMI_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2));
pub const MSDRI_S_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1));
pub const BDA_E_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479679));
pub const BDA_E_NOT_IMPLEMENTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479678));
pub const BDA_E_NO_SUCH_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479677));
pub const BDA_E_OUT_OF_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479676));
pub const BDA_E_INVALID_SCHEMA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479675));
pub const BDA_E_INVALID_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479674));
pub const BDA_E_INVALID_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479673));
pub const BDA_E_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479672));
pub const BDA_E_ACCESS_DENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479671));
pub const BDA_E_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479670));
pub const BDA_E_BUFFER_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479669));
pub const BDA_E_OUT_OF_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479668));
pub const BDA_E_OUT_OF_MEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479667));
pub const BDA_E_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479666));
pub const BDA_E_NO_HANDLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479665));
pub const BDA_E_INVALID_LANGUAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479664));
pub const BDA_E_TIMEOUT_ELAPSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073479663));
pub const BDA_E_NO_MORE_EVENTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073475583));
pub const BDA_E_NO_MORE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073475582));
pub const BDA_E_TUNER_INITIALIZING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073467391));
pub const BDA_E_TUNER_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073467390));
pub const BDA_E_TUNER_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073467389));
pub const BDA_E_INVALID_TUNE_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073467388));
pub const BDA_E_INVALID_ENTITLEMENT_TOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073463295));
pub const BDA_E_INVALID_CAPTURE_TOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073463294));
pub const BDA_E_WOULD_DISRUPT_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073463293));
pub const BDA_E_INVALID_PURCHASE_TOKEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073463292));
pub const BDA_E_IPNETWORK_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073459199));
pub const BDA_E_IPNETWORK_ADDRESS_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073459198));
pub const BDA_E_IPNETWORK_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073459197));
pub const BDA_E_IPNETWORK_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073459196));
pub const BDA_E_TUNE_FAILED_SDV01 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455103));
pub const BDA_E_TUNE_FAILED_SDV02 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455102));
pub const BDA_E_TUNE_FAILED_SDV03 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455101));
pub const BDA_E_TUNE_FAILED_SDV04 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455100));
pub const BDA_E_TUNE_FAILED_SDV05 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455099));
pub const BDA_E_TUNE_FAILED_SDV06 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455098));
pub const BDA_E_TUNE_FAILED_SDV07 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455097));
pub const BDA_E_TUNE_FAILED_SDV08 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073455096));
pub const BDA_E_TUNE_FAILED_SDVFF = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073454849));
pub const BDA_E_WMDRM_INVALID_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418239));
pub const BDA_E_WMDRM_INVALID_CERTIFICATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418238));
pub const BDA_E_WMDRM_INVALID_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418236));
pub const BDA_E_WMDRM_INVALID_DATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418235));
pub const BDA_E_WMDRM_INVALID_PROXIMITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418234));
pub const BDA_E_WMDRM_KEY_ID_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073418232));
pub const SPECIFYPAGES_STATISTICS = Guid.initString("4c437b92-6e9e-11d1-a704-006097c4e476");
pub const g_wszStreamBufferRecordingDuration = "Duration";
pub const g_wszStreamBufferRecordingBitrate = "Bitrate";
pub const g_wszStreamBufferRecordingSeekable = "Seekable";
pub const g_wszStreamBufferRecordingStridable = "Stridable";
pub const g_wszStreamBufferRecordingBroadcast = "Broadcast";
pub const g_wszStreamBufferRecordingProtected = "Is_Protected";
pub const g_wszStreamBufferRecordingTrusted = "Is_Trusted";
pub const g_wszStreamBufferRecordingSignature_Name = "Signature_Name";
pub const g_wszStreamBufferRecordingHasAudio = "HasAudio";
pub const g_wszStreamBufferRecordingHasImage = "HasImage";
pub const g_wszStreamBufferRecordingHasScript = "HasScript";
pub const g_wszStreamBufferRecordingHasVideo = "HasVideo";
pub const g_wszStreamBufferRecordingCurrentBitrate = "CurrentBitrate";
pub const g_wszStreamBufferRecordingOptimalBitrate = "OptimalBitrate";
pub const g_wszStreamBufferRecordingHasAttachedImages = "HasAttachedImages";
pub const g_wszStreamBufferRecordingSkipBackward = "Can_Skip_Backward";
pub const g_wszStreamBufferRecordingSkipForward = "Can_Skip_Forward";
pub const g_wszStreamBufferRecordingNumberOfFrames = "NumberOfFrames";
pub const g_wszStreamBufferRecordingFileSize = "FileSize";
pub const g_wszStreamBufferRecordingHasArbitraryDataStream = "HasArbitraryDataStream";
pub const g_wszStreamBufferRecordingHasFileTransferStream = "HasFileTransferStream";
pub const g_wszStreamBufferRecordingTitle = "Title";
pub const g_wszStreamBufferRecordingAuthor = "Author";
pub const g_wszStreamBufferRecordingDescription = "Description";
pub const g_wszStreamBufferRecordingRating = "Rating";
pub const g_wszStreamBufferRecordingCopyright = "Copyright";
pub const g_wszStreamBufferRecordingUse_DRM = "Use_DRM";
pub const g_wszStreamBufferRecordingDRM_Flags = "DRM_Flags";
pub const g_wszStreamBufferRecordingDRM_Level = "DRM_Level";
pub const g_wszStreamBufferRecordingAlbumTitle = "WM/AlbumTitle";
pub const g_wszStreamBufferRecordingTrack = "WM/Track";
pub const g_wszStreamBufferRecordingPromotionURL = "WM/PromotionURL";
pub const g_wszStreamBufferRecordingAlbumCoverURL = "WM/AlbumCoverURL";
pub const g_wszStreamBufferRecordingGenre = "WM/Genre";
pub const g_wszStreamBufferRecordingYear = "WM/Year";
pub const g_wszStreamBufferRecordingGenreID = "WM/GenreID";
pub const g_wszStreamBufferRecordingMCDI = "WM/MCDI";
pub const g_wszStreamBufferRecordingComposer = "WM/Composer";
pub const g_wszStreamBufferRecordingLyrics = "WM/Lyrics";
pub const g_wszStreamBufferRecordingTrackNumber = "WM/TrackNumber";
pub const g_wszStreamBufferRecordingToolName = "WM/ToolName";
pub const g_wszStreamBufferRecordingToolVersion = "WM/ToolVersion";
pub const g_wszStreamBufferRecordingIsVBR = "IsVBR";
pub const g_wszStreamBufferRecordingAlbumArtist = "WM/AlbumArtist";
pub const g_wszStreamBufferRecordingBannerImageType = "BannerImageType";
pub const g_wszStreamBufferRecordingBannerImageData = "BannerImageData";
pub const g_wszStreamBufferRecordingBannerImageURL = "BannerImageURL";
pub const g_wszStreamBufferRecordingCopyrightURL = "CopyrightURL";
pub const g_wszStreamBufferRecordingAspectRatioX = "AspectRatioX";
pub const g_wszStreamBufferRecordingAspectRatioY = "AspectRatioY";
pub const g_wszStreamBufferRecordingNSCName = "NSC_Name";
pub const g_wszStreamBufferRecordingNSCAddress = "NSC_Address";
pub const g_wszStreamBufferRecordingNSCPhone = "NSC_Phone";
pub const g_wszStreamBufferRecordingNSCEmail = "NSC_Email";
pub const g_wszStreamBufferRecordingNSCDescription = "NSC_Description";
pub const STREAMBUFFER_EC_TIMEHOLE = @as(i32, 806);
pub const STREAMBUFFER_EC_STALE_DATA_READ = @as(i32, 807);
pub const STREAMBUFFER_EC_STALE_FILE_DELETED = @as(i32, 808);
pub const STREAMBUFFER_EC_CONTENT_BECOMING_STALE = @as(i32, 809);
pub const STREAMBUFFER_EC_WRITE_FAILURE = @as(i32, 810);
pub const STREAMBUFFER_EC_WRITE_FAILURE_CLEAR = @as(i32, 811);
pub const STREAMBUFFER_EC_READ_FAILURE = @as(i32, 812);
pub const STREAMBUFFER_EC_RATE_CHANGED = @as(i32, 813);
pub const STREAMBUFFER_EC_PRIMARY_AUDIO = @as(i32, 814);
pub const STREAMBUFFER_EC_RATE_CHANGING_FOR_SETPOSITIONS = @as(i32, 815);
pub const STREAMBUFFER_EC_SETPOSITIONS_EVENTS_DONE = @as(i32, 816);

//--------------------------------------------------------------------------------
// Section: Types (1474)
//--------------------------------------------------------------------------------
pub const OA_BOOL = enum(i32) {
    TRUE = -1,
    FALSE = 0,
};
pub const OATRUE = OA_BOOL.TRUE;
pub const OAFALSE = OA_BOOL.FALSE;

pub const MPEG2VIDEOINFO_FLAGS = enum(u32) {
    DoPanScan = 1,
    DVDLine21Field1 = 2,
    DVDLine21Field2 = 4,
    SourceIsLetterboxed = 8,
    FilmCameraMode = 16,
    LetterboxAnalogOut = 32,
    DSS_UserData = 64,
    DVB_UserData = 128,
    @"27MhzTimebase" = 256,
    WidescreenAnalogOut = 512,
    _,
    pub fn initFlags(o: struct {
        DoPanScan: u1 = 0,
        DVDLine21Field1: u1 = 0,
        DVDLine21Field2: u1 = 0,
        SourceIsLetterboxed: u1 = 0,
        FilmCameraMode: u1 = 0,
        LetterboxAnalogOut: u1 = 0,
        DSS_UserData: u1 = 0,
        DVB_UserData: u1 = 0,
        @"27MhzTimebase": u1 = 0,
        WidescreenAnalogOut: u1 = 0,
    }) MPEG2VIDEOINFO_FLAGS {
        return @intToEnum(MPEG2VIDEOINFO_FLAGS,
              (if (o.DoPanScan == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.DoPanScan) else 0)
            | (if (o.DVDLine21Field1 == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.DVDLine21Field1) else 0)
            | (if (o.DVDLine21Field2 == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.DVDLine21Field2) else 0)
            | (if (o.SourceIsLetterboxed == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.SourceIsLetterboxed) else 0)
            | (if (o.FilmCameraMode == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.FilmCameraMode) else 0)
            | (if (o.LetterboxAnalogOut == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.LetterboxAnalogOut) else 0)
            | (if (o.DSS_UserData == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.DSS_UserData) else 0)
            | (if (o.DVB_UserData == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.DVB_UserData) else 0)
            | (if (o.@"27MhzTimebase" == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.@"27MhzTimebase") else 0)
            | (if (o.WidescreenAnalogOut == 1) @enumToInt(MPEG2VIDEOINFO_FLAGS.WidescreenAnalogOut) else 0)
        );
    }
};
pub const AMMPEG2_DoPanScan = MPEG2VIDEOINFO_FLAGS.DoPanScan;
pub const AMMPEG2_DVDLine21Field1 = MPEG2VIDEOINFO_FLAGS.DVDLine21Field1;
pub const AMMPEG2_DVDLine21Field2 = MPEG2VIDEOINFO_FLAGS.DVDLine21Field2;
pub const AMMPEG2_SourceIsLetterboxed = MPEG2VIDEOINFO_FLAGS.SourceIsLetterboxed;
pub const AMMPEG2_FilmCameraMode = MPEG2VIDEOINFO_FLAGS.FilmCameraMode;
pub const AMMPEG2_LetterboxAnalogOut = MPEG2VIDEOINFO_FLAGS.LetterboxAnalogOut;
pub const AMMPEG2_DSS_UserData = MPEG2VIDEOINFO_FLAGS.DSS_UserData;
pub const AMMPEG2_DVB_UserData = MPEG2VIDEOINFO_FLAGS.DVB_UserData;
pub const AMMPEG2_27MhzTimebase = MPEG2VIDEOINFO_FLAGS.@"27MhzTimebase";
pub const AMMPEG2_WidescreenAnalogOut = MPEG2VIDEOINFO_FLAGS.WidescreenAnalogOut;

pub const MPEGLAYER3WAVEFORMAT_FLAGS = enum(u32) {
    ISO = 0,
    ON = 1,
    OFF = 2,
};
pub const MPEGLAYER3_FLAG_PADDING_ISO = MPEGLAYER3WAVEFORMAT_FLAGS.ISO;
pub const MPEGLAYER3_FLAG_PADDING_ON = MPEGLAYER3WAVEFORMAT_FLAGS.ON;
pub const MPEGLAYER3_FLAG_PADDING_OFF = MPEGLAYER3WAVEFORMAT_FLAGS.OFF;

pub const AMVP_SELECT_FORMAT_BY = enum(i32) {
    DO_NOT_CARE = 0,
    BEST_BANDWIDTH = 1,
    INPUT_SAME_AS_OUTPUT = 2,
};
pub const AMVP_DO_NOT_CARE = AMVP_SELECT_FORMAT_BY.DO_NOT_CARE;
pub const AMVP_BEST_BANDWIDTH = AMVP_SELECT_FORMAT_BY.BEST_BANDWIDTH;
pub const AMVP_INPUT_SAME_AS_OUTPUT = AMVP_SELECT_FORMAT_BY.INPUT_SAME_AS_OUTPUT;

pub const AMVP_MODE = enum(i32) {
    WEAVE = 0,
    BOBINTERLEAVED = 1,
    BOBNONINTERLEAVED = 2,
    SKIPEVEN = 3,
    SKIPODD = 4,
};
pub const AMVP_MODE_WEAVE = AMVP_MODE.WEAVE;
pub const AMVP_MODE_BOBINTERLEAVED = AMVP_MODE.BOBINTERLEAVED;
pub const AMVP_MODE_BOBNONINTERLEAVED = AMVP_MODE.BOBNONINTERLEAVED;
pub const AMVP_MODE_SKIPEVEN = AMVP_MODE.SKIPEVEN;
pub const AMVP_MODE_SKIPODD = AMVP_MODE.SKIPODD;

pub const AMVPSIZE = extern struct {
    dwWidth: u32,
    dwHeight: u32,
};

pub const AMVPDIMINFO = extern struct {
    dwFieldWidth: u32,
    dwFieldHeight: u32,
    dwVBIWidth: u32,
    dwVBIHeight: u32,
    rcValidRegion: RECT,
};

pub const AMVPDATAINFO = extern struct {
    dwSize: u32,
    dwMicrosecondsPerField: u32,
    amvpDimInfo: AMVPDIMINFO,
    dwPictAspectRatioX: u32,
    dwPictAspectRatioY: u32,
    bEnableDoubleClock: BOOL,
    bEnableVACT: BOOL,
    bDataIsInterlaced: BOOL,
    lHalfLinesOdd: i32,
    bFieldPolarityInverted: BOOL,
    dwNumLinesInVREF: u32,
    lHalfLinesEven: i32,
    dwReserved1: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICreateDevEnum_Value = @import("../zig.zig").Guid.initString("29840822-5b84-11d0-bd3b-00a0c911ce86");
pub const IID_ICreateDevEnum = &IID_ICreateDevEnum_Value;
pub const ICreateDevEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateClassEnumerator: fn(
            self: *const ICreateDevEnum,
            clsidDeviceClass: ?*const Guid,
            ppEnumMoniker: ?*?*IEnumMoniker,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateDevEnum_CreateClassEnumerator(self: *const T, clsidDeviceClass: ?*const Guid, ppEnumMoniker: ?*?*IEnumMoniker, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateDevEnum.VTable, self.vtable).CreateClassEnumerator(@ptrCast(*const ICreateDevEnum, self), clsidDeviceClass, ppEnumMoniker, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_MEDIA_TYPE = extern struct {
    majortype: Guid,
    subtype: Guid,
    bFixedSizeSamples: BOOL,
    bTemporalCompression: BOOL,
    lSampleSize: u32,
    formattype: Guid,
    pUnk: ?*IUnknown,
    cbFormat: u32,
    pbFormat: ?*u8,
};

pub const PIN_DIRECTION = enum(i32) {
    INPUT = 0,
    OUTPUT = 1,
};
pub const PINDIR_INPUT = PIN_DIRECTION.INPUT;
pub const PINDIR_OUTPUT = PIN_DIRECTION.OUTPUT;

pub const ALLOCATOR_PROPERTIES = extern struct {
    cBuffers: i32,
    cbBuffer: i32,
    cbAlign: i32,
    cbPrefix: i32,
};

pub const PIN_INFO = extern struct {
    pFilter: ?*IBaseFilter,
    dir: PIN_DIRECTION,
    achName: [128]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPin_Value = @import("../zig.zig").Guid.initString("56a86891-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IPin = &IID_IPin_Value;
pub const IPin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: fn(
            self: *const IPin,
            pReceivePin: ?*IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReceiveConnection: fn(
            self: *const IPin,
            pConnector: ?*IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectedTo: fn(
            self: *const IPin,
            pPin: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectionMediaType: fn(
            self: *const IPin,
            pmt: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPinInfo: fn(
            self: *const IPin,
            pInfo: ?*PIN_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDirection: fn(
            self: *const IPin,
            pPinDir: ?*PIN_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryId: fn(
            self: *const IPin,
            Id: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAccept: fn(
            self: *const IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMediaTypes: fn(
            self: *const IPin,
            ppEnum: ?*?*IEnumMediaTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInternalConnections: fn(
            self: *const IPin,
            apPin: ?[*]?*IPin,
            nPin: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOfStream: fn(
            self: *const IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginFlush: fn(
            self: *const IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndFlush: fn(
            self: *const IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewSegment: fn(
            self: *const IPin,
            tStart: i64,
            tStop: i64,
            dRate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_Connect(self: *const T, pReceivePin: ?*IPin, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).Connect(@ptrCast(*const IPin, self), pReceivePin, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_ReceiveConnection(self: *const T, pConnector: ?*IPin, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).ReceiveConnection(@ptrCast(*const IPin, self), pConnector, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).Disconnect(@ptrCast(*const IPin, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_ConnectedTo(self: *const T, pPin: ?*?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).ConnectedTo(@ptrCast(*const IPin, self), pPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_ConnectionMediaType(self: *const T, pmt: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).ConnectionMediaType(@ptrCast(*const IPin, self), pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryPinInfo(self: *const T, pInfo: ?*PIN_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).QueryPinInfo(@ptrCast(*const IPin, self), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryDirection(self: *const T, pPinDir: ?*PIN_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).QueryDirection(@ptrCast(*const IPin, self), pPinDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryId(self: *const T, Id: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).QueryId(@ptrCast(*const IPin, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryAccept(self: *const T, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).QueryAccept(@ptrCast(*const IPin, self), pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_EnumMediaTypes(self: *const T, ppEnum: ?*?*IEnumMediaTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).EnumMediaTypes(@ptrCast(*const IPin, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryInternalConnections(self: *const T, apPin: ?[*]?*IPin, nPin: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).QueryInternalConnections(@ptrCast(*const IPin, self), apPin, nPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_EndOfStream(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).EndOfStream(@ptrCast(*const IPin, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_BeginFlush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).BeginFlush(@ptrCast(*const IPin, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_EndFlush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).EndFlush(@ptrCast(*const IPin, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_NewSegment(self: *const T, tStart: i64, tStop: i64, dRate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPin.VTable, self.vtable).NewSegment(@ptrCast(*const IPin, self), tStart, tStop, dRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumPins_Value = @import("../zig.zig").Guid.initString("56a86892-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IEnumPins = &IID_IEnumPins_Value;
pub const IEnumPins = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumPins,
            cPins: u32,
            ppPins: [*]?*IPin,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumPins,
            cPins: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumPins,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumPins,
            ppEnum: ?*?*IEnumPins,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPins_Next(self: *const T, cPins: u32, ppPins: [*]?*IPin, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPins.VTable, self.vtable).Next(@ptrCast(*const IEnumPins, self), cPins, ppPins, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPins_Skip(self: *const T, cPins: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPins.VTable, self.vtable).Skip(@ptrCast(*const IEnumPins, self), cPins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPins_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPins.VTable, self.vtable).Reset(@ptrCast(*const IEnumPins, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPins_Clone(self: *const T, ppEnum: ?*?*IEnumPins) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPins.VTable, self.vtable).Clone(@ptrCast(*const IEnumPins, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumMediaTypes_Value = @import("../zig.zig").Guid.initString("89c31040-846b-11ce-97d3-00aa0055595a");
pub const IID_IEnumMediaTypes = &IID_IEnumMediaTypes_Value;
pub const IEnumMediaTypes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMediaTypes,
            cMediaTypes: u32,
            ppMediaTypes: [*]?*AM_MEDIA_TYPE,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMediaTypes,
            cMediaTypes: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMediaTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMediaTypes,
            ppEnum: ?*?*IEnumMediaTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMediaTypes_Next(self: *const T, cMediaTypes: u32, ppMediaTypes: [*]?*AM_MEDIA_TYPE, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMediaTypes.VTable, self.vtable).Next(@ptrCast(*const IEnumMediaTypes, self), cMediaTypes, ppMediaTypes, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMediaTypes_Skip(self: *const T, cMediaTypes: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMediaTypes.VTable, self.vtable).Skip(@ptrCast(*const IEnumMediaTypes, self), cMediaTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMediaTypes_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMediaTypes.VTable, self.vtable).Reset(@ptrCast(*const IEnumMediaTypes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMediaTypes_Clone(self: *const T, ppEnum: ?*?*IEnumMediaTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMediaTypes.VTable, self.vtable).Clone(@ptrCast(*const IEnumMediaTypes, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFilterGraph_Value = @import("../zig.zig").Guid.initString("56a8689f-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFilterGraph = &IID_IFilterGraph_Value;
pub const IFilterGraph = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddFilter: fn(
            self: *const IFilterGraph,
            pFilter: ?*IBaseFilter,
            pName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFilter: fn(
            self: *const IFilterGraph,
            pFilter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFilters: fn(
            self: *const IFilterGraph,
            ppEnum: ?*?*IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindFilterByName: fn(
            self: *const IFilterGraph,
            pName: ?[*:0]const u16,
            ppFilter: ?*?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectDirect: fn(
            self: *const IFilterGraph,
            ppinOut: ?*IPin,
            ppinIn: ?*IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reconnect: fn(
            self: *const IFilterGraph,
            ppin: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IFilterGraph,
            ppin: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultSyncSource: fn(
            self: *const IFilterGraph,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_AddFilter(self: *const T, pFilter: ?*IBaseFilter, pName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph.VTable, self.vtable).AddFilter(@ptrCast(*const IFilterGraph, self), pFilter, pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_RemoveFilter(self: *const T, pFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph.VTable, self.vtable).RemoveFilter(@ptrCast(*const IFilterGraph, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_EnumFilters(self: *const T, ppEnum: ?*?*IEnumFilters) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph.VTable, self.vtable).EnumFilters(@ptrCast(*const IFilterGraph, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_FindFilterByName(self: *const T, pName: ?[*:0]const u16, ppFilter: ?*?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph.VTable, self.vtable).FindFilterByName(@ptrCast(*const IFilterGraph, self), pName, ppFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_ConnectDirect(self: *const T, ppinOut: ?*IPin, ppinIn: ?*IPin, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph.VTable, self.vtable).ConnectDirect(@ptrCast(*const IFilterGraph, self), ppinOut, ppinIn, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_Reconnect(self: *const T, ppin: ?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph.VTable, self.vtable).Reconnect(@ptrCast(*const IFilterGraph, self), ppin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_Disconnect(self: *const T, ppin: ?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph.VTable, self.vtable).Disconnect(@ptrCast(*const IFilterGraph, self), ppin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_SetDefaultSyncSource(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph.VTable, self.vtable).SetDefaultSyncSource(@ptrCast(*const IFilterGraph, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumFilters_Value = @import("../zig.zig").Guid.initString("56a86893-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IEnumFilters = &IID_IEnumFilters_Value;
pub const IEnumFilters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumFilters,
            cFilters: u32,
            ppFilter: [*]?*IBaseFilter,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumFilters,
            cFilters: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumFilters,
            ppEnum: ?*?*IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFilters_Next(self: *const T, cFilters: u32, ppFilter: [*]?*IBaseFilter, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFilters.VTable, self.vtable).Next(@ptrCast(*const IEnumFilters, self), cFilters, ppFilter, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFilters_Skip(self: *const T, cFilters: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFilters.VTable, self.vtable).Skip(@ptrCast(*const IEnumFilters, self), cFilters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFilters_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFilters.VTable, self.vtable).Reset(@ptrCast(*const IEnumFilters, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFilters_Clone(self: *const T, ppEnum: ?*?*IEnumFilters) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFilters.VTable, self.vtable).Clone(@ptrCast(*const IEnumFilters, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FILTER_STATE = enum(i32) {
    Stopped = 0,
    Paused = 1,
    Running = 2,
};
pub const State_Stopped = FILTER_STATE.Stopped;
pub const State_Paused = FILTER_STATE.Paused;
pub const State_Running = FILTER_STATE.Running;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaFilter_Value = @import("../zig.zig").Guid.initString("56a86899-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaFilter = &IID_IMediaFilter_Value;
pub const IMediaFilter = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        Stop: fn(
            self: *const IMediaFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IMediaFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IMediaFilter,
            tStart: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IMediaFilter,
            dwMilliSecsTimeout: u32,
            State: ?*FILTER_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncSource: fn(
            self: *const IMediaFilter,
            pClock: ?*IReferenceClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSyncSource: fn(
            self: *const IMediaFilter,
            pClock: ?*?*IReferenceClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaFilter.VTable, self.vtable).Stop(@ptrCast(*const IMediaFilter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaFilter.VTable, self.vtable).Pause(@ptrCast(*const IMediaFilter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_Run(self: *const T, tStart: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaFilter.VTable, self.vtable).Run(@ptrCast(*const IMediaFilter, self), tStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_GetState(self: *const T, dwMilliSecsTimeout: u32, State: ?*FILTER_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaFilter.VTable, self.vtable).GetState(@ptrCast(*const IMediaFilter, self), dwMilliSecsTimeout, State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_SetSyncSource(self: *const T, pClock: ?*IReferenceClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaFilter.VTable, self.vtable).SetSyncSource(@ptrCast(*const IMediaFilter, self), pClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_GetSyncSource(self: *const T, pClock: ?*?*IReferenceClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaFilter.VTable, self.vtable).GetSyncSource(@ptrCast(*const IMediaFilter, self), pClock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FILTER_INFO = extern struct {
    achName: [128]u16,
    pGraph: ?*IFilterGraph,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBaseFilter_Value = @import("../zig.zig").Guid.initString("56a86895-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IBaseFilter = &IID_IBaseFilter_Value;
pub const IBaseFilter = extern struct {
    pub const VTable = extern struct {
        base: IMediaFilter.VTable,
        EnumPins: fn(
            self: *const IBaseFilter,
            ppEnum: ?*?*IEnumPins,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindPin: fn(
            self: *const IBaseFilter,
            Id: ?[*:0]const u16,
            ppPin: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryFilterInfo: fn(
            self: *const IBaseFilter,
            pInfo: ?*FILTER_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinFilterGraph: fn(
            self: *const IBaseFilter,
            pGraph: ?*IFilterGraph,
            pName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryVendorInfo: fn(
            self: *const IBaseFilter,
            pVendorInfo: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaFilter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_EnumPins(self: *const T, ppEnum: ?*?*IEnumPins) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseFilter.VTable, self.vtable).EnumPins(@ptrCast(*const IBaseFilter, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_FindPin(self: *const T, Id: ?[*:0]const u16, ppPin: ?*?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseFilter.VTable, self.vtable).FindPin(@ptrCast(*const IBaseFilter, self), Id, ppPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_QueryFilterInfo(self: *const T, pInfo: ?*FILTER_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseFilter.VTable, self.vtable).QueryFilterInfo(@ptrCast(*const IBaseFilter, self), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_JoinFilterGraph(self: *const T, pGraph: ?*IFilterGraph, pName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseFilter.VTable, self.vtable).JoinFilterGraph(@ptrCast(*const IBaseFilter, self), pGraph, pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_QueryVendorInfo(self: *const T, pVendorInfo: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseFilter.VTable, self.vtable).QueryVendorInfo(@ptrCast(*const IBaseFilter, self), pVendorInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaSample_Value = @import("../zig.zig").Guid.initString("56a8689a-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaSample = &IID_IMediaSample_Value;
pub const IMediaSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPointer: fn(
            self: *const IMediaSample,
            ppBuffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetTime: fn(
            self: *const IMediaSample,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTime: fn(
            self: *const IMediaSample,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSyncPoint: fn(
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncPoint: fn(
            self: *const IMediaSample,
            bIsSyncPoint: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPreroll: fn(
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreroll: fn(
            self: *const IMediaSample,
            bIsPreroll: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualDataLength: fn(
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        SetActualDataLength: fn(
            self: *const IMediaSample,
            __MIDL__IMediaSample0000: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaType: fn(
            self: *const IMediaSample,
            ppMediaType: ?*?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaType: fn(
            self: *const IMediaSample,
            pMediaType: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDiscontinuity: fn(
            self: *const IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDiscontinuity: fn(
            self: *const IMediaSample,
            bDiscontinuity: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaTime: fn(
            self: *const IMediaSample,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaTime: fn(
            self: *const IMediaSample,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetPointer(self: *const T, ppBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).GetPointer(@ptrCast(*const IMediaSample, self), ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetSize(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).GetSize(@ptrCast(*const IMediaSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).GetTime(@ptrCast(*const IMediaSample, self), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).SetTime(@ptrCast(*const IMediaSample, self), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_IsSyncPoint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).IsSyncPoint(@ptrCast(*const IMediaSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetSyncPoint(self: *const T, bIsSyncPoint: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).SetSyncPoint(@ptrCast(*const IMediaSample, self), bIsSyncPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_IsPreroll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).IsPreroll(@ptrCast(*const IMediaSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetPreroll(self: *const T, bIsPreroll: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).SetPreroll(@ptrCast(*const IMediaSample, self), bIsPreroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetActualDataLength(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).GetActualDataLength(@ptrCast(*const IMediaSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetActualDataLength(self: *const T, __MIDL__IMediaSample0000: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).SetActualDataLength(@ptrCast(*const IMediaSample, self), __MIDL__IMediaSample0000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetMediaType(self: *const T, ppMediaType: ?*?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).GetMediaType(@ptrCast(*const IMediaSample, self), ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetMediaType(self: *const T, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).SetMediaType(@ptrCast(*const IMediaSample, self), pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_IsDiscontinuity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).IsDiscontinuity(@ptrCast(*const IMediaSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetDiscontinuity(self: *const T, bDiscontinuity: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).SetDiscontinuity(@ptrCast(*const IMediaSample, self), bDiscontinuity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetMediaTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).GetMediaTime(@ptrCast(*const IMediaSample, self), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetMediaTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample.VTable, self.vtable).SetMediaTime(@ptrCast(*const IMediaSample, self), pTimeStart, pTimeEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_SAMPLE_PROPERTY_FLAGS = enum(i32) {
    AMPLE_SPLICEPOINT = 1,
    AMPLE_PREROLL = 2,
    AMPLE_DATADISCONTINUITY = 4,
    AMPLE_TYPECHANGED = 8,
    AMPLE_TIMEVALID = 16,
    AMPLE_TIMEDISCONTINUITY = 64,
    AMPLE_FLUSH_ON_PAUSE = 128,
    AMPLE_STOPVALID = 256,
    AMPLE_ENDOFSTREAM = 512,
    TREAM_MEDIA = 0,
    // TREAM_CONTROL = 1, this enum value conflicts with AMPLE_SPLICEPOINT
};
pub const AM_SAMPLE_SPLICEPOINT = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_SPLICEPOINT;
pub const AM_SAMPLE_PREROLL = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_PREROLL;
pub const AM_SAMPLE_DATADISCONTINUITY = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_DATADISCONTINUITY;
pub const AM_SAMPLE_TYPECHANGED = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_TYPECHANGED;
pub const AM_SAMPLE_TIMEVALID = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_TIMEVALID;
pub const AM_SAMPLE_TIMEDISCONTINUITY = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_TIMEDISCONTINUITY;
pub const AM_SAMPLE_FLUSH_ON_PAUSE = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_FLUSH_ON_PAUSE;
pub const AM_SAMPLE_STOPVALID = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_STOPVALID;
pub const AM_SAMPLE_ENDOFSTREAM = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_ENDOFSTREAM;
pub const AM_STREAM_MEDIA = AM_SAMPLE_PROPERTY_FLAGS.TREAM_MEDIA;
pub const AM_STREAM_CONTROL = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_SPLICEPOINT;

pub const AM_SAMPLE2_PROPERTIES = extern struct {
    cbData: u32,
    dwTypeSpecificFlags: u32,
    dwSampleFlags: u32,
    lActual: i32,
    tStart: i64,
    tStop: i64,
    dwStreamId: u32,
    pMediaType: ?*AM_MEDIA_TYPE,
    pbBuffer: ?*u8,
    cbBuffer: i32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaSample2_Value = @import("../zig.zig").Guid.initString("36b73884-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IMediaSample2 = &IID_IMediaSample2_Value;
pub const IMediaSample2 = extern struct {
    pub const VTable = extern struct {
        base: IMediaSample.VTable,
        GetProperties: fn(
            self: *const IMediaSample2,
            cbProperties: u32,
            // TODO: what to do with BytesParamIndex 0?
            pbProperties: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const IMediaSample2,
            cbProperties: u32,
            // TODO: what to do with BytesParamIndex 0?
            pbProperties: ?*const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaSample.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample2_GetProperties(self: *const T, cbProperties: u32, pbProperties: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample2.VTable, self.vtable).GetProperties(@ptrCast(*const IMediaSample2, self), cbProperties, pbProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample2_SetProperties(self: *const T, cbProperties: u32, pbProperties: ?*const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample2.VTable, self.vtable).SetProperties(@ptrCast(*const IMediaSample2, self), cbProperties, pbProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMediaSample2Config_Value = @import("../zig.zig").Guid.initString("68961e68-832b-41ea-bc91-63593f3e70e3");
pub const IID_IMediaSample2Config = &IID_IMediaSample2Config_Value;
pub const IMediaSample2Config = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSurface: fn(
            self: *const IMediaSample2Config,
            ppDirect3DSurface9: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample2Config_GetSurface(self: *const T, ppDirect3DSurface9: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSample2Config.VTable, self.vtable).GetSurface(@ptrCast(*const IMediaSample2Config, self), ppDirect3DSurface9);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemAllocator_Value = @import("../zig.zig").Guid.initString("56a8689c-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMemAllocator = &IID_IMemAllocator_Value;
pub const IMemAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProperties: fn(
            self: *const IMemAllocator,
            pRequest: ?*ALLOCATOR_PROPERTIES,
            pActual: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const IMemAllocator,
            pProps: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IMemAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Decommit: fn(
            self: *const IMemAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffer: fn(
            self: *const IMemAllocator,
            ppBuffer: ?*?*IMediaSample,
            pStartTime: ?*i64,
            pEndTime: ?*i64,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBuffer: fn(
            self: *const IMemAllocator,
            pBuffer: ?*IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_SetProperties(self: *const T, pRequest: ?*ALLOCATOR_PROPERTIES, pActual: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemAllocator.VTable, self.vtable).SetProperties(@ptrCast(*const IMemAllocator, self), pRequest, pActual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_GetProperties(self: *const T, pProps: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemAllocator.VTable, self.vtable).GetProperties(@ptrCast(*const IMemAllocator, self), pProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_Commit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemAllocator.VTable, self.vtable).Commit(@ptrCast(*const IMemAllocator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_Decommit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemAllocator.VTable, self.vtable).Decommit(@ptrCast(*const IMemAllocator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_GetBuffer(self: *const T, ppBuffer: ?*?*IMediaSample, pStartTime: ?*i64, pEndTime: ?*i64, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemAllocator.VTable, self.vtable).GetBuffer(@ptrCast(*const IMemAllocator, self), ppBuffer, pStartTime, pEndTime, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_ReleaseBuffer(self: *const T, pBuffer: ?*IMediaSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemAllocator.VTable, self.vtable).ReleaseBuffer(@ptrCast(*const IMemAllocator, self), pBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemAllocatorCallbackTemp_Value = @import("../zig.zig").Guid.initString("379a0cf0-c1de-11d2-abf5-00a0c905f375");
pub const IID_IMemAllocatorCallbackTemp = &IID_IMemAllocatorCallbackTemp_Value;
pub const IMemAllocatorCallbackTemp = extern struct {
    pub const VTable = extern struct {
        base: IMemAllocator.VTable,
        SetNotify: fn(
            self: *const IMemAllocatorCallbackTemp,
            pNotify: ?*IMemAllocatorNotifyCallbackTemp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFreeCount: fn(
            self: *const IMemAllocatorCallbackTemp,
            plBuffersFree: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMemAllocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocatorCallbackTemp_SetNotify(self: *const T, pNotify: ?*IMemAllocatorNotifyCallbackTemp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemAllocatorCallbackTemp.VTable, self.vtable).SetNotify(@ptrCast(*const IMemAllocatorCallbackTemp, self), pNotify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocatorCallbackTemp_GetFreeCount(self: *const T, plBuffersFree: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemAllocatorCallbackTemp.VTable, self.vtable).GetFreeCount(@ptrCast(*const IMemAllocatorCallbackTemp, self), plBuffersFree);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemAllocatorNotifyCallbackTemp_Value = @import("../zig.zig").Guid.initString("92980b30-c1de-11d2-abf5-00a0c905f375");
pub const IID_IMemAllocatorNotifyCallbackTemp = &IID_IMemAllocatorNotifyCallbackTemp_Value;
pub const IMemAllocatorNotifyCallbackTemp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyRelease: fn(
            self: *const IMemAllocatorNotifyCallbackTemp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocatorNotifyCallbackTemp_NotifyRelease(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemAllocatorNotifyCallbackTemp.VTable, self.vtable).NotifyRelease(@ptrCast(*const IMemAllocatorNotifyCallbackTemp, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemInputPin_Value = @import("../zig.zig").Guid.initString("56a8689d-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMemInputPin = &IID_IMemInputPin_Value;
pub const IMemInputPin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAllocator: fn(
            self: *const IMemInputPin,
            ppAllocator: ?*?*IMemAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyAllocator: fn(
            self: *const IMemInputPin,
            pAllocator: ?*IMemAllocator,
            bReadOnly: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllocatorRequirements: fn(
            self: *const IMemInputPin,
            pProps: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Receive: fn(
            self: *const IMemInputPin,
            pSample: ?*IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReceiveMultiple: fn(
            self: *const IMemInputPin,
            pSamples: [*]?*IMediaSample,
            nSamples: i32,
            nSamplesProcessed: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReceiveCanBlock: fn(
            self: *const IMemInputPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_GetAllocator(self: *const T, ppAllocator: ?*?*IMemAllocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemInputPin.VTable, self.vtable).GetAllocator(@ptrCast(*const IMemInputPin, self), ppAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_NotifyAllocator(self: *const T, pAllocator: ?*IMemAllocator, bReadOnly: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemInputPin.VTable, self.vtable).NotifyAllocator(@ptrCast(*const IMemInputPin, self), pAllocator, bReadOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_GetAllocatorRequirements(self: *const T, pProps: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemInputPin.VTable, self.vtable).GetAllocatorRequirements(@ptrCast(*const IMemInputPin, self), pProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_Receive(self: *const T, pSample: ?*IMediaSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemInputPin.VTable, self.vtable).Receive(@ptrCast(*const IMemInputPin, self), pSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_ReceiveMultiple(self: *const T, pSamples: [*]?*IMediaSample, nSamples: i32, nSamplesProcessed: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemInputPin.VTable, self.vtable).ReceiveMultiple(@ptrCast(*const IMemInputPin, self), pSamples, nSamples, nSamplesProcessed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_ReceiveCanBlock(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemInputPin.VTable, self.vtable).ReceiveCanBlock(@ptrCast(*const IMemInputPin, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMovieSetup_Value = @import("../zig.zig").Guid.initString("a3d8cec0-7e5a-11cf-bbc5-00805f6cef20");
pub const IID_IAMovieSetup = &IID_IAMovieSetup_Value;
pub const IAMovieSetup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: fn(
            self: *const IAMovieSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: fn(
            self: *const IAMovieSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMovieSetup_Register(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMovieSetup.VTable, self.vtable).Register(@ptrCast(*const IAMovieSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMovieSetup_Unregister(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMovieSetup.VTable, self.vtable).Unregister(@ptrCast(*const IAMovieSetup, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_SEEKING_SeekingFlags = enum(i32) {
    NoPositioning = 0,
    AbsolutePositioning = 1,
    RelativePositioning = 2,
    IncrementalPositioning = 3,
    // PositioningBitsMask = 3, this enum value conflicts with IncrementalPositioning
    SeekToKeyFrame = 4,
    ReturnTime = 8,
    Segment = 16,
    NoFlush = 32,
};
pub const AM_SEEKING_NoPositioning = AM_SEEKING_SeekingFlags.NoPositioning;
pub const AM_SEEKING_AbsolutePositioning = AM_SEEKING_SeekingFlags.AbsolutePositioning;
pub const AM_SEEKING_RelativePositioning = AM_SEEKING_SeekingFlags.RelativePositioning;
pub const AM_SEEKING_IncrementalPositioning = AM_SEEKING_SeekingFlags.IncrementalPositioning;
pub const AM_SEEKING_PositioningBitsMask = AM_SEEKING_SeekingFlags.IncrementalPositioning;
pub const AM_SEEKING_SeekToKeyFrame = AM_SEEKING_SeekingFlags.SeekToKeyFrame;
pub const AM_SEEKING_ReturnTime = AM_SEEKING_SeekingFlags.ReturnTime;
pub const AM_SEEKING_Segment = AM_SEEKING_SeekingFlags.Segment;
pub const AM_SEEKING_NoFlush = AM_SEEKING_SeekingFlags.NoFlush;

pub const AM_SEEKING_SEEKING_CAPABILITIES = enum(i32) {
    CanSeekAbsolute = 1,
    CanSeekForwards = 2,
    CanSeekBackwards = 4,
    CanGetCurrentPos = 8,
    CanGetStopPos = 16,
    CanGetDuration = 32,
    CanPlayBackwards = 64,
    CanDoSegments = 128,
    Source = 256,
};
pub const AM_SEEKING_CanSeekAbsolute = AM_SEEKING_SEEKING_CAPABILITIES.CanSeekAbsolute;
pub const AM_SEEKING_CanSeekForwards = AM_SEEKING_SEEKING_CAPABILITIES.CanSeekForwards;
pub const AM_SEEKING_CanSeekBackwards = AM_SEEKING_SEEKING_CAPABILITIES.CanSeekBackwards;
pub const AM_SEEKING_CanGetCurrentPos = AM_SEEKING_SEEKING_CAPABILITIES.CanGetCurrentPos;
pub const AM_SEEKING_CanGetStopPos = AM_SEEKING_SEEKING_CAPABILITIES.CanGetStopPos;
pub const AM_SEEKING_CanGetDuration = AM_SEEKING_SEEKING_CAPABILITIES.CanGetDuration;
pub const AM_SEEKING_CanPlayBackwards = AM_SEEKING_SEEKING_CAPABILITIES.CanPlayBackwards;
pub const AM_SEEKING_CanDoSegments = AM_SEEKING_SEEKING_CAPABILITIES.CanDoSegments;
pub const AM_SEEKING_Source = AM_SEEKING_SEEKING_CAPABILITIES.Source;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaSeeking_Value = @import("../zig.zig").Guid.initString("36b73880-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IMediaSeeking = &IID_IMediaSeeking_Value;
pub const IMediaSeeking = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilities: fn(
            self: *const IMediaSeeking,
            pCapabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckCapabilities: fn(
            self: *const IMediaSeeking,
            pCapabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsFormatSupported: fn(
            self: *const IMediaSeeking,
            pFormat: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPreferredFormat: fn(
            self: *const IMediaSeeking,
            pFormat: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeFormat: fn(
            self: *const IMediaSeeking,
            pFormat: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUsingTimeFormat: fn(
            self: *const IMediaSeeking,
            pFormat: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimeFormat: fn(
            self: *const IMediaSeeking,
            pFormat: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuration: fn(
            self: *const IMediaSeeking,
            pDuration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStopPosition: fn(
            self: *const IMediaSeeking,
            pStop: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPosition: fn(
            self: *const IMediaSeeking,
            pCurrent: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertTimeFormat: fn(
            self: *const IMediaSeeking,
            pTarget: ?*i64,
            pTargetFormat: ?*const Guid,
            Source: i64,
            pSourceFormat: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPositions: fn(
            self: *const IMediaSeeking,
            pCurrent: ?*i64,
            dwCurrentFlags: u32,
            pStop: ?*i64,
            dwStopFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositions: fn(
            self: *const IMediaSeeking,
            pCurrent: ?*i64,
            pStop: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailable: fn(
            self: *const IMediaSeeking,
            pEarliest: ?*i64,
            pLatest: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRate: fn(
            self: *const IMediaSeeking,
            dRate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRate: fn(
            self: *const IMediaSeeking,
            pdRate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreroll: fn(
            self: *const IMediaSeeking,
            pllPreroll: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetCapabilities(self: *const T, pCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).GetCapabilities(@ptrCast(*const IMediaSeeking, self), pCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_CheckCapabilities(self: *const T, pCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).CheckCapabilities(@ptrCast(*const IMediaSeeking, self), pCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_IsFormatSupported(self: *const T, pFormat: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).IsFormatSupported(@ptrCast(*const IMediaSeeking, self), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_QueryPreferredFormat(self: *const T, pFormat: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).QueryPreferredFormat(@ptrCast(*const IMediaSeeking, self), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetTimeFormat(self: *const T, pFormat: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).GetTimeFormat(@ptrCast(*const IMediaSeeking, self), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_IsUsingTimeFormat(self: *const T, pFormat: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).IsUsingTimeFormat(@ptrCast(*const IMediaSeeking, self), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_SetTimeFormat(self: *const T, pFormat: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).SetTimeFormat(@ptrCast(*const IMediaSeeking, self), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetDuration(self: *const T, pDuration: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).GetDuration(@ptrCast(*const IMediaSeeking, self), pDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetStopPosition(self: *const T, pStop: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).GetStopPosition(@ptrCast(*const IMediaSeeking, self), pStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetCurrentPosition(self: *const T, pCurrent: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).GetCurrentPosition(@ptrCast(*const IMediaSeeking, self), pCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_ConvertTimeFormat(self: *const T, pTarget: ?*i64, pTargetFormat: ?*const Guid, Source: i64, pSourceFormat: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).ConvertTimeFormat(@ptrCast(*const IMediaSeeking, self), pTarget, pTargetFormat, Source, pSourceFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_SetPositions(self: *const T, pCurrent: ?*i64, dwCurrentFlags: u32, pStop: ?*i64, dwStopFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).SetPositions(@ptrCast(*const IMediaSeeking, self), pCurrent, dwCurrentFlags, pStop, dwStopFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetPositions(self: *const T, pCurrent: ?*i64, pStop: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).GetPositions(@ptrCast(*const IMediaSeeking, self), pCurrent, pStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetAvailable(self: *const T, pEarliest: ?*i64, pLatest: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).GetAvailable(@ptrCast(*const IMediaSeeking, self), pEarliest, pLatest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_SetRate(self: *const T, dRate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).SetRate(@ptrCast(*const IMediaSeeking, self), dRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetRate(self: *const T, pdRate: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).GetRate(@ptrCast(*const IMediaSeeking, self), pdRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetPreroll(self: *const T, pllPreroll: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaSeeking.VTable, self.vtable).GetPreroll(@ptrCast(*const IMediaSeeking, self), pllPreroll);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_MEDIAEVENT_FLAGS = enum(i32) {
    Y = 1,
};
pub const AM_MEDIAEVENT_NONOTIFY = AM_MEDIAEVENT_FLAGS.Y;

pub const REGFILTER = extern struct {
    Clsid: Guid,
    Name: ?PWSTR,
};

const IID_IEnumRegFilters_Value = @import("../zig.zig").Guid.initString("56a868a4-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IEnumRegFilters = &IID_IEnumRegFilters_Value;
pub const IEnumRegFilters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumRegFilters,
            cFilters: u32,
            apRegFilter: [*]?*REGFILTER,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumRegFilters,
            cFilters: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumRegFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumRegFilters,
            ppEnum: ?*?*IEnumRegFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegFilters_Next(self: *const T, cFilters: u32, apRegFilter: [*]?*REGFILTER, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegFilters.VTable, self.vtable).Next(@ptrCast(*const IEnumRegFilters, self), cFilters, apRegFilter, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegFilters_Skip(self: *const T, cFilters: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegFilters.VTable, self.vtable).Skip(@ptrCast(*const IEnumRegFilters, self), cFilters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegFilters_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegFilters.VTable, self.vtable).Reset(@ptrCast(*const IEnumRegFilters, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegFilters_Clone(self: *const T, ppEnum: ?*?*IEnumRegFilters) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegFilters.VTable, self.vtable).Clone(@ptrCast(*const IEnumRegFilters, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IFILTERMAPPER_MERIT = enum(i32) {
    PREFERRED = 8388608,
    NORMAL = 6291456,
    UNLIKELY = 4194304,
    DO_NOT_USE = 2097152,
    SW_COMPRESSOR = 1048576,
    HW_COMPRESSOR = 1048656,
};
pub const MERIT_PREFERRED = IFILTERMAPPER_MERIT.PREFERRED;
pub const MERIT_NORMAL = IFILTERMAPPER_MERIT.NORMAL;
pub const MERIT_UNLIKELY = IFILTERMAPPER_MERIT.UNLIKELY;
pub const MERIT_DO_NOT_USE = IFILTERMAPPER_MERIT.DO_NOT_USE;
pub const MERIT_SW_COMPRESSOR = IFILTERMAPPER_MERIT.SW_COMPRESSOR;
pub const MERIT_HW_COMPRESSOR = IFILTERMAPPER_MERIT.HW_COMPRESSOR;

const IID_IFilterMapper_Value = @import("../zig.zig").Guid.initString("56a868a3-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFilterMapper = &IID_IFilterMapper_Value;
pub const IFilterMapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterFilter: fn(
            self: *const IFilterMapper,
            clsid: Guid,
            Name: ?[*:0]const u16,
            dwMerit: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterFilterInstance: fn(
            self: *const IFilterMapper,
            clsid: Guid,
            Name: ?[*:0]const u16,
            MRId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterPin: fn(
            self: *const IFilterMapper,
            Filter: Guid,
            Name: ?[*:0]const u16,
            bRendered: BOOL,
            bOutput: BOOL,
            bZero: BOOL,
            bMany: BOOL,
            ConnectsToFilter: Guid,
            ConnectsToPin: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterPinType: fn(
            self: *const IFilterMapper,
            clsFilter: Guid,
            strName: ?[*:0]const u16,
            clsMajorType: Guid,
            clsSubType: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterFilter: fn(
            self: *const IFilterMapper,
            Filter: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterFilterInstance: fn(
            self: *const IFilterMapper,
            MRId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterPin: fn(
            self: *const IFilterMapper,
            Filter: Guid,
            Name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMatchingFilters: fn(
            self: *const IFilterMapper,
            ppEnum: ?*?*IEnumRegFilters,
            dwMerit: u32,
            bInputNeeded: BOOL,
            clsInMaj: Guid,
            clsInSub: Guid,
            bRender: BOOL,
            bOututNeeded: BOOL,
            clsOutMaj: Guid,
            clsOutSub: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_RegisterFilter(self: *const T, clsid: Guid, Name: ?[*:0]const u16, dwMerit: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper.VTable, self.vtable).RegisterFilter(@ptrCast(*const IFilterMapper, self), clsid, Name, dwMerit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_RegisterFilterInstance(self: *const T, clsid: Guid, Name: ?[*:0]const u16, MRId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper.VTable, self.vtable).RegisterFilterInstance(@ptrCast(*const IFilterMapper, self), clsid, Name, MRId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_RegisterPin(self: *const T, Filter: Guid, Name: ?[*:0]const u16, bRendered: BOOL, bOutput: BOOL, bZero: BOOL, bMany: BOOL, ConnectsToFilter: Guid, ConnectsToPin: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper.VTable, self.vtable).RegisterPin(@ptrCast(*const IFilterMapper, self), Filter, Name, bRendered, bOutput, bZero, bMany, ConnectsToFilter, ConnectsToPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_RegisterPinType(self: *const T, clsFilter: Guid, strName: ?[*:0]const u16, clsMajorType: Guid, clsSubType: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper.VTable, self.vtable).RegisterPinType(@ptrCast(*const IFilterMapper, self), clsFilter, strName, clsMajorType, clsSubType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_UnregisterFilter(self: *const T, Filter: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper.VTable, self.vtable).UnregisterFilter(@ptrCast(*const IFilterMapper, self), Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_UnregisterFilterInstance(self: *const T, MRId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper.VTable, self.vtable).UnregisterFilterInstance(@ptrCast(*const IFilterMapper, self), MRId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_UnregisterPin(self: *const T, Filter: Guid, Name: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper.VTable, self.vtable).UnregisterPin(@ptrCast(*const IFilterMapper, self), Filter, Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_EnumMatchingFilters(self: *const T, ppEnum: ?*?*IEnumRegFilters, dwMerit: u32, bInputNeeded: BOOL, clsInMaj: Guid, clsInSub: Guid, bRender: BOOL, bOututNeeded: BOOL, clsOutMaj: Guid, clsOutSub: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper.VTable, self.vtable).EnumMatchingFilters(@ptrCast(*const IFilterMapper, self), ppEnum, dwMerit, bInputNeeded, clsInMaj, clsInSub, bRender, bOututNeeded, clsOutMaj, clsOutSub);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const REGPINTYPES = extern struct {
    clsMajorType: ?*const Guid,
    clsMinorType: ?*const Guid,
};

pub const REGFILTERPINS = extern struct {
    strName: ?PWSTR,
    bRendered: BOOL,
    bOutput: BOOL,
    bZero: BOOL,
    bMany: BOOL,
    clsConnectsToFilter: ?*const Guid,
    strConnectsToPin: ?[*:0]const u16,
    nMediaTypes: u32,
    lpMediaType: ?*const REGPINTYPES,
};

pub const REGPINMEDIUM = extern struct {
    clsMedium: Guid,
    dw1: u32,
    dw2: u32,
};

pub const REG_PINFLAG = enum(u32) {
    ZERO = 1,
    RENDERER = 2,
    MANY = 4,
    OUTPUT = 8,
    _,
    pub fn initFlags(o: struct {
        ZERO: u1 = 0,
        RENDERER: u1 = 0,
        MANY: u1 = 0,
        OUTPUT: u1 = 0,
    }) REG_PINFLAG {
        return @intToEnum(REG_PINFLAG,
              (if (o.ZERO == 1) @enumToInt(REG_PINFLAG.ZERO) else 0)
            | (if (o.RENDERER == 1) @enumToInt(REG_PINFLAG.RENDERER) else 0)
            | (if (o.MANY == 1) @enumToInt(REG_PINFLAG.MANY) else 0)
            | (if (o.OUTPUT == 1) @enumToInt(REG_PINFLAG.OUTPUT) else 0)
        );
    }
};
pub const REG_PINFLAG_B_ZERO = REG_PINFLAG.ZERO;
pub const REG_PINFLAG_B_RENDERER = REG_PINFLAG.RENDERER;
pub const REG_PINFLAG_B_MANY = REG_PINFLAG.MANY;
pub const REG_PINFLAG_B_OUTPUT = REG_PINFLAG.OUTPUT;

pub const REGFILTERPINS2 = extern struct {
    dwFlags: u32,
    cInstances: u32,
    nMediaTypes: u32,
    lpMediaType: ?*const REGPINTYPES,
    nMediums: u32,
    lpMedium: ?*const REGPINMEDIUM,
    clsPinCategory: ?*const Guid,
};

pub const REGFILTER2 = extern struct {
    dwVersion: u32,
    dwMerit: u32,
    Anonymous: extern union {
        Anonymous1: extern struct {
            cPins: u32,
            rgPins: ?*const REGFILTERPINS,
        },
        Anonymous2: extern struct {
            cPins2: u32,
            rgPins2: ?*const REGFILTERPINS2,
        },
    },
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFilterMapper2_Value = @import("../zig.zig").Guid.initString("b79bb0b0-33c1-11d1-abe1-00a0c905f375");
pub const IID_IFilterMapper2 = &IID_IFilterMapper2_Value;
pub const IFilterMapper2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCategory: fn(
            self: *const IFilterMapper2,
            clsidCategory: ?*const Guid,
            dwCategoryMerit: u32,
            Description: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterFilter: fn(
            self: *const IFilterMapper2,
            pclsidCategory: ?*const Guid,
            szInstance: ?[*:0]const u16,
            Filter: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterFilter: fn(
            self: *const IFilterMapper2,
            clsidFilter: ?*const Guid,
            Name: ?[*:0]const u16,
            ppMoniker: ?*?*IMoniker,
            pclsidCategory: ?*const Guid,
            szInstance: ?[*:0]const u16,
            prf2: ?*const REGFILTER2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMatchingFilters: fn(
            self: *const IFilterMapper2,
            ppEnum: ?*?*IEnumMoniker,
            dwFlags: u32,
            bExactMatch: BOOL,
            dwMerit: u32,
            bInputNeeded: BOOL,
            cInputTypes: u32,
            pInputTypes: ?*const Guid,
            pMedIn: ?*const REGPINMEDIUM,
            pPinCategoryIn: ?*const Guid,
            bRender: BOOL,
            bOutputNeeded: BOOL,
            cOutputTypes: u32,
            pOutputTypes: ?*const Guid,
            pMedOut: ?*const REGPINMEDIUM,
            pPinCategoryOut: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper2_CreateCategory(self: *const T, clsidCategory: ?*const Guid, dwCategoryMerit: u32, Description: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper2.VTable, self.vtable).CreateCategory(@ptrCast(*const IFilterMapper2, self), clsidCategory, dwCategoryMerit, Description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper2_UnregisterFilter(self: *const T, pclsidCategory: ?*const Guid, szInstance: ?[*:0]const u16, Filter: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper2.VTable, self.vtable).UnregisterFilter(@ptrCast(*const IFilterMapper2, self), pclsidCategory, szInstance, Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper2_RegisterFilter(self: *const T, clsidFilter: ?*const Guid, Name: ?[*:0]const u16, ppMoniker: ?*?*IMoniker, pclsidCategory: ?*const Guid, szInstance: ?[*:0]const u16, prf2: ?*const REGFILTER2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper2.VTable, self.vtable).RegisterFilter(@ptrCast(*const IFilterMapper2, self), clsidFilter, Name, ppMoniker, pclsidCategory, szInstance, prf2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper2_EnumMatchingFilters(self: *const T, ppEnum: ?*?*IEnumMoniker, dwFlags: u32, bExactMatch: BOOL, dwMerit: u32, bInputNeeded: BOOL, cInputTypes: u32, pInputTypes: ?*const Guid, pMedIn: ?*const REGPINMEDIUM, pPinCategoryIn: ?*const Guid, bRender: BOOL, bOutputNeeded: BOOL, cOutputTypes: u32, pOutputTypes: ?*const Guid, pMedOut: ?*const REGPINMEDIUM, pPinCategoryOut: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper2.VTable, self.vtable).EnumMatchingFilters(@ptrCast(*const IFilterMapper2, self), ppEnum, dwFlags, bExactMatch, dwMerit, bInputNeeded, cInputTypes, pInputTypes, pMedIn, pPinCategoryIn, bRender, bOutputNeeded, cOutputTypes, pOutputTypes, pMedOut, pPinCategoryOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFilterMapper3_Value = @import("../zig.zig").Guid.initString("b79bb0b1-33c1-11d1-abe1-00a0c905f375");
pub const IID_IFilterMapper3 = &IID_IFilterMapper3_Value;
pub const IFilterMapper3 = extern struct {
    pub const VTable = extern struct {
        base: IFilterMapper2.VTable,
        GetICreateDevEnum: fn(
            self: *const IFilterMapper3,
            ppEnum: ?*?*ICreateDevEnum,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFilterMapper2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper3_GetICreateDevEnum(self: *const T, ppEnum: ?*?*ICreateDevEnum) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterMapper3.VTable, self.vtable).GetICreateDevEnum(@ptrCast(*const IFilterMapper3, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const QualityMessageType = enum(i32) {
    amine = 0,
    lood = 1,
};
pub const Famine = QualityMessageType.amine;
pub const Flood = QualityMessageType.lood;

pub const Quality = extern struct {
    Type: QualityMessageType,
    Proportion: i32,
    Late: i64,
    TimeStamp: i64,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQualityControl_Value = @import("../zig.zig").Guid.initString("56a868a5-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IQualityControl = &IID_IQualityControl_Value;
pub const IQualityControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: fn(
            self: *const IQualityControl,
            pSelf: ?*IBaseFilter,
            q: Quality,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSink: fn(
            self: *const IQualityControl,
            piqc: ?*IQualityControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualityControl_Notify(self: *const T, pSelf: ?*IBaseFilter, q: Quality) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQualityControl.VTable, self.vtable).Notify(@ptrCast(*const IQualityControl, self), pSelf, q);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualityControl_SetSink(self: *const T, piqc: ?*IQualityControl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQualityControl.VTable, self.vtable).SetSink(@ptrCast(*const IQualityControl, self), piqc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COLORKEY_TYPE = enum(i32) {
    NOCOLORKEY = 0,
    INDEX = 1,
    RGB = 2,
};
pub const CK_NOCOLORKEY = COLORKEY_TYPE.NOCOLORKEY;
pub const CK_INDEX = COLORKEY_TYPE.INDEX;
pub const CK_RGB = COLORKEY_TYPE.RGB;

pub const COLORKEY = extern struct {
    KeyType: u32,
    PaletteIndex: u32,
    LowColorValue: u32,
    HighColorValue: u32,
};

pub const ADVISE_TYPE = enum(u32) {
    NONE = 0,
    CLIPPING = 1,
    PALETTE = 2,
    COLORKEY = 4,
    POSITION = 8,
    DISPLAY_CHANGE = 16,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CLIPPING: u1 = 0,
        PALETTE: u1 = 0,
        COLORKEY: u1 = 0,
        POSITION: u1 = 0,
        DISPLAY_CHANGE: u1 = 0,
    }) ADVISE_TYPE {
        return @intToEnum(ADVISE_TYPE,
              (if (o.NONE == 1) @enumToInt(ADVISE_TYPE.NONE) else 0)
            | (if (o.CLIPPING == 1) @enumToInt(ADVISE_TYPE.CLIPPING) else 0)
            | (if (o.PALETTE == 1) @enumToInt(ADVISE_TYPE.PALETTE) else 0)
            | (if (o.COLORKEY == 1) @enumToInt(ADVISE_TYPE.COLORKEY) else 0)
            | (if (o.POSITION == 1) @enumToInt(ADVISE_TYPE.POSITION) else 0)
            | (if (o.DISPLAY_CHANGE == 1) @enumToInt(ADVISE_TYPE.DISPLAY_CHANGE) else 0)
        );
    }
};
pub const ADVISE_NONE = ADVISE_TYPE.NONE;
pub const ADVISE_CLIPPING = ADVISE_TYPE.CLIPPING;
pub const ADVISE_PALETTE = ADVISE_TYPE.PALETTE;
pub const ADVISE_COLORKEY = ADVISE_TYPE.COLORKEY;
pub const ADVISE_POSITION = ADVISE_TYPE.POSITION;
pub const ADVISE_DISPLAY_CHANGE = ADVISE_TYPE.DISPLAY_CHANGE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOverlayNotify_Value = @import("../zig.zig").Guid.initString("56a868a0-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IOverlayNotify = &IID_IOverlayNotify_Value;
pub const IOverlayNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPaletteChange: fn(
            self: *const IOverlayNotify,
            dwColors: u32,
            pPalette: ?*const PALETTEENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnClipChange: fn(
            self: *const IOverlayNotify,
            pSourceRect: ?*const RECT,
            pDestinationRect: ?*const RECT,
            pRgnData: ?*const RGNDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnColorKeyChange: fn(
            self: *const IOverlayNotify,
            pColorKey: ?*const COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPositionChange: fn(
            self: *const IOverlayNotify,
            pSourceRect: ?*const RECT,
            pDestinationRect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify_OnPaletteChange(self: *const T, dwColors: u32, pPalette: ?*const PALETTEENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlayNotify.VTable, self.vtable).OnPaletteChange(@ptrCast(*const IOverlayNotify, self), dwColors, pPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify_OnClipChange(self: *const T, pSourceRect: ?*const RECT, pDestinationRect: ?*const RECT, pRgnData: ?*const RGNDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlayNotify.VTable, self.vtable).OnClipChange(@ptrCast(*const IOverlayNotify, self), pSourceRect, pDestinationRect, pRgnData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify_OnColorKeyChange(self: *const T, pColorKey: ?*const COLORKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlayNotify.VTable, self.vtable).OnColorKeyChange(@ptrCast(*const IOverlayNotify, self), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify_OnPositionChange(self: *const T, pSourceRect: ?*const RECT, pDestinationRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlayNotify.VTable, self.vtable).OnPositionChange(@ptrCast(*const IOverlayNotify, self), pSourceRect, pDestinationRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOverlayNotify2_Value = @import("../zig.zig").Guid.initString("680efa10-d535-11d1-87c8-00a0c9223196");
pub const IID_IOverlayNotify2 = &IID_IOverlayNotify2_Value;
pub const IOverlayNotify2 = extern struct {
    pub const VTable = extern struct {
        base: IOverlayNotify.VTable,
        OnDisplayChange: fn(
            self: *const IOverlayNotify2,
            hMonitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOverlayNotify.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify2_OnDisplayChange(self: *const T, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlayNotify2.VTable, self.vtable).OnDisplayChange(@ptrCast(*const IOverlayNotify2, self), hMonitor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOverlay_Value = @import("../zig.zig").Guid.initString("56a868a1-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IOverlay = &IID_IOverlay_Value;
pub const IOverlay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPalette: fn(
            self: *const IOverlay,
            pdwColors: ?*u32,
            ppPalette: [*]?*PALETTEENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPalette: fn(
            self: *const IOverlay,
            dwColors: u32,
            pPalette: [*]PALETTEENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultColorKey: fn(
            self: *const IOverlay,
            pColorKey: ?*COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorKey: fn(
            self: *const IOverlay,
            pColorKey: ?*COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorKey: fn(
            self: *const IOverlay,
            pColorKey: ?*COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindowHandle: fn(
            self: *const IOverlay,
            pHwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipList: fn(
            self: *const IOverlay,
            pSourceRect: ?*RECT,
            pDestinationRect: ?*RECT,
            ppRgnData: ?*?*RGNDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPosition: fn(
            self: *const IOverlay,
            pSourceRect: ?*RECT,
            pDestinationRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IOverlay,
            pOverlayNotify: ?*IOverlayNotify,
            dwInterests: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IOverlay,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetPalette(self: *const T, pdwColors: ?*u32, ppPalette: [*]?*PALETTEENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).GetPalette(@ptrCast(*const IOverlay, self), pdwColors, ppPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_SetPalette(self: *const T, dwColors: u32, pPalette: [*]PALETTEENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).SetPalette(@ptrCast(*const IOverlay, self), dwColors, pPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetDefaultColorKey(self: *const T, pColorKey: ?*COLORKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).GetDefaultColorKey(@ptrCast(*const IOverlay, self), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetColorKey(self: *const T, pColorKey: ?*COLORKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).GetColorKey(@ptrCast(*const IOverlay, self), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_SetColorKey(self: *const T, pColorKey: ?*COLORKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).SetColorKey(@ptrCast(*const IOverlay, self), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetWindowHandle(self: *const T, pHwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).GetWindowHandle(@ptrCast(*const IOverlay, self), pHwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetClipList(self: *const T, pSourceRect: ?*RECT, pDestinationRect: ?*RECT, ppRgnData: ?*?*RGNDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).GetClipList(@ptrCast(*const IOverlay, self), pSourceRect, pDestinationRect, ppRgnData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetVideoPosition(self: *const T, pSourceRect: ?*RECT, pDestinationRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).GetVideoPosition(@ptrCast(*const IOverlay, self), pSourceRect, pDestinationRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_Advise(self: *const T, pOverlayNotify: ?*IOverlayNotify, dwInterests: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).Advise(@ptrCast(*const IOverlay, self), pOverlayNotify, dwInterests);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_Unadvise(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOverlay.VTable, self.vtable).Unadvise(@ptrCast(*const IOverlay, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaEventSink_Value = @import("../zig.zig").Guid.initString("56a868a2-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaEventSink = &IID_IMediaEventSink_Value;
pub const IMediaEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: fn(
            self: *const IMediaEventSink,
            EventCode: i32,
            EventParam1: isize,
            EventParam2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEventSink_Notify(self: *const T, EventCode: i32, EventParam1: isize, EventParam2: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEventSink.VTable, self.vtable).Notify(@ptrCast(*const IMediaEventSink, self), EventCode, EventParam1, EventParam2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSourceFilter_Value = @import("../zig.zig").Guid.initString("56a868a6-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFileSourceFilter = &IID_IFileSourceFilter_Value;
pub const IFileSourceFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Load: fn(
            self: *const IFileSourceFilter,
            pszFileName: ?[*:0]const u16,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurFile: fn(
            self: *const IFileSourceFilter,
            ppszFileName: ?*?PWSTR,
            pmt: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSourceFilter_Load(self: *const T, pszFileName: ?[*:0]const u16, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSourceFilter.VTable, self.vtable).Load(@ptrCast(*const IFileSourceFilter, self), pszFileName, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSourceFilter_GetCurFile(self: *const T, ppszFileName: ?*?PWSTR, pmt: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSourceFilter.VTable, self.vtable).GetCurFile(@ptrCast(*const IFileSourceFilter, self), ppszFileName, pmt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSinkFilter_Value = @import("../zig.zig").Guid.initString("a2104830-7c70-11cf-8bce-00aa00a3f1a6");
pub const IID_IFileSinkFilter = &IID_IFileSinkFilter_Value;
pub const IFileSinkFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFileName: fn(
            self: *const IFileSinkFilter,
            pszFileName: ?[*:0]const u16,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurFile: fn(
            self: *const IFileSinkFilter,
            ppszFileName: ?*?PWSTR,
            pmt: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSinkFilter_SetFileName(self: *const T, pszFileName: ?[*:0]const u16, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSinkFilter.VTable, self.vtable).SetFileName(@ptrCast(*const IFileSinkFilter, self), pszFileName, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSinkFilter_GetCurFile(self: *const T, ppszFileName: ?*?PWSTR, pmt: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSinkFilter.VTable, self.vtable).GetCurFile(@ptrCast(*const IFileSinkFilter, self), ppszFileName, pmt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSinkFilter2_Value = @import("../zig.zig").Guid.initString("00855b90-ce1b-11d0-bd4f-00a0c911ce86");
pub const IID_IFileSinkFilter2 = &IID_IFileSinkFilter2_Value;
pub const IFileSinkFilter2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSinkFilter.VTable,
        SetMode: fn(
            self: *const IFileSinkFilter2,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMode: fn(
            self: *const IFileSinkFilter2,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileSinkFilter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSinkFilter2_SetMode(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSinkFilter2.VTable, self.vtable).SetMode(@ptrCast(*const IFileSinkFilter2, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSinkFilter2_GetMode(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSinkFilter2.VTable, self.vtable).GetMode(@ptrCast(*const IFileSinkFilter2, self), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_FILESINK_FLAGS = enum(i32) {
    E = 1,
};
pub const AM_FILE_OVERWRITE = AM_FILESINK_FLAGS.E;

// TODO: this type is limited to platform 'windows5.0'
const IID_IGraphBuilder_Value = @import("../zig.zig").Guid.initString("56a868a9-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IGraphBuilder = &IID_IGraphBuilder_Value;
pub const IGraphBuilder = extern struct {
    pub const VTable = extern struct {
        base: IFilterGraph.VTable,
        Connect: fn(
            self: *const IGraphBuilder,
            ppinOut: ?*IPin,
            ppinIn: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Render: fn(
            self: *const IGraphBuilder,
            ppinOut: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderFile: fn(
            self: *const IGraphBuilder,
            lpcwstrFile: ?[*:0]const u16,
            lpcwstrPlayList: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSourceFilter: fn(
            self: *const IGraphBuilder,
            lpcwstrFileName: ?[*:0]const u16,
            lpcwstrFilterName: ?[*:0]const u16,
            ppFilter: ?*?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLogFile: fn(
            self: *const IGraphBuilder,
            hFile: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShouldOperationContinue: fn(
            self: *const IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFilterGraph.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_Connect(self: *const T, ppinOut: ?*IPin, ppinIn: ?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphBuilder.VTable, self.vtable).Connect(@ptrCast(*const IGraphBuilder, self), ppinOut, ppinIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_Render(self: *const T, ppinOut: ?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphBuilder.VTable, self.vtable).Render(@ptrCast(*const IGraphBuilder, self), ppinOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_RenderFile(self: *const T, lpcwstrFile: ?[*:0]const u16, lpcwstrPlayList: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphBuilder.VTable, self.vtable).RenderFile(@ptrCast(*const IGraphBuilder, self), lpcwstrFile, lpcwstrPlayList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_AddSourceFilter(self: *const T, lpcwstrFileName: ?[*:0]const u16, lpcwstrFilterName: ?[*:0]const u16, ppFilter: ?*?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphBuilder.VTable, self.vtable).AddSourceFilter(@ptrCast(*const IGraphBuilder, self), lpcwstrFileName, lpcwstrFilterName, ppFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_SetLogFile(self: *const T, hFile: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphBuilder.VTable, self.vtable).SetLogFile(@ptrCast(*const IGraphBuilder, self), hFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphBuilder.VTable, self.vtable).Abort(@ptrCast(*const IGraphBuilder, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_ShouldOperationContinue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphBuilder.VTable, self.vtable).ShouldOperationContinue(@ptrCast(*const IGraphBuilder, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICaptureGraphBuilder_Value = @import("../zig.zig").Guid.initString("bf87b6e0-8c27-11d0-b3f0-00aa003761c5");
pub const IID_ICaptureGraphBuilder = &IID_ICaptureGraphBuilder_Value;
pub const ICaptureGraphBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFiltergraph: fn(
            self: *const ICaptureGraphBuilder,
            pfg: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFiltergraph: fn(
            self: *const ICaptureGraphBuilder,
            ppfg: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputFileName: fn(
            self: *const ICaptureGraphBuilder,
            pType: ?*const Guid,
            lpstrFile: ?[*:0]const u16,
            ppf: ?*?*IBaseFilter,
            ppSink: ?*?*IFileSinkFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindInterface: fn(
            self: *const ICaptureGraphBuilder,
            pCategory: ?*const Guid,
            pf: ?*IBaseFilter,
            riid: ?*const Guid,
            ppint: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderStream: fn(
            self: *const ICaptureGraphBuilder,
            pCategory: ?*const Guid,
            pSource: ?*IUnknown,
            pfCompressor: ?*IBaseFilter,
            pfRenderer: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlStream: fn(
            self: *const ICaptureGraphBuilder,
            pCategory: ?*const Guid,
            pFilter: ?*IBaseFilter,
            pstart: ?*i64,
            pstop: ?*i64,
            wStartCookie: u16,
            wStopCookie: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocCapFile: fn(
            self: *const ICaptureGraphBuilder,
            lpstr: ?[*:0]const u16,
            dwlSize: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyCaptureFile: fn(
            self: *const ICaptureGraphBuilder,
            lpwstrOld: ?PWSTR,
            lpwstrNew: ?PWSTR,
            fAllowEscAbort: i32,
            pCallback: ?*IAMCopyCaptureFileProgress,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_SetFiltergraph(self: *const T, pfg: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder.VTable, self.vtable).SetFiltergraph(@ptrCast(*const ICaptureGraphBuilder, self), pfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_GetFiltergraph(self: *const T, ppfg: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder.VTable, self.vtable).GetFiltergraph(@ptrCast(*const ICaptureGraphBuilder, self), ppfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_SetOutputFileName(self: *const T, pType: ?*const Guid, lpstrFile: ?[*:0]const u16, ppf: ?*?*IBaseFilter, ppSink: ?*?*IFileSinkFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder.VTable, self.vtable).SetOutputFileName(@ptrCast(*const ICaptureGraphBuilder, self), pType, lpstrFile, ppf, ppSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_FindInterface(self: *const T, pCategory: ?*const Guid, pf: ?*IBaseFilter, riid: ?*const Guid, ppint: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder.VTable, self.vtable).FindInterface(@ptrCast(*const ICaptureGraphBuilder, self), pCategory, pf, riid, ppint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_RenderStream(self: *const T, pCategory: ?*const Guid, pSource: ?*IUnknown, pfCompressor: ?*IBaseFilter, pfRenderer: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder.VTable, self.vtable).RenderStream(@ptrCast(*const ICaptureGraphBuilder, self), pCategory, pSource, pfCompressor, pfRenderer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_ControlStream(self: *const T, pCategory: ?*const Guid, pFilter: ?*IBaseFilter, pstart: ?*i64, pstop: ?*i64, wStartCookie: u16, wStopCookie: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder.VTable, self.vtable).ControlStream(@ptrCast(*const ICaptureGraphBuilder, self), pCategory, pFilter, pstart, pstop, wStartCookie, wStopCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_AllocCapFile(self: *const T, lpstr: ?[*:0]const u16, dwlSize: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder.VTable, self.vtable).AllocCapFile(@ptrCast(*const ICaptureGraphBuilder, self), lpstr, dwlSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_CopyCaptureFile(self: *const T, lpwstrOld: ?PWSTR, lpwstrNew: ?PWSTR, fAllowEscAbort: i32, pCallback: ?*IAMCopyCaptureFileProgress) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder.VTable, self.vtable).CopyCaptureFile(@ptrCast(*const ICaptureGraphBuilder, self), lpwstrOld, lpwstrNew, fAllowEscAbort, pCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMCopyCaptureFileProgress_Value = @import("../zig.zig").Guid.initString("670d1d20-a068-11d0-b3f0-00aa003761c5");
pub const IID_IAMCopyCaptureFileProgress = &IID_IAMCopyCaptureFileProgress_Value;
pub const IAMCopyCaptureFileProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Progress: fn(
            self: *const IAMCopyCaptureFileProgress,
            iProgress: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCopyCaptureFileProgress_Progress(self: *const T, iProgress: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCopyCaptureFileProgress.VTable, self.vtable).Progress(@ptrCast(*const IAMCopyCaptureFileProgress, self), iProgress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICaptureGraphBuilder2_Value = @import("../zig.zig").Guid.initString("93e5a4e0-2d50-11d2-abfa-00a0c9c6e38d");
pub const IID_ICaptureGraphBuilder2 = &IID_ICaptureGraphBuilder2_Value;
pub const ICaptureGraphBuilder2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFiltergraph: fn(
            self: *const ICaptureGraphBuilder2,
            pfg: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFiltergraph: fn(
            self: *const ICaptureGraphBuilder2,
            ppfg: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputFileName: fn(
            self: *const ICaptureGraphBuilder2,
            pType: ?*const Guid,
            lpstrFile: ?[*:0]const u16,
            ppf: ?*?*IBaseFilter,
            ppSink: ?*?*IFileSinkFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindInterface: fn(
            self: *const ICaptureGraphBuilder2,
            pCategory: ?*const Guid,
            pType: ?*const Guid,
            pf: ?*IBaseFilter,
            riid: ?*const Guid,
            ppint: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderStream: fn(
            self: *const ICaptureGraphBuilder2,
            pCategory: ?*const Guid,
            pType: ?*const Guid,
            pSource: ?*IUnknown,
            pfCompressor: ?*IBaseFilter,
            pfRenderer: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlStream: fn(
            self: *const ICaptureGraphBuilder2,
            pCategory: ?*const Guid,
            pType: ?*const Guid,
            pFilter: ?*IBaseFilter,
            pstart: ?*i64,
            pstop: ?*i64,
            wStartCookie: u16,
            wStopCookie: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocCapFile: fn(
            self: *const ICaptureGraphBuilder2,
            lpstr: ?[*:0]const u16,
            dwlSize: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyCaptureFile: fn(
            self: *const ICaptureGraphBuilder2,
            lpwstrOld: ?PWSTR,
            lpwstrNew: ?PWSTR,
            fAllowEscAbort: i32,
            pCallback: ?*IAMCopyCaptureFileProgress,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindPin: fn(
            self: *const ICaptureGraphBuilder2,
            pSource: ?*IUnknown,
            pindir: PIN_DIRECTION,
            pCategory: ?*const Guid,
            pType: ?*const Guid,
            fUnconnected: BOOL,
            num: i32,
            ppPin: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_SetFiltergraph(self: *const T, pfg: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder2.VTable, self.vtable).SetFiltergraph(@ptrCast(*const ICaptureGraphBuilder2, self), pfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_GetFiltergraph(self: *const T, ppfg: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder2.VTable, self.vtable).GetFiltergraph(@ptrCast(*const ICaptureGraphBuilder2, self), ppfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_SetOutputFileName(self: *const T, pType: ?*const Guid, lpstrFile: ?[*:0]const u16, ppf: ?*?*IBaseFilter, ppSink: ?*?*IFileSinkFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder2.VTable, self.vtable).SetOutputFileName(@ptrCast(*const ICaptureGraphBuilder2, self), pType, lpstrFile, ppf, ppSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_FindInterface(self: *const T, pCategory: ?*const Guid, pType: ?*const Guid, pf: ?*IBaseFilter, riid: ?*const Guid, ppint: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder2.VTable, self.vtable).FindInterface(@ptrCast(*const ICaptureGraphBuilder2, self), pCategory, pType, pf, riid, ppint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_RenderStream(self: *const T, pCategory: ?*const Guid, pType: ?*const Guid, pSource: ?*IUnknown, pfCompressor: ?*IBaseFilter, pfRenderer: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder2.VTable, self.vtable).RenderStream(@ptrCast(*const ICaptureGraphBuilder2, self), pCategory, pType, pSource, pfCompressor, pfRenderer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_ControlStream(self: *const T, pCategory: ?*const Guid, pType: ?*const Guid, pFilter: ?*IBaseFilter, pstart: ?*i64, pstop: ?*i64, wStartCookie: u16, wStopCookie: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder2.VTable, self.vtable).ControlStream(@ptrCast(*const ICaptureGraphBuilder2, self), pCategory, pType, pFilter, pstart, pstop, wStartCookie, wStopCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_AllocCapFile(self: *const T, lpstr: ?[*:0]const u16, dwlSize: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder2.VTable, self.vtable).AllocCapFile(@ptrCast(*const ICaptureGraphBuilder2, self), lpstr, dwlSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_CopyCaptureFile(self: *const T, lpwstrOld: ?PWSTR, lpwstrNew: ?PWSTR, fAllowEscAbort: i32, pCallback: ?*IAMCopyCaptureFileProgress) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder2.VTable, self.vtable).CopyCaptureFile(@ptrCast(*const ICaptureGraphBuilder2, self), lpwstrOld, lpwstrNew, fAllowEscAbort, pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_FindPin(self: *const T, pSource: ?*IUnknown, pindir: PIN_DIRECTION, pCategory: ?*const Guid, pType: ?*const Guid, fUnconnected: BOOL, num: i32, ppPin: ?*?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptureGraphBuilder2.VTable, self.vtable).FindPin(@ptrCast(*const ICaptureGraphBuilder2, self), pSource, pindir, pCategory, pType, fUnconnected, num, ppPin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_RENSDEREXFLAGS = enum(i32) {
    S = 1,
};
pub const AM_RENDEREX_RENDERTOEXISTINGRENDERERS = _AM_RENSDEREXFLAGS.S;

// TODO: this type is limited to platform 'windows5.0'
const IID_IFilterGraph2_Value = @import("../zig.zig").Guid.initString("36b73882-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IFilterGraph2 = &IID_IFilterGraph2_Value;
pub const IFilterGraph2 = extern struct {
    pub const VTable = extern struct {
        base: IGraphBuilder.VTable,
        AddSourceFilterForMoniker: fn(
            self: *const IFilterGraph2,
            pMoniker: ?*IMoniker,
            pCtx: ?*IBindCtx,
            lpcwstrFilterName: ?[*:0]const u16,
            ppFilter: ?*?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReconnectEx: fn(
            self: *const IFilterGraph2,
            ppin: ?*IPin,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderEx: fn(
            self: *const IFilterGraph2,
            pPinOut: ?*IPin,
            dwFlags: u32,
            pvContext: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IGraphBuilder.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph2_AddSourceFilterForMoniker(self: *const T, pMoniker: ?*IMoniker, pCtx: ?*IBindCtx, lpcwstrFilterName: ?[*:0]const u16, ppFilter: ?*?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph2.VTable, self.vtable).AddSourceFilterForMoniker(@ptrCast(*const IFilterGraph2, self), pMoniker, pCtx, lpcwstrFilterName, ppFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph2_ReconnectEx(self: *const T, ppin: ?*IPin, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph2.VTable, self.vtable).ReconnectEx(@ptrCast(*const IFilterGraph2, self), ppin, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph2_RenderEx(self: *const T, pPinOut: ?*IPin, dwFlags: u32, pvContext: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph2.VTable, self.vtable).RenderEx(@ptrCast(*const IFilterGraph2, self), pPinOut, dwFlags, pvContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFilterGraph3_Value = @import("../zig.zig").Guid.initString("aaf38154-b80b-422f-91e6-b66467509a07");
pub const IID_IFilterGraph3 = &IID_IFilterGraph3_Value;
pub const IFilterGraph3 = extern struct {
    pub const VTable = extern struct {
        base: IFilterGraph2.VTable,
        SetSyncSourceEx: fn(
            self: *const IFilterGraph3,
            pClockForMostOfFilterGraph: ?*IReferenceClock,
            pClockForFilter: ?*IReferenceClock,
            pFilter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFilterGraph2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph3_SetSyncSourceEx(self: *const T, pClockForMostOfFilterGraph: ?*IReferenceClock, pClockForFilter: ?*IReferenceClock, pFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterGraph3.VTable, self.vtable).SetSyncSourceEx(@ptrCast(*const IFilterGraph3, self), pClockForMostOfFilterGraph, pClockForFilter, pFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStreamBuilder_Value = @import("../zig.zig").Guid.initString("56a868bf-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IStreamBuilder = &IID_IStreamBuilder_Value;
pub const IStreamBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Render: fn(
            self: *const IStreamBuilder,
            ppinOut: ?*IPin,
            pGraph: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Backout: fn(
            self: *const IStreamBuilder,
            ppinOut: ?*IPin,
            pGraph: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBuilder_Render(self: *const T, ppinOut: ?*IPin, pGraph: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBuilder.VTable, self.vtable).Render(@ptrCast(*const IStreamBuilder, self), ppinOut, pGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBuilder_Backout(self: *const T, ppinOut: ?*IPin, pGraph: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBuilder.VTable, self.vtable).Backout(@ptrCast(*const IStreamBuilder, self), ppinOut, pGraph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAsyncReader_Value = @import("../zig.zig").Guid.initString("56a868aa-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAsyncReader = &IID_IAsyncReader_Value;
pub const IAsyncReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestAllocator: fn(
            self: *const IAsyncReader,
            pPreferred: ?*IMemAllocator,
            pProps: ?*ALLOCATOR_PROPERTIES,
            ppActual: ?*?*IMemAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Request: fn(
            self: *const IAsyncReader,
            pSample: ?*IMediaSample,
            dwUser: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForNext: fn(
            self: *const IAsyncReader,
            dwTimeout: u32,
            ppSample: ?*?*IMediaSample,
            pdwUser: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SyncReadAligned: fn(
            self: *const IAsyncReader,
            pSample: ?*IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SyncRead: fn(
            self: *const IAsyncReader,
            llPosition: i64,
            lLength: i32,
            // TODO: what to do with BytesParamIndex 1?
            pBuffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Length: fn(
            self: *const IAsyncReader,
            pTotal: ?*i64,
            pAvailable: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginFlush: fn(
            self: *const IAsyncReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndFlush: fn(
            self: *const IAsyncReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_RequestAllocator(self: *const T, pPreferred: ?*IMemAllocator, pProps: ?*ALLOCATOR_PROPERTIES, ppActual: ?*?*IMemAllocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncReader.VTable, self.vtable).RequestAllocator(@ptrCast(*const IAsyncReader, self), pPreferred, pProps, ppActual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_Request(self: *const T, pSample: ?*IMediaSample, dwUser: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncReader.VTable, self.vtable).Request(@ptrCast(*const IAsyncReader, self), pSample, dwUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_WaitForNext(self: *const T, dwTimeout: u32, ppSample: ?*?*IMediaSample, pdwUser: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncReader.VTable, self.vtable).WaitForNext(@ptrCast(*const IAsyncReader, self), dwTimeout, ppSample, pdwUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_SyncReadAligned(self: *const T, pSample: ?*IMediaSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncReader.VTable, self.vtable).SyncReadAligned(@ptrCast(*const IAsyncReader, self), pSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_SyncRead(self: *const T, llPosition: i64, lLength: i32, pBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncReader.VTable, self.vtable).SyncRead(@ptrCast(*const IAsyncReader, self), llPosition, lLength, pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_Length(self: *const T, pTotal: ?*i64, pAvailable: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncReader.VTable, self.vtable).Length(@ptrCast(*const IAsyncReader, self), pTotal, pAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_BeginFlush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncReader.VTable, self.vtable).BeginFlush(@ptrCast(*const IAsyncReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_EndFlush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncReader.VTable, self.vtable).EndFlush(@ptrCast(*const IAsyncReader, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IGraphVersion_Value = @import("../zig.zig").Guid.initString("56a868ab-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IGraphVersion = &IID_IGraphVersion_Value;
pub const IGraphVersion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryVersion: fn(
            self: *const IGraphVersion,
            pVersion: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphVersion_QueryVersion(self: *const T, pVersion: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphVersion.VTable, self.vtable).QueryVersion(@ptrCast(*const IGraphVersion, self), pVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IResourceConsumer_Value = @import("../zig.zig").Guid.initString("56a868ad-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IResourceConsumer = &IID_IResourceConsumer_Value;
pub const IResourceConsumer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcquireResource: fn(
            self: *const IResourceConsumer,
            idResource: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseResource: fn(
            self: *const IResourceConsumer,
            idResource: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceConsumer_AcquireResource(self: *const T, idResource: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceConsumer.VTable, self.vtable).AcquireResource(@ptrCast(*const IResourceConsumer, self), idResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceConsumer_ReleaseResource(self: *const T, idResource: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceConsumer.VTable, self.vtable).ReleaseResource(@ptrCast(*const IResourceConsumer, self), idResource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IResourceManager_Value = @import("../zig.zig").Guid.initString("56a868ac-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IResourceManager = &IID_IResourceManager_Value;
pub const IResourceManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: fn(
            self: *const IResourceManager,
            pName: ?[*:0]const u16,
            cResource: i32,
            plToken: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterGroup: fn(
            self: *const IResourceManager,
            pName: ?[*:0]const u16,
            cResource: i32,
            palTokens: [*]i32,
            plToken: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestResource: fn(
            self: *const IResourceManager,
            idResource: i32,
            pFocusObject: ?*IUnknown,
            pConsumer: ?*IResourceConsumer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyAcquire: fn(
            self: *const IResourceManager,
            idResource: i32,
            pConsumer: ?*IResourceConsumer,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyRelease: fn(
            self: *const IResourceManager,
            idResource: i32,
            pConsumer: ?*IResourceConsumer,
            bStillWant: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelRequest: fn(
            self: *const IResourceManager,
            idResource: i32,
            pConsumer: ?*IResourceConsumer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocus: fn(
            self: *const IResourceManager,
            pFocusObject: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseFocus: fn(
            self: *const IResourceManager,
            pFocusObject: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_Register(self: *const T, pName: ?[*:0]const u16, cResource: i32, plToken: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceManager.VTable, self.vtable).Register(@ptrCast(*const IResourceManager, self), pName, cResource, plToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_RegisterGroup(self: *const T, pName: ?[*:0]const u16, cResource: i32, palTokens: [*]i32, plToken: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceManager.VTable, self.vtable).RegisterGroup(@ptrCast(*const IResourceManager, self), pName, cResource, palTokens, plToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_RequestResource(self: *const T, idResource: i32, pFocusObject: ?*IUnknown, pConsumer: ?*IResourceConsumer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceManager.VTable, self.vtable).RequestResource(@ptrCast(*const IResourceManager, self), idResource, pFocusObject, pConsumer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_NotifyAcquire(self: *const T, idResource: i32, pConsumer: ?*IResourceConsumer, hr: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceManager.VTable, self.vtable).NotifyAcquire(@ptrCast(*const IResourceManager, self), idResource, pConsumer, hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_NotifyRelease(self: *const T, idResource: i32, pConsumer: ?*IResourceConsumer, bStillWant: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceManager.VTable, self.vtable).NotifyRelease(@ptrCast(*const IResourceManager, self), idResource, pConsumer, bStillWant);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_CancelRequest(self: *const T, idResource: i32, pConsumer: ?*IResourceConsumer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceManager.VTable, self.vtable).CancelRequest(@ptrCast(*const IResourceManager, self), idResource, pConsumer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_SetFocus(self: *const T, pFocusObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceManager.VTable, self.vtable).SetFocus(@ptrCast(*const IResourceManager, self), pFocusObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_ReleaseFocus(self: *const T, pFocusObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResourceManager.VTable, self.vtable).ReleaseFocus(@ptrCast(*const IResourceManager, self), pFocusObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDistributorNotify_Value = @import("../zig.zig").Guid.initString("56a868af-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IDistributorNotify = &IID_IDistributorNotify_Value;
pub const IDistributorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Stop: fn(
            self: *const IDistributorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IDistributorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IDistributorNotify,
            tStart: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncSource: fn(
            self: *const IDistributorNotify,
            pClock: ?*IReferenceClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyGraphChange: fn(
            self: *const IDistributorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDistributorNotify.VTable, self.vtable).Stop(@ptrCast(*const IDistributorNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDistributorNotify.VTable, self.vtable).Pause(@ptrCast(*const IDistributorNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_Run(self: *const T, tStart: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDistributorNotify.VTable, self.vtable).Run(@ptrCast(*const IDistributorNotify, self), tStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_SetSyncSource(self: *const T, pClock: ?*IReferenceClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDistributorNotify.VTable, self.vtable).SetSyncSource(@ptrCast(*const IDistributorNotify, self), pClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_NotifyGraphChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDistributorNotify.VTable, self.vtable).NotifyGraphChange(@ptrCast(*const IDistributorNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_STREAM_INFO_FLAGS = enum(i32) {
    START_DEFINED = 1,
    STOP_DEFINED = 2,
    DISCARDING = 4,
    STOP_SEND_EXTRA = 16,
};
pub const AM_STREAM_INFO_START_DEFINED = AM_STREAM_INFO_FLAGS.START_DEFINED;
pub const AM_STREAM_INFO_STOP_DEFINED = AM_STREAM_INFO_FLAGS.STOP_DEFINED;
pub const AM_STREAM_INFO_DISCARDING = AM_STREAM_INFO_FLAGS.DISCARDING;
pub const AM_STREAM_INFO_STOP_SEND_EXTRA = AM_STREAM_INFO_FLAGS.STOP_SEND_EXTRA;

pub const AM_STREAM_INFO = extern struct {
    tStart: i64,
    tStop: i64,
    dwStartCookie: u32,
    dwStopCookie: u32,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMStreamControl_Value = @import("../zig.zig").Guid.initString("36b73881-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IAMStreamControl = &IID_IAMStreamControl_Value;
pub const IAMStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartAt: fn(
            self: *const IAMStreamControl,
            ptStart: ?*const i64,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopAt: fn(
            self: *const IAMStreamControl,
            ptStop: ?*const i64,
            bSendExtra: BOOL,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfo: fn(
            self: *const IAMStreamControl,
            pInfo: ?*AM_STREAM_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamControl_StartAt(self: *const T, ptStart: ?*const i64, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamControl.VTable, self.vtable).StartAt(@ptrCast(*const IAMStreamControl, self), ptStart, dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamControl_StopAt(self: *const T, ptStop: ?*const i64, bSendExtra: BOOL, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamControl.VTable, self.vtable).StopAt(@ptrCast(*const IAMStreamControl, self), ptStop, bSendExtra, dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamControl_GetInfo(self: *const T, pInfo: ?*AM_STREAM_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamControl.VTable, self.vtable).GetInfo(@ptrCast(*const IAMStreamControl, self), pInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISeekingPassThru_Value = @import("../zig.zig").Guid.initString("36b73883-c2c8-11cf-8b46-00805f6cef60");
pub const IID_ISeekingPassThru = &IID_ISeekingPassThru_Value;
pub const ISeekingPassThru = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const ISeekingPassThru,
            bSupportRendering: BOOL,
            pPin: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISeekingPassThru_Init(self: *const T, bSupportRendering: BOOL, pPin: ?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISeekingPassThru.VTable, self.vtable).Init(@ptrCast(*const ISeekingPassThru, self), bSupportRendering, pPin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VIDEO_STREAM_CONFIG_CAPS = extern struct {
    guid: Guid,
    VideoStandard: u32,
    InputSize: SIZE,
    MinCroppingSize: SIZE,
    MaxCroppingSize: SIZE,
    CropGranularityX: i32,
    CropGranularityY: i32,
    CropAlignX: i32,
    CropAlignY: i32,
    MinOutputSize: SIZE,
    MaxOutputSize: SIZE,
    OutputGranularityX: i32,
    OutputGranularityY: i32,
    StretchTapsX: i32,
    StretchTapsY: i32,
    ShrinkTapsX: i32,
    ShrinkTapsY: i32,
    MinFrameInterval: i64,
    MaxFrameInterval: i64,
    MinBitsPerSecond: i32,
    MaxBitsPerSecond: i32,
};

pub const AUDIO_STREAM_CONFIG_CAPS = extern struct {
    guid: Guid,
    MinimumChannels: u32,
    MaximumChannels: u32,
    ChannelsGranularity: u32,
    MinimumBitsPerSample: u32,
    MaximumBitsPerSample: u32,
    BitsPerSampleGranularity: u32,
    MinimumSampleFrequency: u32,
    MaximumSampleFrequency: u32,
    SampleFrequencyGranularity: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMStreamConfig_Value = @import("../zig.zig").Guid.initString("c6e13340-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMStreamConfig = &IID_IAMStreamConfig_Value;
pub const IAMStreamConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFormat: fn(
            self: *const IAMStreamConfig,
            pmt: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormat: fn(
            self: *const IAMStreamConfig,
            ppmt: ?*?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfCapabilities: fn(
            self: *const IAMStreamConfig,
            piCount: ?*i32,
            piSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamCaps: fn(
            self: *const IAMStreamConfig,
            iIndex: i32,
            ppmt: ?*?*AM_MEDIA_TYPE,
            pSCC: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamConfig_SetFormat(self: *const T, pmt: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamConfig.VTable, self.vtable).SetFormat(@ptrCast(*const IAMStreamConfig, self), pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamConfig_GetFormat(self: *const T, ppmt: ?*?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamConfig.VTable, self.vtable).GetFormat(@ptrCast(*const IAMStreamConfig, self), ppmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamConfig_GetNumberOfCapabilities(self: *const T, piCount: ?*i32, piSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamConfig.VTable, self.vtable).GetNumberOfCapabilities(@ptrCast(*const IAMStreamConfig, self), piCount, piSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamConfig_GetStreamCaps(self: *const T, iIndex: i32, ppmt: ?*?*AM_MEDIA_TYPE, pSCC: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamConfig.VTable, self.vtable).GetStreamCaps(@ptrCast(*const IAMStreamConfig, self), iIndex, ppmt, pSCC);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const InterleavingMode = enum(i32) {
    NONE = 0,
    CAPTURE = 1,
    FULL = 2,
    NONE_BUFFERED = 3,
};
pub const INTERLEAVE_NONE = InterleavingMode.NONE;
pub const INTERLEAVE_CAPTURE = InterleavingMode.CAPTURE;
pub const INTERLEAVE_FULL = InterleavingMode.FULL;
pub const INTERLEAVE_NONE_BUFFERED = InterleavingMode.NONE_BUFFERED;

// TODO: this type is limited to platform 'windows5.0'
const IID_IConfigInterleaving_Value = @import("../zig.zig").Guid.initString("bee3d220-157b-11d0-bd23-00a0c911ce86");
pub const IID_IConfigInterleaving = &IID_IConfigInterleaving_Value;
pub const IConfigInterleaving = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: fn(
            self: *const IConfigInterleaving,
            mode: InterleavingMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: fn(
            self: *const IConfigInterleaving,
            pMode: ?*InterleavingMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Interleaving: fn(
            self: *const IConfigInterleaving,
            prtInterleave: ?*const i64,
            prtPreroll: ?*const i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Interleaving: fn(
            self: *const IConfigInterleaving,
            prtInterleave: ?*i64,
            prtPreroll: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigInterleaving_put_Mode(self: *const T, mode: InterleavingMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigInterleaving.VTable, self.vtable).put_Mode(@ptrCast(*const IConfigInterleaving, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigInterleaving_get_Mode(self: *const T, pMode: ?*InterleavingMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigInterleaving.VTable, self.vtable).get_Mode(@ptrCast(*const IConfigInterleaving, self), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigInterleaving_put_Interleaving(self: *const T, prtInterleave: ?*const i64, prtPreroll: ?*const i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigInterleaving.VTable, self.vtable).put_Interleaving(@ptrCast(*const IConfigInterleaving, self), prtInterleave, prtPreroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigInterleaving_get_Interleaving(self: *const T, prtInterleave: ?*i64, prtPreroll: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigInterleaving.VTable, self.vtable).get_Interleaving(@ptrCast(*const IConfigInterleaving, self), prtInterleave, prtPreroll);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConfigAviMux_Value = @import("../zig.zig").Guid.initString("5acd6aa0-f482-11ce-8b67-00aa00a3f1a6");
pub const IID_IConfigAviMux = &IID_IConfigAviMux_Value;
pub const IConfigAviMux = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMasterStream: fn(
            self: *const IConfigAviMux,
            iStream: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMasterStream: fn(
            self: *const IConfigAviMux,
            pStream: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCompatibilityIndex: fn(
            self: *const IConfigAviMux,
            fOldIndex: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCompatibilityIndex: fn(
            self: *const IConfigAviMux,
            pfOldIndex: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAviMux_SetMasterStream(self: *const T, iStream: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAviMux.VTable, self.vtable).SetMasterStream(@ptrCast(*const IConfigAviMux, self), iStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAviMux_GetMasterStream(self: *const T, pStream: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAviMux.VTable, self.vtable).GetMasterStream(@ptrCast(*const IConfigAviMux, self), pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAviMux_SetOutputCompatibilityIndex(self: *const T, fOldIndex: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAviMux.VTable, self.vtable).SetOutputCompatibilityIndex(@ptrCast(*const IConfigAviMux, self), fOldIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAviMux_GetOutputCompatibilityIndex(self: *const T, pfOldIndex: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAviMux.VTable, self.vtable).GetOutputCompatibilityIndex(@ptrCast(*const IConfigAviMux, self), pfOldIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CompressionCaps = enum(i32) {
    Quality = 1,
    Crunch = 2,
    KeyFrame = 4,
    BFrame = 8,
    Window = 16,
};
pub const CompressionCaps_CanQuality = CompressionCaps.Quality;
pub const CompressionCaps_CanCrunch = CompressionCaps.Crunch;
pub const CompressionCaps_CanKeyFrame = CompressionCaps.KeyFrame;
pub const CompressionCaps_CanBFrame = CompressionCaps.BFrame;
pub const CompressionCaps_CanWindow = CompressionCaps.Window;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoCompression_Value = @import("../zig.zig").Guid.initString("c6e13343-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMVideoCompression = &IID_IAMVideoCompression_Value;
pub const IAMVideoCompression = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeyFrameRate: fn(
            self: *const IAMVideoCompression,
            KeyFrameRate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyFrameRate: fn(
            self: *const IAMVideoCompression,
            pKeyFrameRate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PFramesPerKeyFrame: fn(
            self: *const IAMVideoCompression,
            PFramesPerKeyFrame: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PFramesPerKeyFrame: fn(
            self: *const IAMVideoCompression,
            pPFramesPerKeyFrame: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Quality: fn(
            self: *const IAMVideoCompression,
            Quality: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Quality: fn(
            self: *const IAMVideoCompression,
            pQuality: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowSize: fn(
            self: *const IAMVideoCompression,
            WindowSize: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowSize: fn(
            self: *const IAMVideoCompression,
            pWindowSize: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfo: fn(
            self: *const IAMVideoCompression,
            // TODO: what to do with BytesParamIndex 1?
            pszVersion: ?PWSTR,
            pcbVersion: ?*i32,
            // TODO: what to do with BytesParamIndex 3?
            pszDescription: ?PWSTR,
            pcbDescription: ?*i32,
            pDefaultKeyFrameRate: ?*i32,
            pDefaultPFramesPerKey: ?*i32,
            pDefaultQuality: ?*f64,
            pCapabilities: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OverrideKeyFrame: fn(
            self: *const IAMVideoCompression,
            FrameNumber: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OverrideFrameSize: fn(
            self: *const IAMVideoCompression,
            FrameNumber: i32,
            Size: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_put_KeyFrameRate(self: *const T, KeyFrameRate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).put_KeyFrameRate(@ptrCast(*const IAMVideoCompression, self), KeyFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_get_KeyFrameRate(self: *const T, pKeyFrameRate: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).get_KeyFrameRate(@ptrCast(*const IAMVideoCompression, self), pKeyFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_put_PFramesPerKeyFrame(self: *const T, PFramesPerKeyFrame: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).put_PFramesPerKeyFrame(@ptrCast(*const IAMVideoCompression, self), PFramesPerKeyFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_get_PFramesPerKeyFrame(self: *const T, pPFramesPerKeyFrame: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).get_PFramesPerKeyFrame(@ptrCast(*const IAMVideoCompression, self), pPFramesPerKeyFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_put_Quality(self: *const T, _param_Quality: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).put_Quality(@ptrCast(*const IAMVideoCompression, self), _param_Quality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_get_Quality(self: *const T, pQuality: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).get_Quality(@ptrCast(*const IAMVideoCompression, self), pQuality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_put_WindowSize(self: *const T, WindowSize: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).put_WindowSize(@ptrCast(*const IAMVideoCompression, self), WindowSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_get_WindowSize(self: *const T, pWindowSize: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).get_WindowSize(@ptrCast(*const IAMVideoCompression, self), pWindowSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_GetInfo(self: *const T, pszVersion: ?PWSTR, pcbVersion: ?*i32, pszDescription: ?PWSTR, pcbDescription: ?*i32, pDefaultKeyFrameRate: ?*i32, pDefaultPFramesPerKey: ?*i32, pDefaultQuality: ?*f64, pCapabilities: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).GetInfo(@ptrCast(*const IAMVideoCompression, self), pszVersion, pcbVersion, pszDescription, pcbDescription, pDefaultKeyFrameRate, pDefaultPFramesPerKey, pDefaultQuality, pCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_OverrideKeyFrame(self: *const T, FrameNumber: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).OverrideKeyFrame(@ptrCast(*const IAMVideoCompression, self), FrameNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_OverrideFrameSize(self: *const T, FrameNumber: i32, Size: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoCompression.VTable, self.vtable).OverrideFrameSize(@ptrCast(*const IAMVideoCompression, self), FrameNumber, Size);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VfwCaptureDialogs = enum(i32) {
    Source = 1,
    Format = 2,
    Display = 4,
};
pub const VfwCaptureDialog_Source = VfwCaptureDialogs.Source;
pub const VfwCaptureDialog_Format = VfwCaptureDialogs.Format;
pub const VfwCaptureDialog_Display = VfwCaptureDialogs.Display;

pub const VfwCompressDialogs = enum(i32) {
    Config = 1,
    About = 2,
    QueryConfig = 4,
    QueryAbout = 8,
};
pub const VfwCompressDialog_Config = VfwCompressDialogs.Config;
pub const VfwCompressDialog_About = VfwCompressDialogs.About;
pub const VfwCompressDialog_QueryConfig = VfwCompressDialogs.QueryConfig;
pub const VfwCompressDialog_QueryAbout = VfwCompressDialogs.QueryAbout;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVfwCaptureDialogs_Value = @import("../zig.zig").Guid.initString("d8d715a0-6e5e-11d0-b3f0-00aa003761c5");
pub const IID_IAMVfwCaptureDialogs = &IID_IAMVfwCaptureDialogs_Value;
pub const IAMVfwCaptureDialogs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HasDialog: fn(
            self: *const IAMVfwCaptureDialogs,
            iDialog: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowDialog: fn(
            self: *const IAMVfwCaptureDialogs,
            iDialog: i32,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendDriverMessage: fn(
            self: *const IAMVfwCaptureDialogs,
            iDialog: i32,
            uMsg: i32,
            dw1: i32,
            dw2: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCaptureDialogs_HasDialog(self: *const T, iDialog: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVfwCaptureDialogs.VTable, self.vtable).HasDialog(@ptrCast(*const IAMVfwCaptureDialogs, self), iDialog);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCaptureDialogs_ShowDialog(self: *const T, iDialog: i32, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVfwCaptureDialogs.VTable, self.vtable).ShowDialog(@ptrCast(*const IAMVfwCaptureDialogs, self), iDialog, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCaptureDialogs_SendDriverMessage(self: *const T, iDialog: i32, uMsg: i32, dw1: i32, dw2: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVfwCaptureDialogs.VTable, self.vtable).SendDriverMessage(@ptrCast(*const IAMVfwCaptureDialogs, self), iDialog, uMsg, dw1, dw2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVfwCompressDialogs_Value = @import("../zig.zig").Guid.initString("d8d715a3-6e5e-11d0-b3f0-00aa003761c5");
pub const IID_IAMVfwCompressDialogs = &IID_IAMVfwCompressDialogs_Value;
pub const IAMVfwCompressDialogs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowDialog: fn(
            self: *const IAMVfwCompressDialogs,
            iDialog: i32,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IAMVfwCompressDialogs,
            // TODO: what to do with BytesParamIndex 1?
            pState: ?*anyopaque,
            pcbState: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetState: fn(
            self: *const IAMVfwCompressDialogs,
            // TODO: what to do with BytesParamIndex 1?
            pState: ?*anyopaque,
            cbState: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendDriverMessage: fn(
            self: *const IAMVfwCompressDialogs,
            uMsg: i32,
            dw1: i32,
            dw2: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCompressDialogs_ShowDialog(self: *const T, iDialog: i32, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVfwCompressDialogs.VTable, self.vtable).ShowDialog(@ptrCast(*const IAMVfwCompressDialogs, self), iDialog, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCompressDialogs_GetState(self: *const T, pState: ?*anyopaque, pcbState: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVfwCompressDialogs.VTable, self.vtable).GetState(@ptrCast(*const IAMVfwCompressDialogs, self), pState, pcbState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCompressDialogs_SetState(self: *const T, pState: ?*anyopaque, cbState: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVfwCompressDialogs.VTable, self.vtable).SetState(@ptrCast(*const IAMVfwCompressDialogs, self), pState, cbState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCompressDialogs_SendDriverMessage(self: *const T, uMsg: i32, dw1: i32, dw2: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVfwCompressDialogs.VTable, self.vtable).SendDriverMessage(@ptrCast(*const IAMVfwCompressDialogs, self), uMsg, dw1, dw2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMDroppedFrames_Value = @import("../zig.zig").Guid.initString("c6e13344-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMDroppedFrames = &IID_IAMDroppedFrames_Value;
pub const IAMDroppedFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumDropped: fn(
            self: *const IAMDroppedFrames,
            plDropped: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumNotDropped: fn(
            self: *const IAMDroppedFrames,
            plNotDropped: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDroppedInfo: fn(
            self: *const IAMDroppedFrames,
            lSize: i32,
            plArray: ?*i32,
            plNumCopied: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAverageFrameSize: fn(
            self: *const IAMDroppedFrames,
            plAverageSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDroppedFrames_GetNumDropped(self: *const T, plDropped: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDroppedFrames.VTable, self.vtable).GetNumDropped(@ptrCast(*const IAMDroppedFrames, self), plDropped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDroppedFrames_GetNumNotDropped(self: *const T, plNotDropped: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDroppedFrames.VTable, self.vtable).GetNumNotDropped(@ptrCast(*const IAMDroppedFrames, self), plNotDropped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDroppedFrames_GetDroppedInfo(self: *const T, lSize: i32, plArray: ?*i32, plNumCopied: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDroppedFrames.VTable, self.vtable).GetDroppedInfo(@ptrCast(*const IAMDroppedFrames, self), lSize, plArray, plNumCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDroppedFrames_GetAverageFrameSize(self: *const T, plAverageSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDroppedFrames.VTable, self.vtable).GetAverageFrameSize(@ptrCast(*const IAMDroppedFrames, self), plAverageSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMAudioInputMixer_Value = @import("../zig.zig").Guid.initString("54c39221-8380-11d0-b3f0-00aa003761c5");
pub const IID_IAMAudioInputMixer = &IID_IAMAudioInputMixer_Value;
pub const IAMAudioInputMixer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enable: fn(
            self: *const IAMAudioInputMixer,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enable: fn(
            self: *const IAMAudioInputMixer,
            pfEnable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mono: fn(
            self: *const IAMAudioInputMixer,
            fMono: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mono: fn(
            self: *const IAMAudioInputMixer,
            pfMono: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixLevel: fn(
            self: *const IAMAudioInputMixer,
            Level: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixLevel: fn(
            self: *const IAMAudioInputMixer,
            pLevel: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pan: fn(
            self: *const IAMAudioInputMixer,
            Pan: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pan: fn(
            self: *const IAMAudioInputMixer,
            pPan: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Loudness: fn(
            self: *const IAMAudioInputMixer,
            fLoudness: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Loudness: fn(
            self: *const IAMAudioInputMixer,
            pfLoudness: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Treble: fn(
            self: *const IAMAudioInputMixer,
            Treble: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Treble: fn(
            self: *const IAMAudioInputMixer,
            pTreble: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrebleRange: fn(
            self: *const IAMAudioInputMixer,
            pRange: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bass: fn(
            self: *const IAMAudioInputMixer,
            Bass: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bass: fn(
            self: *const IAMAudioInputMixer,
            pBass: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BassRange: fn(
            self: *const IAMAudioInputMixer,
            pRange: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Enable(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).put_Enable(@ptrCast(*const IAMAudioInputMixer, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Enable(self: *const T, pfEnable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).get_Enable(@ptrCast(*const IAMAudioInputMixer, self), pfEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Mono(self: *const T, fMono: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).put_Mono(@ptrCast(*const IAMAudioInputMixer, self), fMono);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Mono(self: *const T, pfMono: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).get_Mono(@ptrCast(*const IAMAudioInputMixer, self), pfMono);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_MixLevel(self: *const T, Level: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).put_MixLevel(@ptrCast(*const IAMAudioInputMixer, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_MixLevel(self: *const T, pLevel: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).get_MixLevel(@ptrCast(*const IAMAudioInputMixer, self), pLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Pan(self: *const T, Pan: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).put_Pan(@ptrCast(*const IAMAudioInputMixer, self), Pan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Pan(self: *const T, pPan: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).get_Pan(@ptrCast(*const IAMAudioInputMixer, self), pPan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Loudness(self: *const T, fLoudness: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).put_Loudness(@ptrCast(*const IAMAudioInputMixer, self), fLoudness);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Loudness(self: *const T, pfLoudness: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).get_Loudness(@ptrCast(*const IAMAudioInputMixer, self), pfLoudness);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Treble(self: *const T, Treble: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).put_Treble(@ptrCast(*const IAMAudioInputMixer, self), Treble);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Treble(self: *const T, pTreble: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).get_Treble(@ptrCast(*const IAMAudioInputMixer, self), pTreble);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_TrebleRange(self: *const T, pRange: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).get_TrebleRange(@ptrCast(*const IAMAudioInputMixer, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Bass(self: *const T, Bass: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).put_Bass(@ptrCast(*const IAMAudioInputMixer, self), Bass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Bass(self: *const T, pBass: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).get_Bass(@ptrCast(*const IAMAudioInputMixer, self), pBass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_BassRange(self: *const T, pRange: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioInputMixer.VTable, self.vtable).get_BassRange(@ptrCast(*const IAMAudioInputMixer, self), pRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMBufferNegotiation_Value = @import("../zig.zig").Guid.initString("56ed71a0-af5f-11d0-b3f0-00aa003761c5");
pub const IID_IAMBufferNegotiation = &IID_IAMBufferNegotiation_Value;
pub const IAMBufferNegotiation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SuggestAllocatorProperties: fn(
            self: *const IAMBufferNegotiation,
            pprop: ?*const ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllocatorProperties: fn(
            self: *const IAMBufferNegotiation,
            pprop: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMBufferNegotiation_SuggestAllocatorProperties(self: *const T, pprop: ?*const ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMBufferNegotiation.VTable, self.vtable).SuggestAllocatorProperties(@ptrCast(*const IAMBufferNegotiation, self), pprop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMBufferNegotiation_GetAllocatorProperties(self: *const T, pprop: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMBufferNegotiation.VTable, self.vtable).GetAllocatorProperties(@ptrCast(*const IAMBufferNegotiation, self), pprop);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AnalogVideoStandard = enum(i32) {
    _None = 0,
    _NTSC_M = 1,
    _NTSC_M_J = 2,
    _NTSC_433 = 4,
    _PAL_B = 16,
    _PAL_D = 32,
    _PAL_G = 64,
    _PAL_H = 128,
    _PAL_I = 256,
    _PAL_M = 512,
    _PAL_N = 1024,
    _PAL_60 = 2048,
    _SECAM_B = 4096,
    _SECAM_D = 8192,
    _SECAM_G = 16384,
    _SECAM_H = 32768,
    _SECAM_K = 65536,
    _SECAM_K1 = 131072,
    _SECAM_L = 262144,
    _SECAM_L1 = 524288,
    _PAL_N_COMBO = 1048576,
    Mask_MCE_NTSC = 1052167,
    Mask_MCE_PAL = 496,
    Mask_MCE_SECAM = 1044480,
};
pub const AnalogVideo_None = AnalogVideoStandard._None;
pub const AnalogVideo_NTSC_M = AnalogVideoStandard._NTSC_M;
pub const AnalogVideo_NTSC_M_J = AnalogVideoStandard._NTSC_M_J;
pub const AnalogVideo_NTSC_433 = AnalogVideoStandard._NTSC_433;
pub const AnalogVideo_PAL_B = AnalogVideoStandard._PAL_B;
pub const AnalogVideo_PAL_D = AnalogVideoStandard._PAL_D;
pub const AnalogVideo_PAL_G = AnalogVideoStandard._PAL_G;
pub const AnalogVideo_PAL_H = AnalogVideoStandard._PAL_H;
pub const AnalogVideo_PAL_I = AnalogVideoStandard._PAL_I;
pub const AnalogVideo_PAL_M = AnalogVideoStandard._PAL_M;
pub const AnalogVideo_PAL_N = AnalogVideoStandard._PAL_N;
pub const AnalogVideo_PAL_60 = AnalogVideoStandard._PAL_60;
pub const AnalogVideo_SECAM_B = AnalogVideoStandard._SECAM_B;
pub const AnalogVideo_SECAM_D = AnalogVideoStandard._SECAM_D;
pub const AnalogVideo_SECAM_G = AnalogVideoStandard._SECAM_G;
pub const AnalogVideo_SECAM_H = AnalogVideoStandard._SECAM_H;
pub const AnalogVideo_SECAM_K = AnalogVideoStandard._SECAM_K;
pub const AnalogVideo_SECAM_K1 = AnalogVideoStandard._SECAM_K1;
pub const AnalogVideo_SECAM_L = AnalogVideoStandard._SECAM_L;
pub const AnalogVideo_SECAM_L1 = AnalogVideoStandard._SECAM_L1;
pub const AnalogVideo_PAL_N_COMBO = AnalogVideoStandard._PAL_N_COMBO;
pub const AnalogVideoMask_MCE_NTSC = AnalogVideoStandard.Mask_MCE_NTSC;
pub const AnalogVideoMask_MCE_PAL = AnalogVideoStandard.Mask_MCE_PAL;
pub const AnalogVideoMask_MCE_SECAM = AnalogVideoStandard.Mask_MCE_SECAM;

pub const TunerInputType = enum(i32) {
    Cable = 0,
    Antenna = 1,
};
pub const TunerInputCable = TunerInputType.Cable;
pub const TunerInputAntenna = TunerInputType.Antenna;

pub const VideoCopyProtectionType = enum(i32) {
    Basic = 0,
    CBI = 1,
};
pub const VideoCopyProtectionMacrovisionBasic = VideoCopyProtectionType.Basic;
pub const VideoCopyProtectionMacrovisionCBI = VideoCopyProtectionType.CBI;

pub const PhysicalConnectorType = enum(i32) {
    Video_Tuner = 1,
    Video_Composite = 2,
    Video_SVideo = 3,
    Video_RGB = 4,
    Video_YRYBY = 5,
    Video_SerialDigital = 6,
    Video_ParallelDigital = 7,
    Video_SCSI = 8,
    Video_AUX = 9,
    Video_1394 = 10,
    Video_USB = 11,
    Video_VideoDecoder = 12,
    Video_VideoEncoder = 13,
    Video_SCART = 14,
    Video_Black = 15,
    Audio_Tuner = 4096,
    Audio_Line = 4097,
    Audio_Mic = 4098,
    Audio_AESDigital = 4099,
    Audio_SPDIFDigital = 4100,
    Audio_SCSI = 4101,
    Audio_AUX = 4102,
    Audio_1394 = 4103,
    Audio_USB = 4104,
    Audio_AudioDecoder = 4105,
};
pub const PhysConn_Video_Tuner = PhysicalConnectorType.Video_Tuner;
pub const PhysConn_Video_Composite = PhysicalConnectorType.Video_Composite;
pub const PhysConn_Video_SVideo = PhysicalConnectorType.Video_SVideo;
pub const PhysConn_Video_RGB = PhysicalConnectorType.Video_RGB;
pub const PhysConn_Video_YRYBY = PhysicalConnectorType.Video_YRYBY;
pub const PhysConn_Video_SerialDigital = PhysicalConnectorType.Video_SerialDigital;
pub const PhysConn_Video_ParallelDigital = PhysicalConnectorType.Video_ParallelDigital;
pub const PhysConn_Video_SCSI = PhysicalConnectorType.Video_SCSI;
pub const PhysConn_Video_AUX = PhysicalConnectorType.Video_AUX;
pub const PhysConn_Video_1394 = PhysicalConnectorType.Video_1394;
pub const PhysConn_Video_USB = PhysicalConnectorType.Video_USB;
pub const PhysConn_Video_VideoDecoder = PhysicalConnectorType.Video_VideoDecoder;
pub const PhysConn_Video_VideoEncoder = PhysicalConnectorType.Video_VideoEncoder;
pub const PhysConn_Video_SCART = PhysicalConnectorType.Video_SCART;
pub const PhysConn_Video_Black = PhysicalConnectorType.Video_Black;
pub const PhysConn_Audio_Tuner = PhysicalConnectorType.Audio_Tuner;
pub const PhysConn_Audio_Line = PhysicalConnectorType.Audio_Line;
pub const PhysConn_Audio_Mic = PhysicalConnectorType.Audio_Mic;
pub const PhysConn_Audio_AESDigital = PhysicalConnectorType.Audio_AESDigital;
pub const PhysConn_Audio_SPDIFDigital = PhysicalConnectorType.Audio_SPDIFDigital;
pub const PhysConn_Audio_SCSI = PhysicalConnectorType.Audio_SCSI;
pub const PhysConn_Audio_AUX = PhysicalConnectorType.Audio_AUX;
pub const PhysConn_Audio_1394 = PhysicalConnectorType.Audio_1394;
pub const PhysConn_Audio_USB = PhysicalConnectorType.Audio_USB;
pub const PhysConn_Audio_AudioDecoder = PhysicalConnectorType.Audio_AudioDecoder;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMAnalogVideoDecoder_Value = @import("../zig.zig").Guid.initString("c6e13350-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMAnalogVideoDecoder = &IID_IAMAnalogVideoDecoder_Value;
pub const IAMAnalogVideoDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableTVFormats: fn(
            self: *const IAMAnalogVideoDecoder,
            lAnalogVideoStandard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVFormat: fn(
            self: *const IAMAnalogVideoDecoder,
            lAnalogVideoStandard: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormat: fn(
            self: *const IAMAnalogVideoDecoder,
            plAnalogVideoStandard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HorizontalLocked: fn(
            self: *const IAMAnalogVideoDecoder,
            plLocked: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VCRHorizontalLocking: fn(
            self: *const IAMAnalogVideoDecoder,
            lVCRHorizontalLocking: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VCRHorizontalLocking: fn(
            self: *const IAMAnalogVideoDecoder,
            plVCRHorizontalLocking: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfLines: fn(
            self: *const IAMAnalogVideoDecoder,
            plNumberOfLines: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OutputEnable: fn(
            self: *const IAMAnalogVideoDecoder,
            lOutputEnable: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputEnable: fn(
            self: *const IAMAnalogVideoDecoder,
            plOutputEnable: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_AvailableTVFormats(self: *const T, lAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoDecoder.VTable, self.vtable).get_AvailableTVFormats(@ptrCast(*const IAMAnalogVideoDecoder, self), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_put_TVFormat(self: *const T, lAnalogVideoStandard: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoDecoder.VTable, self.vtable).put_TVFormat(@ptrCast(*const IAMAnalogVideoDecoder, self), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_TVFormat(self: *const T, plAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoDecoder.VTable, self.vtable).get_TVFormat(@ptrCast(*const IAMAnalogVideoDecoder, self), plAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_HorizontalLocked(self: *const T, plLocked: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoDecoder.VTable, self.vtable).get_HorizontalLocked(@ptrCast(*const IAMAnalogVideoDecoder, self), plLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_put_VCRHorizontalLocking(self: *const T, lVCRHorizontalLocking: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoDecoder.VTable, self.vtable).put_VCRHorizontalLocking(@ptrCast(*const IAMAnalogVideoDecoder, self), lVCRHorizontalLocking);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_VCRHorizontalLocking(self: *const T, plVCRHorizontalLocking: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoDecoder.VTable, self.vtable).get_VCRHorizontalLocking(@ptrCast(*const IAMAnalogVideoDecoder, self), plVCRHorizontalLocking);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_NumberOfLines(self: *const T, plNumberOfLines: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoDecoder.VTable, self.vtable).get_NumberOfLines(@ptrCast(*const IAMAnalogVideoDecoder, self), plNumberOfLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_put_OutputEnable(self: *const T, lOutputEnable: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoDecoder.VTable, self.vtable).put_OutputEnable(@ptrCast(*const IAMAnalogVideoDecoder, self), lOutputEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_OutputEnable(self: *const T, plOutputEnable: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoDecoder.VTable, self.vtable).get_OutputEnable(@ptrCast(*const IAMAnalogVideoDecoder, self), plOutputEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VideoProcAmpProperty = enum(i32) {
    Brightness = 0,
    Contrast = 1,
    Hue = 2,
    Saturation = 3,
    Sharpness = 4,
    Gamma = 5,
    ColorEnable = 6,
    WhiteBalance = 7,
    BacklightCompensation = 8,
    Gain = 9,
};
pub const VideoProcAmp_Brightness = VideoProcAmpProperty.Brightness;
pub const VideoProcAmp_Contrast = VideoProcAmpProperty.Contrast;
pub const VideoProcAmp_Hue = VideoProcAmpProperty.Hue;
pub const VideoProcAmp_Saturation = VideoProcAmpProperty.Saturation;
pub const VideoProcAmp_Sharpness = VideoProcAmpProperty.Sharpness;
pub const VideoProcAmp_Gamma = VideoProcAmpProperty.Gamma;
pub const VideoProcAmp_ColorEnable = VideoProcAmpProperty.ColorEnable;
pub const VideoProcAmp_WhiteBalance = VideoProcAmpProperty.WhiteBalance;
pub const VideoProcAmp_BacklightCompensation = VideoProcAmpProperty.BacklightCompensation;
pub const VideoProcAmp_Gain = VideoProcAmpProperty.Gain;

pub const VideoProcAmpFlags = enum(i32) {
    Auto = 1,
    Manual = 2,
};
pub const VideoProcAmp_Flags_Auto = VideoProcAmpFlags.Auto;
pub const VideoProcAmp_Flags_Manual = VideoProcAmpFlags.Manual;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoProcAmp_Value = @import("../zig.zig").Guid.initString("c6e13360-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMVideoProcAmp = &IID_IAMVideoProcAmp_Value;
pub const IAMVideoProcAmp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRange: fn(
            self: *const IAMVideoProcAmp,
            Property: i32,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set: fn(
            self: *const IAMVideoProcAmp,
            Property: i32,
            lValue: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: fn(
            self: *const IAMVideoProcAmp,
            Property: i32,
            lValue: ?*i32,
            Flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoProcAmp_GetRange(self: *const T, Property: i32, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoProcAmp.VTable, self.vtable).GetRange(@ptrCast(*const IAMVideoProcAmp, self), Property, pMin, pMax, pSteppingDelta, pDefault, pCapsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoProcAmp_Set(self: *const T, Property: i32, lValue: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoProcAmp.VTable, self.vtable).Set(@ptrCast(*const IAMVideoProcAmp, self), Property, lValue, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoProcAmp_Get(self: *const T, Property: i32, lValue: ?*i32, Flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoProcAmp.VTable, self.vtable).Get(@ptrCast(*const IAMVideoProcAmp, self), Property, lValue, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CameraControlProperty = enum(i32) {
    Pan = 0,
    Tilt = 1,
    Roll = 2,
    Zoom = 3,
    Exposure = 4,
    Iris = 5,
    Focus = 6,
};
pub const CameraControl_Pan = CameraControlProperty.Pan;
pub const CameraControl_Tilt = CameraControlProperty.Tilt;
pub const CameraControl_Roll = CameraControlProperty.Roll;
pub const CameraControl_Zoom = CameraControlProperty.Zoom;
pub const CameraControl_Exposure = CameraControlProperty.Exposure;
pub const CameraControl_Iris = CameraControlProperty.Iris;
pub const CameraControl_Focus = CameraControlProperty.Focus;

pub const CameraControlFlags = enum(i32) {
    Auto = 1,
    Manual = 2,
};
pub const CameraControl_Flags_Auto = CameraControlFlags.Auto;
pub const CameraControl_Flags_Manual = CameraControlFlags.Manual;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMCameraControl_Value = @import("../zig.zig").Guid.initString("c6e13370-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMCameraControl = &IID_IAMCameraControl_Value;
pub const IAMCameraControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRange: fn(
            self: *const IAMCameraControl,
            Property: i32,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set: fn(
            self: *const IAMCameraControl,
            Property: i32,
            lValue: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: fn(
            self: *const IAMCameraControl,
            Property: i32,
            lValue: ?*i32,
            Flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCameraControl_GetRange(self: *const T, Property: i32, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCameraControl.VTable, self.vtable).GetRange(@ptrCast(*const IAMCameraControl, self), Property, pMin, pMax, pSteppingDelta, pDefault, pCapsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCameraControl_Set(self: *const T, Property: i32, lValue: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCameraControl.VTable, self.vtable).Set(@ptrCast(*const IAMCameraControl, self), Property, lValue, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCameraControl_Get(self: *const T, Property: i32, lValue: ?*i32, Flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCameraControl.VTable, self.vtable).Get(@ptrCast(*const IAMCameraControl, self), Property, lValue, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VideoControlFlags = enum(i32) {
    FlipHorizontal = 1,
    FlipVertical = 2,
    ExternalTriggerEnable = 4,
    Trigger = 8,
};
pub const VideoControlFlag_FlipHorizontal = VideoControlFlags.FlipHorizontal;
pub const VideoControlFlag_FlipVertical = VideoControlFlags.FlipVertical;
pub const VideoControlFlag_ExternalTriggerEnable = VideoControlFlags.ExternalTriggerEnable;
pub const VideoControlFlag_Trigger = VideoControlFlags.Trigger;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoControl_Value = @import("../zig.zig").Guid.initString("6a2e0670-28e4-11d0-a18c-00a0c9118956");
pub const IID_IAMVideoControl = &IID_IAMVideoControl_Value;
pub const IAMVideoControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCaps: fn(
            self: *const IAMVideoControl,
            pPin: ?*IPin,
            pCapsFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMode: fn(
            self: *const IAMVideoControl,
            pPin: ?*IPin,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMode: fn(
            self: *const IAMVideoControl,
            pPin: ?*IPin,
            Mode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentActualFrameRate: fn(
            self: *const IAMVideoControl,
            pPin: ?*IPin,
            ActualFrameRate: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxAvailableFrameRate: fn(
            self: *const IAMVideoControl,
            pPin: ?*IPin,
            iIndex: i32,
            Dimensions: SIZE,
            MaxAvailableFrameRate: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameRateList: fn(
            self: *const IAMVideoControl,
            pPin: ?*IPin,
            iIndex: i32,
            Dimensions: SIZE,
            ListSize: ?*i32,
            FrameRates: ?*?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetCaps(self: *const T, pPin: ?*IPin, pCapsFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoControl.VTable, self.vtable).GetCaps(@ptrCast(*const IAMVideoControl, self), pPin, pCapsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_SetMode(self: *const T, pPin: ?*IPin, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoControl.VTable, self.vtable).SetMode(@ptrCast(*const IAMVideoControl, self), pPin, Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetMode(self: *const T, pPin: ?*IPin, Mode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoControl.VTable, self.vtable).GetMode(@ptrCast(*const IAMVideoControl, self), pPin, Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetCurrentActualFrameRate(self: *const T, pPin: ?*IPin, ActualFrameRate: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoControl.VTable, self.vtable).GetCurrentActualFrameRate(@ptrCast(*const IAMVideoControl, self), pPin, ActualFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetMaxAvailableFrameRate(self: *const T, pPin: ?*IPin, iIndex: i32, Dimensions: SIZE, MaxAvailableFrameRate: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoControl.VTable, self.vtable).GetMaxAvailableFrameRate(@ptrCast(*const IAMVideoControl, self), pPin, iIndex, Dimensions, MaxAvailableFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetFrameRateList(self: *const T, pPin: ?*IPin, iIndex: i32, Dimensions: SIZE, ListSize: ?*i32, FrameRates: ?*?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoControl.VTable, self.vtable).GetFrameRateList(@ptrCast(*const IAMVideoControl, self), pPin, iIndex, Dimensions, ListSize, FrameRates);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMCrossbar_Value = @import("../zig.zig").Guid.initString("c6e13380-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMCrossbar = &IID_IAMCrossbar_Value;
pub const IAMCrossbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PinCounts: fn(
            self: *const IAMCrossbar,
            OutputPinCount: ?*i32,
            InputPinCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanRoute: fn(
            self: *const IAMCrossbar,
            OutputPinIndex: i32,
            InputPinIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Route: fn(
            self: *const IAMCrossbar,
            OutputPinIndex: i32,
            InputPinIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRoutedTo: fn(
            self: *const IAMCrossbar,
            OutputPinIndex: i32,
            InputPinIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CrossbarPinInfo: fn(
            self: *const IAMCrossbar,
            IsInputPin: BOOL,
            PinIndex: i32,
            PinIndexRelated: ?*i32,
            PhysicalType: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_get_PinCounts(self: *const T, OutputPinCount: ?*i32, InputPinCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCrossbar.VTable, self.vtable).get_PinCounts(@ptrCast(*const IAMCrossbar, self), OutputPinCount, InputPinCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_CanRoute(self: *const T, OutputPinIndex: i32, InputPinIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCrossbar.VTable, self.vtable).CanRoute(@ptrCast(*const IAMCrossbar, self), OutputPinIndex, InputPinIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_Route(self: *const T, OutputPinIndex: i32, InputPinIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCrossbar.VTable, self.vtable).Route(@ptrCast(*const IAMCrossbar, self), OutputPinIndex, InputPinIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_get_IsRoutedTo(self: *const T, OutputPinIndex: i32, InputPinIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCrossbar.VTable, self.vtable).get_IsRoutedTo(@ptrCast(*const IAMCrossbar, self), OutputPinIndex, InputPinIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_get_CrossbarPinInfo(self: *const T, IsInputPin: BOOL, PinIndex: i32, PinIndexRelated: ?*i32, PhysicalType: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCrossbar.VTable, self.vtable).get_CrossbarPinInfo(@ptrCast(*const IAMCrossbar, self), IsInputPin, PinIndex, PinIndexRelated, PhysicalType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMTunerSubChannel = enum(i32) {
    NO_TUNE = -2,
    DEFAULT = -1,
};
pub const AMTUNER_SUBCHAN_NO_TUNE = AMTunerSubChannel.NO_TUNE;
pub const AMTUNER_SUBCHAN_DEFAULT = AMTunerSubChannel.DEFAULT;

pub const AMTunerSignalStrength = enum(i32) {
    HASNOSIGNALSTRENGTH = -1,
    NOSIGNAL = 0,
    SIGNALPRESENT = 1,
};
pub const AMTUNER_HASNOSIGNALSTRENGTH = AMTunerSignalStrength.HASNOSIGNALSTRENGTH;
pub const AMTUNER_NOSIGNAL = AMTunerSignalStrength.NOSIGNAL;
pub const AMTUNER_SIGNALPRESENT = AMTunerSignalStrength.SIGNALPRESENT;

pub const AMTunerModeType = enum(i32) {
    DEFAULT = 0,
    TV = 1,
    FM_RADIO = 2,
    AM_RADIO = 4,
    DSS = 8,
};
pub const AMTUNER_MODE_DEFAULT = AMTunerModeType.DEFAULT;
pub const AMTUNER_MODE_TV = AMTunerModeType.TV;
pub const AMTUNER_MODE_FM_RADIO = AMTunerModeType.FM_RADIO;
pub const AMTUNER_MODE_AM_RADIO = AMTunerModeType.AM_RADIO;
pub const AMTUNER_MODE_DSS = AMTunerModeType.DSS;

pub const AMTunerEventType = enum(i32) {
    D = 1,
};
pub const AMTUNER_EVENT_CHANGED = AMTunerEventType.D;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTuner_Value = @import("../zig.zig").Guid.initString("211a8761-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IAMTuner = &IID_IAMTuner_Value;
pub const IAMTuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channel: fn(
            self: *const IAMTuner,
            lChannel: i32,
            lVideoSubChannel: i32,
            lAudioSubChannel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channel: fn(
            self: *const IAMTuner,
            plChannel: ?*i32,
            plVideoSubChannel: ?*i32,
            plAudioSubChannel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChannelMinMax: fn(
            self: *const IAMTuner,
            lChannelMin: ?*i32,
            lChannelMax: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: fn(
            self: *const IAMTuner,
            lCountryCode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: fn(
            self: *const IAMTuner,
            plCountryCode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuningSpace: fn(
            self: *const IAMTuner,
            lTuningSpace: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: fn(
            self: *const IAMTuner,
            plTuningSpace: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Logon: fn(
            self: *const IAMTuner,
            hCurrentUser: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Logout: fn(
            self: *const IAMTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SignalPresent: fn(
            self: *const IAMTuner,
            plSignalStrength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: fn(
            self: *const IAMTuner,
            lMode: AMTunerModeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: fn(
            self: *const IAMTuner,
            plMode: ?*AMTunerModeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableModes: fn(
            self: *const IAMTuner,
            plModes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterNotificationCallBack: fn(
            self: *const IAMTuner,
            pNotify: ?*IAMTunerNotification,
            lEvents: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterNotificationCallBack: fn(
            self: *const IAMTuner,
            pNotify: ?*IAMTunerNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_put_Channel(self: *const T, lChannel: i32, lVideoSubChannel: i32, lAudioSubChannel: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).put_Channel(@ptrCast(*const IAMTuner, self), lChannel, lVideoSubChannel, lAudioSubChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_get_Channel(self: *const T, plChannel: ?*i32, plVideoSubChannel: ?*i32, plAudioSubChannel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).get_Channel(@ptrCast(*const IAMTuner, self), plChannel, plVideoSubChannel, plAudioSubChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_ChannelMinMax(self: *const T, lChannelMin: ?*i32, lChannelMax: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).ChannelMinMax(@ptrCast(*const IAMTuner, self), lChannelMin, lChannelMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_put_CountryCode(self: *const T, lCountryCode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).put_CountryCode(@ptrCast(*const IAMTuner, self), lCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_get_CountryCode(self: *const T, plCountryCode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).get_CountryCode(@ptrCast(*const IAMTuner, self), plCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_put_TuningSpace(self: *const T, lTuningSpace: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).put_TuningSpace(@ptrCast(*const IAMTuner, self), lTuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_get_TuningSpace(self: *const T, plTuningSpace: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).get_TuningSpace(@ptrCast(*const IAMTuner, self), plTuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_Logon(self: *const T, hCurrentUser: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).Logon(@ptrCast(*const IAMTuner, self), hCurrentUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_Logout(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).Logout(@ptrCast(*const IAMTuner, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_SignalPresent(self: *const T, plSignalStrength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).SignalPresent(@ptrCast(*const IAMTuner, self), plSignalStrength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_put_Mode(self: *const T, lMode: AMTunerModeType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).put_Mode(@ptrCast(*const IAMTuner, self), lMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_get_Mode(self: *const T, plMode: ?*AMTunerModeType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).get_Mode(@ptrCast(*const IAMTuner, self), plMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_GetAvailableModes(self: *const T, plModes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).GetAvailableModes(@ptrCast(*const IAMTuner, self), plModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_RegisterNotificationCallBack(self: *const T, pNotify: ?*IAMTunerNotification, lEvents: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).RegisterNotificationCallBack(@ptrCast(*const IAMTuner, self), pNotify, lEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_UnRegisterNotificationCallBack(self: *const T, pNotify: ?*IAMTunerNotification) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTuner.VTable, self.vtable).UnRegisterNotificationCallBack(@ptrCast(*const IAMTuner, self), pNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMTunerNotification_Value = @import("../zig.zig").Guid.initString("211a8760-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IAMTunerNotification = &IID_IAMTunerNotification_Value;
pub const IAMTunerNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: fn(
            self: *const IAMTunerNotification,
            Event: AMTunerEventType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTunerNotification_OnEvent(self: *const T, Event: AMTunerEventType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTunerNotification.VTable, self.vtable).OnEvent(@ptrCast(*const IAMTunerNotification, self), Event);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTVTuner_Value = @import("../zig.zig").Guid.initString("211a8766-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IAMTVTuner = &IID_IAMTVTuner_Value;
pub const IAMTVTuner = extern struct {
    pub const VTable = extern struct {
        base: IAMTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableTVFormats: fn(
            self: *const IAMTVTuner,
            lAnalogVideoStandard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormat: fn(
            self: *const IAMTVTuner,
            plAnalogVideoStandard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoTune: fn(
            self: *const IAMTVTuner,
            lChannel: i32,
            plFoundSignal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoreAutoTune: fn(
            self: *const IAMTVTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumInputConnections: fn(
            self: *const IAMTVTuner,
            plNumInputConnections: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputType: fn(
            self: *const IAMTVTuner,
            lIndex: i32,
            InputType: TunerInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputType: fn(
            self: *const IAMTVTuner,
            lIndex: i32,
            pInputType: ?*TunerInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectInput: fn(
            self: *const IAMTVTuner,
            lIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectInput: fn(
            self: *const IAMTVTuner,
            plIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoFrequency: fn(
            self: *const IAMTVTuner,
            lFreq: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFrequency: fn(
            self: *const IAMTVTuner,
            lFreq: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAMTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_AvailableTVFormats(self: *const T, lAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).get_AvailableTVFormats(@ptrCast(*const IAMTVTuner, self), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_TVFormat(self: *const T, plAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).get_TVFormat(@ptrCast(*const IAMTVTuner, self), plAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_AutoTune(self: *const T, lChannel: i32, plFoundSignal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).AutoTune(@ptrCast(*const IAMTVTuner, self), lChannel, plFoundSignal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_StoreAutoTune(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).StoreAutoTune(@ptrCast(*const IAMTVTuner, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_NumInputConnections(self: *const T, plNumInputConnections: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).get_NumInputConnections(@ptrCast(*const IAMTVTuner, self), plNumInputConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_put_InputType(self: *const T, lIndex: i32, InputType: TunerInputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).put_InputType(@ptrCast(*const IAMTVTuner, self), lIndex, InputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_InputType(self: *const T, lIndex: i32, pInputType: ?*TunerInputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).get_InputType(@ptrCast(*const IAMTVTuner, self), lIndex, pInputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_put_ConnectInput(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).put_ConnectInput(@ptrCast(*const IAMTVTuner, self), lIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_ConnectInput(self: *const T, plIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).get_ConnectInput(@ptrCast(*const IAMTVTuner, self), plIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_VideoFrequency(self: *const T, lFreq: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).get_VideoFrequency(@ptrCast(*const IAMTVTuner, self), lFreq);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_AudioFrequency(self: *const T, lFreq: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVTuner.VTable, self.vtable).get_AudioFrequency(@ptrCast(*const IAMTVTuner, self), lFreq);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBPCSatelliteTuner_Value = @import("../zig.zig").Guid.initString("211a8765-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IBPCSatelliteTuner = &IID_IBPCSatelliteTuner_Value;
pub const IBPCSatelliteTuner = extern struct {
    pub const VTable = extern struct {
        base: IAMTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubChannelTypes: fn(
            self: *const IBPCSatelliteTuner,
            plDefaultVideoType: ?*i32,
            plDefaultAudioType: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultSubChannelTypes: fn(
            self: *const IBPCSatelliteTuner,
            lDefaultVideoType: i32,
            lDefaultAudioType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsTapingPermitted: fn(
            self: *const IBPCSatelliteTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAMTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBPCSatelliteTuner_get_DefaultSubChannelTypes(self: *const T, plDefaultVideoType: ?*i32, plDefaultAudioType: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBPCSatelliteTuner.VTable, self.vtable).get_DefaultSubChannelTypes(@ptrCast(*const IBPCSatelliteTuner, self), plDefaultVideoType, plDefaultAudioType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBPCSatelliteTuner_put_DefaultSubChannelTypes(self: *const T, lDefaultVideoType: i32, lDefaultAudioType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBPCSatelliteTuner.VTable, self.vtable).put_DefaultSubChannelTypes(@ptrCast(*const IBPCSatelliteTuner, self), lDefaultVideoType, lDefaultAudioType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBPCSatelliteTuner_IsTapingPermitted(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBPCSatelliteTuner.VTable, self.vtable).IsTapingPermitted(@ptrCast(*const IBPCSatelliteTuner, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TVAudioMode = enum(i32) {
    MODE_MONO = 1,
    MODE_STEREO = 2,
    MODE_LANG_A = 16,
    MODE_LANG_B = 32,
    MODE_LANG_C = 64,
    PRESET_STEREO = 512,
    PRESET_LANG_A = 4096,
    PRESET_LANG_B = 8192,
    PRESET_LANG_C = 16384,
};
pub const AMTVAUDIO_MODE_MONO = TVAudioMode.MODE_MONO;
pub const AMTVAUDIO_MODE_STEREO = TVAudioMode.MODE_STEREO;
pub const AMTVAUDIO_MODE_LANG_A = TVAudioMode.MODE_LANG_A;
pub const AMTVAUDIO_MODE_LANG_B = TVAudioMode.MODE_LANG_B;
pub const AMTVAUDIO_MODE_LANG_C = TVAudioMode.MODE_LANG_C;
pub const AMTVAUDIO_PRESET_STEREO = TVAudioMode.PRESET_STEREO;
pub const AMTVAUDIO_PRESET_LANG_A = TVAudioMode.PRESET_LANG_A;
pub const AMTVAUDIO_PRESET_LANG_B = TVAudioMode.PRESET_LANG_B;
pub const AMTVAUDIO_PRESET_LANG_C = TVAudioMode.PRESET_LANG_C;

pub const AMTVAudioEventType = enum(i32) {
    D = 1,
};
pub const AMTVAUDIO_EVENT_CHANGED = AMTVAudioEventType.D;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTVAudio_Value = @import("../zig.zig").Guid.initString("83ec1c30-23d1-11d1-99e6-00a0c9560266");
pub const IID_IAMTVAudio = &IID_IAMTVAudio_Value;
pub const IAMTVAudio = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHardwareSupportedTVAudioModes: fn(
            self: *const IAMTVAudio,
            plModes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableTVAudioModes: fn(
            self: *const IAMTVAudio,
            plModes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVAudioMode: fn(
            self: *const IAMTVAudio,
            plMode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVAudioMode: fn(
            self: *const IAMTVAudio,
            lMode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterNotificationCallBack: fn(
            self: *const IAMTVAudio,
            pNotify: ?*IAMTunerNotification,
            lEvents: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterNotificationCallBack: fn(
            self: *const IAMTVAudio,
            pNotify: ?*IAMTunerNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_GetHardwareSupportedTVAudioModes(self: *const T, plModes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVAudio.VTable, self.vtable).GetHardwareSupportedTVAudioModes(@ptrCast(*const IAMTVAudio, self), plModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_GetAvailableTVAudioModes(self: *const T, plModes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVAudio.VTable, self.vtable).GetAvailableTVAudioModes(@ptrCast(*const IAMTVAudio, self), plModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_get_TVAudioMode(self: *const T, plMode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVAudio.VTable, self.vtable).get_TVAudioMode(@ptrCast(*const IAMTVAudio, self), plMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_put_TVAudioMode(self: *const T, lMode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVAudio.VTable, self.vtable).put_TVAudioMode(@ptrCast(*const IAMTVAudio, self), lMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_RegisterNotificationCallBack(self: *const T, pNotify: ?*IAMTunerNotification, lEvents: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVAudio.VTable, self.vtable).RegisterNotificationCallBack(@ptrCast(*const IAMTVAudio, self), pNotify, lEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_UnRegisterNotificationCallBack(self: *const T, pNotify: ?*IAMTunerNotification) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVAudio.VTable, self.vtable).UnRegisterNotificationCallBack(@ptrCast(*const IAMTVAudio, self), pNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMTVAudioNotification_Value = @import("../zig.zig").Guid.initString("83ec1c33-23d1-11d1-99e6-00a0c9560266");
pub const IID_IAMTVAudioNotification = &IID_IAMTVAudioNotification_Value;
pub const IAMTVAudioNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: fn(
            self: *const IAMTVAudioNotification,
            Event: AMTVAudioEventType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudioNotification_OnEvent(self: *const T, Event: AMTVAudioEventType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTVAudioNotification.VTable, self.vtable).OnEvent(@ptrCast(*const IAMTVAudioNotification, self), Event);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMAnalogVideoEncoder_Value = @import("../zig.zig").Guid.initString("c6e133b0-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMAnalogVideoEncoder = &IID_IAMAnalogVideoEncoder_Value;
pub const IAMAnalogVideoEncoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableTVFormats: fn(
            self: *const IAMAnalogVideoEncoder,
            lAnalogVideoStandard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVFormat: fn(
            self: *const IAMAnalogVideoEncoder,
            lAnalogVideoStandard: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormat: fn(
            self: *const IAMAnalogVideoEncoder,
            plAnalogVideoStandard: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CopyProtection: fn(
            self: *const IAMAnalogVideoEncoder,
            lVideoCopyProtection: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CopyProtection: fn(
            self: *const IAMAnalogVideoEncoder,
            lVideoCopyProtection: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CCEnable: fn(
            self: *const IAMAnalogVideoEncoder,
            lCCEnable: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCEnable: fn(
            self: *const IAMAnalogVideoEncoder,
            lCCEnable: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_get_AvailableTVFormats(self: *const T, lAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoEncoder.VTable, self.vtable).get_AvailableTVFormats(@ptrCast(*const IAMAnalogVideoEncoder, self), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_put_TVFormat(self: *const T, lAnalogVideoStandard: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoEncoder.VTable, self.vtable).put_TVFormat(@ptrCast(*const IAMAnalogVideoEncoder, self), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_get_TVFormat(self: *const T, plAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoEncoder.VTable, self.vtable).get_TVFormat(@ptrCast(*const IAMAnalogVideoEncoder, self), plAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_put_CopyProtection(self: *const T, lVideoCopyProtection: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoEncoder.VTable, self.vtable).put_CopyProtection(@ptrCast(*const IAMAnalogVideoEncoder, self), lVideoCopyProtection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_get_CopyProtection(self: *const T, lVideoCopyProtection: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoEncoder.VTable, self.vtable).get_CopyProtection(@ptrCast(*const IAMAnalogVideoEncoder, self), lVideoCopyProtection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_put_CCEnable(self: *const T, lCCEnable: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoEncoder.VTable, self.vtable).put_CCEnable(@ptrCast(*const IAMAnalogVideoEncoder, self), lCCEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_get_CCEnable(self: *const T, lCCEnable: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAnalogVideoEncoder.VTable, self.vtable).get_CCEnable(@ptrCast(*const IAMAnalogVideoEncoder, self), lCCEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMPROPERTY_PIN = enum(i32) {
    CATEGORY = 0,
    MEDIUM = 1,
};
pub const AMPROPERTY_PIN_CATEGORY = AMPROPERTY_PIN.CATEGORY;
pub const AMPROPERTY_PIN_MEDIUM = AMPROPERTY_PIN.MEDIUM;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaPropertyBag_Value = @import("../zig.zig").Guid.initString("6025a880-c0d5-11d0-bd4e-00a0c911ce86");
pub const IID_IMediaPropertyBag = &IID_IMediaPropertyBag_Value;
pub const IMediaPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IPropertyBag.VTable,
        EnumProperty: fn(
            self: *const IMediaPropertyBag,
            iProperty: u32,
            pvarPropertyName: ?*VARIANT,
            pvarPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPropertyBag.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPropertyBag_EnumProperty(self: *const T, iProperty: u32, pvarPropertyName: ?*VARIANT, pvarPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPropertyBag.VTable, self.vtable).EnumProperty(@ptrCast(*const IMediaPropertyBag, self), iProperty, pvarPropertyName, pvarPropertyValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistMediaPropertyBag_Value = @import("../zig.zig").Guid.initString("5738e040-b67f-11d0-bd4d-00a0c911ce86");
pub const IID_IPersistMediaPropertyBag = &IID_IPersistMediaPropertyBag_Value;
pub const IPersistMediaPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: fn(
            self: *const IPersistMediaPropertyBag,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistMediaPropertyBag,
            pPropBag: ?*IMediaPropertyBag,
            pErrorLog: ?*IErrorLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistMediaPropertyBag,
            pPropBag: ?*IMediaPropertyBag,
            fClearDirty: BOOL,
            fSaveAllProperties: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMediaPropertyBag_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMediaPropertyBag.VTable, self.vtable).InitNew(@ptrCast(*const IPersistMediaPropertyBag, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMediaPropertyBag_Load(self: *const T, pPropBag: ?*IMediaPropertyBag, pErrorLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMediaPropertyBag.VTable, self.vtable).Load(@ptrCast(*const IPersistMediaPropertyBag, self), pPropBag, pErrorLog);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMediaPropertyBag_Save(self: *const T, pPropBag: ?*IMediaPropertyBag, fClearDirty: BOOL, fSaveAllProperties: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMediaPropertyBag.VTable, self.vtable).Save(@ptrCast(*const IPersistMediaPropertyBag, self), pPropBag, fClearDirty, fSaveAllProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMPhysicalPinInfo_Value = @import("../zig.zig").Guid.initString("f938c991-3029-11cf-8c44-00aa006b6814");
pub const IID_IAMPhysicalPinInfo = &IID_IAMPhysicalPinInfo_Value;
pub const IAMPhysicalPinInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPhysicalType: fn(
            self: *const IAMPhysicalPinInfo,
            pType: ?*i32,
            ppszType: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPhysicalPinInfo_GetPhysicalType(self: *const T, pType: ?*i32, ppszType: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPhysicalPinInfo.VTable, self.vtable).GetPhysicalType(@ptrCast(*const IAMPhysicalPinInfo, self), pType, ppszType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtDevice_Value = @import("../zig.zig").Guid.initString("b5730a90-1a2c-11cf-8c23-00aa006b6814");
pub const IID_IAMExtDevice = &IID_IAMExtDevice_Value;
pub const IAMExtDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapability: fn(
            self: *const IAMExtDevice,
            Capability: i32,
            pValue: ?*i32,
            pdblValue: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalDeviceID: fn(
            self: *const IAMExtDevice,
            ppszData: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalDeviceVersion: fn(
            self: *const IAMExtDevice,
            ppszData: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DevicePower: fn(
            self: *const IAMExtDevice,
            PowerMode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevicePower: fn(
            self: *const IAMExtDevice,
            pPowerMode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Calibrate: fn(
            self: *const IAMExtDevice,
            hEvent: usize,
            Mode: i32,
            pStatus: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DevicePort: fn(
            self: *const IAMExtDevice,
            DevicePort: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevicePort: fn(
            self: *const IAMExtDevice,
            pDevicePort: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_GetCapability(self: *const T, Capability: i32, pValue: ?*i32, pdblValue: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtDevice.VTable, self.vtable).GetCapability(@ptrCast(*const IAMExtDevice, self), Capability, pValue, pdblValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_get_ExternalDeviceID(self: *const T, ppszData: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtDevice.VTable, self.vtable).get_ExternalDeviceID(@ptrCast(*const IAMExtDevice, self), ppszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_get_ExternalDeviceVersion(self: *const T, ppszData: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtDevice.VTable, self.vtable).get_ExternalDeviceVersion(@ptrCast(*const IAMExtDevice, self), ppszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_put_DevicePower(self: *const T, PowerMode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtDevice.VTable, self.vtable).put_DevicePower(@ptrCast(*const IAMExtDevice, self), PowerMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_get_DevicePower(self: *const T, pPowerMode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtDevice.VTable, self.vtable).get_DevicePower(@ptrCast(*const IAMExtDevice, self), pPowerMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_Calibrate(self: *const T, hEvent: usize, Mode: i32, pStatus: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtDevice.VTable, self.vtable).Calibrate(@ptrCast(*const IAMExtDevice, self), hEvent, Mode, pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_put_DevicePort(self: *const T, DevicePort: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtDevice.VTable, self.vtable).put_DevicePort(@ptrCast(*const IAMExtDevice, self), DevicePort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_get_DevicePort(self: *const T, pDevicePort: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtDevice.VTable, self.vtable).get_DevicePort(@ptrCast(*const IAMExtDevice, self), pDevicePort);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtTransport_Value = @import("../zig.zig").Guid.initString("a03cd5f0-3045-11cf-8c44-00aa006b6814");
pub const IID_IAMExtTransport = &IID_IAMExtTransport_Value;
pub const IAMExtTransport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapability: fn(
            self: *const IAMExtTransport,
            Capability: i32,
            pValue: ?*i32,
            pdblValue: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaState: fn(
            self: *const IAMExtTransport,
            State: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaState: fn(
            self: *const IAMExtTransport,
            pState: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalControl: fn(
            self: *const IAMExtTransport,
            State: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalControl: fn(
            self: *const IAMExtTransport,
            pState: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const IAMExtTransport,
            StatusItem: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportBasicParameters: fn(
            self: *const IAMExtTransport,
            Param: i32,
            pValue: ?*i32,
            ppszData: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTransportBasicParameters: fn(
            self: *const IAMExtTransport,
            Param: i32,
            Value: i32,
            pszData: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportVideoParameters: fn(
            self: *const IAMExtTransport,
            Param: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTransportVideoParameters: fn(
            self: *const IAMExtTransport,
            Param: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportAudioParameters: fn(
            self: *const IAMExtTransport,
            Param: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTransportAudioParameters: fn(
            self: *const IAMExtTransport,
            Param: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: fn(
            self: *const IAMExtTransport,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: fn(
            self: *const IAMExtTransport,
            pMode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: fn(
            self: *const IAMExtTransport,
            dblRate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: fn(
            self: *const IAMExtTransport,
            pdblRate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChase: fn(
            self: *const IAMExtTransport,
            pEnabled: ?*i32,
            pOffset: ?*i32,
            phEvent: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChase: fn(
            self: *const IAMExtTransport,
            Enable: i32,
            Offset: i32,
            hEvent: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBump: fn(
            self: *const IAMExtTransport,
            pSpeed: ?*i32,
            pDuration: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBump: fn(
            self: *const IAMExtTransport,
            Speed: i32,
            Duration: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AntiClogControl: fn(
            self: *const IAMExtTransport,
            pEnabled: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AntiClogControl: fn(
            self: *const IAMExtTransport,
            Enable: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEditPropertySet: fn(
            self: *const IAMExtTransport,
            EditID: i32,
            pState: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEditPropertySet: fn(
            self: *const IAMExtTransport,
            pEditID: ?*i32,
            State: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEditProperty: fn(
            self: *const IAMExtTransport,
            EditID: i32,
            Param: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEditProperty: fn(
            self: *const IAMExtTransport,
            EditID: i32,
            Param: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EditStart: fn(
            self: *const IAMExtTransport,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EditStart: fn(
            self: *const IAMExtTransport,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetCapability(self: *const T, Capability: i32, pValue: ?*i32, pdblValue: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).GetCapability(@ptrCast(*const IAMExtTransport, self), Capability, pValue, pdblValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_MediaState(self: *const T, State: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).put_MediaState(@ptrCast(*const IAMExtTransport, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_MediaState(self: *const T, pState: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).get_MediaState(@ptrCast(*const IAMExtTransport, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_LocalControl(self: *const T, State: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).put_LocalControl(@ptrCast(*const IAMExtTransport, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_LocalControl(self: *const T, pState: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).get_LocalControl(@ptrCast(*const IAMExtTransport, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetStatus(self: *const T, StatusItem: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).GetStatus(@ptrCast(*const IAMExtTransport, self), StatusItem, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetTransportBasicParameters(self: *const T, Param: i32, pValue: ?*i32, ppszData: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).GetTransportBasicParameters(@ptrCast(*const IAMExtTransport, self), Param, pValue, ppszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetTransportBasicParameters(self: *const T, Param: i32, Value: i32, pszData: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).SetTransportBasicParameters(@ptrCast(*const IAMExtTransport, self), Param, Value, pszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetTransportVideoParameters(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).GetTransportVideoParameters(@ptrCast(*const IAMExtTransport, self), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetTransportVideoParameters(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).SetTransportVideoParameters(@ptrCast(*const IAMExtTransport, self), Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetTransportAudioParameters(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).GetTransportAudioParameters(@ptrCast(*const IAMExtTransport, self), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetTransportAudioParameters(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).SetTransportAudioParameters(@ptrCast(*const IAMExtTransport, self), Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_Mode(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).put_Mode(@ptrCast(*const IAMExtTransport, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_Mode(self: *const T, pMode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).get_Mode(@ptrCast(*const IAMExtTransport, self), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_Rate(self: *const T, dblRate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).put_Rate(@ptrCast(*const IAMExtTransport, self), dblRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_Rate(self: *const T, pdblRate: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).get_Rate(@ptrCast(*const IAMExtTransport, self), pdblRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetChase(self: *const T, pEnabled: ?*i32, pOffset: ?*i32, phEvent: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).GetChase(@ptrCast(*const IAMExtTransport, self), pEnabled, pOffset, phEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetChase(self: *const T, Enable: i32, Offset: i32, hEvent: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).SetChase(@ptrCast(*const IAMExtTransport, self), Enable, Offset, hEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetBump(self: *const T, pSpeed: ?*i32, pDuration: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).GetBump(@ptrCast(*const IAMExtTransport, self), pSpeed, pDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetBump(self: *const T, Speed: i32, Duration: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).SetBump(@ptrCast(*const IAMExtTransport, self), Speed, Duration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_AntiClogControl(self: *const T, pEnabled: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).get_AntiClogControl(@ptrCast(*const IAMExtTransport, self), pEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_AntiClogControl(self: *const T, Enable: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).put_AntiClogControl(@ptrCast(*const IAMExtTransport, self), Enable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetEditPropertySet(self: *const T, EditID: i32, pState: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).GetEditPropertySet(@ptrCast(*const IAMExtTransport, self), EditID, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetEditPropertySet(self: *const T, pEditID: ?*i32, State: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).SetEditPropertySet(@ptrCast(*const IAMExtTransport, self), pEditID, State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetEditProperty(self: *const T, EditID: i32, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).GetEditProperty(@ptrCast(*const IAMExtTransport, self), EditID, Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetEditProperty(self: *const T, EditID: i32, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).SetEditProperty(@ptrCast(*const IAMExtTransport, self), EditID, Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_EditStart(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).get_EditStart(@ptrCast(*const IAMExtTransport, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_EditStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtTransport.VTable, self.vtable).put_EditStart(@ptrCast(*const IAMExtTransport, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTimecodeReader_Value = @import("../zig.zig").Guid.initString("9b496ce1-811b-11cf-8c77-00aa006b6814");
pub const IID_IAMTimecodeReader = &IID_IAMTimecodeReader_Value;
pub const IAMTimecodeReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTCRMode: fn(
            self: *const IAMTimecodeReader,
            Param: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTCRMode: fn(
            self: *const IAMTimecodeReader,
            Param: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VITCLine: fn(
            self: *const IAMTimecodeReader,
            Line: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VITCLine: fn(
            self: *const IAMTimecodeReader,
            pLine: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimecode: fn(
            self: *const IAMTimecodeReader,
            pTimecodeSample: ?*TIMECODE_SAMPLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_GetTCRMode(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeReader.VTable, self.vtable).GetTCRMode(@ptrCast(*const IAMTimecodeReader, self), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_SetTCRMode(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeReader.VTable, self.vtable).SetTCRMode(@ptrCast(*const IAMTimecodeReader, self), Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_put_VITCLine(self: *const T, Line: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeReader.VTable, self.vtable).put_VITCLine(@ptrCast(*const IAMTimecodeReader, self), Line);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_get_VITCLine(self: *const T, pLine: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeReader.VTable, self.vtable).get_VITCLine(@ptrCast(*const IAMTimecodeReader, self), pLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_GetTimecode(self: *const T, pTimecodeSample: ?*TIMECODE_SAMPLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeReader.VTable, self.vtable).GetTimecode(@ptrCast(*const IAMTimecodeReader, self), pTimecodeSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTimecodeGenerator_Value = @import("../zig.zig").Guid.initString("9b496ce0-811b-11cf-8c77-00aa006b6814");
pub const IID_IAMTimecodeGenerator = &IID_IAMTimecodeGenerator_Value;
pub const IAMTimecodeGenerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTCGMode: fn(
            self: *const IAMTimecodeGenerator,
            Param: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTCGMode: fn(
            self: *const IAMTimecodeGenerator,
            Param: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VITCLine: fn(
            self: *const IAMTimecodeGenerator,
            Line: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VITCLine: fn(
            self: *const IAMTimecodeGenerator,
            pLine: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimecode: fn(
            self: *const IAMTimecodeGenerator,
            pTimecodeSample: ?*TIMECODE_SAMPLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimecode: fn(
            self: *const IAMTimecodeGenerator,
            pTimecodeSample: ?*TIMECODE_SAMPLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_GetTCGMode(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeGenerator.VTable, self.vtable).GetTCGMode(@ptrCast(*const IAMTimecodeGenerator, self), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_SetTCGMode(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeGenerator.VTable, self.vtable).SetTCGMode(@ptrCast(*const IAMTimecodeGenerator, self), Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_put_VITCLine(self: *const T, Line: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeGenerator.VTable, self.vtable).put_VITCLine(@ptrCast(*const IAMTimecodeGenerator, self), Line);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_get_VITCLine(self: *const T, pLine: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeGenerator.VTable, self.vtable).get_VITCLine(@ptrCast(*const IAMTimecodeGenerator, self), pLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_SetTimecode(self: *const T, pTimecodeSample: ?*TIMECODE_SAMPLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeGenerator.VTable, self.vtable).SetTimecode(@ptrCast(*const IAMTimecodeGenerator, self), pTimecodeSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_GetTimecode(self: *const T, pTimecodeSample: ?*TIMECODE_SAMPLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeGenerator.VTable, self.vtable).GetTimecode(@ptrCast(*const IAMTimecodeGenerator, self), pTimecodeSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTimecodeDisplay_Value = @import("../zig.zig").Guid.initString("9b496ce2-811b-11cf-8c77-00aa006b6814");
pub const IID_IAMTimecodeDisplay = &IID_IAMTimecodeDisplay_Value;
pub const IAMTimecodeDisplay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTCDisplayEnable: fn(
            self: *const IAMTimecodeDisplay,
            pState: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTCDisplayEnable: fn(
            self: *const IAMTimecodeDisplay,
            State: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTCDisplay: fn(
            self: *const IAMTimecodeDisplay,
            Param: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTCDisplay: fn(
            self: *const IAMTimecodeDisplay,
            Param: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeDisplay_GetTCDisplayEnable(self: *const T, pState: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeDisplay.VTable, self.vtable).GetTCDisplayEnable(@ptrCast(*const IAMTimecodeDisplay, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeDisplay_SetTCDisplayEnable(self: *const T, State: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeDisplay.VTable, self.vtable).SetTCDisplayEnable(@ptrCast(*const IAMTimecodeDisplay, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeDisplay_GetTCDisplay(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeDisplay.VTable, self.vtable).GetTCDisplay(@ptrCast(*const IAMTimecodeDisplay, self), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeDisplay_SetTCDisplay(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMTimecodeDisplay.VTable, self.vtable).SetTCDisplay(@ptrCast(*const IAMTimecodeDisplay, self), Param, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMDevMemoryAllocator_Value = @import("../zig.zig").Guid.initString("c6545bf0-e76b-11d0-bd52-00a0c911ce86");
pub const IID_IAMDevMemoryAllocator = &IID_IAMDevMemoryAllocator_Value;
pub const IAMDevMemoryAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: fn(
            self: *const IAMDevMemoryAllocator,
            pdwcbTotalFree: ?*u32,
            pdwcbLargestFree: ?*u32,
            pdwcbTotalMemory: ?*u32,
            pdwcbMinimumChunk: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckMemory: fn(
            self: *const IAMDevMemoryAllocator,
            pBuffer: ?*const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Alloc: fn(
            self: *const IAMDevMemoryAllocator,
            ppBuffer: ?*?*u8,
            pdwcbBuffer: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Free: fn(
            self: *const IAMDevMemoryAllocator,
            pBuffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevMemoryObject: fn(
            self: *const IAMDevMemoryAllocator,
            ppUnkInnner: ?*?*IUnknown,
            pUnkOuter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_GetInfo(self: *const T, pdwcbTotalFree: ?*u32, pdwcbLargestFree: ?*u32, pdwcbTotalMemory: ?*u32, pdwcbMinimumChunk: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDevMemoryAllocator.VTable, self.vtable).GetInfo(@ptrCast(*const IAMDevMemoryAllocator, self), pdwcbTotalFree, pdwcbLargestFree, pdwcbTotalMemory, pdwcbMinimumChunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_CheckMemory(self: *const T, pBuffer: ?*const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDevMemoryAllocator.VTable, self.vtable).CheckMemory(@ptrCast(*const IAMDevMemoryAllocator, self), pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_Alloc(self: *const T, ppBuffer: ?*?*u8, pdwcbBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDevMemoryAllocator.VTable, self.vtable).Alloc(@ptrCast(*const IAMDevMemoryAllocator, self), ppBuffer, pdwcbBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_Free(self: *const T, pBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDevMemoryAllocator.VTable, self.vtable).Free(@ptrCast(*const IAMDevMemoryAllocator, self), pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_GetDevMemoryObject(self: *const T, ppUnkInnner: ?*?*IUnknown, pUnkOuter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDevMemoryAllocator.VTable, self.vtable).GetDevMemoryObject(@ptrCast(*const IAMDevMemoryAllocator, self), ppUnkInnner, pUnkOuter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMDevMemoryControl_Value = @import("../zig.zig").Guid.initString("c6545bf1-e76b-11d0-bd52-00a0c911ce86");
pub const IID_IAMDevMemoryControl = &IID_IAMDevMemoryControl_Value;
pub const IAMDevMemoryControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryWriteSync: fn(
            self: *const IAMDevMemoryControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSync: fn(
            self: *const IAMDevMemoryControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevId: fn(
            self: *const IAMDevMemoryControl,
            pdwDevId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryControl_QueryWriteSync(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDevMemoryControl.VTable, self.vtable).QueryWriteSync(@ptrCast(*const IAMDevMemoryControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryControl_WriteSync(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDevMemoryControl.VTable, self.vtable).WriteSync(@ptrCast(*const IAMDevMemoryControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryControl_GetDevId(self: *const T, pdwDevId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDevMemoryControl.VTable, self.vtable).GetDevId(@ptrCast(*const IAMDevMemoryControl, self), pdwDevId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AMSTREAMSELECTINFOFLAGS = enum(i32) {
    NABLED = 1,
    XCLUSIVE = 2,
};
pub const AMSTREAMSELECTINFO_ENABLED = _AMSTREAMSELECTINFOFLAGS.NABLED;
pub const AMSTREAMSELECTINFO_EXCLUSIVE = _AMSTREAMSELECTINFOFLAGS.XCLUSIVE;

pub const _AMSTREAMSELECTENABLEFLAGS = enum(i32) {
    E = 1,
    ALL = 2,
};
pub const AMSTREAMSELECTENABLE_ENABLE = _AMSTREAMSELECTENABLEFLAGS.E;
pub const AMSTREAMSELECTENABLE_ENABLEALL = _AMSTREAMSELECTENABLEFLAGS.ALL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMStreamSelect_Value = @import("../zig.zig").Guid.initString("c1960960-17f5-11d1-abe1-00a0c905f375");
pub const IID_IAMStreamSelect = &IID_IAMStreamSelect_Value;
pub const IAMStreamSelect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Count: fn(
            self: *const IAMStreamSelect,
            pcStreams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Info: fn(
            self: *const IAMStreamSelect,
            lIndex: i32,
            ppmt: ?*?*AM_MEDIA_TYPE,
            pdwFlags: ?*u32,
            plcid: ?*u32,
            pdwGroup: ?*u32,
            ppszName: ?*?PWSTR,
            ppObject: ?*?*IUnknown,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const IAMStreamSelect,
            lIndex: i32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamSelect_Count(self: *const T, pcStreams: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamSelect.VTable, self.vtable).Count(@ptrCast(*const IAMStreamSelect, self), pcStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamSelect_Info(self: *const T, lIndex: i32, ppmt: ?*?*AM_MEDIA_TYPE, pdwFlags: ?*u32, plcid: ?*u32, pdwGroup: ?*u32, ppszName: ?*?PWSTR, ppObject: ?*?*IUnknown, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamSelect.VTable, self.vtable).Info(@ptrCast(*const IAMStreamSelect, self), lIndex, ppmt, pdwFlags, plcid, pdwGroup, ppszName, ppObject, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamSelect_Enable(self: *const T, lIndex: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStreamSelect.VTable, self.vtable).Enable(@ptrCast(*const IAMStreamSelect, self), lIndex, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AMRESCTL_RESERVEFLAGS = enum(i32) {
    RESERVE = 0,
    UNRESERVE = 1,
};
pub const AMRESCTL_RESERVEFLAGS_RESERVE = _AMRESCTL_RESERVEFLAGS.RESERVE;
pub const AMRESCTL_RESERVEFLAGS_UNRESERVE = _AMRESCTL_RESERVEFLAGS.UNRESERVE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMResourceControl_Value = @import("../zig.zig").Guid.initString("8389d2d0-77d7-11d1-abe6-00a0c905f375");
pub const IID_IAMResourceControl = &IID_IAMResourceControl_Value;
pub const IAMResourceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reserve: fn(
            self: *const IAMResourceControl,
            dwFlags: u32,
            pvReserved: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMResourceControl_Reserve(self: *const T, dwFlags: u32, pvReserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMResourceControl.VTable, self.vtable).Reserve(@ptrCast(*const IAMResourceControl, self), dwFlags, pvReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMClockAdjust_Value = @import("../zig.zig").Guid.initString("4d5466b0-a49c-11d1-abe8-00a0c905f375");
pub const IID_IAMClockAdjust = &IID_IAMClockAdjust_Value;
pub const IAMClockAdjust = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetClockDelta: fn(
            self: *const IAMClockAdjust,
            rtDelta: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMClockAdjust_SetClockDelta(self: *const T, rtDelta: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMClockAdjust.VTable, self.vtable).SetClockDelta(@ptrCast(*const IAMClockAdjust, self), rtDelta);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_FILTER_MISC_FLAGS = enum(i32) {
    RENDERER = 1,
    SOURCE = 2,
};
pub const AM_FILTER_MISC_FLAGS_IS_RENDERER = _AM_FILTER_MISC_FLAGS.RENDERER;
pub const AM_FILTER_MISC_FLAGS_IS_SOURCE = _AM_FILTER_MISC_FLAGS.SOURCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMFilterMiscFlags_Value = @import("../zig.zig").Guid.initString("2dd74950-a890-11d1-abe8-00a0c905f375");
pub const IID_IAMFilterMiscFlags = &IID_IAMFilterMiscFlags_Value;
pub const IAMFilterMiscFlags = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMiscFlags: fn(
            self: *const IAMFilterMiscFlags,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMFilterMiscFlags_GetMiscFlags(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IAMFilterMiscFlags.VTable, self.vtable).GetMiscFlags(@ptrCast(*const IAMFilterMiscFlags, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDrawVideoImage_Value = @import("../zig.zig").Guid.initString("48efb120-ab49-11d2-aed2-00a0c995e8d5");
pub const IID_IDrawVideoImage = &IID_IDrawVideoImage_Value;
pub const IDrawVideoImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DrawVideoImageBegin: fn(
            self: *const IDrawVideoImage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DrawVideoImageEnd: fn(
            self: *const IDrawVideoImage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DrawVideoImageDraw: fn(
            self: *const IDrawVideoImage,
            hdc: ?HDC,
            lprcSrc: ?*RECT,
            lprcDst: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDrawVideoImage_DrawVideoImageBegin(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDrawVideoImage.VTable, self.vtable).DrawVideoImageBegin(@ptrCast(*const IDrawVideoImage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDrawVideoImage_DrawVideoImageEnd(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDrawVideoImage.VTable, self.vtable).DrawVideoImageEnd(@ptrCast(*const IDrawVideoImage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDrawVideoImage_DrawVideoImageDraw(self: *const T, hdc: ?HDC, lprcSrc: ?*RECT, lprcDst: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDrawVideoImage.VTable, self.vtable).DrawVideoImageDraw(@ptrCast(*const IDrawVideoImage, self), hdc, lprcSrc, lprcDst);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDecimateVideoImage_Value = @import("../zig.zig").Guid.initString("2e5ea3e0-e924-11d2-b6da-00a0c995e8df");
pub const IID_IDecimateVideoImage = &IID_IDecimateVideoImage_Value;
pub const IDecimateVideoImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDecimationImageSize: fn(
            self: *const IDecimateVideoImage,
            lWidth: i32,
            lHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetDecimationImageSize: fn(
            self: *const IDecimateVideoImage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDecimateVideoImage_SetDecimationImageSize(self: *const T, lWidth: i32, lHeight: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDecimateVideoImage.VTable, self.vtable).SetDecimationImageSize(@ptrCast(*const IDecimateVideoImage, self), lWidth, lHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDecimateVideoImage_ResetDecimationImageSize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDecimateVideoImage.VTable, self.vtable).ResetDecimationImageSize(@ptrCast(*const IDecimateVideoImage, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DECIMATION_USAGE = enum(i32) {
    LEGACY = 0,
    USE_DECODER_ONLY = 1,
    USE_VIDEOPORT_ONLY = 2,
    USE_OVERLAY_ONLY = 3,
    DEFAULT = 4,
};
pub const DECIMATION_LEGACY = DECIMATION_USAGE.LEGACY;
pub const DECIMATION_USE_DECODER_ONLY = DECIMATION_USAGE.USE_DECODER_ONLY;
pub const DECIMATION_USE_VIDEOPORT_ONLY = DECIMATION_USAGE.USE_VIDEOPORT_ONLY;
pub const DECIMATION_USE_OVERLAY_ONLY = DECIMATION_USAGE.USE_OVERLAY_ONLY;
pub const DECIMATION_DEFAULT = DECIMATION_USAGE.DEFAULT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMVideoDecimationProperties_Value = @import("../zig.zig").Guid.initString("60d32930-13da-11d3-9ec6-c4fcaef5c7be");
pub const IID_IAMVideoDecimationProperties = &IID_IAMVideoDecimationProperties_Value;
pub const IAMVideoDecimationProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryDecimationUsage: fn(
            self: *const IAMVideoDecimationProperties,
            lpUsage: ?*DECIMATION_USAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDecimationUsage: fn(
            self: *const IAMVideoDecimationProperties,
            Usage: DECIMATION_USAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoDecimationProperties_QueryDecimationUsage(self: *const T, lpUsage: ?*DECIMATION_USAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoDecimationProperties.VTable, self.vtable).QueryDecimationUsage(@ptrCast(*const IAMVideoDecimationProperties, self), lpUsage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoDecimationProperties_SetDecimationUsage(self: *const T, Usage: DECIMATION_USAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoDecimationProperties.VTable, self.vtable).SetDecimationUsage(@ptrCast(*const IAMVideoDecimationProperties, self), Usage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVideoFrameStep_Value = @import("../zig.zig").Guid.initString("e46a9787-2b71-444d-a4b5-1fab7b708d6a");
pub const IID_IVideoFrameStep = &IID_IVideoFrameStep_Value;
pub const IVideoFrameStep = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Step: fn(
            self: *const IVideoFrameStep,
            dwFrames: u32,
            pStepObject: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanStep: fn(
            self: *const IVideoFrameStep,
            bMultiple: i32,
            pStepObject: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelStep: fn(
            self: *const IVideoFrameStep,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoFrameStep_Step(self: *const T, dwFrames: u32, pStepObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoFrameStep.VTable, self.vtable).Step(@ptrCast(*const IVideoFrameStep, self), dwFrames, pStepObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoFrameStep_CanStep(self: *const T, bMultiple: i32, pStepObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoFrameStep.VTable, self.vtable).CanStep(@ptrCast(*const IVideoFrameStep, self), bMultiple, pStepObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoFrameStep_CancelStep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoFrameStep.VTable, self.vtable).CancelStep(@ptrCast(*const IVideoFrameStep, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_PUSHSOURCE_FLAGS = enum(i32) {
    CAPS_INTERNAL_RM = 1,
    CAPS_NOT_LIVE = 2,
    CAPS_PRIVATE_CLOCK = 4,
    REQS_USE_STREAM_CLOCK = 65536,
    REQS_USE_CLOCK_CHAIN = 131072,
};
pub const AM_PUSHSOURCECAPS_INTERNAL_RM = _AM_PUSHSOURCE_FLAGS.CAPS_INTERNAL_RM;
pub const AM_PUSHSOURCECAPS_NOT_LIVE = _AM_PUSHSOURCE_FLAGS.CAPS_NOT_LIVE;
pub const AM_PUSHSOURCECAPS_PRIVATE_CLOCK = _AM_PUSHSOURCE_FLAGS.CAPS_PRIVATE_CLOCK;
pub const AM_PUSHSOURCEREQS_USE_STREAM_CLOCK = _AM_PUSHSOURCE_FLAGS.REQS_USE_STREAM_CLOCK;
pub const AM_PUSHSOURCEREQS_USE_CLOCK_CHAIN = _AM_PUSHSOURCE_FLAGS.REQS_USE_CLOCK_CHAIN;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMLatency_Value = @import("../zig.zig").Guid.initString("62ea93ba-ec62-11d2-b770-00c04fb6bd3d");
pub const IID_IAMLatency = &IID_IAMLatency_Value;
pub const IAMLatency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLatency: fn(
            self: *const IAMLatency,
            prtLatency: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLatency_GetLatency(self: *const T, prtLatency: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLatency.VTable, self.vtable).GetLatency(@ptrCast(*const IAMLatency, self), prtLatency);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMPushSource_Value = @import("../zig.zig").Guid.initString("f185fe76-e64e-11d2-b76e-00c04fb6bd3d");
pub const IID_IAMPushSource = &IID_IAMPushSource_Value;
pub const IAMPushSource = extern struct {
    pub const VTable = extern struct {
        base: IAMLatency.VTable,
        GetPushSourceFlags: fn(
            self: *const IAMPushSource,
            pFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPushSourceFlags: fn(
            self: *const IAMPushSource,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamOffset: fn(
            self: *const IAMPushSource,
            rtOffset: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamOffset: fn(
            self: *const IAMPushSource,
            prtOffset: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxStreamOffset: fn(
            self: *const IAMPushSource,
            prtMaxOffset: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaxStreamOffset: fn(
            self: *const IAMPushSource,
            rtMaxOffset: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAMLatency.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_GetPushSourceFlags(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPushSource.VTable, self.vtable).GetPushSourceFlags(@ptrCast(*const IAMPushSource, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_SetPushSourceFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPushSource.VTable, self.vtable).SetPushSourceFlags(@ptrCast(*const IAMPushSource, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_SetStreamOffset(self: *const T, rtOffset: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPushSource.VTable, self.vtable).SetStreamOffset(@ptrCast(*const IAMPushSource, self), rtOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_GetStreamOffset(self: *const T, prtOffset: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPushSource.VTable, self.vtable).GetStreamOffset(@ptrCast(*const IAMPushSource, self), prtOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_GetMaxStreamOffset(self: *const T, prtMaxOffset: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPushSource.VTable, self.vtable).GetMaxStreamOffset(@ptrCast(*const IAMPushSource, self), prtMaxOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_SetMaxStreamOffset(self: *const T, rtMaxOffset: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPushSource.VTable, self.vtable).SetMaxStreamOffset(@ptrCast(*const IAMPushSource, self), rtMaxOffset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMDeviceRemoval_Value = @import("../zig.zig").Guid.initString("f90a6130-b658-11d2-ae49-0000f8754b99");
pub const IID_IAMDeviceRemoval = &IID_IAMDeviceRemoval_Value;
pub const IAMDeviceRemoval = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeviceInfo: fn(
            self: *const IAMDeviceRemoval,
            pclsidInterfaceClass: ?*Guid,
            pwszSymbolicLink: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reassociate: fn(
            self: *const IAMDeviceRemoval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disassociate: fn(
            self: *const IAMDeviceRemoval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDeviceRemoval_DeviceInfo(self: *const T, pclsidInterfaceClass: ?*Guid, pwszSymbolicLink: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDeviceRemoval.VTable, self.vtable).DeviceInfo(@ptrCast(*const IAMDeviceRemoval, self), pclsidInterfaceClass, pwszSymbolicLink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDeviceRemoval_Reassociate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDeviceRemoval.VTable, self.vtable).Reassociate(@ptrCast(*const IAMDeviceRemoval, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDeviceRemoval_Disassociate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDeviceRemoval.VTable, self.vtable).Disassociate(@ptrCast(*const IAMDeviceRemoval, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVINFO = extern struct {
    dwDVAAuxSrc: u32,
    dwDVAAuxCtl: u32,
    dwDVAAuxSrc1: u32,
    dwDVAAuxCtl1: u32,
    dwDVVAuxSrc: u32,
    dwDVVAuxCtl: u32,
    dwDVReserved: [2]u32,
};

pub const _DVENCODERRESOLUTION = enum(i32) {
    @"720x480" = 2012,
    @"360x240" = 2013,
    @"180x120" = 2014,
    @"88x60" = 2015,
};
pub const DVENCODERRESOLUTION_720x480 = _DVENCODERRESOLUTION.@"720x480";
pub const DVENCODERRESOLUTION_360x240 = _DVENCODERRESOLUTION.@"360x240";
pub const DVENCODERRESOLUTION_180x120 = _DVENCODERRESOLUTION.@"180x120";
pub const DVENCODERRESOLUTION_88x60 = _DVENCODERRESOLUTION.@"88x60";

pub const _DVENCODERVIDEOFORMAT = enum(i32) {
    NTSC = 2000,
    PAL = 2001,
};
pub const DVENCODERVIDEOFORMAT_NTSC = _DVENCODERVIDEOFORMAT.NTSC;
pub const DVENCODERVIDEOFORMAT_PAL = _DVENCODERVIDEOFORMAT.PAL;

pub const _DVENCODERFORMAT = enum(i32) {
    SD = 2007,
    HD = 2008,
    SL = 2009,
};
pub const DVENCODERFORMAT_DVSD = _DVENCODERFORMAT.SD;
pub const DVENCODERFORMAT_DVHD = _DVENCODERFORMAT.HD;
pub const DVENCODERFORMAT_DVSL = _DVENCODERFORMAT.SL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDVEnc_Value = @import("../zig.zig").Guid.initString("d18e17a0-aacb-11d0-afb0-00aa00b67a42");
pub const IID_IDVEnc = &IID_IDVEnc_Value;
pub const IDVEnc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IFormatResolution: fn(
            self: *const IDVEnc,
            VideoFormat: ?*i32,
            DVFormat: ?*i32,
            Resolution: ?*i32,
            fDVInfo: u8,
            sDVInfo: ?*DVINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IFormatResolution: fn(
            self: *const IDVEnc,
            VideoFormat: i32,
            DVFormat: i32,
            Resolution: i32,
            fDVInfo: u8,
            sDVInfo: ?*DVINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVEnc_get_IFormatResolution(self: *const T, VideoFormat: ?*i32, DVFormat: ?*i32, Resolution: ?*i32, fDVInfo: u8, sDVInfo: ?*DVINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVEnc.VTable, self.vtable).get_IFormatResolution(@ptrCast(*const IDVEnc, self), VideoFormat, DVFormat, Resolution, fDVInfo, sDVInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVEnc_put_IFormatResolution(self: *const T, VideoFormat: i32, DVFormat: i32, Resolution: i32, fDVInfo: u8, sDVInfo: ?*DVINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVEnc.VTable, self.vtable).put_IFormatResolution(@ptrCast(*const IDVEnc, self), VideoFormat, DVFormat, Resolution, fDVInfo, sDVInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _DVDECODERRESOLUTION = enum(i32) {
    @"720x480" = 1000,
    @"360x240" = 1001,
    @"180x120" = 1002,
    @"88x60" = 1003,
};
pub const DVDECODERRESOLUTION_720x480 = _DVDECODERRESOLUTION.@"720x480";
pub const DVDECODERRESOLUTION_360x240 = _DVDECODERRESOLUTION.@"360x240";
pub const DVDECODERRESOLUTION_180x120 = _DVDECODERRESOLUTION.@"180x120";
pub const DVDECODERRESOLUTION_88x60 = _DVDECODERRESOLUTION.@"88x60";

pub const _DVRESOLUTION = enum(i32) {
    FULL = 1000,
    HALF = 1001,
    QUARTER = 1002,
    DC = 1003,
};
pub const DVRESOLUTION_FULL = _DVRESOLUTION.FULL;
pub const DVRESOLUTION_HALF = _DVRESOLUTION.HALF;
pub const DVRESOLUTION_QUARTER = _DVRESOLUTION.QUARTER;
pub const DVRESOLUTION_DC = _DVRESOLUTION.DC;

// TODO: this type is limited to platform 'windows5.0'
const IID_IIPDVDec_Value = @import("../zig.zig").Guid.initString("b8e8bd60-0bfe-11d0-af91-00aa00b67a42");
pub const IID_IIPDVDec = &IID_IIPDVDec_Value;
pub const IIPDVDec = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IPDisplay: fn(
            self: *const IIPDVDec,
            displayPix: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IPDisplay: fn(
            self: *const IIPDVDec,
            displayPix: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIPDVDec_get_IPDisplay(self: *const T, displayPix: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIPDVDec.VTable, self.vtable).get_IPDisplay(@ptrCast(*const IIPDVDec, self), displayPix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIPDVDec_put_IPDisplay(self: *const T, displayPix: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIPDVDec.VTable, self.vtable).put_IPDisplay(@ptrCast(*const IIPDVDec, self), displayPix);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVRGB219_Value = @import("../zig.zig").Guid.initString("58473a19-2bc8-4663-8012-25f81babddd1");
pub const IID_IDVRGB219 = &IID_IDVRGB219_Value;
pub const IDVRGB219 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRGB219: fn(
            self: *const IDVRGB219,
            bState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVRGB219_SetRGB219(self: *const T, bState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVRGB219.VTable, self.vtable).SetRGB219(@ptrCast(*const IDVRGB219, self), bState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVSplitter_Value = @import("../zig.zig").Guid.initString("92a3a302-da7c-4a1f-ba7e-1802bb5d2d02");
pub const IID_IDVSplitter = &IID_IDVSplitter_Value;
pub const IDVSplitter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DiscardAlternateVideoFrames: fn(
            self: *const IDVSplitter,
            nDiscard: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVSplitter_DiscardAlternateVideoFrames(self: *const T, nDiscard: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVSplitter.VTable, self.vtable).DiscardAlternateVideoFrames(@ptrCast(*const IDVSplitter, self), nDiscard);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_AUDIO_RENDERER_STAT_PARAM = enum(i32) {
    BREAK_COUNT = 1,
    SLAVE_MODE = 2,
    SILENCE_DUR = 3,
    LAST_BUFFER_DUR = 4,
    DISCONTINUITIES = 5,
    SLAVE_RATE = 6,
    SLAVE_DROPWRITE_DUR = 7,
    SLAVE_HIGHLOWERROR = 8,
    SLAVE_LASTHIGHLOWERROR = 9,
    SLAVE_ACCUMERROR = 10,
    BUFFERFULLNESS = 11,
    JITTER = 12,
};
pub const AM_AUDREND_STAT_PARAM_BREAK_COUNT = _AM_AUDIO_RENDERER_STAT_PARAM.BREAK_COUNT;
pub const AM_AUDREND_STAT_PARAM_SLAVE_MODE = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_MODE;
pub const AM_AUDREND_STAT_PARAM_SILENCE_DUR = _AM_AUDIO_RENDERER_STAT_PARAM.SILENCE_DUR;
pub const AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR = _AM_AUDIO_RENDERER_STAT_PARAM.LAST_BUFFER_DUR;
pub const AM_AUDREND_STAT_PARAM_DISCONTINUITIES = _AM_AUDIO_RENDERER_STAT_PARAM.DISCONTINUITIES;
pub const AM_AUDREND_STAT_PARAM_SLAVE_RATE = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_RATE;
pub const AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_DROPWRITE_DUR;
pub const AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_HIGHLOWERROR;
pub const AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_LASTHIGHLOWERROR;
pub const AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_ACCUMERROR;
pub const AM_AUDREND_STAT_PARAM_BUFFERFULLNESS = _AM_AUDIO_RENDERER_STAT_PARAM.BUFFERFULLNESS;
pub const AM_AUDREND_STAT_PARAM_JITTER = _AM_AUDIO_RENDERER_STAT_PARAM.JITTER;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMAudioRendererStats_Value = @import("../zig.zig").Guid.initString("22320cb2-d41a-11d2-bf7c-d7cb9df0bf93");
pub const IID_IAMAudioRendererStats = &IID_IAMAudioRendererStats_Value;
pub const IAMAudioRendererStats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatParam: fn(
            self: *const IAMAudioRendererStats,
            dwParam: u32,
            pdwParam1: ?*u32,
            pdwParam2: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioRendererStats_GetStatParam(self: *const T, dwParam: u32, pdwParam1: ?*u32, pdwParam2: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAudioRendererStats.VTable, self.vtable).GetStatParam(@ptrCast(*const IAMAudioRendererStats, self), dwParam, pdwParam1, pdwParam2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_INTF_SEARCH_FLAGS = enum(i32) {
    INPUT_PIN = 1,
    OUTPUT_PIN = 2,
    FILTER = 4,
};
pub const AM_INTF_SEARCH_INPUT_PIN = _AM_INTF_SEARCH_FLAGS.INPUT_PIN;
pub const AM_INTF_SEARCH_OUTPUT_PIN = _AM_INTF_SEARCH_FLAGS.OUTPUT_PIN;
pub const AM_INTF_SEARCH_FILTER = _AM_INTF_SEARCH_FLAGS.FILTER;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMGraphStreams_Value = @import("../zig.zig").Guid.initString("632105fa-072e-11d3-8af9-00c04fb6bd3d");
pub const IID_IAMGraphStreams = &IID_IAMGraphStreams_Value;
pub const IAMGraphStreams = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindUpstreamInterface: fn(
            self: *const IAMGraphStreams,
            pPin: ?*IPin,
            riid: ?*const Guid,
            ppvInterface: ?*?*anyopaque,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SyncUsingStreamOffset: fn(
            self: *const IAMGraphStreams,
            bUseStreamOffset: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaxGraphLatency: fn(
            self: *const IAMGraphStreams,
            rtMaxGraphLatency: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphStreams_FindUpstreamInterface(self: *const T, pPin: ?*IPin, riid: ?*const Guid, ppvInterface: ?*?*anyopaque, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMGraphStreams.VTable, self.vtable).FindUpstreamInterface(@ptrCast(*const IAMGraphStreams, self), pPin, riid, ppvInterface, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphStreams_SyncUsingStreamOffset(self: *const T, bUseStreamOffset: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMGraphStreams.VTable, self.vtable).SyncUsingStreamOffset(@ptrCast(*const IAMGraphStreams, self), bUseStreamOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphStreams_SetMaxGraphLatency(self: *const T, rtMaxGraphLatency: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMGraphStreams.VTable, self.vtable).SetMaxGraphLatency(@ptrCast(*const IAMGraphStreams, self), rtMaxGraphLatency);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMOVERLAYFX = enum(i32) {
    NOFX = 0,
    MIRRORLEFTRIGHT = 2,
    MIRRORUPDOWN = 4,
    DEINTERLACE = 8,
};
pub const AMOVERFX_NOFX = AMOVERLAYFX.NOFX;
pub const AMOVERFX_MIRRORLEFTRIGHT = AMOVERLAYFX.MIRRORLEFTRIGHT;
pub const AMOVERFX_MIRRORUPDOWN = AMOVERLAYFX.MIRRORUPDOWN;
pub const AMOVERFX_DEINTERLACE = AMOVERLAYFX.DEINTERLACE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMOverlayFX_Value = @import("../zig.zig").Guid.initString("62fae250-7e65-4460-bfc9-6398b322073c");
pub const IID_IAMOverlayFX = &IID_IAMOverlayFX_Value;
pub const IAMOverlayFX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryOverlayFXCaps: fn(
            self: *const IAMOverlayFX,
            lpdwOverlayFXCaps: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlayFX: fn(
            self: *const IAMOverlayFX,
            dwOverlayFX: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlayFX: fn(
            self: *const IAMOverlayFX,
            lpdwOverlayFX: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOverlayFX_QueryOverlayFXCaps(self: *const T, lpdwOverlayFXCaps: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMOverlayFX.VTable, self.vtable).QueryOverlayFXCaps(@ptrCast(*const IAMOverlayFX, self), lpdwOverlayFXCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOverlayFX_SetOverlayFX(self: *const T, dwOverlayFX: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMOverlayFX.VTable, self.vtable).SetOverlayFX(@ptrCast(*const IAMOverlayFX, self), dwOverlayFX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOverlayFX_GetOverlayFX(self: *const T, lpdwOverlayFX: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMOverlayFX.VTable, self.vtable).GetOverlayFX(@ptrCast(*const IAMOverlayFX, self), lpdwOverlayFX);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMOpenProgress_Value = @import("../zig.zig").Guid.initString("8e1c39a1-de53-11cf-aa63-0080c744528d");
pub const IID_IAMOpenProgress = &IID_IAMOpenProgress_Value;
pub const IAMOpenProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryProgress: fn(
            self: *const IAMOpenProgress,
            pllTotal: ?*i64,
            pllCurrent: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortOperation: fn(
            self: *const IAMOpenProgress,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOpenProgress_QueryProgress(self: *const T, pllTotal: ?*i64, pllCurrent: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMOpenProgress.VTable, self.vtable).QueryProgress(@ptrCast(*const IAMOpenProgress, self), pllTotal, pllCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOpenProgress_AbortOperation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMOpenProgress.VTable, self.vtable).AbortOperation(@ptrCast(*const IAMOpenProgress, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMpeg2Demultiplexer_Value = @import("../zig.zig").Guid.initString("436eee9c-264f-4242-90e1-4e330c107512");
pub const IID_IMpeg2Demultiplexer = &IID_IMpeg2Demultiplexer_Value;
pub const IMpeg2Demultiplexer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateOutputPin: fn(
            self: *const IMpeg2Demultiplexer,
            pMediaType: ?*AM_MEDIA_TYPE,
            pszPinName: ?PWSTR,
            ppIPin: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputPinMediaType: fn(
            self: *const IMpeg2Demultiplexer,
            pszPinName: ?PWSTR,
            pMediaType: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteOutputPin: fn(
            self: *const IMpeg2Demultiplexer,
            pszPinName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Demultiplexer_CreateOutputPin(self: *const T, pMediaType: ?*AM_MEDIA_TYPE, pszPinName: ?PWSTR, ppIPin: ?*?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2Demultiplexer.VTable, self.vtable).CreateOutputPin(@ptrCast(*const IMpeg2Demultiplexer, self), pMediaType, pszPinName, ppIPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Demultiplexer_SetOutputPinMediaType(self: *const T, pszPinName: ?PWSTR, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2Demultiplexer.VTable, self.vtable).SetOutputPinMediaType(@ptrCast(*const IMpeg2Demultiplexer, self), pszPinName, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Demultiplexer_DeleteOutputPin(self: *const T, pszPinName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2Demultiplexer.VTable, self.vtable).DeleteOutputPin(@ptrCast(*const IMpeg2Demultiplexer, self), pszPinName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STREAM_ID_MAP = extern struct {
    stream_id: u32,
    dwMediaSampleContent: u32,
    ulSubstreamFilterValue: u32,
    iDataOffset: i32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumStreamIdMap_Value = @import("../zig.zig").Guid.initString("945c1566-6202-46fc-96c7-d87f289c6534");
pub const IID_IEnumStreamIdMap = &IID_IEnumStreamIdMap_Value;
pub const IEnumStreamIdMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumStreamIdMap,
            cRequest: u32,
            pStreamIdMap: [*]STREAM_ID_MAP,
            pcReceived: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumStreamIdMap,
            cRecords: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumStreamIdMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumStreamIdMap,
            ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamIdMap_Next(self: *const T, cRequest: u32, pStreamIdMap: [*]STREAM_ID_MAP, pcReceived: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumStreamIdMap.VTable, self.vtable).Next(@ptrCast(*const IEnumStreamIdMap, self), cRequest, pStreamIdMap, pcReceived);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamIdMap_Skip(self: *const T, cRecords: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumStreamIdMap.VTable, self.vtable).Skip(@ptrCast(*const IEnumStreamIdMap, self), cRecords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamIdMap_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumStreamIdMap.VTable, self.vtable).Reset(@ptrCast(*const IEnumStreamIdMap, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamIdMap_Clone(self: *const T, ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumStreamIdMap.VTable, self.vtable).Clone(@ptrCast(*const IEnumStreamIdMap, self), ppIEnumStreamIdMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2StreamIdMap_Value = @import("../zig.zig").Guid.initString("d0e04c47-25b8-4369-925a-362a01d95444");
pub const IID_IMPEG2StreamIdMap = &IID_IMPEG2StreamIdMap_Value;
pub const IMPEG2StreamIdMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapStreamId: fn(
            self: *const IMPEG2StreamIdMap,
            ulStreamId: u32,
            MediaSampleContent: u32,
            ulSubstreamFilterValue: u32,
            iDataOffset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnmapStreamId: fn(
            self: *const IMPEG2StreamIdMap,
            culStreamId: u32,
            pulStreamId: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumStreamIdMap: fn(
            self: *const IMPEG2StreamIdMap,
            ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2StreamIdMap_MapStreamId(self: *const T, ulStreamId: u32, MediaSampleContent: u32, ulSubstreamFilterValue: u32, iDataOffset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2StreamIdMap.VTable, self.vtable).MapStreamId(@ptrCast(*const IMPEG2StreamIdMap, self), ulStreamId, MediaSampleContent, ulSubstreamFilterValue, iDataOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2StreamIdMap_UnmapStreamId(self: *const T, culStreamId: u32, pulStreamId: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2StreamIdMap.VTable, self.vtable).UnmapStreamId(@ptrCast(*const IMPEG2StreamIdMap, self), culStreamId, pulStreamId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2StreamIdMap_EnumStreamIdMap(self: *const T, ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2StreamIdMap.VTable, self.vtable).EnumStreamIdMap(@ptrCast(*const IMPEG2StreamIdMap, self), ppIEnumStreamIdMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRegisterServiceProvider_Value = @import("../zig.zig").Guid.initString("7b3a2f01-0751-48dd-b556-004785171c54");
pub const IID_IRegisterServiceProvider = &IID_IRegisterServiceProvider_Value;
pub const IRegisterServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterService: fn(
            self: *const IRegisterServiceProvider,
            guidService: ?*const Guid,
            pUnkObject: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisterServiceProvider_RegisterService(self: *const T, guidService: ?*const Guid, pUnkObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisterServiceProvider.VTable, self.vtable).RegisterService(@ptrCast(*const IRegisterServiceProvider, self), guidService, pUnkObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMClockSlave_Value = @import("../zig.zig").Guid.initString("9fd52741-176d-4b36-8f51-ca8f933223be");
pub const IID_IAMClockSlave = &IID_IAMClockSlave_Value;
pub const IAMClockSlave = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetErrorTolerance: fn(
            self: *const IAMClockSlave,
            dwTolerance: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorTolerance: fn(
            self: *const IAMClockSlave,
            pdwTolerance: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMClockSlave_SetErrorTolerance(self: *const T, dwTolerance: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMClockSlave.VTable, self.vtable).SetErrorTolerance(@ptrCast(*const IAMClockSlave, self), dwTolerance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMClockSlave_GetErrorTolerance(self: *const T, pdwTolerance: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMClockSlave.VTable, self.vtable).GetErrorTolerance(@ptrCast(*const IAMClockSlave, self), pdwTolerance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMGraphBuilderCallback_Value = @import("../zig.zig").Guid.initString("4995f511-9ddb-4f12-bd3b-f04611807b79");
pub const IID_IAMGraphBuilderCallback = &IID_IAMGraphBuilderCallback_Value;
pub const IAMGraphBuilderCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SelectedFilter: fn(
            self: *const IAMGraphBuilderCallback,
            pMon: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatedFilter: fn(
            self: *const IAMGraphBuilderCallback,
            pFil: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphBuilderCallback_SelectedFilter(self: *const T, pMon: ?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMGraphBuilderCallback.VTable, self.vtable).SelectedFilter(@ptrCast(*const IAMGraphBuilderCallback, self), pMon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphBuilderCallback_CreatedFilter(self: *const T, pFil: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMGraphBuilderCallback.VTable, self.vtable).CreatedFilter(@ptrCast(*const IAMGraphBuilderCallback, self), pFil);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMFilterGraphCallback_Value = @import("../zig.zig").Guid.initString("56a868fd-0ad4-11ce-b0a3-0020af0ba770");
pub const IID_IAMFilterGraphCallback = &IID_IAMFilterGraphCallback_Value;
pub const IAMFilterGraphCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UnableToRender: fn(
            self: *const IAMFilterGraphCallback,
            pPin: ?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMFilterGraphCallback_UnableToRender(self: *const T, pPin: ?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMFilterGraphCallback.VTable, self.vtable).UnableToRender(@ptrCast(*const IAMFilterGraphCallback, self), pPin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGetCapabilitiesKey_Value = @import("../zig.zig").Guid.initString("a8809222-07bb-48ea-951c-33158100625b");
pub const IID_IGetCapabilitiesKey = &IID_IGetCapabilitiesKey_Value;
pub const IGetCapabilitiesKey = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilitiesKey: fn(
            self: *const IGetCapabilitiesKey,
            pHKey: ?*?HKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetCapabilitiesKey_GetCapabilitiesKey(self: *const T, pHKey: ?*?HKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetCapabilitiesKey.VTable, self.vtable).GetCapabilitiesKey(@ptrCast(*const IGetCapabilitiesKey, self), pHKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEncoderAPI_Value = @import("../zig.zig").Guid.initString("70423839-6acc-4b23-b079-21dbf08156a5");
pub const IID_IEncoderAPI = &IID_IEncoderAPI_Value;
pub const IEncoderAPI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSupported: fn(
            self: *const IEncoderAPI,
            Api: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAvailable: fn(
            self: *const IEncoderAPI,
            Api: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameterRange: fn(
            self: *const IEncoderAPI,
            Api: ?*const Guid,
            ValueMin: ?*VARIANT,
            ValueMax: ?*VARIANT,
            SteppingDelta: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameterValues: fn(
            self: *const IEncoderAPI,
            Api: ?*const Guid,
            Values: [*]?*VARIANT,
            ValuesCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultValue: fn(
            self: *const IEncoderAPI,
            Api: ?*const Guid,
            Value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IEncoderAPI,
            Api: ?*const Guid,
            Value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const IEncoderAPI,
            Api: ?*const Guid,
            Value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_IsSupported(self: *const T, Api: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncoderAPI.VTable, self.vtable).IsSupported(@ptrCast(*const IEncoderAPI, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_IsAvailable(self: *const T, Api: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncoderAPI.VTable, self.vtable).IsAvailable(@ptrCast(*const IEncoderAPI, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_GetParameterRange(self: *const T, Api: ?*const Guid, ValueMin: ?*VARIANT, ValueMax: ?*VARIANT, SteppingDelta: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncoderAPI.VTable, self.vtable).GetParameterRange(@ptrCast(*const IEncoderAPI, self), Api, ValueMin, ValueMax, SteppingDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_GetParameterValues(self: *const T, Api: ?*const Guid, Values: [*]?*VARIANT, ValuesCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncoderAPI.VTable, self.vtable).GetParameterValues(@ptrCast(*const IEncoderAPI, self), Api, Values, ValuesCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_GetDefaultValue(self: *const T, Api: ?*const Guid, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncoderAPI.VTable, self.vtable).GetDefaultValue(@ptrCast(*const IEncoderAPI, self), Api, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_GetValue(self: *const T, Api: ?*const Guid, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncoderAPI.VTable, self.vtable).GetValue(@ptrCast(*const IEncoderAPI, self), Api, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_SetValue(self: *const T, Api: ?*const Guid, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncoderAPI.VTable, self.vtable).SetValue(@ptrCast(*const IEncoderAPI, self), Api, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVideoEncoder_Value = @import("../zig.zig").Guid.initString("02997c3b-8e1b-460e-9270-545e0de9563e");
pub const IID_IVideoEncoder = &IID_IVideoEncoder_Value;
pub const IVideoEncoder = extern struct {
    pub const VTable = extern struct {
        base: IEncoderAPI.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEncoderAPI.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMDecoderCaps_Value = @import("../zig.zig").Guid.initString("c0dff467-d499-4986-972b-e1d9090fa941");
pub const IID_IAMDecoderCaps = &IID_IAMDecoderCaps_Value;
pub const IAMDecoderCaps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecoderCaps: fn(
            self: *const IAMDecoderCaps,
            dwCapIndex: u32,
            lpdwCap: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDecoderCaps_GetDecoderCaps(self: *const T, dwCapIndex: u32, lpdwCap: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDecoderCaps.VTable, self.vtable).GetDecoderCaps(@ptrCast(*const IAMDecoderCaps, self), dwCapIndex, lpdwCap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMCOPPSignature = extern struct {
    Signature: [256]u8,
};

pub const AMCOPPCommand = extern struct {
    macKDI: Guid,
    guidCommandID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    CommandData: [4056]u8,
};

pub const AMCOPPStatusInput = extern struct {
    rApp: Guid,
    guidStatusRequestID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    StatusData: [4056]u8,
};

pub const AMCOPPStatusOutput = extern struct {
    macKDI: Guid,
    cbSizeData: u32,
    COPPStatus: [4076]u8,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMCertifiedOutputProtection_Value = @import("../zig.zig").Guid.initString("6feded3e-0ff1-4901-a2f1-43f7012c8515");
pub const IID_IAMCertifiedOutputProtection = &IID_IAMCertifiedOutputProtection_Value;
pub const IAMCertifiedOutputProtection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        KeyExchange: fn(
            self: *const IAMCertifiedOutputProtection,
            pRandom: ?*Guid,
            VarLenCertGH: ?*?*u8,
            pdwLengthCertGH: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionSequenceStart: fn(
            self: *const IAMCertifiedOutputProtection,
            pSig: ?*AMCOPPSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProtectionCommand: fn(
            self: *const IAMCertifiedOutputProtection,
            cmd: ?*const AMCOPPCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProtectionStatus: fn(
            self: *const IAMCertifiedOutputProtection,
            pStatusInput: ?*const AMCOPPStatusInput,
            pStatusOutput: ?*AMCOPPStatusOutput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCertifiedOutputProtection_KeyExchange(self: *const T, pRandom: ?*Guid, VarLenCertGH: ?*?*u8, pdwLengthCertGH: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCertifiedOutputProtection.VTable, self.vtable).KeyExchange(@ptrCast(*const IAMCertifiedOutputProtection, self), pRandom, VarLenCertGH, pdwLengthCertGH);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCertifiedOutputProtection_SessionSequenceStart(self: *const T, pSig: ?*AMCOPPSignature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCertifiedOutputProtection.VTable, self.vtable).SessionSequenceStart(@ptrCast(*const IAMCertifiedOutputProtection, self), pSig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCertifiedOutputProtection_ProtectionCommand(self: *const T, cmd: ?*const AMCOPPCommand) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCertifiedOutputProtection.VTable, self.vtable).ProtectionCommand(@ptrCast(*const IAMCertifiedOutputProtection, self), cmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCertifiedOutputProtection_ProtectionStatus(self: *const T, pStatusInput: ?*const AMCOPPStatusInput, pStatusOutput: ?*AMCOPPStatusOutput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCertifiedOutputProtection.VTable, self.vtable).ProtectionStatus(@ptrCast(*const IAMCertifiedOutputProtection, self), pStatusInput, pStatusOutput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAMAsyncReaderTimestampScaling_Value = @import("../zig.zig").Guid.initString("cf7b26fc-9a00-485b-8147-3e789d5e8f67");
pub const IID_IAMAsyncReaderTimestampScaling = &IID_IAMAsyncReaderTimestampScaling_Value;
pub const IAMAsyncReaderTimestampScaling = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTimestampMode: fn(
            self: *const IAMAsyncReaderTimestampScaling,
            pfRaw: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimestampMode: fn(
            self: *const IAMAsyncReaderTimestampScaling,
            fRaw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAsyncReaderTimestampScaling_GetTimestampMode(self: *const T, pfRaw: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAsyncReaderTimestampScaling.VTable, self.vtable).GetTimestampMode(@ptrCast(*const IAMAsyncReaderTimestampScaling, self), pfRaw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAsyncReaderTimestampScaling_SetTimestampMode(self: *const T, fRaw: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMAsyncReaderTimestampScaling.VTable, self.vtable).SetTimestampMode(@ptrCast(*const IAMAsyncReaderTimestampScaling, self), fRaw);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAMPluginControl_Value = @import("../zig.zig").Guid.initString("0e26a181-f40c-4635-8786-976284b52981");
pub const IID_IAMPluginControl = &IID_IAMPluginControl_Value;
pub const IAMPluginControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPreferredClsid: fn(
            self: *const IAMPluginControl,
            subType: ?*const Guid,
            clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredClsidByIndex: fn(
            self: *const IAMPluginControl,
            index: u32,
            subType: ?*Guid,
            clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreferredClsid: fn(
            self: *const IAMPluginControl,
            subType: ?*const Guid,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDisabled: fn(
            self: *const IAMPluginControl,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisabledByIndex: fn(
            self: *const IAMPluginControl,
            index: u32,
            clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisabled: fn(
            self: *const IAMPluginControl,
            clsid: ?*const Guid,
            disabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsLegacyDisabled: fn(
            self: *const IAMPluginControl,
            dllName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_GetPreferredClsid(self: *const T, subType: ?*const Guid, clsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPluginControl.VTable, self.vtable).GetPreferredClsid(@ptrCast(*const IAMPluginControl, self), subType, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_GetPreferredClsidByIndex(self: *const T, index: u32, subType: ?*Guid, clsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPluginControl.VTable, self.vtable).GetPreferredClsidByIndex(@ptrCast(*const IAMPluginControl, self), index, subType, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_SetPreferredClsid(self: *const T, subType: ?*const Guid, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPluginControl.VTable, self.vtable).SetPreferredClsid(@ptrCast(*const IAMPluginControl, self), subType, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_IsDisabled(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPluginControl.VTable, self.vtable).IsDisabled(@ptrCast(*const IAMPluginControl, self), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_GetDisabledByIndex(self: *const T, index: u32, clsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPluginControl.VTable, self.vtable).GetDisabledByIndex(@ptrCast(*const IAMPluginControl, self), index, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_SetDisabled(self: *const T, clsid: ?*const Guid, disabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPluginControl.VTable, self.vtable).SetDisabled(@ptrCast(*const IAMPluginControl, self), clsid, disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_IsLegacyDisabled(self: *const T, dllName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPluginControl.VTable, self.vtable).IsLegacyDisabled(@ptrCast(*const IAMPluginControl, self), dllName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPinConnection_Value = @import("../zig.zig").Guid.initString("4a9a62d3-27d4-403d-91e9-89f540e55534");
pub const IID_IPinConnection = &IID_IPinConnection_Value;
pub const IPinConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DynamicQueryAccept: fn(
            self: *const IPinConnection,
            pmt: ?*const AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEndOfStream: fn(
            self: *const IPinConnection,
            hNotifyEvent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEndPin: fn(
            self: *const IPinConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DynamicDisconnect: fn(
            self: *const IPinConnection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinConnection_DynamicQueryAccept(self: *const T, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinConnection.VTable, self.vtable).DynamicQueryAccept(@ptrCast(*const IPinConnection, self), pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinConnection_NotifyEndOfStream(self: *const T, hNotifyEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinConnection.VTable, self.vtable).NotifyEndOfStream(@ptrCast(*const IPinConnection, self), hNotifyEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinConnection_IsEndPin(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinConnection.VTable, self.vtable).IsEndPin(@ptrCast(*const IPinConnection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinConnection_DynamicDisconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinConnection.VTable, self.vtable).DynamicDisconnect(@ptrCast(*const IPinConnection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPinFlowControl_Value = @import("../zig.zig").Guid.initString("c56e9858-dbf3-4f6b-8119-384af2060deb");
pub const IID_IPinFlowControl = &IID_IPinFlowControl_Value;
pub const IPinFlowControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Block: fn(
            self: *const IPinFlowControl,
            dwBlockFlags: u32,
            hEvent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinFlowControl_Block(self: *const T, dwBlockFlags: u32, hEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinFlowControl.VTable, self.vtable).Block(@ptrCast(*const IPinFlowControl, self), dwBlockFlags, hEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS = enum(i32) {
    K = 1,
};
pub const AM_PIN_FLOW_CONTROL_BLOCK = _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS.K;

pub const AM_GRAPH_CONFIG_RECONNECT_FLAGS = enum(i32) {
    DIRECTCONNECT = 1,
    CACHE_REMOVED_FILTERS = 2,
    USE_ONLY_CACHED_FILTERS = 4,
};
pub const AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT = AM_GRAPH_CONFIG_RECONNECT_FLAGS.DIRECTCONNECT;
pub const AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS = AM_GRAPH_CONFIG_RECONNECT_FLAGS.CACHE_REMOVED_FILTERS;
pub const AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS = AM_GRAPH_CONFIG_RECONNECT_FLAGS.USE_ONLY_CACHED_FILTERS;

pub const _REM_FILTER_FLAGS = enum(i32) {
    D = 1,
};
pub const REMFILTERF_LEAVECONNECTED = _REM_FILTER_FLAGS.D;

pub const AM_FILTER_FLAGS = enum(i32) {
    E = 1,
};
pub const AM_FILTER_FLAGS_REMOVABLE = AM_FILTER_FLAGS.E;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGraphConfig_Value = @import("../zig.zig").Guid.initString("03a1eb8e-32bf-4245-8502-114d08a9cb88");
pub const IID_IGraphConfig = &IID_IGraphConfig_Value;
pub const IGraphConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reconnect: fn(
            self: *const IGraphConfig,
            pOutputPin: ?*IPin,
            pInputPin: ?*IPin,
            pmtFirstConnection: ?*const AM_MEDIA_TYPE,
            pUsingFilter: ?*IBaseFilter,
            hAbortEvent: ?HANDLE,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reconfigure: fn(
            self: *const IGraphConfig,
            pCallback: ?*IGraphConfigCallback,
            pvContext: ?*anyopaque,
            dwFlags: u32,
            hAbortEvent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFilterToCache: fn(
            self: *const IGraphConfig,
            pFilter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCacheFilter: fn(
            self: *const IGraphConfig,
            pEnum: ?*?*IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFilterFromCache: fn(
            self: *const IGraphConfig,
            pFilter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartTime: fn(
            self: *const IGraphConfig,
            prtStart: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushThroughData: fn(
            self: *const IGraphConfig,
            pOutputPin: ?*IPin,
            pConnection: ?*IPinConnection,
            hEventAbort: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilterFlags: fn(
            self: *const IGraphConfig,
            pFilter: ?*IBaseFilter,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterFlags: fn(
            self: *const IGraphConfig,
            pFilter: ?*IBaseFilter,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFilterEx: fn(
            self: *const IGraphConfig,
            pFilter: ?*IBaseFilter,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_Reconnect(self: *const T, pOutputPin: ?*IPin, pInputPin: ?*IPin, pmtFirstConnection: ?*const AM_MEDIA_TYPE, pUsingFilter: ?*IBaseFilter, hAbortEvent: ?HANDLE, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).Reconnect(@ptrCast(*const IGraphConfig, self), pOutputPin, pInputPin, pmtFirstConnection, pUsingFilter, hAbortEvent, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_Reconfigure(self: *const T, pCallback: ?*IGraphConfigCallback, pvContext: ?*anyopaque, dwFlags: u32, hAbortEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).Reconfigure(@ptrCast(*const IGraphConfig, self), pCallback, pvContext, dwFlags, hAbortEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_AddFilterToCache(self: *const T, pFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).AddFilterToCache(@ptrCast(*const IGraphConfig, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_EnumCacheFilter(self: *const T, pEnum: ?*?*IEnumFilters) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).EnumCacheFilter(@ptrCast(*const IGraphConfig, self), pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_RemoveFilterFromCache(self: *const T, pFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).RemoveFilterFromCache(@ptrCast(*const IGraphConfig, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_GetStartTime(self: *const T, prtStart: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).GetStartTime(@ptrCast(*const IGraphConfig, self), prtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_PushThroughData(self: *const T, pOutputPin: ?*IPin, pConnection: ?*IPinConnection, hEventAbort: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).PushThroughData(@ptrCast(*const IGraphConfig, self), pOutputPin, pConnection, hEventAbort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_SetFilterFlags(self: *const T, pFilter: ?*IBaseFilter, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).SetFilterFlags(@ptrCast(*const IGraphConfig, self), pFilter, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_GetFilterFlags(self: *const T, pFilter: ?*IBaseFilter, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).GetFilterFlags(@ptrCast(*const IGraphConfig, self), pFilter, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_RemoveFilterEx(self: *const T, pFilter: ?*IBaseFilter, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfig.VTable, self.vtable).RemoveFilterEx(@ptrCast(*const IGraphConfig, self), pFilter, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGraphConfigCallback_Value = @import("../zig.zig").Guid.initString("ade0fd60-d19d-11d2-abf6-00a0c905f375");
pub const IID_IGraphConfigCallback = &IID_IGraphConfigCallback_Value;
pub const IGraphConfigCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reconfigure: fn(
            self: *const IGraphConfigCallback,
            pvContext: ?*anyopaque,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfigCallback_Reconfigure(self: *const T, pvContext: ?*anyopaque, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGraphConfigCallback.VTable, self.vtable).Reconfigure(@ptrCast(*const IGraphConfigCallback, self), pvContext, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFilterChain_Value = @import("../zig.zig").Guid.initString("dcfbdcf6-0dc2-45f5-9ab2-7c330ea09c29");
pub const IID_IFilterChain = &IID_IFilterChain_Value;
pub const IFilterChain = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartChain: fn(
            self: *const IFilterChain,
            pStartFilter: ?*IBaseFilter,
            pEndFilter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseChain: fn(
            self: *const IFilterChain,
            pStartFilter: ?*IBaseFilter,
            pEndFilter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopChain: fn(
            self: *const IFilterChain,
            pStartFilter: ?*IBaseFilter,
            pEndFilter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveChain: fn(
            self: *const IFilterChain,
            pStartFilter: ?*IBaseFilter,
            pEndFilter: ?*IBaseFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterChain_StartChain(self: *const T, pStartFilter: ?*IBaseFilter, pEndFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterChain.VTable, self.vtable).StartChain(@ptrCast(*const IFilterChain, self), pStartFilter, pEndFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterChain_PauseChain(self: *const T, pStartFilter: ?*IBaseFilter, pEndFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterChain.VTable, self.vtable).PauseChain(@ptrCast(*const IFilterChain, self), pStartFilter, pEndFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterChain_StopChain(self: *const T, pStartFilter: ?*IBaseFilter, pEndFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterChain.VTable, self.vtable).StopChain(@ptrCast(*const IFilterChain, self), pStartFilter, pEndFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterChain_RemoveChain(self: *const T, pStartFilter: ?*IBaseFilter, pEndFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterChain.VTable, self.vtable).RemoveChain(@ptrCast(*const IFilterChain, self), pStartFilter, pEndFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRPresentationFlags = enum(i32) {
    SyncPoint = 1,
    Preroll = 2,
    Discontinuity = 4,
    TimeValid = 8,
    SrcDstRectsValid = 16,
};
pub const VMRSample_SyncPoint = VMRPresentationFlags.SyncPoint;
pub const VMRSample_Preroll = VMRPresentationFlags.Preroll;
pub const VMRSample_Discontinuity = VMRPresentationFlags.Discontinuity;
pub const VMRSample_TimeValid = VMRPresentationFlags.TimeValid;
pub const VMRSample_SrcDstRectsValid = VMRPresentationFlags.SrcDstRectsValid;

pub const VMRPRESENTATIONINFO = extern struct {
    dwFlags: u32,
    lpSurf: ?*IDirectDrawSurface7,
    rtStart: i64,
    rtEnd: i64,
    szAspectRatio: SIZE,
    rcSrc: RECT,
    rcDst: RECT,
    dwTypeSpecificFlags: u32,
    dwInterlaceFlags: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenter_Value = @import("../zig.zig").Guid.initString("ce704fe7-e71e-41fb-baa2-c4403e1182f5");
pub const IID_IVMRImagePresenter = &IID_IVMRImagePresenter_Value;
pub const IVMRImagePresenter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartPresenting: fn(
            self: *const IVMRImagePresenter,
            dwUserID: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopPresenting: fn(
            self: *const IVMRImagePresenter,
            dwUserID: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PresentImage: fn(
            self: *const IVMRImagePresenter,
            dwUserID: usize,
            lpPresInfo: ?*VMRPRESENTATIONINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter_StartPresenting(self: *const T, dwUserID: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenter.VTable, self.vtable).StartPresenting(@ptrCast(*const IVMRImagePresenter, self), dwUserID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter_StopPresenting(self: *const T, dwUserID: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenter.VTable, self.vtable).StopPresenting(@ptrCast(*const IVMRImagePresenter, self), dwUserID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter_PresentImage(self: *const T, dwUserID: usize, lpPresInfo: ?*VMRPRESENTATIONINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenter.VTable, self.vtable).PresentImage(@ptrCast(*const IVMRImagePresenter, self), dwUserID, lpPresInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRSurfaceAllocationFlags = enum(i32) {
    PIXELFORMAT_VALID = 1,
    @"3D_TARGET" = 2,
    ALLOW_SYSMEM = 4,
    FORCE_SYSMEM = 8,
    DIRECTED_FLIP = 16,
    DXVA_TARGET = 32,
};
pub const AMAP_PIXELFORMAT_VALID = VMRSurfaceAllocationFlags.PIXELFORMAT_VALID;
pub const AMAP_3D_TARGET = VMRSurfaceAllocationFlags.@"3D_TARGET";
pub const AMAP_ALLOW_SYSMEM = VMRSurfaceAllocationFlags.ALLOW_SYSMEM;
pub const AMAP_FORCE_SYSMEM = VMRSurfaceAllocationFlags.FORCE_SYSMEM;
pub const AMAP_DIRECTED_FLIP = VMRSurfaceAllocationFlags.DIRECTED_FLIP;
pub const AMAP_DXVA_TARGET = VMRSurfaceAllocationFlags.DXVA_TARGET;

pub const VMRALLOCATIONINFO = extern struct {
    dwFlags: u32,
    lpHdr: ?*BITMAPINFOHEADER,
    lpPixFmt: ?*DDPIXELFORMAT,
    szAspectRatio: SIZE,
    dwMinBuffers: u32,
    dwMaxBuffers: u32,
    dwInterlaceFlags: u32,
    szNativeSize: SIZE,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocator_Value = @import("../zig.zig").Guid.initString("31ce832e-4484-458b-8cca-f4d7e3db0b52");
pub const IID_IVMRSurfaceAllocator = &IID_IVMRSurfaceAllocator_Value;
pub const IVMRSurfaceAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllocateSurface: fn(
            self: *const IVMRSurfaceAllocator,
            dwUserID: usize,
            lpAllocInfo: ?*VMRALLOCATIONINFO,
            lpdwActualBuffers: ?*u32,
            lplpSurface: ?*?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeSurface: fn(
            self: *const IVMRSurfaceAllocator,
            dwID: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrepareSurface: fn(
            self: *const IVMRSurfaceAllocator,
            dwUserID: usize,
            lpSurface: ?*IDirectDrawSurface7,
            dwSurfaceFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseNotify: fn(
            self: *const IVMRSurfaceAllocator,
            lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator_AllocateSurface(self: *const T, dwUserID: usize, lpAllocInfo: ?*VMRALLOCATIONINFO, lpdwActualBuffers: ?*u32, lplpSurface: ?*?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocator.VTable, self.vtable).AllocateSurface(@ptrCast(*const IVMRSurfaceAllocator, self), dwUserID, lpAllocInfo, lpdwActualBuffers, lplpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator_FreeSurface(self: *const T, dwID: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocator.VTable, self.vtable).FreeSurface(@ptrCast(*const IVMRSurfaceAllocator, self), dwID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator_PrepareSurface(self: *const T, dwUserID: usize, lpSurface: ?*IDirectDrawSurface7, dwSurfaceFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocator.VTable, self.vtable).PrepareSurface(@ptrCast(*const IVMRSurfaceAllocator, self), dwUserID, lpSurface, dwSurfaceFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator_AdviseNotify(self: *const T, lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocator.VTable, self.vtable).AdviseNotify(@ptrCast(*const IVMRSurfaceAllocator, self), lpIVMRSurfAllocNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocatorNotify_Value = @import("../zig.zig").Guid.initString("aada05a8-5a4e-4729-af0b-cea27aed51e2");
pub const IID_IVMRSurfaceAllocatorNotify = &IID_IVMRSurfaceAllocatorNotify_Value;
pub const IVMRSurfaceAllocatorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSurfaceAllocator: fn(
            self: *const IVMRSurfaceAllocatorNotify,
            dwUserID: usize,
            lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDDrawDevice: fn(
            self: *const IVMRSurfaceAllocatorNotify,
            lpDDrawDevice: ?*IDirectDraw7,
            hMonitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDDrawDevice: fn(
            self: *const IVMRSurfaceAllocatorNotify,
            lpDDrawDevice: ?*IDirectDraw7,
            hMonitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreDDrawSurfaces: fn(
            self: *const IVMRSurfaceAllocatorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEvent: fn(
            self: *const IVMRSurfaceAllocatorNotify,
            EventCode: i32,
            Param1: isize,
            Param2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderColor: fn(
            self: *const IVMRSurfaceAllocatorNotify,
            clrBorder: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_AdviseSurfaceAllocator(self: *const T, dwUserID: usize, lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify.VTable, self.vtable).AdviseSurfaceAllocator(@ptrCast(*const IVMRSurfaceAllocatorNotify, self), dwUserID, lpIVRMSurfaceAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_SetDDrawDevice(self: *const T, lpDDrawDevice: ?*IDirectDraw7, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify.VTable, self.vtable).SetDDrawDevice(@ptrCast(*const IVMRSurfaceAllocatorNotify, self), lpDDrawDevice, hMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_ChangeDDrawDevice(self: *const T, lpDDrawDevice: ?*IDirectDraw7, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify.VTable, self.vtable).ChangeDDrawDevice(@ptrCast(*const IVMRSurfaceAllocatorNotify, self), lpDDrawDevice, hMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_RestoreDDrawSurfaces(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify.VTable, self.vtable).RestoreDDrawSurfaces(@ptrCast(*const IVMRSurfaceAllocatorNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_NotifyEvent(self: *const T, EventCode: i32, Param1: isize, Param2: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify.VTable, self.vtable).NotifyEvent(@ptrCast(*const IVMRSurfaceAllocatorNotify, self), EventCode, Param1, Param2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_SetBorderColor(self: *const T, clrBorder: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify.VTable, self.vtable).SetBorderColor(@ptrCast(*const IVMRSurfaceAllocatorNotify, self), clrBorder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR_ASPECT_RATIO_MODE = enum(i32) {
    NONE = 0,
    LETTER_BOX = 1,
};
pub const VMR_ARMODE_NONE = VMR_ASPECT_RATIO_MODE.NONE;
pub const VMR_ARMODE_LETTER_BOX = VMR_ASPECT_RATIO_MODE.LETTER_BOX;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRWindowlessControl_Value = @import("../zig.zig").Guid.initString("0eb1088c-4dcd-46f0-878f-39dae86a51b7");
pub const IID_IVMRWindowlessControl = &IID_IVMRWindowlessControl_Value;
pub const IVMRWindowlessControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNativeVideoSize: fn(
            self: *const IVMRWindowlessControl,
            lpWidth: ?*i32,
            lpHeight: ?*i32,
            lpARWidth: ?*i32,
            lpARHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinIdealVideoSize: fn(
            self: *const IVMRWindowlessControl,
            lpWidth: ?*i32,
            lpHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxIdealVideoSize: fn(
            self: *const IVMRWindowlessControl,
            lpWidth: ?*i32,
            lpHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoPosition: fn(
            self: *const IVMRWindowlessControl,
            lpSRCRect: ?*const RECT,
            lpDSTRect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPosition: fn(
            self: *const IVMRWindowlessControl,
            lpSRCRect: ?*RECT,
            lpDSTRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatioMode: fn(
            self: *const IVMRWindowlessControl,
            lpAspectRatioMode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: fn(
            self: *const IVMRWindowlessControl,
            AspectRatioMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoClippingWindow: fn(
            self: *const IVMRWindowlessControl,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RepaintVideo: fn(
            self: *const IVMRWindowlessControl,
            hwnd: ?HWND,
            hdc: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayModeChanged: fn(
            self: *const IVMRWindowlessControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentImage: fn(
            self: *const IVMRWindowlessControl,
            lpDib: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderColor: fn(
            self: *const IVMRWindowlessControl,
            Clr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBorderColor: fn(
            self: *const IVMRWindowlessControl,
            lpClr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorKey: fn(
            self: *const IVMRWindowlessControl,
            Clr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorKey: fn(
            self: *const IVMRWindowlessControl,
            lpClr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetNativeVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32, lpARWidth: ?*i32, lpARHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).GetNativeVideoSize(@ptrCast(*const IVMRWindowlessControl, self), lpWidth, lpHeight, lpARWidth, lpARHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetMinIdealVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).GetMinIdealVideoSize(@ptrCast(*const IVMRWindowlessControl, self), lpWidth, lpHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetMaxIdealVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).GetMaxIdealVideoSize(@ptrCast(*const IVMRWindowlessControl, self), lpWidth, lpHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetVideoPosition(self: *const T, lpSRCRect: ?*const RECT, lpDSTRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).SetVideoPosition(@ptrCast(*const IVMRWindowlessControl, self), lpSRCRect, lpDSTRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetVideoPosition(self: *const T, lpSRCRect: ?*RECT, lpDSTRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).GetVideoPosition(@ptrCast(*const IVMRWindowlessControl, self), lpSRCRect, lpDSTRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetAspectRatioMode(self: *const T, lpAspectRatioMode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).GetAspectRatioMode(@ptrCast(*const IVMRWindowlessControl, self), lpAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetAspectRatioMode(self: *const T, AspectRatioMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).SetAspectRatioMode(@ptrCast(*const IVMRWindowlessControl, self), AspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetVideoClippingWindow(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).SetVideoClippingWindow(@ptrCast(*const IVMRWindowlessControl, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_RepaintVideo(self: *const T, hwnd: ?HWND, hdc: ?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).RepaintVideo(@ptrCast(*const IVMRWindowlessControl, self), hwnd, hdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_DisplayModeChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).DisplayModeChanged(@ptrCast(*const IVMRWindowlessControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetCurrentImage(self: *const T, lpDib: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).GetCurrentImage(@ptrCast(*const IVMRWindowlessControl, self), lpDib);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetBorderColor(self: *const T, Clr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).SetBorderColor(@ptrCast(*const IVMRWindowlessControl, self), Clr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetBorderColor(self: *const T, lpClr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).GetBorderColor(@ptrCast(*const IVMRWindowlessControl, self), lpClr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetColorKey(self: *const T, Clr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).SetColorKey(@ptrCast(*const IVMRWindowlessControl, self), Clr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetColorKey(self: *const T, lpClr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl.VTable, self.vtable).GetColorKey(@ptrCast(*const IVMRWindowlessControl, self), lpClr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRMixerPrefs = enum(i32) {
    NoDecimation = 1,
    DecimateOutput = 2,
    ARAdjustXorY = 4,
    DecimationReserved = 8,
    DecimateMask = 15,
    BiLinearFiltering = 16,
    PointFiltering = 32,
    FilteringMask = 240,
    RenderTargetRGB = 256,
    RenderTargetYUV = 4096,
    RenderTargetYUV420 = 512,
    RenderTargetYUV422 = 1024,
    RenderTargetYUV444 = 2048,
    RenderTargetReserved = 57344,
    RenderTargetMask = 65280,
    DynamicSwitchToBOB = 65536,
    DynamicDecimateBy2 = 131072,
    DynamicReserved = 786432,
    DynamicMask = 983040,
};
pub const MixerPref_NoDecimation = VMRMixerPrefs.NoDecimation;
pub const MixerPref_DecimateOutput = VMRMixerPrefs.DecimateOutput;
pub const MixerPref_ARAdjustXorY = VMRMixerPrefs.ARAdjustXorY;
pub const MixerPref_DecimationReserved = VMRMixerPrefs.DecimationReserved;
pub const MixerPref_DecimateMask = VMRMixerPrefs.DecimateMask;
pub const MixerPref_BiLinearFiltering = VMRMixerPrefs.BiLinearFiltering;
pub const MixerPref_PointFiltering = VMRMixerPrefs.PointFiltering;
pub const MixerPref_FilteringMask = VMRMixerPrefs.FilteringMask;
pub const MixerPref_RenderTargetRGB = VMRMixerPrefs.RenderTargetRGB;
pub const MixerPref_RenderTargetYUV = VMRMixerPrefs.RenderTargetYUV;
pub const MixerPref_RenderTargetYUV420 = VMRMixerPrefs.RenderTargetYUV420;
pub const MixerPref_RenderTargetYUV422 = VMRMixerPrefs.RenderTargetYUV422;
pub const MixerPref_RenderTargetYUV444 = VMRMixerPrefs.RenderTargetYUV444;
pub const MixerPref_RenderTargetReserved = VMRMixerPrefs.RenderTargetReserved;
pub const MixerPref_RenderTargetMask = VMRMixerPrefs.RenderTargetMask;
pub const MixerPref_DynamicSwitchToBOB = VMRMixerPrefs.DynamicSwitchToBOB;
pub const MixerPref_DynamicDecimateBy2 = VMRMixerPrefs.DynamicDecimateBy2;
pub const MixerPref_DynamicReserved = VMRMixerPrefs.DynamicReserved;
pub const MixerPref_DynamicMask = VMRMixerPrefs.DynamicMask;

pub const NORMALIZEDRECT = extern struct {
    left: f32,
    top: f32,
    right: f32,
    bottom: f32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerControl_Value = @import("../zig.zig").Guid.initString("1c1a17b0-bed0-415d-974b-dc6696131599");
pub const IID_IVMRMixerControl = &IID_IVMRMixerControl_Value;
pub const IVMRMixerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlpha: fn(
            self: *const IVMRMixerControl,
            dwStreamID: u32,
            Alpha: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlpha: fn(
            self: *const IVMRMixerControl,
            dwStreamID: u32,
            pAlpha: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZOrder: fn(
            self: *const IVMRMixerControl,
            dwStreamID: u32,
            dwZ: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZOrder: fn(
            self: *const IVMRMixerControl,
            dwStreamID: u32,
            pZ: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputRect: fn(
            self: *const IVMRMixerControl,
            dwStreamID: u32,
            pRect: ?*const NORMALIZEDRECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputRect: fn(
            self: *const IVMRMixerControl,
            dwStreamID: u32,
            pRect: ?*NORMALIZEDRECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundClr: fn(
            self: *const IVMRMixerControl,
            ClrBkg: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundClr: fn(
            self: *const IVMRMixerControl,
            lpClrBkg: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMixingPrefs: fn(
            self: *const IVMRMixerControl,
            dwMixerPrefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMixingPrefs: fn(
            self: *const IVMRMixerControl,
            pdwMixerPrefs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetAlpha(self: *const T, dwStreamID: u32, Alpha: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).SetAlpha(@ptrCast(*const IVMRMixerControl, self), dwStreamID, Alpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetAlpha(self: *const T, dwStreamID: u32, pAlpha: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).GetAlpha(@ptrCast(*const IVMRMixerControl, self), dwStreamID, pAlpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetZOrder(self: *const T, dwStreamID: u32, dwZ: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).SetZOrder(@ptrCast(*const IVMRMixerControl, self), dwStreamID, dwZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetZOrder(self: *const T, dwStreamID: u32, pZ: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).GetZOrder(@ptrCast(*const IVMRMixerControl, self), dwStreamID, pZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetOutputRect(self: *const T, dwStreamID: u32, pRect: ?*const NORMALIZEDRECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).SetOutputRect(@ptrCast(*const IVMRMixerControl, self), dwStreamID, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetOutputRect(self: *const T, dwStreamID: u32, pRect: ?*NORMALIZEDRECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).GetOutputRect(@ptrCast(*const IVMRMixerControl, self), dwStreamID, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetBackgroundClr(self: *const T, ClrBkg: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).SetBackgroundClr(@ptrCast(*const IVMRMixerControl, self), ClrBkg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetBackgroundClr(self: *const T, lpClrBkg: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).GetBackgroundClr(@ptrCast(*const IVMRMixerControl, self), lpClrBkg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetMixingPrefs(self: *const T, dwMixerPrefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).SetMixingPrefs(@ptrCast(*const IVMRMixerControl, self), dwMixerPrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetMixingPrefs(self: *const T, pdwMixerPrefs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl.VTable, self.vtable).GetMixingPrefs(@ptrCast(*const IVMRMixerControl, self), pdwMixerPrefs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRGUID = extern struct {
    pGUID: ?*Guid,
    GUID: Guid,
};

pub const VMRMONITORINFO = extern struct {
    guid: VMRGUID,
    rcMonitor: RECT,
    hMon: ?HMONITOR,
    dwFlags: u32,
    szDevice: [32]u16,
    szDescription: [256]u16,
    liDriverVersion: LARGE_INTEGER,
    dwVendorId: u32,
    dwDeviceId: u32,
    dwSubSysId: u32,
    dwRevision: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMonitorConfig_Value = @import("../zig.zig").Guid.initString("9cf0b1b6-fbaa-4b7f-88cf-cf1f130a0dce");
pub const IID_IVMRMonitorConfig = &IID_IVMRMonitorConfig_Value;
pub const IVMRMonitorConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMonitor: fn(
            self: *const IVMRMonitorConfig,
            pGUID: ?*const VMRGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonitor: fn(
            self: *const IVMRMonitorConfig,
            pGUID: ?*VMRGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultMonitor: fn(
            self: *const IVMRMonitorConfig,
            pGUID: ?*const VMRGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultMonitor: fn(
            self: *const IVMRMonitorConfig,
            pGUID: ?*VMRGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableMonitors: fn(
            self: *const IVMRMonitorConfig,
            pInfo: ?*VMRMONITORINFO,
            dwMaxInfoArraySize: u32,
            pdwNumDevices: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_SetMonitor(self: *const T, pGUID: ?*const VMRGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig.VTable, self.vtable).SetMonitor(@ptrCast(*const IVMRMonitorConfig, self), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_GetMonitor(self: *const T, pGUID: ?*VMRGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig.VTable, self.vtable).GetMonitor(@ptrCast(*const IVMRMonitorConfig, self), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_SetDefaultMonitor(self: *const T, pGUID: ?*const VMRGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig.VTable, self.vtable).SetDefaultMonitor(@ptrCast(*const IVMRMonitorConfig, self), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_GetDefaultMonitor(self: *const T, pGUID: ?*VMRGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig.VTable, self.vtable).GetDefaultMonitor(@ptrCast(*const IVMRMonitorConfig, self), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_GetAvailableMonitors(self: *const T, pInfo: ?*VMRMONITORINFO, dwMaxInfoArraySize: u32, pdwNumDevices: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig.VTable, self.vtable).GetAvailableMonitors(@ptrCast(*const IVMRMonitorConfig, self), pInfo, dwMaxInfoArraySize, pdwNumDevices);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRRenderPrefs = enum(i32) {
    RestrictToInitialMonitor = 0,
    ForceOffscreen = 1,
    ForceOverlays = 2,
    // AllowOverlays = 0, this enum value conflicts with RestrictToInitialMonitor
    // AllowOffscreen = 0, this enum value conflicts with RestrictToInitialMonitor
    DoNotRenderColorKeyAndBorder = 8,
    Reserved = 16,
    PreferAGPMemWhenMixing = 32,
    Mask = 63,
};
pub const RenderPrefs_RestrictToInitialMonitor = VMRRenderPrefs.RestrictToInitialMonitor;
pub const RenderPrefs_ForceOffscreen = VMRRenderPrefs.ForceOffscreen;
pub const RenderPrefs_ForceOverlays = VMRRenderPrefs.ForceOverlays;
pub const RenderPrefs_AllowOverlays = VMRRenderPrefs.RestrictToInitialMonitor;
pub const RenderPrefs_AllowOffscreen = VMRRenderPrefs.RestrictToInitialMonitor;
pub const RenderPrefs_DoNotRenderColorKeyAndBorder = VMRRenderPrefs.DoNotRenderColorKeyAndBorder;
pub const RenderPrefs_Reserved = VMRRenderPrefs.Reserved;
pub const RenderPrefs_PreferAGPMemWhenMixing = VMRRenderPrefs.PreferAGPMemWhenMixing;
pub const RenderPrefs_Mask = VMRRenderPrefs.Mask;

pub const VMRMode = enum(i32) {
    Windowed = 1,
    Windowless = 2,
    Renderless = 4,
    Mask = 7,
};
pub const VMRMode_Windowed = VMRMode.Windowed;
pub const VMRMode_Windowless = VMRMode.Windowless;
pub const VMRMode_Renderless = VMRMode.Renderless;
pub const VMRMode_Mask = VMRMode.Mask;

pub const STREAMIF_CONSTANTS = enum(i32) {
    S = 16,
};
pub const MAX_NUMBER_OF_STREAMS = STREAMIF_CONSTANTS.S;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRFilterConfig_Value = @import("../zig.zig").Guid.initString("9e5530c5-7034-48b4-bb46-0b8a6efc8e36");
pub const IID_IVMRFilterConfig = &IID_IVMRFilterConfig_Value;
pub const IVMRFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetImageCompositor: fn(
            self: *const IVMRFilterConfig,
            lpVMRImgCompositor: ?*IVMRImageCompositor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNumberOfStreams: fn(
            self: *const IVMRFilterConfig,
            dwMaxStreams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfStreams: fn(
            self: *const IVMRFilterConfig,
            pdwMaxStreams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingPrefs: fn(
            self: *const IVMRFilterConfig,
            dwRenderFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingPrefs: fn(
            self: *const IVMRFilterConfig,
            pdwRenderFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingMode: fn(
            self: *const IVMRFilterConfig,
            Mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingMode: fn(
            self: *const IVMRFilterConfig,
            pMode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_SetImageCompositor(self: *const T, lpVMRImgCompositor: ?*IVMRImageCompositor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig.VTable, self.vtable).SetImageCompositor(@ptrCast(*const IVMRFilterConfig, self), lpVMRImgCompositor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_SetNumberOfStreams(self: *const T, dwMaxStreams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig.VTable, self.vtable).SetNumberOfStreams(@ptrCast(*const IVMRFilterConfig, self), dwMaxStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_GetNumberOfStreams(self: *const T, pdwMaxStreams: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig.VTable, self.vtable).GetNumberOfStreams(@ptrCast(*const IVMRFilterConfig, self), pdwMaxStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig.VTable, self.vtable).SetRenderingPrefs(@ptrCast(*const IVMRFilterConfig, self), dwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_GetRenderingPrefs(self: *const T, pdwRenderFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig.VTable, self.vtable).GetRenderingPrefs(@ptrCast(*const IVMRFilterConfig, self), pdwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_SetRenderingMode(self: *const T, Mode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig.VTable, self.vtable).SetRenderingMode(@ptrCast(*const IVMRFilterConfig, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_GetRenderingMode(self: *const T, pMode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig.VTable, self.vtable).GetRenderingMode(@ptrCast(*const IVMRFilterConfig, self), pMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRAspectRatioControl_Value = @import("../zig.zig").Guid.initString("ede80b5c-bad6-4623-b537-65586c9f8dfd");
pub const IID_IVMRAspectRatioControl = &IID_IVMRAspectRatioControl_Value;
pub const IVMRAspectRatioControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAspectRatioMode: fn(
            self: *const IVMRAspectRatioControl,
            lpdwARMode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: fn(
            self: *const IVMRAspectRatioControl,
            dwARMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRAspectRatioControl_GetAspectRatioMode(self: *const T, lpdwARMode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRAspectRatioControl.VTable, self.vtable).GetAspectRatioMode(@ptrCast(*const IVMRAspectRatioControl, self), lpdwARMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRAspectRatioControl_SetAspectRatioMode(self: *const T, dwARMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRAspectRatioControl.VTable, self.vtable).SetAspectRatioMode(@ptrCast(*const IVMRAspectRatioControl, self), dwARMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRDeinterlacePrefs = enum(i32) {
    NextBest = 1,
    BOB = 2,
    Weave = 4,
    Mask = 7,
};
pub const DeinterlacePref_NextBest = VMRDeinterlacePrefs.NextBest;
pub const DeinterlacePref_BOB = VMRDeinterlacePrefs.BOB;
pub const DeinterlacePref_Weave = VMRDeinterlacePrefs.Weave;
pub const DeinterlacePref_Mask = VMRDeinterlacePrefs.Mask;

pub const VMRDeinterlaceTech = enum(i32) {
    Unknown = 0,
    BOBLineReplicate = 1,
    BOBVerticalStretch = 2,
    MedianFiltering = 4,
    EdgeFiltering = 16,
    FieldAdaptive = 32,
    PixelAdaptive = 64,
    MotionVectorSteered = 128,
};
pub const DeinterlaceTech_Unknown = VMRDeinterlaceTech.Unknown;
pub const DeinterlaceTech_BOBLineReplicate = VMRDeinterlaceTech.BOBLineReplicate;
pub const DeinterlaceTech_BOBVerticalStretch = VMRDeinterlaceTech.BOBVerticalStretch;
pub const DeinterlaceTech_MedianFiltering = VMRDeinterlaceTech.MedianFiltering;
pub const DeinterlaceTech_EdgeFiltering = VMRDeinterlaceTech.EdgeFiltering;
pub const DeinterlaceTech_FieldAdaptive = VMRDeinterlaceTech.FieldAdaptive;
pub const DeinterlaceTech_PixelAdaptive = VMRDeinterlaceTech.PixelAdaptive;
pub const DeinterlaceTech_MotionVectorSteered = VMRDeinterlaceTech.MotionVectorSteered;

pub const VMRFrequency = extern struct {
    dwNumerator: u32,
    dwDenominator: u32,
};

pub const VMRVideoDesc = extern struct {
    dwSize: u32,
    dwSampleWidth: u32,
    dwSampleHeight: u32,
    SingleFieldPerSample: BOOL,
    dwFourCC: u32,
    InputSampleFreq: VMRFrequency,
    OutputFrameFreq: VMRFrequency,
};

pub const VMRDeinterlaceCaps = extern struct {
    dwSize: u32,
    dwNumPreviousOutputFrames: u32,
    dwNumForwardRefSamples: u32,
    dwNumBackwardRefSamples: u32,
    DeinterlaceTechnology: VMRDeinterlaceTech,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRDeinterlaceControl_Value = @import("../zig.zig").Guid.initString("bb057577-0db8-4e6a-87a7-1a8c9a505a0f");
pub const IID_IVMRDeinterlaceControl = &IID_IVMRDeinterlaceControl_Value;
pub const IVMRDeinterlaceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfDeinterlaceModes: fn(
            self: *const IVMRDeinterlaceControl,
            lpVideoDescription: ?*VMRVideoDesc,
            lpdwNumDeinterlaceModes: ?*u32,
            lpDeinterlaceModes: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceModeCaps: fn(
            self: *const IVMRDeinterlaceControl,
            lpDeinterlaceMode: ?*Guid,
            lpVideoDescription: ?*VMRVideoDesc,
            lpDeinterlaceCaps: ?*VMRDeinterlaceCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceMode: fn(
            self: *const IVMRDeinterlaceControl,
            dwStreamID: u32,
            lpDeinterlaceMode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeinterlaceMode: fn(
            self: *const IVMRDeinterlaceControl,
            dwStreamID: u32,
            lpDeinterlaceMode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlacePrefs: fn(
            self: *const IVMRDeinterlaceControl,
            lpdwDeinterlacePrefs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeinterlacePrefs: fn(
            self: *const IVMRDeinterlaceControl,
            dwDeinterlacePrefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualDeinterlaceMode: fn(
            self: *const IVMRDeinterlaceControl,
            dwStreamID: u32,
            lpDeinterlaceMode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetNumberOfDeinterlaceModes(self: *const T, lpVideoDescription: ?*VMRVideoDesc, lpdwNumDeinterlaceModes: ?*u32, lpDeinterlaceModes: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl.VTable, self.vtable).GetNumberOfDeinterlaceModes(@ptrCast(*const IVMRDeinterlaceControl, self), lpVideoDescription, lpdwNumDeinterlaceModes, lpDeinterlaceModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetDeinterlaceModeCaps(self: *const T, lpDeinterlaceMode: ?*Guid, lpVideoDescription: ?*VMRVideoDesc, lpDeinterlaceCaps: ?*VMRDeinterlaceCaps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl.VTable, self.vtable).GetDeinterlaceModeCaps(@ptrCast(*const IVMRDeinterlaceControl, self), lpDeinterlaceMode, lpVideoDescription, lpDeinterlaceCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl.VTable, self.vtable).GetDeinterlaceMode(@ptrCast(*const IVMRDeinterlaceControl, self), dwStreamID, lpDeinterlaceMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_SetDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl.VTable, self.vtable).SetDeinterlaceMode(@ptrCast(*const IVMRDeinterlaceControl, self), dwStreamID, lpDeinterlaceMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetDeinterlacePrefs(self: *const T, lpdwDeinterlacePrefs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl.VTable, self.vtable).GetDeinterlacePrefs(@ptrCast(*const IVMRDeinterlaceControl, self), lpdwDeinterlacePrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_SetDeinterlacePrefs(self: *const T, dwDeinterlacePrefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl.VTable, self.vtable).SetDeinterlacePrefs(@ptrCast(*const IVMRDeinterlaceControl, self), dwDeinterlacePrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetActualDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl.VTable, self.vtable).GetActualDeinterlaceMode(@ptrCast(*const IVMRDeinterlaceControl, self), dwStreamID, lpDeinterlaceMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRALPHABITMAP = extern struct {
    dwFlags: u32,
    hdc: ?HDC,
    pDDS: ?*IDirectDrawSurface7,
    rSrc: RECT,
    rDest: NORMALIZEDRECT,
    fAlpha: f32,
    clrSrcKey: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerBitmap_Value = @import("../zig.zig").Guid.initString("1e673275-0257-40aa-af20-7c608d4a0428");
pub const IID_IVMRMixerBitmap = &IID_IVMRMixerBitmap_Value;
pub const IVMRMixerBitmap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlphaBitmap: fn(
            self: *const IVMRMixerBitmap,
            pBmpParms: ?*const VMRALPHABITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAlphaBitmapParameters: fn(
            self: *const IVMRMixerBitmap,
            pBmpParms: ?*VMRALPHABITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlphaBitmapParameters: fn(
            self: *const IVMRMixerBitmap,
            pBmpParms: ?*VMRALPHABITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap_SetAlphaBitmap(self: *const T, pBmpParms: ?*const VMRALPHABITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerBitmap.VTable, self.vtable).SetAlphaBitmap(@ptrCast(*const IVMRMixerBitmap, self), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap_UpdateAlphaBitmapParameters(self: *const T, pBmpParms: ?*VMRALPHABITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerBitmap.VTable, self.vtable).UpdateAlphaBitmapParameters(@ptrCast(*const IVMRMixerBitmap, self), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap_GetAlphaBitmapParameters(self: *const T, pBmpParms: ?*VMRALPHABITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerBitmap.VTable, self.vtable).GetAlphaBitmapParameters(@ptrCast(*const IVMRMixerBitmap, self), pBmpParms);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRVIDEOSTREAMINFO = extern struct {
    pddsVideoSurface: ?*IDirectDrawSurface7,
    dwWidth: u32,
    dwHeight: u32,
    dwStrmID: u32,
    fAlpha: f32,
    ddClrKey: DDCOLORKEY,
    rNormal: NORMALIZEDRECT,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImageCompositor_Value = @import("../zig.zig").Guid.initString("7a4fb5af-479f-4074-bb40-ce6722e43c82");
pub const IID_IVMRImageCompositor = &IID_IVMRImageCompositor_Value;
pub const IVMRImageCompositor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitCompositionTarget: fn(
            self: *const IVMRImageCompositor,
            pD3DDevice: ?*IUnknown,
            pddsRenderTarget: ?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TermCompositionTarget: fn(
            self: *const IVMRImageCompositor,
            pD3DDevice: ?*IUnknown,
            pddsRenderTarget: ?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamMediaType: fn(
            self: *const IVMRImageCompositor,
            dwStrmID: u32,
            pmt: ?*AM_MEDIA_TYPE,
            fTexture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompositeImage: fn(
            self: *const IVMRImageCompositor,
            pD3DDevice: ?*IUnknown,
            pddsRenderTarget: ?*IDirectDrawSurface7,
            pmtRenderTarget: ?*AM_MEDIA_TYPE,
            rtStart: i64,
            rtEnd: i64,
            dwClrBkGnd: u32,
            pVideoStreamInfo: ?*VMRVIDEOSTREAMINFO,
            cStreams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor_InitCompositionTarget(self: *const T, pD3DDevice: ?*IUnknown, pddsRenderTarget: ?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImageCompositor.VTable, self.vtable).InitCompositionTarget(@ptrCast(*const IVMRImageCompositor, self), pD3DDevice, pddsRenderTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor_TermCompositionTarget(self: *const T, pD3DDevice: ?*IUnknown, pddsRenderTarget: ?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImageCompositor.VTable, self.vtable).TermCompositionTarget(@ptrCast(*const IVMRImageCompositor, self), pD3DDevice, pddsRenderTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor_SetStreamMediaType(self: *const T, dwStrmID: u32, pmt: ?*AM_MEDIA_TYPE, fTexture: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImageCompositor.VTable, self.vtable).SetStreamMediaType(@ptrCast(*const IVMRImageCompositor, self), dwStrmID, pmt, fTexture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor_CompositeImage(self: *const T, pD3DDevice: ?*IUnknown, pddsRenderTarget: ?*IDirectDrawSurface7, pmtRenderTarget: ?*AM_MEDIA_TYPE, rtStart: i64, rtEnd: i64, dwClrBkGnd: u32, pVideoStreamInfo: ?*VMRVIDEOSTREAMINFO, cStreams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImageCompositor.VTable, self.vtable).CompositeImage(@ptrCast(*const IVMRImageCompositor, self), pD3DDevice, pddsRenderTarget, pmtRenderTarget, rtStart, rtEnd, dwClrBkGnd, pVideoStreamInfo, cStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRVideoStreamControl_Value = @import("../zig.zig").Guid.initString("058d1f11-2a54-4bef-bd54-df706626b727");
pub const IID_IVMRVideoStreamControl = &IID_IVMRVideoStreamControl_Value;
pub const IVMRVideoStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColorKey: fn(
            self: *const IVMRVideoStreamControl,
            lpClrKey: ?*DDCOLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorKey: fn(
            self: *const IVMRVideoStreamControl,
            lpClrKey: ?*DDCOLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamActiveState: fn(
            self: *const IVMRVideoStreamControl,
            fActive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamActiveState: fn(
            self: *const IVMRVideoStreamControl,
            lpfActive: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl_SetColorKey(self: *const T, lpClrKey: ?*DDCOLORKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRVideoStreamControl.VTable, self.vtable).SetColorKey(@ptrCast(*const IVMRVideoStreamControl, self), lpClrKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl_GetColorKey(self: *const T, lpClrKey: ?*DDCOLORKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRVideoStreamControl.VTable, self.vtable).GetColorKey(@ptrCast(*const IVMRVideoStreamControl, self), lpClrKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl_SetStreamActiveState(self: *const T, fActive: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRVideoStreamControl.VTable, self.vtable).SetStreamActiveState(@ptrCast(*const IVMRVideoStreamControl, self), fActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl_GetStreamActiveState(self: *const T, lpfActive: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRVideoStreamControl.VTable, self.vtable).GetStreamActiveState(@ptrCast(*const IVMRVideoStreamControl, self), lpfActive);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurface_Value = @import("../zig.zig").Guid.initString("a9849bbe-9ec8-4263-b764-62730f0d15d0");
pub const IID_IVMRSurface = &IID_IVMRSurface_Value;
pub const IVMRSurface = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSurfaceLocked: fn(
            self: *const IVMRSurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockSurface: fn(
            self: *const IVMRSurface,
            lpSurface: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockSurface: fn(
            self: *const IVMRSurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurface: fn(
            self: *const IVMRSurface,
            lplpSurface: ?*?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface_IsSurfaceLocked(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurface.VTable, self.vtable).IsSurfaceLocked(@ptrCast(*const IVMRSurface, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface_LockSurface(self: *const T, lpSurface: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurface.VTable, self.vtable).LockSurface(@ptrCast(*const IVMRSurface, self), lpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface_UnlockSurface(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurface.VTable, self.vtable).UnlockSurface(@ptrCast(*const IVMRSurface, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface_GetSurface(self: *const T, lplpSurface: ?*?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurface.VTable, self.vtable).GetSurface(@ptrCast(*const IVMRSurface, self), lplpSurface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenterConfig_Value = @import("../zig.zig").Guid.initString("9f3a1c85-8555-49ba-935f-be5b5b29d178");
pub const IID_IVMRImagePresenterConfig = &IID_IVMRImagePresenterConfig_Value;
pub const IVMRImagePresenterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRenderingPrefs: fn(
            self: *const IVMRImagePresenterConfig,
            dwRenderFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingPrefs: fn(
            self: *const IVMRImagePresenterConfig,
            dwRenderFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterConfig_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenterConfig.VTable, self.vtable).SetRenderingPrefs(@ptrCast(*const IVMRImagePresenterConfig, self), dwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterConfig_GetRenderingPrefs(self: *const T, dwRenderFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenterConfig.VTable, self.vtable).GetRenderingPrefs(@ptrCast(*const IVMRImagePresenterConfig, self), dwRenderFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenterExclModeConfig_Value = @import("../zig.zig").Guid.initString("e6f7ce40-4673-44f1-8f77-5499d68cb4ea");
pub const IID_IVMRImagePresenterExclModeConfig = &IID_IVMRImagePresenterExclModeConfig_Value;
pub const IVMRImagePresenterExclModeConfig = extern struct {
    pub const VTable = extern struct {
        base: IVMRImagePresenterConfig.VTable,
        SetXlcModeDDObjAndPrimarySurface: fn(
            self: *const IVMRImagePresenterExclModeConfig,
            lpDDObj: ?*IDirectDraw7,
            lpPrimarySurf: ?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXlcModeDDObjAndPrimarySurface: fn(
            self: *const IVMRImagePresenterExclModeConfig,
            lpDDObj: ?*?*IDirectDraw7,
            lpPrimarySurf: ?*?*IDirectDrawSurface7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVMRImagePresenterConfig.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterExclModeConfig_SetXlcModeDDObjAndPrimarySurface(self: *const T, lpDDObj: ?*IDirectDraw7, lpPrimarySurf: ?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenterExclModeConfig.VTable, self.vtable).SetXlcModeDDObjAndPrimarySurface(@ptrCast(*const IVMRImagePresenterExclModeConfig, self), lpDDObj, lpPrimarySurf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterExclModeConfig_GetXlcModeDDObjAndPrimarySurface(self: *const T, lpDDObj: ?*?*IDirectDraw7, lpPrimarySurf: ?*?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenterExclModeConfig.VTable, self.vtable).GetXlcModeDDObjAndPrimarySurface(@ptrCast(*const IVMRImagePresenterExclModeConfig, self), lpDDObj, lpPrimarySurf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVPManager_Value = @import("../zig.zig").Guid.initString("aac18c18-e186-46d2-825d-a1f8dc8e395a");
pub const IID_IVPManager = &IID_IVPManager_Value;
pub const IVPManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetVideoPortIndex: fn(
            self: *const IVPManager,
            dwVideoPortIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPortIndex: fn(
            self: *const IVPManager,
            pdwVideoPortIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPManager_SetVideoPortIndex(self: *const T, dwVideoPortIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPManager.VTable, self.vtable).SetVideoPortIndex(@ptrCast(*const IVPManager, self), dwVideoPortIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPManager_GetVideoPortIndex(self: *const T, pdwVideoPortIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPManager.VTable, self.vtable).GetVideoPortIndex(@ptrCast(*const IVPManager, self), pdwVideoPortIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVD_DOMAIN = enum(i32) {
    FirstPlay = 1,
    VideoManagerMenu = 2,
    VideoTitleSetMenu = 3,
    Title = 4,
    Stop = 5,
};
pub const DVD_DOMAIN_FirstPlay = DVD_DOMAIN.FirstPlay;
pub const DVD_DOMAIN_VideoManagerMenu = DVD_DOMAIN.VideoManagerMenu;
pub const DVD_DOMAIN_VideoTitleSetMenu = DVD_DOMAIN.VideoTitleSetMenu;
pub const DVD_DOMAIN_Title = DVD_DOMAIN.Title;
pub const DVD_DOMAIN_Stop = DVD_DOMAIN.Stop;

pub const DVD_MENU_ID = enum(i32) {
    Title = 2,
    Root = 3,
    Subpicture = 4,
    Audio = 5,
    Angle = 6,
    Chapter = 7,
};
pub const DVD_MENU_Title = DVD_MENU_ID.Title;
pub const DVD_MENU_Root = DVD_MENU_ID.Root;
pub const DVD_MENU_Subpicture = DVD_MENU_ID.Subpicture;
pub const DVD_MENU_Audio = DVD_MENU_ID.Audio;
pub const DVD_MENU_Angle = DVD_MENU_ID.Angle;
pub const DVD_MENU_Chapter = DVD_MENU_ID.Chapter;

pub const DVD_DISC_SIDE = enum(i32) {
    A = 1,
    B = 2,
};
pub const DVD_SIDE_A = DVD_DISC_SIDE.A;
pub const DVD_SIDE_B = DVD_DISC_SIDE.B;

pub const DVD_PREFERRED_DISPLAY_MODE = enum(i32) {
    CONTENT_DEFAULT = 0,
    @"16x9" = 1,
    @"4x3_PANSCAN_PREFERRED" = 2,
    @"4x3_LETTERBOX_PREFERRED" = 3,
};
pub const DISPLAY_CONTENT_DEFAULT = DVD_PREFERRED_DISPLAY_MODE.CONTENT_DEFAULT;
pub const DISPLAY_16x9 = DVD_PREFERRED_DISPLAY_MODE.@"16x9";
pub const DISPLAY_4x3_PANSCAN_PREFERRED = DVD_PREFERRED_DISPLAY_MODE.@"4x3_PANSCAN_PREFERRED";
pub const DISPLAY_4x3_LETTERBOX_PREFERRED = DVD_PREFERRED_DISPLAY_MODE.@"4x3_LETTERBOX_PREFERRED";

pub const DVD_ATR = extern struct {
    ulCAT: u32,
    pbATRI: [768]u8,
};

pub const DVD_FRAMERATE = enum(i32) {
    @"25" = 1,
    @"30NonDrop" = 3,
};
pub const DVD_FPS_25 = DVD_FRAMERATE.@"25";
pub const DVD_FPS_30NonDrop = DVD_FRAMERATE.@"30NonDrop";

pub const DVD_TIMECODE = extern struct {
    _bitfield: u32,
};

pub const DVD_NavCmdType = enum(i32) {
    Pre = 1,
    Post = 2,
    Cell = 3,
    Button = 4,
};
pub const DVD_NavCmdType_Pre = DVD_NavCmdType.Pre;
pub const DVD_NavCmdType_Post = DVD_NavCmdType.Post;
pub const DVD_NavCmdType_Cell = DVD_NavCmdType.Cell;
pub const DVD_NavCmdType_Button = DVD_NavCmdType.Button;

pub const DVD_TIMECODE_FLAGS = enum(i32) {
    @"25fps" = 1,
    @"30fps" = 2,
    DropFrame = 4,
    Interpolated = 8,
};
pub const DVD_TC_FLAG_25fps = DVD_TIMECODE_FLAGS.@"25fps";
pub const DVD_TC_FLAG_30fps = DVD_TIMECODE_FLAGS.@"30fps";
pub const DVD_TC_FLAG_DropFrame = DVD_TIMECODE_FLAGS.DropFrame;
pub const DVD_TC_FLAG_Interpolated = DVD_TIMECODE_FLAGS.Interpolated;

pub const DVD_HMSF_TIMECODE = extern struct {
    bHours: u8,
    bMinutes: u8,
    bSeconds: u8,
    bFrames: u8,
};

pub const DVD_PLAYBACK_LOCATION2 = extern struct {
    TitleNum: u32,
    ChapterNum: u32,
    TimeCode: DVD_HMSF_TIMECODE,
    TimeCodeFlags: u32,
};

pub const DVD_PLAYBACK_LOCATION = extern struct {
    TitleNum: u32,
    ChapterNum: u32,
    TimeCode: u32,
};

pub const VALID_UOP_FLAG = enum(i32) {
    Play_Title_Or_AtTime = 1,
    Play_Chapter = 2,
    Play_Title = 4,
    Stop = 8,
    ReturnFromSubMenu = 16,
    Play_Chapter_Or_AtTime = 32,
    PlayPrev_Or_Replay_Chapter = 64,
    PlayNext_Chapter = 128,
    Play_Forwards = 256,
    Play_Backwards = 512,
    ShowMenu_Title = 1024,
    ShowMenu_Root = 2048,
    ShowMenu_SubPic = 4096,
    ShowMenu_Audio = 8192,
    ShowMenu_Angle = 16384,
    ShowMenu_Chapter = 32768,
    Resume = 65536,
    Select_Or_Activate_Button = 131072,
    Still_Off = 262144,
    Pause_On = 524288,
    Select_Audio_Stream = 1048576,
    Select_SubPic_Stream = 2097152,
    Select_Angle = 4194304,
    Select_Karaoke_Audio_Presentation_Mode = 8388608,
    Select_Video_Mode_Preference = 16777216,
};
pub const UOP_FLAG_Play_Title_Or_AtTime = VALID_UOP_FLAG.Play_Title_Or_AtTime;
pub const UOP_FLAG_Play_Chapter = VALID_UOP_FLAG.Play_Chapter;
pub const UOP_FLAG_Play_Title = VALID_UOP_FLAG.Play_Title;
pub const UOP_FLAG_Stop = VALID_UOP_FLAG.Stop;
pub const UOP_FLAG_ReturnFromSubMenu = VALID_UOP_FLAG.ReturnFromSubMenu;
pub const UOP_FLAG_Play_Chapter_Or_AtTime = VALID_UOP_FLAG.Play_Chapter_Or_AtTime;
pub const UOP_FLAG_PlayPrev_Or_Replay_Chapter = VALID_UOP_FLAG.PlayPrev_Or_Replay_Chapter;
pub const UOP_FLAG_PlayNext_Chapter = VALID_UOP_FLAG.PlayNext_Chapter;
pub const UOP_FLAG_Play_Forwards = VALID_UOP_FLAG.Play_Forwards;
pub const UOP_FLAG_Play_Backwards = VALID_UOP_FLAG.Play_Backwards;
pub const UOP_FLAG_ShowMenu_Title = VALID_UOP_FLAG.ShowMenu_Title;
pub const UOP_FLAG_ShowMenu_Root = VALID_UOP_FLAG.ShowMenu_Root;
pub const UOP_FLAG_ShowMenu_SubPic = VALID_UOP_FLAG.ShowMenu_SubPic;
pub const UOP_FLAG_ShowMenu_Audio = VALID_UOP_FLAG.ShowMenu_Audio;
pub const UOP_FLAG_ShowMenu_Angle = VALID_UOP_FLAG.ShowMenu_Angle;
pub const UOP_FLAG_ShowMenu_Chapter = VALID_UOP_FLAG.ShowMenu_Chapter;
pub const UOP_FLAG_Resume = VALID_UOP_FLAG.Resume;
pub const UOP_FLAG_Select_Or_Activate_Button = VALID_UOP_FLAG.Select_Or_Activate_Button;
pub const UOP_FLAG_Still_Off = VALID_UOP_FLAG.Still_Off;
pub const UOP_FLAG_Pause_On = VALID_UOP_FLAG.Pause_On;
pub const UOP_FLAG_Select_Audio_Stream = VALID_UOP_FLAG.Select_Audio_Stream;
pub const UOP_FLAG_Select_SubPic_Stream = VALID_UOP_FLAG.Select_SubPic_Stream;
pub const UOP_FLAG_Select_Angle = VALID_UOP_FLAG.Select_Angle;
pub const UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode = VALID_UOP_FLAG.Select_Karaoke_Audio_Presentation_Mode;
pub const UOP_FLAG_Select_Video_Mode_Preference = VALID_UOP_FLAG.Select_Video_Mode_Preference;

pub const DVD_CMD_FLAGS = enum(i32) {
    None = 0,
    Flush = 1,
    SendEvents = 2,
    Block = 4,
    StartWhenRendered = 8,
    EndAfterRendered = 16,
};
pub const DVD_CMD_FLAG_None = DVD_CMD_FLAGS.None;
pub const DVD_CMD_FLAG_Flush = DVD_CMD_FLAGS.Flush;
pub const DVD_CMD_FLAG_SendEvents = DVD_CMD_FLAGS.SendEvents;
pub const DVD_CMD_FLAG_Block = DVD_CMD_FLAGS.Block;
pub const DVD_CMD_FLAG_StartWhenRendered = DVD_CMD_FLAGS.StartWhenRendered;
pub const DVD_CMD_FLAG_EndAfterRendered = DVD_CMD_FLAGS.EndAfterRendered;

pub const DVD_OPTION_FLAG = enum(i32) {
    ResetOnStop = 1,
    NotifyParentalLevelChange = 2,
    HMSF_TimeCodeEvents = 3,
    AudioDuringFFwdRew = 4,
    EnableNonblockingAPIs = 5,
    CacheSizeInMB = 6,
    EnablePortableBookmarks = 7,
    EnableExtendedCopyProtectErrors = 8,
    NotifyPositionChange = 9,
    IncreaseOutputControl = 10,
    EnableStreaming = 11,
    EnableESOutput = 12,
    EnableTitleLength = 13,
    DisableStillThrottle = 14,
    EnableLoggingEvents = 15,
    MaxReadBurstInKB = 16,
    ReadBurstPeriodInMS = 17,
    RestartDisc = 18,
    EnableCC = 19,
};
pub const DVD_ResetOnStop = DVD_OPTION_FLAG.ResetOnStop;
pub const DVD_NotifyParentalLevelChange = DVD_OPTION_FLAG.NotifyParentalLevelChange;
pub const DVD_HMSF_TimeCodeEvents = DVD_OPTION_FLAG.HMSF_TimeCodeEvents;
pub const DVD_AudioDuringFFwdRew = DVD_OPTION_FLAG.AudioDuringFFwdRew;
pub const DVD_EnableNonblockingAPIs = DVD_OPTION_FLAG.EnableNonblockingAPIs;
pub const DVD_CacheSizeInMB = DVD_OPTION_FLAG.CacheSizeInMB;
pub const DVD_EnablePortableBookmarks = DVD_OPTION_FLAG.EnablePortableBookmarks;
pub const DVD_EnableExtendedCopyProtectErrors = DVD_OPTION_FLAG.EnableExtendedCopyProtectErrors;
pub const DVD_NotifyPositionChange = DVD_OPTION_FLAG.NotifyPositionChange;
pub const DVD_IncreaseOutputControl = DVD_OPTION_FLAG.IncreaseOutputControl;
pub const DVD_EnableStreaming = DVD_OPTION_FLAG.EnableStreaming;
pub const DVD_EnableESOutput = DVD_OPTION_FLAG.EnableESOutput;
pub const DVD_EnableTitleLength = DVD_OPTION_FLAG.EnableTitleLength;
pub const DVD_DisableStillThrottle = DVD_OPTION_FLAG.DisableStillThrottle;
pub const DVD_EnableLoggingEvents = DVD_OPTION_FLAG.EnableLoggingEvents;
pub const DVD_MaxReadBurstInKB = DVD_OPTION_FLAG.MaxReadBurstInKB;
pub const DVD_ReadBurstPeriodInMS = DVD_OPTION_FLAG.ReadBurstPeriodInMS;
pub const DVD_RestartDisc = DVD_OPTION_FLAG.RestartDisc;
pub const DVD_EnableCC = DVD_OPTION_FLAG.EnableCC;

pub const DVD_RELATIVE_BUTTON = enum(i32) {
    Upper = 1,
    Lower = 2,
    Left = 3,
    Right = 4,
};
pub const DVD_Relative_Upper = DVD_RELATIVE_BUTTON.Upper;
pub const DVD_Relative_Lower = DVD_RELATIVE_BUTTON.Lower;
pub const DVD_Relative_Left = DVD_RELATIVE_BUTTON.Left;
pub const DVD_Relative_Right = DVD_RELATIVE_BUTTON.Right;

pub const DVD_PARENTAL_LEVEL = enum(i32) {
    @"8" = 32768,
    @"7" = 16384,
    @"6" = 8192,
    @"5" = 4096,
    @"4" = 2048,
    @"3" = 1024,
    @"2" = 512,
    @"1" = 256,
};
pub const DVD_PARENTAL_LEVEL_8 = DVD_PARENTAL_LEVEL.@"8";
pub const DVD_PARENTAL_LEVEL_7 = DVD_PARENTAL_LEVEL.@"7";
pub const DVD_PARENTAL_LEVEL_6 = DVD_PARENTAL_LEVEL.@"6";
pub const DVD_PARENTAL_LEVEL_5 = DVD_PARENTAL_LEVEL.@"5";
pub const DVD_PARENTAL_LEVEL_4 = DVD_PARENTAL_LEVEL.@"4";
pub const DVD_PARENTAL_LEVEL_3 = DVD_PARENTAL_LEVEL.@"3";
pub const DVD_PARENTAL_LEVEL_2 = DVD_PARENTAL_LEVEL.@"2";
pub const DVD_PARENTAL_LEVEL_1 = DVD_PARENTAL_LEVEL.@"1";

pub const DVD_AUDIO_LANG_EXT = enum(i32) {
    NotSpecified = 0,
    Captions = 1,
    VisuallyImpaired = 2,
    DirectorComments1 = 3,
    DirectorComments2 = 4,
};
pub const DVD_AUD_EXT_NotSpecified = DVD_AUDIO_LANG_EXT.NotSpecified;
pub const DVD_AUD_EXT_Captions = DVD_AUDIO_LANG_EXT.Captions;
pub const DVD_AUD_EXT_VisuallyImpaired = DVD_AUDIO_LANG_EXT.VisuallyImpaired;
pub const DVD_AUD_EXT_DirectorComments1 = DVD_AUDIO_LANG_EXT.DirectorComments1;
pub const DVD_AUD_EXT_DirectorComments2 = DVD_AUDIO_LANG_EXT.DirectorComments2;

pub const DVD_SUBPICTURE_LANG_EXT = enum(i32) {
    NotSpecified = 0,
    Caption_Normal = 1,
    Caption_Big = 2,
    Caption_Children = 3,
    CC_Normal = 5,
    CC_Big = 6,
    CC_Children = 7,
    Forced = 9,
    DirectorComments_Normal = 13,
    DirectorComments_Big = 14,
    DirectorComments_Children = 15,
};
pub const DVD_SP_EXT_NotSpecified = DVD_SUBPICTURE_LANG_EXT.NotSpecified;
pub const DVD_SP_EXT_Caption_Normal = DVD_SUBPICTURE_LANG_EXT.Caption_Normal;
pub const DVD_SP_EXT_Caption_Big = DVD_SUBPICTURE_LANG_EXT.Caption_Big;
pub const DVD_SP_EXT_Caption_Children = DVD_SUBPICTURE_LANG_EXT.Caption_Children;
pub const DVD_SP_EXT_CC_Normal = DVD_SUBPICTURE_LANG_EXT.CC_Normal;
pub const DVD_SP_EXT_CC_Big = DVD_SUBPICTURE_LANG_EXT.CC_Big;
pub const DVD_SP_EXT_CC_Children = DVD_SUBPICTURE_LANG_EXT.CC_Children;
pub const DVD_SP_EXT_Forced = DVD_SUBPICTURE_LANG_EXT.Forced;
pub const DVD_SP_EXT_DirectorComments_Normal = DVD_SUBPICTURE_LANG_EXT.DirectorComments_Normal;
pub const DVD_SP_EXT_DirectorComments_Big = DVD_SUBPICTURE_LANG_EXT.DirectorComments_Big;
pub const DVD_SP_EXT_DirectorComments_Children = DVD_SUBPICTURE_LANG_EXT.DirectorComments_Children;

pub const DVD_AUDIO_APPMODE = enum(i32) {
    None = 0,
    Karaoke = 1,
    Surround = 2,
    Other = 3,
};
pub const DVD_AudioMode_None = DVD_AUDIO_APPMODE.None;
pub const DVD_AudioMode_Karaoke = DVD_AUDIO_APPMODE.Karaoke;
pub const DVD_AudioMode_Surround = DVD_AUDIO_APPMODE.Surround;
pub const DVD_AudioMode_Other = DVD_AUDIO_APPMODE.Other;

pub const DVD_AUDIO_FORMAT = enum(i32) {
    AC3 = 0,
    MPEG1 = 1,
    MPEG1_DRC = 2,
    MPEG2 = 3,
    MPEG2_DRC = 4,
    LPCM = 5,
    DTS = 6,
    SDDS = 7,
    Other = 8,
};
pub const DVD_AudioFormat_AC3 = DVD_AUDIO_FORMAT.AC3;
pub const DVD_AudioFormat_MPEG1 = DVD_AUDIO_FORMAT.MPEG1;
pub const DVD_AudioFormat_MPEG1_DRC = DVD_AUDIO_FORMAT.MPEG1_DRC;
pub const DVD_AudioFormat_MPEG2 = DVD_AUDIO_FORMAT.MPEG2;
pub const DVD_AudioFormat_MPEG2_DRC = DVD_AUDIO_FORMAT.MPEG2_DRC;
pub const DVD_AudioFormat_LPCM = DVD_AUDIO_FORMAT.LPCM;
pub const DVD_AudioFormat_DTS = DVD_AUDIO_FORMAT.DTS;
pub const DVD_AudioFormat_SDDS = DVD_AUDIO_FORMAT.SDDS;
pub const DVD_AudioFormat_Other = DVD_AUDIO_FORMAT.Other;

pub const DVD_KARAOKE_DOWNMIX = enum(i32) {
    @"0to0" = 1,
    @"1to0" = 2,
    @"2to0" = 4,
    @"3to0" = 8,
    @"4to0" = 16,
    Lto0 = 32,
    Rto0 = 64,
    @"0to1" = 256,
    @"1to1" = 512,
    @"2to1" = 1024,
    @"3to1" = 2048,
    @"4to1" = 4096,
    Lto1 = 8192,
    Rto1 = 16384,
};
pub const DVD_Mix_0to0 = DVD_KARAOKE_DOWNMIX.@"0to0";
pub const DVD_Mix_1to0 = DVD_KARAOKE_DOWNMIX.@"1to0";
pub const DVD_Mix_2to0 = DVD_KARAOKE_DOWNMIX.@"2to0";
pub const DVD_Mix_3to0 = DVD_KARAOKE_DOWNMIX.@"3to0";
pub const DVD_Mix_4to0 = DVD_KARAOKE_DOWNMIX.@"4to0";
pub const DVD_Mix_Lto0 = DVD_KARAOKE_DOWNMIX.Lto0;
pub const DVD_Mix_Rto0 = DVD_KARAOKE_DOWNMIX.Rto0;
pub const DVD_Mix_0to1 = DVD_KARAOKE_DOWNMIX.@"0to1";
pub const DVD_Mix_1to1 = DVD_KARAOKE_DOWNMIX.@"1to1";
pub const DVD_Mix_2to1 = DVD_KARAOKE_DOWNMIX.@"2to1";
pub const DVD_Mix_3to1 = DVD_KARAOKE_DOWNMIX.@"3to1";
pub const DVD_Mix_4to1 = DVD_KARAOKE_DOWNMIX.@"4to1";
pub const DVD_Mix_Lto1 = DVD_KARAOKE_DOWNMIX.Lto1;
pub const DVD_Mix_Rto1 = DVD_KARAOKE_DOWNMIX.Rto1;

pub const DVD_AudioAttributes = extern struct {
    AppMode: DVD_AUDIO_APPMODE,
    AppModeData: u8,
    AudioFormat: DVD_AUDIO_FORMAT,
    Language: u32,
    LanguageExtension: DVD_AUDIO_LANG_EXT,
    fHasMultichannelInfo: BOOL,
    dwFrequency: u32,
    bQuantization: u8,
    bNumberOfChannels: u8,
    dwReserved: [2]u32,
};

pub const DVD_MUA_MixingInfo = extern struct {
    fMixTo0: BOOL,
    fMixTo1: BOOL,
    fMix0InPhase: BOOL,
    fMix1InPhase: BOOL,
    dwSpeakerPosition: u32,
};

pub const DVD_MUA_Coeff = extern struct {
    log2_alpha: f64,
    log2_beta: f64,
};

pub const DVD_MultichannelAudioAttributes = extern struct {
    Info: [8]DVD_MUA_MixingInfo,
    Coeff: [8]DVD_MUA_Coeff,
};

pub const DVD_KARAOKE_CONTENTS = enum(i32) {
    GuideVocal1 = 1,
    GuideVocal2 = 2,
    GuideMelody1 = 4,
    GuideMelody2 = 8,
    GuideMelodyA = 16,
    GuideMelodyB = 32,
    SoundEffectA = 64,
    SoundEffectB = 128,
};
pub const DVD_Karaoke_GuideVocal1 = DVD_KARAOKE_CONTENTS.GuideVocal1;
pub const DVD_Karaoke_GuideVocal2 = DVD_KARAOKE_CONTENTS.GuideVocal2;
pub const DVD_Karaoke_GuideMelody1 = DVD_KARAOKE_CONTENTS.GuideMelody1;
pub const DVD_Karaoke_GuideMelody2 = DVD_KARAOKE_CONTENTS.GuideMelody2;
pub const DVD_Karaoke_GuideMelodyA = DVD_KARAOKE_CONTENTS.GuideMelodyA;
pub const DVD_Karaoke_GuideMelodyB = DVD_KARAOKE_CONTENTS.GuideMelodyB;
pub const DVD_Karaoke_SoundEffectA = DVD_KARAOKE_CONTENTS.SoundEffectA;
pub const DVD_Karaoke_SoundEffectB = DVD_KARAOKE_CONTENTS.SoundEffectB;

pub const DVD_KARAOKE_ASSIGNMENT = enum(i32) {
    reserved0 = 0,
    reserved1 = 1,
    LR = 2,
    LRM = 3,
    LR1 = 4,
    LRM1 = 5,
    LR12 = 6,
    LRM12 = 7,
};
pub const DVD_Assignment_reserved0 = DVD_KARAOKE_ASSIGNMENT.reserved0;
pub const DVD_Assignment_reserved1 = DVD_KARAOKE_ASSIGNMENT.reserved1;
pub const DVD_Assignment_LR = DVD_KARAOKE_ASSIGNMENT.LR;
pub const DVD_Assignment_LRM = DVD_KARAOKE_ASSIGNMENT.LRM;
pub const DVD_Assignment_LR1 = DVD_KARAOKE_ASSIGNMENT.LR1;
pub const DVD_Assignment_LRM1 = DVD_KARAOKE_ASSIGNMENT.LRM1;
pub const DVD_Assignment_LR12 = DVD_KARAOKE_ASSIGNMENT.LR12;
pub const DVD_Assignment_LRM12 = DVD_KARAOKE_ASSIGNMENT.LRM12;

pub const DVD_KaraokeAttributes = extern struct {
    bVersion: u8,
    fMasterOfCeremoniesInGuideVocal1: BOOL,
    fDuet: BOOL,
    ChannelAssignment: DVD_KARAOKE_ASSIGNMENT,
    wChannelContents: [8]u16,
};

pub const DVD_VIDEO_COMPRESSION = enum(i32) {
    Other = 0,
    MPEG1 = 1,
    MPEG2 = 2,
};
pub const DVD_VideoCompression_Other = DVD_VIDEO_COMPRESSION.Other;
pub const DVD_VideoCompression_MPEG1 = DVD_VIDEO_COMPRESSION.MPEG1;
pub const DVD_VideoCompression_MPEG2 = DVD_VIDEO_COMPRESSION.MPEG2;

pub const DVD_VideoAttributes = extern struct {
    fPanscanPermitted: BOOL,
    fLetterboxPermitted: BOOL,
    ulAspectX: u32,
    ulAspectY: u32,
    ulFrameRate: u32,
    ulFrameHeight: u32,
    Compression: DVD_VIDEO_COMPRESSION,
    fLine21Field1InGOP: BOOL,
    fLine21Field2InGOP: BOOL,
    ulSourceResolutionX: u32,
    ulSourceResolutionY: u32,
    fIsSourceLetterboxed: BOOL,
    fIsFilmMode: BOOL,
};

pub const DVD_SUBPICTURE_TYPE = enum(i32) {
    NotSpecified = 0,
    Language = 1,
    Other = 2,
};
pub const DVD_SPType_NotSpecified = DVD_SUBPICTURE_TYPE.NotSpecified;
pub const DVD_SPType_Language = DVD_SUBPICTURE_TYPE.Language;
pub const DVD_SPType_Other = DVD_SUBPICTURE_TYPE.Other;

pub const DVD_SUBPICTURE_CODING = enum(i32) {
    RunLength = 0,
    Extended = 1,
    Other = 2,
};
pub const DVD_SPCoding_RunLength = DVD_SUBPICTURE_CODING.RunLength;
pub const DVD_SPCoding_Extended = DVD_SUBPICTURE_CODING.Extended;
pub const DVD_SPCoding_Other = DVD_SUBPICTURE_CODING.Other;

pub const DVD_SubpictureAttributes = extern struct {
    Type: DVD_SUBPICTURE_TYPE,
    CodingMode: DVD_SUBPICTURE_CODING,
    Language: u32,
    LanguageExtension: DVD_SUBPICTURE_LANG_EXT,
};

pub const DVD_TITLE_APPMODE = enum(i32) {
    Not_Specified = 0,
    Karaoke = 1,
    Other = 3,
};
pub const DVD_AppMode_Not_Specified = DVD_TITLE_APPMODE.Not_Specified;
pub const DVD_AppMode_Karaoke = DVD_TITLE_APPMODE.Karaoke;
pub const DVD_AppMode_Other = DVD_TITLE_APPMODE.Other;

pub const DVD_TitleAttributes = extern struct {
    Anonymous: extern union {
        AppMode: DVD_TITLE_APPMODE,
        TitleLength: DVD_HMSF_TIMECODE,
    },
    VideoAttributes: DVD_VideoAttributes,
    ulNumberOfAudioStreams: u32,
    AudioAttributes: [8]DVD_AudioAttributes,
    MultichannelAudioAttributes: [8]DVD_MultichannelAudioAttributes,
    ulNumberOfSubpictureStreams: u32,
    SubpictureAttributes: [32]DVD_SubpictureAttributes,
};

pub const DVD_MenuAttributes = extern struct {
    fCompatibleRegion: [8]BOOL,
    VideoAttributes: DVD_VideoAttributes,
    fAudioPresent: BOOL,
    AudioAttributes: DVD_AudioAttributes,
    fSubpicturePresent: BOOL,
    SubpictureAttributes: DVD_SubpictureAttributes,
};

const IID_IDvdControl_Value = @import("../zig.zig").Guid.initString("a70efe61-e2a3-11d0-a9be-00aa0061be93");
pub const IID_IDvdControl = &IID_IDvdControl_Value;
pub const IDvdControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TitlePlay: fn(
            self: *const IDvdControl,
            ulTitle: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChapterPlay: fn(
            self: *const IDvdControl,
            ulTitle: u32,
            ulChapter: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TimePlay: fn(
            self: *const IDvdControl,
            ulTitle: u32,
            bcdTime: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopForResume: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoUp: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TimeSearch: fn(
            self: *const IDvdControl,
            bcdTime: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChapterSearch: fn(
            self: *const IDvdControl,
            ulChapter: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrevPGSearch: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TopPGSearch: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextPGSearch: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ForwardScan: fn(
            self: *const IDvdControl,
            dwSpeed: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BackwardScan: fn(
            self: *const IDvdControl,
            dwSpeed: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MenuCall: fn(
            self: *const IDvdControl,
            MenuID: DVD_MENU_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpperButtonSelect: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LowerButtonSelect: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LeftButtonSelect: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RightButtonSelect: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ButtonActivate: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ButtonSelectAndActivate: fn(
            self: *const IDvdControl,
            ulButton: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StillOff: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseOn: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseOff: fn(
            self: *const IDvdControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MenuLanguageSelect: fn(
            self: *const IDvdControl,
            Language: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AudioStreamChange: fn(
            self: *const IDvdControl,
            ulAudio: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubpictureStreamChange: fn(
            self: *const IDvdControl,
            ulSubPicture: u32,
            bDisplay: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AngleChange: fn(
            self: *const IDvdControl,
            ulAngle: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParentalLevelSelect: fn(
            self: *const IDvdControl,
            ulParentalLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParentalCountrySelect: fn(
            self: *const IDvdControl,
            wCountry: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KaraokeAudioPresentationModeChange: fn(
            self: *const IDvdControl,
            ulMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VideoModePreferrence: fn(
            self: *const IDvdControl,
            ulPreferredDisplayMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRoot: fn(
            self: *const IDvdControl,
            pszPath: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseActivate: fn(
            self: *const IDvdControl,
            point: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseSelect: fn(
            self: *const IDvdControl,
            point: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChapterPlayAutoStop: fn(
            self: *const IDvdControl,
            ulTitle: u32,
            ulChapter: u32,
            ulChaptersToPlay: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_TitlePlay(self: *const T, ulTitle: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).TitlePlay(@ptrCast(*const IDvdControl, self), ulTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ChapterPlay(self: *const T, ulTitle: u32, ulChapter: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).ChapterPlay(@ptrCast(*const IDvdControl, self), ulTitle, ulChapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_TimePlay(self: *const T, ulTitle: u32, bcdTime: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).TimePlay(@ptrCast(*const IDvdControl, self), ulTitle, bcdTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_StopForResume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).StopForResume(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_GoUp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).GoUp(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_TimeSearch(self: *const T, bcdTime: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).TimeSearch(@ptrCast(*const IDvdControl, self), bcdTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ChapterSearch(self: *const T, ulChapter: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).ChapterSearch(@ptrCast(*const IDvdControl, self), ulChapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_PrevPGSearch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).PrevPGSearch(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_TopPGSearch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).TopPGSearch(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_NextPGSearch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).NextPGSearch(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ForwardScan(self: *const T, dwSpeed: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).ForwardScan(@ptrCast(*const IDvdControl, self), dwSpeed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_BackwardScan(self: *const T, dwSpeed: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).BackwardScan(@ptrCast(*const IDvdControl, self), dwSpeed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_MenuCall(self: *const T, MenuID: DVD_MENU_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).MenuCall(@ptrCast(*const IDvdControl, self), MenuID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).Resume(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_UpperButtonSelect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).UpperButtonSelect(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_LowerButtonSelect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).LowerButtonSelect(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_LeftButtonSelect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).LeftButtonSelect(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_RightButtonSelect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).RightButtonSelect(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ButtonActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).ButtonActivate(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ButtonSelectAndActivate(self: *const T, ulButton: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).ButtonSelectAndActivate(@ptrCast(*const IDvdControl, self), ulButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_StillOff(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).StillOff(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_PauseOn(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).PauseOn(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_PauseOff(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).PauseOff(@ptrCast(*const IDvdControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_MenuLanguageSelect(self: *const T, Language: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).MenuLanguageSelect(@ptrCast(*const IDvdControl, self), Language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_AudioStreamChange(self: *const T, ulAudio: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).AudioStreamChange(@ptrCast(*const IDvdControl, self), ulAudio);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_SubpictureStreamChange(self: *const T, ulSubPicture: u32, bDisplay: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).SubpictureStreamChange(@ptrCast(*const IDvdControl, self), ulSubPicture, bDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_AngleChange(self: *const T, ulAngle: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).AngleChange(@ptrCast(*const IDvdControl, self), ulAngle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ParentalLevelSelect(self: *const T, ulParentalLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).ParentalLevelSelect(@ptrCast(*const IDvdControl, self), ulParentalLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ParentalCountrySelect(self: *const T, wCountry: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).ParentalCountrySelect(@ptrCast(*const IDvdControl, self), wCountry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_KaraokeAudioPresentationModeChange(self: *const T, ulMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).KaraokeAudioPresentationModeChange(@ptrCast(*const IDvdControl, self), ulMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_VideoModePreferrence(self: *const T, ulPreferredDisplayMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).VideoModePreferrence(@ptrCast(*const IDvdControl, self), ulPreferredDisplayMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_SetRoot(self: *const T, pszPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).SetRoot(@ptrCast(*const IDvdControl, self), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_MouseActivate(self: *const T, point: POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).MouseActivate(@ptrCast(*const IDvdControl, self), point);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_MouseSelect(self: *const T, point: POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).MouseSelect(@ptrCast(*const IDvdControl, self), point);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ChapterPlayAutoStop(self: *const T, ulTitle: u32, ulChapter: u32, ulChaptersToPlay: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl.VTable, self.vtable).ChapterPlayAutoStop(@ptrCast(*const IDvdControl, self), ulTitle, ulChapter, ulChaptersToPlay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvdInfo_Value = @import("../zig.zig").Guid.initString("a70efe60-e2a3-11d0-a9be-00aa0061be93");
pub const IID_IDvdInfo = &IID_IDvdInfo_Value;
pub const IDvdInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentDomain: fn(
            self: *const IDvdInfo,
            pDomain: ?*DVD_DOMAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLocation: fn(
            self: *const IDvdInfo,
            pLocation: ?*DVD_PLAYBACK_LOCATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalTitleTime: fn(
            self: *const IDvdInfo,
            pulTotalTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentButton: fn(
            self: *const IDvdInfo,
            pulButtonsAvailable: ?*u32,
            pulCurrentButton: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAngle: fn(
            self: *const IDvdInfo,
            pulAnglesAvailable: ?*u32,
            pulCurrentAngle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAudio: fn(
            self: *const IDvdInfo,
            pulStreamsAvailable: ?*u32,
            pulCurrentStream: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSubpicture: fn(
            self: *const IDvdInfo,
            pulStreamsAvailable: ?*u32,
            pulCurrentStream: ?*u32,
            pIsDisabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentUOPS: fn(
            self: *const IDvdInfo,
            pUOP: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllSPRMs: fn(
            self: *const IDvdInfo,
            pRegisterArray: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllGPRMs: fn(
            self: *const IDvdInfo,
            pRegisterArray: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioLanguage: fn(
            self: *const IDvdInfo,
            ulStream: u32,
            pLanguage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubpictureLanguage: fn(
            self: *const IDvdInfo,
            ulStream: u32,
            pLanguage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitleAttributes: fn(
            self: *const IDvdInfo,
            ulTitle: u32,
            pATR: ?*DVD_ATR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVMGAttributes: fn(
            self: *const IDvdInfo,
            pATR: ?*DVD_ATR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentVideoAttributes: fn(
            self: *const IDvdInfo,
            pATR: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAudioAttributes: fn(
            self: *const IDvdInfo,
            pATR: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSubpictureAttributes: fn(
            self: *const IDvdInfo,
            pATR: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentVolumeInfo: fn(
            self: *const IDvdInfo,
            pulNumOfVol: ?*u32,
            pulThisVolNum: ?*u32,
            pSide: ?*DVD_DISC_SIDE,
            pulNumOfTitles: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextInfo: fn(
            self: *const IDvdInfo,
            // TODO: what to do with BytesParamIndex 1?
            pTextManager: ?*u8,
            ulBufSize: u32,
            pulActualSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPlayerParentalLevel: fn(
            self: *const IDvdInfo,
            pulParentalLevel: ?*u32,
            pulCountryCode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfChapters: fn(
            self: *const IDvdInfo,
            ulTitle: u32,
            pulNumberOfChapters: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitleParentalLevels: fn(
            self: *const IDvdInfo,
            ulTitle: u32,
            pulParentalLevels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRoot: fn(
            self: *const IDvdInfo,
            pRoot: [*:0]u8,
            ulBufSize: u32,
            pulActualSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentDomain(self: *const T, pDomain: ?*DVD_DOMAIN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentDomain(@ptrCast(*const IDvdInfo, self), pDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentLocation(self: *const T, pLocation: ?*DVD_PLAYBACK_LOCATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentLocation(@ptrCast(*const IDvdInfo, self), pLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetTotalTitleTime(self: *const T, pulTotalTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetTotalTitleTime(@ptrCast(*const IDvdInfo, self), pulTotalTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentButton(self: *const T, pulButtonsAvailable: ?*u32, pulCurrentButton: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentButton(@ptrCast(*const IDvdInfo, self), pulButtonsAvailable, pulCurrentButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentAngle(self: *const T, pulAnglesAvailable: ?*u32, pulCurrentAngle: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentAngle(@ptrCast(*const IDvdInfo, self), pulAnglesAvailable, pulCurrentAngle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentAudio(self: *const T, pulStreamsAvailable: ?*u32, pulCurrentStream: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentAudio(@ptrCast(*const IDvdInfo, self), pulStreamsAvailable, pulCurrentStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentSubpicture(self: *const T, pulStreamsAvailable: ?*u32, pulCurrentStream: ?*u32, pIsDisabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentSubpicture(@ptrCast(*const IDvdInfo, self), pulStreamsAvailable, pulCurrentStream, pIsDisabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentUOPS(self: *const T, pUOP: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentUOPS(@ptrCast(*const IDvdInfo, self), pUOP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetAllSPRMs(self: *const T, pRegisterArray: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetAllSPRMs(@ptrCast(*const IDvdInfo, self), pRegisterArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetAllGPRMs(self: *const T, pRegisterArray: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetAllGPRMs(@ptrCast(*const IDvdInfo, self), pRegisterArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetAudioLanguage(self: *const T, ulStream: u32, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetAudioLanguage(@ptrCast(*const IDvdInfo, self), ulStream, pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetSubpictureLanguage(self: *const T, ulStream: u32, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetSubpictureLanguage(@ptrCast(*const IDvdInfo, self), ulStream, pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetTitleAttributes(self: *const T, ulTitle: u32, pATR: ?*DVD_ATR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetTitleAttributes(@ptrCast(*const IDvdInfo, self), ulTitle, pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetVMGAttributes(self: *const T, pATR: ?*DVD_ATR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetVMGAttributes(@ptrCast(*const IDvdInfo, self), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentVideoAttributes(self: *const T, pATR: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentVideoAttributes(@ptrCast(*const IDvdInfo, self), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentAudioAttributes(self: *const T, pATR: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentAudioAttributes(@ptrCast(*const IDvdInfo, self), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentSubpictureAttributes(self: *const T, pATR: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentSubpictureAttributes(@ptrCast(*const IDvdInfo, self), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentVolumeInfo(self: *const T, pulNumOfVol: ?*u32, pulThisVolNum: ?*u32, pSide: ?*DVD_DISC_SIDE, pulNumOfTitles: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetCurrentVolumeInfo(@ptrCast(*const IDvdInfo, self), pulNumOfVol, pulThisVolNum, pSide, pulNumOfTitles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetDVDTextInfo(self: *const T, pTextManager: ?*u8, ulBufSize: u32, pulActualSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetDVDTextInfo(@ptrCast(*const IDvdInfo, self), pTextManager, ulBufSize, pulActualSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetPlayerParentalLevel(self: *const T, pulParentalLevel: ?*u32, pulCountryCode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetPlayerParentalLevel(@ptrCast(*const IDvdInfo, self), pulParentalLevel, pulCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetNumberOfChapters(self: *const T, ulTitle: u32, pulNumberOfChapters: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetNumberOfChapters(@ptrCast(*const IDvdInfo, self), ulTitle, pulNumberOfChapters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetTitleParentalLevels(self: *const T, ulTitle: u32, pulParentalLevels: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetTitleParentalLevels(@ptrCast(*const IDvdInfo, self), ulTitle, pulParentalLevels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetRoot(self: *const T, pRoot: [*:0]u8, ulBufSize: u32, pulActualSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo.VTable, self.vtable).GetRoot(@ptrCast(*const IDvdInfo, self), pRoot, ulBufSize, pulActualSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdCmd_Value = @import("../zig.zig").Guid.initString("5a4a97e4-94ee-4a55-9751-74b5643aa27d");
pub const IID_IDvdCmd = &IID_IDvdCmd_Value;
pub const IDvdCmd = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitForStart: fn(
            self: *const IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForEnd: fn(
            self: *const IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdCmd_WaitForStart(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdCmd.VTable, self.vtable).WaitForStart(@ptrCast(*const IDvdCmd, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdCmd_WaitForEnd(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdCmd.VTable, self.vtable).WaitForEnd(@ptrCast(*const IDvdCmd, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdState_Value = @import("../zig.zig").Guid.initString("86303d6d-1c4a-4087-ab42-f711167048ef");
pub const IID_IDvdState = &IID_IDvdState_Value;
pub const IDvdState = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDiscID: fn(
            self: *const IDvdState,
            pullUniqueID: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentalLevel: fn(
            self: *const IDvdState,
            pulParentalLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdState_GetDiscID(self: *const T, pullUniqueID: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdState.VTable, self.vtable).GetDiscID(@ptrCast(*const IDvdState, self), pullUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdState_GetParentalLevel(self: *const T, pulParentalLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdState.VTable, self.vtable).GetParentalLevel(@ptrCast(*const IDvdState, self), pulParentalLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdControl2_Value = @import("../zig.zig").Guid.initString("33bc7430-eec0-11d2-8201-00a0c9d74842");
pub const IID_IDvdControl2 = &IID_IDvdControl2_Value;
pub const IDvdControl2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PlayTitle: fn(
            self: *const IDvdControl2,
            ulTitle: u32,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapterInTitle: fn(
            self: *const IDvdControl2,
            ulTitle: u32,
            ulChapter: u32,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTimeInTitle: fn(
            self: *const IDvdControl2,
            ulTitle: u32,
            pStartTime: ?*DVD_HMSF_TIMECODE,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IDvdControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnFromSubmenu: fn(
            self: *const IDvdControl2,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTime: fn(
            self: *const IDvdControl2,
            pTime: ?*DVD_HMSF_TIMECODE,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapter: fn(
            self: *const IDvdControl2,
            ulChapter: u32,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPrevChapter: fn(
            self: *const IDvdControl2,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplayChapter: fn(
            self: *const IDvdControl2,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayNextChapter: fn(
            self: *const IDvdControl2,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayForwards: fn(
            self: *const IDvdControl2,
            dSpeed: f64,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayBackwards: fn(
            self: *const IDvdControl2,
            dSpeed: f64,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowMenu: fn(
            self: *const IDvdControl2,
            MenuID: DVD_MENU_ID,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IDvdControl2,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectRelativeButton: fn(
            self: *const IDvdControl2,
            buttonDir: DVD_RELATIVE_BUTTON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateButton: fn(
            self: *const IDvdControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectButton: fn(
            self: *const IDvdControl2,
            ulButton: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAndActivateButton: fn(
            self: *const IDvdControl2,
            ulButton: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StillOff: fn(
            self: *const IDvdControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IDvdControl2,
            bState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAudioStream: fn(
            self: *const IDvdControl2,
            ulAudio: u32,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectSubpictureStream: fn(
            self: *const IDvdControl2,
            ulSubPicture: u32,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubpictureState: fn(
            self: *const IDvdControl2,
            bState: BOOL,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAngle: fn(
            self: *const IDvdControl2,
            ulAngle: u32,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectParentalLevel: fn(
            self: *const IDvdControl2,
            ulParentalLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectParentalCountry: fn(
            self: *const IDvdControl2,
            bCountry: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectKaraokeAudioPresentationMode: fn(
            self: *const IDvdControl2,
            ulMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectVideoModePreference: fn(
            self: *const IDvdControl2,
            ulPreferredDisplayMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDVDDirectory: fn(
            self: *const IDvdControl2,
            pszwPath: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAtPosition: fn(
            self: *const IDvdControl2,
            point: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAtPosition: fn(
            self: *const IDvdControl2,
            point: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChaptersAutoStop: fn(
            self: *const IDvdControl2,
            ulTitle: u32,
            ulChapter: u32,
            ulChaptersToPlay: u32,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AcceptParentalLevelChange: fn(
            self: *const IDvdControl2,
            bAccept: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOption: fn(
            self: *const IDvdControl2,
            flag: DVD_OPTION_FLAG,
            fState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetState: fn(
            self: *const IDvdControl2,
            pState: ?*IDvdState,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPeriodInTitleAutoStop: fn(
            self: *const IDvdControl2,
            ulTitle: u32,
            pStartTime: ?*DVD_HMSF_TIMECODE,
            pEndTime: ?*DVD_HMSF_TIMECODE,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGPRM: fn(
            self: *const IDvdControl2,
            ulIndex: u32,
            wValue: u16,
            dwFlags: u32,
            ppCmd: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultMenuLanguage: fn(
            self: *const IDvdControl2,
            Language: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultAudioLanguage: fn(
            self: *const IDvdControl2,
            Language: u32,
            audioExtension: DVD_AUDIO_LANG_EXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultSubpictureLanguage: fn(
            self: *const IDvdControl2,
            Language: u32,
            subpictureExtension: DVD_SUBPICTURE_LANG_EXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayTitle(self: *const T, ulTitle: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayTitle(@ptrCast(*const IDvdControl2, self), ulTitle, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayChapterInTitle(self: *const T, ulTitle: u32, ulChapter: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayChapterInTitle(@ptrCast(*const IDvdControl2, self), ulTitle, ulChapter, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayAtTimeInTitle(self: *const T, ulTitle: u32, pStartTime: ?*DVD_HMSF_TIMECODE, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayAtTimeInTitle(@ptrCast(*const IDvdControl2, self), ulTitle, pStartTime, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).Stop(@ptrCast(*const IDvdControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ReturnFromSubmenu(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).ReturnFromSubmenu(@ptrCast(*const IDvdControl2, self), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayAtTime(self: *const T, pTime: ?*DVD_HMSF_TIMECODE, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayAtTime(@ptrCast(*const IDvdControl2, self), pTime, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayChapter(self: *const T, ulChapter: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayChapter(@ptrCast(*const IDvdControl2, self), ulChapter, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayPrevChapter(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayPrevChapter(@ptrCast(*const IDvdControl2, self), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ReplayChapter(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).ReplayChapter(@ptrCast(*const IDvdControl2, self), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayNextChapter(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayNextChapter(@ptrCast(*const IDvdControl2, self), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayForwards(self: *const T, dSpeed: f64, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayForwards(@ptrCast(*const IDvdControl2, self), dSpeed, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayBackwards(self: *const T, dSpeed: f64, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayBackwards(@ptrCast(*const IDvdControl2, self), dSpeed, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ShowMenu(self: *const T, MenuID: DVD_MENU_ID, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).ShowMenu(@ptrCast(*const IDvdControl2, self), MenuID, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_Resume(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).Resume(@ptrCast(*const IDvdControl2, self), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectRelativeButton(self: *const T, buttonDir: DVD_RELATIVE_BUTTON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectRelativeButton(@ptrCast(*const IDvdControl2, self), buttonDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ActivateButton(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).ActivateButton(@ptrCast(*const IDvdControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectButton(self: *const T, ulButton: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectButton(@ptrCast(*const IDvdControl2, self), ulButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectAndActivateButton(self: *const T, ulButton: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectAndActivateButton(@ptrCast(*const IDvdControl2, self), ulButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_StillOff(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).StillOff(@ptrCast(*const IDvdControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_Pause(self: *const T, bState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).Pause(@ptrCast(*const IDvdControl2, self), bState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectAudioStream(self: *const T, ulAudio: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectAudioStream(@ptrCast(*const IDvdControl2, self), ulAudio, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectSubpictureStream(self: *const T, ulSubPicture: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectSubpictureStream(@ptrCast(*const IDvdControl2, self), ulSubPicture, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetSubpictureState(self: *const T, bState: BOOL, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SetSubpictureState(@ptrCast(*const IDvdControl2, self), bState, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectAngle(self: *const T, ulAngle: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectAngle(@ptrCast(*const IDvdControl2, self), ulAngle, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectParentalLevel(self: *const T, ulParentalLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectParentalLevel(@ptrCast(*const IDvdControl2, self), ulParentalLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectParentalCountry(self: *const T, bCountry: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectParentalCountry(@ptrCast(*const IDvdControl2, self), bCountry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectKaraokeAudioPresentationMode(self: *const T, ulMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectKaraokeAudioPresentationMode(@ptrCast(*const IDvdControl2, self), ulMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectVideoModePreference(self: *const T, ulPreferredDisplayMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectVideoModePreference(@ptrCast(*const IDvdControl2, self), ulPreferredDisplayMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetDVDDirectory(self: *const T, pszwPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SetDVDDirectory(@ptrCast(*const IDvdControl2, self), pszwPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ActivateAtPosition(self: *const T, point: POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).ActivateAtPosition(@ptrCast(*const IDvdControl2, self), point);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectAtPosition(self: *const T, point: POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectAtPosition(@ptrCast(*const IDvdControl2, self), point);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayChaptersAutoStop(self: *const T, ulTitle: u32, ulChapter: u32, ulChaptersToPlay: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayChaptersAutoStop(@ptrCast(*const IDvdControl2, self), ulTitle, ulChapter, ulChaptersToPlay, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_AcceptParentalLevelChange(self: *const T, bAccept: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).AcceptParentalLevelChange(@ptrCast(*const IDvdControl2, self), bAccept);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetOption(self: *const T, flag: DVD_OPTION_FLAG, fState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SetOption(@ptrCast(*const IDvdControl2, self), flag, fState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetState(self: *const T, pState: ?*IDvdState, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SetState(@ptrCast(*const IDvdControl2, self), pState, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayPeriodInTitleAutoStop(self: *const T, ulTitle: u32, pStartTime: ?*DVD_HMSF_TIMECODE, pEndTime: ?*DVD_HMSF_TIMECODE, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).PlayPeriodInTitleAutoStop(@ptrCast(*const IDvdControl2, self), ulTitle, pStartTime, pEndTime, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetGPRM(self: *const T, ulIndex: u32, wValue: u16, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SetGPRM(@ptrCast(*const IDvdControl2, self), ulIndex, wValue, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectDefaultMenuLanguage(self: *const T, Language: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectDefaultMenuLanguage(@ptrCast(*const IDvdControl2, self), Language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectDefaultAudioLanguage(self: *const T, Language: u32, audioExtension: DVD_AUDIO_LANG_EXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectDefaultAudioLanguage(@ptrCast(*const IDvdControl2, self), Language, audioExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectDefaultSubpictureLanguage(self: *const T, Language: u32, subpictureExtension: DVD_SUBPICTURE_LANG_EXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdControl2.VTable, self.vtable).SelectDefaultSubpictureLanguage(@ptrCast(*const IDvdControl2, self), Language, subpictureExtension);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVD_TextStringType = enum(i32) {
    Struct_Volume = 1,
    Struct_Title = 2,
    Struct_ParentalID = 3,
    Struct_PartOfTitle = 4,
    Struct_Cell = 5,
    Stream_Audio = 16,
    Stream_Subpicture = 17,
    Stream_Angle = 18,
    Channel_Audio = 32,
    General_Name = 48,
    General_Comments = 49,
    Title_Series = 56,
    Title_Movie = 57,
    Title_Video = 58,
    Title_Album = 59,
    Title_Song = 60,
    Title_Other = 63,
    Title_Sub_Series = 64,
    Title_Sub_Movie = 65,
    Title_Sub_Video = 66,
    Title_Sub_Album = 67,
    Title_Sub_Song = 68,
    Title_Sub_Other = 71,
    Title_Orig_Series = 72,
    Title_Orig_Movie = 73,
    Title_Orig_Video = 74,
    Title_Orig_Album = 75,
    Title_Orig_Song = 76,
    Title_Orig_Other = 79,
    Other_Scene = 80,
    Other_Cut = 81,
    Other_Take = 82,
};
pub const DVD_Struct_Volume = DVD_TextStringType.Struct_Volume;
pub const DVD_Struct_Title = DVD_TextStringType.Struct_Title;
pub const DVD_Struct_ParentalID = DVD_TextStringType.Struct_ParentalID;
pub const DVD_Struct_PartOfTitle = DVD_TextStringType.Struct_PartOfTitle;
pub const DVD_Struct_Cell = DVD_TextStringType.Struct_Cell;
pub const DVD_Stream_Audio = DVD_TextStringType.Stream_Audio;
pub const DVD_Stream_Subpicture = DVD_TextStringType.Stream_Subpicture;
pub const DVD_Stream_Angle = DVD_TextStringType.Stream_Angle;
pub const DVD_Channel_Audio = DVD_TextStringType.Channel_Audio;
pub const DVD_General_Name = DVD_TextStringType.General_Name;
pub const DVD_General_Comments = DVD_TextStringType.General_Comments;
pub const DVD_Title_Series = DVD_TextStringType.Title_Series;
pub const DVD_Title_Movie = DVD_TextStringType.Title_Movie;
pub const DVD_Title_Video = DVD_TextStringType.Title_Video;
pub const DVD_Title_Album = DVD_TextStringType.Title_Album;
pub const DVD_Title_Song = DVD_TextStringType.Title_Song;
pub const DVD_Title_Other = DVD_TextStringType.Title_Other;
pub const DVD_Title_Sub_Series = DVD_TextStringType.Title_Sub_Series;
pub const DVD_Title_Sub_Movie = DVD_TextStringType.Title_Sub_Movie;
pub const DVD_Title_Sub_Video = DVD_TextStringType.Title_Sub_Video;
pub const DVD_Title_Sub_Album = DVD_TextStringType.Title_Sub_Album;
pub const DVD_Title_Sub_Song = DVD_TextStringType.Title_Sub_Song;
pub const DVD_Title_Sub_Other = DVD_TextStringType.Title_Sub_Other;
pub const DVD_Title_Orig_Series = DVD_TextStringType.Title_Orig_Series;
pub const DVD_Title_Orig_Movie = DVD_TextStringType.Title_Orig_Movie;
pub const DVD_Title_Orig_Video = DVD_TextStringType.Title_Orig_Video;
pub const DVD_Title_Orig_Album = DVD_TextStringType.Title_Orig_Album;
pub const DVD_Title_Orig_Song = DVD_TextStringType.Title_Orig_Song;
pub const DVD_Title_Orig_Other = DVD_TextStringType.Title_Orig_Other;
pub const DVD_Other_Scene = DVD_TextStringType.Other_Scene;
pub const DVD_Other_Cut = DVD_TextStringType.Other_Cut;
pub const DVD_Other_Take = DVD_TextStringType.Other_Take;

pub const DVD_TextCharSet = enum(i32) {
    Unicode = 0,
    ISO646 = 1,
    JIS_Roman_Kanji = 2,
    ISO8859_1 = 3,
    ShiftJIS_Kanji_Roman_Katakana = 4,
};
pub const DVD_CharSet_Unicode = DVD_TextCharSet.Unicode;
pub const DVD_CharSet_ISO646 = DVD_TextCharSet.ISO646;
pub const DVD_CharSet_JIS_Roman_Kanji = DVD_TextCharSet.JIS_Roman_Kanji;
pub const DVD_CharSet_ISO8859_1 = DVD_TextCharSet.ISO8859_1;
pub const DVD_CharSet_ShiftJIS_Kanji_Roman_Katakana = DVD_TextCharSet.ShiftJIS_Kanji_Roman_Katakana;

pub const DVD_DECODER_CAPS = extern struct {
    dwSize: u32,
    dwAudioCaps: u32,
    dFwdMaxRateVideo: f64,
    dFwdMaxRateAudio: f64,
    dFwdMaxRateSP: f64,
    dBwdMaxRateVideo: f64,
    dBwdMaxRateAudio: f64,
    dBwdMaxRateSP: f64,
    dwRes1: u32,
    dwRes2: u32,
    dwRes3: u32,
    dwRes4: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdInfo2_Value = @import("../zig.zig").Guid.initString("34151510-eec0-11d2-8201-00a0c9d74842");
pub const IID_IDvdInfo2 = &IID_IDvdInfo2_Value;
pub const IDvdInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentDomain: fn(
            self: *const IDvdInfo2,
            pDomain: ?*DVD_DOMAIN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLocation: fn(
            self: *const IDvdInfo2,
            pLocation: ?*DVD_PLAYBACK_LOCATION2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalTitleTime: fn(
            self: *const IDvdInfo2,
            pTotalTime: ?*DVD_HMSF_TIMECODE,
            ulTimeCodeFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentButton: fn(
            self: *const IDvdInfo2,
            pulButtonsAvailable: ?*u32,
            pulCurrentButton: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAngle: fn(
            self: *const IDvdInfo2,
            pulAnglesAvailable: ?*u32,
            pulCurrentAngle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAudio: fn(
            self: *const IDvdInfo2,
            pulStreamsAvailable: ?*u32,
            pulCurrentStream: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSubpicture: fn(
            self: *const IDvdInfo2,
            pulStreamsAvailable: ?*u32,
            pulCurrentStream: ?*u32,
            pbIsDisabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentUOPS: fn(
            self: *const IDvdInfo2,
            pulUOPs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllSPRMs: fn(
            self: *const IDvdInfo2,
            pRegisterArray: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllGPRMs: fn(
            self: *const IDvdInfo2,
            pRegisterArray: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioLanguage: fn(
            self: *const IDvdInfo2,
            ulStream: u32,
            pLanguage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubpictureLanguage: fn(
            self: *const IDvdInfo2,
            ulStream: u32,
            pLanguage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitleAttributes: fn(
            self: *const IDvdInfo2,
            ulTitle: u32,
            pMenu: ?*DVD_MenuAttributes,
            pTitle: ?*DVD_TitleAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVMGAttributes: fn(
            self: *const IDvdInfo2,
            pATR: ?*DVD_MenuAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentVideoAttributes: fn(
            self: *const IDvdInfo2,
            pATR: ?*DVD_VideoAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioAttributes: fn(
            self: *const IDvdInfo2,
            ulStream: u32,
            pATR: ?*DVD_AudioAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKaraokeAttributes: fn(
            self: *const IDvdInfo2,
            ulStream: u32,
            pAttributes: ?*DVD_KaraokeAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubpictureAttributes: fn(
            self: *const IDvdInfo2,
            ulStream: u32,
            pATR: ?*DVD_SubpictureAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDVolumeInfo: fn(
            self: *const IDvdInfo2,
            pulNumOfVolumes: ?*u32,
            pulVolume: ?*u32,
            pSide: ?*DVD_DISC_SIDE,
            pulNumOfTitles: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextNumberOfLanguages: fn(
            self: *const IDvdInfo2,
            pulNumOfLangs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextLanguageInfo: fn(
            self: *const IDvdInfo2,
            ulLangIndex: u32,
            pulNumOfStrings: ?*u32,
            pLangCode: ?*u32,
            pbCharacterSet: ?*DVD_TextCharSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextStringAsNative: fn(
            self: *const IDvdInfo2,
            ulLangIndex: u32,
            ulStringIndex: u32,
            pbBuffer: ?*u8,
            ulMaxBufferSize: u32,
            pulActualSize: ?*u32,
            pType: ?*DVD_TextStringType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDTextStringAsUnicode: fn(
            self: *const IDvdInfo2,
            ulLangIndex: u32,
            ulStringIndex: u32,
            pchwBuffer: ?PWSTR,
            ulMaxBufferSize: u32,
            pulActualSize: ?*u32,
            pType: ?*DVD_TextStringType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPlayerParentalLevel: fn(
            self: *const IDvdInfo2,
            pulParentalLevel: ?*u32,
            pbCountryCode: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfChapters: fn(
            self: *const IDvdInfo2,
            ulTitle: u32,
            pulNumOfChapters: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitleParentalLevels: fn(
            self: *const IDvdInfo2,
            ulTitle: u32,
            pulParentalLevels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDVDDirectory: fn(
            self: *const IDvdInfo2,
            pszwPath: [*:0]u16,
            ulMaxSize: u32,
            pulActualSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAudioStreamEnabled: fn(
            self: *const IDvdInfo2,
            ulStreamNum: u32,
            pbEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDiscID: fn(
            self: *const IDvdInfo2,
            pszwPath: ?[*:0]const u16,
            pullDiscID: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IDvdInfo2,
            pStateData: ?*?*IDvdState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMenuLanguages: fn(
            self: *const IDvdInfo2,
            pLanguages: ?*u32,
            ulMaxLanguages: u32,
            pulActualLanguages: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetButtonAtPosition: fn(
            self: *const IDvdInfo2,
            point: POINT,
            pulButtonIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCmdFromEvent: fn(
            self: *const IDvdInfo2,
            lParam1: isize,
            pCmdObj: ?*?*IDvdCmd,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultMenuLanguage: fn(
            self: *const IDvdInfo2,
            pLanguage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultAudioLanguage: fn(
            self: *const IDvdInfo2,
            pLanguage: ?*u32,
            pAudioExtension: ?*DVD_AUDIO_LANG_EXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultSubpictureLanguage: fn(
            self: *const IDvdInfo2,
            pLanguage: ?*u32,
            pSubpictureExtension: ?*DVD_SUBPICTURE_LANG_EXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDecoderCaps: fn(
            self: *const IDvdInfo2,
            pCaps: ?*DVD_DECODER_CAPS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetButtonRect: fn(
            self: *const IDvdInfo2,
            ulButton: u32,
            pRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubpictureStreamEnabled: fn(
            self: *const IDvdInfo2,
            ulStreamNum: u32,
            pbEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentDomain(self: *const T, pDomain: ?*DVD_DOMAIN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetCurrentDomain(@ptrCast(*const IDvdInfo2, self), pDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentLocation(self: *const T, pLocation: ?*DVD_PLAYBACK_LOCATION2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetCurrentLocation(@ptrCast(*const IDvdInfo2, self), pLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetTotalTitleTime(self: *const T, pTotalTime: ?*DVD_HMSF_TIMECODE, ulTimeCodeFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetTotalTitleTime(@ptrCast(*const IDvdInfo2, self), pTotalTime, ulTimeCodeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentButton(self: *const T, pulButtonsAvailable: ?*u32, pulCurrentButton: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetCurrentButton(@ptrCast(*const IDvdInfo2, self), pulButtonsAvailable, pulCurrentButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentAngle(self: *const T, pulAnglesAvailable: ?*u32, pulCurrentAngle: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetCurrentAngle(@ptrCast(*const IDvdInfo2, self), pulAnglesAvailable, pulCurrentAngle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentAudio(self: *const T, pulStreamsAvailable: ?*u32, pulCurrentStream: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetCurrentAudio(@ptrCast(*const IDvdInfo2, self), pulStreamsAvailable, pulCurrentStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentSubpicture(self: *const T, pulStreamsAvailable: ?*u32, pulCurrentStream: ?*u32, pbIsDisabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetCurrentSubpicture(@ptrCast(*const IDvdInfo2, self), pulStreamsAvailable, pulCurrentStream, pbIsDisabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentUOPS(self: *const T, pulUOPs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetCurrentUOPS(@ptrCast(*const IDvdInfo2, self), pulUOPs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetAllSPRMs(self: *const T, pRegisterArray: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetAllSPRMs(@ptrCast(*const IDvdInfo2, self), pRegisterArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetAllGPRMs(self: *const T, pRegisterArray: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetAllGPRMs(@ptrCast(*const IDvdInfo2, self), pRegisterArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetAudioLanguage(self: *const T, ulStream: u32, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetAudioLanguage(@ptrCast(*const IDvdInfo2, self), ulStream, pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetSubpictureLanguage(self: *const T, ulStream: u32, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetSubpictureLanguage(@ptrCast(*const IDvdInfo2, self), ulStream, pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetTitleAttributes(self: *const T, ulTitle: u32, pMenu: ?*DVD_MenuAttributes, pTitle: ?*DVD_TitleAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetTitleAttributes(@ptrCast(*const IDvdInfo2, self), ulTitle, pMenu, pTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetVMGAttributes(self: *const T, pATR: ?*DVD_MenuAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetVMGAttributes(@ptrCast(*const IDvdInfo2, self), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentVideoAttributes(self: *const T, pATR: ?*DVD_VideoAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetCurrentVideoAttributes(@ptrCast(*const IDvdInfo2, self), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetAudioAttributes(self: *const T, ulStream: u32, pATR: ?*DVD_AudioAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetAudioAttributes(@ptrCast(*const IDvdInfo2, self), ulStream, pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetKaraokeAttributes(self: *const T, ulStream: u32, pAttributes: ?*DVD_KaraokeAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetKaraokeAttributes(@ptrCast(*const IDvdInfo2, self), ulStream, pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetSubpictureAttributes(self: *const T, ulStream: u32, pATR: ?*DVD_SubpictureAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetSubpictureAttributes(@ptrCast(*const IDvdInfo2, self), ulStream, pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDVolumeInfo(self: *const T, pulNumOfVolumes: ?*u32, pulVolume: ?*u32, pSide: ?*DVD_DISC_SIDE, pulNumOfTitles: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDVDVolumeInfo(@ptrCast(*const IDvdInfo2, self), pulNumOfVolumes, pulVolume, pSide, pulNumOfTitles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDTextNumberOfLanguages(self: *const T, pulNumOfLangs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDVDTextNumberOfLanguages(@ptrCast(*const IDvdInfo2, self), pulNumOfLangs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDTextLanguageInfo(self: *const T, ulLangIndex: u32, pulNumOfStrings: ?*u32, pLangCode: ?*u32, pbCharacterSet: ?*DVD_TextCharSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDVDTextLanguageInfo(@ptrCast(*const IDvdInfo2, self), ulLangIndex, pulNumOfStrings, pLangCode, pbCharacterSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDTextStringAsNative(self: *const T, ulLangIndex: u32, ulStringIndex: u32, pbBuffer: ?*u8, ulMaxBufferSize: u32, pulActualSize: ?*u32, pType: ?*DVD_TextStringType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDVDTextStringAsNative(@ptrCast(*const IDvdInfo2, self), ulLangIndex, ulStringIndex, pbBuffer, ulMaxBufferSize, pulActualSize, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDTextStringAsUnicode(self: *const T, ulLangIndex: u32, ulStringIndex: u32, pchwBuffer: ?PWSTR, ulMaxBufferSize: u32, pulActualSize: ?*u32, pType: ?*DVD_TextStringType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDVDTextStringAsUnicode(@ptrCast(*const IDvdInfo2, self), ulLangIndex, ulStringIndex, pchwBuffer, ulMaxBufferSize, pulActualSize, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetPlayerParentalLevel(self: *const T, pulParentalLevel: ?*u32, pbCountryCode: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetPlayerParentalLevel(@ptrCast(*const IDvdInfo2, self), pulParentalLevel, pbCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetNumberOfChapters(self: *const T, ulTitle: u32, pulNumOfChapters: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetNumberOfChapters(@ptrCast(*const IDvdInfo2, self), ulTitle, pulNumOfChapters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetTitleParentalLevels(self: *const T, ulTitle: u32, pulParentalLevels: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetTitleParentalLevels(@ptrCast(*const IDvdInfo2, self), ulTitle, pulParentalLevels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDDirectory(self: *const T, pszwPath: [*:0]u16, ulMaxSize: u32, pulActualSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDVDDirectory(@ptrCast(*const IDvdInfo2, self), pszwPath, ulMaxSize, pulActualSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_IsAudioStreamEnabled(self: *const T, ulStreamNum: u32, pbEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).IsAudioStreamEnabled(@ptrCast(*const IDvdInfo2, self), ulStreamNum, pbEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDiscID(self: *const T, pszwPath: ?[*:0]const u16, pullDiscID: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDiscID(@ptrCast(*const IDvdInfo2, self), pszwPath, pullDiscID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetState(self: *const T, pStateData: ?*?*IDvdState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetState(@ptrCast(*const IDvdInfo2, self), pStateData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetMenuLanguages(self: *const T, pLanguages: ?*u32, ulMaxLanguages: u32, pulActualLanguages: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetMenuLanguages(@ptrCast(*const IDvdInfo2, self), pLanguages, ulMaxLanguages, pulActualLanguages);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetButtonAtPosition(self: *const T, point: POINT, pulButtonIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetButtonAtPosition(@ptrCast(*const IDvdInfo2, self), point, pulButtonIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCmdFromEvent(self: *const T, lParam1: isize, pCmdObj: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetCmdFromEvent(@ptrCast(*const IDvdInfo2, self), lParam1, pCmdObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDefaultMenuLanguage(self: *const T, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDefaultMenuLanguage(@ptrCast(*const IDvdInfo2, self), pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDefaultAudioLanguage(self: *const T, pLanguage: ?*u32, pAudioExtension: ?*DVD_AUDIO_LANG_EXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDefaultAudioLanguage(@ptrCast(*const IDvdInfo2, self), pLanguage, pAudioExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDefaultSubpictureLanguage(self: *const T, pLanguage: ?*u32, pSubpictureExtension: ?*DVD_SUBPICTURE_LANG_EXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDefaultSubpictureLanguage(@ptrCast(*const IDvdInfo2, self), pLanguage, pSubpictureExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDecoderCaps(self: *const T, pCaps: ?*DVD_DECODER_CAPS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetDecoderCaps(@ptrCast(*const IDvdInfo2, self), pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetButtonRect(self: *const T, ulButton: u32, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).GetButtonRect(@ptrCast(*const IDvdInfo2, self), ulButton, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_IsSubpictureStreamEnabled(self: *const T, ulStreamNum: u32, pbEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdInfo2.VTable, self.vtable).IsSubpictureStreamEnabled(@ptrCast(*const IDvdInfo2, self), ulStreamNum, pbEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_DVD_GRAPH_FLAGS = enum(i32) {
    HWDEC_PREFER = 1,
    HWDEC_ONLY = 2,
    SWDEC_PREFER = 4,
    SWDEC_ONLY = 8,
    NOVPE = 256,
    DO_NOT_CLEAR = 512,
    VMR9_ONLY = 2048,
    EVR_ONLY = 4096,
    EVR_QOS = 8192,
    ADAPT_GRAPH = 16384,
    MASK = 65535,
};
pub const AM_DVD_HWDEC_PREFER = AM_DVD_GRAPH_FLAGS.HWDEC_PREFER;
pub const AM_DVD_HWDEC_ONLY = AM_DVD_GRAPH_FLAGS.HWDEC_ONLY;
pub const AM_DVD_SWDEC_PREFER = AM_DVD_GRAPH_FLAGS.SWDEC_PREFER;
pub const AM_DVD_SWDEC_ONLY = AM_DVD_GRAPH_FLAGS.SWDEC_ONLY;
pub const AM_DVD_NOVPE = AM_DVD_GRAPH_FLAGS.NOVPE;
pub const AM_DVD_DO_NOT_CLEAR = AM_DVD_GRAPH_FLAGS.DO_NOT_CLEAR;
pub const AM_DVD_VMR9_ONLY = AM_DVD_GRAPH_FLAGS.VMR9_ONLY;
pub const AM_DVD_EVR_ONLY = AM_DVD_GRAPH_FLAGS.EVR_ONLY;
pub const AM_DVD_EVR_QOS = AM_DVD_GRAPH_FLAGS.EVR_QOS;
pub const AM_DVD_ADAPT_GRAPH = AM_DVD_GRAPH_FLAGS.ADAPT_GRAPH;
pub const AM_DVD_MASK = AM_DVD_GRAPH_FLAGS.MASK;

pub const AM_DVD_STREAM_FLAGS = enum(i32) {
    VIDEO = 1,
    AUDIO = 2,
    SUBPIC = 4,
};
pub const AM_DVD_STREAM_VIDEO = AM_DVD_STREAM_FLAGS.VIDEO;
pub const AM_DVD_STREAM_AUDIO = AM_DVD_STREAM_FLAGS.AUDIO;
pub const AM_DVD_STREAM_SUBPIC = AM_DVD_STREAM_FLAGS.SUBPIC;

pub const AM_DVD_RENDERSTATUS = extern struct {
    hrVPEStatus: HRESULT,
    bDvdVolInvalid: BOOL,
    bDvdVolUnknown: BOOL,
    bNoLine21In: BOOL,
    bNoLine21Out: BOOL,
    iNumStreams: i32,
    iNumStreamsFailed: i32,
    dwFailedStreamsFlag: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDvdGraphBuilder_Value = @import("../zig.zig").Guid.initString("fcc152b6-f372-11d0-8e00-00c04fd7c08b");
pub const IID_IDvdGraphBuilder = &IID_IDvdGraphBuilder_Value;
pub const IDvdGraphBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFiltergraph: fn(
            self: *const IDvdGraphBuilder,
            ppGB: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDvdInterface: fn(
            self: *const IDvdGraphBuilder,
            riid: ?*const Guid,
            ppvIF: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderDvdVideoVolume: fn(
            self: *const IDvdGraphBuilder,
            lpcwszPathName: ?[*:0]const u16,
            dwFlags: u32,
            pStatus: ?*AM_DVD_RENDERSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdGraphBuilder_GetFiltergraph(self: *const T, ppGB: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdGraphBuilder.VTable, self.vtable).GetFiltergraph(@ptrCast(*const IDvdGraphBuilder, self), ppGB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdGraphBuilder_GetDvdInterface(self: *const T, riid: ?*const Guid, ppvIF: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdGraphBuilder.VTable, self.vtable).GetDvdInterface(@ptrCast(*const IDvdGraphBuilder, self), riid, ppvIF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdGraphBuilder_RenderDvdVideoVolume(self: *const T, lpcwszPathName: ?[*:0]const u16, dwFlags: u32, pStatus: ?*AM_DVD_RENDERSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvdGraphBuilder.VTable, self.vtable).RenderDvdVideoVolume(@ptrCast(*const IDvdGraphBuilder, self), lpcwszPathName, dwFlags, pStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDDrawExclModeVideo_Value = @import("../zig.zig").Guid.initString("153acc21-d83b-11d1-82bf-00a0c9696c8f");
pub const IID_IDDrawExclModeVideo = &IID_IDDrawExclModeVideo_Value;
pub const IDDrawExclModeVideo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDDrawObject: fn(
            self: *const IDDrawExclModeVideo,
            pDDrawObject: ?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDDrawObject: fn(
            self: *const IDDrawExclModeVideo,
            ppDDrawObject: ?*?*IDirectDraw,
            pbUsingExternal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDDrawSurface: fn(
            self: *const IDDrawExclModeVideo,
            pDDrawSurface: ?*IDirectDrawSurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDDrawSurface: fn(
            self: *const IDDrawExclModeVideo,
            ppDDrawSurface: ?*?*IDirectDrawSurface,
            pbUsingExternal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDrawParameters: fn(
            self: *const IDDrawExclModeVideo,
            prcSource: ?*const RECT,
            prcTarget: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNativeVideoProps: fn(
            self: *const IDDrawExclModeVideo,
            pdwVideoWidth: ?*u32,
            pdwVideoHeight: ?*u32,
            pdwPictAspectRatioX: ?*u32,
            pdwPictAspectRatioY: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCallbackInterface: fn(
            self: *const IDDrawExclModeVideo,
            pCallback: ?*IDDrawExclModeVideoCallback,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_SetDDrawObject(self: *const T, pDDrawObject: ?*IDirectDraw) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideo.VTable, self.vtable).SetDDrawObject(@ptrCast(*const IDDrawExclModeVideo, self), pDDrawObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_GetDDrawObject(self: *const T, ppDDrawObject: ?*?*IDirectDraw, pbUsingExternal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideo.VTable, self.vtable).GetDDrawObject(@ptrCast(*const IDDrawExclModeVideo, self), ppDDrawObject, pbUsingExternal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_SetDDrawSurface(self: *const T, pDDrawSurface: ?*IDirectDrawSurface) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideo.VTable, self.vtable).SetDDrawSurface(@ptrCast(*const IDDrawExclModeVideo, self), pDDrawSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_GetDDrawSurface(self: *const T, ppDDrawSurface: ?*?*IDirectDrawSurface, pbUsingExternal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideo.VTable, self.vtable).GetDDrawSurface(@ptrCast(*const IDDrawExclModeVideo, self), ppDDrawSurface, pbUsingExternal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_SetDrawParameters(self: *const T, prcSource: ?*const RECT, prcTarget: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideo.VTable, self.vtable).SetDrawParameters(@ptrCast(*const IDDrawExclModeVideo, self), prcSource, prcTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_GetNativeVideoProps(self: *const T, pdwVideoWidth: ?*u32, pdwVideoHeight: ?*u32, pdwPictAspectRatioX: ?*u32, pdwPictAspectRatioY: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideo.VTable, self.vtable).GetNativeVideoProps(@ptrCast(*const IDDrawExclModeVideo, self), pdwVideoWidth, pdwVideoHeight, pdwPictAspectRatioX, pdwPictAspectRatioY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_SetCallbackInterface(self: *const T, pCallback: ?*IDDrawExclModeVideoCallback, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideo.VTable, self.vtable).SetCallbackInterface(@ptrCast(*const IDDrawExclModeVideo, self), pCallback, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_OVERLAY_NOTIFY_FLAGS = enum(i32) {
    VISIBLE_CHANGE = 1,
    SOURCE_CHANGE = 2,
    DEST_CHANGE = 4,
};
pub const AM_OVERLAY_NOTIFY_VISIBLE_CHANGE = _AM_OVERLAY_NOTIFY_FLAGS.VISIBLE_CHANGE;
pub const AM_OVERLAY_NOTIFY_SOURCE_CHANGE = _AM_OVERLAY_NOTIFY_FLAGS.SOURCE_CHANGE;
pub const AM_OVERLAY_NOTIFY_DEST_CHANGE = _AM_OVERLAY_NOTIFY_FLAGS.DEST_CHANGE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDDrawExclModeVideoCallback_Value = @import("../zig.zig").Guid.initString("913c24a0-20ab-11d2-9038-00a0c9697298");
pub const IID_IDDrawExclModeVideoCallback = &IID_IDDrawExclModeVideoCallback_Value;
pub const IDDrawExclModeVideoCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateOverlay: fn(
            self: *const IDDrawExclModeVideoCallback,
            bBefore: BOOL,
            dwFlags: u32,
            bOldVisible: BOOL,
            prcOldSrc: ?*const RECT,
            prcOldDest: ?*const RECT,
            bNewVisible: BOOL,
            prcNewSrc: ?*const RECT,
            prcNewDest: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUpdateColorKey: fn(
            self: *const IDDrawExclModeVideoCallback,
            pKey: ?*const COLORKEY,
            dwColor: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUpdateSize: fn(
            self: *const IDDrawExclModeVideoCallback,
            dwWidth: u32,
            dwHeight: u32,
            dwARWidth: u32,
            dwARHeight: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideoCallback_OnUpdateOverlay(self: *const T, bBefore: BOOL, dwFlags: u32, bOldVisible: BOOL, prcOldSrc: ?*const RECT, prcOldDest: ?*const RECT, bNewVisible: BOOL, prcNewSrc: ?*const RECT, prcNewDest: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideoCallback.VTable, self.vtable).OnUpdateOverlay(@ptrCast(*const IDDrawExclModeVideoCallback, self), bBefore, dwFlags, bOldVisible, prcOldSrc, prcOldDest, bNewVisible, prcNewSrc, prcNewDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideoCallback_OnUpdateColorKey(self: *const T, pKey: ?*const COLORKEY, dwColor: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideoCallback.VTable, self.vtable).OnUpdateColorKey(@ptrCast(*const IDDrawExclModeVideoCallback, self), pKey, dwColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideoCallback_OnUpdateSize(self: *const T, dwWidth: u32, dwHeight: u32, dwARWidth: u32, dwARHeight: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDDrawExclModeVideoCallback.VTable, self.vtable).OnUpdateSize(@ptrCast(*const IDDrawExclModeVideoCallback, self), dwWidth, dwHeight, dwARWidth, dwARHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BDA_TEMPLATE_CONNECTION = extern struct {
    FromNodeType: u32,
    FromNodePinType: u32,
    ToNodeType: u32,
    ToNodePinType: u32,
};

pub const BDA_TEMPLATE_PIN_JOINT = extern struct {
    uliTemplateConnection: u32,
    ulcInstancesMax: u32,
};

pub const BDA_EVENT_ID = enum(i32) {
    SIGNAL_LOSS = 0,
    SIGNAL_LOCK = 1,
    DATA_START = 2,
    DATA_STOP = 3,
    CHANNEL_ACQUIRED = 4,
    CHANNEL_LOST = 5,
    CHANNEL_SOURCE_CHANGED = 6,
    CHANNEL_ACTIVATED = 7,
    CHANNEL_DEACTIVATED = 8,
    SUBCHANNEL_ACQUIRED = 9,
    SUBCHANNEL_LOST = 10,
    SUBCHANNEL_SOURCE_CHANGED = 11,
    SUBCHANNEL_ACTIVATED = 12,
    SUBCHANNEL_DEACTIVATED = 13,
    ACCESS_GRANTED = 14,
    ACCESS_DENIED = 15,
    OFFER_EXTENDED = 16,
    PURCHASE_COMPLETED = 17,
    SMART_CARD_INSERTED = 18,
    SMART_CARD_REMOVED = 19,
};
pub const BDA_EVENT_SIGNAL_LOSS = BDA_EVENT_ID.SIGNAL_LOSS;
pub const BDA_EVENT_SIGNAL_LOCK = BDA_EVENT_ID.SIGNAL_LOCK;
pub const BDA_EVENT_DATA_START = BDA_EVENT_ID.DATA_START;
pub const BDA_EVENT_DATA_STOP = BDA_EVENT_ID.DATA_STOP;
pub const BDA_EVENT_CHANNEL_ACQUIRED = BDA_EVENT_ID.CHANNEL_ACQUIRED;
pub const BDA_EVENT_CHANNEL_LOST = BDA_EVENT_ID.CHANNEL_LOST;
pub const BDA_EVENT_CHANNEL_SOURCE_CHANGED = BDA_EVENT_ID.CHANNEL_SOURCE_CHANGED;
pub const BDA_EVENT_CHANNEL_ACTIVATED = BDA_EVENT_ID.CHANNEL_ACTIVATED;
pub const BDA_EVENT_CHANNEL_DEACTIVATED = BDA_EVENT_ID.CHANNEL_DEACTIVATED;
pub const BDA_EVENT_SUBCHANNEL_ACQUIRED = BDA_EVENT_ID.SUBCHANNEL_ACQUIRED;
pub const BDA_EVENT_SUBCHANNEL_LOST = BDA_EVENT_ID.SUBCHANNEL_LOST;
pub const BDA_EVENT_SUBCHANNEL_SOURCE_CHANGED = BDA_EVENT_ID.SUBCHANNEL_SOURCE_CHANGED;
pub const BDA_EVENT_SUBCHANNEL_ACTIVATED = BDA_EVENT_ID.SUBCHANNEL_ACTIVATED;
pub const BDA_EVENT_SUBCHANNEL_DEACTIVATED = BDA_EVENT_ID.SUBCHANNEL_DEACTIVATED;
pub const BDA_EVENT_ACCESS_GRANTED = BDA_EVENT_ID.ACCESS_GRANTED;
pub const BDA_EVENT_ACCESS_DENIED = BDA_EVENT_ID.ACCESS_DENIED;
pub const BDA_EVENT_OFFER_EXTENDED = BDA_EVENT_ID.OFFER_EXTENDED;
pub const BDA_EVENT_PURCHASE_COMPLETED = BDA_EVENT_ID.PURCHASE_COMPLETED;
pub const BDA_EVENT_SMART_CARD_INSERTED = BDA_EVENT_ID.SMART_CARD_INSERTED;
pub const BDA_EVENT_SMART_CARD_REMOVED = BDA_EVENT_ID.SMART_CARD_REMOVED;

pub const KS_BDA_FRAME_INFO = extern struct {
    ExtendedHeaderSize: u32,
    dwFrameFlags: u32,
    ulEvent: u32,
    ulChannelNumber: u32,
    ulSubchannelNumber: u32,
    ulReason: u32,
};

pub const BDA_ETHERNET_ADDRESS = extern struct {
    rgbAddress: [6]u8,
};

pub const BDA_ETHERNET_ADDRESS_LIST = extern struct {
    ulcAddresses: u32,
    rgAddressl: [1]BDA_ETHERNET_ADDRESS,
};

pub const BDA_MULTICAST_MODE = enum(i32) {
    PROMISCUOUS_MULTICAST = 0,
    FILTERED_MULTICAST = 1,
    NO_MULTICAST = 2,
};
pub const BDA_PROMISCUOUS_MULTICAST = BDA_MULTICAST_MODE.PROMISCUOUS_MULTICAST;
pub const BDA_FILTERED_MULTICAST = BDA_MULTICAST_MODE.FILTERED_MULTICAST;
pub const BDA_NO_MULTICAST = BDA_MULTICAST_MODE.NO_MULTICAST;

pub const BDA_IPv4_ADDRESS = extern struct {
    rgbAddress: [4]u8,
};

pub const BDA_IPv4_ADDRESS_LIST = extern struct {
    ulcAddresses: u32,
    rgAddressl: [1]BDA_IPv4_ADDRESS,
};

pub const BDA_IPv6_ADDRESS = extern struct {
    rgbAddress: [6]u8,
};

pub const BDA_IPv6_ADDRESS_LIST = extern struct {
    ulcAddresses: u32,
    rgAddressl: [1]BDA_IPv6_ADDRESS,
};

pub const BDA_SIGNAL_STATE = enum(i32) {
    UNAVAILABLE = 0,
    INACTIVE = 1,
    ACTIVE = 2,
};
pub const BDA_SIGNAL_UNAVAILABLE = BDA_SIGNAL_STATE.UNAVAILABLE;
pub const BDA_SIGNAL_INACTIVE = BDA_SIGNAL_STATE.INACTIVE;
pub const BDA_SIGNAL_ACTIVE = BDA_SIGNAL_STATE.ACTIVE;

pub const BDA_CHANGE_STATE = enum(i32) {
    COMPLETE = 0,
    PENDING = 1,
};
pub const BDA_CHANGES_COMPLETE = BDA_CHANGE_STATE.COMPLETE;
pub const BDA_CHANGES_PENDING = BDA_CHANGE_STATE.PENDING;

pub const BDANODE_DESCRIPTOR = extern struct {
    ulBdaNodeType: u32,
    guidFunction: Guid,
    guidName: Guid,
};

pub const BDA_TABLE_SECTION = extern struct {
    ulPrimarySectionId: u32,
    ulSecondarySectionId: u32,
    ulcbSectionLength: u32,
    argbSectionData: [1]u32,
};

pub const BDA_DISEQC_SEND = extern struct {
    ulRequestId: u32,
    ulPacketLength: u32,
    argbPacketData: [8]u8,
};

pub const BDA_DISEQC_RESPONSE = extern struct {
    ulRequestId: u32,
    ulPacketLength: u32,
    argbPacketData: [8]u8,
};

pub const MEDIA_SAMPLE_CONTENT = enum(i32) {
    TRANSPORT_PACKET = 0,
    ELEMENTARY_STREAM = 1,
    MPEG2_PSI = 2,
    TRANSPORT_PAYLOAD = 3,
};
pub const MEDIA_TRANSPORT_PACKET = MEDIA_SAMPLE_CONTENT.TRANSPORT_PACKET;
pub const MEDIA_ELEMENTARY_STREAM = MEDIA_SAMPLE_CONTENT.ELEMENTARY_STREAM;
pub const MEDIA_MPEG2_PSI = MEDIA_SAMPLE_CONTENT.MPEG2_PSI;
pub const MEDIA_TRANSPORT_PAYLOAD = MEDIA_SAMPLE_CONTENT.TRANSPORT_PAYLOAD;

pub const PID_MAP = extern struct {
    ulPID: u32,
    MediaSampleContent: MEDIA_SAMPLE_CONTENT,
};

pub const BDA_PID_MAP = extern struct {
    MediaSampleContent: MEDIA_SAMPLE_CONTENT,
    ulcPIDs: u32,
    aulPIDs: [1]u32,
};

pub const BDA_PID_UNMAP = extern struct {
    ulcPIDs: u32,
    aulPIDs: [1]u32,
};

pub const BDA_CA_MODULE_UI = extern struct {
    ulFormat: u32,
    ulbcDesc: u32,
    ulDesc: [1]u32,
};

pub const BDA_PROGRAM_PID_LIST = extern struct {
    ulProgramNumber: u32,
    ulcPIDs: u32,
    ulPID: [1]u32,
};

pub const BDA_DRM_DRMSTATUS = extern struct {
    lResult: i32,
    DRMuuid: Guid,
    ulDrmUuidListStringSize: u32,
    argbDrmUuidListString: [1]Guid,
};

pub const BDA_WMDRM_STATUS = extern struct {
    lResult: i32,
    ulMaxCaptureTokenSize: u32,
    uMaxStreamingPid: u32,
    ulMaxLicense: u32,
    ulMinSecurityLevel: u32,
    ulRevInfoSequenceNumber: u32,
    ulRevInfoIssuedTime: u64,
    ulRevListVersion: u32,
    ulRevInfoTTL: u32,
    ulState: u32,
};

pub const BDA_WMDRM_KEYINFOLIST = extern struct {
    lResult: i32,
    ulKeyuuidBufferLen: u32,
    argKeyuuidBuffer: [1]Guid,
};

pub const BDA_BUFFER = extern struct {
    lResult: i32,
    ulBufferSize: u32,
    argbBuffer: [1]u8,
};

pub const BDA_WMDRM_RENEWLICENSE = extern struct {
    lResult: i32,
    ulDescrambleStatus: u32,
    ulXmrLicenseOutputLength: u32,
    argbXmrLicenceOutputBuffer: [1]u8,
};

pub const BDA_WMDRMTUNER_PIDPROTECTION = extern struct {
    lResult: i32,
    uuidKeyID: Guid,
};

pub const BDA_WMDRMTUNER_PURCHASEENTITLEMENT = extern struct {
    lResult: i32,
    ulDescrambleStatus: u32,
    ulCaptureTokenLength: u32,
    argbCaptureTokenBuffer: [1]u8,
};

pub const BDA_TUNER_TUNERSTATE = extern struct {
    lResult: i32,
    ulTuneLength: u32,
    argbTuneData: [1]u8,
};

pub const BDA_TUNER_DIAGNOSTICS = extern struct {
    lResult: i32,
    ulSignalLevel: u32,
    ulSignalLevelQuality: u32,
    ulSignalNoiseRatio: u32,
};

pub const BDA_STRING = extern struct {
    lResult: i32,
    ulStringSize: u32,
    argbString: [1]u8,
};

pub const BDA_SCAN_CAPABILTIES = extern struct {
    lResult: i32,
    ul64AnalogStandardsSupported: u64,
};

pub const BDA_SCAN_STATE = extern struct {
    lResult: i32,
    ulSignalLock: u32,
    ulSecondsLeft: u32,
    ulCurrentFrequency: u32,
};

pub const BDA_SCAN_START = extern struct {
    lResult: i32,
    LowerFrequency: u32,
    HigerFrequency: u32,
};

pub const BDA_GDDS_DATATYPE = extern struct {
    lResult: i32,
    uuidDataType: Guid,
};

pub const BDA_GDDS_DATA = extern struct {
    lResult: i32,
    ulDataLength: u32,
    ulPercentageProgress: u32,
    argbData: [1]u8,
};

pub const BDA_USERACTIVITY_INTERVAL = extern struct {
    lResult: i32,
    ulActivityInterval: u32,
};

pub const BDA_CAS_CHECK_ENTITLEMENTTOKEN = extern struct {
    lResult: i32,
    ulDescrambleStatus: u32,
};

pub const BDA_CAS_CLOSE_MMIDIALOG = extern struct {
    lResult: i32,
    SessionResult: u32,
};

pub const BDA_CAS_REQUESTTUNERDATA = extern struct {
    ucRequestPriority: u8,
    ucRequestReason: u8,
    ucRequestConsequences: u8,
    ulEstimatedTime: u32,
};

pub const BDA_CAS_OPENMMIDATA = extern struct {
    ulDialogNumber: u32,
    ulDialogRequest: u32,
    uuidDialogType: Guid,
    usDialogDataLength: u16,
    argbDialogData: [1]u8,
};

pub const BDA_CAS_CLOSEMMIDATA = extern struct {
    ulDialogNumber: u32,
};

pub const ISDBCAS_REQUEST_ID = enum(i32) {
    G = 56,
    D = 58,
};
pub const ISDBCAS_REQUEST_ID_EMG = ISDBCAS_REQUEST_ID.G;
pub const ISDBCAS_REQUEST_ID_EMD = ISDBCAS_REQUEST_ID.D;

pub const BDA_ISDBCAS_REQUESTHEADER = packed struct {
    bInstruction: u8,
    bReserved: [3]u8,
    ulDataLength: u32,
    argbIsdbCommand: [1]u8,
};

pub const BDA_ISDBCAS_RESPONSEDATA = packed struct {
    lResult: i32,
    ulRequestID: u32,
    ulIsdbStatus: u32,
    ulIsdbDataSize: u32,
    argbIsdbCommandData: [1]u8,
};

pub const BDA_ISDBCAS_EMG_REQ = extern struct {
    bCLA: u8,
    bINS: u8,
    bP1: u8,
    bP2: u8,
    bLC: u8,
    bCardId: [6]u8,
    bProtocol: u8,
    bCABroadcasterGroupId: u8,
    bMessageControl: u8,
    bMessageCode: [1]u8,
};

pub const MUX_PID_TYPE = enum(i32) {
    OTHER = -1,
    ELEMENTARY_STREAM = 0,
    MPEG2_SECTION_PSI_SI = 1,
};
pub const PID_OTHER = MUX_PID_TYPE.OTHER;
pub const PID_ELEMENTARY_STREAM = MUX_PID_TYPE.ELEMENTARY_STREAM;
pub const PID_MPEG2_SECTION_PSI_SI = MUX_PID_TYPE.MPEG2_SECTION_PSI_SI;

pub const BDA_MUX_PIDLISTITEM = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    usPIDNumber: u16,
    usProgramNumber: u16,
    ePIDType: MUX_PID_TYPE,
};

pub const BDA_TS_SELECTORINFO = packed struct {
    bTSInfolength: u8,
    bReserved: [2]u8,
    guidNetworkType: Guid,
    bTSIDCount: u8,
    usTSID: [1]u16,
};

pub const BDA_TS_SELECTORINFO_ISDBS_EXT = extern struct {
    bTMCC: [48]u8,
};

pub const BDA_DVBT2_L1_SIGNALLING_DATA = extern struct {
    L1Pre_TYPE: u8,
    L1Pre_BWT_S1_S2: u8,
    L1Pre_REPETITION_GUARD_PAPR: u8,
    L1Pre_MOD_COD_FEC: u8,
    L1Pre_POSTSIZE_INFO_PILOT: [5]u8,
    L1Pre_TX_ID_AVAIL: u8,
    L1Pre_CELL_ID: [2]u8,
    L1Pre_NETWORK_ID: [2]u8,
    L1Pre_T2SYSTEM_ID: [2]u8,
    L1Pre_NUM_T2_FRAMES: u8,
    L1Pre_NUM_DATA_REGENFLAG_L1POSTEXT: [2]u8,
    L1Pre_NUMRF_CURRENTRF_RESERVED: [2]u8,
    L1Pre_CRC32: [4]u8,
    L1PostData: [1]u8,
};

pub const BDA_RATING_PINRESET = extern struct {
    bPinLength: u8,
    argbNewPin: [1]u8,
};

pub const DVBSystemType = enum(i32) {
    DVB_Cable = 0,
    DVB_Terrestrial = 1,
    DVB_Satellite = 2,
    ISDB_Terrestrial = 3,
    ISDB_Satellite = 4,
};
pub const DVB_Cable = DVBSystemType.DVB_Cable;
pub const DVB_Terrestrial = DVBSystemType.DVB_Terrestrial;
pub const DVB_Satellite = DVBSystemType.DVB_Satellite;
pub const ISDB_Terrestrial = DVBSystemType.ISDB_Terrestrial;
pub const ISDB_Satellite = DVBSystemType.ISDB_Satellite;

pub const BDA_Channel = enum(i32) {
    L = -1,
};
pub const BDA_UNDEFINED_CHANNEL = BDA_Channel.L;

pub const ComponentCategory = enum(i32) {
    ategoryNotSet = -1,
    ategoryOther = 0,
    ategoryVideo = 1,
    ategoryAudio = 2,
    ategoryText = 3,
    ategorySubtitles = 4,
    ategoryCaptions = 5,
    ategorySuperimpose = 6,
    ategoryData = 7,
    ATEGORY_COUNT = 8,
};
pub const CategoryNotSet = ComponentCategory.ategoryNotSet;
pub const CategoryOther = ComponentCategory.ategoryOther;
pub const CategoryVideo = ComponentCategory.ategoryVideo;
pub const CategoryAudio = ComponentCategory.ategoryAudio;
pub const CategoryText = ComponentCategory.ategoryText;
pub const CategorySubtitles = ComponentCategory.ategorySubtitles;
pub const CategoryCaptions = ComponentCategory.ategoryCaptions;
pub const CategorySuperimpose = ComponentCategory.ategorySuperimpose;
pub const CategoryData = ComponentCategory.ategoryData;
pub const CATEGORY_COUNT = ComponentCategory.ATEGORY_COUNT;

pub const ComponentStatus = enum(i32) {
    Active = 0,
    Inactive = 1,
    Unavailable = 2,
};
pub const StatusActive = ComponentStatus.Active;
pub const StatusInactive = ComponentStatus.Inactive;
pub const StatusUnavailable = ComponentStatus.Unavailable;

pub const MPEG2StreamType = enum(i32) {
    BDA_UNITIALIZED_MPEG2STREAMTYPE = -1,
    Reserved1 = 0,
    ISO_IEC_11172_2_VIDEO = 1,
    ISO_IEC_13818_2_VIDEO = 2,
    ISO_IEC_11172_3_AUDIO = 3,
    ISO_IEC_13818_3_AUDIO = 4,
    ISO_IEC_13818_1_PRIVATE_SECTION = 5,
    ISO_IEC_13818_1_PES = 6,
    ISO_IEC_13522_MHEG = 7,
    ANNEX_A_DSM_CC = 8,
    ITU_T_REC_H_222_1 = 9,
    ISO_IEC_13818_6_TYPE_A = 10,
    ISO_IEC_13818_6_TYPE_B = 11,
    ISO_IEC_13818_6_TYPE_C = 12,
    ISO_IEC_13818_6_TYPE_D = 13,
    ISO_IEC_13818_1_AUXILIARY = 14,
    ISO_IEC_13818_7_AUDIO = 15,
    ISO_IEC_14496_2_VISUAL = 16,
    ISO_IEC_14496_3_AUDIO = 17,
    ISO_IEC_14496_1_IN_PES = 18,
    ISO_IEC_14496_1_IN_SECTION = 19,
    ISO_IEC_13818_6_DOWNLOAD = 20,
    METADATA_IN_PES = 21,
    METADATA_IN_SECTION = 22,
    METADATA_IN_DATA_CAROUSEL = 23,
    METADATA_IN_OBJECT_CAROUSEL = 24,
    METADATA_IN_DOWNLOAD_PROTOCOL = 25,
    IRPM_STREAMM = 26,
    ITU_T_H264 = 27,
    ISO_IEC_13818_1_RESERVED = 28,
    // USER_PRIVATE = 16, this enum value conflicts with ISO_IEC_14496_2_VISUAL
    HEVC_VIDEO_OR_TEMPORAL_VIDEO = 36,
    HEVC_TEMPORAL_VIDEO_SUBSET = 37,
    ISO_IEC_USER_PRIVATE = 128,
    DOLBY_AC3_AUDIO = 129,
    DOLBY_DIGITAL_PLUS_AUDIO_ATSC = 135,
};
pub const BDA_UNITIALIZED_MPEG2STREAMTYPE = MPEG2StreamType.BDA_UNITIALIZED_MPEG2STREAMTYPE;
pub const Reserved1 = MPEG2StreamType.Reserved1;
pub const ISO_IEC_11172_2_VIDEO = MPEG2StreamType.ISO_IEC_11172_2_VIDEO;
pub const ISO_IEC_13818_2_VIDEO = MPEG2StreamType.ISO_IEC_13818_2_VIDEO;
pub const ISO_IEC_11172_3_AUDIO = MPEG2StreamType.ISO_IEC_11172_3_AUDIO;
pub const ISO_IEC_13818_3_AUDIO = MPEG2StreamType.ISO_IEC_13818_3_AUDIO;
pub const ISO_IEC_13818_1_PRIVATE_SECTION = MPEG2StreamType.ISO_IEC_13818_1_PRIVATE_SECTION;
pub const ISO_IEC_13818_1_PES = MPEG2StreamType.ISO_IEC_13818_1_PES;
pub const ISO_IEC_13522_MHEG = MPEG2StreamType.ISO_IEC_13522_MHEG;
pub const ANNEX_A_DSM_CC = MPEG2StreamType.ANNEX_A_DSM_CC;
pub const ITU_T_REC_H_222_1 = MPEG2StreamType.ITU_T_REC_H_222_1;
pub const ISO_IEC_13818_6_TYPE_A = MPEG2StreamType.ISO_IEC_13818_6_TYPE_A;
pub const ISO_IEC_13818_6_TYPE_B = MPEG2StreamType.ISO_IEC_13818_6_TYPE_B;
pub const ISO_IEC_13818_6_TYPE_C = MPEG2StreamType.ISO_IEC_13818_6_TYPE_C;
pub const ISO_IEC_13818_6_TYPE_D = MPEG2StreamType.ISO_IEC_13818_6_TYPE_D;
pub const ISO_IEC_13818_1_AUXILIARY = MPEG2StreamType.ISO_IEC_13818_1_AUXILIARY;
pub const ISO_IEC_13818_7_AUDIO = MPEG2StreamType.ISO_IEC_13818_7_AUDIO;
pub const ISO_IEC_14496_2_VISUAL = MPEG2StreamType.ISO_IEC_14496_2_VISUAL;
pub const ISO_IEC_14496_3_AUDIO = MPEG2StreamType.ISO_IEC_14496_3_AUDIO;
pub const ISO_IEC_14496_1_IN_PES = MPEG2StreamType.ISO_IEC_14496_1_IN_PES;
pub const ISO_IEC_14496_1_IN_SECTION = MPEG2StreamType.ISO_IEC_14496_1_IN_SECTION;
pub const ISO_IEC_13818_6_DOWNLOAD = MPEG2StreamType.ISO_IEC_13818_6_DOWNLOAD;
pub const METADATA_IN_PES = MPEG2StreamType.METADATA_IN_PES;
pub const METADATA_IN_SECTION = MPEG2StreamType.METADATA_IN_SECTION;
pub const METADATA_IN_DATA_CAROUSEL = MPEG2StreamType.METADATA_IN_DATA_CAROUSEL;
pub const METADATA_IN_OBJECT_CAROUSEL = MPEG2StreamType.METADATA_IN_OBJECT_CAROUSEL;
pub const METADATA_IN_DOWNLOAD_PROTOCOL = MPEG2StreamType.METADATA_IN_DOWNLOAD_PROTOCOL;
pub const IRPM_STREAMM = MPEG2StreamType.IRPM_STREAMM;
pub const ITU_T_H264 = MPEG2StreamType.ITU_T_H264;
pub const ISO_IEC_13818_1_RESERVED = MPEG2StreamType.ISO_IEC_13818_1_RESERVED;
pub const USER_PRIVATE = MPEG2StreamType.ISO_IEC_14496_2_VISUAL;
pub const HEVC_VIDEO_OR_TEMPORAL_VIDEO = MPEG2StreamType.HEVC_VIDEO_OR_TEMPORAL_VIDEO;
pub const HEVC_TEMPORAL_VIDEO_SUBSET = MPEG2StreamType.HEVC_TEMPORAL_VIDEO_SUBSET;
pub const ISO_IEC_USER_PRIVATE = MPEG2StreamType.ISO_IEC_USER_PRIVATE;
pub const DOLBY_AC3_AUDIO = MPEG2StreamType.DOLBY_AC3_AUDIO;
pub const DOLBY_DIGITAL_PLUS_AUDIO_ATSC = MPEG2StreamType.DOLBY_DIGITAL_PLUS_AUDIO_ATSC;

pub const MPEG2_TRANSPORT_STRIDE = extern struct {
    dwOffset: u32,
    dwPacketLength: u32,
    dwStride: u32,
};

pub const ATSCComponentTypeFlags = enum(i32) {
    @"3" = 1,
};
pub const ATSCCT_AC3 = ATSCComponentTypeFlags.@"3";

pub const BinaryConvolutionCodeRate = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"1_2" = 1,
    @"2_3" = 2,
    @"3_4" = 3,
    @"3_5" = 4,
    @"4_5" = 5,
    @"5_6" = 6,
    @"5_11" = 7,
    @"7_8" = 8,
    @"1_4" = 9,
    @"1_3" = 10,
    @"2_5" = 11,
    @"6_7" = 12,
    @"8_9" = 13,
    @"9_10" = 14,
    MAX = 15,
};
pub const BDA_BCC_RATE_NOT_SET = BinaryConvolutionCodeRate.NOT_SET;
pub const BDA_BCC_RATE_NOT_DEFINED = BinaryConvolutionCodeRate.NOT_DEFINED;
pub const BDA_BCC_RATE_1_2 = BinaryConvolutionCodeRate.@"1_2";
pub const BDA_BCC_RATE_2_3 = BinaryConvolutionCodeRate.@"2_3";
pub const BDA_BCC_RATE_3_4 = BinaryConvolutionCodeRate.@"3_4";
pub const BDA_BCC_RATE_3_5 = BinaryConvolutionCodeRate.@"3_5";
pub const BDA_BCC_RATE_4_5 = BinaryConvolutionCodeRate.@"4_5";
pub const BDA_BCC_RATE_5_6 = BinaryConvolutionCodeRate.@"5_6";
pub const BDA_BCC_RATE_5_11 = BinaryConvolutionCodeRate.@"5_11";
pub const BDA_BCC_RATE_7_8 = BinaryConvolutionCodeRate.@"7_8";
pub const BDA_BCC_RATE_1_4 = BinaryConvolutionCodeRate.@"1_4";
pub const BDA_BCC_RATE_1_3 = BinaryConvolutionCodeRate.@"1_3";
pub const BDA_BCC_RATE_2_5 = BinaryConvolutionCodeRate.@"2_5";
pub const BDA_BCC_RATE_6_7 = BinaryConvolutionCodeRate.@"6_7";
pub const BDA_BCC_RATE_8_9 = BinaryConvolutionCodeRate.@"8_9";
pub const BDA_BCC_RATE_9_10 = BinaryConvolutionCodeRate.@"9_10";
pub const BDA_BCC_RATE_MAX = BinaryConvolutionCodeRate.MAX;

pub const FECMethod = enum(i32) {
    METHOD_NOT_SET = -1,
    METHOD_NOT_DEFINED = 0,
    VITERBI = 1,
    RS_204_188 = 2,
    LDPC = 3,
    BCH = 4,
    RS_147_130 = 5,
    MAX = 6,
};
pub const BDA_FEC_METHOD_NOT_SET = FECMethod.METHOD_NOT_SET;
pub const BDA_FEC_METHOD_NOT_DEFINED = FECMethod.METHOD_NOT_DEFINED;
pub const BDA_FEC_VITERBI = FECMethod.VITERBI;
pub const BDA_FEC_RS_204_188 = FECMethod.RS_204_188;
pub const BDA_FEC_LDPC = FECMethod.LDPC;
pub const BDA_FEC_BCH = FECMethod.BCH;
pub const BDA_FEC_RS_147_130 = FECMethod.RS_147_130;
pub const BDA_FEC_MAX = FECMethod.MAX;

pub const ModulationType = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"16QAM" = 1,
    @"32QAM" = 2,
    @"64QAM" = 3,
    @"80QAM" = 4,
    @"96QAM" = 5,
    @"112QAM" = 6,
    @"128QAM" = 7,
    @"160QAM" = 8,
    @"192QAM" = 9,
    @"224QAM" = 10,
    @"256QAM" = 11,
    @"320QAM" = 12,
    @"384QAM" = 13,
    @"448QAM" = 14,
    @"512QAM" = 15,
    @"640QAM" = 16,
    @"768QAM" = 17,
    @"896QAM" = 18,
    @"1024QAM" = 19,
    QPSK = 20,
    BPSK = 21,
    OQPSK = 22,
    @"8VSB" = 23,
    @"16VSB" = 24,
    ANALOG_AMPLITUDE = 25,
    ANALOG_FREQUENCY = 26,
    @"8PSK" = 27,
    RF = 28,
    @"16APSK" = 29,
    @"32APSK" = 30,
    NBC_QPSK = 31,
    NBC_8PSK = 32,
    DIRECTV = 33,
    ISDB_T_TMCC = 34,
    ISDB_S_TMCC = 35,
    MAX = 36,
};
pub const BDA_MOD_NOT_SET = ModulationType.NOT_SET;
pub const BDA_MOD_NOT_DEFINED = ModulationType.NOT_DEFINED;
pub const BDA_MOD_16QAM = ModulationType.@"16QAM";
pub const BDA_MOD_32QAM = ModulationType.@"32QAM";
pub const BDA_MOD_64QAM = ModulationType.@"64QAM";
pub const BDA_MOD_80QAM = ModulationType.@"80QAM";
pub const BDA_MOD_96QAM = ModulationType.@"96QAM";
pub const BDA_MOD_112QAM = ModulationType.@"112QAM";
pub const BDA_MOD_128QAM = ModulationType.@"128QAM";
pub const BDA_MOD_160QAM = ModulationType.@"160QAM";
pub const BDA_MOD_192QAM = ModulationType.@"192QAM";
pub const BDA_MOD_224QAM = ModulationType.@"224QAM";
pub const BDA_MOD_256QAM = ModulationType.@"256QAM";
pub const BDA_MOD_320QAM = ModulationType.@"320QAM";
pub const BDA_MOD_384QAM = ModulationType.@"384QAM";
pub const BDA_MOD_448QAM = ModulationType.@"448QAM";
pub const BDA_MOD_512QAM = ModulationType.@"512QAM";
pub const BDA_MOD_640QAM = ModulationType.@"640QAM";
pub const BDA_MOD_768QAM = ModulationType.@"768QAM";
pub const BDA_MOD_896QAM = ModulationType.@"896QAM";
pub const BDA_MOD_1024QAM = ModulationType.@"1024QAM";
pub const BDA_MOD_QPSK = ModulationType.QPSK;
pub const BDA_MOD_BPSK = ModulationType.BPSK;
pub const BDA_MOD_OQPSK = ModulationType.OQPSK;
pub const BDA_MOD_8VSB = ModulationType.@"8VSB";
pub const BDA_MOD_16VSB = ModulationType.@"16VSB";
pub const BDA_MOD_ANALOG_AMPLITUDE = ModulationType.ANALOG_AMPLITUDE;
pub const BDA_MOD_ANALOG_FREQUENCY = ModulationType.ANALOG_FREQUENCY;
pub const BDA_MOD_8PSK = ModulationType.@"8PSK";
pub const BDA_MOD_RF = ModulationType.RF;
pub const BDA_MOD_16APSK = ModulationType.@"16APSK";
pub const BDA_MOD_32APSK = ModulationType.@"32APSK";
pub const BDA_MOD_NBC_QPSK = ModulationType.NBC_QPSK;
pub const BDA_MOD_NBC_8PSK = ModulationType.NBC_8PSK;
pub const BDA_MOD_DIRECTV = ModulationType.DIRECTV;
pub const BDA_MOD_ISDB_T_TMCC = ModulationType.ISDB_T_TMCC;
pub const BDA_MOD_ISDB_S_TMCC = ModulationType.ISDB_S_TMCC;
pub const BDA_MOD_MAX = ModulationType.MAX;

pub const ScanModulationTypes = enum(i32) {
    BDA_SCAN_MOD_16QAM = 1,
    BDA_SCAN_MOD_32QAM = 2,
    BDA_SCAN_MOD_64QAM = 4,
    BDA_SCAN_MOD_80QAM = 8,
    BDA_SCAN_MOD_96QAM = 16,
    BDA_SCAN_MOD_112QAM = 32,
    BDA_SCAN_MOD_128QAM = 64,
    BDA_SCAN_MOD_160QAM = 128,
    BDA_SCAN_MOD_192QAM = 256,
    BDA_SCAN_MOD_224QAM = 512,
    BDA_SCAN_MOD_256QAM = 1024,
    BDA_SCAN_MOD_320QAM = 2048,
    BDA_SCAN_MOD_384QAM = 4096,
    BDA_SCAN_MOD_448QAM = 8192,
    BDA_SCAN_MOD_512QAM = 16384,
    BDA_SCAN_MOD_640QAM = 32768,
    BDA_SCAN_MOD_768QAM = 65536,
    BDA_SCAN_MOD_896QAM = 131072,
    BDA_SCAN_MOD_1024QAM = 262144,
    BDA_SCAN_MOD_QPSK = 524288,
    BDA_SCAN_MOD_BPSK = 1048576,
    BDA_SCAN_MOD_OQPSK = 2097152,
    BDA_SCAN_MOD_8VSB = 4194304,
    BDA_SCAN_MOD_16VSB = 8388608,
    BDA_SCAN_MOD_AM_RADIO = 16777216,
    BDA_SCAN_MOD_FM_RADIO = 33554432,
    BDA_SCAN_MOD_8PSK = 67108864,
    BDA_SCAN_MOD_RF = 134217728,
    ScanModulationTypesMask_MCE_DigitalCable = 11,
    ScanModulationTypesMask_MCE_TerrestrialATSC = 23,
    ScanModulationTypesMask_MCE_AnalogTv = 28,
    ScanModulationTypesMask_MCE_All_TV = -1,
    ScanModulationTypesMask_DVBC = 75,
    BDA_SCAN_MOD_16APSK = 268435456,
    BDA_SCAN_MOD_32APSK = 536870912,
};
pub const BDA_SCAN_MOD_16QAM = ScanModulationTypes.BDA_SCAN_MOD_16QAM;
pub const BDA_SCAN_MOD_32QAM = ScanModulationTypes.BDA_SCAN_MOD_32QAM;
pub const BDA_SCAN_MOD_64QAM = ScanModulationTypes.BDA_SCAN_MOD_64QAM;
pub const BDA_SCAN_MOD_80QAM = ScanModulationTypes.BDA_SCAN_MOD_80QAM;
pub const BDA_SCAN_MOD_96QAM = ScanModulationTypes.BDA_SCAN_MOD_96QAM;
pub const BDA_SCAN_MOD_112QAM = ScanModulationTypes.BDA_SCAN_MOD_112QAM;
pub const BDA_SCAN_MOD_128QAM = ScanModulationTypes.BDA_SCAN_MOD_128QAM;
pub const BDA_SCAN_MOD_160QAM = ScanModulationTypes.BDA_SCAN_MOD_160QAM;
pub const BDA_SCAN_MOD_192QAM = ScanModulationTypes.BDA_SCAN_MOD_192QAM;
pub const BDA_SCAN_MOD_224QAM = ScanModulationTypes.BDA_SCAN_MOD_224QAM;
pub const BDA_SCAN_MOD_256QAM = ScanModulationTypes.BDA_SCAN_MOD_256QAM;
pub const BDA_SCAN_MOD_320QAM = ScanModulationTypes.BDA_SCAN_MOD_320QAM;
pub const BDA_SCAN_MOD_384QAM = ScanModulationTypes.BDA_SCAN_MOD_384QAM;
pub const BDA_SCAN_MOD_448QAM = ScanModulationTypes.BDA_SCAN_MOD_448QAM;
pub const BDA_SCAN_MOD_512QAM = ScanModulationTypes.BDA_SCAN_MOD_512QAM;
pub const BDA_SCAN_MOD_640QAM = ScanModulationTypes.BDA_SCAN_MOD_640QAM;
pub const BDA_SCAN_MOD_768QAM = ScanModulationTypes.BDA_SCAN_MOD_768QAM;
pub const BDA_SCAN_MOD_896QAM = ScanModulationTypes.BDA_SCAN_MOD_896QAM;
pub const BDA_SCAN_MOD_1024QAM = ScanModulationTypes.BDA_SCAN_MOD_1024QAM;
pub const BDA_SCAN_MOD_QPSK = ScanModulationTypes.BDA_SCAN_MOD_QPSK;
pub const BDA_SCAN_MOD_BPSK = ScanModulationTypes.BDA_SCAN_MOD_BPSK;
pub const BDA_SCAN_MOD_OQPSK = ScanModulationTypes.BDA_SCAN_MOD_OQPSK;
pub const BDA_SCAN_MOD_8VSB = ScanModulationTypes.BDA_SCAN_MOD_8VSB;
pub const BDA_SCAN_MOD_16VSB = ScanModulationTypes.BDA_SCAN_MOD_16VSB;
pub const BDA_SCAN_MOD_AM_RADIO = ScanModulationTypes.BDA_SCAN_MOD_AM_RADIO;
pub const BDA_SCAN_MOD_FM_RADIO = ScanModulationTypes.BDA_SCAN_MOD_FM_RADIO;
pub const BDA_SCAN_MOD_8PSK = ScanModulationTypes.BDA_SCAN_MOD_8PSK;
pub const BDA_SCAN_MOD_RF = ScanModulationTypes.BDA_SCAN_MOD_RF;
pub const ScanModulationTypesMask_MCE_DigitalCable = ScanModulationTypes.ScanModulationTypesMask_MCE_DigitalCable;
pub const ScanModulationTypesMask_MCE_TerrestrialATSC = ScanModulationTypes.ScanModulationTypesMask_MCE_TerrestrialATSC;
pub const ScanModulationTypesMask_MCE_AnalogTv = ScanModulationTypes.ScanModulationTypesMask_MCE_AnalogTv;
pub const ScanModulationTypesMask_MCE_All_TV = ScanModulationTypes.ScanModulationTypesMask_MCE_All_TV;
pub const ScanModulationTypesMask_DVBC = ScanModulationTypes.ScanModulationTypesMask_DVBC;
pub const BDA_SCAN_MOD_16APSK = ScanModulationTypes.BDA_SCAN_MOD_16APSK;
pub const BDA_SCAN_MOD_32APSK = ScanModulationTypes.BDA_SCAN_MOD_32APSK;

pub const SpectralInversion = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    AUTOMATIC = 1,
    NORMAL = 2,
    INVERTED = 3,
    MAX = 4,
};
pub const BDA_SPECTRAL_INVERSION_NOT_SET = SpectralInversion.NOT_SET;
pub const BDA_SPECTRAL_INVERSION_NOT_DEFINED = SpectralInversion.NOT_DEFINED;
pub const BDA_SPECTRAL_INVERSION_AUTOMATIC = SpectralInversion.AUTOMATIC;
pub const BDA_SPECTRAL_INVERSION_NORMAL = SpectralInversion.NORMAL;
pub const BDA_SPECTRAL_INVERSION_INVERTED = SpectralInversion.INVERTED;
pub const BDA_SPECTRAL_INVERSION_MAX = SpectralInversion.MAX;

pub const Polarisation = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    LINEAR_H = 1,
    LINEAR_V = 2,
    CIRCULAR_L = 3,
    CIRCULAR_R = 4,
    MAX = 5,
};
pub const BDA_POLARISATION_NOT_SET = Polarisation.NOT_SET;
pub const BDA_POLARISATION_NOT_DEFINED = Polarisation.NOT_DEFINED;
pub const BDA_POLARISATION_LINEAR_H = Polarisation.LINEAR_H;
pub const BDA_POLARISATION_LINEAR_V = Polarisation.LINEAR_V;
pub const BDA_POLARISATION_CIRCULAR_L = Polarisation.CIRCULAR_L;
pub const BDA_POLARISATION_CIRCULAR_R = Polarisation.CIRCULAR_R;
pub const BDA_POLARISATION_MAX = Polarisation.MAX;

pub const LNB_Source = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    A = 1,
    B = 2,
    C = 3,
    D = 4,
    MAX = 5,
};
pub const BDA_LNB_SOURCE_NOT_SET = LNB_Source.NOT_SET;
pub const BDA_LNB_SOURCE_NOT_DEFINED = LNB_Source.NOT_DEFINED;
pub const BDA_LNB_SOURCE_A = LNB_Source.A;
pub const BDA_LNB_SOURCE_B = LNB_Source.B;
pub const BDA_LNB_SOURCE_C = LNB_Source.C;
pub const BDA_LNB_SOURCE_D = LNB_Source.D;
pub const BDA_LNB_SOURCE_MAX = LNB_Source.MAX;

pub const GuardInterval = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"1_32" = 1,
    @"1_16" = 2,
    @"1_8" = 3,
    @"1_4" = 4,
    @"1_128" = 5,
    @"19_128" = 6,
    @"19_256" = 7,
    MAX = 8,
};
pub const BDA_GUARD_NOT_SET = GuardInterval.NOT_SET;
pub const BDA_GUARD_NOT_DEFINED = GuardInterval.NOT_DEFINED;
pub const BDA_GUARD_1_32 = GuardInterval.@"1_32";
pub const BDA_GUARD_1_16 = GuardInterval.@"1_16";
pub const BDA_GUARD_1_8 = GuardInterval.@"1_8";
pub const BDA_GUARD_1_4 = GuardInterval.@"1_4";
pub const BDA_GUARD_1_128 = GuardInterval.@"1_128";
pub const BDA_GUARD_19_128 = GuardInterval.@"19_128";
pub const BDA_GUARD_19_256 = GuardInterval.@"19_256";
pub const BDA_GUARD_MAX = GuardInterval.MAX;

pub const HierarchyAlpha = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"1" = 1,
    @"2" = 2,
    @"4" = 3,
    MAX = 4,
};
pub const BDA_HALPHA_NOT_SET = HierarchyAlpha.NOT_SET;
pub const BDA_HALPHA_NOT_DEFINED = HierarchyAlpha.NOT_DEFINED;
pub const BDA_HALPHA_1 = HierarchyAlpha.@"1";
pub const BDA_HALPHA_2 = HierarchyAlpha.@"2";
pub const BDA_HALPHA_4 = HierarchyAlpha.@"4";
pub const BDA_HALPHA_MAX = HierarchyAlpha.MAX;

pub const TransmissionMode = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"2K" = 1,
    @"8K" = 2,
    @"4K" = 3,
    @"2K_INTERLEAVED" = 4,
    @"4K_INTERLEAVED" = 5,
    @"1K" = 6,
    @"16K" = 7,
    @"32K" = 8,
    MAX = 9,
};
pub const BDA_XMIT_MODE_NOT_SET = TransmissionMode.NOT_SET;
pub const BDA_XMIT_MODE_NOT_DEFINED = TransmissionMode.NOT_DEFINED;
pub const BDA_XMIT_MODE_2K = TransmissionMode.@"2K";
pub const BDA_XMIT_MODE_8K = TransmissionMode.@"8K";
pub const BDA_XMIT_MODE_4K = TransmissionMode.@"4K";
pub const BDA_XMIT_MODE_2K_INTERLEAVED = TransmissionMode.@"2K_INTERLEAVED";
pub const BDA_XMIT_MODE_4K_INTERLEAVED = TransmissionMode.@"4K_INTERLEAVED";
pub const BDA_XMIT_MODE_1K = TransmissionMode.@"1K";
pub const BDA_XMIT_MODE_16K = TransmissionMode.@"16K";
pub const BDA_XMIT_MODE_32K = TransmissionMode.@"32K";
pub const BDA_XMIT_MODE_MAX = TransmissionMode.MAX;

pub const RollOff = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"20" = 1,
    @"25" = 2,
    @"35" = 3,
    MAX = 4,
};
pub const BDA_ROLL_OFF_NOT_SET = RollOff.NOT_SET;
pub const BDA_ROLL_OFF_NOT_DEFINED = RollOff.NOT_DEFINED;
pub const BDA_ROLL_OFF_20 = RollOff.@"20";
pub const BDA_ROLL_OFF_25 = RollOff.@"25";
pub const BDA_ROLL_OFF_35 = RollOff.@"35";
pub const BDA_ROLL_OFF_MAX = RollOff.MAX;

pub const Pilot = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    OFF = 1,
    ON = 2,
    MAX = 3,
};
pub const BDA_PILOT_NOT_SET = Pilot.NOT_SET;
pub const BDA_PILOT_NOT_DEFINED = Pilot.NOT_DEFINED;
pub const BDA_PILOT_OFF = Pilot.OFF;
pub const BDA_PILOT_ON = Pilot.ON;
pub const BDA_PILOT_MAX = Pilot.MAX;

pub const BDA_SIGNAL_TIMEOUTS = extern struct {
    ulCarrierTimeoutMs: u32,
    ulScanningTimeoutMs: u32,
    ulTuningTimeoutMs: u32,
};

pub const BDA_Frequency = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_FREQUENCY_NOT_SET = BDA_Frequency.SET;
pub const BDA_FREQUENCY_NOT_DEFINED = BDA_Frequency.DEFINED;

pub const BDA_Range = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_RANGE_NOT_SET = BDA_Range.SET;
pub const BDA_RANGE_NOT_DEFINED = BDA_Range.DEFINED;

pub const BDA_Channel_Bandwidth = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_CHAN_BANDWITH_NOT_SET = BDA_Channel_Bandwidth.SET;
pub const BDA_CHAN_BANDWITH_NOT_DEFINED = BDA_Channel_Bandwidth.DEFINED;

pub const BDA_Frequency_Multiplier = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_FREQUENCY_MULTIPLIER_NOT_SET = BDA_Frequency_Multiplier.SET;
pub const BDA_FREQUENCY_MULTIPLIER_NOT_DEFINED = BDA_Frequency_Multiplier.DEFINED;

pub const BDA_Comp_Flags = enum(i32) {
    NOT_DEFINED = 0,
    EXCLUDE_TS_FROM_TR = 1,
    INCLUDE_LOCATOR_IN_TR = 2,
    INCLUDE_COMPONENTS_IN_TR = 4,
};
pub const BDACOMP_NOT_DEFINED = BDA_Comp_Flags.NOT_DEFINED;
pub const BDACOMP_EXCLUDE_TS_FROM_TR = BDA_Comp_Flags.EXCLUDE_TS_FROM_TR;
pub const BDACOMP_INCLUDE_LOCATOR_IN_TR = BDA_Comp_Flags.INCLUDE_LOCATOR_IN_TR;
pub const BDACOMP_INCLUDE_COMPONENTS_IN_TR = BDA_Comp_Flags.INCLUDE_COMPONENTS_IN_TR;

pub const ApplicationTypeType = enum(i32) {
    ConditionalAccess = 0,
    POD_Host_Binding_Information = 1,
    IPService = 2,
    NetworkInterface_SCTE55_2 = 3,
    NetworkInterface_SCTE55_1 = 4,
    CopyProtection = 5,
    Diagnostic = 6,
    Undesignated = 7,
    Reserved = 8,
};
pub const SCTE28_ConditionalAccess = ApplicationTypeType.ConditionalAccess;
pub const SCTE28_POD_Host_Binding_Information = ApplicationTypeType.POD_Host_Binding_Information;
pub const SCTE28_IPService = ApplicationTypeType.IPService;
pub const SCTE28_NetworkInterface_SCTE55_2 = ApplicationTypeType.NetworkInterface_SCTE55_2;
pub const SCTE28_NetworkInterface_SCTE55_1 = ApplicationTypeType.NetworkInterface_SCTE55_1;
pub const SCTE28_CopyProtection = ApplicationTypeType.CopyProtection;
pub const SCTE28_Diagnostic = ApplicationTypeType.Diagnostic;
pub const SCTE28_Undesignated = ApplicationTypeType.Undesignated;
pub const SCTE28_Reserved = ApplicationTypeType.Reserved;

pub const BDA_CONDITIONALACCESS_REQUESTTYPE = enum(i32) {
    UNSPECIFIED = 0,
    NOT_POSSIBLE = 1,
    POSSIBLE = 2,
    POSSIBLE_NO_STREAMING_DISRUPTION = 3,
};
pub const CONDITIONALACCESS_ACCESS_UNSPECIFIED = BDA_CONDITIONALACCESS_REQUESTTYPE.UNSPECIFIED;
pub const CONDITIONALACCESS_ACCESS_NOT_POSSIBLE = BDA_CONDITIONALACCESS_REQUESTTYPE.NOT_POSSIBLE;
pub const CONDITIONALACCESS_ACCESS_POSSIBLE = BDA_CONDITIONALACCESS_REQUESTTYPE.POSSIBLE;
pub const CONDITIONALACCESS_ACCESS_POSSIBLE_NO_STREAMING_DISRUPTION = BDA_CONDITIONALACCESS_REQUESTTYPE.POSSIBLE_NO_STREAMING_DISRUPTION;

pub const BDA_CONDITIONALACCESS_MMICLOSEREASON = enum(i32) {
    UNSPECIFIED = 0,
    CLOSED_ITSELF = 1,
    TUNER_REQUESTED_CLOSE = 2,
    DIALOG_TIMEOUT = 3,
    DIALOG_FOCUS_CHANGE = 4,
    DIALOG_USER_DISMISSED = 5,
    DIALOG_USER_NOT_AVAILABLE = 6,
};
pub const CONDITIONALACCESS_UNSPECIFIED = BDA_CONDITIONALACCESS_MMICLOSEREASON.UNSPECIFIED;
pub const CONDITIONALACCESS_CLOSED_ITSELF = BDA_CONDITIONALACCESS_MMICLOSEREASON.CLOSED_ITSELF;
pub const CONDITIONALACCESS_TUNER_REQUESTED_CLOSE = BDA_CONDITIONALACCESS_MMICLOSEREASON.TUNER_REQUESTED_CLOSE;
pub const CONDITIONALACCESS_DIALOG_TIMEOUT = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_TIMEOUT;
pub const CONDITIONALACCESS_DIALOG_FOCUS_CHANGE = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_FOCUS_CHANGE;
pub const CONDITIONALACCESS_DIALOG_USER_DISMISSED = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_USER_DISMISSED;
pub const CONDITIONALACCESS_DIALOG_USER_NOT_AVAILABLE = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_USER_NOT_AVAILABLE;

pub const BDA_CONDITIONALACCESS_SESSION_RESULT = enum(i32) {
    SUCCESSFULL = 0,
    ENDED_NOCHANGE = 1,
    ABORTED = 2,
};
pub const CONDITIONALACCESS_SUCCESSFULL = BDA_CONDITIONALACCESS_SESSION_RESULT.SUCCESSFULL;
pub const CONDITIONALACCESS_ENDED_NOCHANGE = BDA_CONDITIONALACCESS_SESSION_RESULT.ENDED_NOCHANGE;
pub const CONDITIONALACCESS_ABORTED = BDA_CONDITIONALACCESS_SESSION_RESULT.ABORTED;

pub const BDA_DISCOVERY_STATE = enum(i32) {
    UNSPECIFIED = 0,
    REQUIRED = 1,
    COMPLETE = 2,
};
pub const BDA_DISCOVERY_UNSPECIFIED = BDA_DISCOVERY_STATE.UNSPECIFIED;
pub const BDA_DISCOVERY_REQUIRED = BDA_DISCOVERY_STATE.REQUIRED;
pub const BDA_DISCOVERY_COMPLETE = BDA_DISCOVERY_STATE.COMPLETE;

pub const SmartCardStatusType = enum(i32) {
    Inserted = 0,
    Removed = 1,
    Error = 2,
    DataChanged = 3,
    FirmwareUpgrade = 4,
};
pub const CardInserted = SmartCardStatusType.Inserted;
pub const CardRemoved = SmartCardStatusType.Removed;
pub const CardError = SmartCardStatusType.Error;
pub const CardDataChanged = SmartCardStatusType.DataChanged;
pub const CardFirmwareUpgrade = SmartCardStatusType.FirmwareUpgrade;

pub const SmartCardAssociationType = enum(i32) {
    NotAssociated = 0,
    Associated = 1,
    AssociationUnknown = 2,
};
pub const NotAssociated = SmartCardAssociationType.NotAssociated;
pub const Associated = SmartCardAssociationType.Associated;
pub const AssociationUnknown = SmartCardAssociationType.AssociationUnknown;

pub const LocationCodeSchemeType = enum(i32) {
    @"8" = 0,
};
pub const SCTE_18 = LocationCodeSchemeType.@"8";

pub const EALocationCodeType = extern struct {
    LocationCodeScheme: LocationCodeSchemeType,
    state_code: u8,
    county_subdivision: u8,
    county_code: u16,
};

pub const EntitlementType = enum(i32) {
    Entitled = 0,
    NotEntitled = 1,
    TechnicalFailure = 2,
};
pub const Entitled = EntitlementType.Entitled;
pub const NotEntitled = EntitlementType.NotEntitled;
pub const TechnicalFailure = EntitlementType.TechnicalFailure;

pub const UICloseReasonType = enum(i32) {
    NotReady = 0,
    UserClosed = 1,
    SystemClosed = 2,
    DeviceClosed = 3,
    ErrorClosed = 4,
};
pub const NotReady = UICloseReasonType.NotReady;
pub const UserClosed = UICloseReasonType.UserClosed;
pub const SystemClosed = UICloseReasonType.SystemClosed;
pub const DeviceClosed = UICloseReasonType.DeviceClosed;
pub const ErrorClosed = UICloseReasonType.ErrorClosed;

pub const SmartCardApplication = extern struct {
    ApplicationType: ApplicationTypeType,
    ApplicationVersion: u16,
    pbstrApplicationName: ?BSTR,
    pbstrApplicationURL: ?BSTR,
};

pub const BDA_DrmPairingError = enum(i32) {
    Succeeded = 0,
    HardwareFailure = 1,
    NeedRevocationData = 2,
    NeedIndiv = 3,
    Other = 4,
    DrmInitFailed = 5,
    DrmNotPaired = 6,
    DrmRePairSoon = 7,
    Aborted = 8,
    NeedSDKUpdate = 9,
};
pub const BDA_DrmPairing_Succeeded = BDA_DrmPairingError.Succeeded;
pub const BDA_DrmPairing_HardwareFailure = BDA_DrmPairingError.HardwareFailure;
pub const BDA_DrmPairing_NeedRevocationData = BDA_DrmPairingError.NeedRevocationData;
pub const BDA_DrmPairing_NeedIndiv = BDA_DrmPairingError.NeedIndiv;
pub const BDA_DrmPairing_Other = BDA_DrmPairingError.Other;
pub const BDA_DrmPairing_DrmInitFailed = BDA_DrmPairingError.DrmInitFailed;
pub const BDA_DrmPairing_DrmNotPaired = BDA_DrmPairingError.DrmNotPaired;
pub const BDA_DrmPairing_DrmRePairSoon = BDA_DrmPairingError.DrmRePairSoon;
pub const BDA_DrmPairing_Aborted = BDA_DrmPairingError.Aborted;
pub const BDA_DrmPairing_NeedSDKUpdate = BDA_DrmPairingError.NeedSDKUpdate;

const IID_IBDA_NetworkProvider_Value = @import("../zig.zig").Guid.initString("fd501041-8ebe-11ce-8183-00aa00577da2");
pub const IID_IBDA_NetworkProvider = &IID_IBDA_NetworkProvider_Value;
pub const IBDA_NetworkProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutSignalSource: fn(
            self: *const IBDA_NetworkProvider,
            ulSignalSource: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignalSource: fn(
            self: *const IBDA_NetworkProvider,
            pulSignalSource: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkType: fn(
            self: *const IBDA_NetworkProvider,
            pguidNetworkType: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutTuningSpace: fn(
            self: *const IBDA_NetworkProvider,
            guidTuningSpace: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTuningSpace: fn(
            self: *const IBDA_NetworkProvider,
            pguidTuingSpace: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterDeviceFilter: fn(
            self: *const IBDA_NetworkProvider,
            pUnkFilterControl: ?*IUnknown,
            ppvRegisitrationContext: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterDeviceFilter: fn(
            self: *const IBDA_NetworkProvider,
            pvRegistrationContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_PutSignalSource(self: *const T, ulSignalSource: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NetworkProvider.VTable, self.vtable).PutSignalSource(@ptrCast(*const IBDA_NetworkProvider, self), ulSignalSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_GetSignalSource(self: *const T, pulSignalSource: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NetworkProvider.VTable, self.vtable).GetSignalSource(@ptrCast(*const IBDA_NetworkProvider, self), pulSignalSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_GetNetworkType(self: *const T, pguidNetworkType: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NetworkProvider.VTable, self.vtable).GetNetworkType(@ptrCast(*const IBDA_NetworkProvider, self), pguidNetworkType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_PutTuningSpace(self: *const T, guidTuningSpace: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NetworkProvider.VTable, self.vtable).PutTuningSpace(@ptrCast(*const IBDA_NetworkProvider, self), guidTuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_GetTuningSpace(self: *const T, pguidTuingSpace: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NetworkProvider.VTable, self.vtable).GetTuningSpace(@ptrCast(*const IBDA_NetworkProvider, self), pguidTuingSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_RegisterDeviceFilter(self: *const T, pUnkFilterControl: ?*IUnknown, ppvRegisitrationContext: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NetworkProvider.VTable, self.vtable).RegisterDeviceFilter(@ptrCast(*const IBDA_NetworkProvider, self), pUnkFilterControl, ppvRegisitrationContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_UnRegisterDeviceFilter(self: *const T, pvRegistrationContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NetworkProvider.VTable, self.vtable).UnRegisterDeviceFilter(@ptrCast(*const IBDA_NetworkProvider, self), pvRegistrationContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_EthernetFilter_Value = @import("../zig.zig").Guid.initString("71985f43-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_EthernetFilter = &IID_IBDA_EthernetFilter_Value;
pub const IBDA_EthernetFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastListSize: fn(
            self: *const IBDA_EthernetFilter,
            pulcbAddresses: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastList: fn(
            self: *const IBDA_EthernetFilter,
            ulcbAddresses: u32,
            pAddressList: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastList: fn(
            self: *const IBDA_EthernetFilter,
            pulcbAddresses: ?*u32,
            pAddressList: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastMode: fn(
            self: *const IBDA_EthernetFilter,
            ulModeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastMode: fn(
            self: *const IBDA_EthernetFilter,
            pulModeMask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_GetMulticastListSize(self: *const T, pulcbAddresses: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_EthernetFilter.VTable, self.vtable).GetMulticastListSize(@ptrCast(*const IBDA_EthernetFilter, self), pulcbAddresses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_PutMulticastList(self: *const T, ulcbAddresses: u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_EthernetFilter.VTable, self.vtable).PutMulticastList(@ptrCast(*const IBDA_EthernetFilter, self), ulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_GetMulticastList(self: *const T, pulcbAddresses: ?*u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_EthernetFilter.VTable, self.vtable).GetMulticastList(@ptrCast(*const IBDA_EthernetFilter, self), pulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_PutMulticastMode(self: *const T, ulModeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_EthernetFilter.VTable, self.vtable).PutMulticastMode(@ptrCast(*const IBDA_EthernetFilter, self), ulModeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_GetMulticastMode(self: *const T, pulModeMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_EthernetFilter.VTable, self.vtable).GetMulticastMode(@ptrCast(*const IBDA_EthernetFilter, self), pulModeMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPV4Filter_Value = @import("../zig.zig").Guid.initString("71985f44-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_IPV4Filter = &IID_IBDA_IPV4Filter_Value;
pub const IBDA_IPV4Filter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastListSize: fn(
            self: *const IBDA_IPV4Filter,
            pulcbAddresses: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastList: fn(
            self: *const IBDA_IPV4Filter,
            ulcbAddresses: u32,
            pAddressList: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastList: fn(
            self: *const IBDA_IPV4Filter,
            pulcbAddresses: ?*u32,
            pAddressList: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastMode: fn(
            self: *const IBDA_IPV4Filter,
            ulModeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastMode: fn(
            self: *const IBDA_IPV4Filter,
            pulModeMask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_GetMulticastListSize(self: *const T, pulcbAddresses: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV4Filter.VTable, self.vtable).GetMulticastListSize(@ptrCast(*const IBDA_IPV4Filter, self), pulcbAddresses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_PutMulticastList(self: *const T, ulcbAddresses: u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV4Filter.VTable, self.vtable).PutMulticastList(@ptrCast(*const IBDA_IPV4Filter, self), ulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_GetMulticastList(self: *const T, pulcbAddresses: ?*u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV4Filter.VTable, self.vtable).GetMulticastList(@ptrCast(*const IBDA_IPV4Filter, self), pulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_PutMulticastMode(self: *const T, ulModeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV4Filter.VTable, self.vtable).PutMulticastMode(@ptrCast(*const IBDA_IPV4Filter, self), ulModeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_GetMulticastMode(self: *const T, pulModeMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV4Filter.VTable, self.vtable).GetMulticastMode(@ptrCast(*const IBDA_IPV4Filter, self), pulModeMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPV6Filter_Value = @import("../zig.zig").Guid.initString("e1785a74-2a23-4fb3-9245-a8f88017ef33");
pub const IID_IBDA_IPV6Filter = &IID_IBDA_IPV6Filter_Value;
pub const IBDA_IPV6Filter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastListSize: fn(
            self: *const IBDA_IPV6Filter,
            pulcbAddresses: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastList: fn(
            self: *const IBDA_IPV6Filter,
            ulcbAddresses: u32,
            pAddressList: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastList: fn(
            self: *const IBDA_IPV6Filter,
            pulcbAddresses: ?*u32,
            pAddressList: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutMulticastMode: fn(
            self: *const IBDA_IPV6Filter,
            ulModeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMulticastMode: fn(
            self: *const IBDA_IPV6Filter,
            pulModeMask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_GetMulticastListSize(self: *const T, pulcbAddresses: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV6Filter.VTable, self.vtable).GetMulticastListSize(@ptrCast(*const IBDA_IPV6Filter, self), pulcbAddresses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_PutMulticastList(self: *const T, ulcbAddresses: u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV6Filter.VTable, self.vtable).PutMulticastList(@ptrCast(*const IBDA_IPV6Filter, self), ulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_GetMulticastList(self: *const T, pulcbAddresses: ?*u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV6Filter.VTable, self.vtable).GetMulticastList(@ptrCast(*const IBDA_IPV6Filter, self), pulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_PutMulticastMode(self: *const T, ulModeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV6Filter.VTable, self.vtable).PutMulticastMode(@ptrCast(*const IBDA_IPV6Filter, self), ulModeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_GetMulticastMode(self: *const T, pulModeMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPV6Filter.VTable, self.vtable).GetMulticastMode(@ptrCast(*const IBDA_IPV6Filter, self), pulModeMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DeviceControl_Value = @import("../zig.zig").Guid.initString("fd0a5af3-b41d-11d2-9c95-00c04f7971e0");
pub const IID_IBDA_DeviceControl = &IID_IBDA_DeviceControl_Value;
pub const IBDA_DeviceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartChanges: fn(
            self: *const IBDA_DeviceControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckChanges: fn(
            self: *const IBDA_DeviceControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitChanges: fn(
            self: *const IBDA_DeviceControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChangeState: fn(
            self: *const IBDA_DeviceControl,
            pState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DeviceControl_StartChanges(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DeviceControl.VTable, self.vtable).StartChanges(@ptrCast(*const IBDA_DeviceControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DeviceControl_CheckChanges(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DeviceControl.VTable, self.vtable).CheckChanges(@ptrCast(*const IBDA_DeviceControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DeviceControl_CommitChanges(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DeviceControl.VTable, self.vtable).CommitChanges(@ptrCast(*const IBDA_DeviceControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DeviceControl_GetChangeState(self: *const T, pState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DeviceControl.VTable, self.vtable).GetChangeState(@ptrCast(*const IBDA_DeviceControl, self), pState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_PinControl_Value = @import("../zig.zig").Guid.initString("0ded49d5-a8b7-4d5d-97a1-12b0c195874d");
pub const IID_IBDA_PinControl = &IID_IBDA_PinControl_Value;
pub const IBDA_PinControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPinID: fn(
            self: *const IBDA_PinControl,
            pulPinID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPinType: fn(
            self: *const IBDA_PinControl,
            pulPinType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegistrationContext: fn(
            self: *const IBDA_PinControl,
            pulRegistrationCtx: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_PinControl_GetPinID(self: *const T, pulPinID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_PinControl.VTable, self.vtable).GetPinID(@ptrCast(*const IBDA_PinControl, self), pulPinID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_PinControl_GetPinType(self: *const T, pulPinType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_PinControl.VTable, self.vtable).GetPinType(@ptrCast(*const IBDA_PinControl, self), pulPinType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_PinControl_RegistrationContext(self: *const T, pulRegistrationCtx: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_PinControl.VTable, self.vtable).RegistrationContext(@ptrCast(*const IBDA_PinControl, self), pulRegistrationCtx);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_SignalProperties_Value = @import("../zig.zig").Guid.initString("d2f1644b-b409-11d2-bc69-00a0c9ee9e16");
pub const IID_IBDA_SignalProperties = &IID_IBDA_SignalProperties_Value;
pub const IBDA_SignalProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutNetworkType: fn(
            self: *const IBDA_SignalProperties,
            guidNetworkType: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkType: fn(
            self: *const IBDA_SignalProperties,
            pguidNetworkType: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutSignalSource: fn(
            self: *const IBDA_SignalProperties,
            ulSignalSource: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignalSource: fn(
            self: *const IBDA_SignalProperties,
            pulSignalSource: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutTuningSpace: fn(
            self: *const IBDA_SignalProperties,
            guidTuningSpace: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTuningSpace: fn(
            self: *const IBDA_SignalProperties,
            pguidTuingSpace: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_PutNetworkType(self: *const T, guidNetworkType: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalProperties.VTable, self.vtable).PutNetworkType(@ptrCast(*const IBDA_SignalProperties, self), guidNetworkType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_GetNetworkType(self: *const T, pguidNetworkType: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalProperties.VTable, self.vtable).GetNetworkType(@ptrCast(*const IBDA_SignalProperties, self), pguidNetworkType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_PutSignalSource(self: *const T, ulSignalSource: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalProperties.VTable, self.vtable).PutSignalSource(@ptrCast(*const IBDA_SignalProperties, self), ulSignalSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_GetSignalSource(self: *const T, pulSignalSource: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalProperties.VTable, self.vtable).GetSignalSource(@ptrCast(*const IBDA_SignalProperties, self), pulSignalSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_PutTuningSpace(self: *const T, guidTuningSpace: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalProperties.VTable, self.vtable).PutTuningSpace(@ptrCast(*const IBDA_SignalProperties, self), guidTuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_GetTuningSpace(self: *const T, pguidTuingSpace: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalProperties.VTable, self.vtable).GetTuningSpace(@ptrCast(*const IBDA_SignalProperties, self), pguidTuingSpace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_SignalStatistics_Value = @import("../zig.zig").Guid.initString("1347d106-cf3a-428a-a5cb-ac0d9a2a4338");
pub const IID_IBDA_SignalStatistics = &IID_IBDA_SignalStatistics_Value;
pub const IBDA_SignalStatistics = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalStrength: fn(
            self: *const IBDA_SignalStatistics,
            lDbStrength: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalStrength: fn(
            self: *const IBDA_SignalStatistics,
            plDbStrength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalQuality: fn(
            self: *const IBDA_SignalStatistics,
            lPercentQuality: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalQuality: fn(
            self: *const IBDA_SignalStatistics,
            plPercentQuality: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalPresent: fn(
            self: *const IBDA_SignalStatistics,
            fPresent: BOOLEAN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalPresent: fn(
            self: *const IBDA_SignalStatistics,
            pfPresent: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalLocked: fn(
            self: *const IBDA_SignalStatistics,
            fLocked: BOOLEAN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalLocked: fn(
            self: *const IBDA_SignalStatistics,
            pfLocked: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SampleTime: fn(
            self: *const IBDA_SignalStatistics,
            lmsSampleTime: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SampleTime: fn(
            self: *const IBDA_SignalStatistics,
            plmsSampleTime: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SignalStrength(self: *const T, lDbStrength: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).put_SignalStrength(@ptrCast(*const IBDA_SignalStatistics, self), lDbStrength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SignalStrength(self: *const T, plDbStrength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).get_SignalStrength(@ptrCast(*const IBDA_SignalStatistics, self), plDbStrength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SignalQuality(self: *const T, lPercentQuality: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).put_SignalQuality(@ptrCast(*const IBDA_SignalStatistics, self), lPercentQuality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SignalQuality(self: *const T, plPercentQuality: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).get_SignalQuality(@ptrCast(*const IBDA_SignalStatistics, self), plPercentQuality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SignalPresent(self: *const T, fPresent: BOOLEAN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).put_SignalPresent(@ptrCast(*const IBDA_SignalStatistics, self), fPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SignalPresent(self: *const T, pfPresent: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).get_SignalPresent(@ptrCast(*const IBDA_SignalStatistics, self), pfPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SignalLocked(self: *const T, fLocked: BOOLEAN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).put_SignalLocked(@ptrCast(*const IBDA_SignalStatistics, self), fLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SignalLocked(self: *const T, pfLocked: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).get_SignalLocked(@ptrCast(*const IBDA_SignalStatistics, self), pfLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SampleTime(self: *const T, lmsSampleTime: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).put_SampleTime(@ptrCast(*const IBDA_SignalStatistics, self), lmsSampleTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SampleTime(self: *const T, plmsSampleTime: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_SignalStatistics.VTable, self.vtable).get_SampleTime(@ptrCast(*const IBDA_SignalStatistics, self), plmsSampleTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_Topology_Value = @import("../zig.zig").Guid.initString("79b56888-7fea-4690-b45d-38fd3c7849be");
pub const IID_IBDA_Topology = &IID_IBDA_Topology_Value;
pub const IBDA_Topology = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNodeTypes: fn(
            self: *const IBDA_Topology,
            pulcNodeTypes: ?*u32,
            ulcNodeTypesMax: u32,
            rgulNodeTypes: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNodeDescriptors: fn(
            self: *const IBDA_Topology,
            ulcNodeDescriptors: ?*u32,
            ulcNodeDescriptorsMax: u32,
            rgNodeDescriptors: [*]BDANODE_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNodeInterfaces: fn(
            self: *const IBDA_Topology,
            ulNodeType: u32,
            pulcInterfaces: ?*u32,
            ulcInterfacesMax: u32,
            rgguidInterfaces: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPinTypes: fn(
            self: *const IBDA_Topology,
            pulcPinTypes: ?*u32,
            ulcPinTypesMax: u32,
            rgulPinTypes: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTemplateConnections: fn(
            self: *const IBDA_Topology,
            pulcConnections: ?*u32,
            ulcConnectionsMax: u32,
            rgConnections: [*]BDA_TEMPLATE_CONNECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePin: fn(
            self: *const IBDA_Topology,
            ulPinType: u32,
            pulPinId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePin: fn(
            self: *const IBDA_Topology,
            ulPinId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaType: fn(
            self: *const IBDA_Topology,
            ulPinId: u32,
            pMediaType: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMedium: fn(
            self: *const IBDA_Topology,
            ulPinId: u32,
            pMedium: ?*REGPINMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTopology: fn(
            self: *const IBDA_Topology,
            ulInputPinId: u32,
            ulOutputPinId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlNode: fn(
            self: *const IBDA_Topology,
            ulInputPinId: u32,
            ulOutputPinId: u32,
            ulNodeType: u32,
            ppControlNode: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetNodeTypes(self: *const T, pulcNodeTypes: ?*u32, ulcNodeTypesMax: u32, rgulNodeTypes: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).GetNodeTypes(@ptrCast(*const IBDA_Topology, self), pulcNodeTypes, ulcNodeTypesMax, rgulNodeTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetNodeDescriptors(self: *const T, ulcNodeDescriptors: ?*u32, ulcNodeDescriptorsMax: u32, rgNodeDescriptors: [*]BDANODE_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).GetNodeDescriptors(@ptrCast(*const IBDA_Topology, self), ulcNodeDescriptors, ulcNodeDescriptorsMax, rgNodeDescriptors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetNodeInterfaces(self: *const T, ulNodeType: u32, pulcInterfaces: ?*u32, ulcInterfacesMax: u32, rgguidInterfaces: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).GetNodeInterfaces(@ptrCast(*const IBDA_Topology, self), ulNodeType, pulcInterfaces, ulcInterfacesMax, rgguidInterfaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetPinTypes(self: *const T, pulcPinTypes: ?*u32, ulcPinTypesMax: u32, rgulPinTypes: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).GetPinTypes(@ptrCast(*const IBDA_Topology, self), pulcPinTypes, ulcPinTypesMax, rgulPinTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetTemplateConnections(self: *const T, pulcConnections: ?*u32, ulcConnectionsMax: u32, rgConnections: [*]BDA_TEMPLATE_CONNECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).GetTemplateConnections(@ptrCast(*const IBDA_Topology, self), pulcConnections, ulcConnectionsMax, rgConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_CreatePin(self: *const T, ulPinType: u32, pulPinId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).CreatePin(@ptrCast(*const IBDA_Topology, self), ulPinType, pulPinId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_DeletePin(self: *const T, ulPinId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).DeletePin(@ptrCast(*const IBDA_Topology, self), ulPinId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_SetMediaType(self: *const T, ulPinId: u32, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).SetMediaType(@ptrCast(*const IBDA_Topology, self), ulPinId, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_SetMedium(self: *const T, ulPinId: u32, pMedium: ?*REGPINMEDIUM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).SetMedium(@ptrCast(*const IBDA_Topology, self), ulPinId, pMedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_CreateTopology(self: *const T, ulInputPinId: u32, ulOutputPinId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).CreateTopology(@ptrCast(*const IBDA_Topology, self), ulInputPinId, ulOutputPinId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetControlNode(self: *const T, ulInputPinId: u32, ulOutputPinId: u32, ulNodeType: u32, ppControlNode: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Topology.VTable, self.vtable).GetControlNode(@ptrCast(*const IBDA_Topology, self), ulInputPinId, ulOutputPinId, ulNodeType, ppControlNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_VoidTransform_Value = @import("../zig.zig").Guid.initString("71985f46-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_VoidTransform = &IID_IBDA_VoidTransform_Value;
pub const IBDA_VoidTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const IBDA_VoidTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IBDA_VoidTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_VoidTransform_Start(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_VoidTransform.VTable, self.vtable).Start(@ptrCast(*const IBDA_VoidTransform, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_VoidTransform_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_VoidTransform.VTable, self.vtable).Stop(@ptrCast(*const IBDA_VoidTransform, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_NullTransform_Value = @import("../zig.zig").Guid.initString("ddf15b0d-bd25-11d2-9ca0-00c04f7971e0");
pub const IID_IBDA_NullTransform = &IID_IBDA_NullTransform_Value;
pub const IBDA_NullTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const IBDA_NullTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IBDA_NullTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NullTransform_Start(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NullTransform.VTable, self.vtable).Start(@ptrCast(*const IBDA_NullTransform, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NullTransform_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NullTransform.VTable, self.vtable).Stop(@ptrCast(*const IBDA_NullTransform, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_FrequencyFilter_Value = @import("../zig.zig").Guid.initString("71985f47-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_FrequencyFilter = &IID_IBDA_FrequencyFilter_Value;
pub const IBDA_FrequencyFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Autotune: fn(
            self: *const IBDA_FrequencyFilter,
            ulTransponder: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Autotune: fn(
            self: *const IBDA_FrequencyFilter,
            pulTransponder: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Frequency: fn(
            self: *const IBDA_FrequencyFilter,
            ulFrequency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Frequency: fn(
            self: *const IBDA_FrequencyFilter,
            pulFrequency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Polarity: fn(
            self: *const IBDA_FrequencyFilter,
            Polarity: Polarisation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Polarity: fn(
            self: *const IBDA_FrequencyFilter,
            pPolarity: ?*Polarisation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Range: fn(
            self: *const IBDA_FrequencyFilter,
            ulRange: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Range: fn(
            self: *const IBDA_FrequencyFilter,
            pulRange: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bandwidth: fn(
            self: *const IBDA_FrequencyFilter,
            ulBandwidth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bandwidth: fn(
            self: *const IBDA_FrequencyFilter,
            pulBandwidth: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyMultiplier: fn(
            self: *const IBDA_FrequencyFilter,
            ulMultiplier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyMultiplier: fn(
            self: *const IBDA_FrequencyFilter,
            pulMultiplier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Autotune(self: *const T, ulTransponder: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).put_Autotune(@ptrCast(*const IBDA_FrequencyFilter, self), ulTransponder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Autotune(self: *const T, pulTransponder: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).get_Autotune(@ptrCast(*const IBDA_FrequencyFilter, self), pulTransponder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Frequency(self: *const T, ulFrequency: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).put_Frequency(@ptrCast(*const IBDA_FrequencyFilter, self), ulFrequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Frequency(self: *const T, pulFrequency: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).get_Frequency(@ptrCast(*const IBDA_FrequencyFilter, self), pulFrequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Polarity(self: *const T, Polarity: Polarisation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).put_Polarity(@ptrCast(*const IBDA_FrequencyFilter, self), Polarity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Polarity(self: *const T, pPolarity: ?*Polarisation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).get_Polarity(@ptrCast(*const IBDA_FrequencyFilter, self), pPolarity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Range(self: *const T, ulRange: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).put_Range(@ptrCast(*const IBDA_FrequencyFilter, self), ulRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Range(self: *const T, pulRange: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).get_Range(@ptrCast(*const IBDA_FrequencyFilter, self), pulRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Bandwidth(self: *const T, ulBandwidth: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).put_Bandwidth(@ptrCast(*const IBDA_FrequencyFilter, self), ulBandwidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Bandwidth(self: *const T, pulBandwidth: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).get_Bandwidth(@ptrCast(*const IBDA_FrequencyFilter, self), pulBandwidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_FrequencyMultiplier(self: *const T, ulMultiplier: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).put_FrequencyMultiplier(@ptrCast(*const IBDA_FrequencyFilter, self), ulMultiplier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_FrequencyMultiplier(self: *const T, pulMultiplier: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FrequencyFilter.VTable, self.vtable).get_FrequencyMultiplier(@ptrCast(*const IBDA_FrequencyFilter, self), pulMultiplier);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_LNBInfo_Value = @import("../zig.zig").Guid.initString("992cf102-49f9-4719-a664-c4f23e2408f4");
pub const IID_IBDA_LNBInfo = &IID_IBDA_LNBInfo_Value;
pub const IBDA_LNBInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscilatorFrequencyLowBand: fn(
            self: *const IBDA_LNBInfo,
            ulLOFLow: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscilatorFrequencyLowBand: fn(
            self: *const IBDA_LNBInfo,
            pulLOFLow: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscilatorFrequencyHighBand: fn(
            self: *const IBDA_LNBInfo,
            ulLOFHigh: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscilatorFrequencyHighBand: fn(
            self: *const IBDA_LNBInfo,
            pulLOFHigh: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HighLowSwitchFrequency: fn(
            self: *const IBDA_LNBInfo,
            ulSwitchFrequency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HighLowSwitchFrequency: fn(
            self: *const IBDA_LNBInfo,
            pulSwitchFrequency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_put_LocalOscilatorFrequencyLowBand(self: *const T, ulLOFLow: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_LNBInfo.VTable, self.vtable).put_LocalOscilatorFrequencyLowBand(@ptrCast(*const IBDA_LNBInfo, self), ulLOFLow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_get_LocalOscilatorFrequencyLowBand(self: *const T, pulLOFLow: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_LNBInfo.VTable, self.vtable).get_LocalOscilatorFrequencyLowBand(@ptrCast(*const IBDA_LNBInfo, self), pulLOFLow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_put_LocalOscilatorFrequencyHighBand(self: *const T, ulLOFHigh: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_LNBInfo.VTable, self.vtable).put_LocalOscilatorFrequencyHighBand(@ptrCast(*const IBDA_LNBInfo, self), ulLOFHigh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_get_LocalOscilatorFrequencyHighBand(self: *const T, pulLOFHigh: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_LNBInfo.VTable, self.vtable).get_LocalOscilatorFrequencyHighBand(@ptrCast(*const IBDA_LNBInfo, self), pulLOFHigh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_put_HighLowSwitchFrequency(self: *const T, ulSwitchFrequency: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_LNBInfo.VTable, self.vtable).put_HighLowSwitchFrequency(@ptrCast(*const IBDA_LNBInfo, self), ulSwitchFrequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_get_HighLowSwitchFrequency(self: *const T, pulSwitchFrequency: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_LNBInfo.VTable, self.vtable).get_HighLowSwitchFrequency(@ptrCast(*const IBDA_LNBInfo, self), pulSwitchFrequency);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DiseqCommand_Value = @import("../zig.zig").Guid.initString("f84e2ab0-3c6b-45e3-a0fc-8669d4b81f11");
pub const IID_IBDA_DiseqCommand = &IID_IBDA_DiseqCommand_Value;
pub const IBDA_DiseqCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableDiseqCommands: fn(
            self: *const IBDA_DiseqCommand,
            bEnable: BOOLEAN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqLNBSource: fn(
            self: *const IBDA_DiseqCommand,
            ulLNBSource: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqUseToneBurst: fn(
            self: *const IBDA_DiseqCommand,
            bUseToneBurst: BOOLEAN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqRepeats: fn(
            self: *const IBDA_DiseqCommand,
            ulRepeats: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqSendCommand: fn(
            self: *const IBDA_DiseqCommand,
            ulRequestId: u32,
            ulcbCommandLen: u32,
            pbCommand: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiseqResponse: fn(
            self: *const IBDA_DiseqCommand,
            ulRequestId: u32,
            pulcbResponseLen: ?*u32,
            pbResponse: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_EnableDiseqCommands(self: *const T, bEnable: BOOLEAN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DiseqCommand.VTable, self.vtable).put_EnableDiseqCommands(@ptrCast(*const IBDA_DiseqCommand, self), bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_DiseqLNBSource(self: *const T, ulLNBSource: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DiseqCommand.VTable, self.vtable).put_DiseqLNBSource(@ptrCast(*const IBDA_DiseqCommand, self), ulLNBSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_DiseqUseToneBurst(self: *const T, bUseToneBurst: BOOLEAN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DiseqCommand.VTable, self.vtable).put_DiseqUseToneBurst(@ptrCast(*const IBDA_DiseqCommand, self), bUseToneBurst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_DiseqRepeats(self: *const T, ulRepeats: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DiseqCommand.VTable, self.vtable).put_DiseqRepeats(@ptrCast(*const IBDA_DiseqCommand, self), ulRepeats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_DiseqSendCommand(self: *const T, ulRequestId: u32, ulcbCommandLen: u32, pbCommand: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DiseqCommand.VTable, self.vtable).put_DiseqSendCommand(@ptrCast(*const IBDA_DiseqCommand, self), ulRequestId, ulcbCommandLen, pbCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_get_DiseqResponse(self: *const T, ulRequestId: u32, pulcbResponseLen: ?*u32, pbResponse: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DiseqCommand.VTable, self.vtable).get_DiseqResponse(@ptrCast(*const IBDA_DiseqCommand, self), ulRequestId, pulcbResponseLen, pbResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_AutoDemodulate_Value = @import("../zig.zig").Guid.initString("ddf15b12-bd25-11d2-9ca0-00c04f7971e0");
pub const IID_IBDA_AutoDemodulate = &IID_IBDA_AutoDemodulate_Value;
pub const IBDA_AutoDemodulate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoDemodulate: fn(
            self: *const IBDA_AutoDemodulate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AutoDemodulate_put_AutoDemodulate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_AutoDemodulate.VTable, self.vtable).put_AutoDemodulate(@ptrCast(*const IBDA_AutoDemodulate, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_AutoDemodulateEx_Value = @import("../zig.zig").Guid.initString("34518d13-1182-48e6-b28f-b24987787326");
pub const IID_IBDA_AutoDemodulateEx = &IID_IBDA_AutoDemodulateEx_Value;
pub const IBDA_AutoDemodulateEx = extern struct {
    pub const VTable = extern struct {
        base: IBDA_AutoDemodulate.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedDeviceNodeTypes: fn(
            self: *const IBDA_AutoDemodulateEx,
            ulcDeviceNodeTypesMax: u32,
            pulcDeviceNodeTypes: ?*u32,
            pguidDeviceNodeTypes: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedVideoFormats: fn(
            self: *const IBDA_AutoDemodulateEx,
            pulAMTunerModeType: ?*u32,
            pulAnalogVideoStandard: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuxInputCount: fn(
            self: *const IBDA_AutoDemodulateEx,
            pulCompositeCount: ?*u32,
            pulSvideoCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBDA_AutoDemodulate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AutoDemodulateEx_get_SupportedDeviceNodeTypes(self: *const T, ulcDeviceNodeTypesMax: u32, pulcDeviceNodeTypes: ?*u32, pguidDeviceNodeTypes: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_AutoDemodulateEx.VTable, self.vtable).get_SupportedDeviceNodeTypes(@ptrCast(*const IBDA_AutoDemodulateEx, self), ulcDeviceNodeTypesMax, pulcDeviceNodeTypes, pguidDeviceNodeTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AutoDemodulateEx_get_SupportedVideoFormats(self: *const T, pulAMTunerModeType: ?*u32, pulAnalogVideoStandard: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_AutoDemodulateEx.VTable, self.vtable).get_SupportedVideoFormats(@ptrCast(*const IBDA_AutoDemodulateEx, self), pulAMTunerModeType, pulAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AutoDemodulateEx_get_AuxInputCount(self: *const T, pulCompositeCount: ?*u32, pulSvideoCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_AutoDemodulateEx.VTable, self.vtable).get_AuxInputCount(@ptrCast(*const IBDA_AutoDemodulateEx, self), pulCompositeCount, pulSvideoCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DigitalDemodulator_Value = @import("../zig.zig").Guid.initString("ef30f379-985b-4d10-b640-a79d5e04e1e0");
pub const IID_IBDA_DigitalDemodulator = &IID_IBDA_DigitalDemodulator_Value;
pub const IBDA_DigitalDemodulator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ModulationType: fn(
            self: *const IBDA_DigitalDemodulator,
            pModulationType: ?*ModulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModulationType: fn(
            self: *const IBDA_DigitalDemodulator,
            pModulationType: ?*ModulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFECMethod: fn(
            self: *const IBDA_DigitalDemodulator,
            pFECMethod: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFECMethod: fn(
            self: *const IBDA_DigitalDemodulator,
            pFECMethod: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFECRate: fn(
            self: *const IBDA_DigitalDemodulator,
            pFECRate: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFECRate: fn(
            self: *const IBDA_DigitalDemodulator,
            pFECRate: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFECMethod: fn(
            self: *const IBDA_DigitalDemodulator,
            pFECMethod: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFECMethod: fn(
            self: *const IBDA_DigitalDemodulator,
            pFECMethod: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFECRate: fn(
            self: *const IBDA_DigitalDemodulator,
            pFECRate: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFECRate: fn(
            self: *const IBDA_DigitalDemodulator,
            pFECRate: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SymbolRate: fn(
            self: *const IBDA_DigitalDemodulator,
            pSymbolRate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SymbolRate: fn(
            self: *const IBDA_DigitalDemodulator,
            pSymbolRate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SpectralInversion: fn(
            self: *const IBDA_DigitalDemodulator,
            pSpectralInversion: ?*SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SpectralInversion: fn(
            self: *const IBDA_DigitalDemodulator,
            pSpectralInversion: ?*SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_ModulationType(self: *const T, pModulationType: ?*ModulationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).put_ModulationType(@ptrCast(*const IBDA_DigitalDemodulator, self), pModulationType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_ModulationType(self: *const T, pModulationType: ?*ModulationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).get_ModulationType(@ptrCast(*const IBDA_DigitalDemodulator, self), pModulationType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_InnerFECMethod(self: *const T, pFECMethod: ?*FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).put_InnerFECMethod(@ptrCast(*const IBDA_DigitalDemodulator, self), pFECMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_InnerFECMethod(self: *const T, pFECMethod: ?*FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).get_InnerFECMethod(@ptrCast(*const IBDA_DigitalDemodulator, self), pFECMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_InnerFECRate(self: *const T, pFECRate: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).put_InnerFECRate(@ptrCast(*const IBDA_DigitalDemodulator, self), pFECRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_InnerFECRate(self: *const T, pFECRate: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).get_InnerFECRate(@ptrCast(*const IBDA_DigitalDemodulator, self), pFECRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_OuterFECMethod(self: *const T, pFECMethod: ?*FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).put_OuterFECMethod(@ptrCast(*const IBDA_DigitalDemodulator, self), pFECMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_OuterFECMethod(self: *const T, pFECMethod: ?*FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).get_OuterFECMethod(@ptrCast(*const IBDA_DigitalDemodulator, self), pFECMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_OuterFECRate(self: *const T, pFECRate: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).put_OuterFECRate(@ptrCast(*const IBDA_DigitalDemodulator, self), pFECRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_OuterFECRate(self: *const T, pFECRate: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).get_OuterFECRate(@ptrCast(*const IBDA_DigitalDemodulator, self), pFECRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_SymbolRate(self: *const T, pSymbolRate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).put_SymbolRate(@ptrCast(*const IBDA_DigitalDemodulator, self), pSymbolRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_SymbolRate(self: *const T, pSymbolRate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).get_SymbolRate(@ptrCast(*const IBDA_DigitalDemodulator, self), pSymbolRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_SpectralInversion(self: *const T, pSpectralInversion: ?*SpectralInversion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).put_SpectralInversion(@ptrCast(*const IBDA_DigitalDemodulator, self), pSpectralInversion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_SpectralInversion(self: *const T, pSpectralInversion: ?*SpectralInversion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator.VTable, self.vtable).get_SpectralInversion(@ptrCast(*const IBDA_DigitalDemodulator, self), pSpectralInversion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DigitalDemodulator2_Value = @import("../zig.zig").Guid.initString("525ed3ee-5cf3-4e1e-9a06-5368a84f9a6e");
pub const IID_IBDA_DigitalDemodulator2 = &IID_IBDA_DigitalDemodulator2_Value;
pub const IBDA_DigitalDemodulator2 = extern struct {
    pub const VTable = extern struct {
        base: IBDA_DigitalDemodulator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GuardInterval: fn(
            self: *const IBDA_DigitalDemodulator2,
            pGuardInterval: ?*GuardInterval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GuardInterval: fn(
            self: *const IBDA_DigitalDemodulator2,
            pGuardInterval: ?*GuardInterval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TransmissionMode: fn(
            self: *const IBDA_DigitalDemodulator2,
            pTransmissionMode: ?*TransmissionMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TransmissionMode: fn(
            self: *const IBDA_DigitalDemodulator2,
            pTransmissionMode: ?*TransmissionMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RollOff: fn(
            self: *const IBDA_DigitalDemodulator2,
            pRollOff: ?*RollOff,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RollOff: fn(
            self: *const IBDA_DigitalDemodulator2,
            pRollOff: ?*RollOff,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pilot: fn(
            self: *const IBDA_DigitalDemodulator2,
            pPilot: ?*Pilot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pilot: fn(
            self: *const IBDA_DigitalDemodulator2,
            pPilot: ?*Pilot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBDA_DigitalDemodulator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_put_GuardInterval(self: *const T, pGuardInterval: ?*GuardInterval) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator2.VTable, self.vtable).put_GuardInterval(@ptrCast(*const IBDA_DigitalDemodulator2, self), pGuardInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_get_GuardInterval(self: *const T, pGuardInterval: ?*GuardInterval) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator2.VTable, self.vtable).get_GuardInterval(@ptrCast(*const IBDA_DigitalDemodulator2, self), pGuardInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_put_TransmissionMode(self: *const T, pTransmissionMode: ?*TransmissionMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator2.VTable, self.vtable).put_TransmissionMode(@ptrCast(*const IBDA_DigitalDemodulator2, self), pTransmissionMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_get_TransmissionMode(self: *const T, pTransmissionMode: ?*TransmissionMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator2.VTable, self.vtable).get_TransmissionMode(@ptrCast(*const IBDA_DigitalDemodulator2, self), pTransmissionMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_put_RollOff(self: *const T, pRollOff: ?*RollOff) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator2.VTable, self.vtable).put_RollOff(@ptrCast(*const IBDA_DigitalDemodulator2, self), pRollOff);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_get_RollOff(self: *const T, pRollOff: ?*RollOff) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator2.VTable, self.vtable).get_RollOff(@ptrCast(*const IBDA_DigitalDemodulator2, self), pRollOff);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_put_Pilot(self: *const T, pPilot: ?*Pilot) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator2.VTable, self.vtable).put_Pilot(@ptrCast(*const IBDA_DigitalDemodulator2, self), pPilot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_get_Pilot(self: *const T, pPilot: ?*Pilot) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator2.VTable, self.vtable).get_Pilot(@ptrCast(*const IBDA_DigitalDemodulator2, self), pPilot);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DigitalDemodulator3_Value = @import("../zig.zig").Guid.initString("13f19604-7d32-4359-93a2-a05205d90ac9");
pub const IID_IBDA_DigitalDemodulator3 = &IID_IBDA_DigitalDemodulator3_Value;
pub const IBDA_DigitalDemodulator3 = extern struct {
    pub const VTable = extern struct {
        base: IBDA_DigitalDemodulator2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalTimeouts: fn(
            self: *const IBDA_DigitalDemodulator3,
            pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalTimeouts: fn(
            self: *const IBDA_DigitalDemodulator3,
            pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PLPNumber: fn(
            self: *const IBDA_DigitalDemodulator3,
            pPLPNumber: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PLPNumber: fn(
            self: *const IBDA_DigitalDemodulator3,
            pPLPNumber: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBDA_DigitalDemodulator2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator3_put_SignalTimeouts(self: *const T, pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator3.VTable, self.vtable).put_SignalTimeouts(@ptrCast(*const IBDA_DigitalDemodulator3, self), pSignalTimeouts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator3_get_SignalTimeouts(self: *const T, pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator3.VTable, self.vtable).get_SignalTimeouts(@ptrCast(*const IBDA_DigitalDemodulator3, self), pSignalTimeouts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator3_put_PLPNumber(self: *const T, pPLPNumber: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator3.VTable, self.vtable).put_PLPNumber(@ptrCast(*const IBDA_DigitalDemodulator3, self), pPLPNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator3_get_PLPNumber(self: *const T, pPLPNumber: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DigitalDemodulator3.VTable, self.vtable).get_PLPNumber(@ptrCast(*const IBDA_DigitalDemodulator3, self), pPLPNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const KSPROPERTY_IPSINK = enum(u32) {
    MULTICASTLIST = 0,
    ADAPTER_DESCRIPTION = 1,
    ADAPTER_ADDRESS = 2,
    _,
    pub fn initFlags(o: struct {
        MULTICASTLIST: u1 = 0,
        ADAPTER_DESCRIPTION: u1 = 0,
        ADAPTER_ADDRESS: u1 = 0,
    }) KSPROPERTY_IPSINK {
        return @intToEnum(KSPROPERTY_IPSINK,
              (if (o.MULTICASTLIST == 1) @enumToInt(KSPROPERTY_IPSINK.MULTICASTLIST) else 0)
            | (if (o.ADAPTER_DESCRIPTION == 1) @enumToInt(KSPROPERTY_IPSINK.ADAPTER_DESCRIPTION) else 0)
            | (if (o.ADAPTER_ADDRESS == 1) @enumToInt(KSPROPERTY_IPSINK.ADAPTER_ADDRESS) else 0)
        );
    }
};
pub const KSPROPERTY_IPSINK_MULTICASTLIST = KSPROPERTY_IPSINK.MULTICASTLIST;
pub const KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION = KSPROPERTY_IPSINK.ADAPTER_DESCRIPTION;
pub const KSPROPERTY_IPSINK_ADAPTER_ADDRESS = KSPROPERTY_IPSINK.ADAPTER_ADDRESS;

const IID_ICCSubStreamFiltering_Value = @import("../zig.zig").Guid.initString("4b2bd7ea-8347-467b-8dbf-62f784929cc3");
pub const IID_ICCSubStreamFiltering = &IID_ICCSubStreamFiltering_Value;
pub const ICCSubStreamFiltering = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubstreamTypes: fn(
            self: *const ICCSubStreamFiltering,
            pTypes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SubstreamTypes: fn(
            self: *const ICCSubStreamFiltering,
            Types: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICCSubStreamFiltering_get_SubstreamTypes(self: *const T, pTypes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICCSubStreamFiltering.VTable, self.vtable).get_SubstreamTypes(@ptrCast(*const ICCSubStreamFiltering, self), pTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICCSubStreamFiltering_put_SubstreamTypes(self: *const T, Types: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICCSubStreamFiltering.VTable, self.vtable).put_SubstreamTypes(@ptrCast(*const ICCSubStreamFiltering, self), Types);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPSinkControl_Value = @import("../zig.zig").Guid.initString("3f4dc8e2-4050-11d3-8f4b-00c04f7971e2");
pub const IID_IBDA_IPSinkControl = &IID_IBDA_IPSinkControl_Value;
pub const IBDA_IPSinkControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastList: fn(
            self: *const IBDA_IPSinkControl,
            pulcbSize: ?*u32,
            pbBuffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterIPAddress: fn(
            self: *const IBDA_IPSinkControl,
            pulcbSize: ?*u32,
            pbBuffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkControl_GetMulticastList(self: *const T, pulcbSize: ?*u32, pbBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPSinkControl.VTable, self.vtable).GetMulticastList(@ptrCast(*const IBDA_IPSinkControl, self), pulcbSize, pbBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkControl_GetAdapterIPAddress(self: *const T, pulcbSize: ?*u32, pbBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPSinkControl.VTable, self.vtable).GetAdapterIPAddress(@ptrCast(*const IBDA_IPSinkControl, self), pulcbSize, pbBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPSinkInfo_Value = @import("../zig.zig").Guid.initString("a750108f-492e-4d51-95f7-649b23ff7ad7");
pub const IID_IBDA_IPSinkInfo = &IID_IBDA_IPSinkInfo_Value;
pub const IBDA_IPSinkInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MulticastList: fn(
            self: *const IBDA_IPSinkInfo,
            pulcbAddresses: ?*u32,
            ppbAddressList: [*]?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AdapterIPAddress: fn(
            self: *const IBDA_IPSinkInfo,
            pbstrBuffer: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AdapterDescription: fn(
            self: *const IBDA_IPSinkInfo,
            pbstrBuffer: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkInfo_get_MulticastList(self: *const T, pulcbAddresses: ?*u32, ppbAddressList: [*]?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPSinkInfo.VTable, self.vtable).get_MulticastList(@ptrCast(*const IBDA_IPSinkInfo, self), pulcbAddresses, ppbAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkInfo_get_AdapterIPAddress(self: *const T, pbstrBuffer: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPSinkInfo.VTable, self.vtable).get_AdapterIPAddress(@ptrCast(*const IBDA_IPSinkInfo, self), pbstrBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkInfo_get_AdapterDescription(self: *const T, pbstrBuffer: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_IPSinkInfo.VTable, self.vtable).get_AdapterDescription(@ptrCast(*const IBDA_IPSinkInfo, self), pbstrBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumPIDMap_Value = @import("../zig.zig").Guid.initString("afb6c2a2-2c41-11d3-8a60-0000f81e0e4a");
pub const IID_IEnumPIDMap = &IID_IEnumPIDMap_Value;
pub const IEnumPIDMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumPIDMap,
            cRequest: u32,
            pPIDMap: [*]PID_MAP,
            pcReceived: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumPIDMap,
            cRecords: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumPIDMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumPIDMap,
            ppIEnumPIDMap: ?*?*IEnumPIDMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPIDMap_Next(self: *const T, cRequest: u32, pPIDMap: [*]PID_MAP, pcReceived: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPIDMap.VTable, self.vtable).Next(@ptrCast(*const IEnumPIDMap, self), cRequest, pPIDMap, pcReceived);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPIDMap_Skip(self: *const T, cRecords: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPIDMap.VTable, self.vtable).Skip(@ptrCast(*const IEnumPIDMap, self), cRecords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPIDMap_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPIDMap.VTable, self.vtable).Reset(@ptrCast(*const IEnumPIDMap, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPIDMap_Clone(self: *const T, ppIEnumPIDMap: ?*?*IEnumPIDMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPIDMap.VTable, self.vtable).Clone(@ptrCast(*const IEnumPIDMap, self), ppIEnumPIDMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2PIDMap_Value = @import("../zig.zig").Guid.initString("afb6c2a1-2c41-11d3-8a60-0000f81e0e4a");
pub const IID_IMPEG2PIDMap = &IID_IMPEG2PIDMap_Value;
pub const IMPEG2PIDMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapPID: fn(
            self: *const IMPEG2PIDMap,
            culPID: u32,
            pulPID: ?*u32,
            MediaSampleContent: MEDIA_SAMPLE_CONTENT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnmapPID: fn(
            self: *const IMPEG2PIDMap,
            culPID: u32,
            pulPID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPIDMap: fn(
            self: *const IMPEG2PIDMap,
            pIEnumPIDMap: ?*?*IEnumPIDMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2PIDMap_MapPID(self: *const T, culPID: u32, pulPID: ?*u32, MediaSampleContent: MEDIA_SAMPLE_CONTENT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2PIDMap.VTable, self.vtable).MapPID(@ptrCast(*const IMPEG2PIDMap, self), culPID, pulPID, MediaSampleContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2PIDMap_UnmapPID(self: *const T, culPID: u32, pulPID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2PIDMap.VTable, self.vtable).UnmapPID(@ptrCast(*const IMPEG2PIDMap, self), culPID, pulPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2PIDMap_EnumPIDMap(self: *const T, pIEnumPIDMap: ?*?*IEnumPIDMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2PIDMap.VTable, self.vtable).EnumPIDMap(@ptrCast(*const IMPEG2PIDMap, self), pIEnumPIDMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFrequencyMap_Value = @import("../zig.zig").Guid.initString("06fb45c1-693c-4ea7-b79f-7a6a54d8def2");
pub const IID_IFrequencyMap = &IID_IFrequencyMap_Value;
pub const IFrequencyMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyMapping: fn(
            self: *const IFrequencyMap,
            ulCount: ?*u32,
            ppulList: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyMapping: fn(
            self: *const IFrequencyMap,
            ulCount: u32,
            pList: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: fn(
            self: *const IFrequencyMap,
            pulCountryCode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: fn(
            self: *const IFrequencyMap,
            ulCountryCode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultFrequencyMapping: fn(
            self: *const IFrequencyMap,
            ulCountryCode: u32,
            pulCount: ?*u32,
            ppulList: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCodeList: fn(
            self: *const IFrequencyMap,
            pulCount: ?*u32,
            ppulList: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_get_FrequencyMapping(self: *const T, ulCount: ?*u32, ppulList: ?*?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrequencyMap.VTable, self.vtable).get_FrequencyMapping(@ptrCast(*const IFrequencyMap, self), ulCount, ppulList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_put_FrequencyMapping(self: *const T, ulCount: u32, pList: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrequencyMap.VTable, self.vtable).put_FrequencyMapping(@ptrCast(*const IFrequencyMap, self), ulCount, pList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_get_CountryCode(self: *const T, pulCountryCode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrequencyMap.VTable, self.vtable).get_CountryCode(@ptrCast(*const IFrequencyMap, self), pulCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_put_CountryCode(self: *const T, ulCountryCode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrequencyMap.VTable, self.vtable).put_CountryCode(@ptrCast(*const IFrequencyMap, self), ulCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_get_DefaultFrequencyMapping(self: *const T, ulCountryCode: u32, pulCount: ?*u32, ppulList: ?*?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrequencyMap.VTable, self.vtable).get_DefaultFrequencyMapping(@ptrCast(*const IFrequencyMap, self), ulCountryCode, pulCount, ppulList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_get_CountryCodeList(self: *const T, pulCount: ?*u32, ppulList: ?*?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrequencyMap.VTable, self.vtable).get_CountryCodeList(@ptrCast(*const IFrequencyMap, self), pulCount, ppulList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_EasMessage_Value = @import("../zig.zig").Guid.initString("d806973d-3ebe-46de-8fbb-6358fe784208");
pub const IID_IBDA_EasMessage = &IID_IBDA_EasMessage_Value;
pub const IBDA_EasMessage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EasMessage: fn(
            self: *const IBDA_EasMessage,
            ulEventID: u32,
            ppEASObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EasMessage_get_EasMessage(self: *const T, ulEventID: u32, ppEASObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_EasMessage.VTable, self.vtable).get_EasMessage(@ptrCast(*const IBDA_EasMessage, self), ulEventID, ppEASObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_TransportStreamInfo_Value = @import("../zig.zig").Guid.initString("8e882535-5f86-47ab-86cf-c281a72a0549");
pub const IID_IBDA_TransportStreamInfo = &IID_IBDA_TransportStreamInfo_Value;
pub const IBDA_TransportStreamInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PatTableTickCount: fn(
            self: *const IBDA_TransportStreamInfo,
            pPatTickCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TransportStreamInfo_get_PatTableTickCount(self: *const T, pPatTickCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_TransportStreamInfo.VTable, self.vtable).get_PatTableTickCount(@ptrCast(*const IBDA_TransportStreamInfo, self), pPatTickCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_ConditionalAccess_Value = @import("../zig.zig").Guid.initString("cd51f1e0-7be9-4123-8482-a2a796c0a6b0");
pub const IID_IBDA_ConditionalAccess = &IID_IBDA_ConditionalAccess_Value;
pub const IBDA_ConditionalAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmartCardStatus: fn(
            self: *const IBDA_ConditionalAccess,
            pCardStatus: ?*SmartCardStatusType,
            pCardAssociation: ?*SmartCardAssociationType,
            pbstrCardError: ?*?BSTR,
            pfOOBLocked: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmartCardInfo: fn(
            self: *const IBDA_ConditionalAccess,
            pbstrCardName: ?*?BSTR,
            pbstrCardManufacturer: ?*?BSTR,
            pfDaylightSavings: ?*i16,
            pbyRatingRegion: ?*u8,
            plTimeZoneOffsetMinutes: ?*i32,
            pbstrLanguage: ?*?BSTR,
            pEALocationCode: ?*EALocationCodeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmartCardApplications: fn(
            self: *const IBDA_ConditionalAccess,
            pulcApplications: ?*u32,
            ulcApplicationsMax: u32,
            rgApplications: [*]SmartCardApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Entitlement: fn(
            self: *const IBDA_ConditionalAccess,
            usVirtualChannel: u16,
            pEntitlement: ?*EntitlementType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TuneByChannel: fn(
            self: *const IBDA_ConditionalAccess,
            usVirtualChannel: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProgram: fn(
            self: *const IBDA_ConditionalAccess,
            usProgramNumber: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProgram: fn(
            self: *const IBDA_ConditionalAccess,
            usProgramNumber: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProgram: fn(
            self: *const IBDA_ConditionalAccess,
            usProgramNumber: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleUI: fn(
            self: *const IBDA_ConditionalAccess,
            byDialogNumber: u8,
            pbstrURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InformUIClosed: fn(
            self: *const IBDA_ConditionalAccess,
            byDialogNumber: u8,
            CloseReason: UICloseReasonType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_get_SmartCardStatus(self: *const T, pCardStatus: ?*SmartCardStatusType, pCardAssociation: ?*SmartCardAssociationType, pbstrCardError: ?*?BSTR, pfOOBLocked: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).get_SmartCardStatus(@ptrCast(*const IBDA_ConditionalAccess, self), pCardStatus, pCardAssociation, pbstrCardError, pfOOBLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_get_SmartCardInfo(self: *const T, pbstrCardName: ?*?BSTR, pbstrCardManufacturer: ?*?BSTR, pfDaylightSavings: ?*i16, pbyRatingRegion: ?*u8, plTimeZoneOffsetMinutes: ?*i32, pbstrLanguage: ?*?BSTR, pEALocationCode: ?*EALocationCodeType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).get_SmartCardInfo(@ptrCast(*const IBDA_ConditionalAccess, self), pbstrCardName, pbstrCardManufacturer, pfDaylightSavings, pbyRatingRegion, plTimeZoneOffsetMinutes, pbstrLanguage, pEALocationCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_get_SmartCardApplications(self: *const T, pulcApplications: ?*u32, ulcApplicationsMax: u32, rgApplications: [*]SmartCardApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).get_SmartCardApplications(@ptrCast(*const IBDA_ConditionalAccess, self), pulcApplications, ulcApplicationsMax, rgApplications);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_get_Entitlement(self: *const T, usVirtualChannel: u16, pEntitlement: ?*EntitlementType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).get_Entitlement(@ptrCast(*const IBDA_ConditionalAccess, self), usVirtualChannel, pEntitlement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_TuneByChannel(self: *const T, usVirtualChannel: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).TuneByChannel(@ptrCast(*const IBDA_ConditionalAccess, self), usVirtualChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_SetProgram(self: *const T, usProgramNumber: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).SetProgram(@ptrCast(*const IBDA_ConditionalAccess, self), usProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_AddProgram(self: *const T, usProgramNumber: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).AddProgram(@ptrCast(*const IBDA_ConditionalAccess, self), usProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_RemoveProgram(self: *const T, usProgramNumber: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).RemoveProgram(@ptrCast(*const IBDA_ConditionalAccess, self), usProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_GetModuleUI(self: *const T, byDialogNumber: u8, pbstrURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).GetModuleUI(@ptrCast(*const IBDA_ConditionalAccess, self), byDialogNumber, pbstrURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_InformUIClosed(self: *const T, byDialogNumber: u8, CloseReason: UICloseReasonType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccess.VTable, self.vtable).InformUIClosed(@ptrCast(*const IBDA_ConditionalAccess, self), byDialogNumber, CloseReason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DiagnosticProperties_Value = @import("../zig.zig").Guid.initString("20e80cb5-c543-4c1b-8eb3-49e719eee7d4");
pub const IID_IBDA_DiagnosticProperties = &IID_IBDA_DiagnosticProperties_Value;
pub const IBDA_DiagnosticProperties = extern struct {
    pub const VTable = extern struct {
        base: IPropertyBag.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPropertyBag.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_DRM_Value = @import("../zig.zig").Guid.initString("f98d88b0-1992-4cd6-a6d9-b9afab99330d");
pub const IID_IBDA_DRM = &IID_IBDA_DRM_Value;
pub const IBDA_DRM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDRMPairingStatus: fn(
            self: *const IBDA_DRM,
            pdwStatus: ?*u32,
            phError: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PerformDRMPairing: fn(
            self: *const IBDA_DRM,
            fSync: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRM_GetDRMPairingStatus(self: *const T, pdwStatus: ?*u32, phError: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRM.VTable, self.vtable).GetDRMPairingStatus(@ptrCast(*const IBDA_DRM, self), pdwStatus, phError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRM_PerformDRMPairing(self: *const T, fSync: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRM.VTable, self.vtable).PerformDRMPairing(@ptrCast(*const IBDA_DRM, self), fSync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_NameValueService_Value = @import("../zig.zig").Guid.initString("7f0b3150-7b81-4ad4-98e3-7e9097094301");
pub const IID_IBDA_NameValueService = &IID_IBDA_NameValueService_Value;
pub const IBDA_NameValueService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValueNameByIndex: fn(
            self: *const IBDA_NameValueService,
            ulIndex: u32,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IBDA_NameValueService,
            bstrName: ?BSTR,
            bstrLanguage: ?BSTR,
            pbstrValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const IBDA_NameValueService,
            ulDialogRequest: u32,
            bstrLanguage: ?BSTR,
            bstrName: ?BSTR,
            bstrValue: ?BSTR,
            ulReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NameValueService_GetValueNameByIndex(self: *const T, ulIndex: u32, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NameValueService.VTable, self.vtable).GetValueNameByIndex(@ptrCast(*const IBDA_NameValueService, self), ulIndex, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NameValueService_GetValue(self: *const T, bstrName: ?BSTR, bstrLanguage: ?BSTR, pbstrValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NameValueService.VTable, self.vtable).GetValue(@ptrCast(*const IBDA_NameValueService, self), bstrName, bstrLanguage, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NameValueService_SetValue(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, bstrName: ?BSTR, bstrValue: ?BSTR, ulReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_NameValueService.VTable, self.vtable).SetValue(@ptrCast(*const IBDA_NameValueService, self), ulDialogRequest, bstrLanguage, bstrName, bstrValue, ulReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_ConditionalAccessEx_Value = @import("../zig.zig").Guid.initString("497c3418-23cb-44ba-bb62-769f506fcea7");
pub const IID_IBDA_ConditionalAccessEx = &IID_IBDA_ConditionalAccessEx_Value;
pub const IBDA_ConditionalAccessEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CheckEntitlementToken: fn(
            self: *const IBDA_ConditionalAccessEx,
            ulDialogRequest: u32,
            bstrLanguage: ?BSTR,
            RequestType: BDA_CONDITIONALACCESS_REQUESTTYPE,
            ulcbEntitlementTokenLen: u32,
            pbEntitlementToken: [*:0]u8,
            pulDescrambleStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaptureToken: fn(
            self: *const IBDA_ConditionalAccessEx,
            ulcbCaptureTokenLen: u32,
            pbCaptureToken: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenBroadcastMmi: fn(
            self: *const IBDA_ConditionalAccessEx,
            ulDialogRequest: u32,
            bstrLanguage: ?BSTR,
            EventId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseMmiDialog: fn(
            self: *const IBDA_ConditionalAccessEx,
            ulDialogRequest: u32,
            bstrLanguage: ?BSTR,
            ulDialogNumber: u32,
            ReasonCode: BDA_CONDITIONALACCESS_MMICLOSEREASON,
            pulSessionResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDialogRequestNumber: fn(
            self: *const IBDA_ConditionalAccessEx,
            pulDialogRequestNumber: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_CheckEntitlementToken(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, RequestType: BDA_CONDITIONALACCESS_REQUESTTYPE, ulcbEntitlementTokenLen: u32, pbEntitlementToken: [*:0]u8, pulDescrambleStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccessEx.VTable, self.vtable).CheckEntitlementToken(@ptrCast(*const IBDA_ConditionalAccessEx, self), ulDialogRequest, bstrLanguage, RequestType, ulcbEntitlementTokenLen, pbEntitlementToken, pulDescrambleStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_SetCaptureToken(self: *const T, ulcbCaptureTokenLen: u32, pbCaptureToken: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccessEx.VTable, self.vtable).SetCaptureToken(@ptrCast(*const IBDA_ConditionalAccessEx, self), ulcbCaptureTokenLen, pbCaptureToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_OpenBroadcastMmi(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, EventId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccessEx.VTable, self.vtable).OpenBroadcastMmi(@ptrCast(*const IBDA_ConditionalAccessEx, self), ulDialogRequest, bstrLanguage, EventId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_CloseMmiDialog(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, ulDialogNumber: u32, ReasonCode: BDA_CONDITIONALACCESS_MMICLOSEREASON, pulSessionResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccessEx.VTable, self.vtable).CloseMmiDialog(@ptrCast(*const IBDA_ConditionalAccessEx, self), ulDialogRequest, bstrLanguage, ulDialogNumber, ReasonCode, pulSessionResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_CreateDialogRequestNumber(self: *const T, pulDialogRequestNumber: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ConditionalAccessEx.VTable, self.vtable).CreateDialogRequestNumber(@ptrCast(*const IBDA_ConditionalAccessEx, self), pulDialogRequestNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_ISDBConditionalAccess_Value = @import("../zig.zig").Guid.initString("5e68c627-16c2-4e6c-b1e2-d00170cdaa0f");
pub const IID_IBDA_ISDBConditionalAccess = &IID_IBDA_ISDBConditionalAccess_Value;
pub const IBDA_ISDBConditionalAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIsdbCasRequest: fn(
            self: *const IBDA_ISDBConditionalAccess,
            ulRequestId: u32,
            ulcbRequestBufferLen: u32,
            pbRequestBuffer: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ISDBConditionalAccess_SetIsdbCasRequest(self: *const T, ulRequestId: u32, ulcbRequestBufferLen: u32, pbRequestBuffer: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_ISDBConditionalAccess.VTable, self.vtable).SetIsdbCasRequest(@ptrCast(*const IBDA_ISDBConditionalAccess, self), ulRequestId, ulcbRequestBufferLen, pbRequestBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_EventingService_Value = @import("../zig.zig").Guid.initString("207c413f-00dc-4c61-bad6-6fee1ff07064");
pub const IID_IBDA_EventingService = &IID_IBDA_EventingService_Value;
pub const IBDA_EventingService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompleteEvent: fn(
            self: *const IBDA_EventingService,
            ulEventID: u32,
            ulEventResult: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EventingService_CompleteEvent(self: *const T, ulEventID: u32, ulEventResult: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_EventingService.VTable, self.vtable).CompleteEvent(@ptrCast(*const IBDA_EventingService, self), ulEventID, ulEventResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_AUX_Value = @import("../zig.zig").Guid.initString("7def4c09-6e66-4567-a819-f0e17f4a81ab");
pub const IID_IBDA_AUX = &IID_IBDA_AUX_Value;
pub const IBDA_AUX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCapabilities: fn(
            self: *const IBDA_AUX,
            pdwNumAuxInputsBSTR: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCapability: fn(
            self: *const IBDA_AUX,
            dwIndex: u32,
            dwInputID: ?*u32,
            pConnectorType: ?*Guid,
            ConnTypeNum: ?*u32,
            NumVideoStds: ?*u32,
            AnalogStds: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AUX_QueryCapabilities(self: *const T, pdwNumAuxInputsBSTR: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_AUX.VTable, self.vtable).QueryCapabilities(@ptrCast(*const IBDA_AUX, self), pdwNumAuxInputsBSTR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AUX_EnumCapability(self: *const T, dwIndex: u32, dwInputID: ?*u32, pConnectorType: ?*Guid, ConnTypeNum: ?*u32, NumVideoStds: ?*u32, AnalogStds: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_AUX.VTable, self.vtable).EnumCapability(@ptrCast(*const IBDA_AUX, self), dwIndex, dwInputID, pConnectorType, ConnTypeNum, NumVideoStds, AnalogStds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_Encoder_Value = @import("../zig.zig").Guid.initString("3a8bad59-59fe-4559-a0ba-396cfaa98ae3");
pub const IID_IBDA_Encoder = &IID_IBDA_Encoder_Value;
pub const IBDA_Encoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCapabilities: fn(
            self: *const IBDA_Encoder,
            NumAudioFmts: ?*u32,
            NumVideoFmts: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAudioCapability: fn(
            self: *const IBDA_Encoder,
            FmtIndex: u32,
            MethodID: ?*u32,
            AlgorithmType: ?*u32,
            SamplingRate: ?*u32,
            BitDepth: ?*u32,
            NumChannels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumVideoCapability: fn(
            self: *const IBDA_Encoder,
            FmtIndex: u32,
            MethodID: ?*u32,
            AlgorithmType: ?*u32,
            VerticalSize: ?*u32,
            HorizontalSize: ?*u32,
            AspectRatio: ?*u32,
            FrameRateCode: ?*u32,
            ProgressiveSequence: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameters: fn(
            self: *const IBDA_Encoder,
            AudioBitrateMode: u32,
            AudioBitrate: u32,
            AudioMethodID: u32,
            AudioProgram: u32,
            VideoBitrateMode: u32,
            VideoBitrate: u32,
            VideoMethodID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IBDA_Encoder,
            AudioBitrateMax: ?*u32,
            AudioBitrateMin: ?*u32,
            AudioBitrateMode: ?*u32,
            AudioBitrateStepping: ?*u32,
            AudioBitrate: ?*u32,
            AudioMethodID: ?*u32,
            AvailableAudioPrograms: ?*u32,
            AudioProgram: ?*u32,
            VideoBitrateMax: ?*u32,
            VideoBitrateMin: ?*u32,
            VideoBitrateMode: ?*u32,
            VideoBitrate: ?*u32,
            VideoBitrateStepping: ?*u32,
            VideoMethodID: ?*u32,
            SignalSourceID: ?*u32,
            SignalFormat: ?*u64,
            SignalLock: ?*BOOL,
            SignalLevel: ?*i32,
            SignalToNoiseRatio: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_QueryCapabilities(self: *const T, NumAudioFmts: ?*u32, NumVideoFmts: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Encoder.VTable, self.vtable).QueryCapabilities(@ptrCast(*const IBDA_Encoder, self), NumAudioFmts, NumVideoFmts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_EnumAudioCapability(self: *const T, FmtIndex: u32, MethodID: ?*u32, AlgorithmType: ?*u32, SamplingRate: ?*u32, BitDepth: ?*u32, NumChannels: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Encoder.VTable, self.vtable).EnumAudioCapability(@ptrCast(*const IBDA_Encoder, self), FmtIndex, MethodID, AlgorithmType, SamplingRate, BitDepth, NumChannels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_EnumVideoCapability(self: *const T, FmtIndex: u32, MethodID: ?*u32, AlgorithmType: ?*u32, VerticalSize: ?*u32, HorizontalSize: ?*u32, AspectRatio: ?*u32, FrameRateCode: ?*u32, ProgressiveSequence: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Encoder.VTable, self.vtable).EnumVideoCapability(@ptrCast(*const IBDA_Encoder, self), FmtIndex, MethodID, AlgorithmType, VerticalSize, HorizontalSize, AspectRatio, FrameRateCode, ProgressiveSequence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_SetParameters(self: *const T, AudioBitrateMode: u32, AudioBitrate: u32, AudioMethodID: u32, AudioProgram: u32, VideoBitrateMode: u32, VideoBitrate: u32, VideoMethodID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Encoder.VTable, self.vtable).SetParameters(@ptrCast(*const IBDA_Encoder, self), AudioBitrateMode, AudioBitrate, AudioMethodID, AudioProgram, VideoBitrateMode, VideoBitrate, VideoMethodID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_GetState(self: *const T, AudioBitrateMax: ?*u32, AudioBitrateMin: ?*u32, AudioBitrateMode: ?*u32, AudioBitrateStepping: ?*u32, AudioBitrate: ?*u32, AudioMethodID: ?*u32, AvailableAudioPrograms: ?*u32, AudioProgram: ?*u32, VideoBitrateMax: ?*u32, VideoBitrateMin: ?*u32, VideoBitrateMode: ?*u32, VideoBitrate: ?*u32, VideoBitrateStepping: ?*u32, VideoMethodID: ?*u32, SignalSourceID: ?*u32, SignalFormat: ?*u64, SignalLock: ?*BOOL, SignalLevel: ?*i32, SignalToNoiseRatio: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_Encoder.VTable, self.vtable).GetState(@ptrCast(*const IBDA_Encoder, self), AudioBitrateMax, AudioBitrateMin, AudioBitrateMode, AudioBitrateStepping, AudioBitrate, AudioMethodID, AvailableAudioPrograms, AudioProgram, VideoBitrateMax, VideoBitrateMin, VideoBitrateMode, VideoBitrate, VideoBitrateStepping, VideoMethodID, SignalSourceID, SignalFormat, SignalLock, SignalLevel, SignalToNoiseRatio);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_FDC_Value = @import("../zig.zig").Guid.initString("138adc7e-58ae-437f-b0b4-c9fe19d5b4ac");
pub const IID_IBDA_FDC = &IID_IBDA_FDC_Value;
pub const IBDA_FDC = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: fn(
            self: *const IBDA_FDC,
            CurrentBitrate: ?*u32,
            CarrierLock: ?*BOOL,
            CurrentFrequency: ?*u32,
            CurrentSpectrumInversion: ?*BOOL,
            CurrentPIDList: ?*?BSTR,
            CurrentTIDList: ?*?BSTR,
            Overflow: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestTables: fn(
            self: *const IBDA_FDC,
            TableIDs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPid: fn(
            self: *const IBDA_FDC,
            PidsToAdd: ?BSTR,
            RemainingFilterEntries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePid: fn(
            self: *const IBDA_FDC,
            PidsToRemove: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTid: fn(
            self: *const IBDA_FDC,
            TidsToAdd: ?BSTR,
            CurrentTidList: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTid: fn(
            self: *const IBDA_FDC,
            TidsToRemove: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableSection: fn(
            self: *const IBDA_FDC,
            Pid: ?*u32,
            MaxBufferSize: u32,
            ActualSize: ?*u32,
            SecBuffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_GetStatus(self: *const T, CurrentBitrate: ?*u32, CarrierLock: ?*BOOL, CurrentFrequency: ?*u32, CurrentSpectrumInversion: ?*BOOL, CurrentPIDList: ?*?BSTR, CurrentTIDList: ?*?BSTR, Overflow: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FDC.VTable, self.vtable).GetStatus(@ptrCast(*const IBDA_FDC, self), CurrentBitrate, CarrierLock, CurrentFrequency, CurrentSpectrumInversion, CurrentPIDList, CurrentTIDList, Overflow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_RequestTables(self: *const T, TableIDs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FDC.VTable, self.vtable).RequestTables(@ptrCast(*const IBDA_FDC, self), TableIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_AddPid(self: *const T, PidsToAdd: ?BSTR, RemainingFilterEntries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FDC.VTable, self.vtable).AddPid(@ptrCast(*const IBDA_FDC, self), PidsToAdd, RemainingFilterEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_RemovePid(self: *const T, PidsToRemove: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FDC.VTable, self.vtable).RemovePid(@ptrCast(*const IBDA_FDC, self), PidsToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_AddTid(self: *const T, TidsToAdd: ?BSTR, CurrentTidList: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FDC.VTable, self.vtable).AddTid(@ptrCast(*const IBDA_FDC, self), TidsToAdd, CurrentTidList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_RemoveTid(self: *const T, TidsToRemove: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FDC.VTable, self.vtable).RemoveTid(@ptrCast(*const IBDA_FDC, self), TidsToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_GetTableSection(self: *const T, Pid: ?*u32, MaxBufferSize: u32, ActualSize: ?*u32, SecBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_FDC.VTable, self.vtable).GetTableSection(@ptrCast(*const IBDA_FDC, self), Pid, MaxBufferSize, ActualSize, SecBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_GuideDataDeliveryService_Value = @import("../zig.zig").Guid.initString("c0afcb73-23e7-4bc6-bafa-fdc167b4719f");
pub const IID_IBDA_GuideDataDeliveryService = &IID_IBDA_GuideDataDeliveryService_Value;
pub const IBDA_GuideDataDeliveryService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGuideDataType: fn(
            self: *const IBDA_GuideDataDeliveryService,
            pguidDataType: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideData: fn(
            self: *const IBDA_GuideDataDeliveryService,
            pulcbBufferLen: ?*u32,
            pbBuffer: ?*u8,
            pulGuideDataPercentageProgress: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestGuideDataUpdate: fn(
            self: *const IBDA_GuideDataDeliveryService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTuneXmlFromServiceIdx: fn(
            self: *const IBDA_GuideDataDeliveryService,
            ul64ServiceIdx: u64,
            pbstrTuneXml: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServices: fn(
            self: *const IBDA_GuideDataDeliveryService,
            pulcbBufferLen: ?*u32,
            pbBuffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceInfoFromTuneXml: fn(
            self: *const IBDA_GuideDataDeliveryService,
            bstrTuneXml: ?BSTR,
            pbstrServiceDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetGuideDataType(self: *const T, pguidDataType: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_GuideDataDeliveryService.VTable, self.vtable).GetGuideDataType(@ptrCast(*const IBDA_GuideDataDeliveryService, self), pguidDataType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetGuideData(self: *const T, pulcbBufferLen: ?*u32, pbBuffer: ?*u8, pulGuideDataPercentageProgress: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_GuideDataDeliveryService.VTable, self.vtable).GetGuideData(@ptrCast(*const IBDA_GuideDataDeliveryService, self), pulcbBufferLen, pbBuffer, pulGuideDataPercentageProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_RequestGuideDataUpdate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_GuideDataDeliveryService.VTable, self.vtable).RequestGuideDataUpdate(@ptrCast(*const IBDA_GuideDataDeliveryService, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetTuneXmlFromServiceIdx(self: *const T, ul64ServiceIdx: u64, pbstrTuneXml: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_GuideDataDeliveryService.VTable, self.vtable).GetTuneXmlFromServiceIdx(@ptrCast(*const IBDA_GuideDataDeliveryService, self), ul64ServiceIdx, pbstrTuneXml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetServices(self: *const T, pulcbBufferLen: ?*u32, pbBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_GuideDataDeliveryService.VTable, self.vtable).GetServices(@ptrCast(*const IBDA_GuideDataDeliveryService, self), pulcbBufferLen, pbBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetServiceInfoFromTuneXml(self: *const T, bstrTuneXml: ?BSTR, pbstrServiceDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_GuideDataDeliveryService.VTable, self.vtable).GetServiceInfoFromTuneXml(@ptrCast(*const IBDA_GuideDataDeliveryService, self), bstrTuneXml, pbstrServiceDescription);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DRMService_Value = @import("../zig.zig").Guid.initString("bff6b5bb-b0ae-484c-9dca-73528fb0b46e");
pub const IID_IBDA_DRMService = &IID_IBDA_DRMService_Value;
pub const IBDA_DRMService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDRM: fn(
            self: *const IBDA_DRMService,
            puuidNewDrm: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDRMStatus: fn(
            self: *const IBDA_DRMService,
            pbstrDrmUuidList: ?*?BSTR,
            DrmUuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRMService_SetDRM(self: *const T, puuidNewDrm: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRMService.VTable, self.vtable).SetDRM(@ptrCast(*const IBDA_DRMService, self), puuidNewDrm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRMService_GetDRMStatus(self: *const T, pbstrDrmUuidList: ?*?BSTR, DrmUuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRMService.VTable, self.vtable).GetDRMStatus(@ptrCast(*const IBDA_DRMService, self), pbstrDrmUuidList, DrmUuid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_WMDRMSession_Value = @import("../zig.zig").Guid.initString("4be6fa3d-07cd-4139-8b80-8c18ba3aec88");
pub const IID_IBDA_WMDRMSession = &IID_IBDA_WMDRMSession_Value;
pub const IBDA_WMDRMSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: fn(
            self: *const IBDA_WMDRMSession,
            MaxCaptureToken: ?*u32,
            MaxStreamingPid: ?*u32,
            MaxLicense: ?*u32,
            MinSecurityLevel: ?*u32,
            RevInfoSequenceNumber: ?*u32,
            RevInfoIssuedTime: ?*u64,
            RevInfoTTL: ?*u32,
            RevListVersion: ?*u32,
            ulState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRevInfo: fn(
            self: *const IBDA_WMDRMSession,
            ulRevInfoLen: u32,
            pbRevInfo: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCrl: fn(
            self: *const IBDA_WMDRMSession,
            ulCrlLen: u32,
            pbCrlLen: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransactMessage: fn(
            self: *const IBDA_WMDRMSession,
            ulcbRequest: u32,
            pbRequest: [*:0]u8,
            pulcbResponse: ?*u32,
            pbResponse: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicense: fn(
            self: *const IBDA_WMDRMSession,
            uuidKey: ?*Guid,
            pulPackageLen: ?*u32,
            pbPackage: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReissueLicense: fn(
            self: *const IBDA_WMDRMSession,
            uuidKey: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenewLicense: fn(
            self: *const IBDA_WMDRMSession,
            ulInXmrLicenseLen: u32,
            pbInXmrLicense: [*:0]u8,
            ulEntitlementTokenLen: u32,
            pbEntitlementToken: [*:0]u8,
            pulDescrambleStatus: ?*u32,
            pulOutXmrLicenseLen: ?*u32,
            pbOutXmrLicense: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyInfo: fn(
            self: *const IBDA_WMDRMSession,
            pulKeyInfoLen: ?*u32,
            pbKeyInfo: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_GetStatus(self: *const T, MaxCaptureToken: ?*u32, MaxStreamingPid: ?*u32, MaxLicense: ?*u32, MinSecurityLevel: ?*u32, RevInfoSequenceNumber: ?*u32, RevInfoIssuedTime: ?*u64, RevInfoTTL: ?*u32, RevListVersion: ?*u32, ulState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMSession.VTable, self.vtable).GetStatus(@ptrCast(*const IBDA_WMDRMSession, self), MaxCaptureToken, MaxStreamingPid, MaxLicense, MinSecurityLevel, RevInfoSequenceNumber, RevInfoIssuedTime, RevInfoTTL, RevListVersion, ulState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_SetRevInfo(self: *const T, ulRevInfoLen: u32, pbRevInfo: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMSession.VTable, self.vtable).SetRevInfo(@ptrCast(*const IBDA_WMDRMSession, self), ulRevInfoLen, pbRevInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_SetCrl(self: *const T, ulCrlLen: u32, pbCrlLen: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMSession.VTable, self.vtable).SetCrl(@ptrCast(*const IBDA_WMDRMSession, self), ulCrlLen, pbCrlLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_TransactMessage(self: *const T, ulcbRequest: u32, pbRequest: [*:0]u8, pulcbResponse: ?*u32, pbResponse: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMSession.VTable, self.vtable).TransactMessage(@ptrCast(*const IBDA_WMDRMSession, self), ulcbRequest, pbRequest, pulcbResponse, pbResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_GetLicense(self: *const T, uuidKey: ?*Guid, pulPackageLen: ?*u32, pbPackage: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMSession.VTable, self.vtable).GetLicense(@ptrCast(*const IBDA_WMDRMSession, self), uuidKey, pulPackageLen, pbPackage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_ReissueLicense(self: *const T, uuidKey: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMSession.VTable, self.vtable).ReissueLicense(@ptrCast(*const IBDA_WMDRMSession, self), uuidKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_RenewLicense(self: *const T, ulInXmrLicenseLen: u32, pbInXmrLicense: [*:0]u8, ulEntitlementTokenLen: u32, pbEntitlementToken: [*:0]u8, pulDescrambleStatus: ?*u32, pulOutXmrLicenseLen: ?*u32, pbOutXmrLicense: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMSession.VTable, self.vtable).RenewLicense(@ptrCast(*const IBDA_WMDRMSession, self), ulInXmrLicenseLen, pbInXmrLicense, ulEntitlementTokenLen, pbEntitlementToken, pulDescrambleStatus, pulOutXmrLicenseLen, pbOutXmrLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_GetKeyInfo(self: *const T, pulKeyInfoLen: ?*u32, pbKeyInfo: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMSession.VTable, self.vtable).GetKeyInfo(@ptrCast(*const IBDA_WMDRMSession, self), pulKeyInfoLen, pbKeyInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_WMDRMTuner_Value = @import("../zig.zig").Guid.initString("86d979cf-a8a7-4f94-b5fb-14c0aca68fe6");
pub const IID_IBDA_WMDRMTuner = &IID_IBDA_WMDRMTuner_Value;
pub const IBDA_WMDRMTuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PurchaseEntitlement: fn(
            self: *const IBDA_WMDRMTuner,
            ulDialogRequest: u32,
            bstrLanguage: ?BSTR,
            ulPurchaseTokenLen: u32,
            pbPurchaseToken: [*:0]u8,
            pulDescrambleStatus: ?*u32,
            pulCaptureTokenLen: ?*u32,
            pbCaptureToken: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelCaptureToken: fn(
            self: *const IBDA_WMDRMTuner,
            ulCaptureTokenLen: u32,
            pbCaptureToken: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPidProtection: fn(
            self: *const IBDA_WMDRMTuner,
            ulPid: u32,
            uuidKey: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPidProtection: fn(
            self: *const IBDA_WMDRMTuner,
            pulPid: u32,
            uuidKey: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncValue: fn(
            self: *const IBDA_WMDRMTuner,
            ulSyncValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartCodeProfile: fn(
            self: *const IBDA_WMDRMTuner,
            pulStartCodeProfileLen: ?*u32,
            pbStartCodeProfile: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_PurchaseEntitlement(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, ulPurchaseTokenLen: u32, pbPurchaseToken: [*:0]u8, pulDescrambleStatus: ?*u32, pulCaptureTokenLen: ?*u32, pbCaptureToken: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMTuner.VTable, self.vtable).PurchaseEntitlement(@ptrCast(*const IBDA_WMDRMTuner, self), ulDialogRequest, bstrLanguage, ulPurchaseTokenLen, pbPurchaseToken, pulDescrambleStatus, pulCaptureTokenLen, pbCaptureToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_CancelCaptureToken(self: *const T, ulCaptureTokenLen: u32, pbCaptureToken: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMTuner.VTable, self.vtable).CancelCaptureToken(@ptrCast(*const IBDA_WMDRMTuner, self), ulCaptureTokenLen, pbCaptureToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_SetPidProtection(self: *const T, ulPid: u32, uuidKey: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMTuner.VTable, self.vtable).SetPidProtection(@ptrCast(*const IBDA_WMDRMTuner, self), ulPid, uuidKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_GetPidProtection(self: *const T, pulPid: u32, uuidKey: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMTuner.VTable, self.vtable).GetPidProtection(@ptrCast(*const IBDA_WMDRMTuner, self), pulPid, uuidKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_SetSyncValue(self: *const T, ulSyncValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMTuner.VTable, self.vtable).SetSyncValue(@ptrCast(*const IBDA_WMDRMTuner, self), ulSyncValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_GetStartCodeProfile(self: *const T, pulStartCodeProfileLen: ?*u32, pbStartCodeProfile: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_WMDRMTuner.VTable, self.vtable).GetStartCodeProfile(@ptrCast(*const IBDA_WMDRMTuner, self), pulStartCodeProfileLen, pbStartCodeProfile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_DRIDRMService_Value = @import("../zig.zig").Guid.initString("1f9bc2a5-44a3-4c52-aab1-0bbce5a1381d");
pub const IID_IBDA_DRIDRMService = &IID_IBDA_DRIDRMService_Value;
pub const IBDA_DRIDRMService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDRM: fn(
            self: *const IBDA_DRIDRMService,
            bstrNewDrm: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDRMStatus: fn(
            self: *const IBDA_DRIDRMService,
            pbstrDrmUuidList: ?*?BSTR,
            DrmUuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPairingStatus: fn(
            self: *const IBDA_DRIDRMService,
            penumPairingStatus: ?*BDA_DrmPairingError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIDRMService_SetDRM(self: *const T, bstrNewDrm: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIDRMService.VTable, self.vtable).SetDRM(@ptrCast(*const IBDA_DRIDRMService, self), bstrNewDrm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIDRMService_GetDRMStatus(self: *const T, pbstrDrmUuidList: ?*?BSTR, DrmUuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIDRMService.VTable, self.vtable).GetDRMStatus(@ptrCast(*const IBDA_DRIDRMService, self), pbstrDrmUuidList, DrmUuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIDRMService_GetPairingStatus(self: *const T, penumPairingStatus: ?*BDA_DrmPairingError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIDRMService.VTable, self.vtable).GetPairingStatus(@ptrCast(*const IBDA_DRIDRMService, self), penumPairingStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DRIWMDRMSession_Value = @import("../zig.zig").Guid.initString("05c690f8-56db-4bb2-b053-79c12098bb26");
pub const IID_IBDA_DRIWMDRMSession = &IID_IBDA_DRIWMDRMSession_Value;
pub const IBDA_DRIWMDRMSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcknowledgeLicense: fn(
            self: *const IBDA_DRIWMDRMSession,
            hrLicenseAck: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessLicenseChallenge: fn(
            self: *const IBDA_DRIWMDRMSession,
            dwcbLicenseMessage: u32,
            pbLicenseMessage: [*:0]u8,
            pdwcbLicenseResponse: ?*u32,
            ppbLicenseResponse: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessRegistrationChallenge: fn(
            self: *const IBDA_DRIWMDRMSession,
            dwcbRegistrationMessage: u32,
            pbRegistrationMessage: [*:0]u8,
            pdwcbRegistrationResponse: ?*u32,
            ppbRegistrationResponse: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRevInfo: fn(
            self: *const IBDA_DRIWMDRMSession,
            dwRevInfoLen: u32,
            pbRevInfo: [*:0]u8,
            pdwResponse: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCrl: fn(
            self: *const IBDA_DRIWMDRMSession,
            dwCrlLen: u32,
            pbCrlLen: [*:0]u8,
            pdwResponse: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHMSAssociationData: fn(
            self: *const IBDA_DRIWMDRMSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastCardeaError: fn(
            self: *const IBDA_DRIWMDRMSession,
            pdwError: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_AcknowledgeLicense(self: *const T, hrLicenseAck: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIWMDRMSession.VTable, self.vtable).AcknowledgeLicense(@ptrCast(*const IBDA_DRIWMDRMSession, self), hrLicenseAck);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_ProcessLicenseChallenge(self: *const T, dwcbLicenseMessage: u32, pbLicenseMessage: [*:0]u8, pdwcbLicenseResponse: ?*u32, ppbLicenseResponse: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIWMDRMSession.VTable, self.vtable).ProcessLicenseChallenge(@ptrCast(*const IBDA_DRIWMDRMSession, self), dwcbLicenseMessage, pbLicenseMessage, pdwcbLicenseResponse, ppbLicenseResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_ProcessRegistrationChallenge(self: *const T, dwcbRegistrationMessage: u32, pbRegistrationMessage: [*:0]u8, pdwcbRegistrationResponse: ?*u32, ppbRegistrationResponse: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIWMDRMSession.VTable, self.vtable).ProcessRegistrationChallenge(@ptrCast(*const IBDA_DRIWMDRMSession, self), dwcbRegistrationMessage, pbRegistrationMessage, pdwcbRegistrationResponse, ppbRegistrationResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_SetRevInfo(self: *const T, dwRevInfoLen: u32, pbRevInfo: [*:0]u8, pdwResponse: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIWMDRMSession.VTable, self.vtable).SetRevInfo(@ptrCast(*const IBDA_DRIWMDRMSession, self), dwRevInfoLen, pbRevInfo, pdwResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_SetCrl(self: *const T, dwCrlLen: u32, pbCrlLen: [*:0]u8, pdwResponse: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIWMDRMSession.VTable, self.vtable).SetCrl(@ptrCast(*const IBDA_DRIWMDRMSession, self), dwCrlLen, pbCrlLen, pdwResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_GetHMSAssociationData(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIWMDRMSession.VTable, self.vtable).GetHMSAssociationData(@ptrCast(*const IBDA_DRIWMDRMSession, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_GetLastCardeaError(self: *const T, pdwError: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_DRIWMDRMSession.VTable, self.vtable).GetLastCardeaError(@ptrCast(*const IBDA_DRIWMDRMSession, self), pdwError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_MUX_Value = @import("../zig.zig").Guid.initString("942aafec-4c05-4c74-b8eb-8706c2a4943f");
pub const IID_IBDA_MUX = &IID_IBDA_MUX_Value;
pub const IBDA_MUX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPidList: fn(
            self: *const IBDA_MUX,
            ulPidListCount: u32,
            pbPidListBuffer: [*]BDA_MUX_PIDLISTITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPidList: fn(
            self: *const IBDA_MUX,
            pulPidListCount: ?*u32,
            pbPidListBuffer: ?*BDA_MUX_PIDLISTITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_MUX_SetPidList(self: *const T, ulPidListCount: u32, pbPidListBuffer: [*]BDA_MUX_PIDLISTITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_MUX.VTable, self.vtable).SetPidList(@ptrCast(*const IBDA_MUX, self), ulPidListCount, pbPidListBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_MUX_GetPidList(self: *const T, pulPidListCount: ?*u32, pbPidListBuffer: ?*BDA_MUX_PIDLISTITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_MUX.VTable, self.vtable).GetPidList(@ptrCast(*const IBDA_MUX, self), pulPidListCount, pbPidListBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_TransportStreamSelector_Value = @import("../zig.zig").Guid.initString("1dcfafe9-b45e-41b3-bb2a-561eb129ae98");
pub const IID_IBDA_TransportStreamSelector = &IID_IBDA_TransportStreamSelector_Value;
pub const IBDA_TransportStreamSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTSID: fn(
            self: *const IBDA_TransportStreamSelector,
            usTSID: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSInformation: fn(
            self: *const IBDA_TransportStreamSelector,
            pulTSInformationBufferLen: ?*u32,
            pbTSInformationBuffer: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TransportStreamSelector_SetTSID(self: *const T, usTSID: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_TransportStreamSelector.VTable, self.vtable).SetTSID(@ptrCast(*const IBDA_TransportStreamSelector, self), usTSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TransportStreamSelector_GetTSInformation(self: *const T, pulTSInformationBufferLen: ?*u32, pbTSInformationBuffer: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_TransportStreamSelector.VTable, self.vtable).GetTSInformation(@ptrCast(*const IBDA_TransportStreamSelector, self), pulTSInformationBufferLen, pbTSInformationBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_UserActivityService_Value = @import("../zig.zig").Guid.initString("53b14189-e478-4b7a-a1ff-506db4b99dfe");
pub const IID_IBDA_UserActivityService = &IID_IBDA_UserActivityService_Value;
pub const IBDA_UserActivityService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCurrentTunerUseReason: fn(
            self: *const IBDA_UserActivityService,
            dwUseReason: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserActivityInterval: fn(
            self: *const IBDA_UserActivityService,
            pdwActivityInterval: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UserActivityDetected: fn(
            self: *const IBDA_UserActivityService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_UserActivityService_SetCurrentTunerUseReason(self: *const T, dwUseReason: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_UserActivityService.VTable, self.vtable).SetCurrentTunerUseReason(@ptrCast(*const IBDA_UserActivityService, self), dwUseReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_UserActivityService_GetUserActivityInterval(self: *const T, pdwActivityInterval: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_UserActivityService.VTable, self.vtable).GetUserActivityInterval(@ptrCast(*const IBDA_UserActivityService, self), pdwActivityInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_UserActivityService_UserActivityDetected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_UserActivityService.VTable, self.vtable).UserActivityDetected(@ptrCast(*const IBDA_UserActivityService, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEvent_Value = @import("../zig.zig").Guid.initString("1f0e5357-af43-44e6-8547-654c645145d2");
pub const IID_IESEvent = &IID_IESEvent_Value;
pub const IESEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventId: fn(
            self: *const IESEvent,
            pdwEventId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventType: fn(
            self: *const IESEvent,
            pguidEventType: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompletionStatus: fn(
            self: *const IESEvent,
            dwResult: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: fn(
            self: *const IESEvent,
            pbData: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringData: fn(
            self: *const IESEvent,
            pbstrData: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_GetEventId(self: *const T, pdwEventId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEvent.VTable, self.vtable).GetEventId(@ptrCast(*const IESEvent, self), pdwEventId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_GetEventType(self: *const T, pguidEventType: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEvent.VTable, self.vtable).GetEventType(@ptrCast(*const IESEvent, self), pguidEventType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_SetCompletionStatus(self: *const T, dwResult: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEvent.VTable, self.vtable).SetCompletionStatus(@ptrCast(*const IESEvent, self), dwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_GetData(self: *const T, pbData: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEvent.VTable, self.vtable).GetData(@ptrCast(*const IESEvent, self), pbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_GetStringData(self: *const T, pbstrData: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEvent.VTable, self.vtable).GetStringData(@ptrCast(*const IESEvent, self), pbstrData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEvents_Value = @import("../zig.zig").Guid.initString("abd414bf-cfe5-4e5e-af5b-4b4e49c5bfeb");
pub const IID_IESEvents = &IID_IESEvents_Value;
pub const IESEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnESEventReceived: fn(
            self: *const IESEvents,
            guidEventType: Guid,
            pESEvent: ?*IESEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvents_OnESEventReceived(self: *const T, guidEventType: Guid, pESEvent: ?*IESEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEvents.VTable, self.vtable).OnESEventReceived(@ptrCast(*const IESEvents, self), guidEventType, pESEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBroadcastEvent_Value = @import("../zig.zig").Guid.initString("3b21263f-26e8-489d-aac4-924f7efd9511");
pub const IID_IBroadcastEvent = &IID_IBroadcastEvent_Value;
pub const IBroadcastEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Fire: fn(
            self: *const IBroadcastEvent,
            EventID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBroadcastEvent_Fire(self: *const T, EventID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBroadcastEvent.VTable, self.vtable).Fire(@ptrCast(*const IBroadcastEvent, self), EventID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBroadcastEventEx_Value = @import("../zig.zig").Guid.initString("3d9e3887-1929-423f-8021-43682de95448");
pub const IID_IBroadcastEventEx = &IID_IBroadcastEventEx_Value;
pub const IBroadcastEventEx = extern struct {
    pub const VTable = extern struct {
        base: IBroadcastEvent.VTable,
        FireEx: fn(
            self: *const IBroadcastEventEx,
            EventID: Guid,
            Param1: u32,
            Param2: u32,
            Param3: u32,
            Param4: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBroadcastEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBroadcastEventEx_FireEx(self: *const T, EventID: Guid, Param1: u32, Param2: u32, Param3: u32, Param4: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBroadcastEventEx.VTable, self.vtable).FireEx(@ptrCast(*const IBroadcastEventEx, self), EventID, Param1, Param2, Param3, Param4);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetShowConfig_Value = @import("../zig.zig").Guid.initString("fa2aa8f1-8b62-11d0-a520-000000000000");
pub const IID_IAMNetShowConfig = &IID_IAMNetShowConfig_Value;
pub const IAMNetShowConfig = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferingTime: fn(
            self: *const IAMNetShowConfig,
            pBufferingTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferingTime: fn(
            self: *const IAMNetShowConfig,
            BufferingTime: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseFixedUDPPort: fn(
            self: *const IAMNetShowConfig,
            pUseFixedUDPPort: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseFixedUDPPort: fn(
            self: *const IAMNetShowConfig,
            UseFixedUDPPort: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FixedUDPPort: fn(
            self: *const IAMNetShowConfig,
            pFixedUDPPort: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FixedUDPPort: fn(
            self: *const IAMNetShowConfig,
            FixedUDPPort: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseHTTPProxy: fn(
            self: *const IAMNetShowConfig,
            pUseHTTPProxy: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseHTTPProxy: fn(
            self: *const IAMNetShowConfig,
            UseHTTPProxy: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableAutoProxy: fn(
            self: *const IAMNetShowConfig,
            pEnableAutoProxy: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableAutoProxy: fn(
            self: *const IAMNetShowConfig,
            EnableAutoProxy: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTTPProxyHost: fn(
            self: *const IAMNetShowConfig,
            pbstrHTTPProxyHost: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HTTPProxyHost: fn(
            self: *const IAMNetShowConfig,
            bstrHTTPProxyHost: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTTPProxyPort: fn(
            self: *const IAMNetShowConfig,
            pHTTPProxyPort: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HTTPProxyPort: fn(
            self: *const IAMNetShowConfig,
            HTTPProxyPort: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableMulticast: fn(
            self: *const IAMNetShowConfig,
            pEnableMulticast: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableMulticast: fn(
            self: *const IAMNetShowConfig,
            EnableMulticast: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableUDP: fn(
            self: *const IAMNetShowConfig,
            pEnableUDP: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableUDP: fn(
            self: *const IAMNetShowConfig,
            EnableUDP: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableTCP: fn(
            self: *const IAMNetShowConfig,
            pEnableTCP: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableTCP: fn(
            self: *const IAMNetShowConfig,
            EnableTCP: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableHTTP: fn(
            self: *const IAMNetShowConfig,
            pEnableHTTP: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableHTTP: fn(
            self: *const IAMNetShowConfig,
            EnableHTTP: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_BufferingTime(self: *const T, pBufferingTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_BufferingTime(@ptrCast(*const IAMNetShowConfig, self), pBufferingTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_BufferingTime(self: *const T, BufferingTime: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_BufferingTime(@ptrCast(*const IAMNetShowConfig, self), BufferingTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_UseFixedUDPPort(self: *const T, pUseFixedUDPPort: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_UseFixedUDPPort(@ptrCast(*const IAMNetShowConfig, self), pUseFixedUDPPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_UseFixedUDPPort(self: *const T, UseFixedUDPPort: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_UseFixedUDPPort(@ptrCast(*const IAMNetShowConfig, self), UseFixedUDPPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_FixedUDPPort(self: *const T, pFixedUDPPort: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_FixedUDPPort(@ptrCast(*const IAMNetShowConfig, self), pFixedUDPPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_FixedUDPPort(self: *const T, FixedUDPPort: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_FixedUDPPort(@ptrCast(*const IAMNetShowConfig, self), FixedUDPPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_UseHTTPProxy(self: *const T, pUseHTTPProxy: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_UseHTTPProxy(@ptrCast(*const IAMNetShowConfig, self), pUseHTTPProxy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_UseHTTPProxy(self: *const T, UseHTTPProxy: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_UseHTTPProxy(@ptrCast(*const IAMNetShowConfig, self), UseHTTPProxy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableAutoProxy(self: *const T, pEnableAutoProxy: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_EnableAutoProxy(@ptrCast(*const IAMNetShowConfig, self), pEnableAutoProxy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableAutoProxy(self: *const T, EnableAutoProxy: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_EnableAutoProxy(@ptrCast(*const IAMNetShowConfig, self), EnableAutoProxy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_HTTPProxyHost(self: *const T, pbstrHTTPProxyHost: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_HTTPProxyHost(@ptrCast(*const IAMNetShowConfig, self), pbstrHTTPProxyHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_HTTPProxyHost(self: *const T, bstrHTTPProxyHost: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_HTTPProxyHost(@ptrCast(*const IAMNetShowConfig, self), bstrHTTPProxyHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_HTTPProxyPort(self: *const T, pHTTPProxyPort: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_HTTPProxyPort(@ptrCast(*const IAMNetShowConfig, self), pHTTPProxyPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_HTTPProxyPort(self: *const T, HTTPProxyPort: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_HTTPProxyPort(@ptrCast(*const IAMNetShowConfig, self), HTTPProxyPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableMulticast(self: *const T, pEnableMulticast: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_EnableMulticast(@ptrCast(*const IAMNetShowConfig, self), pEnableMulticast);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableMulticast(self: *const T, EnableMulticast: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_EnableMulticast(@ptrCast(*const IAMNetShowConfig, self), EnableMulticast);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableUDP(self: *const T, pEnableUDP: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_EnableUDP(@ptrCast(*const IAMNetShowConfig, self), pEnableUDP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableUDP(self: *const T, EnableUDP: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_EnableUDP(@ptrCast(*const IAMNetShowConfig, self), EnableUDP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableTCP(self: *const T, pEnableTCP: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_EnableTCP(@ptrCast(*const IAMNetShowConfig, self), pEnableTCP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableTCP(self: *const T, EnableTCP: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_EnableTCP(@ptrCast(*const IAMNetShowConfig, self), EnableTCP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableHTTP(self: *const T, pEnableHTTP: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).get_EnableHTTP(@ptrCast(*const IAMNetShowConfig, self), pEnableHTTP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableHTTP(self: *const T, EnableHTTP: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowConfig.VTable, self.vtable).put_EnableHTTP(@ptrCast(*const IAMNetShowConfig, self), EnableHTTP);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMChannelInfo_Value = @import("../zig.zig").Guid.initString("fa2aa8f2-8b62-11d0-a520-000000000000");
pub const IID_IAMChannelInfo = &IID_IAMChannelInfo_Value;
pub const IAMChannelInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelName: fn(
            self: *const IAMChannelInfo,
            pbstrChannelName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelDescription: fn(
            self: *const IAMChannelInfo,
            pbstrChannelDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelURL: fn(
            self: *const IAMChannelInfo,
            pbstrChannelURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContactAddress: fn(
            self: *const IAMChannelInfo,
            pbstrContactAddress: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContactPhone: fn(
            self: *const IAMChannelInfo,
            pbstrContactPhone: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContactEmail: fn(
            self: *const IAMChannelInfo,
            pbstrContactEmail: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ChannelName(self: *const T, pbstrChannelName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMChannelInfo.VTable, self.vtable).get_ChannelName(@ptrCast(*const IAMChannelInfo, self), pbstrChannelName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ChannelDescription(self: *const T, pbstrChannelDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMChannelInfo.VTable, self.vtable).get_ChannelDescription(@ptrCast(*const IAMChannelInfo, self), pbstrChannelDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ChannelURL(self: *const T, pbstrChannelURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMChannelInfo.VTable, self.vtable).get_ChannelURL(@ptrCast(*const IAMChannelInfo, self), pbstrChannelURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ContactAddress(self: *const T, pbstrContactAddress: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMChannelInfo.VTable, self.vtable).get_ContactAddress(@ptrCast(*const IAMChannelInfo, self), pbstrContactAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ContactPhone(self: *const T, pbstrContactPhone: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMChannelInfo.VTable, self.vtable).get_ContactPhone(@ptrCast(*const IAMChannelInfo, self), pbstrContactPhone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ContactEmail(self: *const T, pbstrContactEmail: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMChannelInfo.VTable, self.vtable).get_ContactEmail(@ptrCast(*const IAMChannelInfo, self), pbstrContactEmail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetworkStatus_Value = @import("../zig.zig").Guid.initString("fa2aa8f3-8b62-11d0-a520-000000000000");
pub const IID_IAMNetworkStatus = &IID_IAMNetworkStatus_Value;
pub const IAMNetworkStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReceivedPackets: fn(
            self: *const IAMNetworkStatus,
            pReceivedPackets: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoveredPackets: fn(
            self: *const IAMNetworkStatus,
            pRecoveredPackets: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LostPackets: fn(
            self: *const IAMNetworkStatus,
            pLostPackets: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReceptionQuality: fn(
            self: *const IAMNetworkStatus,
            pReceptionQuality: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferingCount: fn(
            self: *const IAMNetworkStatus,
            pBufferingCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBroadcast: fn(
            self: *const IAMNetworkStatus,
            pIsBroadcast: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferingProgress: fn(
            self: *const IAMNetworkStatus,
            pBufferingProgress: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_ReceivedPackets(self: *const T, pReceivedPackets: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetworkStatus.VTable, self.vtable).get_ReceivedPackets(@ptrCast(*const IAMNetworkStatus, self), pReceivedPackets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_RecoveredPackets(self: *const T, pRecoveredPackets: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetworkStatus.VTable, self.vtable).get_RecoveredPackets(@ptrCast(*const IAMNetworkStatus, self), pRecoveredPackets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_LostPackets(self: *const T, pLostPackets: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetworkStatus.VTable, self.vtable).get_LostPackets(@ptrCast(*const IAMNetworkStatus, self), pLostPackets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_ReceptionQuality(self: *const T, pReceptionQuality: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetworkStatus.VTable, self.vtable).get_ReceptionQuality(@ptrCast(*const IAMNetworkStatus, self), pReceptionQuality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_BufferingCount(self: *const T, pBufferingCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetworkStatus.VTable, self.vtable).get_BufferingCount(@ptrCast(*const IAMNetworkStatus, self), pBufferingCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_IsBroadcast(self: *const T, pIsBroadcast: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetworkStatus.VTable, self.vtable).get_IsBroadcast(@ptrCast(*const IAMNetworkStatus, self), pIsBroadcast);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_BufferingProgress(self: *const T, pBufferingProgress: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetworkStatus.VTable, self.vtable).get_BufferingProgress(@ptrCast(*const IAMNetworkStatus, self), pBufferingProgress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMExtendedSeekingCapabilities = enum(i32) {
    CANSEEK = 1,
    CANSCAN = 2,
    MARKERSEEK = 4,
    SCANWITHOUTCLOCK = 8,
    NOSTANDARDREPAINT = 16,
    BUFFERING = 32,
    SENDS_VIDEOFRAMEREADY = 64,
};
pub const AM_EXSEEK_CANSEEK = AMExtendedSeekingCapabilities.CANSEEK;
pub const AM_EXSEEK_CANSCAN = AMExtendedSeekingCapabilities.CANSCAN;
pub const AM_EXSEEK_MARKERSEEK = AMExtendedSeekingCapabilities.MARKERSEEK;
pub const AM_EXSEEK_SCANWITHOUTCLOCK = AMExtendedSeekingCapabilities.SCANWITHOUTCLOCK;
pub const AM_EXSEEK_NOSTANDARDREPAINT = AMExtendedSeekingCapabilities.NOSTANDARDREPAINT;
pub const AM_EXSEEK_BUFFERING = AMExtendedSeekingCapabilities.BUFFERING;
pub const AM_EXSEEK_SENDS_VIDEOFRAMEREADY = AMExtendedSeekingCapabilities.SENDS_VIDEOFRAMEREADY;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtendedSeeking_Value = @import("../zig.zig").Guid.initString("fa2aa8f9-8b62-11d0-a520-000000000000");
pub const IID_IAMExtendedSeeking = &IID_IAMExtendedSeeking_Value;
pub const IAMExtendedSeeking = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExSeekCapabilities: fn(
            self: *const IAMExtendedSeeking,
            pExCapabilities: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MarkerCount: fn(
            self: *const IAMExtendedSeeking,
            pMarkerCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentMarker: fn(
            self: *const IAMExtendedSeeking,
            pCurrentMarker: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarkerTime: fn(
            self: *const IAMExtendedSeeking,
            MarkerNum: i32,
            pMarkerTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarkerName: fn(
            self: *const IAMExtendedSeeking,
            MarkerNum: i32,
            pbstrMarkerName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PlaybackSpeed: fn(
            self: *const IAMExtendedSeeking,
            Speed: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlaybackSpeed: fn(
            self: *const IAMExtendedSeeking,
            pSpeed: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_get_ExSeekCapabilities(self: *const T, pExCapabilities: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedSeeking.VTable, self.vtable).get_ExSeekCapabilities(@ptrCast(*const IAMExtendedSeeking, self), pExCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_get_MarkerCount(self: *const T, pMarkerCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedSeeking.VTable, self.vtable).get_MarkerCount(@ptrCast(*const IAMExtendedSeeking, self), pMarkerCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_get_CurrentMarker(self: *const T, pCurrentMarker: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedSeeking.VTable, self.vtable).get_CurrentMarker(@ptrCast(*const IAMExtendedSeeking, self), pCurrentMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_GetMarkerTime(self: *const T, MarkerNum: i32, pMarkerTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedSeeking.VTable, self.vtable).GetMarkerTime(@ptrCast(*const IAMExtendedSeeking, self), MarkerNum, pMarkerTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_GetMarkerName(self: *const T, MarkerNum: i32, pbstrMarkerName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedSeeking.VTable, self.vtable).GetMarkerName(@ptrCast(*const IAMExtendedSeeking, self), MarkerNum, pbstrMarkerName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_put_PlaybackSpeed(self: *const T, Speed: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedSeeking.VTable, self.vtable).put_PlaybackSpeed(@ptrCast(*const IAMExtendedSeeking, self), Speed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_get_PlaybackSpeed(self: *const T, pSpeed: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedSeeking.VTable, self.vtable).get_PlaybackSpeed(@ptrCast(*const IAMExtendedSeeking, self), pSpeed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetShowExProps_Value = @import("../zig.zig").Guid.initString("fa2aa8f5-8b62-11d0-a520-000000000000");
pub const IID_IAMNetShowExProps = &IID_IAMNetShowExProps_Value;
pub const IAMNetShowExProps = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceProtocol: fn(
            self: *const IAMNetShowExProps,
            pSourceProtocol: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bandwidth: fn(
            self: *const IAMNetShowExProps,
            pBandwidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorCorrection: fn(
            self: *const IAMNetShowExProps,
            pbstrErrorCorrection: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CodecCount: fn(
            self: *const IAMNetShowExProps,
            pCodecCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodecInstalled: fn(
            self: *const IAMNetShowExProps,
            CodecNum: i32,
            pCodecInstalled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodecDescription: fn(
            self: *const IAMNetShowExProps,
            CodecNum: i32,
            pbstrCodecDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodecURL: fn(
            self: *const IAMNetShowExProps,
            CodecNum: i32,
            pbstrCodecURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreationDate: fn(
            self: *const IAMNetShowExProps,
            pCreationDate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceLink: fn(
            self: *const IAMNetShowExProps,
            pbstrSourceLink: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_SourceProtocol(self: *const T, pSourceProtocol: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowExProps.VTable, self.vtable).get_SourceProtocol(@ptrCast(*const IAMNetShowExProps, self), pSourceProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_Bandwidth(self: *const T, pBandwidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowExProps.VTable, self.vtable).get_Bandwidth(@ptrCast(*const IAMNetShowExProps, self), pBandwidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_ErrorCorrection(self: *const T, pbstrErrorCorrection: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowExProps.VTable, self.vtable).get_ErrorCorrection(@ptrCast(*const IAMNetShowExProps, self), pbstrErrorCorrection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_CodecCount(self: *const T, pCodecCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowExProps.VTable, self.vtable).get_CodecCount(@ptrCast(*const IAMNetShowExProps, self), pCodecCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_GetCodecInstalled(self: *const T, CodecNum: i32, pCodecInstalled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowExProps.VTable, self.vtable).GetCodecInstalled(@ptrCast(*const IAMNetShowExProps, self), CodecNum, pCodecInstalled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_GetCodecDescription(self: *const T, CodecNum: i32, pbstrCodecDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowExProps.VTable, self.vtable).GetCodecDescription(@ptrCast(*const IAMNetShowExProps, self), CodecNum, pbstrCodecDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_GetCodecURL(self: *const T, CodecNum: i32, pbstrCodecURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowExProps.VTable, self.vtable).GetCodecURL(@ptrCast(*const IAMNetShowExProps, self), CodecNum, pbstrCodecURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_CreationDate(self: *const T, pCreationDate: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowExProps.VTable, self.vtable).get_CreationDate(@ptrCast(*const IAMNetShowExProps, self), pCreationDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_SourceLink(self: *const T, pbstrSourceLink: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowExProps.VTable, self.vtable).get_SourceLink(@ptrCast(*const IAMNetShowExProps, self), pbstrSourceLink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtendedErrorInfo_Value = @import("../zig.zig").Guid.initString("fa2aa8f6-8b62-11d0-a520-000000000000");
pub const IID_IAMExtendedErrorInfo = &IID_IAMExtendedErrorInfo_Value;
pub const IAMExtendedErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HasError: fn(
            self: *const IAMExtendedErrorInfo,
            pHasError: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorDescription: fn(
            self: *const IAMExtendedErrorInfo,
            pbstrErrorDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorCode: fn(
            self: *const IAMExtendedErrorInfo,
            pErrorCode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedErrorInfo_get_HasError(self: *const T, pHasError: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedErrorInfo.VTable, self.vtable).get_HasError(@ptrCast(*const IAMExtendedErrorInfo, self), pHasError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedErrorInfo_get_ErrorDescription(self: *const T, pbstrErrorDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedErrorInfo.VTable, self.vtable).get_ErrorDescription(@ptrCast(*const IAMExtendedErrorInfo, self), pbstrErrorDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedErrorInfo_get_ErrorCode(self: *const T, pErrorCode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMExtendedErrorInfo.VTable, self.vtable).get_ErrorCode(@ptrCast(*const IAMExtendedErrorInfo, self), pErrorCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMMediaContent_Value = @import("../zig.zig").Guid.initString("fa2aa8f4-8b62-11d0-a520-000000000000");
pub const IID_IAMMediaContent = &IID_IAMMediaContent_Value;
pub const IAMMediaContent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthorName: fn(
            self: *const IAMMediaContent,
            pbstrAuthorName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: fn(
            self: *const IAMMediaContent,
            pbstrTitle: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rating: fn(
            self: *const IAMMediaContent,
            pbstrRating: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IAMMediaContent,
            pbstrDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Copyright: fn(
            self: *const IAMMediaContent,
            pbstrCopyright: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BaseURL: fn(
            self: *const IAMMediaContent,
            pbstrBaseURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogoURL: fn(
            self: *const IAMMediaContent,
            pbstrLogoURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogoIconURL: fn(
            self: *const IAMMediaContent,
            pbstrLogoURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WatermarkURL: fn(
            self: *const IAMMediaContent,
            pbstrWatermarkURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoURL: fn(
            self: *const IAMMediaContent,
            pbstrMoreInfoURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoBannerImage: fn(
            self: *const IAMMediaContent,
            pbstrMoreInfoBannerImage: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoBannerURL: fn(
            self: *const IAMMediaContent,
            pbstrMoreInfoBannerURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoText: fn(
            self: *const IAMMediaContent,
            pbstrMoreInfoText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_AuthorName(self: *const T, pbstrAuthorName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_AuthorName(@ptrCast(*const IAMMediaContent, self), pbstrAuthorName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_Title(self: *const T, pbstrTitle: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_Title(@ptrCast(*const IAMMediaContent, self), pbstrTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_Rating(self: *const T, pbstrRating: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_Rating(@ptrCast(*const IAMMediaContent, self), pbstrRating);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_Description(self: *const T, pbstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_Description(@ptrCast(*const IAMMediaContent, self), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_Copyright(self: *const T, pbstrCopyright: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_Copyright(@ptrCast(*const IAMMediaContent, self), pbstrCopyright);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_BaseURL(self: *const T, pbstrBaseURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_BaseURL(@ptrCast(*const IAMMediaContent, self), pbstrBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_LogoURL(self: *const T, pbstrLogoURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_LogoURL(@ptrCast(*const IAMMediaContent, self), pbstrLogoURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_LogoIconURL(self: *const T, pbstrLogoURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_LogoIconURL(@ptrCast(*const IAMMediaContent, self), pbstrLogoURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_WatermarkURL(self: *const T, pbstrWatermarkURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_WatermarkURL(@ptrCast(*const IAMMediaContent, self), pbstrWatermarkURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_MoreInfoURL(self: *const T, pbstrMoreInfoURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_MoreInfoURL(@ptrCast(*const IAMMediaContent, self), pbstrMoreInfoURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_MoreInfoBannerImage(self: *const T, pbstrMoreInfoBannerImage: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_MoreInfoBannerImage(@ptrCast(*const IAMMediaContent, self), pbstrMoreInfoBannerImage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_MoreInfoBannerURL(self: *const T, pbstrMoreInfoBannerURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_MoreInfoBannerURL(@ptrCast(*const IAMMediaContent, self), pbstrMoreInfoBannerURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_MoreInfoText(self: *const T, pbstrMoreInfoText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent.VTable, self.vtable).get_MoreInfoText(@ptrCast(*const IAMMediaContent, self), pbstrMoreInfoText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMMediaContent2_Value = @import("../zig.zig").Guid.initString("ce8f78c1-74d9-11d2-b09d-00a0c9a81117");
pub const IID_IAMMediaContent2 = &IID_IAMMediaContent2_Value;
pub const IAMMediaContent2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaParameter: fn(
            self: *const IAMMediaContent2,
            EntryNum: i32,
            bstrName: ?BSTR,
            pbstrValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaParameterName: fn(
            self: *const IAMMediaContent2,
            EntryNum: i32,
            Index: i32,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlaylistCount: fn(
            self: *const IAMMediaContent2,
            pNumberEntries: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent2_get_MediaParameter(self: *const T, EntryNum: i32, bstrName: ?BSTR, pbstrValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent2.VTable, self.vtable).get_MediaParameter(@ptrCast(*const IAMMediaContent2, self), EntryNum, bstrName, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent2_get_MediaParameterName(self: *const T, EntryNum: i32, Index: i32, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent2.VTable, self.vtable).get_MediaParameterName(@ptrCast(*const IAMMediaContent2, self), EntryNum, Index, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent2_get_PlaylistCount(self: *const T, pNumberEntries: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaContent2.VTable, self.vtable).get_PlaylistCount(@ptrCast(*const IAMMediaContent2, self), pNumberEntries);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetShowPreroll_Value = @import("../zig.zig").Guid.initString("aae7e4e2-6388-11d1-8d93-006097c9a2b2");
pub const IID_IAMNetShowPreroll = &IID_IAMNetShowPreroll_Value;
pub const IAMNetShowPreroll = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Preroll: fn(
            self: *const IAMNetShowPreroll,
            fPreroll: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Preroll: fn(
            self: *const IAMNetShowPreroll,
            pfPreroll: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowPreroll_put_Preroll(self: *const T, fPreroll: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowPreroll.VTable, self.vtable).put_Preroll(@ptrCast(*const IAMNetShowPreroll, self), fPreroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowPreroll_get_Preroll(self: *const T, pfPreroll: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMNetShowPreroll.VTable, self.vtable).get_Preroll(@ptrCast(*const IAMNetShowPreroll, self), pfPreroll);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDShowPlugin_Value = @import("../zig.zig").Guid.initString("4746b7c8-700e-11d1-becc-00c04fb6e937");
pub const IID_IDShowPlugin = &IID_IDShowPlugin_Value;
pub const IDShowPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: fn(
            self: *const IDShowPlugin,
            pURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAgent: fn(
            self: *const IDShowPlugin,
            pUserAgent: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDShowPlugin_get_URL(self: *const T, pURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDShowPlugin.VTable, self.vtable).get_URL(@ptrCast(*const IDShowPlugin, self), pURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDShowPlugin_get_UserAgent(self: *const T, pUserAgent: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDShowPlugin.VTable, self.vtable).get_UserAgent(@ptrCast(*const IDShowPlugin, self), pUserAgent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IAMDirectSound = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectSoundInterface: fn(
            self: *const IAMDirectSound,
            lplpds: ?*?*IDirectSound,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrimaryBufferInterface: fn(
            self: *const IAMDirectSound,
            lplpdsb: ?*?*IDirectSoundBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecondaryBufferInterface: fn(
            self: *const IAMDirectSound,
            lplpdsb: ?*?*IDirectSoundBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseDirectSoundInterface: fn(
            self: *const IAMDirectSound,
            lpds: ?*IDirectSound,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleasePrimaryBufferInterface: fn(
            self: *const IAMDirectSound,
            lpdsb: ?*IDirectSoundBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseSecondaryBufferInterface: fn(
            self: *const IAMDirectSound,
            lpdsb: ?*IDirectSoundBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocusWindow: fn(
            self: *const IAMDirectSound,
            param0: ?HWND,
            param1: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocusWindow: fn(
            self: *const IAMDirectSound,
            param0: ?*?HWND,
            param1: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_GetDirectSoundInterface(self: *const T, lplpds: ?*?*IDirectSound) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDirectSound.VTable, self.vtable).GetDirectSoundInterface(@ptrCast(*const IAMDirectSound, self), lplpds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_GetPrimaryBufferInterface(self: *const T, lplpdsb: ?*?*IDirectSoundBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDirectSound.VTable, self.vtable).GetPrimaryBufferInterface(@ptrCast(*const IAMDirectSound, self), lplpdsb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_GetSecondaryBufferInterface(self: *const T, lplpdsb: ?*?*IDirectSoundBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDirectSound.VTable, self.vtable).GetSecondaryBufferInterface(@ptrCast(*const IAMDirectSound, self), lplpdsb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_ReleaseDirectSoundInterface(self: *const T, lpds: ?*IDirectSound) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDirectSound.VTable, self.vtable).ReleaseDirectSoundInterface(@ptrCast(*const IAMDirectSound, self), lpds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_ReleasePrimaryBufferInterface(self: *const T, lpdsb: ?*IDirectSoundBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDirectSound.VTable, self.vtable).ReleasePrimaryBufferInterface(@ptrCast(*const IAMDirectSound, self), lpdsb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_ReleaseSecondaryBufferInterface(self: *const T, lpdsb: ?*IDirectSoundBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDirectSound.VTable, self.vtable).ReleaseSecondaryBufferInterface(@ptrCast(*const IAMDirectSound, self), lpdsb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_SetFocusWindow(self: *const T, param0: ?HWND, param1: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDirectSound.VTable, self.vtable).SetFocusWindow(@ptrCast(*const IAMDirectSound, self), param0, param1);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_GetFocusWindow(self: *const T, param0: ?*?HWND, param1: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMDirectSound.VTable, self.vtable).GetFocusWindow(@ptrCast(*const IAMDirectSound, self), param0, param1);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_LINE21_CCLEVEL = enum(i32) {
    @"2" = 0,
};
pub const AM_L21_CCLEVEL_TC2 = AM_LINE21_CCLEVEL.@"2";

pub const AM_LINE21_CCSERVICE = enum(i32) {
    None = 0,
    Caption1 = 1,
    Caption2 = 2,
    Text1 = 3,
    Text2 = 4,
    XDS = 5,
    DefChannel = 10,
    Invalid = 11,
};
pub const AM_L21_CCSERVICE_None = AM_LINE21_CCSERVICE.None;
pub const AM_L21_CCSERVICE_Caption1 = AM_LINE21_CCSERVICE.Caption1;
pub const AM_L21_CCSERVICE_Caption2 = AM_LINE21_CCSERVICE.Caption2;
pub const AM_L21_CCSERVICE_Text1 = AM_LINE21_CCSERVICE.Text1;
pub const AM_L21_CCSERVICE_Text2 = AM_LINE21_CCSERVICE.Text2;
pub const AM_L21_CCSERVICE_XDS = AM_LINE21_CCSERVICE.XDS;
pub const AM_L21_CCSERVICE_DefChannel = AM_LINE21_CCSERVICE.DefChannel;
pub const AM_L21_CCSERVICE_Invalid = AM_LINE21_CCSERVICE.Invalid;

pub const AM_LINE21_CCSTATE = enum(i32) {
    ff = 0,
    n = 1,
};
pub const AM_L21_CCSTATE_Off = AM_LINE21_CCSTATE.ff;
pub const AM_L21_CCSTATE_On = AM_LINE21_CCSTATE.n;

pub const AM_LINE21_CCSTYLE = enum(i32) {
    None = 0,
    PopOn = 1,
    PaintOn = 2,
    RollUp = 3,
};
pub const AM_L21_CCSTYLE_None = AM_LINE21_CCSTYLE.None;
pub const AM_L21_CCSTYLE_PopOn = AM_LINE21_CCSTYLE.PopOn;
pub const AM_L21_CCSTYLE_PaintOn = AM_LINE21_CCSTYLE.PaintOn;
pub const AM_L21_CCSTYLE_RollUp = AM_LINE21_CCSTYLE.RollUp;

pub const AM_LINE21_DRAWBGMODE = enum(i32) {
    Opaque = 0,
    Transparent = 1,
};
pub const AM_L21_DRAWBGMODE_Opaque = AM_LINE21_DRAWBGMODE.Opaque;
pub const AM_L21_DRAWBGMODE_Transparent = AM_LINE21_DRAWBGMODE.Transparent;

// TODO: this type is limited to platform 'windows5.0'
pub const IAMLine21Decoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecoderLevel: fn(
            self: *const IAMLine21Decoder,
            lpLevel: ?*AM_LINE21_CCLEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentService: fn(
            self: *const IAMLine21Decoder,
            lpService: ?*AM_LINE21_CCSERVICE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentService: fn(
            self: *const IAMLine21Decoder,
            Service: AM_LINE21_CCSERVICE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceState: fn(
            self: *const IAMLine21Decoder,
            lpState: ?*AM_LINE21_CCSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetServiceState: fn(
            self: *const IAMLine21Decoder,
            State: AM_LINE21_CCSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputFormat: fn(
            self: *const IAMLine21Decoder,
            lpbmih: ?*BITMAPINFOHEADER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputFormat: fn(
            self: *const IAMLine21Decoder,
            lpbmi: ?*BITMAPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: fn(
            self: *const IAMLine21Decoder,
            pdwPhysColor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundColor: fn(
            self: *const IAMLine21Decoder,
            dwPhysColor: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRedrawAlways: fn(
            self: *const IAMLine21Decoder,
            lpbOption: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRedrawAlways: fn(
            self: *const IAMLine21Decoder,
            bOption: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrawBackgroundMode: fn(
            self: *const IAMLine21Decoder,
            lpMode: ?*AM_LINE21_DRAWBGMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDrawBackgroundMode: fn(
            self: *const IAMLine21Decoder,
            Mode: AM_LINE21_DRAWBGMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetDecoderLevel(self: *const T, lpLevel: ?*AM_LINE21_CCLEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).GetDecoderLevel(@ptrCast(*const IAMLine21Decoder, self), lpLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetCurrentService(self: *const T, lpService: ?*AM_LINE21_CCSERVICE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).GetCurrentService(@ptrCast(*const IAMLine21Decoder, self), lpService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetCurrentService(self: *const T, Service: AM_LINE21_CCSERVICE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).SetCurrentService(@ptrCast(*const IAMLine21Decoder, self), Service);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetServiceState(self: *const T, lpState: ?*AM_LINE21_CCSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).GetServiceState(@ptrCast(*const IAMLine21Decoder, self), lpState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetServiceState(self: *const T, State: AM_LINE21_CCSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).SetServiceState(@ptrCast(*const IAMLine21Decoder, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetOutputFormat(self: *const T, lpbmih: ?*BITMAPINFOHEADER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).GetOutputFormat(@ptrCast(*const IAMLine21Decoder, self), lpbmih);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetOutputFormat(self: *const T, lpbmi: ?*BITMAPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).SetOutputFormat(@ptrCast(*const IAMLine21Decoder, self), lpbmi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetBackgroundColor(self: *const T, pdwPhysColor: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).GetBackgroundColor(@ptrCast(*const IAMLine21Decoder, self), pdwPhysColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetBackgroundColor(self: *const T, dwPhysColor: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).SetBackgroundColor(@ptrCast(*const IAMLine21Decoder, self), dwPhysColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetRedrawAlways(self: *const T, lpbOption: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).GetRedrawAlways(@ptrCast(*const IAMLine21Decoder, self), lpbOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetRedrawAlways(self: *const T, bOption: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).SetRedrawAlways(@ptrCast(*const IAMLine21Decoder, self), bOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetDrawBackgroundMode(self: *const T, lpMode: ?*AM_LINE21_DRAWBGMODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).GetDrawBackgroundMode(@ptrCast(*const IAMLine21Decoder, self), lpMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetDrawBackgroundMode(self: *const T, Mode: AM_LINE21_DRAWBGMODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMLine21Decoder.VTable, self.vtable).SetDrawBackgroundMode(@ptrCast(*const IAMLine21Decoder, self), Mode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMParse_Value = @import("../zig.zig").Guid.initString("c47a3420-005c-11d2-9038-00a0c9697298");
pub const IID_IAMParse = &IID_IAMParse_Value;
pub const IAMParse = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParseTime: fn(
            self: *const IAMParse,
            prtCurrent: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParseTime: fn(
            self: *const IAMParse,
            rtCurrent: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IAMParse,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMParse_GetParseTime(self: *const T, prtCurrent: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMParse.VTable, self.vtable).GetParseTime(@ptrCast(*const IAMParse, self), prtCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMParse_SetParseTime(self: *const T, rtCurrent: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMParse.VTable, self.vtable).SetParseTime(@ptrCast(*const IAMParse, self), rtCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMParse_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMParse.VTable, self.vtable).Flush(@ptrCast(*const IAMParse, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_FilgraphManager_Value = @import("../zig.zig").Guid.initString("e436ebb3-524f-11ce-9f53-0020af0ba770");
pub const CLSID_FilgraphManager = &CLSID_FilgraphManager_Value;

const IID_IAMCollection_Value = @import("../zig.zig").Guid.initString("56a868b9-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAMCollection = &IID_IAMCollection_Value;
pub const IAMCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAMCollection,
            plCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IAMCollection,
            lItem: i32,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IAMCollection,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCollection_get_Count(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCollection.VTable, self.vtable).get_Count(@ptrCast(*const IAMCollection, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCollection_Item(self: *const T, lItem: i32, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCollection.VTable, self.vtable).Item(@ptrCast(*const IAMCollection, self), lItem, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCollection_get__NewEnum(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IAMCollection, self), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaControl_Value = @import("../zig.zig").Guid.initString("56a868b1-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaControl = &IID_IMediaControl_Value;
pub const IMediaControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Run: fn(
            self: *const IMediaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IMediaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IMediaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IMediaControl,
            msTimeout: i32,
            pfs: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenderFile: fn(
            self: *const IMediaControl,
            strFilename: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSourceFilter: fn(
            self: *const IMediaControl,
            strFilename: ?BSTR,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilterCollection: fn(
            self: *const IMediaControl,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegFilterCollection: fn(
            self: *const IMediaControl,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopWhenReady: fn(
            self: *const IMediaControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_Run(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaControl.VTable, self.vtable).Run(@ptrCast(*const IMediaControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaControl.VTable, self.vtable).Pause(@ptrCast(*const IMediaControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaControl.VTable, self.vtable).Stop(@ptrCast(*const IMediaControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_GetState(self: *const T, msTimeout: i32, pfs: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaControl.VTable, self.vtable).GetState(@ptrCast(*const IMediaControl, self), msTimeout, pfs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_RenderFile(self: *const T, strFilename: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaControl.VTable, self.vtable).RenderFile(@ptrCast(*const IMediaControl, self), strFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_AddSourceFilter(self: *const T, strFilename: ?BSTR, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaControl.VTable, self.vtable).AddSourceFilter(@ptrCast(*const IMediaControl, self), strFilename, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_get_FilterCollection(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaControl.VTable, self.vtable).get_FilterCollection(@ptrCast(*const IMediaControl, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_get_RegFilterCollection(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaControl.VTable, self.vtable).get_RegFilterCollection(@ptrCast(*const IMediaControl, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_StopWhenReady(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaControl.VTable, self.vtable).StopWhenReady(@ptrCast(*const IMediaControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaEvent_Value = @import("../zig.zig").Guid.initString("56a868b6-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaEvent = &IID_IMediaEvent_Value;
pub const IMediaEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetEventHandle: fn(
            self: *const IMediaEvent,
            hEvent: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEvent: fn(
            self: *const IMediaEvent,
            lEventCode: ?*i32,
            lParam1: ?*isize,
            lParam2: ?*isize,
            msTimeout: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForCompletion: fn(
            self: *const IMediaEvent,
            msTimeout: i32,
            pEvCode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelDefaultHandling: fn(
            self: *const IMediaEvent,
            lEvCode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreDefaultHandling: fn(
            self: *const IMediaEvent,
            lEvCode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeEventParams: fn(
            self: *const IMediaEvent,
            lEvCode: i32,
            lParam1: isize,
            lParam2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_GetEventHandle(self: *const T, hEvent: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEvent.VTable, self.vtable).GetEventHandle(@ptrCast(*const IMediaEvent, self), hEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_GetEvent(self: *const T, lEventCode: ?*i32, lParam1: ?*isize, lParam2: ?*isize, msTimeout: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEvent.VTable, self.vtable).GetEvent(@ptrCast(*const IMediaEvent, self), lEventCode, lParam1, lParam2, msTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_WaitForCompletion(self: *const T, msTimeout: i32, pEvCode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEvent.VTable, self.vtable).WaitForCompletion(@ptrCast(*const IMediaEvent, self), msTimeout, pEvCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_CancelDefaultHandling(self: *const T, lEvCode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEvent.VTable, self.vtable).CancelDefaultHandling(@ptrCast(*const IMediaEvent, self), lEvCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_RestoreDefaultHandling(self: *const T, lEvCode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEvent.VTable, self.vtable).RestoreDefaultHandling(@ptrCast(*const IMediaEvent, self), lEvCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_FreeEventParams(self: *const T, lEvCode: i32, lParam1: isize, lParam2: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEvent.VTable, self.vtable).FreeEventParams(@ptrCast(*const IMediaEvent, self), lEvCode, lParam1, lParam2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaEventEx_Value = @import("../zig.zig").Guid.initString("56a868c0-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaEventEx = &IID_IMediaEventEx_Value;
pub const IMediaEventEx = extern struct {
    pub const VTable = extern struct {
        base: IMediaEvent.VTable,
        SetNotifyWindow: fn(
            self: *const IMediaEventEx,
            hwnd: isize,
            lMsg: i32,
            lInstanceData: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyFlags: fn(
            self: *const IMediaEventEx,
            lNoNotifyFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyFlags: fn(
            self: *const IMediaEventEx,
            lplNoNotifyFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEventEx_SetNotifyWindow(self: *const T, hwnd: isize, lMsg: i32, lInstanceData: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEventEx.VTable, self.vtable).SetNotifyWindow(@ptrCast(*const IMediaEventEx, self), hwnd, lMsg, lInstanceData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEventEx_SetNotifyFlags(self: *const T, lNoNotifyFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEventEx.VTable, self.vtable).SetNotifyFlags(@ptrCast(*const IMediaEventEx, self), lNoNotifyFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEventEx_GetNotifyFlags(self: *const T, lplNoNotifyFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaEventEx.VTable, self.vtable).GetNotifyFlags(@ptrCast(*const IMediaEventEx, self), lplNoNotifyFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaPosition_Value = @import("../zig.zig").Guid.initString("56a868b2-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaPosition = &IID_IMediaPosition_Value;
pub const IMediaPosition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Duration: fn(
            self: *const IMediaPosition,
            plength: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentPosition: fn(
            self: *const IMediaPosition,
            llTime: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPosition: fn(
            self: *const IMediaPosition,
            pllTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopTime: fn(
            self: *const IMediaPosition,
            pllTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopTime: fn(
            self: *const IMediaPosition,
            llTime: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrerollTime: fn(
            self: *const IMediaPosition,
            pllTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PrerollTime: fn(
            self: *const IMediaPosition,
            llTime: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: fn(
            self: *const IMediaPosition,
            dRate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: fn(
            self: *const IMediaPosition,
            pdRate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanSeekForward: fn(
            self: *const IMediaPosition,
            pCanSeekForward: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanSeekBackward: fn(
            self: *const IMediaPosition,
            pCanSeekBackward: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_Duration(self: *const T, plength: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).get_Duration(@ptrCast(*const IMediaPosition, self), plength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_put_CurrentPosition(self: *const T, llTime: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).put_CurrentPosition(@ptrCast(*const IMediaPosition, self), llTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_CurrentPosition(self: *const T, pllTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).get_CurrentPosition(@ptrCast(*const IMediaPosition, self), pllTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_StopTime(self: *const T, pllTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).get_StopTime(@ptrCast(*const IMediaPosition, self), pllTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_put_StopTime(self: *const T, llTime: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).put_StopTime(@ptrCast(*const IMediaPosition, self), llTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_PrerollTime(self: *const T, pllTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).get_PrerollTime(@ptrCast(*const IMediaPosition, self), pllTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_put_PrerollTime(self: *const T, llTime: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).put_PrerollTime(@ptrCast(*const IMediaPosition, self), llTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_put_Rate(self: *const T, dRate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).put_Rate(@ptrCast(*const IMediaPosition, self), dRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_Rate(self: *const T, pdRate: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).get_Rate(@ptrCast(*const IMediaPosition, self), pdRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_CanSeekForward(self: *const T, pCanSeekForward: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).CanSeekForward(@ptrCast(*const IMediaPosition, self), pCanSeekForward);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_CanSeekBackward(self: *const T, pCanSeekBackward: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaPosition.VTable, self.vtable).CanSeekBackward(@ptrCast(*const IMediaPosition, self), pCanSeekBackward);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBasicAudio_Value = @import("../zig.zig").Guid.initString("56a868b3-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IBasicAudio = &IID_IBasicAudio_Value;
pub const IBasicAudio = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: fn(
            self: *const IBasicAudio,
            lVolume: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: fn(
            self: *const IBasicAudio,
            plVolume: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Balance: fn(
            self: *const IBasicAudio,
            lBalance: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Balance: fn(
            self: *const IBasicAudio,
            plBalance: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicAudio_put_Volume(self: *const T, lVolume: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicAudio.VTable, self.vtable).put_Volume(@ptrCast(*const IBasicAudio, self), lVolume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicAudio_get_Volume(self: *const T, plVolume: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicAudio.VTable, self.vtable).get_Volume(@ptrCast(*const IBasicAudio, self), plVolume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicAudio_put_Balance(self: *const T, lBalance: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicAudio.VTable, self.vtable).put_Balance(@ptrCast(*const IBasicAudio, self), lBalance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicAudio_get_Balance(self: *const T, plBalance: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicAudio.VTable, self.vtable).get_Balance(@ptrCast(*const IBasicAudio, self), plBalance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IVideoWindow_Value = @import("../zig.zig").Guid.initString("56a868b4-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IVideoWindow = &IID_IVideoWindow_Value;
pub const IVideoWindow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Caption: fn(
            self: *const IVideoWindow,
            strCaption: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Caption: fn(
            self: *const IVideoWindow,
            strCaption: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowStyle: fn(
            self: *const IVideoWindow,
            WindowStyle: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowStyle: fn(
            self: *const IVideoWindow,
            WindowStyle: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowStyleEx: fn(
            self: *const IVideoWindow,
            WindowStyleEx: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowStyleEx: fn(
            self: *const IVideoWindow,
            WindowStyleEx: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoShow: fn(
            self: *const IVideoWindow,
            AutoShow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoShow: fn(
            self: *const IVideoWindow,
            AutoShow: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowState: fn(
            self: *const IVideoWindow,
            WindowState: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowState: fn(
            self: *const IVideoWindow,
            WindowState: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BackgroundPalette: fn(
            self: *const IVideoWindow,
            BackgroundPalette: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackgroundPalette: fn(
            self: *const IVideoWindow,
            pBackgroundPalette: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: fn(
            self: *const IVideoWindow,
            Visible: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: fn(
            self: *const IVideoWindow,
            pVisible: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: fn(
            self: *const IVideoWindow,
            Left: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: fn(
            self: *const IVideoWindow,
            pLeft: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: fn(
            self: *const IVideoWindow,
            Width: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: fn(
            self: *const IVideoWindow,
            pWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: fn(
            self: *const IVideoWindow,
            Top: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: fn(
            self: *const IVideoWindow,
            pTop: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: fn(
            self: *const IVideoWindow,
            Height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: fn(
            self: *const IVideoWindow,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Owner: fn(
            self: *const IVideoWindow,
            Owner: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Owner: fn(
            self: *const IVideoWindow,
            Owner: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MessageDrain: fn(
            self: *const IVideoWindow,
            Drain: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MessageDrain: fn(
            self: *const IVideoWindow,
            Drain: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BorderColor: fn(
            self: *const IVideoWindow,
            Color: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BorderColor: fn(
            self: *const IVideoWindow,
            Color: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullScreenMode: fn(
            self: *const IVideoWindow,
            FullScreenMode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FullScreenMode: fn(
            self: *const IVideoWindow,
            FullScreenMode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWindowForeground: fn(
            self: *const IVideoWindow,
            Focus: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyOwnerMessage: fn(
            self: *const IVideoWindow,
            hwnd: isize,
            uMsg: i32,
            wParam: isize,
            lParam: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWindowPosition: fn(
            self: *const IVideoWindow,
            Left: i32,
            Top: i32,
            Width: i32,
            Height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindowPosition: fn(
            self: *const IVideoWindow,
            pLeft: ?*i32,
            pTop: ?*i32,
            pWidth: ?*i32,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinIdealImageSize: fn(
            self: *const IVideoWindow,
            pWidth: ?*i32,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxIdealImageSize: fn(
            self: *const IVideoWindow,
            pWidth: ?*i32,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestorePosition: fn(
            self: *const IVideoWindow,
            pLeft: ?*i32,
            pTop: ?*i32,
            pWidth: ?*i32,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HideCursor: fn(
            self: *const IVideoWindow,
            HideCursor: OA_BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCursorHidden: fn(
            self: *const IVideoWindow,
            CursorHidden: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Caption(self: *const T, strCaption: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_Caption(@ptrCast(*const IVideoWindow, self), strCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Caption(self: *const T, strCaption: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_Caption(@ptrCast(*const IVideoWindow, self), strCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_WindowStyle(self: *const T, WindowStyle: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_WindowStyle(@ptrCast(*const IVideoWindow, self), WindowStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_WindowStyle(self: *const T, WindowStyle: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_WindowStyle(@ptrCast(*const IVideoWindow, self), WindowStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_WindowStyleEx(self: *const T, WindowStyleEx: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_WindowStyleEx(@ptrCast(*const IVideoWindow, self), WindowStyleEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_WindowStyleEx(self: *const T, WindowStyleEx: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_WindowStyleEx(@ptrCast(*const IVideoWindow, self), WindowStyleEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_AutoShow(self: *const T, AutoShow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_AutoShow(@ptrCast(*const IVideoWindow, self), AutoShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_AutoShow(self: *const T, AutoShow: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_AutoShow(@ptrCast(*const IVideoWindow, self), AutoShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_WindowState(self: *const T, WindowState: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_WindowState(@ptrCast(*const IVideoWindow, self), WindowState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_WindowState(self: *const T, WindowState: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_WindowState(@ptrCast(*const IVideoWindow, self), WindowState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_BackgroundPalette(self: *const T, BackgroundPalette: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_BackgroundPalette(@ptrCast(*const IVideoWindow, self), BackgroundPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_BackgroundPalette(self: *const T, pBackgroundPalette: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_BackgroundPalette(@ptrCast(*const IVideoWindow, self), pBackgroundPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Visible(self: *const T, Visible: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_Visible(@ptrCast(*const IVideoWindow, self), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Visible(self: *const T, pVisible: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_Visible(@ptrCast(*const IVideoWindow, self), pVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Left(self: *const T, Left: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_Left(@ptrCast(*const IVideoWindow, self), Left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Left(self: *const T, pLeft: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_Left(@ptrCast(*const IVideoWindow, self), pLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Width(self: *const T, Width: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_Width(@ptrCast(*const IVideoWindow, self), Width);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Width(self: *const T, pWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_Width(@ptrCast(*const IVideoWindow, self), pWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Top(self: *const T, Top: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_Top(@ptrCast(*const IVideoWindow, self), Top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Top(self: *const T, pTop: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_Top(@ptrCast(*const IVideoWindow, self), pTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Height(self: *const T, Height: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_Height(@ptrCast(*const IVideoWindow, self), Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Height(self: *const T, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_Height(@ptrCast(*const IVideoWindow, self), pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Owner(self: *const T, Owner: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_Owner(@ptrCast(*const IVideoWindow, self), Owner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Owner(self: *const T, Owner: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_Owner(@ptrCast(*const IVideoWindow, self), Owner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_MessageDrain(self: *const T, Drain: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_MessageDrain(@ptrCast(*const IVideoWindow, self), Drain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_MessageDrain(self: *const T, Drain: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_MessageDrain(@ptrCast(*const IVideoWindow, self), Drain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_BorderColor(self: *const T, Color: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_BorderColor(@ptrCast(*const IVideoWindow, self), Color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_BorderColor(self: *const T, Color: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_BorderColor(@ptrCast(*const IVideoWindow, self), Color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_FullScreenMode(self: *const T, FullScreenMode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).get_FullScreenMode(@ptrCast(*const IVideoWindow, self), FullScreenMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_FullScreenMode(self: *const T, FullScreenMode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).put_FullScreenMode(@ptrCast(*const IVideoWindow, self), FullScreenMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_SetWindowForeground(self: *const T, Focus: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).SetWindowForeground(@ptrCast(*const IVideoWindow, self), Focus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_NotifyOwnerMessage(self: *const T, hwnd: isize, uMsg: i32, wParam: isize, lParam: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).NotifyOwnerMessage(@ptrCast(*const IVideoWindow, self), hwnd, uMsg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_SetWindowPosition(self: *const T, Left: i32, Top: i32, Width: i32, Height: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).SetWindowPosition(@ptrCast(*const IVideoWindow, self), Left, Top, Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_GetWindowPosition(self: *const T, pLeft: ?*i32, pTop: ?*i32, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).GetWindowPosition(@ptrCast(*const IVideoWindow, self), pLeft, pTop, pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_GetMinIdealImageSize(self: *const T, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).GetMinIdealImageSize(@ptrCast(*const IVideoWindow, self), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_GetMaxIdealImageSize(self: *const T, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).GetMaxIdealImageSize(@ptrCast(*const IVideoWindow, self), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_GetRestorePosition(self: *const T, pLeft: ?*i32, pTop: ?*i32, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).GetRestorePosition(@ptrCast(*const IVideoWindow, self), pLeft, pTop, pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_HideCursor(self: *const T, HideCursor: OA_BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).HideCursor(@ptrCast(*const IVideoWindow, self), HideCursor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_IsCursorHidden(self: *const T, CursorHidden: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoWindow.VTable, self.vtable).IsCursorHidden(@ptrCast(*const IVideoWindow, self), CursorHidden);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBasicVideo_Value = @import("../zig.zig").Guid.initString("56a868b5-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IBasicVideo = &IID_IBasicVideo_Value;
pub const IBasicVideo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgTimePerFrame: fn(
            self: *const IBasicVideo,
            pAvgTimePerFrame: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitRate: fn(
            self: *const IBasicVideo,
            pBitRate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitErrorRate: fn(
            self: *const IBasicVideo,
            pBitErrorRate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoWidth: fn(
            self: *const IBasicVideo,
            pVideoWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoHeight: fn(
            self: *const IBasicVideo,
            pVideoHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceLeft: fn(
            self: *const IBasicVideo,
            SourceLeft: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceLeft: fn(
            self: *const IBasicVideo,
            pSourceLeft: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceWidth: fn(
            self: *const IBasicVideo,
            SourceWidth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceWidth: fn(
            self: *const IBasicVideo,
            pSourceWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceTop: fn(
            self: *const IBasicVideo,
            SourceTop: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceTop: fn(
            self: *const IBasicVideo,
            pSourceTop: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceHeight: fn(
            self: *const IBasicVideo,
            SourceHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceHeight: fn(
            self: *const IBasicVideo,
            pSourceHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationLeft: fn(
            self: *const IBasicVideo,
            DestinationLeft: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationLeft: fn(
            self: *const IBasicVideo,
            pDestinationLeft: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationWidth: fn(
            self: *const IBasicVideo,
            DestinationWidth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationWidth: fn(
            self: *const IBasicVideo,
            pDestinationWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationTop: fn(
            self: *const IBasicVideo,
            DestinationTop: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationTop: fn(
            self: *const IBasicVideo,
            pDestinationTop: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationHeight: fn(
            self: *const IBasicVideo,
            DestinationHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationHeight: fn(
            self: *const IBasicVideo,
            pDestinationHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePosition: fn(
            self: *const IBasicVideo,
            Left: i32,
            Top: i32,
            Width: i32,
            Height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePosition: fn(
            self: *const IBasicVideo,
            pLeft: ?*i32,
            pTop: ?*i32,
            pWidth: ?*i32,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultSourcePosition: fn(
            self: *const IBasicVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDestinationPosition: fn(
            self: *const IBasicVideo,
            Left: i32,
            Top: i32,
            Width: i32,
            Height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestinationPosition: fn(
            self: *const IBasicVideo,
            pLeft: ?*i32,
            pTop: ?*i32,
            pWidth: ?*i32,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultDestinationPosition: fn(
            self: *const IBasicVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoSize: fn(
            self: *const IBasicVideo,
            pWidth: ?*i32,
            pHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPaletteEntries: fn(
            self: *const IBasicVideo,
            StartIndex: i32,
            Entries: i32,
            pRetrieved: ?*i32,
            pPalette: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentImage: fn(
            self: *const IBasicVideo,
            pBufferSize: ?*i32,
            pDIBImage: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUsingDefaultSource: fn(
            self: *const IBasicVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUsingDefaultDestination: fn(
            self: *const IBasicVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_AvgTimePerFrame(self: *const T, pAvgTimePerFrame: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_AvgTimePerFrame(@ptrCast(*const IBasicVideo, self), pAvgTimePerFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_BitRate(self: *const T, pBitRate: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_BitRate(@ptrCast(*const IBasicVideo, self), pBitRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_BitErrorRate(self: *const T, pBitErrorRate: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_BitErrorRate(@ptrCast(*const IBasicVideo, self), pBitErrorRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_VideoWidth(self: *const T, pVideoWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_VideoWidth(@ptrCast(*const IBasicVideo, self), pVideoWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_VideoHeight(self: *const T, pVideoHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_VideoHeight(@ptrCast(*const IBasicVideo, self), pVideoHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_SourceLeft(self: *const T, SourceLeft: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).put_SourceLeft(@ptrCast(*const IBasicVideo, self), SourceLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_SourceLeft(self: *const T, pSourceLeft: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_SourceLeft(@ptrCast(*const IBasicVideo, self), pSourceLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_SourceWidth(self: *const T, SourceWidth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).put_SourceWidth(@ptrCast(*const IBasicVideo, self), SourceWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_SourceWidth(self: *const T, pSourceWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_SourceWidth(@ptrCast(*const IBasicVideo, self), pSourceWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_SourceTop(self: *const T, SourceTop: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).put_SourceTop(@ptrCast(*const IBasicVideo, self), SourceTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_SourceTop(self: *const T, pSourceTop: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_SourceTop(@ptrCast(*const IBasicVideo, self), pSourceTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_SourceHeight(self: *const T, SourceHeight: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).put_SourceHeight(@ptrCast(*const IBasicVideo, self), SourceHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_SourceHeight(self: *const T, pSourceHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_SourceHeight(@ptrCast(*const IBasicVideo, self), pSourceHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_DestinationLeft(self: *const T, DestinationLeft: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).put_DestinationLeft(@ptrCast(*const IBasicVideo, self), DestinationLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_DestinationLeft(self: *const T, pDestinationLeft: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_DestinationLeft(@ptrCast(*const IBasicVideo, self), pDestinationLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_DestinationWidth(self: *const T, DestinationWidth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).put_DestinationWidth(@ptrCast(*const IBasicVideo, self), DestinationWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_DestinationWidth(self: *const T, pDestinationWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_DestinationWidth(@ptrCast(*const IBasicVideo, self), pDestinationWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_DestinationTop(self: *const T, DestinationTop: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).put_DestinationTop(@ptrCast(*const IBasicVideo, self), DestinationTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_DestinationTop(self: *const T, pDestinationTop: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_DestinationTop(@ptrCast(*const IBasicVideo, self), pDestinationTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_DestinationHeight(self: *const T, DestinationHeight: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).put_DestinationHeight(@ptrCast(*const IBasicVideo, self), DestinationHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_DestinationHeight(self: *const T, pDestinationHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).get_DestinationHeight(@ptrCast(*const IBasicVideo, self), pDestinationHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_SetSourcePosition(self: *const T, Left: i32, Top: i32, Width: i32, Height: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).SetSourcePosition(@ptrCast(*const IBasicVideo, self), Left, Top, Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetSourcePosition(self: *const T, pLeft: ?*i32, pTop: ?*i32, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).GetSourcePosition(@ptrCast(*const IBasicVideo, self), pLeft, pTop, pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_SetDefaultSourcePosition(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).SetDefaultSourcePosition(@ptrCast(*const IBasicVideo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_SetDestinationPosition(self: *const T, Left: i32, Top: i32, Width: i32, Height: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).SetDestinationPosition(@ptrCast(*const IBasicVideo, self), Left, Top, Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetDestinationPosition(self: *const T, pLeft: ?*i32, pTop: ?*i32, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).GetDestinationPosition(@ptrCast(*const IBasicVideo, self), pLeft, pTop, pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_SetDefaultDestinationPosition(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).SetDefaultDestinationPosition(@ptrCast(*const IBasicVideo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetVideoSize(self: *const T, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).GetVideoSize(@ptrCast(*const IBasicVideo, self), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetVideoPaletteEntries(self: *const T, StartIndex: i32, Entries: i32, pRetrieved: ?*i32, pPalette: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).GetVideoPaletteEntries(@ptrCast(*const IBasicVideo, self), StartIndex, Entries, pRetrieved, pPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetCurrentImage(self: *const T, pBufferSize: ?*i32, pDIBImage: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).GetCurrentImage(@ptrCast(*const IBasicVideo, self), pBufferSize, pDIBImage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_IsUsingDefaultSource(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).IsUsingDefaultSource(@ptrCast(*const IBasicVideo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_IsUsingDefaultDestination(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo.VTable, self.vtable).IsUsingDefaultDestination(@ptrCast(*const IBasicVideo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBasicVideo2_Value = @import("../zig.zig").Guid.initString("329bb360-f6ea-11d1-9038-00a0c9697298");
pub const IID_IBasicVideo2 = &IID_IBasicVideo2_Value;
pub const IBasicVideo2 = extern struct {
    pub const VTable = extern struct {
        base: IBasicVideo.VTable,
        GetPreferredAspectRatio: fn(
            self: *const IBasicVideo2,
            plAspectX: ?*i32,
            plAspectY: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBasicVideo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo2_GetPreferredAspectRatio(self: *const T, plAspectX: ?*i32, plAspectY: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBasicVideo2.VTable, self.vtable).GetPreferredAspectRatio(@ptrCast(*const IBasicVideo2, self), plAspectX, plAspectY);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDeferredCommand_Value = @import("../zig.zig").Guid.initString("56a868b8-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IDeferredCommand = &IID_IDeferredCommand_Value;
pub const IDeferredCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: fn(
            self: *const IDeferredCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Confidence: fn(
            self: *const IDeferredCommand,
            pConfidence: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Postpone: fn(
            self: *const IDeferredCommand,
            newtime: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHResult: fn(
            self: *const IDeferredCommand,
            phrResult: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeferredCommand_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeferredCommand.VTable, self.vtable).Cancel(@ptrCast(*const IDeferredCommand, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeferredCommand_Confidence(self: *const T, pConfidence: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeferredCommand.VTable, self.vtable).Confidence(@ptrCast(*const IDeferredCommand, self), pConfidence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeferredCommand_Postpone(self: *const T, newtime: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeferredCommand.VTable, self.vtable).Postpone(@ptrCast(*const IDeferredCommand, self), newtime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeferredCommand_GetHResult(self: *const T, phrResult: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeferredCommand.VTable, self.vtable).GetHResult(@ptrCast(*const IDeferredCommand, self), phrResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQueueCommand_Value = @import("../zig.zig").Guid.initString("56a868b7-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IQueueCommand = &IID_IQueueCommand_Value;
pub const IQueueCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvokeAtStreamTime: fn(
            self: *const IQueueCommand,
            pCmd: ?*?*IDeferredCommand,
            time: f64,
            iid: ?*Guid,
            dispidMethod: i32,
            wFlags: i16,
            cArgs: i32,
            pDispParams: ?*VARIANT,
            pvarResult: ?*VARIANT,
            puArgErr: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeAtPresentationTime: fn(
            self: *const IQueueCommand,
            pCmd: ?*?*IDeferredCommand,
            time: f64,
            iid: ?*Guid,
            dispidMethod: i32,
            wFlags: i16,
            cArgs: i32,
            pDispParams: ?*VARIANT,
            pvarResult: ?*VARIANT,
            puArgErr: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueueCommand_InvokeAtStreamTime(self: *const T, pCmd: ?*?*IDeferredCommand, time: f64, iid: ?*Guid, dispidMethod: i32, wFlags: i16, cArgs: i32, pDispParams: ?*VARIANT, pvarResult: ?*VARIANT, puArgErr: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueueCommand.VTable, self.vtable).InvokeAtStreamTime(@ptrCast(*const IQueueCommand, self), pCmd, time, iid, dispidMethod, wFlags, cArgs, pDispParams, pvarResult, puArgErr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueueCommand_InvokeAtPresentationTime(self: *const T, pCmd: ?*?*IDeferredCommand, time: f64, iid: ?*Guid, dispidMethod: i32, wFlags: i16, cArgs: i32, pDispParams: ?*VARIANT, pvarResult: ?*VARIANT, puArgErr: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueueCommand.VTable, self.vtable).InvokeAtPresentationTime(@ptrCast(*const IQueueCommand, self), pCmd, time, iid, dispidMethod, wFlags, cArgs, pDispParams, pvarResult, puArgErr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFilterInfo_Value = @import("../zig.zig").Guid.initString("56a868ba-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFilterInfo = &IID_IFilterInfo_Value;
pub const IFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        FindPin: fn(
            self: *const IFilterInfo,
            strPinID: ?BSTR,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFilterInfo,
            strName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VendorInfo: fn(
            self: *const IFilterInfo,
            strVendorInfo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Filter: fn(
            self: *const IFilterInfo,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pins: fn(
            self: *const IFilterInfo,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFileSource: fn(
            self: *const IFilterInfo,
            pbIsSource: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Filename: fn(
            self: *const IFilterInfo,
            pstrFilename: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Filename: fn(
            self: *const IFilterInfo,
            strFilename: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_FindPin(self: *const T, strPinID: ?BSTR, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterInfo.VTable, self.vtable).FindPin(@ptrCast(*const IFilterInfo, self), strPinID, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_Name(self: *const T, strName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterInfo.VTable, self.vtable).get_Name(@ptrCast(*const IFilterInfo, self), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_VendorInfo(self: *const T, strVendorInfo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterInfo.VTable, self.vtable).get_VendorInfo(@ptrCast(*const IFilterInfo, self), strVendorInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_Filter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterInfo.VTable, self.vtable).get_Filter(@ptrCast(*const IFilterInfo, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_Pins(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterInfo.VTable, self.vtable).get_Pins(@ptrCast(*const IFilterInfo, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_IsFileSource(self: *const T, pbIsSource: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterInfo.VTable, self.vtable).get_IsFileSource(@ptrCast(*const IFilterInfo, self), pbIsSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_Filename(self: *const T, pstrFilename: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterInfo.VTable, self.vtable).get_Filename(@ptrCast(*const IFilterInfo, self), pstrFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_put_Filename(self: *const T, strFilename: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFilterInfo.VTable, self.vtable).put_Filename(@ptrCast(*const IFilterInfo, self), strFilename);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRegFilterInfo_Value = @import("../zig.zig").Guid.initString("56a868bb-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IRegFilterInfo = &IID_IRegFilterInfo_Value;
pub const IRegFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IRegFilterInfo,
            strName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Filter: fn(
            self: *const IRegFilterInfo,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegFilterInfo_get_Name(self: *const T, strName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegFilterInfo.VTable, self.vtable).get_Name(@ptrCast(*const IRegFilterInfo, self), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegFilterInfo_Filter(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegFilterInfo.VTable, self.vtable).Filter(@ptrCast(*const IRegFilterInfo, self), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaTypeInfo_Value = @import("../zig.zig").Guid.initString("56a868bc-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaTypeInfo = &IID_IMediaTypeInfo_Value;
pub const IMediaTypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IMediaTypeInfo,
            strType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Subtype: fn(
            self: *const IMediaTypeInfo,
            strType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaTypeInfo_get_Type(self: *const T, strType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaTypeInfo.VTable, self.vtable).get_Type(@ptrCast(*const IMediaTypeInfo, self), strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaTypeInfo_get_Subtype(self: *const T, strType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaTypeInfo.VTable, self.vtable).get_Subtype(@ptrCast(*const IMediaTypeInfo, self), strType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPinInfo_Value = @import("../zig.zig").Guid.initString("56a868bd-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IPinInfo = &IID_IPinInfo_Value;
pub const IPinInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pin: fn(
            self: *const IPinInfo,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectedTo: fn(
            self: *const IPinInfo,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionMediaType: fn(
            self: *const IPinInfo,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilterInfo: fn(
            self: *const IPinInfo,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IPinInfo,
            ppUnk: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Direction: fn(
            self: *const IPinInfo,
            ppDirection: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PinID: fn(
            self: *const IPinInfo,
            strPinID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaTypes: fn(
            self: *const IPinInfo,
            ppUnk: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Connect: fn(
            self: *const IPinInfo,
            pPin: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectDirect: fn(
            self: *const IPinInfo,
            pPin: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectWithType: fn(
            self: *const IPinInfo,
            pPin: ?*IUnknown,
            pMediaType: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IPinInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Render: fn(
            self: *const IPinInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_Pin(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).get_Pin(@ptrCast(*const IPinInfo, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_ConnectedTo(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).get_ConnectedTo(@ptrCast(*const IPinInfo, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_ConnectionMediaType(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).get_ConnectionMediaType(@ptrCast(*const IPinInfo, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_FilterInfo(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).get_FilterInfo(@ptrCast(*const IPinInfo, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_Name(self: *const T, ppUnk: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).get_Name(@ptrCast(*const IPinInfo, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_Direction(self: *const T, ppDirection: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).get_Direction(@ptrCast(*const IPinInfo, self), ppDirection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_PinID(self: *const T, strPinID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).get_PinID(@ptrCast(*const IPinInfo, self), strPinID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_MediaTypes(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).get_MediaTypes(@ptrCast(*const IPinInfo, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_Connect(self: *const T, pPin: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).Connect(@ptrCast(*const IPinInfo, self), pPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_ConnectDirect(self: *const T, pPin: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).ConnectDirect(@ptrCast(*const IPinInfo, self), pPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_ConnectWithType(self: *const T, pPin: ?*IUnknown, pMediaType: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).ConnectWithType(@ptrCast(*const IPinInfo, self), pPin, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).Disconnect(@ptrCast(*const IPinInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_Render(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPinInfo.VTable, self.vtable).Render(@ptrCast(*const IPinInfo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMStats_Value = @import("../zig.zig").Guid.initString("bc9bcf80-dcd2-11d2-abf6-00a0c905f375");
pub const IID_IAMStats = &IID_IAMStats_Value;
pub const IAMStats = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Reset: fn(
            self: *const IAMStats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IAMStats,
            plCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueByIndex: fn(
            self: *const IAMStats,
            lIndex: i32,
            szName: ?*?BSTR,
            lCount: ?*i32,
            dLast: ?*f64,
            dAverage: ?*f64,
            dStdDev: ?*f64,
            dMin: ?*f64,
            dMax: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueByName: fn(
            self: *const IAMStats,
            szName: ?BSTR,
            lIndex: ?*i32,
            lCount: ?*i32,
            dLast: ?*f64,
            dAverage: ?*f64,
            dStdDev: ?*f64,
            dMin: ?*f64,
            dMax: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const IAMStats,
            szName: ?BSTR,
            lCreate: i32,
            plIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddValue: fn(
            self: *const IAMStats,
            lIndex: i32,
            dValue: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStats.VTable, self.vtable).Reset(@ptrCast(*const IAMStats, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_get_Count(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStats.VTable, self.vtable).get_Count(@ptrCast(*const IAMStats, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_GetValueByIndex(self: *const T, lIndex: i32, szName: ?*?BSTR, lCount: ?*i32, dLast: ?*f64, dAverage: ?*f64, dStdDev: ?*f64, dMin: ?*f64, dMax: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStats.VTable, self.vtable).GetValueByIndex(@ptrCast(*const IAMStats, self), lIndex, szName, lCount, dLast, dAverage, dStdDev, dMin, dMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_GetValueByName(self: *const T, szName: ?BSTR, lIndex: ?*i32, lCount: ?*i32, dLast: ?*f64, dAverage: ?*f64, dStdDev: ?*f64, dMin: ?*f64, dMax: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStats.VTable, self.vtable).GetValueByName(@ptrCast(*const IAMStats, self), szName, lIndex, lCount, dLast, dAverage, dStdDev, dMin, dMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_GetIndex(self: *const T, szName: ?BSTR, lCreate: i32, plIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStats.VTable, self.vtable).GetIndex(@ptrCast(*const IAMStats, self), szName, lCreate, plIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_AddValue(self: *const T, lIndex: i32, dValue: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMStats.VTable, self.vtable).AddValue(@ptrCast(*const IAMStats, self), lIndex, dValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMVAUncompBufferInfo = extern struct {
    dwMinNumSurfaces: u32,
    dwMaxNumSurfaces: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
};

pub const AMVAUncompDataInfo = extern struct {
    dwUncompWidth: u32,
    dwUncompHeight: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
};

pub const AMVAInternalMemInfo = extern struct {
    dwScratchMemAlloc: u32,
};

pub const AMVACompBufferInfo = extern struct {
    dwNumCompBuffers: u32,
    dwWidthToCreate: u32,
    dwHeightToCreate: u32,
    dwBytesToAllocate: u32,
    ddCompCaps: DDSCAPS2,
    ddPixelFormat: DDPIXELFORMAT,
};

pub const AMVABeginFrameInfo = extern struct {
    dwDestSurfaceIndex: u32,
    pInputData: ?*anyopaque,
    dwSizeInputData: u32,
    pOutputData: ?*anyopaque,
    dwSizeOutputData: u32,
};

pub const AMVAEndFrameInfo = extern struct {
    dwSizeMiscData: u32,
    pMiscData: ?*anyopaque,
};

pub const AMVABUFFERINFO = extern struct {
    dwTypeIndex: u32,
    dwBufferIndex: u32,
    dwDataOffset: u32,
    dwDataSize: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoAcceleratorNotify_Value = @import("../zig.zig").Guid.initString("256a6a21-fbad-11d1-82bf-00a0c9696c8f");
pub const IID_IAMVideoAcceleratorNotify = &IID_IAMVideoAcceleratorNotify_Value;
pub const IAMVideoAcceleratorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUncompSurfacesInfo: fn(
            self: *const IAMVideoAcceleratorNotify,
            pGuid: ?*const Guid,
            pUncompBufferInfo: ?*AMVAUncompBufferInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUncompSurfacesInfo: fn(
            self: *const IAMVideoAcceleratorNotify,
            dwActualUncompSurfacesAllocated: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCreateVideoAcceleratorData: fn(
            self: *const IAMVideoAcceleratorNotify,
            pGuid: ?*const Guid,
            pdwSizeMiscData: ?*u32,
            ppMiscData: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAcceleratorNotify_GetUncompSurfacesInfo(self: *const T, pGuid: ?*const Guid, pUncompBufferInfo: ?*AMVAUncompBufferInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAcceleratorNotify.VTable, self.vtable).GetUncompSurfacesInfo(@ptrCast(*const IAMVideoAcceleratorNotify, self), pGuid, pUncompBufferInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAcceleratorNotify_SetUncompSurfacesInfo(self: *const T, dwActualUncompSurfacesAllocated: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAcceleratorNotify.VTable, self.vtable).SetUncompSurfacesInfo(@ptrCast(*const IAMVideoAcceleratorNotify, self), dwActualUncompSurfacesAllocated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAcceleratorNotify_GetCreateVideoAcceleratorData(self: *const T, pGuid: ?*const Guid, pdwSizeMiscData: ?*u32, ppMiscData: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAcceleratorNotify.VTable, self.vtable).GetCreateVideoAcceleratorData(@ptrCast(*const IAMVideoAcceleratorNotify, self), pGuid, pdwSizeMiscData, ppMiscData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoAccelerator_Value = @import("../zig.zig").Guid.initString("256a6a22-fbad-11d1-82bf-00a0c9696c8f");
pub const IID_IAMVideoAccelerator = &IID_IAMVideoAccelerator_Value;
pub const IAMVideoAccelerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVideoAcceleratorGUIDs: fn(
            self: *const IAMVideoAccelerator,
            pdwNumGuidsSupported: ?*u32,
            pGuidsSupported: ?[*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUncompFormatsSupported: fn(
            self: *const IAMVideoAccelerator,
            pGuid: ?*const Guid,
            pdwNumFormatsSupported: ?*u32,
            pFormatsSupported: ?[*]DDPIXELFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInternalMemInfo: fn(
            self: *const IAMVideoAccelerator,
            pGuid: ?*const Guid,
            pamvaUncompDataInfo: ?*const AMVAUncompDataInfo,
            pamvaInternalMemInfo: ?*AMVAInternalMemInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompBufferInfo: fn(
            self: *const IAMVideoAccelerator,
            pGuid: ?*const Guid,
            pamvaUncompDataInfo: ?*const AMVAUncompDataInfo,
            pdwNumTypesCompBuffers: ?*u32,
            pamvaCompBufferInfo: ?[*]AMVACompBufferInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInternalCompBufferInfo: fn(
            self: *const IAMVideoAccelerator,
            pdwNumTypesCompBuffers: ?*u32,
            pamvaCompBufferInfo: ?[*]AMVACompBufferInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginFrame: fn(
            self: *const IAMVideoAccelerator,
            amvaBeginFrameInfo: ?*const AMVABeginFrameInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndFrame: fn(
            self: *const IAMVideoAccelerator,
            pEndFrameInfo: ?*const AMVAEndFrameInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffer: fn(
            self: *const IAMVideoAccelerator,
            dwTypeIndex: u32,
            dwBufferIndex: u32,
            bReadOnly: BOOL,
            ppBuffer: ?*?*anyopaque,
            lpStride: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBuffer: fn(
            self: *const IAMVideoAccelerator,
            dwTypeIndex: u32,
            dwBufferIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IAMVideoAccelerator,
            dwFunction: u32,
            lpPrivateInputData: ?*anyopaque,
            cbPrivateInputData: u32,
            lpPrivateOutputDat: ?*anyopaque,
            cbPrivateOutputData: u32,
            dwNumBuffers: u32,
            pamvaBufferInfo: [*]const AMVABUFFERINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryRenderStatus: fn(
            self: *const IAMVideoAccelerator,
            dwTypeIndex: u32,
            dwBufferIndex: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayFrame: fn(
            self: *const IAMVideoAccelerator,
            dwFlipToIndex: u32,
            pMediaSample: ?*IMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetVideoAcceleratorGUIDs(self: *const T, pdwNumGuidsSupported: ?*u32, pGuidsSupported: ?[*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).GetVideoAcceleratorGUIDs(@ptrCast(*const IAMVideoAccelerator, self), pdwNumGuidsSupported, pGuidsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetUncompFormatsSupported(self: *const T, pGuid: ?*const Guid, pdwNumFormatsSupported: ?*u32, pFormatsSupported: ?[*]DDPIXELFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).GetUncompFormatsSupported(@ptrCast(*const IAMVideoAccelerator, self), pGuid, pdwNumFormatsSupported, pFormatsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetInternalMemInfo(self: *const T, pGuid: ?*const Guid, pamvaUncompDataInfo: ?*const AMVAUncompDataInfo, pamvaInternalMemInfo: ?*AMVAInternalMemInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).GetInternalMemInfo(@ptrCast(*const IAMVideoAccelerator, self), pGuid, pamvaUncompDataInfo, pamvaInternalMemInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetCompBufferInfo(self: *const T, pGuid: ?*const Guid, pamvaUncompDataInfo: ?*const AMVAUncompDataInfo, pdwNumTypesCompBuffers: ?*u32, pamvaCompBufferInfo: ?[*]AMVACompBufferInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).GetCompBufferInfo(@ptrCast(*const IAMVideoAccelerator, self), pGuid, pamvaUncompDataInfo, pdwNumTypesCompBuffers, pamvaCompBufferInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetInternalCompBufferInfo(self: *const T, pdwNumTypesCompBuffers: ?*u32, pamvaCompBufferInfo: ?[*]AMVACompBufferInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).GetInternalCompBufferInfo(@ptrCast(*const IAMVideoAccelerator, self), pdwNumTypesCompBuffers, pamvaCompBufferInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_BeginFrame(self: *const T, amvaBeginFrameInfo: ?*const AMVABeginFrameInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).BeginFrame(@ptrCast(*const IAMVideoAccelerator, self), amvaBeginFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_EndFrame(self: *const T, pEndFrameInfo: ?*const AMVAEndFrameInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).EndFrame(@ptrCast(*const IAMVideoAccelerator, self), pEndFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetBuffer(self: *const T, dwTypeIndex: u32, dwBufferIndex: u32, bReadOnly: BOOL, ppBuffer: ?*?*anyopaque, lpStride: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).GetBuffer(@ptrCast(*const IAMVideoAccelerator, self), dwTypeIndex, dwBufferIndex, bReadOnly, ppBuffer, lpStride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_ReleaseBuffer(self: *const T, dwTypeIndex: u32, dwBufferIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).ReleaseBuffer(@ptrCast(*const IAMVideoAccelerator, self), dwTypeIndex, dwBufferIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_Execute(self: *const T, dwFunction: u32, lpPrivateInputData: ?*anyopaque, cbPrivateInputData: u32, lpPrivateOutputDat: ?*anyopaque, cbPrivateOutputData: u32, dwNumBuffers: u32, pamvaBufferInfo: [*]const AMVABUFFERINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).Execute(@ptrCast(*const IAMVideoAccelerator, self), dwFunction, lpPrivateInputData, cbPrivateInputData, lpPrivateOutputDat, cbPrivateOutputData, dwNumBuffers, pamvaBufferInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_QueryRenderStatus(self: *const T, dwTypeIndex: u32, dwBufferIndex: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).QueryRenderStatus(@ptrCast(*const IAMVideoAccelerator, self), dwTypeIndex, dwBufferIndex, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_DisplayFrame(self: *const T, dwFlipToIndex: u32, pMediaSample: ?*IMediaSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMVideoAccelerator.VTable, self.vtable).DisplayFrame(@ptrCast(*const IAMVideoAccelerator, self), dwFlipToIndex, pMediaSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_WST_PAGE = extern struct {
    dwPageNr: u32,
    dwSubPageNr: u32,
    pucPageData: ?*u8,
};

pub const AM_WST_LEVEL = enum(i32) {
    @"5" = 0,
};
pub const AM_WST_LEVEL_1_5 = AM_WST_LEVEL.@"5";

pub const AM_WST_SERVICE = enum(i32) {
    None = 0,
    Text = 1,
    IDS = 2,
    Invalid = 3,
};
pub const AM_WST_SERVICE_None = AM_WST_SERVICE.None;
pub const AM_WST_SERVICE_Text = AM_WST_SERVICE.Text;
pub const AM_WST_SERVICE_IDS = AM_WST_SERVICE.IDS;
pub const AM_WST_SERVICE_Invalid = AM_WST_SERVICE.Invalid;

pub const AM_WST_STATE = enum(i32) {
    ff = 0,
    n = 1,
};
pub const AM_WST_STATE_Off = AM_WST_STATE.ff;
pub const AM_WST_STATE_On = AM_WST_STATE.n;

pub const AM_WST_STYLE = enum(i32) {
    None = 0,
    Invers = 1,
};
pub const AM_WST_STYLE_None = AM_WST_STYLE.None;
pub const AM_WST_STYLE_Invers = AM_WST_STYLE.Invers;

pub const AM_WST_DRAWBGMODE = enum(i32) {
    Opaque = 0,
    Transparent = 1,
};
pub const AM_WST_DRAWBGMODE_Opaque = AM_WST_DRAWBGMODE.Opaque;
pub const AM_WST_DRAWBGMODE_Transparent = AM_WST_DRAWBGMODE.Transparent;

// TODO: this type is limited to platform 'windows5.1.2600'
pub const IAMWstDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecoderLevel: fn(
            self: *const IAMWstDecoder,
            lpLevel: ?*AM_WST_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentService: fn(
            self: *const IAMWstDecoder,
            lpService: ?*AM_WST_SERVICE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceState: fn(
            self: *const IAMWstDecoder,
            lpState: ?*AM_WST_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetServiceState: fn(
            self: *const IAMWstDecoder,
            State: AM_WST_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputFormat: fn(
            self: *const IAMWstDecoder,
            lpbmih: ?*BITMAPINFOHEADER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputFormat: fn(
            self: *const IAMWstDecoder,
            lpbmi: ?*BITMAPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: fn(
            self: *const IAMWstDecoder,
            pdwPhysColor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundColor: fn(
            self: *const IAMWstDecoder,
            dwPhysColor: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRedrawAlways: fn(
            self: *const IAMWstDecoder,
            lpbOption: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRedrawAlways: fn(
            self: *const IAMWstDecoder,
            bOption: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrawBackgroundMode: fn(
            self: *const IAMWstDecoder,
            lpMode: ?*AM_WST_DRAWBGMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDrawBackgroundMode: fn(
            self: *const IAMWstDecoder,
            Mode: AM_WST_DRAWBGMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAnswerMode: fn(
            self: *const IAMWstDecoder,
            bAnswer: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnswerMode: fn(
            self: *const IAMWstDecoder,
            pbAnswer: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHoldPage: fn(
            self: *const IAMWstDecoder,
            bHoldPage: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHoldPage: fn(
            self: *const IAMWstDecoder,
            pbHoldPage: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPage: fn(
            self: *const IAMWstDecoder,
            pWstPage: ?*AM_WST_PAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentPage: fn(
            self: *const IAMWstDecoder,
            WstPage: AM_WST_PAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetDecoderLevel(self: *const T, lpLevel: ?*AM_WST_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetDecoderLevel(@ptrCast(*const IAMWstDecoder, self), lpLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetCurrentService(self: *const T, lpService: ?*AM_WST_SERVICE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetCurrentService(@ptrCast(*const IAMWstDecoder, self), lpService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetServiceState(self: *const T, lpState: ?*AM_WST_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetServiceState(@ptrCast(*const IAMWstDecoder, self), lpState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetServiceState(self: *const T, State: AM_WST_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).SetServiceState(@ptrCast(*const IAMWstDecoder, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetOutputFormat(self: *const T, lpbmih: ?*BITMAPINFOHEADER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetOutputFormat(@ptrCast(*const IAMWstDecoder, self), lpbmih);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetOutputFormat(self: *const T, lpbmi: ?*BITMAPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).SetOutputFormat(@ptrCast(*const IAMWstDecoder, self), lpbmi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetBackgroundColor(self: *const T, pdwPhysColor: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetBackgroundColor(@ptrCast(*const IAMWstDecoder, self), pdwPhysColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetBackgroundColor(self: *const T, dwPhysColor: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).SetBackgroundColor(@ptrCast(*const IAMWstDecoder, self), dwPhysColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetRedrawAlways(self: *const T, lpbOption: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetRedrawAlways(@ptrCast(*const IAMWstDecoder, self), lpbOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetRedrawAlways(self: *const T, bOption: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).SetRedrawAlways(@ptrCast(*const IAMWstDecoder, self), bOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetDrawBackgroundMode(self: *const T, lpMode: ?*AM_WST_DRAWBGMODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetDrawBackgroundMode(@ptrCast(*const IAMWstDecoder, self), lpMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetDrawBackgroundMode(self: *const T, Mode: AM_WST_DRAWBGMODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).SetDrawBackgroundMode(@ptrCast(*const IAMWstDecoder, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetAnswerMode(self: *const T, bAnswer: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).SetAnswerMode(@ptrCast(*const IAMWstDecoder, self), bAnswer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetAnswerMode(self: *const T, pbAnswer: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetAnswerMode(@ptrCast(*const IAMWstDecoder, self), pbAnswer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetHoldPage(self: *const T, bHoldPage: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).SetHoldPage(@ptrCast(*const IAMWstDecoder, self), bHoldPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetHoldPage(self: *const T, pbHoldPage: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetHoldPage(@ptrCast(*const IAMWstDecoder, self), pbHoldPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetCurrentPage(self: *const T, pWstPage: ?*AM_WST_PAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).GetCurrentPage(@ptrCast(*const IAMWstDecoder, self), pWstPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetCurrentPage(self: *const T, WstPage: AM_WST_PAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMWstDecoder.VTable, self.vtable).SetCurrentPage(@ptrCast(*const IAMWstDecoder, self), WstPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IKsTopologyInfo_Value = @import("../zig.zig").Guid.initString("720d4ac0-7533-11d0-a5d6-28db04c10000");
pub const IID_IKsTopologyInfo = &IID_IKsTopologyInfo_Value;
pub const IKsTopologyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumCategories: fn(
            self: *const IKsTopologyInfo,
            pdwNumCategories: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: fn(
            self: *const IKsTopologyInfo,
            dwIndex: u32,
            pCategory: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumConnections: fn(
            self: *const IKsTopologyInfo,
            pdwNumConnections: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionInfo: fn(
            self: *const IKsTopologyInfo,
            dwIndex: u32,
            pConnectionInfo: ?*KSTOPOLOGY_CONNECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NodeName: fn(
            self: *const IKsTopologyInfo,
            dwNodeId: u32,
            // TODO: what to do with BytesParamIndex 2?
            pwchNodeName: ?PWSTR,
            dwBufSize: u32,
            pdwNameLen: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumNodes: fn(
            self: *const IKsTopologyInfo,
            pdwNumNodes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NodeType: fn(
            self: *const IKsTopologyInfo,
            dwNodeId: u32,
            pNodeType: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateNodeInstance: fn(
            self: *const IKsTopologyInfo,
            dwNodeId: u32,
            iid: ?*const Guid,
            ppvObject: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsTopologyInfo_get_NumCategories(self: *const T, pdwNumCategories: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsTopologyInfo.VTable, self.vtable).get_NumCategories(@ptrCast(*const IKsTopologyInfo, self), pdwNumCategories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsTopologyInfo_get_Category(self: *const T, dwIndex: u32, pCategory: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsTopologyInfo.VTable, self.vtable).get_Category(@ptrCast(*const IKsTopologyInfo, self), dwIndex, pCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsTopologyInfo_get_NumConnections(self: *const T, pdwNumConnections: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsTopologyInfo.VTable, self.vtable).get_NumConnections(@ptrCast(*const IKsTopologyInfo, self), pdwNumConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsTopologyInfo_get_ConnectionInfo(self: *const T, dwIndex: u32, pConnectionInfo: ?*KSTOPOLOGY_CONNECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsTopologyInfo.VTable, self.vtable).get_ConnectionInfo(@ptrCast(*const IKsTopologyInfo, self), dwIndex, pConnectionInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsTopologyInfo_get_NodeName(self: *const T, dwNodeId: u32, pwchNodeName: ?PWSTR, dwBufSize: u32, pdwNameLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsTopologyInfo.VTable, self.vtable).get_NodeName(@ptrCast(*const IKsTopologyInfo, self), dwNodeId, pwchNodeName, dwBufSize, pdwNameLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsTopologyInfo_get_NumNodes(self: *const T, pdwNumNodes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsTopologyInfo.VTable, self.vtable).get_NumNodes(@ptrCast(*const IKsTopologyInfo, self), pdwNumNodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsTopologyInfo_get_NodeType(self: *const T, dwNodeId: u32, pNodeType: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsTopologyInfo.VTable, self.vtable).get_NodeType(@ptrCast(*const IKsTopologyInfo, self), dwNodeId, pNodeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsTopologyInfo_CreateNodeInstance(self: *const T, dwNodeId: u32, iid: ?*const Guid, ppvObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsTopologyInfo.VTable, self.vtable).CreateNodeInstance(@ptrCast(*const IKsTopologyInfo, self), dwNodeId, iid, ppvObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISelector_Value = @import("../zig.zig").Guid.initString("1abdaeca-68b6-4f83-9371-b413907c7b9f");
pub const IID_ISelector = &IID_ISelector_Value;
pub const ISelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumSources: fn(
            self: *const ISelector,
            pdwNumSources: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceNodeId: fn(
            self: *const ISelector,
            pdwPinId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceNodeId: fn(
            self: *const ISelector,
            dwPinId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelector_get_NumSources(self: *const T, pdwNumSources: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelector.VTable, self.vtable).get_NumSources(@ptrCast(*const ISelector, self), pdwNumSources);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelector_get_SourceNodeId(self: *const T, pdwPinId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelector.VTable, self.vtable).get_SourceNodeId(@ptrCast(*const ISelector, self), pdwPinId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelector_put_SourceNodeId(self: *const T, dwPinId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelector.VTable, self.vtable).put_SourceNodeId(@ptrCast(*const ISelector, self), dwPinId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICameraControl_Value = @import("../zig.zig").Guid.initString("2ba1785d-4d1b-44ef-85e8-c7f1d3f20184");
pub const IID_ICameraControl = &IID_ICameraControl_Value;
pub const ICameraControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Exposure: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Exposure: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Exposure: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Focus: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Focus: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Focus: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Iris: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Iris: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Iris: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Zoom: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Zoom: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Zoom: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FocalLengths: fn(
            self: *const ICameraControl,
            plOcularFocalLength: ?*i32,
            plObjectiveFocalLengthMin: ?*i32,
            plObjectiveFocalLengthMax: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pan: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pan: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Pan: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tilt: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Tilt: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Tilt: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PanTilt: fn(
            self: *const ICameraControl,
            pPanValue: ?*i32,
            pTiltValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PanTilt: fn(
            self: *const ICameraControl,
            PanValue: i32,
            TiltValue: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Roll: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Roll: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Roll: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExposureRelative: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExposureRelative: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_ExposureRelative: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FocusRelative: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FocusRelative: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_FocusRelative: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IrisRelative: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IrisRelative: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_IrisRelative: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ZoomRelative: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ZoomRelative: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_ZoomRelative: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PanRelative: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PanRelative: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TiltRelative: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TiltRelative: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_TiltRelative: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PanTiltRelative: fn(
            self: *const ICameraControl,
            pPanValue: ?*i32,
            pTiltValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PanTiltRelative: fn(
            self: *const ICameraControl,
            PanValue: i32,
            TiltValue: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_PanRelative: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RollRelative: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RollRelative: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_RollRelative: fn(
            self: *const ICameraControl,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScanMode: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ScanMode: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrivacyMode: fn(
            self: *const ICameraControl,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PrivacyMode: fn(
            self: *const ICameraControl,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Exposure(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_Exposure(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Exposure(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_Exposure(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Exposure(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_Exposure(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Focus(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_Focus(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Focus(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_Focus(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Focus(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_Focus(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Iris(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_Iris(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Iris(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_Iris(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Iris(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_Iris(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Zoom(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_Zoom(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Zoom(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_Zoom(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Zoom(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_Zoom(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_FocalLengths(self: *const T, plOcularFocalLength: ?*i32, plObjectiveFocalLengthMin: ?*i32, plObjectiveFocalLengthMax: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_FocalLengths(@ptrCast(*const ICameraControl, self), plOcularFocalLength, plObjectiveFocalLengthMin, plObjectiveFocalLengthMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Pan(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_Pan(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Pan(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_Pan(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Pan(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_Pan(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Tilt(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_Tilt(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Tilt(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_Tilt(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Tilt(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_Tilt(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_PanTilt(self: *const T, pPanValue: ?*i32, pTiltValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_PanTilt(@ptrCast(*const ICameraControl, self), pPanValue, pTiltValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_PanTilt(self: *const T, PanValue: i32, TiltValue: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_PanTilt(@ptrCast(*const ICameraControl, self), PanValue, TiltValue, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Roll(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_Roll(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Roll(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_Roll(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Roll(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_Roll(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_ExposureRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_ExposureRelative(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_ExposureRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_ExposureRelative(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_ExposureRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_ExposureRelative(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_FocusRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_FocusRelative(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_FocusRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_FocusRelative(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_FocusRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_FocusRelative(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_IrisRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_IrisRelative(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_IrisRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_IrisRelative(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_IrisRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_IrisRelative(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_ZoomRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_ZoomRelative(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_ZoomRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_ZoomRelative(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_ZoomRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_ZoomRelative(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_PanRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_PanRelative(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_PanRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_PanRelative(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_TiltRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_TiltRelative(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_TiltRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_TiltRelative(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_TiltRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_TiltRelative(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_PanTiltRelative(self: *const T, pPanValue: ?*i32, pTiltValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_PanTiltRelative(@ptrCast(*const ICameraControl, self), pPanValue, pTiltValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_PanTiltRelative(self: *const T, PanValue: i32, TiltValue: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_PanTiltRelative(@ptrCast(*const ICameraControl, self), PanValue, TiltValue, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_PanRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_PanRelative(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_RollRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_RollRelative(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_RollRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_RollRelative(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_RollRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).getRange_RollRelative(@ptrCast(*const ICameraControl, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_ScanMode(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_ScanMode(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_ScanMode(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_ScanMode(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_PrivacyMode(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).get_PrivacyMode(@ptrCast(*const ICameraControl, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_PrivacyMode(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraControl.VTable, self.vtable).put_PrivacyMode(@ptrCast(*const ICameraControl, self), Value, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVideoProcAmp_Value = @import("../zig.zig").Guid.initString("4050560e-42a7-413a-85c2-09269a2d0f44");
pub const IID_IVideoProcAmp = &IID_IVideoProcAmp_Value;
pub const IVideoProcAmp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BacklightCompensation: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BacklightCompensation: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_BacklightCompensation: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Brightness: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Brightness: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Brightness: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColorEnable: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ColorEnable: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_ColorEnable: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Contrast: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Contrast: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Contrast: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Gamma: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Gamma: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Gamma: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Saturation: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Saturation: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Saturation: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Sharpness: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Sharpness: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Sharpness: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WhiteBalance: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WhiteBalance: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_WhiteBalance: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Gain: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Gain: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Gain: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hue: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Hue: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_Hue: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DigitalMultiplier: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DigitalMultiplier: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_DigitalMultiplier: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PowerlineFrequency: fn(
            self: *const IVideoProcAmp,
            pValue: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PowerlineFrequency: fn(
            self: *const IVideoProcAmp,
            Value: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_PowerlineFrequency: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WhiteBalanceComponent: fn(
            self: *const IVideoProcAmp,
            pValue1: ?*i32,
            pValue2: ?*i32,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WhiteBalanceComponent: fn(
            self: *const IVideoProcAmp,
            Value1: i32,
            Value2: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRange_WhiteBalanceComponent: fn(
            self: *const IVideoProcAmp,
            pMin: ?*i32,
            pMax: ?*i32,
            pSteppingDelta: ?*i32,
            pDefault: ?*i32,
            pCapsFlag: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_BacklightCompensation(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_BacklightCompensation(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_BacklightCompensation(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_BacklightCompensation(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_BacklightCompensation(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_BacklightCompensation(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Brightness(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_Brightness(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Brightness(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_Brightness(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Brightness(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_Brightness(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_ColorEnable(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_ColorEnable(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_ColorEnable(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_ColorEnable(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_ColorEnable(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_ColorEnable(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Contrast(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_Contrast(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Contrast(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_Contrast(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Contrast(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_Contrast(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Gamma(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_Gamma(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Gamma(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_Gamma(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Gamma(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_Gamma(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Saturation(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_Saturation(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Saturation(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_Saturation(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Saturation(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_Saturation(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Sharpness(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_Sharpness(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Sharpness(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_Sharpness(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Sharpness(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_Sharpness(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_WhiteBalance(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_WhiteBalance(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_WhiteBalance(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_WhiteBalance(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_WhiteBalance(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_WhiteBalance(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Gain(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_Gain(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Gain(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_Gain(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Gain(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_Gain(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Hue(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_Hue(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Hue(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_Hue(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Hue(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_Hue(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_DigitalMultiplier(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_DigitalMultiplier(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_DigitalMultiplier(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_DigitalMultiplier(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_DigitalMultiplier(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_DigitalMultiplier(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_PowerlineFrequency(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_PowerlineFrequency(@ptrCast(*const IVideoProcAmp, self), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_PowerlineFrequency(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_PowerlineFrequency(@ptrCast(*const IVideoProcAmp, self), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_PowerlineFrequency(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_PowerlineFrequency(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_WhiteBalanceComponent(self: *const T, pValue1: ?*i32, pValue2: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).get_WhiteBalanceComponent(@ptrCast(*const IVideoProcAmp, self), pValue1, pValue2, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_WhiteBalanceComponent(self: *const T, Value1: i32, Value2: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).put_WhiteBalanceComponent(@ptrCast(*const IVideoProcAmp, self), Value1, Value2, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_WhiteBalanceComponent(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVideoProcAmp.VTable, self.vtable).getRange_WhiteBalanceComponent(@ptrCast(*const IVideoProcAmp, self), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IKsNodeControl_Value = @import("../zig.zig").Guid.initString("11737c14-24a7-4bb5-81a0-0d003813b0c4");
pub const IID_IKsNodeControl = &IID_IKsNodeControl_Value;
pub const IKsNodeControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NodeId: fn(
            self: *const IKsNodeControl,
            dwNodeId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KsControl: fn(
            self: *const IKsNodeControl,
            pKsControl: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsNodeControl_put_NodeId(self: *const T, dwNodeId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsNodeControl.VTable, self.vtable).put_NodeId(@ptrCast(*const IKsNodeControl, self), dwNodeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKsNodeControl_put_KsControl(self: *const T, pKsControl: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKsNodeControl.VTable, self.vtable).put_KsControl(@ptrCast(*const IKsNodeControl, self), pKsControl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConfigAsfWriter_Value = @import("../zig.zig").Guid.initString("45086030-f7e4-486a-b504-826bb5792a3b");
pub const IID_IConfigAsfWriter = &IID_IConfigAsfWriter_Value;
pub const IConfigAsfWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConfigureFilterUsingProfileId: fn(
            self: *const IConfigAsfWriter,
            dwProfileId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProfileId: fn(
            self: *const IConfigAsfWriter,
            pdwProfileId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureFilterUsingProfileGuid: fn(
            self: *const IConfigAsfWriter,
            guidProfile: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProfileGuid: fn(
            self: *const IConfigAsfWriter,
            pProfileGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureFilterUsingProfile: fn(
            self: *const IConfigAsfWriter,
            pProfile: ?*IWMProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProfile: fn(
            self: *const IConfigAsfWriter,
            ppProfile: ?*?*IWMProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndexMode: fn(
            self: *const IConfigAsfWriter,
            bIndexFile: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexMode: fn(
            self: *const IConfigAsfWriter,
            pbIndexFile: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_ConfigureFilterUsingProfileId(self: *const T, dwProfileId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter.VTable, self.vtable).ConfigureFilterUsingProfileId(@ptrCast(*const IConfigAsfWriter, self), dwProfileId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_GetCurrentProfileId(self: *const T, pdwProfileId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter.VTable, self.vtable).GetCurrentProfileId(@ptrCast(*const IConfigAsfWriter, self), pdwProfileId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_ConfigureFilterUsingProfileGuid(self: *const T, guidProfile: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter.VTable, self.vtable).ConfigureFilterUsingProfileGuid(@ptrCast(*const IConfigAsfWriter, self), guidProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_GetCurrentProfileGuid(self: *const T, pProfileGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter.VTable, self.vtable).GetCurrentProfileGuid(@ptrCast(*const IConfigAsfWriter, self), pProfileGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_ConfigureFilterUsingProfile(self: *const T, pProfile: ?*IWMProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter.VTable, self.vtable).ConfigureFilterUsingProfile(@ptrCast(*const IConfigAsfWriter, self), pProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_GetCurrentProfile(self: *const T, ppProfile: ?*?*IWMProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter.VTable, self.vtable).GetCurrentProfile(@ptrCast(*const IConfigAsfWriter, self), ppProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_SetIndexMode(self: *const T, bIndexFile: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter.VTable, self.vtable).SetIndexMode(@ptrCast(*const IConfigAsfWriter, self), bIndexFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_GetIndexMode(self: *const T, pbIndexFile: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter.VTable, self.vtable).GetIndexMode(@ptrCast(*const IConfigAsfWriter, self), pbIndexFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConfigAsfWriter2_Value = @import("../zig.zig").Guid.initString("7989ccaa-53f0-44f0-884a-f3b03f6ae066");
pub const IID_IConfigAsfWriter2 = &IID_IConfigAsfWriter2_Value;
pub const IConfigAsfWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IConfigAsfWriter.VTable,
        StreamNumFromPin: fn(
            self: *const IConfigAsfWriter2,
            pPin: ?*IPin,
            pwStreamNum: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParam: fn(
            self: *const IConfigAsfWriter2,
            dwParam: u32,
            dwParam1: u32,
            dwParam2: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParam: fn(
            self: *const IConfigAsfWriter2,
            dwParam: u32,
            pdwParam1: ?*u32,
            pdwParam2: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetMultiPassState: fn(
            self: *const IConfigAsfWriter2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConfigAsfWriter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter2_StreamNumFromPin(self: *const T, pPin: ?*IPin, pwStreamNum: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter2.VTable, self.vtable).StreamNumFromPin(@ptrCast(*const IConfigAsfWriter2, self), pPin, pwStreamNum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter2_SetParam(self: *const T, dwParam: u32, dwParam1: u32, dwParam2: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter2.VTable, self.vtable).SetParam(@ptrCast(*const IConfigAsfWriter2, self), dwParam, dwParam1, dwParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter2_GetParam(self: *const T, dwParam: u32, pdwParam1: ?*u32, pdwParam2: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter2.VTable, self.vtable).GetParam(@ptrCast(*const IConfigAsfWriter2, self), dwParam, pdwParam1, pdwParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter2_ResetMultiPassState(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConfigAsfWriter2.VTable, self.vtable).ResetMultiPassState(@ptrCast(*const IConfigAsfWriter2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STREAM_TYPE = enum(i32) {
    READ = 0,
    WRITE = 1,
    TRANSFORM = 2,
};
pub const STREAMTYPE_READ = STREAM_TYPE.READ;
pub const STREAMTYPE_WRITE = STREAM_TYPE.WRITE;
pub const STREAMTYPE_TRANSFORM = STREAM_TYPE.TRANSFORM;

pub const STREAM_STATE = enum(i32) {
    STOP = 0,
    RUN = 1,
};
pub const STREAMSTATE_STOP = STREAM_STATE.STOP;
pub const STREAMSTATE_RUN = STREAM_STATE.RUN;

pub const COMPLETION_STATUS_FLAGS = enum(i32) {
    NOUPDATEOK = 1,
    WAIT = 2,
    ABORT = 4,
};
pub const COMPSTAT_NOUPDATEOK = COMPLETION_STATUS_FLAGS.NOUPDATEOK;
pub const COMPSTAT_WAIT = COMPLETION_STATUS_FLAGS.WAIT;
pub const COMPSTAT_ABORT = COMPLETION_STATUS_FLAGS.ABORT;

pub const MMSSF_GET_INFORMATION_FLAGS = enum(u32) {
    HASCLOCK = 1,
    SUPPORTSEEK = 2,
    ASYNCHRONOUS = 4,
    _,
    pub fn initFlags(o: struct {
        HASCLOCK: u1 = 0,
        SUPPORTSEEK: u1 = 0,
        ASYNCHRONOUS: u1 = 0,
    }) MMSSF_GET_INFORMATION_FLAGS {
        return @intToEnum(MMSSF_GET_INFORMATION_FLAGS,
              (if (o.HASCLOCK == 1) @enumToInt(MMSSF_GET_INFORMATION_FLAGS.HASCLOCK) else 0)
            | (if (o.SUPPORTSEEK == 1) @enumToInt(MMSSF_GET_INFORMATION_FLAGS.SUPPORTSEEK) else 0)
            | (if (o.ASYNCHRONOUS == 1) @enumToInt(MMSSF_GET_INFORMATION_FLAGS.ASYNCHRONOUS) else 0)
        );
    }
};
pub const MMSSF_HASCLOCK = MMSSF_GET_INFORMATION_FLAGS.HASCLOCK;
pub const MMSSF_SUPPORTSEEK = MMSSF_GET_INFORMATION_FLAGS.SUPPORTSEEK;
pub const MMSSF_ASYNCHRONOUS = MMSSF_GET_INFORMATION_FLAGS.ASYNCHRONOUS;

pub const SSUPDATE_TYPE = enum(i32) {
    ASYNC = 1,
    CONTINUOUS = 2,
};
pub const SSUPDATE_ASYNC = SSUPDATE_TYPE.ASYNC;
pub const SSUPDATE_CONTINUOUS = SSUPDATE_TYPE.CONTINUOUS;

const IID_IMultiMediaStream_Value = @import("../zig.zig").Guid.initString("b502d1bc-9a57-11d0-8fde-00c04fd9189d");
pub const IID_IMultiMediaStream = &IID_IMultiMediaStream_Value;
pub const IMultiMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInformation: fn(
            self: *const IMultiMediaStream,
            pdwFlags: ?*MMSSF_GET_INFORMATION_FLAGS,
            pStreamType: ?*STREAM_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaStream: fn(
            self: *const IMultiMediaStream,
            idPurpose: ?*Guid,
            ppMediaStream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMediaStreams: fn(
            self: *const IMultiMediaStream,
            Index: i32,
            ppMediaStream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IMultiMediaStream,
            pCurrentState: ?*STREAM_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetState: fn(
            self: *const IMultiMediaStream,
            NewState: STREAM_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTime: fn(
            self: *const IMultiMediaStream,
            pCurrentTime: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuration: fn(
            self: *const IMultiMediaStream,
            pDuration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Seek: fn(
            self: *const IMultiMediaStream,
            SeekTime: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEndOfStreamEventHandle: fn(
            self: *const IMultiMediaStream,
            phEOS: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetInformation(self: *const T, pdwFlags: ?*MMSSF_GET_INFORMATION_FLAGS, pStreamType: ?*STREAM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiMediaStream.VTable, self.vtable).GetInformation(@ptrCast(*const IMultiMediaStream, self), pdwFlags, pStreamType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetMediaStream(self: *const T, idPurpose: ?*Guid, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiMediaStream.VTable, self.vtable).GetMediaStream(@ptrCast(*const IMultiMediaStream, self), idPurpose, ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_EnumMediaStreams(self: *const T, Index: i32, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiMediaStream.VTable, self.vtable).EnumMediaStreams(@ptrCast(*const IMultiMediaStream, self), Index, ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetState(self: *const T, pCurrentState: ?*STREAM_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiMediaStream.VTable, self.vtable).GetState(@ptrCast(*const IMultiMediaStream, self), pCurrentState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_SetState(self: *const T, NewState: STREAM_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiMediaStream.VTable, self.vtable).SetState(@ptrCast(*const IMultiMediaStream, self), NewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetTime(self: *const T, pCurrentTime: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiMediaStream.VTable, self.vtable).GetTime(@ptrCast(*const IMultiMediaStream, self), pCurrentTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetDuration(self: *const T, pDuration: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiMediaStream.VTable, self.vtable).GetDuration(@ptrCast(*const IMultiMediaStream, self), pDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_Seek(self: *const T, SeekTime: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiMediaStream.VTable, self.vtable).Seek(@ptrCast(*const IMultiMediaStream, self), SeekTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetEndOfStreamEventHandle(self: *const T, phEOS: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiMediaStream.VTable, self.vtable).GetEndOfStreamEventHandle(@ptrCast(*const IMultiMediaStream, self), phEOS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaStream_Value = @import("../zig.zig").Guid.initString("b502d1bd-9a57-11d0-8fde-00c04fd9189d");
pub const IID_IMediaStream = &IID_IMediaStream_Value;
pub const IMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMultiMediaStream: fn(
            self: *const IMediaStream,
            ppMultiMediaStream: ?*?*IMultiMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInformation: fn(
            self: *const IMediaStream,
            pPurposeId: ?*Guid,
            pType: ?*STREAM_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSameFormat: fn(
            self: *const IMediaStream,
            pStreamThatHasDesiredFormat: ?*IMediaStream,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateSample: fn(
            self: *const IMediaStream,
            dwFlags: u32,
            ppSample: ?*?*IStreamSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSharedSample: fn(
            self: *const IMediaStream,
            pExistingSample: ?*IStreamSample,
            dwFlags: u32,
            ppNewSample: ?*?*IStreamSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendEndOfStream: fn(
            self: *const IMediaStream,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_GetMultiMediaStream(self: *const T, ppMultiMediaStream: ?*?*IMultiMediaStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStream.VTable, self.vtable).GetMultiMediaStream(@ptrCast(*const IMediaStream, self), ppMultiMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_GetInformation(self: *const T, pPurposeId: ?*Guid, pType: ?*STREAM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStream.VTable, self.vtable).GetInformation(@ptrCast(*const IMediaStream, self), pPurposeId, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_SetSameFormat(self: *const T, pStreamThatHasDesiredFormat: ?*IMediaStream, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStream.VTable, self.vtable).SetSameFormat(@ptrCast(*const IMediaStream, self), pStreamThatHasDesiredFormat, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_AllocateSample(self: *const T, dwFlags: u32, ppSample: ?*?*IStreamSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStream.VTable, self.vtable).AllocateSample(@ptrCast(*const IMediaStream, self), dwFlags, ppSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_CreateSharedSample(self: *const T, pExistingSample: ?*IStreamSample, dwFlags: u32, ppNewSample: ?*?*IStreamSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStream.VTable, self.vtable).CreateSharedSample(@ptrCast(*const IMediaStream, self), pExistingSample, dwFlags, ppNewSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_SendEndOfStream(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStream.VTable, self.vtable).SendEndOfStream(@ptrCast(*const IMediaStream, self), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStreamSample_Value = @import("../zig.zig").Guid.initString("b502d1be-9a57-11d0-8fde-00c04fd9189d");
pub const IID_IStreamSample = &IID_IStreamSample_Value;
pub const IStreamSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMediaStream: fn(
            self: *const IStreamSample,
            ppMediaStream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSampleTimes: fn(
            self: *const IStreamSample,
            pStartTime: ?*i64,
            pEndTime: ?*i64,
            pCurrentTime: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSampleTimes: fn(
            self: *const IStreamSample,
            pStartTime: ?*const i64,
            pEndTime: ?*const i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const IStreamSample,
            dwFlags: u32,
            hEvent: ?HANDLE,
            pfnAPC: ?PAPCFUNC,
            dwAPCData: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompletionStatus: fn(
            self: *const IStreamSample,
            dwFlags: u32,
            dwMilliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_GetMediaStream(self: *const T, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamSample.VTable, self.vtable).GetMediaStream(@ptrCast(*const IStreamSample, self), ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_GetSampleTimes(self: *const T, pStartTime: ?*i64, pEndTime: ?*i64, pCurrentTime: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamSample.VTable, self.vtable).GetSampleTimes(@ptrCast(*const IStreamSample, self), pStartTime, pEndTime, pCurrentTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_SetSampleTimes(self: *const T, pStartTime: ?*const i64, pEndTime: ?*const i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamSample.VTable, self.vtable).SetSampleTimes(@ptrCast(*const IStreamSample, self), pStartTime, pEndTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_Update(self: *const T, dwFlags: u32, hEvent: ?HANDLE, pfnAPC: ?PAPCFUNC, dwAPCData: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamSample.VTable, self.vtable).Update(@ptrCast(*const IStreamSample, self), dwFlags, hEvent, pfnAPC, dwAPCData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_CompletionStatus(self: *const T, dwFlags: u32, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamSample.VTable, self.vtable).CompletionStatus(@ptrCast(*const IStreamSample, self), dwFlags, dwMilliseconds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DDSFF_FLAGS = enum(u32) {
    R = 1,
    _,
    pub fn initFlags(o: struct {
        R: u1 = 0,
    }) DDSFF_FLAGS {
        return @intToEnum(DDSFF_FLAGS,
              (if (o.R == 1) @enumToInt(DDSFF_FLAGS.R) else 0)
        );
    }
};
pub const DDSFF_PROGRESSIVERENDER = DDSFF_FLAGS.R;

const IID_IDirectDrawMediaStream_Value = @import("../zig.zig").Guid.initString("f4104fce-9a70-11d0-8fde-00c04fd9189d");
pub const IID_IDirectDrawMediaStream = &IID_IDirectDrawMediaStream_Value;
pub const IDirectDrawMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        GetFormat: fn(
            self: *const IDirectDrawMediaStream,
            pDDSDCurrent: ?*DDSURFACEDESC,
            ppDirectDrawPalette: ?*?*IDirectDrawPalette,
            pDDSDDesired: ?*DDSURFACEDESC,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: fn(
            self: *const IDirectDrawMediaStream,
            pDDSurfaceDesc: ?*const DDSURFACEDESC,
            pDirectDrawPalette: ?*IDirectDrawPalette,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectDraw: fn(
            self: *const IDirectDrawMediaStream,
            ppDirectDraw: ?*?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectDraw: fn(
            self: *const IDirectDrawMediaStream,
            pDirectDraw: ?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSample: fn(
            self: *const IDirectDrawMediaStream,
            pSurface: ?*IDirectDrawSurface,
            pRect: ?*const RECT,
            dwFlags: u32,
            ppSample: ?*?*IDirectDrawStreamSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimePerFrame: fn(
            self: *const IDirectDrawMediaStream,
            pFrameTime: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_GetFormat(self: *const T, pDDSDCurrent: ?*DDSURFACEDESC, ppDirectDrawPalette: ?*?*IDirectDrawPalette, pDDSDDesired: ?*DDSURFACEDESC, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawMediaStream.VTable, self.vtable).GetFormat(@ptrCast(*const IDirectDrawMediaStream, self), pDDSDCurrent, ppDirectDrawPalette, pDDSDDesired, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_SetFormat(self: *const T, pDDSurfaceDesc: ?*const DDSURFACEDESC, pDirectDrawPalette: ?*IDirectDrawPalette) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawMediaStream.VTable, self.vtable).SetFormat(@ptrCast(*const IDirectDrawMediaStream, self), pDDSurfaceDesc, pDirectDrawPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_GetDirectDraw(self: *const T, ppDirectDraw: ?*?*IDirectDraw) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawMediaStream.VTable, self.vtable).GetDirectDraw(@ptrCast(*const IDirectDrawMediaStream, self), ppDirectDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_SetDirectDraw(self: *const T, pDirectDraw: ?*IDirectDraw) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawMediaStream.VTable, self.vtable).SetDirectDraw(@ptrCast(*const IDirectDrawMediaStream, self), pDirectDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_CreateSample(self: *const T, pSurface: ?*IDirectDrawSurface, pRect: ?*const RECT, dwFlags: u32, ppSample: ?*?*IDirectDrawStreamSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawMediaStream.VTable, self.vtable).CreateSample(@ptrCast(*const IDirectDrawMediaStream, self), pSurface, pRect, dwFlags, ppSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_GetTimePerFrame(self: *const T, pFrameTime: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawMediaStream.VTable, self.vtable).GetTimePerFrame(@ptrCast(*const IDirectDrawMediaStream, self), pFrameTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectDrawStreamSample_Value = @import("../zig.zig").Guid.initString("f4104fcf-9a70-11d0-8fde-00c04fd9189d");
pub const IID_IDirectDrawStreamSample = &IID_IDirectDrawStreamSample_Value;
pub const IDirectDrawStreamSample = extern struct {
    pub const VTable = extern struct {
        base: IStreamSample.VTable,
        GetSurface: fn(
            self: *const IDirectDrawStreamSample,
            ppDirectDrawSurface: ?*?*IDirectDrawSurface,
            pRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRect: fn(
            self: *const IDirectDrawStreamSample,
            pRect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamSample.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawStreamSample_GetSurface(self: *const T, ppDirectDrawSurface: ?*?*IDirectDrawSurface, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawStreamSample.VTable, self.vtable).GetSurface(@ptrCast(*const IDirectDrawStreamSample, self), ppDirectDrawSurface, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawStreamSample_SetRect(self: *const T, pRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawStreamSample.VTable, self.vtable).SetRect(@ptrCast(*const IDirectDrawStreamSample, self), pRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioMediaStream_Value = @import("../zig.zig").Guid.initString("f7537560-a3be-11d0-8212-00c04fc32c45");
pub const IID_IAudioMediaStream = &IID_IAudioMediaStream_Value;
pub const IAudioMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        GetFormat: fn(
            self: *const IAudioMediaStream,
            pWaveFormatCurrent: ?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: fn(
            self: *const IAudioMediaStream,
            lpWaveFormat: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSample: fn(
            self: *const IAudioMediaStream,
            pAudioData: ?*IAudioData,
            dwFlags: u32,
            ppSample: ?*?*IAudioStreamSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaStream_GetFormat(self: *const T, pWaveFormatCurrent: ?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMediaStream.VTable, self.vtable).GetFormat(@ptrCast(*const IAudioMediaStream, self), pWaveFormatCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaStream_SetFormat(self: *const T, lpWaveFormat: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMediaStream.VTable, self.vtable).SetFormat(@ptrCast(*const IAudioMediaStream, self), lpWaveFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaStream_CreateSample(self: *const T, pAudioData: ?*IAudioData, dwFlags: u32, ppSample: ?*?*IAudioStreamSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMediaStream.VTable, self.vtable).CreateSample(@ptrCast(*const IAudioMediaStream, self), pAudioData, dwFlags, ppSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioStreamSample_Value = @import("../zig.zig").Guid.initString("345fee00-aba5-11d0-8212-00c04fc32c45");
pub const IID_IAudioStreamSample = &IID_IAudioStreamSample_Value;
pub const IAudioStreamSample = extern struct {
    pub const VTable = extern struct {
        base: IStreamSample.VTable,
        GetAudioData: fn(
            self: *const IAudioStreamSample,
            ppAudio: ?*?*IAudioData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamSample.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStreamSample_GetAudioData(self: *const T, ppAudio: ?*?*IAudioData) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioStreamSample.VTable, self.vtable).GetAudioData(@ptrCast(*const IAudioStreamSample, self), ppAudio);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMemoryData_Value = @import("../zig.zig").Guid.initString("327fc560-af60-11d0-8212-00c04fc32c45");
pub const IID_IMemoryData = &IID_IMemoryData_Value;
pub const IMemoryData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBuffer: fn(
            self: *const IMemoryData,
            cbSize: u32,
            pbData: ?*u8,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfo: fn(
            self: *const IMemoryData,
            pdwLength: ?*u32,
            ppbData: ?*?*u8,
            pcbActualData: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActual: fn(
            self: *const IMemoryData,
            cbDataValid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemoryData_SetBuffer(self: *const T, cbSize: u32, pbData: ?*u8, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemoryData.VTable, self.vtable).SetBuffer(@ptrCast(*const IMemoryData, self), cbSize, pbData, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemoryData_GetInfo(self: *const T, pdwLength: ?*u32, ppbData: ?*?*u8, pcbActualData: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemoryData.VTable, self.vtable).GetInfo(@ptrCast(*const IMemoryData, self), pdwLength, ppbData, pcbActualData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemoryData_SetActual(self: *const T, cbDataValid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMemoryData.VTable, self.vtable).SetActual(@ptrCast(*const IMemoryData, self), cbDataValid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioData_Value = @import("../zig.zig").Guid.initString("54c719c0-af60-11d0-8212-00c04fc32c45");
pub const IID_IAudioData = &IID_IAudioData_Value;
pub const IAudioData = extern struct {
    pub const VTable = extern struct {
        base: IMemoryData.VTable,
        GetFormat: fn(
            self: *const IAudioData,
            pWaveFormatCurrent: ?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: fn(
            self: *const IAudioData,
            lpWaveFormat: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMemoryData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioData_GetFormat(self: *const T, pWaveFormatCurrent: ?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioData.VTable, self.vtable).GetFormat(@ptrCast(*const IAudioData, self), pWaveFormatCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioData_SetFormat(self: *const T, lpWaveFormat: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioData.VTable, self.vtable).SetFormat(@ptrCast(*const IAudioData, self), lpWaveFormat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMMSF_MMS_INIT_FLAGS = enum(u32) {
    D = 1,
    _,
    pub fn initFlags(o: struct {
        D: u1 = 0,
    }) AMMSF_MMS_INIT_FLAGS {
        return @intToEnum(AMMSF_MMS_INIT_FLAGS,
              (if (o.D == 1) @enumToInt(AMMSF_MMS_INIT_FLAGS.D) else 0)
        );
    }
};
pub const AMMSF_NOGRAPHTHREAD = AMMSF_MMS_INIT_FLAGS.D;

pub const AMMSF_MS_FLAGS = enum(u32) {
    ADDDEFAULTRENDERER = 1,
    CREATEPEER = 2,
    STOPIFNOSAMPLES = 4,
    NOSTALL = 8,
    _,
    pub fn initFlags(o: struct {
        ADDDEFAULTRENDERER: u1 = 0,
        CREATEPEER: u1 = 0,
        STOPIFNOSAMPLES: u1 = 0,
        NOSTALL: u1 = 0,
    }) AMMSF_MS_FLAGS {
        return @intToEnum(AMMSF_MS_FLAGS,
              (if (o.ADDDEFAULTRENDERER == 1) @enumToInt(AMMSF_MS_FLAGS.ADDDEFAULTRENDERER) else 0)
            | (if (o.CREATEPEER == 1) @enumToInt(AMMSF_MS_FLAGS.CREATEPEER) else 0)
            | (if (o.STOPIFNOSAMPLES == 1) @enumToInt(AMMSF_MS_FLAGS.STOPIFNOSAMPLES) else 0)
            | (if (o.NOSTALL == 1) @enumToInt(AMMSF_MS_FLAGS.NOSTALL) else 0)
        );
    }
};
pub const AMMSF_ADDDEFAULTRENDERER = AMMSF_MS_FLAGS.ADDDEFAULTRENDERER;
pub const AMMSF_CREATEPEER = AMMSF_MS_FLAGS.CREATEPEER;
pub const AMMSF_STOPIFNOSAMPLES = AMMSF_MS_FLAGS.STOPIFNOSAMPLES;
pub const AMMSF_NOSTALL = AMMSF_MS_FLAGS.NOSTALL;

pub const AMMSF_RENDER_FLAGS = enum(u32) {
    RENDERTYPEMASK = 3,
    RENDERTOEXISTING = 0,
    RENDERALLSTREAMS = 1,
    NORENDER = 2,
    NOCLOCK = 4,
    RUN = 8,
    _,
    pub fn initFlags(o: struct {
        RENDERTYPEMASK: u1 = 0,
        RENDERTOEXISTING: u1 = 0,
        RENDERALLSTREAMS: u1 = 0,
        NORENDER: u1 = 0,
        NOCLOCK: u1 = 0,
        RUN: u1 = 0,
    }) AMMSF_RENDER_FLAGS {
        return @intToEnum(AMMSF_RENDER_FLAGS,
              (if (o.RENDERTYPEMASK == 1) @enumToInt(AMMSF_RENDER_FLAGS.RENDERTYPEMASK) else 0)
            | (if (o.RENDERTOEXISTING == 1) @enumToInt(AMMSF_RENDER_FLAGS.RENDERTOEXISTING) else 0)
            | (if (o.RENDERALLSTREAMS == 1) @enumToInt(AMMSF_RENDER_FLAGS.RENDERALLSTREAMS) else 0)
            | (if (o.NORENDER == 1) @enumToInt(AMMSF_RENDER_FLAGS.NORENDER) else 0)
            | (if (o.NOCLOCK == 1) @enumToInt(AMMSF_RENDER_FLAGS.NOCLOCK) else 0)
            | (if (o.RUN == 1) @enumToInt(AMMSF_RENDER_FLAGS.RUN) else 0)
        );
    }
};
pub const AMMSF_RENDERTYPEMASK = AMMSF_RENDER_FLAGS.RENDERTYPEMASK;
pub const AMMSF_RENDERTOEXISTING = AMMSF_RENDER_FLAGS.RENDERTOEXISTING;
pub const AMMSF_RENDERALLSTREAMS = AMMSF_RENDER_FLAGS.RENDERALLSTREAMS;
pub const AMMSF_NORENDER = AMMSF_RENDER_FLAGS.NORENDER;
pub const AMMSF_NOCLOCK = AMMSF_RENDER_FLAGS.NOCLOCK;
pub const AMMSF_RUN = AMMSF_RENDER_FLAGS.RUN;

pub const OUTPUT_STATE = enum(u32) {
    Disabled = 0,
    ReadData = 1,
    RenderData = 2,
    _,
    pub fn initFlags(o: struct {
        Disabled: u1 = 0,
        ReadData: u1 = 0,
        RenderData: u1 = 0,
    }) OUTPUT_STATE {
        return @intToEnum(OUTPUT_STATE,
              (if (o.Disabled == 1) @enumToInt(OUTPUT_STATE.Disabled) else 0)
            | (if (o.ReadData == 1) @enumToInt(OUTPUT_STATE.ReadData) else 0)
            | (if (o.RenderData == 1) @enumToInt(OUTPUT_STATE.RenderData) else 0)
        );
    }
};
pub const Disabled = OUTPUT_STATE.Disabled;
pub const ReadData = OUTPUT_STATE.ReadData;
pub const RenderData = OUTPUT_STATE.RenderData;

const IID_IAMMultiMediaStream_Value = @import("../zig.zig").Guid.initString("bebe595c-9a6f-11d0-8fde-00c04fd9189d");
pub const IID_IAMMultiMediaStream = &IID_IAMMultiMediaStream_Value;
pub const IAMMultiMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMultiMediaStream.VTable,
        Initialize: fn(
            self: *const IAMMultiMediaStream,
            StreamType: STREAM_TYPE,
            dwFlags: AMMSF_MMS_INIT_FLAGS,
            pFilterGraph: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterGraph: fn(
            self: *const IAMMultiMediaStream,
            ppGraphBuilder: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilter: fn(
            self: *const IAMMultiMediaStream,
            ppFilter: ?*?*IMediaStreamFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMediaStream: fn(
            self: *const IAMMultiMediaStream,
            pStreamObject: ?*IUnknown,
            PurposeId: ?*const Guid,
            dwFlags: AMMSF_MS_FLAGS,
            ppNewStream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenFile: fn(
            self: *const IAMMultiMediaStream,
            pszFileName: ?[*:0]const u16,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenMoniker: fn(
            self: *const IAMMultiMediaStream,
            pCtx: ?*IBindCtx,
            pMoniker: ?*IMoniker,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Render: fn(
            self: *const IAMMultiMediaStream,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMultiMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_Initialize(self: *const T, StreamType: STREAM_TYPE, dwFlags: AMMSF_MMS_INIT_FLAGS, pFilterGraph: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMultiMediaStream.VTable, self.vtable).Initialize(@ptrCast(*const IAMMultiMediaStream, self), StreamType, dwFlags, pFilterGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_GetFilterGraph(self: *const T, ppGraphBuilder: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMultiMediaStream.VTable, self.vtable).GetFilterGraph(@ptrCast(*const IAMMultiMediaStream, self), ppGraphBuilder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_GetFilter(self: *const T, ppFilter: ?*?*IMediaStreamFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMultiMediaStream.VTable, self.vtable).GetFilter(@ptrCast(*const IAMMultiMediaStream, self), ppFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_AddMediaStream(self: *const T, pStreamObject: ?*IUnknown, PurposeId: ?*const Guid, dwFlags: AMMSF_MS_FLAGS, ppNewStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMultiMediaStream.VTable, self.vtable).AddMediaStream(@ptrCast(*const IAMMultiMediaStream, self), pStreamObject, PurposeId, dwFlags, ppNewStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_OpenFile(self: *const T, pszFileName: ?[*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMultiMediaStream.VTable, self.vtable).OpenFile(@ptrCast(*const IAMMultiMediaStream, self), pszFileName, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_OpenMoniker(self: *const T, pCtx: ?*IBindCtx, pMoniker: ?*IMoniker, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMultiMediaStream.VTable, self.vtable).OpenMoniker(@ptrCast(*const IAMMultiMediaStream, self), pCtx, pMoniker, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_Render(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMultiMediaStream.VTable, self.vtable).Render(@ptrCast(*const IAMMultiMediaStream, self), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMMediaStream_Value = @import("../zig.zig").Guid.initString("bebe595d-9a6f-11d0-8fde-00c04fd9189d");
pub const IID_IAMMediaStream = &IID_IAMMediaStream_Value;
pub const IAMMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        Initialize: fn(
            self: *const IAMMediaStream,
            pSourceObject: ?*IUnknown,
            dwFlags: u32,
            PurposeId: ?*Guid,
            StreamType: STREAM_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetState: fn(
            self: *const IAMMediaStream,
            State: FILTER_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinAMMultiMediaStream: fn(
            self: *const IAMMediaStream,
            pAMMultiMediaStream: ?*IAMMultiMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinFilter: fn(
            self: *const IAMMediaStream,
            pMediaStreamFilter: ?*IMediaStreamFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinFilterGraph: fn(
            self: *const IAMMediaStream,
            pFilterGraph: ?*IFilterGraph,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_Initialize(self: *const T, pSourceObject: ?*IUnknown, dwFlags: u32, PurposeId: ?*Guid, StreamType: STREAM_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaStream.VTable, self.vtable).Initialize(@ptrCast(*const IAMMediaStream, self), pSourceObject, dwFlags, PurposeId, StreamType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_SetState(self: *const T, State: FILTER_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaStream.VTable, self.vtable).SetState(@ptrCast(*const IAMMediaStream, self), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_JoinAMMultiMediaStream(self: *const T, pAMMultiMediaStream: ?*IAMMultiMediaStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaStream.VTable, self.vtable).JoinAMMultiMediaStream(@ptrCast(*const IAMMediaStream, self), pAMMultiMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_JoinFilter(self: *const T, pMediaStreamFilter: ?*IMediaStreamFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaStream.VTable, self.vtable).JoinFilter(@ptrCast(*const IAMMediaStream, self), pMediaStreamFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_JoinFilterGraph(self: *const T, pFilterGraph: ?*IFilterGraph) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaStream.VTable, self.vtable).JoinFilterGraph(@ptrCast(*const IAMMediaStream, self), pFilterGraph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaStreamFilter_Value = @import("../zig.zig").Guid.initString("bebe595e-9a6f-11d0-8fde-00c04fd9189d");
pub const IID_IMediaStreamFilter = &IID_IMediaStreamFilter_Value;
pub const IMediaStreamFilter = extern struct {
    pub const VTable = extern struct {
        base: IBaseFilter.VTable,
        AddMediaStream: fn(
            self: *const IMediaStreamFilter,
            pAMMediaStream: ?*IAMMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaStream: fn(
            self: *const IMediaStreamFilter,
            idPurpose: ?*Guid,
            ppMediaStream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMediaStreams: fn(
            self: *const IMediaStreamFilter,
            Index: i32,
            ppMediaStream: ?*?*IMediaStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupportSeeking: fn(
            self: *const IMediaStreamFilter,
            bRenderer: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReferenceTimeToStreamTime: fn(
            self: *const IMediaStreamFilter,
            pTime: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentStreamTime: fn(
            self: *const IMediaStreamFilter,
            pCurrentStreamTime: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitUntil: fn(
            self: *const IMediaStreamFilter,
            WaitStreamTime: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IMediaStreamFilter,
            bCancelEOS: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOfStream: fn(
            self: *const IMediaStreamFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBaseFilter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_AddMediaStream(self: *const T, pAMMediaStream: ?*IAMMediaStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStreamFilter.VTable, self.vtable).AddMediaStream(@ptrCast(*const IMediaStreamFilter, self), pAMMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_GetMediaStream(self: *const T, idPurpose: ?*Guid, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStreamFilter.VTable, self.vtable).GetMediaStream(@ptrCast(*const IMediaStreamFilter, self), idPurpose, ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_EnumMediaStreams(self: *const T, Index: i32, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStreamFilter.VTable, self.vtable).EnumMediaStreams(@ptrCast(*const IMediaStreamFilter, self), Index, ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_SupportSeeking(self: *const T, bRenderer: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStreamFilter.VTable, self.vtable).SupportSeeking(@ptrCast(*const IMediaStreamFilter, self), bRenderer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_ReferenceTimeToStreamTime(self: *const T, pTime: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStreamFilter.VTable, self.vtable).ReferenceTimeToStreamTime(@ptrCast(*const IMediaStreamFilter, self), pTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_GetCurrentStreamTime(self: *const T, pCurrentStreamTime: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStreamFilter.VTable, self.vtable).GetCurrentStreamTime(@ptrCast(*const IMediaStreamFilter, self), pCurrentStreamTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_WaitUntil(self: *const T, WaitStreamTime: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStreamFilter.VTable, self.vtable).WaitUntil(@ptrCast(*const IMediaStreamFilter, self), WaitStreamTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_Flush(self: *const T, bCancelEOS: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStreamFilter.VTable, self.vtable).Flush(@ptrCast(*const IMediaStreamFilter, self), bCancelEOS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_EndOfStream(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaStreamFilter.VTable, self.vtable).EndOfStream(@ptrCast(*const IMediaStreamFilter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectDrawMediaSampleAllocator_Value = @import("../zig.zig").Guid.initString("ab6b4afc-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IDirectDrawMediaSampleAllocator = &IID_IDirectDrawMediaSampleAllocator_Value;
pub const IDirectDrawMediaSampleAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectDraw: fn(
            self: *const IDirectDrawMediaSampleAllocator,
            ppDirectDraw: ?*?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaSampleAllocator_GetDirectDraw(self: *const T, ppDirectDraw: ?*?*IDirectDraw) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawMediaSampleAllocator.VTable, self.vtable).GetDirectDraw(@ptrCast(*const IDirectDrawMediaSampleAllocator, self), ppDirectDraw);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectDrawMediaSample_Value = @import("../zig.zig").Guid.initString("ab6b4afe-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IDirectDrawMediaSample = &IID_IDirectDrawMediaSample_Value;
pub const IDirectDrawMediaSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSurfaceAndReleaseLock: fn(
            self: *const IDirectDrawMediaSample,
            ppDirectDrawSurface: ?*?*IDirectDrawSurface,
            pRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockMediaSamplePointer: fn(
            self: *const IDirectDrawMediaSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaSample_GetSurfaceAndReleaseLock(self: *const T, ppDirectDrawSurface: ?*?*IDirectDrawSurface, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawMediaSample.VTable, self.vtable).GetSurfaceAndReleaseLock(@ptrCast(*const IDirectDrawMediaSample, self), ppDirectDrawSurface, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaSample_LockMediaSamplePointer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawMediaSample.VTable, self.vtable).LockMediaSamplePointer(@ptrCast(*const IDirectDrawMediaSample, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMMediaTypeStream_Value = @import("../zig.zig").Guid.initString("ab6b4afa-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IAMMediaTypeStream = &IID_IAMMediaTypeStream_Value;
pub const IAMMediaTypeStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        GetFormat: fn(
            self: *const IAMMediaTypeStream,
            pMediaType: ?*AM_MEDIA_TYPE,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: fn(
            self: *const IAMMediaTypeStream,
            pMediaType: ?*AM_MEDIA_TYPE,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSample: fn(
            self: *const IAMMediaTypeStream,
            lSampleSize: i32,
            pbBuffer: ?*u8,
            dwFlags: u32,
            pUnkOuter: ?*IUnknown,
            ppAMMediaTypeSample: ?*?*IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamAllocatorRequirements: fn(
            self: *const IAMMediaTypeStream,
            pProps: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamAllocatorRequirements: fn(
            self: *const IAMMediaTypeStream,
            pProps: ?*ALLOCATOR_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_GetFormat(self: *const T, pMediaType: ?*AM_MEDIA_TYPE, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeStream.VTable, self.vtable).GetFormat(@ptrCast(*const IAMMediaTypeStream, self), pMediaType, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_SetFormat(self: *const T, pMediaType: ?*AM_MEDIA_TYPE, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeStream.VTable, self.vtable).SetFormat(@ptrCast(*const IAMMediaTypeStream, self), pMediaType, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_CreateSample(self: *const T, lSampleSize: i32, pbBuffer: ?*u8, dwFlags: u32, pUnkOuter: ?*IUnknown, ppAMMediaTypeSample: ?*?*IAMMediaTypeSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeStream.VTable, self.vtable).CreateSample(@ptrCast(*const IAMMediaTypeStream, self), lSampleSize, pbBuffer, dwFlags, pUnkOuter, ppAMMediaTypeSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_GetStreamAllocatorRequirements(self: *const T, pProps: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeStream.VTable, self.vtable).GetStreamAllocatorRequirements(@ptrCast(*const IAMMediaTypeStream, self), pProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_SetStreamAllocatorRequirements(self: *const T, pProps: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeStream.VTable, self.vtable).SetStreamAllocatorRequirements(@ptrCast(*const IAMMediaTypeStream, self), pProps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMMediaTypeSample_Value = @import("../zig.zig").Guid.initString("ab6b4afb-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IAMMediaTypeSample = &IID_IAMMediaTypeSample_Value;
pub const IAMMediaTypeSample = extern struct {
    pub const VTable = extern struct {
        base: IStreamSample.VTable,
        SetPointer: fn(
            self: *const IAMMediaTypeSample,
            pBuffer: [*:0]u8,
            lSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPointer: fn(
            self: *const IAMMediaTypeSample,
            ppBuffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetTime: fn(
            self: *const IAMMediaTypeSample,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTime: fn(
            self: *const IAMMediaTypeSample,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSyncPoint: fn(
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncPoint: fn(
            self: *const IAMMediaTypeSample,
            bIsSyncPoint: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPreroll: fn(
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreroll: fn(
            self: *const IAMMediaTypeSample,
            bIsPreroll: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualDataLength: fn(
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        SetActualDataLength: fn(
            self: *const IAMMediaTypeSample,
            __MIDL__IAMMediaTypeSample0000: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaType: fn(
            self: *const IAMMediaTypeSample,
            ppMediaType: ?*?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaType: fn(
            self: *const IAMMediaTypeSample,
            pMediaType: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDiscontinuity: fn(
            self: *const IAMMediaTypeSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDiscontinuity: fn(
            self: *const IAMMediaTypeSample,
            bDiscontinuity: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaTime: fn(
            self: *const IAMMediaTypeSample,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaTime: fn(
            self: *const IAMMediaTypeSample,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamSample.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetPointer(self: *const T, pBuffer: [*:0]u8, lSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).SetPointer(@ptrCast(*const IAMMediaTypeSample, self), pBuffer, lSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetPointer(self: *const T, ppBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).GetPointer(@ptrCast(*const IAMMediaTypeSample, self), ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetSize(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).GetSize(@ptrCast(*const IAMMediaTypeSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).GetTime(@ptrCast(*const IAMMediaTypeSample, self), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).SetTime(@ptrCast(*const IAMMediaTypeSample, self), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_IsSyncPoint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).IsSyncPoint(@ptrCast(*const IAMMediaTypeSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetSyncPoint(self: *const T, bIsSyncPoint: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).SetSyncPoint(@ptrCast(*const IAMMediaTypeSample, self), bIsSyncPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_IsPreroll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).IsPreroll(@ptrCast(*const IAMMediaTypeSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetPreroll(self: *const T, bIsPreroll: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).SetPreroll(@ptrCast(*const IAMMediaTypeSample, self), bIsPreroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetActualDataLength(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).GetActualDataLength(@ptrCast(*const IAMMediaTypeSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetActualDataLength(self: *const T, __MIDL__IAMMediaTypeSample0000: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).SetActualDataLength(@ptrCast(*const IAMMediaTypeSample, self), __MIDL__IAMMediaTypeSample0000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetMediaType(self: *const T, ppMediaType: ?*?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).GetMediaType(@ptrCast(*const IAMMediaTypeSample, self), ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetMediaType(self: *const T, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).SetMediaType(@ptrCast(*const IAMMediaTypeSample, self), pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_IsDiscontinuity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).IsDiscontinuity(@ptrCast(*const IAMMediaTypeSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetDiscontinuity(self: *const T, bDiscontinuity: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).SetDiscontinuity(@ptrCast(*const IAMMediaTypeSample, self), bDiscontinuity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetMediaTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).GetMediaTime(@ptrCast(*const IAMMediaTypeSample, self), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetMediaTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMMediaTypeSample.VTable, self.vtable).SetMediaTime(@ptrCast(*const IAMMediaTypeSample, self), pTimeStart, pTimeEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IDirectDrawVideo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSwitches: fn(
            self: *const IDirectDrawVideo,
            pSwitches: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSwitches: fn(
            self: *const IDirectDrawVideo,
            Switches: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaps: fn(
            self: *const IDirectDrawVideo,
            pCaps: ?*DDCAPS_DX7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmulatedCaps: fn(
            self: *const IDirectDrawVideo,
            pCaps: ?*DDCAPS_DX7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurfaceDesc: fn(
            self: *const IDirectDrawVideo,
            pSurfaceDesc: ?*DDSURFACEDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFourCCCodes: fn(
            self: *const IDirectDrawVideo,
            pCount: ?*u32,
            pCodes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectDraw: fn(
            self: *const IDirectDrawVideo,
            pDirectDraw: ?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectDraw: fn(
            self: *const IDirectDrawVideo,
            ppDirectDraw: ?*?*IDirectDraw,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurfaceType: fn(
            self: *const IDirectDrawVideo,
            pSurfaceType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefault: fn(
            self: *const IDirectDrawVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UseScanLine: fn(
            self: *const IDirectDrawVideo,
            UseScanLine: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanUseScanLine: fn(
            self: *const IDirectDrawVideo,
            UseScanLine: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UseOverlayStretch: fn(
            self: *const IDirectDrawVideo,
            UseOverlayStretch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanUseOverlayStretch: fn(
            self: *const IDirectDrawVideo,
            UseOverlayStretch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UseWhenFullScreen: fn(
            self: *const IDirectDrawVideo,
            UseWhenFullScreen: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WillUseFullScreen: fn(
            self: *const IDirectDrawVideo,
            UseWhenFullScreen: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetSwitches(self: *const T, pSwitches: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).GetSwitches(@ptrCast(*const IDirectDrawVideo, self), pSwitches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_SetSwitches(self: *const T, Switches: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).SetSwitches(@ptrCast(*const IDirectDrawVideo, self), Switches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetCaps(self: *const T, pCaps: ?*DDCAPS_DX7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).GetCaps(@ptrCast(*const IDirectDrawVideo, self), pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetEmulatedCaps(self: *const T, pCaps: ?*DDCAPS_DX7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).GetEmulatedCaps(@ptrCast(*const IDirectDrawVideo, self), pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetSurfaceDesc(self: *const T, pSurfaceDesc: ?*DDSURFACEDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).GetSurfaceDesc(@ptrCast(*const IDirectDrawVideo, self), pSurfaceDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetFourCCCodes(self: *const T, pCount: ?*u32, pCodes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).GetFourCCCodes(@ptrCast(*const IDirectDrawVideo, self), pCount, pCodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_SetDirectDraw(self: *const T, pDirectDraw: ?*IDirectDraw) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).SetDirectDraw(@ptrCast(*const IDirectDrawVideo, self), pDirectDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetDirectDraw(self: *const T, ppDirectDraw: ?*?*IDirectDraw) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).GetDirectDraw(@ptrCast(*const IDirectDrawVideo, self), ppDirectDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetSurfaceType(self: *const T, pSurfaceType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).GetSurfaceType(@ptrCast(*const IDirectDrawVideo, self), pSurfaceType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_SetDefault(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).SetDefault(@ptrCast(*const IDirectDrawVideo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_UseScanLine(self: *const T, UseScanLine: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).UseScanLine(@ptrCast(*const IDirectDrawVideo, self), UseScanLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_CanUseScanLine(self: *const T, UseScanLine: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).CanUseScanLine(@ptrCast(*const IDirectDrawVideo, self), UseScanLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_UseOverlayStretch(self: *const T, UseOverlayStretch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).UseOverlayStretch(@ptrCast(*const IDirectDrawVideo, self), UseOverlayStretch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_CanUseOverlayStretch(self: *const T, UseOverlayStretch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).CanUseOverlayStretch(@ptrCast(*const IDirectDrawVideo, self), UseOverlayStretch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_UseWhenFullScreen(self: *const T, UseWhenFullScreen: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).UseWhenFullScreen(@ptrCast(*const IDirectDrawVideo, self), UseWhenFullScreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_WillUseFullScreen(self: *const T, UseWhenFullScreen: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectDrawVideo.VTable, self.vtable).WillUseFullScreen(@ptrCast(*const IDirectDrawVideo, self), UseWhenFullScreen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IQualProp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FramesDroppedInRenderer: fn(
            self: *const IQualProp,
            pcFrames: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FramesDrawn: fn(
            self: *const IQualProp,
            pcFramesDrawn: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgFrameRate: fn(
            self: *const IQualProp,
            piAvgFrameRate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Jitter: fn(
            self: *const IQualProp,
            iJitter: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgSyncOffset: fn(
            self: *const IQualProp,
            piAvg: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevSyncOffset: fn(
            self: *const IQualProp,
            piDev: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_FramesDroppedInRenderer(self: *const T, pcFrames: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQualProp.VTable, self.vtable).get_FramesDroppedInRenderer(@ptrCast(*const IQualProp, self), pcFrames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_FramesDrawn(self: *const T, pcFramesDrawn: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQualProp.VTable, self.vtable).get_FramesDrawn(@ptrCast(*const IQualProp, self), pcFramesDrawn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_AvgFrameRate(self: *const T, piAvgFrameRate: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQualProp.VTable, self.vtable).get_AvgFrameRate(@ptrCast(*const IQualProp, self), piAvgFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_Jitter(self: *const T, iJitter: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQualProp.VTable, self.vtable).get_Jitter(@ptrCast(*const IQualProp, self), iJitter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_AvgSyncOffset(self: *const T, piAvg: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQualProp.VTable, self.vtable).get_AvgSyncOffset(@ptrCast(*const IQualProp, self), piAvg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_DevSyncOffset(self: *const T, piDev: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQualProp.VTable, self.vtable).get_DevSyncOffset(@ptrCast(*const IQualProp, self), piDev);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IFullScreenVideo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CountModes: fn(
            self: *const IFullScreenVideo,
            pModes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModeInfo: fn(
            self: *const IFullScreenVideo,
            Mode: i32,
            pWidth: ?*i32,
            pHeight: ?*i32,
            pDepth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentMode: fn(
            self: *const IFullScreenVideo,
            pMode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsModeAvailable: fn(
            self: *const IFullScreenVideo,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsModeEnabled: fn(
            self: *const IFullScreenVideo,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnabled: fn(
            self: *const IFullScreenVideo,
            Mode: i32,
            bEnabled: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipFactor: fn(
            self: *const IFullScreenVideo,
            pClipFactor: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClipFactor: fn(
            self: *const IFullScreenVideo,
            ClipFactor: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMessageDrain: fn(
            self: *const IFullScreenVideo,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageDrain: fn(
            self: *const IFullScreenVideo,
            hwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMonitor: fn(
            self: *const IFullScreenVideo,
            Monitor: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonitor: fn(
            self: *const IFullScreenVideo,
            Monitor: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HideOnDeactivate: fn(
            self: *const IFullScreenVideo,
            Hide: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsHideOnDeactivate: fn(
            self: *const IFullScreenVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaption: fn(
            self: *const IFullScreenVideo,
            strCaption: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaption: fn(
            self: *const IFullScreenVideo,
            pstrCaption: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefault: fn(
            self: *const IFullScreenVideo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_CountModes(self: *const T, pModes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).CountModes(@ptrCast(*const IFullScreenVideo, self), pModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetModeInfo(self: *const T, Mode: i32, pWidth: ?*i32, pHeight: ?*i32, pDepth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).GetModeInfo(@ptrCast(*const IFullScreenVideo, self), Mode, pWidth, pHeight, pDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetCurrentMode(self: *const T, pMode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).GetCurrentMode(@ptrCast(*const IFullScreenVideo, self), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_IsModeAvailable(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).IsModeAvailable(@ptrCast(*const IFullScreenVideo, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_IsModeEnabled(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).IsModeEnabled(@ptrCast(*const IFullScreenVideo, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetEnabled(self: *const T, Mode: i32, bEnabled: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).SetEnabled(@ptrCast(*const IFullScreenVideo, self), Mode, bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetClipFactor(self: *const T, pClipFactor: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).GetClipFactor(@ptrCast(*const IFullScreenVideo, self), pClipFactor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetClipFactor(self: *const T, ClipFactor: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).SetClipFactor(@ptrCast(*const IFullScreenVideo, self), ClipFactor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetMessageDrain(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).SetMessageDrain(@ptrCast(*const IFullScreenVideo, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetMessageDrain(self: *const T, hwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).GetMessageDrain(@ptrCast(*const IFullScreenVideo, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetMonitor(self: *const T, Monitor: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).SetMonitor(@ptrCast(*const IFullScreenVideo, self), Monitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetMonitor(self: *const T, Monitor: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).GetMonitor(@ptrCast(*const IFullScreenVideo, self), Monitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_HideOnDeactivate(self: *const T, Hide: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).HideOnDeactivate(@ptrCast(*const IFullScreenVideo, self), Hide);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_IsHideOnDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).IsHideOnDeactivate(@ptrCast(*const IFullScreenVideo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetCaption(self: *const T, strCaption: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).SetCaption(@ptrCast(*const IFullScreenVideo, self), strCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetCaption(self: *const T, pstrCaption: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).GetCaption(@ptrCast(*const IFullScreenVideo, self), pstrCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetDefault(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideo.VTable, self.vtable).SetDefault(@ptrCast(*const IFullScreenVideo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IFullScreenVideoEx = extern struct {
    pub const VTable = extern struct {
        base: IFullScreenVideo.VTable,
        SetAcceleratorTable: fn(
            self: *const IFullScreenVideoEx,
            hwnd: ?HWND,
            hAccel: ?HACCEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAcceleratorTable: fn(
            self: *const IFullScreenVideoEx,
            phwnd: ?*?HWND,
            phAccel: ?*?HACCEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeepPixelAspectRatio: fn(
            self: *const IFullScreenVideoEx,
            KeepAspect: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsKeepPixelAspectRatio: fn(
            self: *const IFullScreenVideoEx,
            pKeepAspect: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFullScreenVideo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideoEx_SetAcceleratorTable(self: *const T, hwnd: ?HWND, hAccel: ?HACCEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideoEx.VTable, self.vtable).SetAcceleratorTable(@ptrCast(*const IFullScreenVideoEx, self), hwnd, hAccel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideoEx_GetAcceleratorTable(self: *const T, phwnd: ?*?HWND, phAccel: ?*?HACCEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideoEx.VTable, self.vtable).GetAcceleratorTable(@ptrCast(*const IFullScreenVideoEx, self), phwnd, phAccel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideoEx_KeepPixelAspectRatio(self: *const T, KeepAspect: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideoEx.VTable, self.vtable).KeepPixelAspectRatio(@ptrCast(*const IFullScreenVideoEx, self), KeepAspect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideoEx_IsKeepPixelAspectRatio(self: *const T, pKeepAspect: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFullScreenVideoEx.VTable, self.vtable).IsKeepPixelAspectRatio(@ptrCast(*const IFullScreenVideoEx, self), pKeepAspect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IBaseVideoMixer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLeadPin: fn(
            self: *const IBaseVideoMixer,
            iPin: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeadPin: fn(
            self: *const IBaseVideoMixer,
            piPin: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputPinCount: fn(
            self: *const IBaseVideoMixer,
            piPinCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUsingClock: fn(
            self: *const IBaseVideoMixer,
            pbValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUsingClock: fn(
            self: *const IBaseVideoMixer,
            bValue: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClockPeriod: fn(
            self: *const IBaseVideoMixer,
            pbValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClockPeriod: fn(
            self: *const IBaseVideoMixer,
            bValue: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_SetLeadPin(self: *const T, iPin: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseVideoMixer.VTable, self.vtable).SetLeadPin(@ptrCast(*const IBaseVideoMixer, self), iPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_GetLeadPin(self: *const T, piPin: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseVideoMixer.VTable, self.vtable).GetLeadPin(@ptrCast(*const IBaseVideoMixer, self), piPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_GetInputPinCount(self: *const T, piPinCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseVideoMixer.VTable, self.vtable).GetInputPinCount(@ptrCast(*const IBaseVideoMixer, self), piPinCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_IsUsingClock(self: *const T, pbValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseVideoMixer.VTable, self.vtable).IsUsingClock(@ptrCast(*const IBaseVideoMixer, self), pbValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_SetUsingClock(self: *const T, bValue: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseVideoMixer.VTable, self.vtable).SetUsingClock(@ptrCast(*const IBaseVideoMixer, self), bValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_GetClockPeriod(self: *const T, pbValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseVideoMixer.VTable, self.vtable).GetClockPeriod(@ptrCast(*const IBaseVideoMixer, self), pbValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_SetClockPeriod(self: *const T, bValue: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBaseVideoMixer.VTable, self.vtable).SetClockPeriod(@ptrCast(*const IBaseVideoMixer, self), bValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TRUECOLORINFO = extern struct {
    dwBitMasks: [3]u32,
    bmiColors: [256]RGBQUAD,
};

pub const VIDEOINFOHEADER = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    bmiHeader: BITMAPINFOHEADER,
};

pub const VIDEOINFO = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    bmiHeader: BITMAPINFOHEADER,
    Anonymous: extern union {
        bmiColors: [256]RGBQUAD,
        dwBitMasks: [3]u32,
        TrueColorInfo: TRUECOLORINFO,
    },
};

pub const MPEG1VIDEOINFO = extern struct {
    hdr: VIDEOINFOHEADER,
    dwStartTimeCode: u32,
    cbSequenceHeader: u32,
    bSequenceHeader: [1]u8,
};

pub const ANALOGVIDEOINFO = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwActiveWidth: u32,
    dwActiveHeight: u32,
    AvgTimePerFrame: i64,
};

pub const AM_PROPERTY_FRAMESTEP = enum(i32) {
    STEP = 1,
    CANCEL = 2,
    CANSTEP = 3,
    CANSTEPMULTIPLE = 4,
};
pub const AM_PROPERTY_FRAMESTEP_STEP = AM_PROPERTY_FRAMESTEP.STEP;
pub const AM_PROPERTY_FRAMESTEP_CANCEL = AM_PROPERTY_FRAMESTEP.CANCEL;
pub const AM_PROPERTY_FRAMESTEP_CANSTEP = AM_PROPERTY_FRAMESTEP.CANSTEP;
pub const AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE = AM_PROPERTY_FRAMESTEP.CANSTEPMULTIPLE;

pub const AM_FRAMESTEP_STEP = extern struct {
    dwFramesToStep: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDMOWrapperFilter_Value = @import("../zig.zig").Guid.initString("52d6f586-9f0f-4824-8fc8-e32ca04930c2");
pub const IID_IDMOWrapperFilter = &IID_IDMOWrapperFilter_Value;
pub const IDMOWrapperFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IDMOWrapperFilter,
            clsidDMO: ?*const Guid,
            catDMO: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDMOWrapperFilter_Init(self: *const T, clsidDMO: ?*const Guid, catDMO: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDMOWrapperFilter.VTable, self.vtable).Init(@ptrCast(*const IDMOWrapperFilter, self), clsidDMO, catDMO);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMixerOCXNotify_Value = @import("../zig.zig").Guid.initString("81a3bd31-dee1-11d1-8508-00a0c91f9ca0");
pub const IID_IMixerOCXNotify = &IID_IMixerOCXNotify_Value;
pub const IMixerOCXNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnInvalidateRect: fn(
            self: *const IMixerOCXNotify,
            lpcRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStatusChange: fn(
            self: *const IMixerOCXNotify,
            ulStatusFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDataChange: fn(
            self: *const IMixerOCXNotify,
            ulDataFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCXNotify_OnInvalidateRect(self: *const T, lpcRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCXNotify.VTable, self.vtable).OnInvalidateRect(@ptrCast(*const IMixerOCXNotify, self), lpcRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCXNotify_OnStatusChange(self: *const T, ulStatusFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCXNotify.VTable, self.vtable).OnStatusChange(@ptrCast(*const IMixerOCXNotify, self), ulStatusFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCXNotify_OnDataChange(self: *const T, ulDataFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCXNotify.VTable, self.vtable).OnDataChange(@ptrCast(*const IMixerOCXNotify, self), ulDataFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMixerOCX_Value = @import("../zig.zig").Guid.initString("81a3bd32-dee1-11d1-8508-00a0c91f9ca0");
pub const IID_IMixerOCX = &IID_IMixerOCX_Value;
pub const IMixerOCX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDisplayChange: fn(
            self: *const IMixerOCX,
            ulBitsPerPixel: u32,
            ulScreenWidth: u32,
            ulScreenHeight: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatio: fn(
            self: *const IMixerOCX,
            pdwPictAspectRatioX: ?*u32,
            pdwPictAspectRatioY: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoSize: fn(
            self: *const IMixerOCX,
            pdwVideoWidth: ?*u32,
            pdwVideoHeight: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const IMixerOCX,
            pdwStatus: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDraw: fn(
            self: *const IMixerOCX,
            hdcDraw: ?HDC,
            prcDraw: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDrawRegion: fn(
            self: *const IMixerOCX,
            lpptTopLeftSC: ?*POINT,
            prcDrawCC: ?*RECT,
            lprcClip: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IMixerOCX,
            pmdns: ?*IMixerOCXNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnAdvise: fn(
            self: *const IMixerOCX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_OnDisplayChange(self: *const T, ulBitsPerPixel: u32, ulScreenWidth: u32, ulScreenHeight: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCX.VTable, self.vtable).OnDisplayChange(@ptrCast(*const IMixerOCX, self), ulBitsPerPixel, ulScreenWidth, ulScreenHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_GetAspectRatio(self: *const T, pdwPictAspectRatioX: ?*u32, pdwPictAspectRatioY: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCX.VTable, self.vtable).GetAspectRatio(@ptrCast(*const IMixerOCX, self), pdwPictAspectRatioX, pdwPictAspectRatioY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_GetVideoSize(self: *const T, pdwVideoWidth: ?*u32, pdwVideoHeight: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCX.VTable, self.vtable).GetVideoSize(@ptrCast(*const IMixerOCX, self), pdwVideoWidth, pdwVideoHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_GetStatus(self: *const T, pdwStatus: ?*?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCX.VTable, self.vtable).GetStatus(@ptrCast(*const IMixerOCX, self), pdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_OnDraw(self: *const T, hdcDraw: ?HDC, prcDraw: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCX.VTable, self.vtable).OnDraw(@ptrCast(*const IMixerOCX, self), hdcDraw, prcDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_SetDrawRegion(self: *const T, lpptTopLeftSC: ?*POINT, prcDrawCC: ?*RECT, lprcClip: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCX.VTable, self.vtable).SetDrawRegion(@ptrCast(*const IMixerOCX, self), lpptTopLeftSC, prcDrawCC, lprcClip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_Advise(self: *const T, pmdns: ?*IMixerOCXNotify) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCX.VTable, self.vtable).Advise(@ptrCast(*const IMixerOCX, self), pmdns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_UnAdvise(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerOCX.VTable, self.vtable).UnAdvise(@ptrCast(*const IMixerOCX, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_ASPECT_RATIO_MODE = enum(i32) {
    STRETCHED = 0,
    LETTER_BOX = 1,
    CROP = 2,
    STRETCHED_AS_PRIMARY = 3,
};
pub const AM_ARMODE_STRETCHED = AM_ASPECT_RATIO_MODE.STRETCHED;
pub const AM_ARMODE_LETTER_BOX = AM_ASPECT_RATIO_MODE.LETTER_BOX;
pub const AM_ARMODE_CROP = AM_ASPECT_RATIO_MODE.CROP;
pub const AM_ARMODE_STRETCHED_AS_PRIMARY = AM_ASPECT_RATIO_MODE.STRETCHED_AS_PRIMARY;

// TODO: this type is limited to platform 'windows5.0'
pub const IMixerPinConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRelativePosition: fn(
            self: *const IMixerPinConfig,
            dwLeft: u32,
            dwTop: u32,
            dwRight: u32,
            dwBottom: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelativePosition: fn(
            self: *const IMixerPinConfig,
            pdwLeft: ?*u32,
            pdwTop: ?*u32,
            pdwRight: ?*u32,
            pdwBottom: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZOrder: fn(
            self: *const IMixerPinConfig,
            dwZOrder: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZOrder: fn(
            self: *const IMixerPinConfig,
            pdwZOrder: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColorKey: fn(
            self: *const IMixerPinConfig,
            pColorKey: ?*COLORKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColorKey: fn(
            self: *const IMixerPinConfig,
            pColorKey: ?*COLORKEY,
            pColor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBlendingParameter: fn(
            self: *const IMixerPinConfig,
            dwBlendingParameter: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBlendingParameter: fn(
            self: *const IMixerPinConfig,
            pdwBlendingParameter: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: fn(
            self: *const IMixerPinConfig,
            amAspectRatioMode: AM_ASPECT_RATIO_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatioMode: fn(
            self: *const IMixerPinConfig,
            pamAspectRatioMode: ?*AM_ASPECT_RATIO_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamTransparent: fn(
            self: *const IMixerPinConfig,
            bStreamTransparent: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamTransparent: fn(
            self: *const IMixerPinConfig,
            pbStreamTransparent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetRelativePosition(self: *const T, dwLeft: u32, dwTop: u32, dwRight: u32, dwBottom: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).SetRelativePosition(@ptrCast(*const IMixerPinConfig, self), dwLeft, dwTop, dwRight, dwBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetRelativePosition(self: *const T, pdwLeft: ?*u32, pdwTop: ?*u32, pdwRight: ?*u32, pdwBottom: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).GetRelativePosition(@ptrCast(*const IMixerPinConfig, self), pdwLeft, pdwTop, pdwRight, pdwBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetZOrder(self: *const T, dwZOrder: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).SetZOrder(@ptrCast(*const IMixerPinConfig, self), dwZOrder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetZOrder(self: *const T, pdwZOrder: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).GetZOrder(@ptrCast(*const IMixerPinConfig, self), pdwZOrder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetColorKey(self: *const T, pColorKey: ?*COLORKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).SetColorKey(@ptrCast(*const IMixerPinConfig, self), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetColorKey(self: *const T, pColorKey: ?*COLORKEY, pColor: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).GetColorKey(@ptrCast(*const IMixerPinConfig, self), pColorKey, pColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetBlendingParameter(self: *const T, dwBlendingParameter: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).SetBlendingParameter(@ptrCast(*const IMixerPinConfig, self), dwBlendingParameter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetBlendingParameter(self: *const T, pdwBlendingParameter: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).GetBlendingParameter(@ptrCast(*const IMixerPinConfig, self), pdwBlendingParameter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetAspectRatioMode(self: *const T, amAspectRatioMode: AM_ASPECT_RATIO_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).SetAspectRatioMode(@ptrCast(*const IMixerPinConfig, self), amAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetAspectRatioMode(self: *const T, pamAspectRatioMode: ?*AM_ASPECT_RATIO_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).GetAspectRatioMode(@ptrCast(*const IMixerPinConfig, self), pamAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetStreamTransparent(self: *const T, bStreamTransparent: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).SetStreamTransparent(@ptrCast(*const IMixerPinConfig, self), bStreamTransparent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetStreamTransparent(self: *const T, pbStreamTransparent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig.VTable, self.vtable).GetStreamTransparent(@ptrCast(*const IMixerPinConfig, self), pbStreamTransparent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMixerPinConfig2 = extern struct {
    pub const VTable = extern struct {
        base: IMixerPinConfig.VTable,
        SetOverlaySurfaceColorControls: fn(
            self: *const IMixerPinConfig2,
            pColorControl: ?*DDCOLORCONTROL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlaySurfaceColorControls: fn(
            self: *const IMixerPinConfig2,
            pColorControl: ?*DDCOLORCONTROL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMixerPinConfig.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig2_SetOverlaySurfaceColorControls(self: *const T, pColorControl: ?*DDCOLORCONTROL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig2.VTable, self.vtable).SetOverlaySurfaceColorControls(@ptrCast(*const IMixerPinConfig2, self), pColorControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig2_GetOverlaySurfaceColorControls(self: *const T, pColorControl: ?*DDCOLORCONTROL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMixerPinConfig2.VTable, self.vtable).GetOverlaySurfaceColorControls(@ptrCast(*const IMixerPinConfig2, self), pColorControl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_MPEGSTREAMTYPE = extern struct {
    dwStreamId: u32,
    dwReserved: u32,
    mt: AM_MEDIA_TYPE,
    bFormat: [1]u8,
};

pub const AM_MPEGSYSTEMTYPE = extern struct {
    dwBitRate: u32,
    cStreams: u32,
    Streams: [1]AM_MPEGSTREAMTYPE,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMpegAudioDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyDivider: fn(
            self: *const IMpegAudioDecoder,
            pDivider: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyDivider: fn(
            self: *const IMpegAudioDecoder,
            Divider: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DecoderAccuracy: fn(
            self: *const IMpegAudioDecoder,
            pAccuracy: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DecoderAccuracy: fn(
            self: *const IMpegAudioDecoder,
            Accuracy: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Stereo: fn(
            self: *const IMpegAudioDecoder,
            pStereo: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Stereo: fn(
            self: *const IMpegAudioDecoder,
            Stereo: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DecoderWordSize: fn(
            self: *const IMpegAudioDecoder,
            pWordSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DecoderWordSize: fn(
            self: *const IMpegAudioDecoder,
            WordSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IntegerDecode: fn(
            self: *const IMpegAudioDecoder,
            pIntDecode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IntegerDecode: fn(
            self: *const IMpegAudioDecoder,
            IntDecode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DualMode: fn(
            self: *const IMpegAudioDecoder,
            pIntDecode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DualMode: fn(
            self: *const IMpegAudioDecoder,
            IntDecode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFormat: fn(
            self: *const IMpegAudioDecoder,
            lpFmt: ?*MPEG1WAVEFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_FrequencyDivider(self: *const T, pDivider: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).get_FrequencyDivider(@ptrCast(*const IMpegAudioDecoder, self), pDivider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_FrequencyDivider(self: *const T, Divider: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).put_FrequencyDivider(@ptrCast(*const IMpegAudioDecoder, self), Divider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_DecoderAccuracy(self: *const T, pAccuracy: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).get_DecoderAccuracy(@ptrCast(*const IMpegAudioDecoder, self), pAccuracy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_DecoderAccuracy(self: *const T, Accuracy: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).put_DecoderAccuracy(@ptrCast(*const IMpegAudioDecoder, self), Accuracy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_Stereo(self: *const T, pStereo: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).get_Stereo(@ptrCast(*const IMpegAudioDecoder, self), pStereo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_Stereo(self: *const T, Stereo: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).put_Stereo(@ptrCast(*const IMpegAudioDecoder, self), Stereo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_DecoderWordSize(self: *const T, pWordSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).get_DecoderWordSize(@ptrCast(*const IMpegAudioDecoder, self), pWordSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_DecoderWordSize(self: *const T, WordSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).put_DecoderWordSize(@ptrCast(*const IMpegAudioDecoder, self), WordSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_IntegerDecode(self: *const T, pIntDecode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).get_IntegerDecode(@ptrCast(*const IMpegAudioDecoder, self), pIntDecode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_IntegerDecode(self: *const T, IntDecode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).put_IntegerDecode(@ptrCast(*const IMpegAudioDecoder, self), IntDecode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_DualMode(self: *const T, pIntDecode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).get_DualMode(@ptrCast(*const IMpegAudioDecoder, self), pIntDecode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_DualMode(self: *const T, IntDecode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).put_DualMode(@ptrCast(*const IMpegAudioDecoder, self), IntDecode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_AudioFormat(self: *const T, lpFmt: ?*MPEG1WAVEFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpegAudioDecoder.VTable, self.vtable).get_AudioFormat(@ptrCast(*const IMpegAudioDecoder, self), lpFmt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9PresentationFlags = enum(i32) {
    SyncPoint = 1,
    Preroll = 2,
    Discontinuity = 4,
    TimeValid = 8,
    SrcDstRectsValid = 16,
};
pub const VMR9Sample_SyncPoint = VMR9PresentationFlags.SyncPoint;
pub const VMR9Sample_Preroll = VMR9PresentationFlags.Preroll;
pub const VMR9Sample_Discontinuity = VMR9PresentationFlags.Discontinuity;
pub const VMR9Sample_TimeValid = VMR9PresentationFlags.TimeValid;
pub const VMR9Sample_SrcDstRectsValid = VMR9PresentationFlags.SrcDstRectsValid;

pub const VMR9PresentationInfo = extern struct {
    dwFlags: u32,
    lpSurf: ?*IDirect3DSurface9,
    rtStart: i64,
    rtEnd: i64,
    szAspectRatio: SIZE,
    rcSrc: RECT,
    rcDst: RECT,
    dwReserved1: u32,
    dwReserved2: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenter9_Value = @import("../zig.zig").Guid.initString("69188c61-12a3-40f0-8ffc-342e7b433fd7");
pub const IID_IVMRImagePresenter9 = &IID_IVMRImagePresenter9_Value;
pub const IVMRImagePresenter9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartPresenting: fn(
            self: *const IVMRImagePresenter9,
            dwUserID: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopPresenting: fn(
            self: *const IVMRImagePresenter9,
            dwUserID: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PresentImage: fn(
            self: *const IVMRImagePresenter9,
            dwUserID: usize,
            lpPresInfo: ?*VMR9PresentationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter9_StartPresenting(self: *const T, dwUserID: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenter9.VTable, self.vtable).StartPresenting(@ptrCast(*const IVMRImagePresenter9, self), dwUserID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter9_StopPresenting(self: *const T, dwUserID: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenter9.VTable, self.vtable).StopPresenting(@ptrCast(*const IVMRImagePresenter9, self), dwUserID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter9_PresentImage(self: *const T, dwUserID: usize, lpPresInfo: ?*VMR9PresentationInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenter9.VTable, self.vtable).PresentImage(@ptrCast(*const IVMRImagePresenter9, self), dwUserID, lpPresInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9SurfaceAllocationFlags = enum(i32) {
    @"3DRenderTarget" = 1,
    DXVATarget = 2,
    TextureSurface = 4,
    OffscreenSurface = 8,
    RGBDynamicSwitch = 16,
    UsageReserved = 224,
    UsageMask = 255,
};
pub const VMR9AllocFlag_3DRenderTarget = VMR9SurfaceAllocationFlags.@"3DRenderTarget";
pub const VMR9AllocFlag_DXVATarget = VMR9SurfaceAllocationFlags.DXVATarget;
pub const VMR9AllocFlag_TextureSurface = VMR9SurfaceAllocationFlags.TextureSurface;
pub const VMR9AllocFlag_OffscreenSurface = VMR9SurfaceAllocationFlags.OffscreenSurface;
pub const VMR9AllocFlag_RGBDynamicSwitch = VMR9SurfaceAllocationFlags.RGBDynamicSwitch;
pub const VMR9AllocFlag_UsageReserved = VMR9SurfaceAllocationFlags.UsageReserved;
pub const VMR9AllocFlag_UsageMask = VMR9SurfaceAllocationFlags.UsageMask;

pub const VMR9AllocationInfo = extern struct {
    dwFlags: u32,
    dwWidth: u32,
    dwHeight: u32,
    Format: D3DFORMAT,
    Pool: D3DPOOL,
    MinBuffers: u32,
    szAspectRatio: SIZE,
    szNativeSize: SIZE,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocator9_Value = @import("../zig.zig").Guid.initString("8d5148ea-3f5d-46cf-9df1-d1b896eedb1f");
pub const IID_IVMRSurfaceAllocator9 = &IID_IVMRSurfaceAllocator9_Value;
pub const IVMRSurfaceAllocator9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeDevice: fn(
            self: *const IVMRSurfaceAllocator9,
            dwUserID: usize,
            lpAllocInfo: ?*VMR9AllocationInfo,
            lpNumBuffers: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateDevice: fn(
            self: *const IVMRSurfaceAllocator9,
            dwID: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurface: fn(
            self: *const IVMRSurfaceAllocator9,
            dwUserID: usize,
            SurfaceIndex: u32,
            SurfaceFlags: u32,
            lplpSurface: ?*?*IDirect3DSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseNotify: fn(
            self: *const IVMRSurfaceAllocator9,
            lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator9_InitializeDevice(self: *const T, dwUserID: usize, lpAllocInfo: ?*VMR9AllocationInfo, lpNumBuffers: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocator9.VTable, self.vtable).InitializeDevice(@ptrCast(*const IVMRSurfaceAllocator9, self), dwUserID, lpAllocInfo, lpNumBuffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator9_TerminateDevice(self: *const T, dwID: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocator9.VTable, self.vtable).TerminateDevice(@ptrCast(*const IVMRSurfaceAllocator9, self), dwID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator9_GetSurface(self: *const T, dwUserID: usize, SurfaceIndex: u32, SurfaceFlags: u32, lplpSurface: ?*?*IDirect3DSurface9) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocator9.VTable, self.vtable).GetSurface(@ptrCast(*const IVMRSurfaceAllocator9, self), dwUserID, SurfaceIndex, SurfaceFlags, lplpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator9_AdviseNotify(self: *const T, lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify9) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocator9.VTable, self.vtable).AdviseNotify(@ptrCast(*const IVMRSurfaceAllocator9, self), lpIVMRSurfAllocNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocatorEx9_Value = @import("../zig.zig").Guid.initString("6de9a68a-a928-4522-bf57-655ae3866456");
pub const IID_IVMRSurfaceAllocatorEx9 = &IID_IVMRSurfaceAllocatorEx9_Value;
pub const IVMRSurfaceAllocatorEx9 = extern struct {
    pub const VTable = extern struct {
        base: IVMRSurfaceAllocator9.VTable,
        GetSurfaceEx: fn(
            self: *const IVMRSurfaceAllocatorEx9,
            dwUserID: usize,
            SurfaceIndex: u32,
            SurfaceFlags: u32,
            lplpSurface: ?*?*IDirect3DSurface9,
            lprcDst: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVMRSurfaceAllocator9.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorEx9_GetSurfaceEx(self: *const T, dwUserID: usize, SurfaceIndex: u32, SurfaceFlags: u32, lplpSurface: ?*?*IDirect3DSurface9, lprcDst: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorEx9.VTable, self.vtable).GetSurfaceEx(@ptrCast(*const IVMRSurfaceAllocatorEx9, self), dwUserID, SurfaceIndex, SurfaceFlags, lplpSurface, lprcDst);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocatorNotify9_Value = @import("../zig.zig").Guid.initString("dca3f5df-bb3a-4d03-bd81-84614bfbfa0c");
pub const IID_IVMRSurfaceAllocatorNotify9 = &IID_IVMRSurfaceAllocatorNotify9_Value;
pub const IVMRSurfaceAllocatorNotify9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSurfaceAllocator: fn(
            self: *const IVMRSurfaceAllocatorNotify9,
            dwUserID: usize,
            lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetD3DDevice: fn(
            self: *const IVMRSurfaceAllocatorNotify9,
            lpD3DDevice: ?*IDirect3DDevice9,
            hMonitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeD3DDevice: fn(
            self: *const IVMRSurfaceAllocatorNotify9,
            lpD3DDevice: ?*IDirect3DDevice9,
            hMonitor: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateSurfaceHelper: fn(
            self: *const IVMRSurfaceAllocatorNotify9,
            lpAllocInfo: ?*VMR9AllocationInfo,
            lpNumBuffers: ?*u32,
            lplpSurface: ?*?*IDirect3DSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEvent: fn(
            self: *const IVMRSurfaceAllocatorNotify9,
            EventCode: i32,
            Param1: isize,
            Param2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(self: *const T, dwUserID: usize, lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator9) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify9.VTable, self.vtable).AdviseSurfaceAllocator(@ptrCast(*const IVMRSurfaceAllocatorNotify9, self), dwUserID, lpIVRMSurfaceAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_SetD3DDevice(self: *const T, lpD3DDevice: ?*IDirect3DDevice9, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify9.VTable, self.vtable).SetD3DDevice(@ptrCast(*const IVMRSurfaceAllocatorNotify9, self), lpD3DDevice, hMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_ChangeD3DDevice(self: *const T, lpD3DDevice: ?*IDirect3DDevice9, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify9.VTable, self.vtable).ChangeD3DDevice(@ptrCast(*const IVMRSurfaceAllocatorNotify9, self), lpD3DDevice, hMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(self: *const T, lpAllocInfo: ?*VMR9AllocationInfo, lpNumBuffers: ?*u32, lplpSurface: ?*?*IDirect3DSurface9) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify9.VTable, self.vtable).AllocateSurfaceHelper(@ptrCast(*const IVMRSurfaceAllocatorNotify9, self), lpAllocInfo, lpNumBuffers, lplpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_NotifyEvent(self: *const T, EventCode: i32, Param1: isize, Param2: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurfaceAllocatorNotify9.VTable, self.vtable).NotifyEvent(@ptrCast(*const IVMRSurfaceAllocatorNotify9, self), EventCode, Param1, Param2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9AspectRatioMode = enum(i32) {
    None = 0,
    LetterBox = 1,
};
pub const VMR9ARMode_None = VMR9AspectRatioMode.None;
pub const VMR9ARMode_LetterBox = VMR9AspectRatioMode.LetterBox;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRWindowlessControl9_Value = @import("../zig.zig").Guid.initString("8f537d09-f85e-4414-b23b-502e54c79927");
pub const IID_IVMRWindowlessControl9 = &IID_IVMRWindowlessControl9_Value;
pub const IVMRWindowlessControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNativeVideoSize: fn(
            self: *const IVMRWindowlessControl9,
            lpWidth: ?*i32,
            lpHeight: ?*i32,
            lpARWidth: ?*i32,
            lpARHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinIdealVideoSize: fn(
            self: *const IVMRWindowlessControl9,
            lpWidth: ?*i32,
            lpHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxIdealVideoSize: fn(
            self: *const IVMRWindowlessControl9,
            lpWidth: ?*i32,
            lpHeight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoPosition: fn(
            self: *const IVMRWindowlessControl9,
            lpSRCRect: ?*const RECT,
            lpDSTRect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPosition: fn(
            self: *const IVMRWindowlessControl9,
            lpSRCRect: ?*RECT,
            lpDSTRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatioMode: fn(
            self: *const IVMRWindowlessControl9,
            lpAspectRatioMode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: fn(
            self: *const IVMRWindowlessControl9,
            AspectRatioMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoClippingWindow: fn(
            self: *const IVMRWindowlessControl9,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RepaintVideo: fn(
            self: *const IVMRWindowlessControl9,
            hwnd: ?HWND,
            hdc: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayModeChanged: fn(
            self: *const IVMRWindowlessControl9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentImage: fn(
            self: *const IVMRWindowlessControl9,
            lpDib: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderColor: fn(
            self: *const IVMRWindowlessControl9,
            Clr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBorderColor: fn(
            self: *const IVMRWindowlessControl9,
            lpClr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetNativeVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32, lpARWidth: ?*i32, lpARHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).GetNativeVideoSize(@ptrCast(*const IVMRWindowlessControl9, self), lpWidth, lpHeight, lpARWidth, lpARHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetMinIdealVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).GetMinIdealVideoSize(@ptrCast(*const IVMRWindowlessControl9, self), lpWidth, lpHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetMaxIdealVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).GetMaxIdealVideoSize(@ptrCast(*const IVMRWindowlessControl9, self), lpWidth, lpHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_SetVideoPosition(self: *const T, lpSRCRect: ?*const RECT, lpDSTRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).SetVideoPosition(@ptrCast(*const IVMRWindowlessControl9, self), lpSRCRect, lpDSTRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetVideoPosition(self: *const T, lpSRCRect: ?*RECT, lpDSTRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).GetVideoPosition(@ptrCast(*const IVMRWindowlessControl9, self), lpSRCRect, lpDSTRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetAspectRatioMode(self: *const T, lpAspectRatioMode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).GetAspectRatioMode(@ptrCast(*const IVMRWindowlessControl9, self), lpAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_SetAspectRatioMode(self: *const T, AspectRatioMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).SetAspectRatioMode(@ptrCast(*const IVMRWindowlessControl9, self), AspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_SetVideoClippingWindow(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).SetVideoClippingWindow(@ptrCast(*const IVMRWindowlessControl9, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_RepaintVideo(self: *const T, hwnd: ?HWND, hdc: ?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).RepaintVideo(@ptrCast(*const IVMRWindowlessControl9, self), hwnd, hdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_DisplayModeChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).DisplayModeChanged(@ptrCast(*const IVMRWindowlessControl9, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetCurrentImage(self: *const T, lpDib: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).GetCurrentImage(@ptrCast(*const IVMRWindowlessControl9, self), lpDib);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_SetBorderColor(self: *const T, Clr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).SetBorderColor(@ptrCast(*const IVMRWindowlessControl9, self), Clr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetBorderColor(self: *const T, lpClr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRWindowlessControl9.VTable, self.vtable).GetBorderColor(@ptrCast(*const IVMRWindowlessControl9, self), lpClr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9MixerPrefs = enum(i32) {
    NoDecimation = 1,
    DecimateOutput = 2,
    ARAdjustXorY = 4,
    NonSquareMixing = 8,
    DecimateMask = 15,
    BiLinearFiltering = 16,
    PointFiltering = 32,
    AnisotropicFiltering = 64,
    PyramidalQuadFiltering = 128,
    GaussianQuadFiltering = 256,
    FilteringReserved = 3584,
    FilteringMask = 4080,
    RenderTargetRGB = 4096,
    RenderTargetYUV = 8192,
    RenderTargetReserved = 1032192,
    RenderTargetMask = 1044480,
    DynamicSwitchToBOB = 1048576,
    DynamicDecimateBy2 = 2097152,
    DynamicReserved = 12582912,
    DynamicMask = 15728640,
};
pub const MixerPref9_NoDecimation = VMR9MixerPrefs.NoDecimation;
pub const MixerPref9_DecimateOutput = VMR9MixerPrefs.DecimateOutput;
pub const MixerPref9_ARAdjustXorY = VMR9MixerPrefs.ARAdjustXorY;
pub const MixerPref9_NonSquareMixing = VMR9MixerPrefs.NonSquareMixing;
pub const MixerPref9_DecimateMask = VMR9MixerPrefs.DecimateMask;
pub const MixerPref9_BiLinearFiltering = VMR9MixerPrefs.BiLinearFiltering;
pub const MixerPref9_PointFiltering = VMR9MixerPrefs.PointFiltering;
pub const MixerPref9_AnisotropicFiltering = VMR9MixerPrefs.AnisotropicFiltering;
pub const MixerPref9_PyramidalQuadFiltering = VMR9MixerPrefs.PyramidalQuadFiltering;
pub const MixerPref9_GaussianQuadFiltering = VMR9MixerPrefs.GaussianQuadFiltering;
pub const MixerPref9_FilteringReserved = VMR9MixerPrefs.FilteringReserved;
pub const MixerPref9_FilteringMask = VMR9MixerPrefs.FilteringMask;
pub const MixerPref9_RenderTargetRGB = VMR9MixerPrefs.RenderTargetRGB;
pub const MixerPref9_RenderTargetYUV = VMR9MixerPrefs.RenderTargetYUV;
pub const MixerPref9_RenderTargetReserved = VMR9MixerPrefs.RenderTargetReserved;
pub const MixerPref9_RenderTargetMask = VMR9MixerPrefs.RenderTargetMask;
pub const MixerPref9_DynamicSwitchToBOB = VMR9MixerPrefs.DynamicSwitchToBOB;
pub const MixerPref9_DynamicDecimateBy2 = VMR9MixerPrefs.DynamicDecimateBy2;
pub const MixerPref9_DynamicReserved = VMR9MixerPrefs.DynamicReserved;
pub const MixerPref9_DynamicMask = VMR9MixerPrefs.DynamicMask;

pub const VMR9NormalizedRect = extern struct {
    left: f32,
    top: f32,
    right: f32,
    bottom: f32,
};

pub const VMR9ProcAmpControlFlags = enum(i32) {
    Brightness = 1,
    Contrast = 2,
    Hue = 4,
    Saturation = 8,
    Mask = 15,
};
pub const ProcAmpControl9_Brightness = VMR9ProcAmpControlFlags.Brightness;
pub const ProcAmpControl9_Contrast = VMR9ProcAmpControlFlags.Contrast;
pub const ProcAmpControl9_Hue = VMR9ProcAmpControlFlags.Hue;
pub const ProcAmpControl9_Saturation = VMR9ProcAmpControlFlags.Saturation;
pub const ProcAmpControl9_Mask = VMR9ProcAmpControlFlags.Mask;

pub const VMR9ProcAmpControl = extern struct {
    dwSize: u32,
    dwFlags: u32,
    Brightness: f32,
    Contrast: f32,
    Hue: f32,
    Saturation: f32,
};

pub const VMR9ProcAmpControlRange = extern struct {
    dwSize: u32,
    dwProperty: VMR9ProcAmpControlFlags,
    MinValue: f32,
    MaxValue: f32,
    DefaultValue: f32,
    StepSize: f32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerControl9_Value = @import("../zig.zig").Guid.initString("1a777eaa-47c8-4930-b2c9-8fee1c1b0f3b");
pub const IID_IVMRMixerControl9 = &IID_IVMRMixerControl9_Value;
pub const IVMRMixerControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlpha: fn(
            self: *const IVMRMixerControl9,
            dwStreamID: u32,
            Alpha: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlpha: fn(
            self: *const IVMRMixerControl9,
            dwStreamID: u32,
            pAlpha: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetZOrder: fn(
            self: *const IVMRMixerControl9,
            dwStreamID: u32,
            dwZ: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZOrder: fn(
            self: *const IVMRMixerControl9,
            dwStreamID: u32,
            pZ: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputRect: fn(
            self: *const IVMRMixerControl9,
            dwStreamID: u32,
            pRect: ?*const VMR9NormalizedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputRect: fn(
            self: *const IVMRMixerControl9,
            dwStreamID: u32,
            pRect: ?*VMR9NormalizedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundClr: fn(
            self: *const IVMRMixerControl9,
            ClrBkg: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundClr: fn(
            self: *const IVMRMixerControl9,
            lpClrBkg: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMixingPrefs: fn(
            self: *const IVMRMixerControl9,
            dwMixerPrefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMixingPrefs: fn(
            self: *const IVMRMixerControl9,
            pdwMixerPrefs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcAmpControl: fn(
            self: *const IVMRMixerControl9,
            dwStreamID: u32,
            lpClrControl: ?*VMR9ProcAmpControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcAmpControl: fn(
            self: *const IVMRMixerControl9,
            dwStreamID: u32,
            lpClrControl: ?*VMR9ProcAmpControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcAmpControlRange: fn(
            self: *const IVMRMixerControl9,
            dwStreamID: u32,
            lpClrControl: ?*VMR9ProcAmpControlRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetAlpha(self: *const T, dwStreamID: u32, Alpha: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).SetAlpha(@ptrCast(*const IVMRMixerControl9, self), dwStreamID, Alpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetAlpha(self: *const T, dwStreamID: u32, pAlpha: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).GetAlpha(@ptrCast(*const IVMRMixerControl9, self), dwStreamID, pAlpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetZOrder(self: *const T, dwStreamID: u32, dwZ: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).SetZOrder(@ptrCast(*const IVMRMixerControl9, self), dwStreamID, dwZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetZOrder(self: *const T, dwStreamID: u32, pZ: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).GetZOrder(@ptrCast(*const IVMRMixerControl9, self), dwStreamID, pZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetOutputRect(self: *const T, dwStreamID: u32, pRect: ?*const VMR9NormalizedRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).SetOutputRect(@ptrCast(*const IVMRMixerControl9, self), dwStreamID, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetOutputRect(self: *const T, dwStreamID: u32, pRect: ?*VMR9NormalizedRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).GetOutputRect(@ptrCast(*const IVMRMixerControl9, self), dwStreamID, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetBackgroundClr(self: *const T, ClrBkg: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).SetBackgroundClr(@ptrCast(*const IVMRMixerControl9, self), ClrBkg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetBackgroundClr(self: *const T, lpClrBkg: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).GetBackgroundClr(@ptrCast(*const IVMRMixerControl9, self), lpClrBkg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetMixingPrefs(self: *const T, dwMixerPrefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).SetMixingPrefs(@ptrCast(*const IVMRMixerControl9, self), dwMixerPrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetMixingPrefs(self: *const T, pdwMixerPrefs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).GetMixingPrefs(@ptrCast(*const IVMRMixerControl9, self), pdwMixerPrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetProcAmpControl(self: *const T, dwStreamID: u32, lpClrControl: ?*VMR9ProcAmpControl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).SetProcAmpControl(@ptrCast(*const IVMRMixerControl9, self), dwStreamID, lpClrControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetProcAmpControl(self: *const T, dwStreamID: u32, lpClrControl: ?*VMR9ProcAmpControl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).GetProcAmpControl(@ptrCast(*const IVMRMixerControl9, self), dwStreamID, lpClrControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetProcAmpControlRange(self: *const T, dwStreamID: u32, lpClrControl: ?*VMR9ProcAmpControlRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerControl9.VTable, self.vtable).GetProcAmpControlRange(@ptrCast(*const IVMRMixerControl9, self), dwStreamID, lpClrControl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9AlphaBitmap = extern struct {
    dwFlags: u32,
    hdc: ?HDC,
    pDDS: ?*IDirect3DSurface9,
    rSrc: RECT,
    rDest: VMR9NormalizedRect,
    fAlpha: f32,
    clrSrcKey: u32,
    dwFilterMode: u32,
};

pub const VMR9AlphaBitmapFlags = enum(i32) {
    Disable = 1,
    hDC = 2,
    EntireDDS = 4,
    SrcColorKey = 8,
    SrcRect = 16,
    FilterMode = 32,
};
pub const VMR9AlphaBitmap_Disable = VMR9AlphaBitmapFlags.Disable;
pub const VMR9AlphaBitmap_hDC = VMR9AlphaBitmapFlags.hDC;
pub const VMR9AlphaBitmap_EntireDDS = VMR9AlphaBitmapFlags.EntireDDS;
pub const VMR9AlphaBitmap_SrcColorKey = VMR9AlphaBitmapFlags.SrcColorKey;
pub const VMR9AlphaBitmap_SrcRect = VMR9AlphaBitmapFlags.SrcRect;
pub const VMR9AlphaBitmap_FilterMode = VMR9AlphaBitmapFlags.FilterMode;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerBitmap9_Value = @import("../zig.zig").Guid.initString("ced175e5-1935-4820-81bd-ff6ad00c9108");
pub const IID_IVMRMixerBitmap9 = &IID_IVMRMixerBitmap9_Value;
pub const IVMRMixerBitmap9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlphaBitmap: fn(
            self: *const IVMRMixerBitmap9,
            pBmpParms: ?*const VMR9AlphaBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAlphaBitmapParameters: fn(
            self: *const IVMRMixerBitmap9,
            pBmpParms: ?*const VMR9AlphaBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlphaBitmapParameters: fn(
            self: *const IVMRMixerBitmap9,
            pBmpParms: ?*VMR9AlphaBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap9_SetAlphaBitmap(self: *const T, pBmpParms: ?*const VMR9AlphaBitmap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerBitmap9.VTable, self.vtable).SetAlphaBitmap(@ptrCast(*const IVMRMixerBitmap9, self), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap9_UpdateAlphaBitmapParameters(self: *const T, pBmpParms: ?*const VMR9AlphaBitmap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerBitmap9.VTable, self.vtable).UpdateAlphaBitmapParameters(@ptrCast(*const IVMRMixerBitmap9, self), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap9_GetAlphaBitmapParameters(self: *const T, pBmpParms: ?*VMR9AlphaBitmap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMixerBitmap9.VTable, self.vtable).GetAlphaBitmapParameters(@ptrCast(*const IVMRMixerBitmap9, self), pBmpParms);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurface9_Value = @import("../zig.zig").Guid.initString("dfc581a1-6e1f-4c3a-8d0a-5e9792ea2afc");
pub const IID_IVMRSurface9 = &IID_IVMRSurface9_Value;
pub const IVMRSurface9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSurfaceLocked: fn(
            self: *const IVMRSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockSurface: fn(
            self: *const IVMRSurface9,
            lpSurface: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockSurface: fn(
            self: *const IVMRSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurface: fn(
            self: *const IVMRSurface9,
            lplpSurface: ?*?*IDirect3DSurface9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface9_IsSurfaceLocked(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurface9.VTable, self.vtable).IsSurfaceLocked(@ptrCast(*const IVMRSurface9, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface9_LockSurface(self: *const T, lpSurface: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurface9.VTable, self.vtable).LockSurface(@ptrCast(*const IVMRSurface9, self), lpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface9_UnlockSurface(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurface9.VTable, self.vtable).UnlockSurface(@ptrCast(*const IVMRSurface9, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface9_GetSurface(self: *const T, lplpSurface: ?*?*IDirect3DSurface9) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRSurface9.VTable, self.vtable).GetSurface(@ptrCast(*const IVMRSurface9, self), lplpSurface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9RenderPrefs = enum(i32) {
    DoNotRenderBorder = 1,
    // Mask = 1, this enum value conflicts with DoNotRenderBorder
};
pub const RenderPrefs9_DoNotRenderBorder = VMR9RenderPrefs.DoNotRenderBorder;
pub const RenderPrefs9_Mask = VMR9RenderPrefs.DoNotRenderBorder;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenterConfig9_Value = @import("../zig.zig").Guid.initString("45c15cab-6e22-420a-8043-ae1f0ac02c7d");
pub const IID_IVMRImagePresenterConfig9 = &IID_IVMRImagePresenterConfig9_Value;
pub const IVMRImagePresenterConfig9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRenderingPrefs: fn(
            self: *const IVMRImagePresenterConfig9,
            dwRenderFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingPrefs: fn(
            self: *const IVMRImagePresenterConfig9,
            dwRenderFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterConfig9_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenterConfig9.VTable, self.vtable).SetRenderingPrefs(@ptrCast(*const IVMRImagePresenterConfig9, self), dwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterConfig9_GetRenderingPrefs(self: *const T, dwRenderFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImagePresenterConfig9.VTable, self.vtable).GetRenderingPrefs(@ptrCast(*const IVMRImagePresenterConfig9, self), dwRenderFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRVideoStreamControl9_Value = @import("../zig.zig").Guid.initString("d0cfe38b-93e7-4772-8957-0400c49a4485");
pub const IID_IVMRVideoStreamControl9 = &IID_IVMRVideoStreamControl9_Value;
pub const IVMRVideoStreamControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamActiveState: fn(
            self: *const IVMRVideoStreamControl9,
            fActive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamActiveState: fn(
            self: *const IVMRVideoStreamControl9,
            lpfActive: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl9_SetStreamActiveState(self: *const T, fActive: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRVideoStreamControl9.VTable, self.vtable).SetStreamActiveState(@ptrCast(*const IVMRVideoStreamControl9, self), fActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl9_GetStreamActiveState(self: *const T, lpfActive: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRVideoStreamControl9.VTable, self.vtable).GetStreamActiveState(@ptrCast(*const IVMRVideoStreamControl9, self), lpfActive);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9Mode = enum(i32) {
    Windowed = 1,
    Windowless = 2,
    Renderless = 4,
    Mask = 7,
};
pub const VMR9Mode_Windowed = VMR9Mode.Windowed;
pub const VMR9Mode_Windowless = VMR9Mode.Windowless;
pub const VMR9Mode_Renderless = VMR9Mode.Renderless;
pub const VMR9Mode_Mask = VMR9Mode.Mask;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRFilterConfig9_Value = @import("../zig.zig").Guid.initString("5a804648-4f66-4867-9c43-4f5c822cf1b8");
pub const IID_IVMRFilterConfig9 = &IID_IVMRFilterConfig9_Value;
pub const IVMRFilterConfig9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetImageCompositor: fn(
            self: *const IVMRFilterConfig9,
            lpVMRImgCompositor: ?*IVMRImageCompositor9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNumberOfStreams: fn(
            self: *const IVMRFilterConfig9,
            dwMaxStreams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfStreams: fn(
            self: *const IVMRFilterConfig9,
            pdwMaxStreams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingPrefs: fn(
            self: *const IVMRFilterConfig9,
            dwRenderFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingPrefs: fn(
            self: *const IVMRFilterConfig9,
            pdwRenderFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingMode: fn(
            self: *const IVMRFilterConfig9,
            Mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingMode: fn(
            self: *const IVMRFilterConfig9,
            pMode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_SetImageCompositor(self: *const T, lpVMRImgCompositor: ?*IVMRImageCompositor9) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig9.VTable, self.vtable).SetImageCompositor(@ptrCast(*const IVMRFilterConfig9, self), lpVMRImgCompositor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_SetNumberOfStreams(self: *const T, dwMaxStreams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig9.VTable, self.vtable).SetNumberOfStreams(@ptrCast(*const IVMRFilterConfig9, self), dwMaxStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_GetNumberOfStreams(self: *const T, pdwMaxStreams: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig9.VTable, self.vtable).GetNumberOfStreams(@ptrCast(*const IVMRFilterConfig9, self), pdwMaxStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig9.VTable, self.vtable).SetRenderingPrefs(@ptrCast(*const IVMRFilterConfig9, self), dwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_GetRenderingPrefs(self: *const T, pdwRenderFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig9.VTable, self.vtable).GetRenderingPrefs(@ptrCast(*const IVMRFilterConfig9, self), pdwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_SetRenderingMode(self: *const T, Mode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig9.VTable, self.vtable).SetRenderingMode(@ptrCast(*const IVMRFilterConfig9, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_GetRenderingMode(self: *const T, pMode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRFilterConfig9.VTable, self.vtable).GetRenderingMode(@ptrCast(*const IVMRFilterConfig9, self), pMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRAspectRatioControl9_Value = @import("../zig.zig").Guid.initString("00d96c29-bbde-4efc-9901-bb5036392146");
pub const IID_IVMRAspectRatioControl9 = &IID_IVMRAspectRatioControl9_Value;
pub const IVMRAspectRatioControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAspectRatioMode: fn(
            self: *const IVMRAspectRatioControl9,
            lpdwARMode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: fn(
            self: *const IVMRAspectRatioControl9,
            dwARMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRAspectRatioControl9_GetAspectRatioMode(self: *const T, lpdwARMode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRAspectRatioControl9.VTable, self.vtable).GetAspectRatioMode(@ptrCast(*const IVMRAspectRatioControl9, self), lpdwARMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRAspectRatioControl9_SetAspectRatioMode(self: *const T, dwARMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRAspectRatioControl9.VTable, self.vtable).SetAspectRatioMode(@ptrCast(*const IVMRAspectRatioControl9, self), dwARMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9MonitorInfo = extern struct {
    uDevID: u32,
    rcMonitor: RECT,
    hMon: ?HMONITOR,
    dwFlags: u32,
    szDevice: [32]u16,
    szDescription: [512]u16,
    liDriverVersion: LARGE_INTEGER,
    dwVendorId: u32,
    dwDeviceId: u32,
    dwSubSysId: u32,
    dwRevision: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMonitorConfig9_Value = @import("../zig.zig").Guid.initString("46c2e457-8ba0-4eef-b80b-0680f0978749");
pub const IID_IVMRMonitorConfig9 = &IID_IVMRMonitorConfig9_Value;
pub const IVMRMonitorConfig9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMonitor: fn(
            self: *const IVMRMonitorConfig9,
            uDev: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonitor: fn(
            self: *const IVMRMonitorConfig9,
            puDev: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultMonitor: fn(
            self: *const IVMRMonitorConfig9,
            uDev: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultMonitor: fn(
            self: *const IVMRMonitorConfig9,
            puDev: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableMonitors: fn(
            self: *const IVMRMonitorConfig9,
            pInfo: [*]VMR9MonitorInfo,
            dwMaxInfoArraySize: u32,
            pdwNumDevices: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_SetMonitor(self: *const T, uDev: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig9.VTable, self.vtable).SetMonitor(@ptrCast(*const IVMRMonitorConfig9, self), uDev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_GetMonitor(self: *const T, puDev: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig9.VTable, self.vtable).GetMonitor(@ptrCast(*const IVMRMonitorConfig9, self), puDev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_SetDefaultMonitor(self: *const T, uDev: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig9.VTable, self.vtable).SetDefaultMonitor(@ptrCast(*const IVMRMonitorConfig9, self), uDev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_GetDefaultMonitor(self: *const T, puDev: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig9.VTable, self.vtable).GetDefaultMonitor(@ptrCast(*const IVMRMonitorConfig9, self), puDev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_GetAvailableMonitors(self: *const T, pInfo: [*]VMR9MonitorInfo, dwMaxInfoArraySize: u32, pdwNumDevices: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRMonitorConfig9.VTable, self.vtable).GetAvailableMonitors(@ptrCast(*const IVMRMonitorConfig9, self), pInfo, dwMaxInfoArraySize, pdwNumDevices);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9DeinterlacePrefs = enum(i32) {
    NextBest = 1,
    BOB = 2,
    Weave = 4,
    Mask = 7,
};
pub const DeinterlacePref9_NextBest = VMR9DeinterlacePrefs.NextBest;
pub const DeinterlacePref9_BOB = VMR9DeinterlacePrefs.BOB;
pub const DeinterlacePref9_Weave = VMR9DeinterlacePrefs.Weave;
pub const DeinterlacePref9_Mask = VMR9DeinterlacePrefs.Mask;

pub const VMR9DeinterlaceTech = enum(i32) {
    Unknown = 0,
    BOBLineReplicate = 1,
    BOBVerticalStretch = 2,
    MedianFiltering = 4,
    EdgeFiltering = 16,
    FieldAdaptive = 32,
    PixelAdaptive = 64,
    MotionVectorSteered = 128,
};
pub const DeinterlaceTech9_Unknown = VMR9DeinterlaceTech.Unknown;
pub const DeinterlaceTech9_BOBLineReplicate = VMR9DeinterlaceTech.BOBLineReplicate;
pub const DeinterlaceTech9_BOBVerticalStretch = VMR9DeinterlaceTech.BOBVerticalStretch;
pub const DeinterlaceTech9_MedianFiltering = VMR9DeinterlaceTech.MedianFiltering;
pub const DeinterlaceTech9_EdgeFiltering = VMR9DeinterlaceTech.EdgeFiltering;
pub const DeinterlaceTech9_FieldAdaptive = VMR9DeinterlaceTech.FieldAdaptive;
pub const DeinterlaceTech9_PixelAdaptive = VMR9DeinterlaceTech.PixelAdaptive;
pub const DeinterlaceTech9_MotionVectorSteered = VMR9DeinterlaceTech.MotionVectorSteered;

pub const VMR9Frequency = extern struct {
    dwNumerator: u32,
    dwDenominator: u32,
};

pub const VMR9_SampleFormat = enum(i32) {
    Reserved = 1,
    ProgressiveFrame = 2,
    FieldInterleavedEvenFirst = 3,
    FieldInterleavedOddFirst = 4,
    FieldSingleEven = 5,
    FieldSingleOdd = 6,
};
pub const VMR9_SampleReserved = VMR9_SampleFormat.Reserved;
pub const VMR9_SampleProgressiveFrame = VMR9_SampleFormat.ProgressiveFrame;
pub const VMR9_SampleFieldInterleavedEvenFirst = VMR9_SampleFormat.FieldInterleavedEvenFirst;
pub const VMR9_SampleFieldInterleavedOddFirst = VMR9_SampleFormat.FieldInterleavedOddFirst;
pub const VMR9_SampleFieldSingleEven = VMR9_SampleFormat.FieldSingleEven;
pub const VMR9_SampleFieldSingleOdd = VMR9_SampleFormat.FieldSingleOdd;

pub const VMR9VideoDesc = extern struct {
    dwSize: u32,
    dwSampleWidth: u32,
    dwSampleHeight: u32,
    SampleFormat: VMR9_SampleFormat,
    dwFourCC: u32,
    InputSampleFreq: VMR9Frequency,
    OutputFrameFreq: VMR9Frequency,
};

pub const VMR9DeinterlaceCaps = extern struct {
    dwSize: u32,
    dwNumPreviousOutputFrames: u32,
    dwNumForwardRefSamples: u32,
    dwNumBackwardRefSamples: u32,
    DeinterlaceTechnology: VMR9DeinterlaceTech,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRDeinterlaceControl9_Value = @import("../zig.zig").Guid.initString("a215fb8d-13c2-4f7f-993c-003d6271a459");
pub const IID_IVMRDeinterlaceControl9 = &IID_IVMRDeinterlaceControl9_Value;
pub const IVMRDeinterlaceControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfDeinterlaceModes: fn(
            self: *const IVMRDeinterlaceControl9,
            lpVideoDescription: ?*VMR9VideoDesc,
            lpdwNumDeinterlaceModes: ?*u32,
            lpDeinterlaceModes: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceModeCaps: fn(
            self: *const IVMRDeinterlaceControl9,
            lpDeinterlaceMode: ?*Guid,
            lpVideoDescription: ?*VMR9VideoDesc,
            lpDeinterlaceCaps: ?*VMR9DeinterlaceCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceMode: fn(
            self: *const IVMRDeinterlaceControl9,
            dwStreamID: u32,
            lpDeinterlaceMode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeinterlaceMode: fn(
            self: *const IVMRDeinterlaceControl9,
            dwStreamID: u32,
            lpDeinterlaceMode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlacePrefs: fn(
            self: *const IVMRDeinterlaceControl9,
            lpdwDeinterlacePrefs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeinterlacePrefs: fn(
            self: *const IVMRDeinterlaceControl9,
            dwDeinterlacePrefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualDeinterlaceMode: fn(
            self: *const IVMRDeinterlaceControl9,
            dwStreamID: u32,
            lpDeinterlaceMode: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetNumberOfDeinterlaceModes(self: *const T, lpVideoDescription: ?*VMR9VideoDesc, lpdwNumDeinterlaceModes: ?*u32, lpDeinterlaceModes: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl9.VTable, self.vtable).GetNumberOfDeinterlaceModes(@ptrCast(*const IVMRDeinterlaceControl9, self), lpVideoDescription, lpdwNumDeinterlaceModes, lpDeinterlaceModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetDeinterlaceModeCaps(self: *const T, lpDeinterlaceMode: ?*Guid, lpVideoDescription: ?*VMR9VideoDesc, lpDeinterlaceCaps: ?*VMR9DeinterlaceCaps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl9.VTable, self.vtable).GetDeinterlaceModeCaps(@ptrCast(*const IVMRDeinterlaceControl9, self), lpDeinterlaceMode, lpVideoDescription, lpDeinterlaceCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl9.VTable, self.vtable).GetDeinterlaceMode(@ptrCast(*const IVMRDeinterlaceControl9, self), dwStreamID, lpDeinterlaceMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_SetDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl9.VTable, self.vtable).SetDeinterlaceMode(@ptrCast(*const IVMRDeinterlaceControl9, self), dwStreamID, lpDeinterlaceMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetDeinterlacePrefs(self: *const T, lpdwDeinterlacePrefs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl9.VTable, self.vtable).GetDeinterlacePrefs(@ptrCast(*const IVMRDeinterlaceControl9, self), lpdwDeinterlacePrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_SetDeinterlacePrefs(self: *const T, dwDeinterlacePrefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl9.VTable, self.vtable).SetDeinterlacePrefs(@ptrCast(*const IVMRDeinterlaceControl9, self), dwDeinterlacePrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetActualDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRDeinterlaceControl9.VTable, self.vtable).GetActualDeinterlaceMode(@ptrCast(*const IVMRDeinterlaceControl9, self), dwStreamID, lpDeinterlaceMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9VideoStreamInfo = extern struct {
    pddsVideoSurface: ?*IDirect3DSurface9,
    dwWidth: u32,
    dwHeight: u32,
    dwStrmID: u32,
    fAlpha: f32,
    rNormal: VMR9NormalizedRect,
    rtStart: i64,
    rtEnd: i64,
    SampleFormat: VMR9_SampleFormat,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImageCompositor9_Value = @import("../zig.zig").Guid.initString("4a5c89eb-df51-4654-ac2a-e48e02bbabf6");
pub const IID_IVMRImageCompositor9 = &IID_IVMRImageCompositor9_Value;
pub const IVMRImageCompositor9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitCompositionDevice: fn(
            self: *const IVMRImageCompositor9,
            pD3DDevice: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TermCompositionDevice: fn(
            self: *const IVMRImageCompositor9,
            pD3DDevice: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamMediaType: fn(
            self: *const IVMRImageCompositor9,
            dwStrmID: u32,
            pmt: ?*AM_MEDIA_TYPE,
            fTexture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompositeImage: fn(
            self: *const IVMRImageCompositor9,
            pD3DDevice: ?*IUnknown,
            pddsRenderTarget: ?*IDirect3DSurface9,
            pmtRenderTarget: ?*AM_MEDIA_TYPE,
            rtStart: i64,
            rtEnd: i64,
            dwClrBkGnd: u32,
            pVideoStreamInfo: ?*VMR9VideoStreamInfo,
            cStreams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor9_InitCompositionDevice(self: *const T, pD3DDevice: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImageCompositor9.VTable, self.vtable).InitCompositionDevice(@ptrCast(*const IVMRImageCompositor9, self), pD3DDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor9_TermCompositionDevice(self: *const T, pD3DDevice: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImageCompositor9.VTable, self.vtable).TermCompositionDevice(@ptrCast(*const IVMRImageCompositor9, self), pD3DDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor9_SetStreamMediaType(self: *const T, dwStrmID: u32, pmt: ?*AM_MEDIA_TYPE, fTexture: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImageCompositor9.VTable, self.vtable).SetStreamMediaType(@ptrCast(*const IVMRImageCompositor9, self), dwStrmID, pmt, fTexture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor9_CompositeImage(self: *const T, pD3DDevice: ?*IUnknown, pddsRenderTarget: ?*IDirect3DSurface9, pmtRenderTarget: ?*AM_MEDIA_TYPE, rtStart: i64, rtEnd: i64, dwClrBkGnd: u32, pVideoStreamInfo: ?*VMR9VideoStreamInfo, cStreams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVMRImageCompositor9.VTable, self.vtable).CompositeImage(@ptrCast(*const IVMRImageCompositor9, self), pD3DDevice, pddsRenderTarget, pmtRenderTarget, rtStart, rtEnd, dwClrBkGnd, pVideoStreamInfo, cStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPBaseConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectInfo: fn(
            self: *const IVPBaseConfig,
            pdwNumConnectInfo: ?*u32,
            pddVPConnectInfo: ?[*]DDVIDEOPORTCONNECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConnectInfo: fn(
            self: *const IVPBaseConfig,
            dwChosenEntry: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVPDataInfo: fn(
            self: *const IVPBaseConfig,
            pamvpDataInfo: ?*AMVPDATAINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxPixelRate: fn(
            self: *const IVPBaseConfig,
            pamvpSize: ?*AMVPSIZE,
            pdwMaxPixelsPerSecond: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InformVPInputFormats: fn(
            self: *const IVPBaseConfig,
            dwNumFormats: u32,
            pDDPixelFormats: ?*DDPIXELFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoFormats: fn(
            self: *const IVPBaseConfig,
            pdwNumFormats: ?*u32,
            pddPixelFormats: ?[*]DDPIXELFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoFormat: fn(
            self: *const IVPBaseConfig,
            dwChosenEntry: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInvertPolarity: fn(
            self: *const IVPBaseConfig,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlaySurface: fn(
            self: *const IVPBaseConfig,
            ppddOverlaySurface: ?*?*IDirectDrawSurface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectDrawKernelHandle: fn(
            self: *const IVPBaseConfig,
            dwDDKernelHandle: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoPortID: fn(
            self: *const IVPBaseConfig,
            dwVideoPortID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDDSurfaceKernelHandles: fn(
            self: *const IVPBaseConfig,
            cHandles: u32,
            rgDDKernelHandles: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSurfaceParameters: fn(
            self: *const IVPBaseConfig,
            dwPitch: u32,
            dwXOrigin: u32,
            dwYOrigin: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetConnectInfo(self: *const T, pdwNumConnectInfo: ?*u32, pddVPConnectInfo: ?[*]DDVIDEOPORTCONNECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).GetConnectInfo(@ptrCast(*const IVPBaseConfig, self), pdwNumConnectInfo, pddVPConnectInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetConnectInfo(self: *const T, dwChosenEntry: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).SetConnectInfo(@ptrCast(*const IVPBaseConfig, self), dwChosenEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetVPDataInfo(self: *const T, pamvpDataInfo: ?*AMVPDATAINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).GetVPDataInfo(@ptrCast(*const IVPBaseConfig, self), pamvpDataInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetMaxPixelRate(self: *const T, pamvpSize: ?*AMVPSIZE, pdwMaxPixelsPerSecond: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).GetMaxPixelRate(@ptrCast(*const IVPBaseConfig, self), pamvpSize, pdwMaxPixelsPerSecond);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_InformVPInputFormats(self: *const T, dwNumFormats: u32, pDDPixelFormats: ?*DDPIXELFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).InformVPInputFormats(@ptrCast(*const IVPBaseConfig, self), dwNumFormats, pDDPixelFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetVideoFormats(self: *const T, pdwNumFormats: ?*u32, pddPixelFormats: ?[*]DDPIXELFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).GetVideoFormats(@ptrCast(*const IVPBaseConfig, self), pdwNumFormats, pddPixelFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetVideoFormat(self: *const T, dwChosenEntry: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).SetVideoFormat(@ptrCast(*const IVPBaseConfig, self), dwChosenEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetInvertPolarity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).SetInvertPolarity(@ptrCast(*const IVPBaseConfig, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetOverlaySurface(self: *const T, ppddOverlaySurface: ?*?*IDirectDrawSurface) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).GetOverlaySurface(@ptrCast(*const IVPBaseConfig, self), ppddOverlaySurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetDirectDrawKernelHandle(self: *const T, dwDDKernelHandle: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).SetDirectDrawKernelHandle(@ptrCast(*const IVPBaseConfig, self), dwDDKernelHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetVideoPortID(self: *const T, dwVideoPortID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).SetVideoPortID(@ptrCast(*const IVPBaseConfig, self), dwVideoPortID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetDDSurfaceKernelHandles(self: *const T, cHandles: u32, rgDDKernelHandles: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).SetDDSurfaceKernelHandles(@ptrCast(*const IVPBaseConfig, self), cHandles, rgDDKernelHandles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetSurfaceParameters(self: *const T, dwPitch: u32, dwXOrigin: u32, dwYOrigin: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseConfig.VTable, self.vtable).SetSurfaceParameters(@ptrCast(*const IVPBaseConfig, self), dwPitch, dwXOrigin, dwYOrigin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPConfig = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseConfig.VTable,
        IsVPDecimationAllowed: fn(
            self: *const IVPConfig,
            pbIsDecimationAllowed: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScalingFactors: fn(
            self: *const IVPConfig,
            pamvpSize: ?*AMVPSIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPBaseConfig.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPConfig_IsVPDecimationAllowed(self: *const T, pbIsDecimationAllowed: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPConfig.VTable, self.vtable).IsVPDecimationAllowed(@ptrCast(*const IVPConfig, self), pbIsDecimationAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPConfig_SetScalingFactors(self: *const T, pamvpSize: ?*AMVPSIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPConfig.VTable, self.vtable).SetScalingFactors(@ptrCast(*const IVPConfig, self), pamvpSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVPVBIConfig = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseConfig.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPBaseConfig.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPBaseNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenegotiateVPParameters: fn(
            self: *const IVPBaseNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseNotify_RenegotiateVPParameters(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPBaseNotify.VTable, self.vtable).RenegotiateVPParameters(@ptrCast(*const IVPBaseNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPNotify = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseNotify.VTable,
        SetDeinterlaceMode: fn(
            self: *const IVPNotify,
            mode: AMVP_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeinterlaceMode: fn(
            self: *const IVPNotify,
            pMode: ?*AMVP_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPBaseNotify.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPNotify_SetDeinterlaceMode(self: *const T, mode: AMVP_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPNotify.VTable, self.vtable).SetDeinterlaceMode(@ptrCast(*const IVPNotify, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPNotify_GetDeinterlaceMode(self: *const T, pMode: ?*AMVP_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPNotify.VTable, self.vtable).GetDeinterlaceMode(@ptrCast(*const IVPNotify, self), pMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPNotify2 = extern struct {
    pub const VTable = extern struct {
        base: IVPNotify.VTable,
        SetVPSyncMaster: fn(
            self: *const IVPNotify2,
            bVPSyncMaster: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVPSyncMaster: fn(
            self: *const IVPNotify2,
            pbVPSyncMaster: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPNotify.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPNotify2_SetVPSyncMaster(self: *const T, bVPSyncMaster: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPNotify2.VTable, self.vtable).SetVPSyncMaster(@ptrCast(*const IVPNotify2, self), bVPSyncMaster);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPNotify2_GetVPSyncMaster(self: *const T, pbVPSyncMaster: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVPNotify2.VTable, self.vtable).GetVPSyncMaster(@ptrCast(*const IVPNotify2, self), pbVPSyncMaster);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVPVBINotify = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseNotify.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPBaseNotify.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RIFFCHUNK = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
};

pub const RIFFLIST = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    fccListType: u32,
};

pub const AVIMAINHEADER = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    dwMicroSecPerFrame: u32,
    dwMaxBytesPerSec: u32,
    dwPaddingGranularity: u32,
    dwFlags: u32,
    dwTotalFrames: u32,
    dwInitialFrames: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwReserved: [4]u32,
};

pub const AVIEXTHEADER = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    dwGrandFrames: u32,
    dwFuture: [61]u32,
};

pub const AVISTREAMHEADER = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    wPriority: u16,
    wLanguage: u16,
    dwInitialFrames: u32,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: extern struct {
        left: i16,
        top: i16,
        right: i16,
        bottom: i16,
    },
};

pub const AVIOLDINDEX = extern struct {
    pub const _avioldindex_entry = extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        dwChunkId: u32,
        dwFlags: u32,
        dwOffset: u32,
        dwSize: u32,
    };
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    aIndex: [1]_avioldindex_entry,
};

pub const TIMECODEDATA = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    time: TIMECODE,
    dwSMPTEflags: u32,
    dwUser: u32,
};

pub const AVIMETAINDEX = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    wLongsPerEntry: u16,
    bIndexSubType: u8,
    bIndexType: u8,
    nEntriesInUse: u32,
    dwChunkId: u32,
    dwReserved: [3]u32,
    adwIndex: [1]u32,
};

pub const AVISUPERINDEX = extern struct {
    pub const _avisuperindex_entry = extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        qwOffset: u64,
        dwSize: u32,
        dwDuration: u32,
    };
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    wLongsPerEntry: u16,
    bIndexSubType: u8,
    bIndexType: u8,
    nEntriesInUse: u32,
    dwChunkId: u32,
    dwReserved: [3]u32,
    aIndex: [1022]_avisuperindex_entry,
};

pub const AVISTDINDEX_ENTRY = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    dwOffset: u32,
    dwSize: u32,
};

pub const AVISTDINDEX = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    wLongsPerEntry: u16,
    bIndexSubType: u8,
    bIndexType: u8,
    nEntriesInUse: u32,
    dwChunkId: u32,
    qwBaseOffset: u64,
    dwReserved_3: u32,
    aIndex: [2044]AVISTDINDEX_ENTRY,
};

pub const AVITIMEDINDEX_ENTRY = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    dwOffset: u32,
    dwSize: u32,
    dwDuration: u32,
};

pub const _avitimedindex = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    wLongsPerEntry: u16,
    bIndexSubType: u8,
    bIndexType: u8,
    nEntriesInUse: u32,
    dwChunkId: u32,
    qwBaseOffset: u64,
    dwReserved_3: u32,
    aIndex: [1362]AVITIMEDINDEX_ENTRY,
    adwTrailingFill: [2734]u32,
};

pub const AVITIMECODEINDEX = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    wLongsPerEntry: u16,
    bIndexSubType: u8,
    bIndexType: u8,
    nEntriesInUse: u32,
    dwChunkId: u32,
    dwReserved: [3]u32,
    aIndex: [1022]TIMECODEDATA,
};

pub const AVITCDLINDEX_ENTRY = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    dwTick: u32,
    time: TIMECODE,
    dwSMPTEflags: u32,
    dwUser: u32,
    szReelId: [12]i8,
};

pub const _avitcdlindex = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    wLongsPerEntry: u16,
    bIndexSubType: u8,
    bIndexType: u8,
    nEntriesInUse: u32,
    dwChunkId: u32,
    dwReserved: [3]u32,
    aIndex: [584]AVITCDLINDEX_ENTRY,
    adwTrailingFill: [3512]u32,
};

pub const AVIFIELDINDEX = extern struct {
    pub const _avifieldindex_entry = extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        dwOffset: u32,
        dwSize: u32,
        dwOffsetField2: u32,
    };
    // WARNING: unable to add field alignment because it's causing a compiler bug
    fcc: u32,
    cb: u32,
    wLongsPerEntry: u16,
    bIndexSubType: u8,
    bIndexType: u8,
    nEntriesInUse: u32,
    dwChunkId: u32,
    qwBaseOffset: u64,
    dwReserved3: u32,
    aIndex: [1]_avifieldindex_entry,
};

pub const MainAVIHeader = extern struct {
    dwMicroSecPerFrame: u32,
    dwMaxBytesPerSec: u32,
    dwPaddingGranularity: u32,
    dwFlags: u32,
    dwTotalFrames: u32,
    dwInitialFrames: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwReserved: [4]u32,
};

pub const AVIStreamHeader = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    wPriority: u16,
    wLanguage: u16,
    dwInitialFrames: u32,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: RECT,
};

pub const AVIINDEXENTRY = extern struct {
    ckid: u32,
    dwFlags: u32,
    dwChunkOffset: u32,
    dwChunkLength: u32,
};

pub const AVIPALCHANGE = extern struct {
    bFirstEntry: u8,
    bNumEntries: u8,
    wFlags: u16,
    peNew: [1]PALETTEENTRY,
};

pub const AM_PROPERTY_AC3 = enum(i32) {
    ERROR_CONCEALMENT = 1,
    ALTERNATE_AUDIO = 2,
    DOWNMIX = 3,
    BIT_STREAM_MODE = 4,
    DIALOGUE_LEVEL = 5,
    LANGUAGE_CODE = 6,
    ROOM_TYPE = 7,
};
pub const AM_PROPERTY_AC3_ERROR_CONCEALMENT = AM_PROPERTY_AC3.ERROR_CONCEALMENT;
pub const AM_PROPERTY_AC3_ALTERNATE_AUDIO = AM_PROPERTY_AC3.ALTERNATE_AUDIO;
pub const AM_PROPERTY_AC3_DOWNMIX = AM_PROPERTY_AC3.DOWNMIX;
pub const AM_PROPERTY_AC3_BIT_STREAM_MODE = AM_PROPERTY_AC3.BIT_STREAM_MODE;
pub const AM_PROPERTY_AC3_DIALOGUE_LEVEL = AM_PROPERTY_AC3.DIALOGUE_LEVEL;
pub const AM_PROPERTY_AC3_LANGUAGE_CODE = AM_PROPERTY_AC3.LANGUAGE_CODE;
pub const AM_PROPERTY_AC3_ROOM_TYPE = AM_PROPERTY_AC3.ROOM_TYPE;

pub const AM_AC3_ERROR_CONCEALMENT = extern struct {
    fRepeatPreviousBlock: BOOL,
    fErrorInCurrentBlock: BOOL,
};

pub const AM_AC3_ALTERNATE_AUDIO = extern struct {
    fStereo: BOOL,
    DualMode: u32,
};

pub const AM_AC3_DOWNMIX = extern struct {
    fDownMix: BOOL,
    fDolbySurround: BOOL,
};

pub const AM_AC3_BIT_STREAM_MODE = extern struct {
    BitStreamMode: i32,
};

pub const AM_AC3_DIALOGUE_LEVEL = extern struct {
    DialogueLevel: u32,
};

pub const AM_AC3_ROOM_TYPE = extern struct {
    fLargeRoom: BOOL,
};

pub const AM_PROPERTY_DVDSUBPIC = enum(i32) {
    PALETTE = 0,
    HLI = 1,
    COMPOSIT_ON = 2,
};
pub const AM_PROPERTY_DVDSUBPIC_PALETTE = AM_PROPERTY_DVDSUBPIC.PALETTE;
pub const AM_PROPERTY_DVDSUBPIC_HLI = AM_PROPERTY_DVDSUBPIC.HLI;
pub const AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON = AM_PROPERTY_DVDSUBPIC.COMPOSIT_ON;

pub const AM_DVD_YUV = extern struct {
    Reserved: u8,
    Y: u8,
    U: u8,
    V: u8,
};

pub const AM_PROPERTY_SPPAL = extern struct {
    sppal: [16]AM_DVD_YUV,
};

pub const AM_COLCON = extern struct {
    _bitfield1: u8,
    _bitfield2: u8,
    _bitfield3: u8,
    _bitfield4: u8,
};

pub const AM_PROPERTY_SPHLI = extern struct {
    HLISS: u16,
    Reserved: u16,
    StartPTM: u32,
    EndPTM: u32,
    StartX: u16,
    StartY: u16,
    StopX: u16,
    StopY: u16,
    ColCon: AM_COLCON,
};

pub const AM_PROPERTY_DVDCOPYPROT = enum(i32) {
    DVDCOPY_CHLG_KEY = 1,
    DVDCOPY_DVD_KEY1 = 2,
    DVDCOPY_DEC_KEY2 = 3,
    DVDCOPY_TITLE_KEY = 4,
    COPY_MACROVISION = 5,
    DVDCOPY_REGION = 6,
    DVDCOPY_SET_COPY_STATE = 7,
    COPY_ANALOG_COMPONENT = 8,
    COPY_DIGITAL_CP = 9,
    COPY_DVD_SRM = 10,
    DVDCOPY_SUPPORTS_NEW_KEYCOUNT = 11,
    DVDCOPY_DISC_KEY = 128,
};
pub const AM_PROPERTY_DVDCOPY_CHLG_KEY = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_CHLG_KEY;
pub const AM_PROPERTY_DVDCOPY_DVD_KEY1 = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_DVD_KEY1;
pub const AM_PROPERTY_DVDCOPY_DEC_KEY2 = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_DEC_KEY2;
pub const AM_PROPERTY_DVDCOPY_TITLE_KEY = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_TITLE_KEY;
pub const AM_PROPERTY_COPY_MACROVISION = AM_PROPERTY_DVDCOPYPROT.COPY_MACROVISION;
pub const AM_PROPERTY_DVDCOPY_REGION = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_REGION;
pub const AM_PROPERTY_DVDCOPY_SET_COPY_STATE = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_SET_COPY_STATE;
pub const AM_PROPERTY_COPY_ANALOG_COMPONENT = AM_PROPERTY_DVDCOPYPROT.COPY_ANALOG_COMPONENT;
pub const AM_PROPERTY_COPY_DIGITAL_CP = AM_PROPERTY_DVDCOPYPROT.COPY_DIGITAL_CP;
pub const AM_PROPERTY_COPY_DVD_SRM = AM_PROPERTY_DVDCOPYPROT.COPY_DVD_SRM;
pub const AM_PROPERTY_DVDCOPY_SUPPORTS_NEW_KEYCOUNT = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_SUPPORTS_NEW_KEYCOUNT;
pub const AM_PROPERTY_DVDCOPY_DISC_KEY = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_DISC_KEY;

pub const AM_DIGITAL_CP = enum(i32) {
    OFF = 0,
    ON = 1,
    DVD_COMPLIANT = 2,
};
pub const AM_DIGITAL_CP_OFF = AM_DIGITAL_CP.OFF;
pub const AM_DIGITAL_CP_ON = AM_DIGITAL_CP.ON;
pub const AM_DIGITAL_CP_DVD_COMPLIANT = AM_DIGITAL_CP.DVD_COMPLIANT;

pub const AM_DVDCOPY_CHLGKEY = extern struct {
    ChlgKey: [10]u8,
    Reserved: [2]u8,
};

pub const AM_DVDCOPY_BUSKEY = extern struct {
    BusKey: [5]u8,
    Reserved: [1]u8,
};

pub const AM_DVDCOPY_DISCKEY = extern struct {
    DiscKey: [2048]u8,
};

pub const AM_DVDCOPY_TITLEKEY = extern struct {
    KeyFlags: u32,
    Reserved1: [2]u32,
    TitleKey: [6]u8,
    Reserved2: [2]u8,
};

pub const AM_COPY_MACROVISION = extern struct {
    MACROVISIONLevel: u32,
};

pub const AM_DVDCOPY_SET_COPY_STATE = extern struct {
    DVDCopyState: u32,
};

pub const AM_DVDCOPYSTATE = enum(i32) {
    INITIALIZE = 0,
    INITIALIZE_TITLE = 1,
    AUTHENTICATION_NOT_REQUIRED = 2,
    AUTHENTICATION_REQUIRED = 3,
    DONE = 4,
};
pub const AM_DVDCOPYSTATE_INITIALIZE = AM_DVDCOPYSTATE.INITIALIZE;
pub const AM_DVDCOPYSTATE_INITIALIZE_TITLE = AM_DVDCOPYSTATE.INITIALIZE_TITLE;
pub const AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED = AM_DVDCOPYSTATE.AUTHENTICATION_NOT_REQUIRED;
pub const AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED = AM_DVDCOPYSTATE.AUTHENTICATION_REQUIRED;
pub const AM_DVDCOPYSTATE_DONE = AM_DVDCOPYSTATE.DONE;

pub const AM_COPY_MACROVISION_LEVEL = enum(i32) {
    DISABLED = 0,
    LEVEL1 = 1,
    LEVEL2 = 2,
    LEVEL3 = 3,
};
pub const AM_MACROVISION_DISABLED = AM_COPY_MACROVISION_LEVEL.DISABLED;
pub const AM_MACROVISION_LEVEL1 = AM_COPY_MACROVISION_LEVEL.LEVEL1;
pub const AM_MACROVISION_LEVEL2 = AM_COPY_MACROVISION_LEVEL.LEVEL2;
pub const AM_MACROVISION_LEVEL3 = AM_COPY_MACROVISION_LEVEL.LEVEL3;

pub const DVD_REGION = extern struct {
    CopySystem: u8,
    RegionData: u8,
    SystemRegion: u8,
    ResetCount: u8,
};

pub const AM_MPEG2Level = enum(i32) {
    Low = 1,
    Main = 2,
    High1440 = 3,
    High = 4,
};
pub const AM_MPEG2Level_Low = AM_MPEG2Level.Low;
pub const AM_MPEG2Level_Main = AM_MPEG2Level.Main;
pub const AM_MPEG2Level_High1440 = AM_MPEG2Level.High1440;
pub const AM_MPEG2Level_High = AM_MPEG2Level.High;

pub const AM_MPEG2Profile = enum(i32) {
    Simple = 1,
    Main = 2,
    SNRScalable = 3,
    SpatiallyScalable = 4,
    High = 5,
};
pub const AM_MPEG2Profile_Simple = AM_MPEG2Profile.Simple;
pub const AM_MPEG2Profile_Main = AM_MPEG2Profile.Main;
pub const AM_MPEG2Profile_SNRScalable = AM_MPEG2Profile.SNRScalable;
pub const AM_MPEG2Profile_SpatiallyScalable = AM_MPEG2Profile.SpatiallyScalable;
pub const AM_MPEG2Profile_High = AM_MPEG2Profile.High;

pub const VIDEOINFOHEADER2 = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    dwInterlaceFlags: u32,
    dwCopyProtectFlags: u32,
    dwPictAspectRatioX: u32,
    dwPictAspectRatioY: u32,
    Anonymous: extern union {
        dwControlFlags: u32,
        dwReserved1: u32,
    },
    dwReserved2: u32,
    bmiHeader: BITMAPINFOHEADER,
};

pub const MPEG2VIDEOINFO = extern struct {
    hdr: VIDEOINFOHEADER2,
    dwStartTimeCode: u32,
    cbSequenceHeader: u32,
    dwProfile: u32,
    dwLevel: u32,
    dwFlags: MPEG2VIDEOINFO_FLAGS,
    dwSequenceHeader: [1]u32,
};

pub const AM_DvdKaraokeData = extern struct {
    dwDownmix: u32,
    dwSpeakerAssignment: u32,
};

pub const AM_PROPERTY_DVDKARAOKE = enum(i32) {
    ENABLE = 0,
    DATA = 1,
};
pub const AM_PROPERTY_DVDKARAOKE_ENABLE = AM_PROPERTY_DVDKARAOKE.ENABLE;
pub const AM_PROPERTY_DVDKARAOKE_DATA = AM_PROPERTY_DVDKARAOKE.DATA;

pub const AM_PROPERTY_TS_RATE_CHANGE = enum(i32) {
    SimpleRateChange = 1,
    ExactRateChange = 2,
    MaxFullDataRate = 3,
    Step = 4,
    UseRateVersion = 5,
    QueryFullFrameRate = 6,
    QueryLastRateSegPTS = 7,
    CorrectTS = 8,
    ReverseMaxFullDataRate = 9,
    ResetOnTimeDisc = 10,
    QueryMapping = 11,
};
pub const AM_RATE_SimpleRateChange = AM_PROPERTY_TS_RATE_CHANGE.SimpleRateChange;
pub const AM_RATE_ExactRateChange = AM_PROPERTY_TS_RATE_CHANGE.ExactRateChange;
pub const AM_RATE_MaxFullDataRate = AM_PROPERTY_TS_RATE_CHANGE.MaxFullDataRate;
pub const AM_RATE_Step = AM_PROPERTY_TS_RATE_CHANGE.Step;
pub const AM_RATE_UseRateVersion = AM_PROPERTY_TS_RATE_CHANGE.UseRateVersion;
pub const AM_RATE_QueryFullFrameRate = AM_PROPERTY_TS_RATE_CHANGE.QueryFullFrameRate;
pub const AM_RATE_QueryLastRateSegPTS = AM_PROPERTY_TS_RATE_CHANGE.QueryLastRateSegPTS;
pub const AM_RATE_CorrectTS = AM_PROPERTY_TS_RATE_CHANGE.CorrectTS;
pub const AM_RATE_ReverseMaxFullDataRate = AM_PROPERTY_TS_RATE_CHANGE.ReverseMaxFullDataRate;
pub const AM_RATE_ResetOnTimeDisc = AM_PROPERTY_TS_RATE_CHANGE.ResetOnTimeDisc;
pub const AM_RATE_QueryMapping = AM_PROPERTY_TS_RATE_CHANGE.QueryMapping;

pub const AM_PROPERTY_DVD_RATE_CHANGE = enum(i32) {
    ChangeRate = 1,
    FullDataRateMax = 2,
    ReverseDecode = 3,
    DecoderPosition = 4,
    DecoderVersion = 5,
};
pub const AM_RATE_ChangeRate = AM_PROPERTY_DVD_RATE_CHANGE.ChangeRate;
pub const AM_RATE_FullDataRateMax = AM_PROPERTY_DVD_RATE_CHANGE.FullDataRateMax;
pub const AM_RATE_ReverseDecode = AM_PROPERTY_DVD_RATE_CHANGE.ReverseDecode;
pub const AM_RATE_DecoderPosition = AM_PROPERTY_DVD_RATE_CHANGE.DecoderPosition;
pub const AM_RATE_DecoderVersion = AM_PROPERTY_DVD_RATE_CHANGE.DecoderVersion;

pub const AM_SimpleRateChange = extern struct {
    StartTime: i64,
    Rate: i32,
};

pub const AM_QueryRate = extern struct {
    lMaxForwardFullFrame: i32,
    lMaxReverseFullFrame: i32,
};

pub const AM_ExactRateChange = extern struct {
    OutputZeroTime: i64,
    Rate: i32,
};

pub const AM_DVD_ChangeRate = extern struct {
    StartInTime: i64,
    StartOutTime: i64,
    Rate: i32,
};

pub const DVD_PLAY_DIRECTION = enum(i32) {
    FORWARD = 0,
    BACKWARD = 1,
};
pub const DVD_DIR_FORWARD = DVD_PLAY_DIRECTION.FORWARD;
pub const DVD_DIR_BACKWARD = DVD_PLAY_DIRECTION.BACKWARD;

pub const DVD_ERROR = enum(i32) {
    Unexpected = 1,
    CopyProtectFail = 2,
    InvalidDVD1_0Disc = 3,
    InvalidDiscRegion = 4,
    LowParentalLevel = 5,
    MacrovisionFail = 6,
    IncompatibleSystemAndDecoderRegions = 7,
    IncompatibleDiscAndDecoderRegions = 8,
    CopyProtectOutputFail = 9,
    CopyProtectOutputNotSupported = 10,
};
pub const DVD_ERROR_Unexpected = DVD_ERROR.Unexpected;
pub const DVD_ERROR_CopyProtectFail = DVD_ERROR.CopyProtectFail;
pub const DVD_ERROR_InvalidDVD1_0Disc = DVD_ERROR.InvalidDVD1_0Disc;
pub const DVD_ERROR_InvalidDiscRegion = DVD_ERROR.InvalidDiscRegion;
pub const DVD_ERROR_LowParentalLevel = DVD_ERROR.LowParentalLevel;
pub const DVD_ERROR_MacrovisionFail = DVD_ERROR.MacrovisionFail;
pub const DVD_ERROR_IncompatibleSystemAndDecoderRegions = DVD_ERROR.IncompatibleSystemAndDecoderRegions;
pub const DVD_ERROR_IncompatibleDiscAndDecoderRegions = DVD_ERROR.IncompatibleDiscAndDecoderRegions;
pub const DVD_ERROR_CopyProtectOutputFail = DVD_ERROR.CopyProtectOutputFail;
pub const DVD_ERROR_CopyProtectOutputNotSupported = DVD_ERROR.CopyProtectOutputNotSupported;

pub const DVD_WARNING = enum(i32) {
    InvalidDVD1_0Disc = 1,
    FormatNotSupported = 2,
    IllegalNavCommand = 3,
    Open = 4,
    Seek = 5,
    Read = 6,
};
pub const DVD_WARNING_InvalidDVD1_0Disc = DVD_WARNING.InvalidDVD1_0Disc;
pub const DVD_WARNING_FormatNotSupported = DVD_WARNING.FormatNotSupported;
pub const DVD_WARNING_IllegalNavCommand = DVD_WARNING.IllegalNavCommand;
pub const DVD_WARNING_Open = DVD_WARNING.Open;
pub const DVD_WARNING_Seek = DVD_WARNING.Seek;
pub const DVD_WARNING_Read = DVD_WARNING.Read;

pub const DVD_PB_STOPPED = enum(i32) {
    Other = 0,
    NoBranch = 1,
    NoFirstPlayDomain = 2,
    StopCommand = 3,
    Reset = 4,
    DiscEjected = 5,
    IllegalNavCommand = 6,
    PlayPeriodAutoStop = 7,
    PlayChapterAutoStop = 8,
    ParentalFailure = 9,
    RegionFailure = 10,
    MacrovisionFailure = 11,
    DiscReadError = 12,
    CopyProtectFailure = 13,
    CopyProtectOutputFailure = 14,
    CopyProtectOutputNotSupported = 15,
};
pub const DVD_PB_STOPPED_Other = DVD_PB_STOPPED.Other;
pub const DVD_PB_STOPPED_NoBranch = DVD_PB_STOPPED.NoBranch;
pub const DVD_PB_STOPPED_NoFirstPlayDomain = DVD_PB_STOPPED.NoFirstPlayDomain;
pub const DVD_PB_STOPPED_StopCommand = DVD_PB_STOPPED.StopCommand;
pub const DVD_PB_STOPPED_Reset = DVD_PB_STOPPED.Reset;
pub const DVD_PB_STOPPED_DiscEjected = DVD_PB_STOPPED.DiscEjected;
pub const DVD_PB_STOPPED_IllegalNavCommand = DVD_PB_STOPPED.IllegalNavCommand;
pub const DVD_PB_STOPPED_PlayPeriodAutoStop = DVD_PB_STOPPED.PlayPeriodAutoStop;
pub const DVD_PB_STOPPED_PlayChapterAutoStop = DVD_PB_STOPPED.PlayChapterAutoStop;
pub const DVD_PB_STOPPED_ParentalFailure = DVD_PB_STOPPED.ParentalFailure;
pub const DVD_PB_STOPPED_RegionFailure = DVD_PB_STOPPED.RegionFailure;
pub const DVD_PB_STOPPED_MacrovisionFailure = DVD_PB_STOPPED.MacrovisionFailure;
pub const DVD_PB_STOPPED_DiscReadError = DVD_PB_STOPPED.DiscReadError;
pub const DVD_PB_STOPPED_CopyProtectFailure = DVD_PB_STOPPED.CopyProtectFailure;
pub const DVD_PB_STOPPED_CopyProtectOutputFailure = DVD_PB_STOPPED.CopyProtectOutputFailure;
pub const DVD_PB_STOPPED_CopyProtectOutputNotSupported = DVD_PB_STOPPED.CopyProtectOutputNotSupported;

pub const AMGETERRORTEXTPROCA = fn(
    param0: HRESULT,
    param1: ?PSTR,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const AMGETERRORTEXTPROCW = fn(
    param0: HRESULT,
    param1: ?PWSTR,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SNDDEV_ERR = enum(i32) {
    Open = 1,
    Close = 2,
    GetCaps = 3,
    PrepareHeader = 4,
    UnprepareHeader = 5,
    Reset = 6,
    Restart = 7,
    GetPosition = 8,
    Write = 9,
    Pause = 10,
    Stop = 11,
    Start = 12,
    AddBuffer = 13,
    Query = 14,
};
pub const SNDDEV_ERROR_Open = SNDDEV_ERR.Open;
pub const SNDDEV_ERROR_Close = SNDDEV_ERR.Close;
pub const SNDDEV_ERROR_GetCaps = SNDDEV_ERR.GetCaps;
pub const SNDDEV_ERROR_PrepareHeader = SNDDEV_ERR.PrepareHeader;
pub const SNDDEV_ERROR_UnprepareHeader = SNDDEV_ERR.UnprepareHeader;
pub const SNDDEV_ERROR_Reset = SNDDEV_ERR.Reset;
pub const SNDDEV_ERROR_Restart = SNDDEV_ERR.Restart;
pub const SNDDEV_ERROR_GetPosition = SNDDEV_ERR.GetPosition;
pub const SNDDEV_ERROR_Write = SNDDEV_ERR.Write;
pub const SNDDEV_ERROR_Pause = SNDDEV_ERR.Pause;
pub const SNDDEV_ERROR_Stop = SNDDEV_ERR.Stop;
pub const SNDDEV_ERROR_Start = SNDDEV_ERR.Start;
pub const SNDDEV_ERROR_AddBuffer = SNDDEV_ERR.AddBuffer;
pub const SNDDEV_ERROR_Query = SNDDEV_ERR.Query;

pub const MP_TYPE = enum(i32) {
    INT = 0,
    FLOAT = 1,
    BOOL = 2,
    ENUM = 3,
    MAX = 4,
};
pub const MPT_INT = MP_TYPE.INT;
pub const MPT_FLOAT = MP_TYPE.FLOAT;
pub const MPT_BOOL = MP_TYPE.BOOL;
pub const MPT_ENUM = MP_TYPE.ENUM;
pub const MPT_MAX = MP_TYPE.MAX;

pub const MP_CURVE_TYPE = enum(i32) {
    JUMP = 1,
    LINEAR = 2,
    SQUARE = 4,
    INVSQUARE = 8,
    SINE = 16,
};
pub const MP_CURVE_JUMP = MP_CURVE_TYPE.JUMP;
pub const MP_CURVE_LINEAR = MP_CURVE_TYPE.LINEAR;
pub const MP_CURVE_SQUARE = MP_CURVE_TYPE.SQUARE;
pub const MP_CURVE_INVSQUARE = MP_CURVE_TYPE.INVSQUARE;
pub const MP_CURVE_SINE = MP_CURVE_TYPE.SINE;

pub const MP_PARAMINFO = extern struct {
    mpType: MP_TYPE,
    mopCaps: u32,
    mpdMinValue: f32,
    mpdMaxValue: f32,
    mpdNeutralValue: f32,
    szUnitText: [32]u16,
    szLabel: [32]u16,
};

pub const MP_ENVELOPE_SEGMENT = extern struct {
    rtStart: i64,
    rtEnd: i64,
    valStart: f32,
    valEnd: f32,
    iCurve: MP_CURVE_TYPE,
    flags: u32,
};

const IID_IMediaParamInfo_Value = @import("../zig.zig").Guid.initString("6d6cbb60-a223-44aa-842f-a2f06750be6d");
pub const IID_IMediaParamInfo = &IID_IMediaParamInfo_Value;
pub const IMediaParamInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParamCount: fn(
            self: *const IMediaParamInfo,
            pdwParams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamInfo: fn(
            self: *const IMediaParamInfo,
            dwParamIndex: u32,
            pInfo: ?*MP_PARAMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamText: fn(
            self: *const IMediaParamInfo,
            dwParamIndex: u32,
            ppwchText: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumTimeFormats: fn(
            self: *const IMediaParamInfo,
            pdwNumTimeFormats: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedTimeFormat: fn(
            self: *const IMediaParamInfo,
            dwFormatIndex: u32,
            pguidTimeFormat: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTimeFormat: fn(
            self: *const IMediaParamInfo,
            pguidTimeFormat: ?*Guid,
            pTimeData: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetParamCount(self: *const T, pdwParams: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParamInfo.VTable, self.vtable).GetParamCount(@ptrCast(*const IMediaParamInfo, self), pdwParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetParamInfo(self: *const T, dwParamIndex: u32, pInfo: ?*MP_PARAMINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParamInfo.VTable, self.vtable).GetParamInfo(@ptrCast(*const IMediaParamInfo, self), dwParamIndex, pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetParamText(self: *const T, dwParamIndex: u32, ppwchText: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParamInfo.VTable, self.vtable).GetParamText(@ptrCast(*const IMediaParamInfo, self), dwParamIndex, ppwchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetNumTimeFormats(self: *const T, pdwNumTimeFormats: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParamInfo.VTable, self.vtable).GetNumTimeFormats(@ptrCast(*const IMediaParamInfo, self), pdwNumTimeFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetSupportedTimeFormat(self: *const T, dwFormatIndex: u32, pguidTimeFormat: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParamInfo.VTable, self.vtable).GetSupportedTimeFormat(@ptrCast(*const IMediaParamInfo, self), dwFormatIndex, pguidTimeFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetCurrentTimeFormat(self: *const T, pguidTimeFormat: ?*Guid, pTimeData: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParamInfo.VTable, self.vtable).GetCurrentTimeFormat(@ptrCast(*const IMediaParamInfo, self), pguidTimeFormat, pTimeData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaParams_Value = @import("../zig.zig").Guid.initString("6d6cbb61-a223-44aa-842f-a2f06750be6e");
pub const IID_IMediaParams = &IID_IMediaParams_Value;
pub const IMediaParams = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParam: fn(
            self: *const IMediaParams,
            dwParamIndex: u32,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParam: fn(
            self: *const IMediaParams,
            dwParamIndex: u32,
            value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEnvelope: fn(
            self: *const IMediaParams,
            dwParamIndex: u32,
            cSegments: u32,
            pEnvelopeSegments: ?*MP_ENVELOPE_SEGMENT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushEnvelope: fn(
            self: *const IMediaParams,
            dwParamIndex: u32,
            refTimeStart: i64,
            refTimeEnd: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimeFormat: fn(
            self: *const IMediaParams,
            guidTimeFormat: Guid,
            mpTimeData: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_GetParam(self: *const T, dwParamIndex: u32, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParams.VTable, self.vtable).GetParam(@ptrCast(*const IMediaParams, self), dwParamIndex, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_SetParam(self: *const T, dwParamIndex: u32, value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParams.VTable, self.vtable).SetParam(@ptrCast(*const IMediaParams, self), dwParamIndex, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_AddEnvelope(self: *const T, dwParamIndex: u32, cSegments: u32, pEnvelopeSegments: ?*MP_ENVELOPE_SEGMENT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParams.VTable, self.vtable).AddEnvelope(@ptrCast(*const IMediaParams, self), dwParamIndex, cSegments, pEnvelopeSegments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_FlushEnvelope(self: *const T, dwParamIndex: u32, refTimeStart: i64, refTimeEnd: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParams.VTable, self.vtable).FlushEnvelope(@ptrCast(*const IMediaParams, self), dwParamIndex, refTimeStart, refTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_SetTimeFormat(self: *const T, guidTimeFormat: Guid, mpTimeData: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMediaParams.VTable, self.vtable).SetTimeFormat(@ptrCast(*const IMediaParams, self), guidTimeFormat, mpTimeData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VFW_FILTERLIST = extern struct {
    cFilters: u32,
    aClsId: [1]Guid,
};

pub const DXVA2_SampleFlags = enum(i32) {
    _Palette_Changed = 1,
    _SrcRect_Changed = 2,
    _DstRect_Changed = 4,
    _ColorData_Changed = 8,
    _PlanarAlpha_Changed = 16,
    _RFF = 65536,
    _TFF = 131072,
    _RFF_TFF_Present = 262144,
    sMask = -65505,
};
pub const DXVA2_SampleFlag_Palette_Changed = DXVA2_SampleFlags._Palette_Changed;
pub const DXVA2_SampleFlag_SrcRect_Changed = DXVA2_SampleFlags._SrcRect_Changed;
pub const DXVA2_SampleFlag_DstRect_Changed = DXVA2_SampleFlags._DstRect_Changed;
pub const DXVA2_SampleFlag_ColorData_Changed = DXVA2_SampleFlags._ColorData_Changed;
pub const DXVA2_SampleFlag_PlanarAlpha_Changed = DXVA2_SampleFlags._PlanarAlpha_Changed;
pub const DXVA2_SampleFlag_RFF = DXVA2_SampleFlags._RFF;
pub const DXVA2_SampleFlag_TFF = DXVA2_SampleFlags._TFF;
pub const DXVA2_SampleFlag_RFF_TFF_Present = DXVA2_SampleFlags._RFF_TFF_Present;
pub const DXVA2_SampleFlagsMask = DXVA2_SampleFlags.sMask;

pub const DXVA2_DestinationFlags = enum(i32) {
    _Background_Changed = 1,
    _TargetRect_Changed = 2,
    _ColorData_Changed = 4,
    _Alpha_Changed = 8,
    _RFF = 65536,
    _TFF = 131072,
    _RFF_TFF_Present = 262144,
    Mask = -65521,
};
pub const DXVA2_DestinationFlag_Background_Changed = DXVA2_DestinationFlags._Background_Changed;
pub const DXVA2_DestinationFlag_TargetRect_Changed = DXVA2_DestinationFlags._TargetRect_Changed;
pub const DXVA2_DestinationFlag_ColorData_Changed = DXVA2_DestinationFlags._ColorData_Changed;
pub const DXVA2_DestinationFlag_Alpha_Changed = DXVA2_DestinationFlags._Alpha_Changed;
pub const DXVA2_DestinationFlag_RFF = DXVA2_DestinationFlags._RFF;
pub const DXVA2_DestinationFlag_TFF = DXVA2_DestinationFlags._TFF;
pub const DXVA2_DestinationFlag_RFF_TFF_Present = DXVA2_DestinationFlags._RFF_TFF_Present;
pub const DXVA2_DestinationFlagMask = DXVA2_DestinationFlags.Mask;

pub const DXVA2_VIDEOSAMPLE = extern struct {
    Start: i64,
    End: i64,
    SampleFormat: DXVA2_ExtendedFormat,
    SampleFlags: u32,
    SrcResource: ?*anyopaque,
    SrcRect: RECT,
    DstRect: RECT,
    Pal: [16]DXVA2_AYUVSample8,
    PlanarAlpha: DXVA2_Fixed32,
};

pub const DXVA2_VIDEOPROCESSBLT = extern struct {
    TargetFrame: i64,
    TargetRect: RECT,
    ConstrictionSize: SIZE,
    StreamingFlags: u32,
    BackgroundColor: DXVA2_AYUVSample16,
    DestFormat: DXVA2_ExtendedFormat,
    DestFlags: u32,
    ProcAmpValues: DXVA2_ProcAmpValues,
    Alpha: DXVA2_Fixed32,
    NoiseFilterLuma: DXVA2_FilterValues,
    NoiseFilterChroma: DXVA2_FilterValues,
    DetailFilterLuma: DXVA2_FilterValues,
    DetailFilterChroma: DXVA2_FilterValues,
    pSrcSurfaces: ?*DXVA2_VIDEOSAMPLE,
    NumSrcSurfaces: u32,
};

pub const PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT = fn(
    pVideoDesc: ?*const DXVA2_VideoDesc,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS = fn(
    pVideoDesc: ?*const DXVA2_VideoDesc,
    Count: u32,
    pFormats: [*]D3DFORMAT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETVIDEOPROCESSORCAPS = fn(
    pVideoDesc: ?*const DXVA2_VideoDesc,
    RenderTargetFormat: D3DFORMAT,
    pCaps: ?*DXVA2_VideoProcessorCaps,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT = fn(
    pVideoDesc: ?*const DXVA2_VideoDesc,
    RenderTargetFormat: D3DFORMAT,
    pCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS = fn(
    pVideoDesc: ?*const DXVA2_VideoDesc,
    RenderTargetFormat: D3DFORMAT,
    Count: u32,
    pFormats: [*]D3DFORMAT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETPROCAMPRANGE = fn(
    pVideoDesc: ?*const DXVA2_VideoDesc,
    RenderTargetFormat: D3DFORMAT,
    ProcAmpCap: u32,
    pRange: ?*DXVA2_ValueRange,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_GETFILTERPROPERTYRANGE = fn(
    pVideoDesc: ?*const DXVA2_VideoDesc,
    RenderTargetFormat: D3DFORMAT,
    FilterSetting: u32,
    pRange: ?*DXVA2_ValueRange,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_CREATEVIDEOPROCESSDEVICE = fn(
    pD3DD9: ?*IDirect3DDevice9,
    pVideoDesc: ?*const DXVA2_VideoDesc,
    RenderTargetFormat: D3DFORMAT,
    MaxSubStreams: u32,
    phDevice: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_DESTROYVIDEOPROCESSDEVICE = fn(
    hDevice: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_VIDEOPROCESSBEGINFRAME = fn(
    hDevice: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_VIDEOPROCESSENDFRAME = fn(
    hDevice: ?HANDLE,
    pHandleComplete: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_VIDEOPROCESSSETRENDERTARGET = fn(
    hDevice: ?HANDLE,
    pRenderTarget: ?*IDirect3DSurface9,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVA2SW_VIDEOPROCESSBLT = fn(
    hDevice: ?HANDLE,
    pBlt: ?*const DXVA2_VIDEOPROCESSBLT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DXVA2SW_CALLBACKS = extern struct {
    Size: u32,
    GetVideoProcessorRenderTargetCount: ?PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT,
    GetVideoProcessorRenderTargets: ?PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS,
    GetVideoProcessorCaps: ?PDXVA2SW_GETVIDEOPROCESSORCAPS,
    GetVideoProcessorSubStreamFormatCount: ?PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT,
    GetVideoProcessorSubStreamFormats: ?PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS,
    GetProcAmpRange: ?PDXVA2SW_GETPROCAMPRANGE,
    GetFilterPropertyRange: ?PDXVA2SW_GETFILTERPROPERTYRANGE,
    CreateVideoProcessDevice: ?PDXVA2SW_CREATEVIDEOPROCESSDEVICE,
    DestroyVideoProcessDevice: ?PDXVA2SW_DESTROYVIDEOPROCESSDEVICE,
    VideoProcessBeginFrame: ?PDXVA2SW_VIDEOPROCESSBEGINFRAME,
    VideoProcessEndFrame: ?PDXVA2SW_VIDEOPROCESSENDFRAME,
    VideoProcessSetRenderTarget: ?PDXVA2SW_VIDEOPROCESSSETRENDERTARGET,
    VideoProcessBlt: ?PDXVA2SW_VIDEOPROCESSBLT,
};

pub const DXVA2Trace_DecodeDevCreatedData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pD3DDevice: u64,
    DeviceGuid: Guid,
    Width: u32,
    Height: u32,
    Enter: BOOL,
};

pub const DXVA2Trace_DecodeDeviceData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    Enter: BOOL,
};

pub const DXVA2Trace_DecodeDevBeginFrameData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pRenderTarget: u64,
    Enter: BOOL,
};

pub const DXVA2Trace_DecodeDevGetBufferData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    BufferType: u32,
    Enter: BOOL,
};

pub const DXVA2Trace_VideoProcessDevCreatedData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pD3DDevice: u64,
    DeviceGuid: Guid,
    RTFourCC: u32,
    Width: u32,
    Height: u32,
    Enter: BOOL,
};

pub const DXVA2Trace_VideoProcessDeviceData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    Enter: BOOL,
};

pub const DXVA2TraceVideoProcessBltData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pRenderTarget: u64,
    TargetFrameTime: u64,
    TargetRect: RECT,
    Enter: BOOL,
};

pub const AMPlayListItemFlags = enum(i32) {
    SKIP = 1,
    BIND = 2,
};
pub const AMPLAYLISTITEM_CANSKIP = AMPlayListItemFlags.SKIP;
pub const AMPLAYLISTITEM_CANBIND = AMPlayListItemFlags.BIND;

const IID_IAMPlayListItem_Value = @import("../zig.zig").Guid.initString("56a868ff-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAMPlayListItem = &IID_IAMPlayListItem_Value;
pub const IAMPlayListItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFlags: fn(
            self: *const IAMPlayListItem,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceCount: fn(
            self: *const IAMPlayListItem,
            pdwSources: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceURL: fn(
            self: *const IAMPlayListItem,
            dwSourceIndex: u32,
            pbstrURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceStart: fn(
            self: *const IAMPlayListItem,
            dwSourceIndex: u32,
            prtStart: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceDuration: fn(
            self: *const IAMPlayListItem,
            dwSourceIndex: u32,
            prtDuration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceStartMarker: fn(
            self: *const IAMPlayListItem,
            dwSourceIndex: u32,
            pdwMarker: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEndMarker: fn(
            self: *const IAMPlayListItem,
            dwSourceIndex: u32,
            pdwMarker: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceStartMarkerName: fn(
            self: *const IAMPlayListItem,
            dwSourceIndex: u32,
            pbstrStartMarker: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEndMarkerName: fn(
            self: *const IAMPlayListItem,
            dwSourceIndex: u32,
            pbstrEndMarker: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkURL: fn(
            self: *const IAMPlayListItem,
            pbstrURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScanDuration: fn(
            self: *const IAMPlayListItem,
            dwSourceIndex: u32,
            prtScanDuration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetFlags(@ptrCast(*const IAMPlayListItem, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceCount(self: *const T, pdwSources: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetSourceCount(@ptrCast(*const IAMPlayListItem, self), pdwSources);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceURL(self: *const T, dwSourceIndex: u32, pbstrURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetSourceURL(@ptrCast(*const IAMPlayListItem, self), dwSourceIndex, pbstrURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceStart(self: *const T, dwSourceIndex: u32, prtStart: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetSourceStart(@ptrCast(*const IAMPlayListItem, self), dwSourceIndex, prtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceDuration(self: *const T, dwSourceIndex: u32, prtDuration: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetSourceDuration(@ptrCast(*const IAMPlayListItem, self), dwSourceIndex, prtDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceStartMarker(self: *const T, dwSourceIndex: u32, pdwMarker: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetSourceStartMarker(@ptrCast(*const IAMPlayListItem, self), dwSourceIndex, pdwMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceEndMarker(self: *const T, dwSourceIndex: u32, pdwMarker: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetSourceEndMarker(@ptrCast(*const IAMPlayListItem, self), dwSourceIndex, pdwMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceStartMarkerName(self: *const T, dwSourceIndex: u32, pbstrStartMarker: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetSourceStartMarkerName(@ptrCast(*const IAMPlayListItem, self), dwSourceIndex, pbstrStartMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceEndMarkerName(self: *const T, dwSourceIndex: u32, pbstrEndMarker: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetSourceEndMarkerName(@ptrCast(*const IAMPlayListItem, self), dwSourceIndex, pbstrEndMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetLinkURL(self: *const T, pbstrURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetLinkURL(@ptrCast(*const IAMPlayListItem, self), pbstrURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetScanDuration(self: *const T, dwSourceIndex: u32, prtScanDuration: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayListItem.VTable, self.vtable).GetScanDuration(@ptrCast(*const IAMPlayListItem, self), dwSourceIndex, prtScanDuration);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMPlayListFlags = enum(i32) {
    STARTINSCANMODE = 1,
    FORCEBANNER = 2,
};
pub const AMPLAYLIST_STARTINSCANMODE = AMPlayListFlags.STARTINSCANMODE;
pub const AMPLAYLIST_FORCEBANNER = AMPlayListFlags.FORCEBANNER;

pub const AMPlayListEventFlags = enum(i32) {
    RESUME = 0,
    BREAK = 1,
    NEXT = 2,
    MASK = 15,
    REFRESH = 16,
};
pub const AMPLAYLISTEVENT_RESUME = AMPlayListEventFlags.RESUME;
pub const AMPLAYLISTEVENT_BREAK = AMPlayListEventFlags.BREAK;
pub const AMPLAYLISTEVENT_NEXT = AMPlayListEventFlags.NEXT;
pub const AMPLAYLISTEVENT_MASK = AMPlayListEventFlags.MASK;
pub const AMPLAYLISTEVENT_REFRESH = AMPlayListEventFlags.REFRESH;

const IID_IAMPlayList_Value = @import("../zig.zig").Guid.initString("56a868fe-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAMPlayList = &IID_IAMPlayList_Value;
pub const IAMPlayList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFlags: fn(
            self: *const IAMPlayList,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemCount: fn(
            self: *const IAMPlayList,
            pdwItems: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const IAMPlayList,
            dwItemIndex: u32,
            ppItem: ?*?*IAMPlayListItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamedEvent: fn(
            self: *const IAMPlayList,
            pwszEventName: ?PWSTR,
            dwItemIndex: u32,
            ppItem: ?*?*IAMPlayListItem,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRepeatInfo: fn(
            self: *const IAMPlayList,
            pdwRepeatCount: ?*u32,
            pdwRepeatStart: ?*u32,
            pdwRepeatEnd: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayList.VTable, self.vtable).GetFlags(@ptrCast(*const IAMPlayList, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetItemCount(self: *const T, pdwItems: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayList.VTable, self.vtable).GetItemCount(@ptrCast(*const IAMPlayList, self), pdwItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetItem(self: *const T, dwItemIndex: u32, ppItem: ?*?*IAMPlayListItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayList.VTable, self.vtable).GetItem(@ptrCast(*const IAMPlayList, self), dwItemIndex, ppItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetNamedEvent(self: *const T, pwszEventName: ?PWSTR, dwItemIndex: u32, ppItem: ?*?*IAMPlayListItem, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayList.VTable, self.vtable).GetNamedEvent(@ptrCast(*const IAMPlayList, self), pwszEventName, dwItemIndex, ppItem, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetRepeatInfo(self: *const T, pdwRepeatCount: ?*u32, pdwRepeatStart: ?*u32, pdwRepeatEnd: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMPlayList.VTable, self.vtable).GetRepeatInfo(@ptrCast(*const IAMPlayList, self), pdwRepeatCount, pdwRepeatStart, pdwRepeatEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpecifyParticularPages_Value = @import("../zig.zig").Guid.initString("4c437b91-6e9e-11d1-a704-006097c4e476");
pub const IID_ISpecifyParticularPages = &IID_ISpecifyParticularPages_Value;
pub const ISpecifyParticularPages = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPages: fn(
            self: *const ISpecifyParticularPages,
            guidWhatPages: ?*const Guid,
            pPages: ?*CAUUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpecifyParticularPages_GetPages(self: *const T, guidWhatPages: ?*const Guid, pPages: ?*CAUUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpecifyParticularPages.VTable, self.vtable).GetPages(@ptrCast(*const ISpecifyParticularPages, self), guidWhatPages, pPages);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMRebuild_Value = @import("../zig.zig").Guid.initString("02ef04dd-7580-11d1-bece-00c04fb6e937");
pub const IID_IAMRebuild = &IID_IAMRebuild_Value;
pub const IAMRebuild = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RebuildNow: fn(
            self: *const IAMRebuild,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMRebuild_RebuildNow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAMRebuild.VTable, self.vtable).RebuildNow(@ptrCast(*const IAMRebuild, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBufferingTime_Value = @import("../zig.zig").Guid.initString("1e00486a-78dd-11d2-8dd3-006097c9a2b2");
pub const IID_IBufferingTime = &IID_IBufferingTime_Value;
pub const IBufferingTime = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBufferingTime: fn(
            self: *const IBufferingTime,
            pdwMilliseconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBufferingTime: fn(
            self: *const IBufferingTime,
            dwMilliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBufferingTime_GetBufferingTime(self: *const T, pdwMilliseconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBufferingTime.VTable, self.vtable).GetBufferingTime(@ptrCast(*const IBufferingTime, self), pdwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBufferingTime_SetBufferingTime(self: *const T, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBufferingTime.VTable, self.vtable).SetBufferingTime(@ptrCast(*const IBufferingTime, self), dwMilliseconds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SystemTuningSpaces_Value = @import("../zig.zig").Guid.initString("d02aac50-027e-11d3-9d8e-00c04f72d980");
pub const CLSID_SystemTuningSpaces = &CLSID_SystemTuningSpaces_Value;

const CLSID_TuningSpace_Value = @import("../zig.zig").Guid.initString("5ffdc5e6-b83a-4b55-b6e8-c69e765fe9db");
pub const CLSID_TuningSpace = &CLSID_TuningSpace_Value;

const CLSID_ChannelIDTuningSpace_Value = @import("../zig.zig").Guid.initString("cc829a2f-3365-463f-af13-81dbb6f3a555");
pub const CLSID_ChannelIDTuningSpace = &CLSID_ChannelIDTuningSpace_Value;

const CLSID_ATSCTuningSpace_Value = @import("../zig.zig").Guid.initString("a2e30750-6c3d-11d3-b653-00c04f79498e");
pub const CLSID_ATSCTuningSpace = &CLSID_ATSCTuningSpace_Value;

const CLSID_DigitalCableTuningSpace_Value = @import("../zig.zig").Guid.initString("d9bb4cee-b87a-47f1-ac92-b08d9c7813fc");
pub const CLSID_DigitalCableTuningSpace = &CLSID_DigitalCableTuningSpace_Value;

const CLSID_AnalogRadioTuningSpace_Value = @import("../zig.zig").Guid.initString("8a674b4c-1f63-11d3-b64c-00c04f79498e");
pub const CLSID_AnalogRadioTuningSpace = &CLSID_AnalogRadioTuningSpace_Value;

const CLSID_AuxInTuningSpace_Value = @import("../zig.zig").Guid.initString("f9769a06-7aca-4e39-9cfb-97bb35f0e77e");
pub const CLSID_AuxInTuningSpace = &CLSID_AuxInTuningSpace_Value;

const CLSID_AnalogTVTuningSpace_Value = @import("../zig.zig").Guid.initString("8a674b4d-1f63-11d3-b64c-00c04f79498e");
pub const CLSID_AnalogTVTuningSpace = &CLSID_AnalogTVTuningSpace_Value;

const CLSID_DVBTuningSpace_Value = @import("../zig.zig").Guid.initString("c6b14b32-76aa-4a86-a7ac-5c79aaf58da7");
pub const CLSID_DVBTuningSpace = &CLSID_DVBTuningSpace_Value;

const CLSID_DVBSTuningSpace_Value = @import("../zig.zig").Guid.initString("b64016f3-c9a2-4066-96f0-bd9563314726");
pub const CLSID_DVBSTuningSpace = &CLSID_DVBSTuningSpace_Value;

const CLSID_ComponentTypes_Value = @import("../zig.zig").Guid.initString("a1a2b1c4-0e3a-11d3-9d8e-00c04f72d980");
pub const CLSID_ComponentTypes = &CLSID_ComponentTypes_Value;

const CLSID_ComponentType_Value = @import("../zig.zig").Guid.initString("823535a0-0318-11d3-9d8e-00c04f72d980");
pub const CLSID_ComponentType = &CLSID_ComponentType_Value;

const CLSID_LanguageComponentType_Value = @import("../zig.zig").Guid.initString("1be49f30-0e1b-11d3-9d8e-00c04f72d980");
pub const CLSID_LanguageComponentType = &CLSID_LanguageComponentType_Value;

const CLSID_MPEG2ComponentType_Value = @import("../zig.zig").Guid.initString("418008f3-cf67-4668-9628-10dc52be1d08");
pub const CLSID_MPEG2ComponentType = &CLSID_MPEG2ComponentType_Value;

const CLSID_ATSCComponentType_Value = @import("../zig.zig").Guid.initString("a8dcf3d5-0780-4ef4-8a83-2cffaacb8ace");
pub const CLSID_ATSCComponentType = &CLSID_ATSCComponentType_Value;

const CLSID_Components_Value = @import("../zig.zig").Guid.initString("809b6661-94c4-49e6-b6ec-3f0f862215aa");
pub const CLSID_Components = &CLSID_Components_Value;

const CLSID_Component_Value = @import("../zig.zig").Guid.initString("59dc47a8-116c-11d3-9d8e-00c04f72d980");
pub const CLSID_Component = &CLSID_Component_Value;

const CLSID_MPEG2Component_Value = @import("../zig.zig").Guid.initString("055cb2d7-2969-45cd-914b-76890722f112");
pub const CLSID_MPEG2Component = &CLSID_MPEG2Component_Value;

const CLSID_AnalogAudioComponentType_Value = @import("../zig.zig").Guid.initString("28ab0005-e845-4ffa-aa9b-f4665236141c");
pub const CLSID_AnalogAudioComponentType = &CLSID_AnalogAudioComponentType_Value;

const CLSID_TuneRequest_Value = @import("../zig.zig").Guid.initString("b46e0d38-ab35-4a06-a137-70576b01b39f");
pub const CLSID_TuneRequest = &CLSID_TuneRequest_Value;

const CLSID_ChannelIDTuneRequest_Value = @import("../zig.zig").Guid.initString("3a9428a7-31a4-45e9-9efb-e055bf7bb3db");
pub const CLSID_ChannelIDTuneRequest = &CLSID_ChannelIDTuneRequest_Value;

const CLSID_ChannelTuneRequest_Value = @import("../zig.zig").Guid.initString("0369b4e5-45b6-11d3-b650-00c04f79498e");
pub const CLSID_ChannelTuneRequest = &CLSID_ChannelTuneRequest_Value;

const CLSID_ATSCChannelTuneRequest_Value = @import("../zig.zig").Guid.initString("0369b4e6-45b6-11d3-b650-00c04f79498e");
pub const CLSID_ATSCChannelTuneRequest = &CLSID_ATSCChannelTuneRequest_Value;

const CLSID_DigitalCableTuneRequest_Value = @import("../zig.zig").Guid.initString("26ec0b63-aa90-458a-8df4-5659f2c8a18a");
pub const CLSID_DigitalCableTuneRequest = &CLSID_DigitalCableTuneRequest_Value;

const CLSID_MPEG2TuneRequest_Value = @import("../zig.zig").Guid.initString("0955ac62-bf2e-4cba-a2b9-a63f772d46cf");
pub const CLSID_MPEG2TuneRequest = &CLSID_MPEG2TuneRequest_Value;

const CLSID_MPEG2TuneRequestFactory_Value = @import("../zig.zig").Guid.initString("2c63e4eb-4cea-41b8-919c-e947ea19a77c");
pub const CLSID_MPEG2TuneRequestFactory = &CLSID_MPEG2TuneRequestFactory_Value;

const CLSID_Locator_Value = @import("../zig.zig").Guid.initString("0888c883-ac4f-4943-b516-2c38d9b34562");
pub const CLSID_Locator = &CLSID_Locator_Value;

const CLSID_DigitalLocator_Value = @import("../zig.zig").Guid.initString("6e50cc0d-c19b-4bf6-810b-5bd60761f5cc");
pub const CLSID_DigitalLocator = &CLSID_DigitalLocator_Value;

const CLSID_AnalogLocator_Value = @import("../zig.zig").Guid.initString("49638b91-48ab-48b7-a47a-7d0e75a08ede");
pub const CLSID_AnalogLocator = &CLSID_AnalogLocator_Value;

const CLSID_ATSCLocator_Value = @import("../zig.zig").Guid.initString("8872ff1b-98fa-4d7a-8d93-c9f1055f85bb");
pub const CLSID_ATSCLocator = &CLSID_ATSCLocator_Value;

const CLSID_DigitalCableLocator_Value = @import("../zig.zig").Guid.initString("03c06416-d127-407a-ab4c-fdd279abbe5d");
pub const CLSID_DigitalCableLocator = &CLSID_DigitalCableLocator_Value;

const CLSID_DVBTLocator_Value = @import("../zig.zig").Guid.initString("9cd64701-bdf3-4d14-8e03-f12983d86664");
pub const CLSID_DVBTLocator = &CLSID_DVBTLocator_Value;

const CLSID_DVBTLocator2_Value = @import("../zig.zig").Guid.initString("efe3fa02-45d7-4920-be96-53fa7f35b0e6");
pub const CLSID_DVBTLocator2 = &CLSID_DVBTLocator2_Value;

const CLSID_DVBSLocator_Value = @import("../zig.zig").Guid.initString("1df7d126-4050-47f0-a7cf-4c4ca9241333");
pub const CLSID_DVBSLocator = &CLSID_DVBSLocator_Value;

const CLSID_DVBCLocator_Value = @import("../zig.zig").Guid.initString("c531d9fd-9685-4028-8b68-6e1232079f1e");
pub const CLSID_DVBCLocator = &CLSID_DVBCLocator_Value;

const CLSID_ISDBSLocator_Value = @import("../zig.zig").Guid.initString("6504afed-a629-455c-a7f1-04964dea5cc4");
pub const CLSID_ISDBSLocator = &CLSID_ISDBSLocator_Value;

const CLSID_DVBTuneRequest_Value = @import("../zig.zig").Guid.initString("15d6504a-5494-499c-886c-973c9e53b9f1");
pub const CLSID_DVBTuneRequest = &CLSID_DVBTuneRequest_Value;

const CLSID_CreatePropBagOnRegKey_Value = @import("../zig.zig").Guid.initString("8a674b49-1f63-11d3-b64c-00c04f79498e");
pub const CLSID_CreatePropBagOnRegKey = &CLSID_CreatePropBagOnRegKey_Value;

const CLSID_BroadcastEventService_Value = @import("../zig.zig").Guid.initString("0b3ffb92-0919-4934-9d5b-619c719d0202");
pub const CLSID_BroadcastEventService = &CLSID_BroadcastEventService_Value;

const CLSID_TunerMarshaler_Value = @import("../zig.zig").Guid.initString("6438570b-0c08-4a25-9504-8012bb4d50cf");
pub const CLSID_TunerMarshaler = &CLSID_TunerMarshaler_Value;

const CLSID_PersistTuneXmlUtility_Value = @import("../zig.zig").Guid.initString("e77026b0-b97f-4cbb-b7fb-f4f03ad69f11");
pub const CLSID_PersistTuneXmlUtility = &CLSID_PersistTuneXmlUtility_Value;

const CLSID_ESEventService_Value = @import("../zig.zig").Guid.initString("c20447fc-ec60-475e-813f-d2b0a6decefe");
pub const CLSID_ESEventService = &CLSID_ESEventService_Value;

const CLSID_ESEventFactory_Value = @import("../zig.zig").Guid.initString("8e8a07da-71f8-40c1-a929-5e3a868ac2c6");
pub const CLSID_ESEventFactory = &CLSID_ESEventFactory_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICreatePropBagOnRegKey_Value = @import("../zig.zig").Guid.initString("8a674b48-1f63-11d3-b64c-00c04f79498e");
pub const IID_ICreatePropBagOnRegKey = &IID_ICreatePropBagOnRegKey_Value;
pub const ICreatePropBagOnRegKey = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const ICreatePropBagOnRegKey,
            hkey: ?HKEY,
            subkey: ?[*:0]const u16,
            ulOptions: u32,
            samDesired: u32,
            iid: ?*const Guid,
            ppBag: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreatePropBagOnRegKey_Create(self: *const T, hkey: ?HKEY, subkey: ?[*:0]const u16, ulOptions: u32, samDesired: u32, iid: ?*const Guid, ppBag: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreatePropBagOnRegKey.VTable, self.vtable).Create(@ptrCast(*const ICreatePropBagOnRegKey, self), hkey, subkey, ulOptions, samDesired, iid, ppBag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DISPID_TUNER = enum(i32) {
    TUNER_TS_UNIQUENAME = 1,
    TUNER_TS_FRIENDLYNAME = 2,
    TUNER_TS_CLSID = 3,
    TUNER_TS_NETWORKTYPE = 4,
    TUNER_TS__NETWORKTYPE = 5,
    TUNER_TS_CREATETUNEREQUEST = 6,
    TUNER_TS_ENUMCATEGORYGUIDS = 7,
    TUNER_TS_ENUMDEVICEMONIKERS = 8,
    TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES = 9,
    TUNER_TS_FREQMAP = 10,
    TUNER_TS_DEFLOCATOR = 11,
    TUNER_TS_CLONE = 12,
    // TUNER_TR_TUNINGSPACE = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_TR_COMPONENTS = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_TR_CLONE = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_TR_LOCATOR = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_CT_CATEGORY = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_CT_MEDIAMAJORTYPE = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_CT__MEDIAMAJORTYPE = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_CT_MEDIASUBTYPE = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_CT__MEDIASUBTYPE = 5, this enum value conflicts with TUNER_TS__NETWORKTYPE
    // TUNER_CT_MEDIAFORMATTYPE = 6, this enum value conflicts with TUNER_TS_CREATETUNEREQUEST
    // TUNER_CT__MEDIAFORMATTYPE = 7, this enum value conflicts with TUNER_TS_ENUMCATEGORYGUIDS
    // TUNER_CT_MEDIATYPE = 8, this enum value conflicts with TUNER_TS_ENUMDEVICEMONIKERS
    // TUNER_CT_CLONE = 9, this enum value conflicts with TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES
    TUNER_LCT_LANGID = 100,
    TUNER_MP2CT_TYPE = 200,
    TUNER_ATSCCT_FLAGS = 300,
    // TUNER_L_CARRFREQ = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_L_INNERFECMETHOD = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_L_INNERFECRATE = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_L_OUTERFECMETHOD = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_L_OUTERFECRATE = 5, this enum value conflicts with TUNER_TS__NETWORKTYPE
    // TUNER_L_MOD = 6, this enum value conflicts with TUNER_TS_CREATETUNEREQUEST
    // TUNER_L_SYMRATE = 7, this enum value conflicts with TUNER_TS_ENUMCATEGORYGUIDS
    // TUNER_L_CLONE = 8, this enum value conflicts with TUNER_TS_ENUMDEVICEMONIKERS
    TUNER_L_ATSC_PHYS_CHANNEL = 201,
    TUNER_L_ATSC_TSID = 202,
    TUNER_L_ATSC_MP2_PROGNO = 203,
    TUNER_L_DVBT_BANDWIDTH = 301,
    TUNER_L_DVBT_LPINNERFECMETHOD = 302,
    TUNER_L_DVBT_LPINNERFECRATE = 303,
    TUNER_L_DVBT_GUARDINTERVAL = 304,
    TUNER_L_DVBT_HALPHA = 305,
    TUNER_L_DVBT_TRANSMISSIONMODE = 306,
    TUNER_L_DVBT_INUSE = 307,
    TUNER_L_DVBT2_PHYSICALLAYERPIPEID = 351,
    TUNER_L_DVBS_POLARISATION = 401,
    TUNER_L_DVBS_WEST = 402,
    TUNER_L_DVBS_ORBITAL = 403,
    TUNER_L_DVBS_AZIMUTH = 404,
    TUNER_L_DVBS_ELEVATION = 405,
    TUNER_L_DVBS2_DISEQ_LNB_SOURCE = 406,
    TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE = 407,
    TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE = 408,
    TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE = 409,
    TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE = 410,
    TUNER_L_DVBS2_ROLLOFF = 411,
    TUNER_L_DVBS2_PILOT = 412,
    TUNER_L_ANALOG_STANDARD = 601,
    TUNER_L_DTV_O_MAJOR_CHANNEL = 701,
    // TUNER_C_TYPE = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_C_STATUS = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_C_LANGID = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_C_DESCRIPTION = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_C_CLONE = 5, this enum value conflicts with TUNER_TS__NETWORKTYPE
    TUNER_C_MP2_PID = 101,
    TUNER_C_MP2_PCRPID = 102,
    TUNER_C_MP2_PROGNO = 103,
    // TUNER_C_ANALOG_AUDIO = 201, this enum value conflicts with TUNER_L_ATSC_PHYS_CHANNEL
    // TUNER_TS_DVB_SYSTEMTYPE = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_DVB2_NETWORK_ID = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    TUNER_TS_DVBS_LOW_OSC_FREQ = 1001,
    TUNER_TS_DVBS_HI_OSC_FREQ = 1002,
    TUNER_TS_DVBS_LNB_SWITCH_FREQ = 1003,
    TUNER_TS_DVBS_INPUT_RANGE = 1004,
    TUNER_TS_DVBS_SPECTRAL_INVERSION = 1005,
    // TUNER_TS_AR_MINFREQUENCY = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_AR_MAXFREQUENCY = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // TUNER_TS_AR_STEP = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    TUNER_TS_AR_COUNTRYCODE = 104,
    // TUNER_TS_AUX_COUNTRYCODE = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_ATV_MINCHANNEL = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_ATV_MAXCHANNEL = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // TUNER_TS_ATV_INPUTTYPE = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    // TUNER_TS_ATV_COUNTRYCODE = 104, this enum value conflicts with TUNER_TS_AR_COUNTRYCODE
    // TUNER_TS_ATSC_MINMINORCHANNEL = 201, this enum value conflicts with TUNER_L_ATSC_PHYS_CHANNEL
    // TUNER_TS_ATSC_MAXMINORCHANNEL = 202, this enum value conflicts with TUNER_L_ATSC_TSID
    // TUNER_TS_ATSC_MINPHYSCHANNEL = 203, this enum value conflicts with TUNER_L_ATSC_MP2_PROGNO
    TUNER_TS_ATSC_MAXPHYSCHANNEL = 204,
    // TUNER_TS_DC_MINMAJORCHANNEL = 301, this enum value conflicts with TUNER_L_DVBT_BANDWIDTH
    // TUNER_TS_DC_MAXMAJORCHANNEL = 302, this enum value conflicts with TUNER_L_DVBT_LPINNERFECMETHOD
    // TUNER_TS_DC_MINSOURCEID = 303, this enum value conflicts with TUNER_L_DVBT_LPINNERFECRATE
    // TUNER_TS_DC_MAXSOURCEID = 304, this enum value conflicts with TUNER_L_DVBT_GUARDINTERVAL
    // CHTUNER_ATVAC_CHANNEL = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_ATVDC_SYSTEM = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_ATVDC_CONTENT = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // CHTUNER_CIDTR_CHANNELID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_CTR_CHANNEL = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_ACTR_MINOR_CHANNEL = 201, this enum value conflicts with TUNER_L_ATSC_PHYS_CHANNEL
    // CHTUNER_DCTR_MAJOR_CHANNEL = 301, this enum value conflicts with TUNER_L_DVBT_BANDWIDTH
    // CHTUNER_DCTR_SRCID = 302, this enum value conflicts with TUNER_L_DVBT_LPINNERFECMETHOD
    // DVBTUNER_DVBC_ATTRIBUTESVALID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // DVBTUNER_DVBC_PID = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // DVBTUNER_DVBC_TAG = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    // DVBTUNER_DVBC_COMPONENTTYPE = 104, this enum value conflicts with TUNER_TS_AR_COUNTRYCODE
    // DVBTUNER_ONID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // DVBTUNER_TSID = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // DVBTUNER_SID = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    // MP2TUNER_TSID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // MP2TUNER_PROGNO = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // MP2TUNERFACTORY_CREATETUNEREQUEST = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
};
pub const DISPID_TUNER_TS_UNIQUENAME = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_TS_FRIENDLYNAME = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_TS_CLSID = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_TS_NETWORKTYPE = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_TS__NETWORKTYPE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_TS_CREATETUNEREQUEST = DISPID_TUNER.TUNER_TS_CREATETUNEREQUEST;
pub const DISPID_TUNER_TS_ENUMCATEGORYGUIDS = DISPID_TUNER.TUNER_TS_ENUMCATEGORYGUIDS;
pub const DISPID_TUNER_TS_ENUMDEVICEMONIKERS = DISPID_TUNER.TUNER_TS_ENUMDEVICEMONIKERS;
pub const DISPID_TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES = DISPID_TUNER.TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES;
pub const DISPID_TUNER_TS_FREQMAP = DISPID_TUNER.TUNER_TS_FREQMAP;
pub const DISPID_TUNER_TS_DEFLOCATOR = DISPID_TUNER.TUNER_TS_DEFLOCATOR;
pub const DISPID_TUNER_TS_CLONE = DISPID_TUNER.TUNER_TS_CLONE;
pub const DISPID_TUNER_TR_TUNINGSPACE = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_TR_COMPONENTS = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_TR_CLONE = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_TR_LOCATOR = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_CT_CATEGORY = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_CT_MEDIAMAJORTYPE = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_CT__MEDIAMAJORTYPE = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_CT_MEDIASUBTYPE = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_CT__MEDIASUBTYPE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_CT_MEDIAFORMATTYPE = DISPID_TUNER.TUNER_TS_CREATETUNEREQUEST;
pub const DISPID_TUNER_CT__MEDIAFORMATTYPE = DISPID_TUNER.TUNER_TS_ENUMCATEGORYGUIDS;
pub const DISPID_TUNER_CT_MEDIATYPE = DISPID_TUNER.TUNER_TS_ENUMDEVICEMONIKERS;
pub const DISPID_TUNER_CT_CLONE = DISPID_TUNER.TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES;
pub const DISPID_TUNER_LCT_LANGID = DISPID_TUNER.TUNER_LCT_LANGID;
pub const DISPID_TUNER_MP2CT_TYPE = DISPID_TUNER.TUNER_MP2CT_TYPE;
pub const DISPID_TUNER_ATSCCT_FLAGS = DISPID_TUNER.TUNER_ATSCCT_FLAGS;
pub const DISPID_TUNER_L_CARRFREQ = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_L_INNERFECMETHOD = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_L_INNERFECRATE = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_L_OUTERFECMETHOD = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_L_OUTERFECRATE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_L_MOD = DISPID_TUNER.TUNER_TS_CREATETUNEREQUEST;
pub const DISPID_TUNER_L_SYMRATE = DISPID_TUNER.TUNER_TS_ENUMCATEGORYGUIDS;
pub const DISPID_TUNER_L_CLONE = DISPID_TUNER.TUNER_TS_ENUMDEVICEMONIKERS;
pub const DISPID_TUNER_L_ATSC_PHYS_CHANNEL = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_TUNER_L_ATSC_TSID = DISPID_TUNER.TUNER_L_ATSC_TSID;
pub const DISPID_TUNER_L_ATSC_MP2_PROGNO = DISPID_TUNER.TUNER_L_ATSC_MP2_PROGNO;
pub const DISPID_TUNER_L_DVBT_BANDWIDTH = DISPID_TUNER.TUNER_L_DVBT_BANDWIDTH;
pub const DISPID_TUNER_L_DVBT_LPINNERFECMETHOD = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECMETHOD;
pub const DISPID_TUNER_L_DVBT_LPINNERFECRATE = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECRATE;
pub const DISPID_TUNER_L_DVBT_GUARDINTERVAL = DISPID_TUNER.TUNER_L_DVBT_GUARDINTERVAL;
pub const DISPID_TUNER_L_DVBT_HALPHA = DISPID_TUNER.TUNER_L_DVBT_HALPHA;
pub const DISPID_TUNER_L_DVBT_TRANSMISSIONMODE = DISPID_TUNER.TUNER_L_DVBT_TRANSMISSIONMODE;
pub const DISPID_TUNER_L_DVBT_INUSE = DISPID_TUNER.TUNER_L_DVBT_INUSE;
pub const DISPID_TUNER_L_DVBT2_PHYSICALLAYERPIPEID = DISPID_TUNER.TUNER_L_DVBT2_PHYSICALLAYERPIPEID;
pub const DISPID_TUNER_L_DVBS_POLARISATION = DISPID_TUNER.TUNER_L_DVBS_POLARISATION;
pub const DISPID_TUNER_L_DVBS_WEST = DISPID_TUNER.TUNER_L_DVBS_WEST;
pub const DISPID_TUNER_L_DVBS_ORBITAL = DISPID_TUNER.TUNER_L_DVBS_ORBITAL;
pub const DISPID_TUNER_L_DVBS_AZIMUTH = DISPID_TUNER.TUNER_L_DVBS_AZIMUTH;
pub const DISPID_TUNER_L_DVBS_ELEVATION = DISPID_TUNER.TUNER_L_DVBS_ELEVATION;
pub const DISPID_TUNER_L_DVBS2_DISEQ_LNB_SOURCE = DISPID_TUNER.TUNER_L_DVBS2_DISEQ_LNB_SOURCE;
pub const DISPID_TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE;
pub const DISPID_TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE;
pub const DISPID_TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE;
pub const DISPID_TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE;
pub const DISPID_TUNER_L_DVBS2_ROLLOFF = DISPID_TUNER.TUNER_L_DVBS2_ROLLOFF;
pub const DISPID_TUNER_L_DVBS2_PILOT = DISPID_TUNER.TUNER_L_DVBS2_PILOT;
pub const DISPID_TUNER_L_ANALOG_STANDARD = DISPID_TUNER.TUNER_L_ANALOG_STANDARD;
pub const DISPID_TUNER_L_DTV_O_MAJOR_CHANNEL = DISPID_TUNER.TUNER_L_DTV_O_MAJOR_CHANNEL;
pub const DISPID_TUNER_C_TYPE = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_C_STATUS = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_C_LANGID = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_C_DESCRIPTION = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_C_CLONE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_C_MP2_PID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_C_MP2_PCRPID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_C_MP2_PROGNO = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_TUNER_C_ANALOG_AUDIO = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_TUNER_TS_DVB_SYSTEMTYPE = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_DVB2_NETWORK_ID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_TS_DVBS_LOW_OSC_FREQ = DISPID_TUNER.TUNER_TS_DVBS_LOW_OSC_FREQ;
pub const DISPID_TUNER_TS_DVBS_HI_OSC_FREQ = DISPID_TUNER.TUNER_TS_DVBS_HI_OSC_FREQ;
pub const DISPID_TUNER_TS_DVBS_LNB_SWITCH_FREQ = DISPID_TUNER.TUNER_TS_DVBS_LNB_SWITCH_FREQ;
pub const DISPID_TUNER_TS_DVBS_INPUT_RANGE = DISPID_TUNER.TUNER_TS_DVBS_INPUT_RANGE;
pub const DISPID_TUNER_TS_DVBS_SPECTRAL_INVERSION = DISPID_TUNER.TUNER_TS_DVBS_SPECTRAL_INVERSION;
pub const DISPID_TUNER_TS_AR_MINFREQUENCY = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_AR_MAXFREQUENCY = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_TS_AR_STEP = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_TUNER_TS_AR_COUNTRYCODE = DISPID_TUNER.TUNER_TS_AR_COUNTRYCODE;
pub const DISPID_TUNER_TS_AUX_COUNTRYCODE = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_ATV_MINCHANNEL = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_ATV_MAXCHANNEL = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_TS_ATV_INPUTTYPE = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_TUNER_TS_ATV_COUNTRYCODE = DISPID_TUNER.TUNER_TS_AR_COUNTRYCODE;
pub const DISPID_TUNER_TS_ATSC_MINMINORCHANNEL = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_TUNER_TS_ATSC_MAXMINORCHANNEL = DISPID_TUNER.TUNER_L_ATSC_TSID;
pub const DISPID_TUNER_TS_ATSC_MINPHYSCHANNEL = DISPID_TUNER.TUNER_L_ATSC_MP2_PROGNO;
pub const DISPID_TUNER_TS_ATSC_MAXPHYSCHANNEL = DISPID_TUNER.TUNER_TS_ATSC_MAXPHYSCHANNEL;
pub const DISPID_TUNER_TS_DC_MINMAJORCHANNEL = DISPID_TUNER.TUNER_L_DVBT_BANDWIDTH;
pub const DISPID_TUNER_TS_DC_MAXMAJORCHANNEL = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECMETHOD;
pub const DISPID_TUNER_TS_DC_MINSOURCEID = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECRATE;
pub const DISPID_TUNER_TS_DC_MAXSOURCEID = DISPID_TUNER.TUNER_L_DVBT_GUARDINTERVAL;
pub const DISPID_CHTUNER_ATVAC_CHANNEL = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_ATVDC_SYSTEM = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_ATVDC_CONTENT = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_CHTUNER_CIDTR_CHANNELID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_CTR_CHANNEL = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_ACTR_MINOR_CHANNEL = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_CHTUNER_DCTR_MAJOR_CHANNEL = DISPID_TUNER.TUNER_L_DVBT_BANDWIDTH;
pub const DISPID_CHTUNER_DCTR_SRCID = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECMETHOD;
pub const DISPID_DVBTUNER_DVBC_ATTRIBUTESVALID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_DVBTUNER_DVBC_PID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_DVBTUNER_DVBC_TAG = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_DVBTUNER_DVBC_COMPONENTTYPE = DISPID_TUNER.TUNER_TS_AR_COUNTRYCODE;
pub const DISPID_DVBTUNER_ONID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_DVBTUNER_TSID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_DVBTUNER_SID = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_MP2TUNER_TSID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_MP2TUNER_PROGNO = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_MP2TUNERFACTORY_CREATETUNEREQUEST = DISPID_TUNER.TUNER_TS_UNIQUENAME;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuningSpaces_Value = @import("../zig.zig").Guid.initString("901284e4-33fe-4b69-8d63-634a596f3756");
pub const IID_ITuningSpaces = &IID_ITuningSpaces_Value;
pub const ITuningSpaces = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ITuningSpaces,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ITuningSpaces,
            NewEnum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ITuningSpaces,
            varIndex: VARIANT,
            TuningSpace: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumTuningSpaces: fn(
            self: *const ITuningSpaces,
            NewEnum: ?*?*IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaces_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaces.VTable, self.vtable).get_Count(@ptrCast(*const ITuningSpaces, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaces_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaces.VTable, self.vtable).get__NewEnum(@ptrCast(*const ITuningSpaces, self), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaces_get_Item(self: *const T, varIndex: VARIANT, TuningSpace: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaces.VTable, self.vtable).get_Item(@ptrCast(*const ITuningSpaces, self), varIndex, TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaces_get_EnumTuningSpaces(self: *const T, NewEnum: ?*?*IEnumTuningSpaces) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaces.VTable, self.vtable).get_EnumTuningSpaces(@ptrCast(*const ITuningSpaces, self), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuningSpaceContainer_Value = @import("../zig.zig").Guid.initString("5b692e84-e2f1-11d2-9493-00c04f72d980");
pub const IID_ITuningSpaceContainer = &IID_ITuningSpaceContainer_Value;
pub const ITuningSpaceContainer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ITuningSpaceContainer,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ITuningSpaceContainer,
            NewEnum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ITuningSpaceContainer,
            varIndex: VARIANT,
            TuningSpace: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Item: fn(
            self: *const ITuningSpaceContainer,
            varIndex: VARIANT,
            TuningSpace: ?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TuningSpacesForCLSID: fn(
            self: *const ITuningSpaceContainer,
            SpaceCLSID: ?BSTR,
            NewColl: ?*?*ITuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _TuningSpacesForCLSID2: fn(
            self: *const ITuningSpaceContainer,
            SpaceCLSID: ?*const Guid,
            NewColl: ?*?*ITuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TuningSpacesForName: fn(
            self: *const ITuningSpaceContainer,
            Name: ?BSTR,
            NewColl: ?*?*ITuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindID: fn(
            self: *const ITuningSpaceContainer,
            TuningSpace: ?*ITuningSpace,
            ID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ITuningSpaceContainer,
            TuningSpace: ?*ITuningSpace,
            NewIndex: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumTuningSpaces: fn(
            self: *const ITuningSpaceContainer,
            ppEnum: ?*?*IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ITuningSpaceContainer,
            Index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxCount: fn(
            self: *const ITuningSpaceContainer,
            MaxCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxCount: fn(
            self: *const ITuningSpaceContainer,
            MaxCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).get_Count(@ptrCast(*const ITuningSpaceContainer, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).get__NewEnum(@ptrCast(*const ITuningSpaceContainer, self), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get_Item(self: *const T, varIndex: VARIANT, TuningSpace: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).get_Item(@ptrCast(*const ITuningSpaceContainer, self), varIndex, TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_put_Item(self: *const T, varIndex: VARIANT, TuningSpace: ?*ITuningSpace) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).put_Item(@ptrCast(*const ITuningSpaceContainer, self), varIndex, TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_TuningSpacesForCLSID(self: *const T, SpaceCLSID: ?BSTR, NewColl: ?*?*ITuningSpaces) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).TuningSpacesForCLSID(@ptrCast(*const ITuningSpaceContainer, self), SpaceCLSID, NewColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer__TuningSpacesForCLSID2(self: *const T, SpaceCLSID: ?*const Guid, NewColl: ?*?*ITuningSpaces) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable)._TuningSpacesForCLSID2(@ptrCast(*const ITuningSpaceContainer, self), SpaceCLSID, NewColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_TuningSpacesForName(self: *const T, Name: ?BSTR, NewColl: ?*?*ITuningSpaces) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).TuningSpacesForName(@ptrCast(*const ITuningSpaceContainer, self), Name, NewColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_FindID(self: *const T, TuningSpace: ?*ITuningSpace, ID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).FindID(@ptrCast(*const ITuningSpaceContainer, self), TuningSpace, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_Add(self: *const T, TuningSpace: ?*ITuningSpace, NewIndex: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).Add(@ptrCast(*const ITuningSpaceContainer, self), TuningSpace, NewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get_EnumTuningSpaces(self: *const T, ppEnum: ?*?*IEnumTuningSpaces) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).get_EnumTuningSpaces(@ptrCast(*const ITuningSpaceContainer, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_Remove(self: *const T, Index: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).Remove(@ptrCast(*const ITuningSpaceContainer, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get_MaxCount(self: *const T, MaxCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).get_MaxCount(@ptrCast(*const ITuningSpaceContainer, self), MaxCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_put_MaxCount(self: *const T, MaxCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpaceContainer.VTable, self.vtable).put_MaxCount(@ptrCast(*const ITuningSpaceContainer, self), MaxCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuningSpace_Value = @import("../zig.zig").Guid.initString("061c6e30-e622-11d2-9493-00c04f72d980");
pub const IID_ITuningSpace = &IID_ITuningSpace_Value;
pub const ITuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UniqueName: fn(
            self: *const ITuningSpace,
            Name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UniqueName: fn(
            self: *const ITuningSpace,
            Name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FriendlyName: fn(
            self: *const ITuningSpace,
            Name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FriendlyName: fn(
            self: *const ITuningSpace,
            Name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CLSID: fn(
            self: *const ITuningSpace,
            SpaceCLSID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetworkType: fn(
            self: *const ITuningSpace,
            NetworkTypeGuid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NetworkType: fn(
            self: *const ITuningSpace,
            NetworkTypeGuid: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NetworkType: fn(
            self: *const ITuningSpace,
            NetworkTypeGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__NetworkType: fn(
            self: *const ITuningSpace,
            NetworkTypeGuid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTuneRequest: fn(
            self: *const ITuningSpace,
            TuneRequest: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCategoryGUIDs: fn(
            self: *const ITuningSpace,
            ppEnum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDeviceMonikers: fn(
            self: *const ITuningSpace,
            ppEnum: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultPreferredComponentTypes: fn(
            self: *const ITuningSpace,
            ComponentTypes: ?*?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultPreferredComponentTypes: fn(
            self: *const ITuningSpace,
            NewComponentTypes: ?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyMapping: fn(
            self: *const ITuningSpace,
            pMapping: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyMapping: fn(
            self: *const ITuningSpace,
            Mapping: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultLocator: fn(
            self: *const ITuningSpace,
            LocatorVal: ?*?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultLocator: fn(
            self: *const ITuningSpace,
            LocatorVal: ?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const ITuningSpace,
            NewTS: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_UniqueName(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).get_UniqueName(@ptrCast(*const ITuningSpace, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_UniqueName(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).put_UniqueName(@ptrCast(*const ITuningSpace, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_FriendlyName(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).get_FriendlyName(@ptrCast(*const ITuningSpace, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_FriendlyName(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).put_FriendlyName(@ptrCast(*const ITuningSpace, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_CLSID(self: *const T, SpaceCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).get_CLSID(@ptrCast(*const ITuningSpace, self), SpaceCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_NetworkType(self: *const T, NetworkTypeGuid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).get_NetworkType(@ptrCast(*const ITuningSpace, self), NetworkTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_NetworkType(self: *const T, NetworkTypeGuid: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).put_NetworkType(@ptrCast(*const ITuningSpace, self), NetworkTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get__NetworkType(self: *const T, NetworkTypeGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).get__NetworkType(@ptrCast(*const ITuningSpace, self), NetworkTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put__NetworkType(self: *const T, NetworkTypeGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).put__NetworkType(@ptrCast(*const ITuningSpace, self), NetworkTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_CreateTuneRequest(self: *const T, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).CreateTuneRequest(@ptrCast(*const ITuningSpace, self), TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_EnumCategoryGUIDs(self: *const T, ppEnum: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).EnumCategoryGUIDs(@ptrCast(*const ITuningSpace, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_EnumDeviceMonikers(self: *const T, ppEnum: ?*?*IEnumMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).EnumDeviceMonikers(@ptrCast(*const ITuningSpace, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_DefaultPreferredComponentTypes(self: *const T, ComponentTypes: ?*?*IComponentTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).get_DefaultPreferredComponentTypes(@ptrCast(*const ITuningSpace, self), ComponentTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_DefaultPreferredComponentTypes(self: *const T, NewComponentTypes: ?*IComponentTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).put_DefaultPreferredComponentTypes(@ptrCast(*const ITuningSpace, self), NewComponentTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_FrequencyMapping(self: *const T, pMapping: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).get_FrequencyMapping(@ptrCast(*const ITuningSpace, self), pMapping);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_FrequencyMapping(self: *const T, Mapping: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).put_FrequencyMapping(@ptrCast(*const ITuningSpace, self), Mapping);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_DefaultLocator(self: *const T, LocatorVal: ?*?*ILocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).get_DefaultLocator(@ptrCast(*const ITuningSpace, self), LocatorVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_DefaultLocator(self: *const T, LocatorVal: ?*ILocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).put_DefaultLocator(@ptrCast(*const ITuningSpace, self), LocatorVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_Clone(self: *const T, NewTS: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuningSpace.VTable, self.vtable).Clone(@ptrCast(*const ITuningSpace, self), NewTS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumTuningSpaces_Value = @import("../zig.zig").Guid.initString("8b8eb248-fc2b-11d2-9d8c-00c04f72d980");
pub const IID_IEnumTuningSpaces = &IID_IEnumTuningSpaces_Value;
pub const IEnumTuningSpaces = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumTuningSpaces,
            celt: u32,
            rgelt: [*]?*ITuningSpace,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTuningSpaces,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumTuningSpaces,
            ppEnum: ?*?*IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuningSpaces_Next(self: *const T, celt: u32, rgelt: [*]?*ITuningSpace, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTuningSpaces.VTable, self.vtable).Next(@ptrCast(*const IEnumTuningSpaces, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuningSpaces_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTuningSpaces.VTable, self.vtable).Skip(@ptrCast(*const IEnumTuningSpaces, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuningSpaces_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTuningSpaces.VTable, self.vtable).Reset(@ptrCast(*const IEnumTuningSpaces, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuningSpaces_Clone(self: *const T, ppEnum: ?*?*IEnumTuningSpaces) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTuningSpaces.VTable, self.vtable).Clone(@ptrCast(*const IEnumTuningSpaces, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTuningSpace_Value = @import("../zig.zig").Guid.initString("ada0b268-3b19-4e5b-acc4-49f852be13ba");
pub const IID_IDVBTuningSpace = &IID_IDVBTuningSpace_Value;
pub const IDVBTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SystemType: fn(
            self: *const IDVBTuningSpace,
            SysType: ?*DVBSystemType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SystemType: fn(
            self: *const IDVBTuningSpace,
            SysType: DVBSystemType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuningSpace_get_SystemType(self: *const T, SysType: ?*DVBSystemType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuningSpace.VTable, self.vtable).get_SystemType(@ptrCast(*const IDVBTuningSpace, self), SysType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuningSpace_put_SystemType(self: *const T, SysType: DVBSystemType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuningSpace.VTable, self.vtable).put_SystemType(@ptrCast(*const IDVBTuningSpace, self), SysType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTuningSpace2_Value = @import("../zig.zig").Guid.initString("843188b4-ce62-43db-966b-8145a094e040");
pub const IID_IDVBTuningSpace2 = &IID_IDVBTuningSpace2_Value;
pub const IDVBTuningSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IDVBTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetworkID: fn(
            self: *const IDVBTuningSpace2,
            NetworkID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NetworkID: fn(
            self: *const IDVBTuningSpace2,
            NetworkID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuningSpace2_get_NetworkID(self: *const T, NetworkID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuningSpace2.VTable, self.vtable).get_NetworkID(@ptrCast(*const IDVBTuningSpace2, self), NetworkID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuningSpace2_put_NetworkID(self: *const T, NetworkID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuningSpace2.VTable, self.vtable).put_NetworkID(@ptrCast(*const IDVBTuningSpace2, self), NetworkID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBSTuningSpace_Value = @import("../zig.zig").Guid.initString("cdf7be60-d954-42fd-a972-78971958e470");
pub const IID_IDVBSTuningSpace = &IID_IDVBSTuningSpace_Value;
pub const IDVBSTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IDVBTuningSpace2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LowOscillator: fn(
            self: *const IDVBSTuningSpace,
            LowOscillator: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LowOscillator: fn(
            self: *const IDVBSTuningSpace,
            LowOscillator: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HighOscillator: fn(
            self: *const IDVBSTuningSpace,
            HighOscillator: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HighOscillator: fn(
            self: *const IDVBSTuningSpace,
            HighOscillator: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LNBSwitch: fn(
            self: *const IDVBSTuningSpace,
            LNBSwitch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LNBSwitch: fn(
            self: *const IDVBSTuningSpace,
            LNBSwitch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputRange: fn(
            self: *const IDVBSTuningSpace,
            InputRange: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputRange: fn(
            self: *const IDVBSTuningSpace,
            InputRange: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SpectralInversion: fn(
            self: *const IDVBSTuningSpace,
            SpectralInversionVal: ?*SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SpectralInversion: fn(
            self: *const IDVBSTuningSpace,
            SpectralInversionVal: SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBTuningSpace2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_LowOscillator(self: *const T, LowOscillator: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).get_LowOscillator(@ptrCast(*const IDVBSTuningSpace, self), LowOscillator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_LowOscillator(self: *const T, LowOscillator: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).put_LowOscillator(@ptrCast(*const IDVBSTuningSpace, self), LowOscillator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_HighOscillator(self: *const T, HighOscillator: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).get_HighOscillator(@ptrCast(*const IDVBSTuningSpace, self), HighOscillator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_HighOscillator(self: *const T, HighOscillator: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).put_HighOscillator(@ptrCast(*const IDVBSTuningSpace, self), HighOscillator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_LNBSwitch(self: *const T, LNBSwitch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).get_LNBSwitch(@ptrCast(*const IDVBSTuningSpace, self), LNBSwitch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_LNBSwitch(self: *const T, LNBSwitch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).put_LNBSwitch(@ptrCast(*const IDVBSTuningSpace, self), LNBSwitch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_InputRange(self: *const T, InputRange: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).get_InputRange(@ptrCast(*const IDVBSTuningSpace, self), InputRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_InputRange(self: *const T, InputRange: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).put_InputRange(@ptrCast(*const IDVBSTuningSpace, self), InputRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_SpectralInversion(self: *const T, SpectralInversionVal: ?*SpectralInversion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).get_SpectralInversion(@ptrCast(*const IDVBSTuningSpace, self), SpectralInversionVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_SpectralInversion(self: *const T, SpectralInversionVal: SpectralInversion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSTuningSpace.VTable, self.vtable).put_SpectralInversion(@ptrCast(*const IDVBSTuningSpace, self), SpectralInversionVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAuxInTuningSpace_Value = @import("../zig.zig").Guid.initString("e48244b8-7e17-4f76-a763-5090ff1e2f30");
pub const IID_IAuxInTuningSpace = &IID_IAuxInTuningSpace_Value;
pub const IAuxInTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuningSpace.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAuxInTuningSpace2_Value = @import("../zig.zig").Guid.initString("b10931ed-8bfe-4ab0-9dce-e469c29a9729");
pub const IID_IAuxInTuningSpace2 = &IID_IAuxInTuningSpace2_Value;
pub const IAuxInTuningSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IAuxInTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: fn(
            self: *const IAuxInTuningSpace2,
            CountryCodeVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: fn(
            self: *const IAuxInTuningSpace2,
            NewCountryCodeVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAuxInTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAuxInTuningSpace2_get_CountryCode(self: *const T, CountryCodeVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAuxInTuningSpace2.VTable, self.vtable).get_CountryCode(@ptrCast(*const IAuxInTuningSpace2, self), CountryCodeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAuxInTuningSpace2_put_CountryCode(self: *const T, NewCountryCodeVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAuxInTuningSpace2.VTable, self.vtable).put_CountryCode(@ptrCast(*const IAuxInTuningSpace2, self), NewCountryCodeVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAnalogTVTuningSpace_Value = @import("../zig.zig").Guid.initString("2a6e293c-2595-11d3-b64c-00c04f79498e");
pub const IID_IAnalogTVTuningSpace = &IID_IAnalogTVTuningSpace_Value;
pub const IAnalogTVTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinChannel: fn(
            self: *const IAnalogTVTuningSpace,
            MinChannelVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinChannel: fn(
            self: *const IAnalogTVTuningSpace,
            NewMinChannelVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxChannel: fn(
            self: *const IAnalogTVTuningSpace,
            MaxChannelVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxChannel: fn(
            self: *const IAnalogTVTuningSpace,
            NewMaxChannelVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputType: fn(
            self: *const IAnalogTVTuningSpace,
            InputTypeVal: ?*TunerInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputType: fn(
            self: *const IAnalogTVTuningSpace,
            NewInputTypeVal: TunerInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: fn(
            self: *const IAnalogTVTuningSpace,
            CountryCodeVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: fn(
            self: *const IAnalogTVTuningSpace,
            NewCountryCodeVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_get_MinChannel(self: *const T, MinChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogTVTuningSpace.VTable, self.vtable).get_MinChannel(@ptrCast(*const IAnalogTVTuningSpace, self), MinChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_put_MinChannel(self: *const T, NewMinChannelVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogTVTuningSpace.VTable, self.vtable).put_MinChannel(@ptrCast(*const IAnalogTVTuningSpace, self), NewMinChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_get_MaxChannel(self: *const T, MaxChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogTVTuningSpace.VTable, self.vtable).get_MaxChannel(@ptrCast(*const IAnalogTVTuningSpace, self), MaxChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_put_MaxChannel(self: *const T, NewMaxChannelVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogTVTuningSpace.VTable, self.vtable).put_MaxChannel(@ptrCast(*const IAnalogTVTuningSpace, self), NewMaxChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_get_InputType(self: *const T, InputTypeVal: ?*TunerInputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogTVTuningSpace.VTable, self.vtable).get_InputType(@ptrCast(*const IAnalogTVTuningSpace, self), InputTypeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_put_InputType(self: *const T, NewInputTypeVal: TunerInputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogTVTuningSpace.VTable, self.vtable).put_InputType(@ptrCast(*const IAnalogTVTuningSpace, self), NewInputTypeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_get_CountryCode(self: *const T, CountryCodeVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogTVTuningSpace.VTable, self.vtable).get_CountryCode(@ptrCast(*const IAnalogTVTuningSpace, self), CountryCodeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_put_CountryCode(self: *const T, NewCountryCodeVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogTVTuningSpace.VTable, self.vtable).put_CountryCode(@ptrCast(*const IAnalogTVTuningSpace, self), NewCountryCodeVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCTuningSpace_Value = @import("../zig.zig").Guid.initString("0369b4e2-45b6-11d3-b650-00c04f79498e");
pub const IID_IATSCTuningSpace = &IID_IATSCTuningSpace_Value;
pub const IATSCTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IAnalogTVTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinMinorChannel: fn(
            self: *const IATSCTuningSpace,
            MinMinorChannelVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinMinorChannel: fn(
            self: *const IATSCTuningSpace,
            NewMinMinorChannelVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxMinorChannel: fn(
            self: *const IATSCTuningSpace,
            MaxMinorChannelVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxMinorChannel: fn(
            self: *const IATSCTuningSpace,
            NewMaxMinorChannelVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinPhysicalChannel: fn(
            self: *const IATSCTuningSpace,
            MinPhysicalChannelVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinPhysicalChannel: fn(
            self: *const IATSCTuningSpace,
            NewMinPhysicalChannelVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxPhysicalChannel: fn(
            self: *const IATSCTuningSpace,
            MaxPhysicalChannelVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxPhysicalChannel: fn(
            self: *const IATSCTuningSpace,
            NewMaxPhysicalChannelVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAnalogTVTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_get_MinMinorChannel(self: *const T, MinMinorChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCTuningSpace.VTable, self.vtable).get_MinMinorChannel(@ptrCast(*const IATSCTuningSpace, self), MinMinorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_put_MinMinorChannel(self: *const T, NewMinMinorChannelVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCTuningSpace.VTable, self.vtable).put_MinMinorChannel(@ptrCast(*const IATSCTuningSpace, self), NewMinMinorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_get_MaxMinorChannel(self: *const T, MaxMinorChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCTuningSpace.VTable, self.vtable).get_MaxMinorChannel(@ptrCast(*const IATSCTuningSpace, self), MaxMinorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_put_MaxMinorChannel(self: *const T, NewMaxMinorChannelVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCTuningSpace.VTable, self.vtable).put_MaxMinorChannel(@ptrCast(*const IATSCTuningSpace, self), NewMaxMinorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_get_MinPhysicalChannel(self: *const T, MinPhysicalChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCTuningSpace.VTable, self.vtable).get_MinPhysicalChannel(@ptrCast(*const IATSCTuningSpace, self), MinPhysicalChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_put_MinPhysicalChannel(self: *const T, NewMinPhysicalChannelVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCTuningSpace.VTable, self.vtable).put_MinPhysicalChannel(@ptrCast(*const IATSCTuningSpace, self), NewMinPhysicalChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_get_MaxPhysicalChannel(self: *const T, MaxPhysicalChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCTuningSpace.VTable, self.vtable).get_MaxPhysicalChannel(@ptrCast(*const IATSCTuningSpace, self), MaxPhysicalChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_put_MaxPhysicalChannel(self: *const T, NewMaxPhysicalChannelVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCTuningSpace.VTable, self.vtable).put_MaxPhysicalChannel(@ptrCast(*const IATSCTuningSpace, self), NewMaxPhysicalChannelVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalCableTuningSpace_Value = @import("../zig.zig").Guid.initString("013f9f9c-b449-4ec7-a6d2-9d4f2fc70ae5");
pub const IID_IDigitalCableTuningSpace = &IID_IDigitalCableTuningSpace_Value;
pub const IDigitalCableTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IATSCTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinMajorChannel: fn(
            self: *const IDigitalCableTuningSpace,
            MinMajorChannelVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinMajorChannel: fn(
            self: *const IDigitalCableTuningSpace,
            NewMinMajorChannelVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxMajorChannel: fn(
            self: *const IDigitalCableTuningSpace,
            MaxMajorChannelVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxMajorChannel: fn(
            self: *const IDigitalCableTuningSpace,
            NewMaxMajorChannelVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinSourceID: fn(
            self: *const IDigitalCableTuningSpace,
            MinSourceIDVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinSourceID: fn(
            self: *const IDigitalCableTuningSpace,
            NewMinSourceIDVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxSourceID: fn(
            self: *const IDigitalCableTuningSpace,
            MaxSourceIDVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxSourceID: fn(
            self: *const IDigitalCableTuningSpace,
            NewMaxSourceIDVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IATSCTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_get_MinMajorChannel(self: *const T, MinMajorChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuningSpace.VTable, self.vtable).get_MinMajorChannel(@ptrCast(*const IDigitalCableTuningSpace, self), MinMajorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_put_MinMajorChannel(self: *const T, NewMinMajorChannelVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuningSpace.VTable, self.vtable).put_MinMajorChannel(@ptrCast(*const IDigitalCableTuningSpace, self), NewMinMajorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_get_MaxMajorChannel(self: *const T, MaxMajorChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuningSpace.VTable, self.vtable).get_MaxMajorChannel(@ptrCast(*const IDigitalCableTuningSpace, self), MaxMajorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_put_MaxMajorChannel(self: *const T, NewMaxMajorChannelVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuningSpace.VTable, self.vtable).put_MaxMajorChannel(@ptrCast(*const IDigitalCableTuningSpace, self), NewMaxMajorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_get_MinSourceID(self: *const T, MinSourceIDVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuningSpace.VTable, self.vtable).get_MinSourceID(@ptrCast(*const IDigitalCableTuningSpace, self), MinSourceIDVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_put_MinSourceID(self: *const T, NewMinSourceIDVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuningSpace.VTable, self.vtable).put_MinSourceID(@ptrCast(*const IDigitalCableTuningSpace, self), NewMinSourceIDVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_get_MaxSourceID(self: *const T, MaxSourceIDVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuningSpace.VTable, self.vtable).get_MaxSourceID(@ptrCast(*const IDigitalCableTuningSpace, self), MaxSourceIDVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_put_MaxSourceID(self: *const T, NewMaxSourceIDVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuningSpace.VTable, self.vtable).put_MaxSourceID(@ptrCast(*const IDigitalCableTuningSpace, self), NewMaxSourceIDVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAnalogRadioTuningSpace_Value = @import("../zig.zig").Guid.initString("2a6e293b-2595-11d3-b64c-00c04f79498e");
pub const IID_IAnalogRadioTuningSpace = &IID_IAnalogRadioTuningSpace_Value;
pub const IAnalogRadioTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinFrequency: fn(
            self: *const IAnalogRadioTuningSpace,
            MinFrequencyVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinFrequency: fn(
            self: *const IAnalogRadioTuningSpace,
            NewMinFrequencyVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxFrequency: fn(
            self: *const IAnalogRadioTuningSpace,
            MaxFrequencyVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxFrequency: fn(
            self: *const IAnalogRadioTuningSpace,
            NewMaxFrequencyVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Step: fn(
            self: *const IAnalogRadioTuningSpace,
            StepVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Step: fn(
            self: *const IAnalogRadioTuningSpace,
            NewStepVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_get_MinFrequency(self: *const T, MinFrequencyVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogRadioTuningSpace.VTable, self.vtable).get_MinFrequency(@ptrCast(*const IAnalogRadioTuningSpace, self), MinFrequencyVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_put_MinFrequency(self: *const T, NewMinFrequencyVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogRadioTuningSpace.VTable, self.vtable).put_MinFrequency(@ptrCast(*const IAnalogRadioTuningSpace, self), NewMinFrequencyVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_get_MaxFrequency(self: *const T, MaxFrequencyVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogRadioTuningSpace.VTable, self.vtable).get_MaxFrequency(@ptrCast(*const IAnalogRadioTuningSpace, self), MaxFrequencyVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_put_MaxFrequency(self: *const T, NewMaxFrequencyVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogRadioTuningSpace.VTable, self.vtable).put_MaxFrequency(@ptrCast(*const IAnalogRadioTuningSpace, self), NewMaxFrequencyVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_get_Step(self: *const T, StepVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogRadioTuningSpace.VTable, self.vtable).get_Step(@ptrCast(*const IAnalogRadioTuningSpace, self), StepVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_put_Step(self: *const T, NewStepVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogRadioTuningSpace.VTable, self.vtable).put_Step(@ptrCast(*const IAnalogRadioTuningSpace, self), NewStepVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAnalogRadioTuningSpace2_Value = @import("../zig.zig").Guid.initString("39dd45da-2da8-46ba-8a8a-87e2b73d983a");
pub const IID_IAnalogRadioTuningSpace2 = &IID_IAnalogRadioTuningSpace2_Value;
pub const IAnalogRadioTuningSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IAnalogRadioTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: fn(
            self: *const IAnalogRadioTuningSpace2,
            CountryCodeVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: fn(
            self: *const IAnalogRadioTuningSpace2,
            NewCountryCodeVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAnalogRadioTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace2_get_CountryCode(self: *const T, CountryCodeVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogRadioTuningSpace2.VTable, self.vtable).get_CountryCode(@ptrCast(*const IAnalogRadioTuningSpace2, self), CountryCodeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace2_put_CountryCode(self: *const T, NewCountryCodeVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogRadioTuningSpace2.VTable, self.vtable).put_CountryCode(@ptrCast(*const IAnalogRadioTuningSpace2, self), NewCountryCodeVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuneRequest_Value = @import("../zig.zig").Guid.initString("07ddc146-fc3d-11d2-9d8c-00c04f72d980");
pub const IID_ITuneRequest = &IID_ITuneRequest_Value;
pub const ITuneRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: fn(
            self: *const ITuneRequest,
            TuningSpace: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Components: fn(
            self: *const ITuneRequest,
            Components: ?*?*IComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const ITuneRequest,
            NewTuneRequest: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Locator: fn(
            self: *const ITuneRequest,
            Locator: ?*?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Locator: fn(
            self: *const ITuneRequest,
            Locator: ?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_get_TuningSpace(self: *const T, TuningSpace: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequest.VTable, self.vtable).get_TuningSpace(@ptrCast(*const ITuneRequest, self), TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_get_Components(self: *const T, Components: ?*?*IComponents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequest.VTable, self.vtable).get_Components(@ptrCast(*const ITuneRequest, self), Components);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_Clone(self: *const T, NewTuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequest.VTable, self.vtable).Clone(@ptrCast(*const ITuneRequest, self), NewTuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_get_Locator(self: *const T, Locator: ?*?*ILocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequest.VTable, self.vtable).get_Locator(@ptrCast(*const ITuneRequest, self), Locator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_put_Locator(self: *const T, Locator: ?*ILocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequest.VTable, self.vtable).put_Locator(@ptrCast(*const ITuneRequest, self), Locator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IChannelIDTuneRequest_Value = @import("../zig.zig").Guid.initString("156eff60-86f4-4e28-89fc-109799fd57ee");
pub const IID_IChannelIDTuneRequest = &IID_IChannelIDTuneRequest_Value;
pub const IChannelIDTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelID: fn(
            self: *const IChannelIDTuneRequest,
            ChannelID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ChannelID: fn(
            self: *const IChannelIDTuneRequest,
            ChannelID: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelIDTuneRequest_get_ChannelID(self: *const T, ChannelID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChannelIDTuneRequest.VTable, self.vtable).get_ChannelID(@ptrCast(*const IChannelIDTuneRequest, self), ChannelID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelIDTuneRequest_put_ChannelID(self: *const T, ChannelID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChannelIDTuneRequest.VTable, self.vtable).put_ChannelID(@ptrCast(*const IChannelIDTuneRequest, self), ChannelID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IChannelTuneRequest_Value = @import("../zig.zig").Guid.initString("0369b4e0-45b6-11d3-b650-00c04f79498e");
pub const IID_IChannelTuneRequest = &IID_IChannelTuneRequest_Value;
pub const IChannelTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channel: fn(
            self: *const IChannelTuneRequest,
            Channel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channel: fn(
            self: *const IChannelTuneRequest,
            Channel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelTuneRequest_get_Channel(self: *const T, Channel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChannelTuneRequest.VTable, self.vtable).get_Channel(@ptrCast(*const IChannelTuneRequest, self), Channel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelTuneRequest_put_Channel(self: *const T, Channel: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChannelTuneRequest.VTable, self.vtable).put_Channel(@ptrCast(*const IChannelTuneRequest, self), Channel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCChannelTuneRequest_Value = @import("../zig.zig").Guid.initString("0369b4e1-45b6-11d3-b650-00c04f79498e");
pub const IID_IATSCChannelTuneRequest = &IID_IATSCChannelTuneRequest_Value;
pub const IATSCChannelTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: IChannelTuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinorChannel: fn(
            self: *const IATSCChannelTuneRequest,
            MinorChannel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinorChannel: fn(
            self: *const IATSCChannelTuneRequest,
            MinorChannel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IChannelTuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCChannelTuneRequest_get_MinorChannel(self: *const T, MinorChannel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCChannelTuneRequest.VTable, self.vtable).get_MinorChannel(@ptrCast(*const IATSCChannelTuneRequest, self), MinorChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCChannelTuneRequest_put_MinorChannel(self: *const T, MinorChannel: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCChannelTuneRequest.VTable, self.vtable).put_MinorChannel(@ptrCast(*const IATSCChannelTuneRequest, self), MinorChannel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalCableTuneRequest_Value = @import("../zig.zig").Guid.initString("bad7753b-6b37-4810-ae57-3ce0c4a9e6cb");
pub const IID_IDigitalCableTuneRequest = &IID_IDigitalCableTuneRequest_Value;
pub const IDigitalCableTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: IATSCChannelTuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MajorChannel: fn(
            self: *const IDigitalCableTuneRequest,
            pMajorChannel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MajorChannel: fn(
            self: *const IDigitalCableTuneRequest,
            MajorChannel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceID: fn(
            self: *const IDigitalCableTuneRequest,
            pSourceID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceID: fn(
            self: *const IDigitalCableTuneRequest,
            SourceID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IATSCChannelTuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuneRequest_get_MajorChannel(self: *const T, pMajorChannel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuneRequest.VTable, self.vtable).get_MajorChannel(@ptrCast(*const IDigitalCableTuneRequest, self), pMajorChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuneRequest_put_MajorChannel(self: *const T, MajorChannel: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuneRequest.VTable, self.vtable).put_MajorChannel(@ptrCast(*const IDigitalCableTuneRequest, self), MajorChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuneRequest_get_SourceID(self: *const T, pSourceID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuneRequest.VTable, self.vtable).get_SourceID(@ptrCast(*const IDigitalCableTuneRequest, self), pSourceID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuneRequest_put_SourceID(self: *const T, SourceID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDigitalCableTuneRequest.VTable, self.vtable).put_SourceID(@ptrCast(*const IDigitalCableTuneRequest, self), SourceID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTuneRequest_Value = @import("../zig.zig").Guid.initString("0d6f567e-a636-42bb-83ba-ce4c1704afa2");
pub const IID_IDVBTuneRequest = &IID_IDVBTuneRequest_Value;
pub const IDVBTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ONID: fn(
            self: *const IDVBTuneRequest,
            ONID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ONID: fn(
            self: *const IDVBTuneRequest,
            ONID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TSID: fn(
            self: *const IDVBTuneRequest,
            TSID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TSID: fn(
            self: *const IDVBTuneRequest,
            TSID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SID: fn(
            self: *const IDVBTuneRequest,
            SID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SID: fn(
            self: *const IDVBTuneRequest,
            SID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_get_ONID(self: *const T, ONID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuneRequest.VTable, self.vtable).get_ONID(@ptrCast(*const IDVBTuneRequest, self), ONID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_put_ONID(self: *const T, ONID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuneRequest.VTable, self.vtable).put_ONID(@ptrCast(*const IDVBTuneRequest, self), ONID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_get_TSID(self: *const T, TSID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuneRequest.VTable, self.vtable).get_TSID(@ptrCast(*const IDVBTuneRequest, self), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_put_TSID(self: *const T, TSID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuneRequest.VTable, self.vtable).put_TSID(@ptrCast(*const IDVBTuneRequest, self), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_get_SID(self: *const T, SID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuneRequest.VTable, self.vtable).get_SID(@ptrCast(*const IDVBTuneRequest, self), SID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_put_SID(self: *const T, SID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTuneRequest.VTable, self.vtable).put_SID(@ptrCast(*const IDVBTuneRequest, self), SID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2TuneRequest_Value = @import("../zig.zig").Guid.initString("eb7d987f-8a01-42ad-b8ae-574deee44d1a");
pub const IID_IMPEG2TuneRequest = &IID_IMPEG2TuneRequest_Value;
pub const IMPEG2TuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TSID: fn(
            self: *const IMPEG2TuneRequest,
            TSID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TSID: fn(
            self: *const IMPEG2TuneRequest,
            TSID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgNo: fn(
            self: *const IMPEG2TuneRequest,
            ProgNo: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProgNo: fn(
            self: *const IMPEG2TuneRequest,
            ProgNo: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequest_get_TSID(self: *const T, TSID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2TuneRequest.VTable, self.vtable).get_TSID(@ptrCast(*const IMPEG2TuneRequest, self), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequest_put_TSID(self: *const T, TSID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2TuneRequest.VTable, self.vtable).put_TSID(@ptrCast(*const IMPEG2TuneRequest, self), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequest_get_ProgNo(self: *const T, ProgNo: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2TuneRequest.VTable, self.vtable).get_ProgNo(@ptrCast(*const IMPEG2TuneRequest, self), ProgNo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequest_put_ProgNo(self: *const T, ProgNo: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2TuneRequest.VTable, self.vtable).put_ProgNo(@ptrCast(*const IMPEG2TuneRequest, self), ProgNo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2TuneRequestFactory_Value = @import("../zig.zig").Guid.initString("14e11abd-ee37-4893-9ea1-6964de933e39");
pub const IID_IMPEG2TuneRequestFactory = &IID_IMPEG2TuneRequestFactory_Value;
pub const IMPEG2TuneRequestFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateTuneRequest: fn(
            self: *const IMPEG2TuneRequestFactory,
            TuningSpace: ?*ITuningSpace,
            TuneRequest: ?*?*IMPEG2TuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequestFactory_CreateTuneRequest(self: *const T, TuningSpace: ?*ITuningSpace, TuneRequest: ?*?*IMPEG2TuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2TuneRequestFactory.VTable, self.vtable).CreateTuneRequest(@ptrCast(*const IMPEG2TuneRequestFactory, self), TuningSpace, TuneRequest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2TuneRequestSupport_Value = @import("../zig.zig").Guid.initString("1b9d5fc3-5bbc-4b6c-bb18-b9d10e3eeebf");
pub const IID_IMPEG2TuneRequestSupport = &IID_IMPEG2TuneRequestSupport_Value;
pub const IMPEG2TuneRequestSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITunerCap_Value = @import("../zig.zig").Guid.initString("e60dfa45-8d56-4e65-a8ab-d6be9412c249");
pub const IID_ITunerCap = &IID_ITunerCap_Value;
pub const ITunerCap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedNetworkTypes: fn(
            self: *const ITunerCap,
            ulcNetworkTypesMax: u32,
            pulcNetworkTypes: ?*u32,
            pguidNetworkTypes: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedVideoFormats: fn(
            self: *const ITunerCap,
            pulAMTunerModeType: ?*u32,
            pulAnalogVideoStandard: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuxInputCount: fn(
            self: *const ITunerCap,
            pulCompositeCount: ?*u32,
            pulSvideoCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITunerCap_get_SupportedNetworkTypes(self: *const T, ulcNetworkTypesMax: u32, pulcNetworkTypes: ?*u32, pguidNetworkTypes: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITunerCap.VTable, self.vtable).get_SupportedNetworkTypes(@ptrCast(*const ITunerCap, self), ulcNetworkTypesMax, pulcNetworkTypes, pguidNetworkTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITunerCap_get_SupportedVideoFormats(self: *const T, pulAMTunerModeType: ?*u32, pulAnalogVideoStandard: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITunerCap.VTable, self.vtable).get_SupportedVideoFormats(@ptrCast(*const ITunerCap, self), pulAMTunerModeType, pulAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITunerCap_get_AuxInputCount(self: *const T, pulCompositeCount: ?*u32, pulSvideoCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITunerCap.VTable, self.vtable).get_AuxInputCount(@ptrCast(*const ITunerCap, self), pulCompositeCount, pulSvideoCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ITunerCapEx_Value = @import("../zig.zig").Guid.initString("ed3e0c66-18c8-4ea6-9300-f6841fdd35dc");
pub const IID_ITunerCapEx = &IID_ITunerCapEx_Value;
pub const ITunerCapEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Has608_708Caption: fn(
            self: *const ITunerCapEx,
            pbHasCaption: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITunerCapEx_get_Has608_708Caption(self: *const T, pbHasCaption: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITunerCapEx.VTable, self.vtable).get_Has608_708Caption(@ptrCast(*const ITunerCapEx, self), pbHasCaption);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITuner_Value = @import("../zig.zig").Guid.initString("28c52640-018a-11d3-9d8e-00c04f72d980");
pub const IID_ITuner = &IID_ITuner_Value;
pub const ITuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: fn(
            self: *const ITuner,
            TuningSpace: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuningSpace: fn(
            self: *const ITuner,
            TuningSpace: ?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumTuningSpaces: fn(
            self: *const ITuner,
            ppEnum: ?*?*IEnumTuningSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuneRequest: fn(
            self: *const ITuner,
            TuneRequest: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuneRequest: fn(
            self: *const ITuner,
            TuneRequest: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: fn(
            self: *const ITuner,
            TuneRequest: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredComponentTypes: fn(
            self: *const ITuner,
            ComponentTypes: ?*?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredComponentTypes: fn(
            self: *const ITuner,
            ComponentTypes: ?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalStrength: fn(
            self: *const ITuner,
            Strength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TriggerSignalEvents: fn(
            self: *const ITuner,
            Interval: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_get_TuningSpace(self: *const T, TuningSpace: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).get_TuningSpace(@ptrCast(*const ITuner, self), TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_put_TuningSpace(self: *const T, TuningSpace: ?*ITuningSpace) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).put_TuningSpace(@ptrCast(*const ITuner, self), TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_EnumTuningSpaces(self: *const T, ppEnum: ?*?*IEnumTuningSpaces) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).EnumTuningSpaces(@ptrCast(*const ITuner, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_get_TuneRequest(self: *const T, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).get_TuneRequest(@ptrCast(*const ITuner, self), TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_put_TuneRequest(self: *const T, TuneRequest: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).put_TuneRequest(@ptrCast(*const ITuner, self), TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_Validate(self: *const T, TuneRequest: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).Validate(@ptrCast(*const ITuner, self), TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_get_PreferredComponentTypes(self: *const T, ComponentTypes: ?*?*IComponentTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).get_PreferredComponentTypes(@ptrCast(*const ITuner, self), ComponentTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_put_PreferredComponentTypes(self: *const T, ComponentTypes: ?*IComponentTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).put_PreferredComponentTypes(@ptrCast(*const ITuner, self), ComponentTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_get_SignalStrength(self: *const T, Strength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).get_SignalStrength(@ptrCast(*const ITuner, self), Strength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_TriggerSignalEvents(self: *const T, Interval: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuner.VTable, self.vtable).TriggerSignalEvents(@ptrCast(*const ITuner, self), Interval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScanningTuner_Value = @import("../zig.zig").Guid.initString("1dfd0a5c-0284-11d3-9d8e-00c04f72d980");
pub const IID_IScanningTuner = &IID_IScanningTuner_Value;
pub const IScanningTuner = extern struct {
    pub const VTable = extern struct {
        base: ITuner.VTable,
        SeekUp: fn(
            self: *const IScanningTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SeekDown: fn(
            self: *const IScanningTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScanUp: fn(
            self: *const IScanningTuner,
            MillisecondsPause: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScanDown: fn(
            self: *const IScanningTuner,
            MillisecondsPause: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoProgram: fn(
            self: *const IScanningTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_SeekUp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTuner.VTable, self.vtable).SeekUp(@ptrCast(*const IScanningTuner, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_SeekDown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTuner.VTable, self.vtable).SeekDown(@ptrCast(*const IScanningTuner, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_ScanUp(self: *const T, MillisecondsPause: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTuner.VTable, self.vtable).ScanUp(@ptrCast(*const IScanningTuner, self), MillisecondsPause);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_ScanDown(self: *const T, MillisecondsPause: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTuner.VTable, self.vtable).ScanDown(@ptrCast(*const IScanningTuner, self), MillisecondsPause);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_AutoProgram(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTuner.VTable, self.vtable).AutoProgram(@ptrCast(*const IScanningTuner, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScanningTunerEx_Value = @import("../zig.zig").Guid.initString("04bbd195-0e2d-4593-9bd5-4f908bc33cf5");
pub const IID_IScanningTunerEx = &IID_IScanningTunerEx_Value;
pub const IScanningTunerEx = extern struct {
    pub const VTable = extern struct {
        base: IScanningTuner.VTable,
        GetCurrentLocator: fn(
            self: *const IScanningTunerEx,
            pILocator: ?*?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PerformExhaustiveScan: fn(
            self: *const IScanningTunerEx,
            dwLowerFreq: i32,
            dwHigherFreq: i32,
            bFineTune: i16,
            hEvent: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateCurrentScan: fn(
            self: *const IScanningTunerEx,
            pcurrentFreq: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumeCurrentScan: fn(
            self: *const IScanningTunerEx,
            hEvent: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTunerScanningCapability: fn(
            self: *const IScanningTunerEx,
            HardwareAssistedScanning: ?*i32,
            NumStandardsSupported: ?*i32,
            BroadcastStandards: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTunerStatus: fn(
            self: *const IScanningTunerEx,
            SecondsLeft: ?*i32,
            CurrentLockType: ?*i32,
            AutoDetect: ?*i32,
            CurrentFreq: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTunerStandardCapability: fn(
            self: *const IScanningTunerEx,
            CurrentBroadcastStandard: Guid,
            SettlingTime: ?*i32,
            TvStandardsSupported: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScanSignalTypeFilter: fn(
            self: *const IScanningTunerEx,
            ScanModulationTypes: i32,
            AnalogVideoStandard: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IScanningTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_GetCurrentLocator(self: *const T, pILocator: ?*?*ILocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTunerEx.VTable, self.vtable).GetCurrentLocator(@ptrCast(*const IScanningTunerEx, self), pILocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_PerformExhaustiveScan(self: *const T, dwLowerFreq: i32, dwHigherFreq: i32, bFineTune: i16, hEvent: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTunerEx.VTable, self.vtable).PerformExhaustiveScan(@ptrCast(*const IScanningTunerEx, self), dwLowerFreq, dwHigherFreq, bFineTune, hEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_TerminateCurrentScan(self: *const T, pcurrentFreq: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTunerEx.VTable, self.vtable).TerminateCurrentScan(@ptrCast(*const IScanningTunerEx, self), pcurrentFreq);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_ResumeCurrentScan(self: *const T, hEvent: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTunerEx.VTable, self.vtable).ResumeCurrentScan(@ptrCast(*const IScanningTunerEx, self), hEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_GetTunerScanningCapability(self: *const T, HardwareAssistedScanning: ?*i32, NumStandardsSupported: ?*i32, BroadcastStandards: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTunerEx.VTable, self.vtable).GetTunerScanningCapability(@ptrCast(*const IScanningTunerEx, self), HardwareAssistedScanning, NumStandardsSupported, BroadcastStandards);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_GetTunerStatus(self: *const T, SecondsLeft: ?*i32, CurrentLockType: ?*i32, AutoDetect: ?*i32, CurrentFreq: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTunerEx.VTable, self.vtable).GetTunerStatus(@ptrCast(*const IScanningTunerEx, self), SecondsLeft, CurrentLockType, AutoDetect, CurrentFreq);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_GetCurrentTunerStandardCapability(self: *const T, CurrentBroadcastStandard: Guid, SettlingTime: ?*i32, TvStandardsSupported: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTunerEx.VTable, self.vtable).GetCurrentTunerStandardCapability(@ptrCast(*const IScanningTunerEx, self), CurrentBroadcastStandard, SettlingTime, TvStandardsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_SetScanSignalTypeFilter(self: *const T, _param_ScanModulationTypes: i32, _param_AnalogVideoStandard: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScanningTunerEx.VTable, self.vtable).SetScanSignalTypeFilter(@ptrCast(*const IScanningTunerEx, self), _param_ScanModulationTypes, _param_AnalogVideoStandard);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IComponentType_Value = @import("../zig.zig").Guid.initString("6a340dc0-0311-11d3-9d8e-00c04f72d980");
pub const IID_IComponentType = &IID_IComponentType_Value;
pub const IComponentType = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: fn(
            self: *const IComponentType,
            Category: ?*ComponentCategory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Category: fn(
            self: *const IComponentType,
            Category: ComponentCategory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaMajorType: fn(
            self: *const IComponentType,
            MediaMajorType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaMajorType: fn(
            self: *const IComponentType,
            MediaMajorType: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MediaMajorType: fn(
            self: *const IComponentType,
            MediaMajorTypeGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MediaMajorType: fn(
            self: *const IComponentType,
            MediaMajorTypeGuid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaSubType: fn(
            self: *const IComponentType,
            MediaSubType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaSubType: fn(
            self: *const IComponentType,
            MediaSubType: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MediaSubType: fn(
            self: *const IComponentType,
            MediaSubTypeGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MediaSubType: fn(
            self: *const IComponentType,
            MediaSubTypeGuid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaFormatType: fn(
            self: *const IComponentType,
            MediaFormatType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaFormatType: fn(
            self: *const IComponentType,
            MediaFormatType: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MediaFormatType: fn(
            self: *const IComponentType,
            MediaFormatTypeGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MediaFormatType: fn(
            self: *const IComponentType,
            MediaFormatTypeGuid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: fn(
            self: *const IComponentType,
            MediaType: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaType: fn(
            self: *const IComponentType,
            MediaType: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IComponentType,
            NewCT: ?*?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_Category(self: *const T, Category: ?*ComponentCategory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).get_Category(@ptrCast(*const IComponentType, self), Category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_Category(self: *const T, Category: ComponentCategory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).put_Category(@ptrCast(*const IComponentType, self), Category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_MediaMajorType(self: *const T, MediaMajorType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).get_MediaMajorType(@ptrCast(*const IComponentType, self), MediaMajorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_MediaMajorType(self: *const T, MediaMajorType: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).put_MediaMajorType(@ptrCast(*const IComponentType, self), MediaMajorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get__MediaMajorType(self: *const T, MediaMajorTypeGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).get__MediaMajorType(@ptrCast(*const IComponentType, self), MediaMajorTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put__MediaMajorType(self: *const T, MediaMajorTypeGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).put__MediaMajorType(@ptrCast(*const IComponentType, self), MediaMajorTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_MediaSubType(self: *const T, MediaSubType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).get_MediaSubType(@ptrCast(*const IComponentType, self), MediaSubType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_MediaSubType(self: *const T, MediaSubType: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).put_MediaSubType(@ptrCast(*const IComponentType, self), MediaSubType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get__MediaSubType(self: *const T, MediaSubTypeGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).get__MediaSubType(@ptrCast(*const IComponentType, self), MediaSubTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put__MediaSubType(self: *const T, MediaSubTypeGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).put__MediaSubType(@ptrCast(*const IComponentType, self), MediaSubTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_MediaFormatType(self: *const T, MediaFormatType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).get_MediaFormatType(@ptrCast(*const IComponentType, self), MediaFormatType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_MediaFormatType(self: *const T, MediaFormatType: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).put_MediaFormatType(@ptrCast(*const IComponentType, self), MediaFormatType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get__MediaFormatType(self: *const T, MediaFormatTypeGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).get__MediaFormatType(@ptrCast(*const IComponentType, self), MediaFormatTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put__MediaFormatType(self: *const T, MediaFormatTypeGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).put__MediaFormatType(@ptrCast(*const IComponentType, self), MediaFormatTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_MediaType(self: *const T, MediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).get_MediaType(@ptrCast(*const IComponentType, self), MediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_MediaType(self: *const T, MediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).put_MediaType(@ptrCast(*const IComponentType, self), MediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_Clone(self: *const T, NewCT: ?*?*IComponentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentType.VTable, self.vtable).Clone(@ptrCast(*const IComponentType, self), NewCT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ILanguageComponentType_Value = @import("../zig.zig").Guid.initString("b874c8ba-0fa2-11d3-9d8e-00c04f72d980");
pub const IID_ILanguageComponentType = &IID_ILanguageComponentType_Value;
pub const ILanguageComponentType = extern struct {
    pub const VTable = extern struct {
        base: IComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LangID: fn(
            self: *const ILanguageComponentType,
            LangID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LangID: fn(
            self: *const ILanguageComponentType,
            LangID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponentType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageComponentType_get_LangID(self: *const T, LangID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageComponentType.VTable, self.vtable).get_LangID(@ptrCast(*const ILanguageComponentType, self), LangID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageComponentType_put_LangID(self: *const T, LangID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILanguageComponentType.VTable, self.vtable).put_LangID(@ptrCast(*const ILanguageComponentType, self), LangID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2ComponentType_Value = @import("../zig.zig").Guid.initString("2c073d84-b51c-48c9-aa9f-68971e1f6e38");
pub const IID_IMPEG2ComponentType = &IID_IMPEG2ComponentType_Value;
pub const IMPEG2ComponentType = extern struct {
    pub const VTable = extern struct {
        base: ILanguageComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StreamType: fn(
            self: *const IMPEG2ComponentType,
            MP2StreamType: ?*MPEG2StreamType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StreamType: fn(
            self: *const IMPEG2ComponentType,
            MP2StreamType: MPEG2StreamType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ILanguageComponentType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2ComponentType_get_StreamType(self: *const T, MP2StreamType: ?*MPEG2StreamType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2ComponentType.VTable, self.vtable).get_StreamType(@ptrCast(*const IMPEG2ComponentType, self), MP2StreamType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2ComponentType_put_StreamType(self: *const T, MP2StreamType: MPEG2StreamType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2ComponentType.VTable, self.vtable).put_StreamType(@ptrCast(*const IMPEG2ComponentType, self), MP2StreamType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCComponentType_Value = @import("../zig.zig").Guid.initString("fc189e4d-7bd4-4125-b3b3-3a76a332cc96");
pub const IID_IATSCComponentType = &IID_IATSCComponentType_Value;
pub const IATSCComponentType = extern struct {
    pub const VTable = extern struct {
        base: IMPEG2ComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Flags: fn(
            self: *const IATSCComponentType,
            Flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Flags: fn(
            self: *const IATSCComponentType,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMPEG2ComponentType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCComponentType_get_Flags(self: *const T, Flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCComponentType.VTable, self.vtable).get_Flags(@ptrCast(*const IATSCComponentType, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCComponentType_put_Flags(self: *const T, flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCComponentType.VTable, self.vtable).put_Flags(@ptrCast(*const IATSCComponentType, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumComponentTypes_Value = @import("../zig.zig").Guid.initString("8a674b4a-1f63-11d3-b64c-00c04f79498e");
pub const IID_IEnumComponentTypes = &IID_IEnumComponentTypes_Value;
pub const IEnumComponentTypes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumComponentTypes,
            celt: u32,
            rgelt: [*]?*IComponentType,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumComponentTypes,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumComponentTypes,
            ppEnum: ?*?*IEnumComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponentTypes_Next(self: *const T, celt: u32, rgelt: [*]?*IComponentType, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumComponentTypes.VTable, self.vtable).Next(@ptrCast(*const IEnumComponentTypes, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponentTypes_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumComponentTypes.VTable, self.vtable).Skip(@ptrCast(*const IEnumComponentTypes, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponentTypes_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumComponentTypes.VTable, self.vtable).Reset(@ptrCast(*const IEnumComponentTypes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponentTypes_Clone(self: *const T, ppEnum: ?*?*IEnumComponentTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumComponentTypes.VTable, self.vtable).Clone(@ptrCast(*const IEnumComponentTypes, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IComponentTypes_Value = @import("../zig.zig").Guid.initString("0dc13d4a-0313-11d3-9d8e-00c04f72d980");
pub const IID_IComponentTypes = &IID_IComponentTypes_Value;
pub const IComponentTypes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IComponentTypes,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IComponentTypes,
            ppNewEnum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumComponentTypes: fn(
            self: *const IComponentTypes,
            ppNewEnum: ?*?*IEnumComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IComponentTypes,
            Index: VARIANT,
            ComponentType: ?*?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Item: fn(
            self: *const IComponentTypes,
            Index: VARIANT,
            ComponentType: ?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IComponentTypes,
            ComponentType: ?*IComponentType,
            NewIndex: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IComponentTypes,
            Index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IComponentTypes,
            NewList: ?*?*IComponentTypes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentTypes.VTable, self.vtable).get_Count(@ptrCast(*const IComponentTypes, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_get__NewEnum(self: *const T, ppNewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentTypes.VTable, self.vtable).get__NewEnum(@ptrCast(*const IComponentTypes, self), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_EnumComponentTypes(self: *const T, ppNewEnum: ?*?*IEnumComponentTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentTypes.VTable, self.vtable).EnumComponentTypes(@ptrCast(*const IComponentTypes, self), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_get_Item(self: *const T, Index: VARIANT, ComponentType: ?*?*IComponentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentTypes.VTable, self.vtable).get_Item(@ptrCast(*const IComponentTypes, self), Index, ComponentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_put_Item(self: *const T, Index: VARIANT, ComponentType: ?*IComponentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentTypes.VTable, self.vtable).put_Item(@ptrCast(*const IComponentTypes, self), Index, ComponentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_Add(self: *const T, ComponentType: ?*IComponentType, NewIndex: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentTypes.VTable, self.vtable).Add(@ptrCast(*const IComponentTypes, self), ComponentType, NewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_Remove(self: *const T, Index: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentTypes.VTable, self.vtable).Remove(@ptrCast(*const IComponentTypes, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_Clone(self: *const T, NewList: ?*?*IComponentTypes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentTypes.VTable, self.vtable).Clone(@ptrCast(*const IComponentTypes, self), NewList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponent_Value = @import("../zig.zig").Guid.initString("1a5576fc-0e19-11d3-9d8e-00c04f72d980");
pub const IID_IComponent = &IID_IComponent_Value;
pub const IComponent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IComponent,
            CT: ?*?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Type: fn(
            self: *const IComponent,
            CT: ?*IComponentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DescLangID: fn(
            self: *const IComponent,
            LangID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DescLangID: fn(
            self: *const IComponent,
            LangID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: fn(
            self: *const IComponent,
            Status: ?*ComponentStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Status: fn(
            self: *const IComponent,
            Status: ComponentStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IComponent,
            Description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IComponent,
            Description: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IComponent,
            NewComponent: ?*?*IComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_get_Type(self: *const T, CT: ?*?*IComponentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).get_Type(@ptrCast(*const IComponent, self), CT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_put_Type(self: *const T, CT: ?*IComponentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).put_Type(@ptrCast(*const IComponent, self), CT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_get_DescLangID(self: *const T, LangID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).get_DescLangID(@ptrCast(*const IComponent, self), LangID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_put_DescLangID(self: *const T, LangID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).put_DescLangID(@ptrCast(*const IComponent, self), LangID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_get_Status(self: *const T, Status: ?*ComponentStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).get_Status(@ptrCast(*const IComponent, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_put_Status(self: *const T, Status: ComponentStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).put_Status(@ptrCast(*const IComponent, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_get_Description(self: *const T, Description: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).get_Description(@ptrCast(*const IComponent, self), Description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_put_Description(self: *const T, Description: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).put_Description(@ptrCast(*const IComponent, self), Description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_Clone(self: *const T, NewComponent: ?*?*IComponent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).Clone(@ptrCast(*const IComponent, self), NewComponent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAnalogAudioComponentType_Value = @import("../zig.zig").Guid.initString("2cfeb2a8-1787-4a24-a941-c6eaec39c842");
pub const IID_IAnalogAudioComponentType = &IID_IAnalogAudioComponentType_Value;
pub const IAnalogAudioComponentType = extern struct {
    pub const VTable = extern struct {
        base: IComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AnalogAudioMode: fn(
            self: *const IAnalogAudioComponentType,
            Mode: ?*TVAudioMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AnalogAudioMode: fn(
            self: *const IAnalogAudioComponentType,
            Mode: TVAudioMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponentType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogAudioComponentType_get_AnalogAudioMode(self: *const T, Mode: ?*TVAudioMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogAudioComponentType.VTable, self.vtable).get_AnalogAudioMode(@ptrCast(*const IAnalogAudioComponentType, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogAudioComponentType_put_AnalogAudioMode(self: *const T, Mode: TVAudioMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogAudioComponentType.VTable, self.vtable).put_AnalogAudioMode(@ptrCast(*const IAnalogAudioComponentType, self), Mode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2Component_Value = @import("../zig.zig").Guid.initString("1493e353-1eb6-473c-802d-8e6b8ec9d2a9");
pub const IID_IMPEG2Component = &IID_IMPEG2Component_Value;
pub const IMPEG2Component = extern struct {
    pub const VTable = extern struct {
        base: IComponent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PID: fn(
            self: *const IMPEG2Component,
            PID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PID: fn(
            self: *const IMPEG2Component,
            PID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PCRPID: fn(
            self: *const IMPEG2Component,
            PCRPID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PCRPID: fn(
            self: *const IMPEG2Component,
            PCRPID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgramNumber: fn(
            self: *const IMPEG2Component,
            ProgramNumber: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProgramNumber: fn(
            self: *const IMPEG2Component,
            ProgramNumber: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_get_PID(self: *const T, PID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2Component.VTable, self.vtable).get_PID(@ptrCast(*const IMPEG2Component, self), PID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_put_PID(self: *const T, PID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2Component.VTable, self.vtable).put_PID(@ptrCast(*const IMPEG2Component, self), PID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_get_PCRPID(self: *const T, PCRPID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2Component.VTable, self.vtable).get_PCRPID(@ptrCast(*const IMPEG2Component, self), PCRPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_put_PCRPID(self: *const T, PCRPID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2Component.VTable, self.vtable).put_PCRPID(@ptrCast(*const IMPEG2Component, self), PCRPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_get_ProgramNumber(self: *const T, ProgramNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2Component.VTable, self.vtable).get_ProgramNumber(@ptrCast(*const IMPEG2Component, self), ProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_put_ProgramNumber(self: *const T, ProgramNumber: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2Component.VTable, self.vtable).put_ProgramNumber(@ptrCast(*const IMPEG2Component, self), ProgramNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumComponents_Value = @import("../zig.zig").Guid.initString("2a6e2939-2595-11d3-b64c-00c04f79498e");
pub const IID_IEnumComponents = &IID_IEnumComponents_Value;
pub const IEnumComponents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumComponents,
            celt: u32,
            rgelt: [*]?*IComponent,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumComponents,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumComponents,
            ppEnum: ?*?*IEnumComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponents_Next(self: *const T, celt: u32, rgelt: [*]?*IComponent, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumComponents.VTable, self.vtable).Next(@ptrCast(*const IEnumComponents, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponents_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumComponents.VTable, self.vtable).Skip(@ptrCast(*const IEnumComponents, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponents_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumComponents.VTable, self.vtable).Reset(@ptrCast(*const IEnumComponents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponents_Clone(self: *const T, ppEnum: ?*?*IEnumComponents) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumComponents.VTable, self.vtable).Clone(@ptrCast(*const IEnumComponents, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IComponents_Value = @import("../zig.zig").Guid.initString("39a48091-fffe-4182-a161-3ff802640e26");
pub const IID_IComponents = &IID_IComponents_Value;
pub const IComponents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IComponents,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IComponents,
            ppNewEnum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumComponents: fn(
            self: *const IComponents,
            ppNewEnum: ?*?*IEnumComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IComponents,
            Index: VARIANT,
            ppComponent: ?*?*IComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IComponents,
            Component: ?*IComponent,
            NewIndex: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IComponents,
            Index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IComponents,
            NewList: ?*?*IComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Item: fn(
            self: *const IComponents,
            Index: VARIANT,
            ppComponent: ?*IComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponents.VTable, self.vtable).get_Count(@ptrCast(*const IComponents, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_get__NewEnum(self: *const T, ppNewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponents.VTable, self.vtable).get__NewEnum(@ptrCast(*const IComponents, self), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_EnumComponents(self: *const T, ppNewEnum: ?*?*IEnumComponents) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponents.VTable, self.vtable).EnumComponents(@ptrCast(*const IComponents, self), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_get_Item(self: *const T, Index: VARIANT, ppComponent: ?*?*IComponent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponents.VTable, self.vtable).get_Item(@ptrCast(*const IComponents, self), Index, ppComponent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_Add(self: *const T, Component: ?*IComponent, NewIndex: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponents.VTable, self.vtable).Add(@ptrCast(*const IComponents, self), Component, NewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_Remove(self: *const T, Index: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponents.VTable, self.vtable).Remove(@ptrCast(*const IComponents, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_Clone(self: *const T, NewList: ?*?*IComponents) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponents.VTable, self.vtable).Clone(@ptrCast(*const IComponents, self), NewList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_put_Item(self: *const T, Index: VARIANT, ppComponent: ?*IComponent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponents.VTable, self.vtable).put_Item(@ptrCast(*const IComponents, self), Index, ppComponent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IComponentsOld_Value = @import("../zig.zig").Guid.initString("fcd01846-0e19-11d3-9d8e-00c04f72d980");
pub const IID_IComponentsOld = &IID_IComponentsOld_Value;
pub const IComponentsOld = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IComponentsOld,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IComponentsOld,
            ppNewEnum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumComponents: fn(
            self: *const IComponentsOld,
            ppNewEnum: ?*?*IEnumComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IComponentsOld,
            Index: VARIANT,
            ppComponent: ?*?*IComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IComponentsOld,
            Component: ?*IComponent,
            NewIndex: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IComponentsOld,
            Index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IComponentsOld,
            NewList: ?*?*IComponents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentsOld.VTable, self.vtable).get_Count(@ptrCast(*const IComponentsOld, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_get__NewEnum(self: *const T, ppNewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentsOld.VTable, self.vtable).get__NewEnum(@ptrCast(*const IComponentsOld, self), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_EnumComponents(self: *const T, ppNewEnum: ?*?*IEnumComponents) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentsOld.VTable, self.vtable).EnumComponents(@ptrCast(*const IComponentsOld, self), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_get_Item(self: *const T, Index: VARIANT, ppComponent: ?*?*IComponent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentsOld.VTable, self.vtable).get_Item(@ptrCast(*const IComponentsOld, self), Index, ppComponent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_Add(self: *const T, Component: ?*IComponent, NewIndex: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentsOld.VTable, self.vtable).Add(@ptrCast(*const IComponentsOld, self), Component, NewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_Remove(self: *const T, Index: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentsOld.VTable, self.vtable).Remove(@ptrCast(*const IComponentsOld, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_Clone(self: *const T, NewList: ?*?*IComponents) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentsOld.VTable, self.vtable).Clone(@ptrCast(*const IComponentsOld, self), NewList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ILocator_Value = @import("../zig.zig").Guid.initString("286d7f89-760c-4f89-80c4-66841d2507aa");
pub const IID_ILocator = &IID_ILocator_Value;
pub const ILocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CarrierFrequency: fn(
            self: *const ILocator,
            Frequency: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CarrierFrequency: fn(
            self: *const ILocator,
            Frequency: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFEC: fn(
            self: *const ILocator,
            FEC: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFEC: fn(
            self: *const ILocator,
            FEC: FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFECRate: fn(
            self: *const ILocator,
            FEC: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFECRate: fn(
            self: *const ILocator,
            FEC: BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFEC: fn(
            self: *const ILocator,
            FEC: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFEC: fn(
            self: *const ILocator,
            FEC: FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFECRate: fn(
            self: *const ILocator,
            FEC: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFECRate: fn(
            self: *const ILocator,
            FEC: BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Modulation: fn(
            self: *const ILocator,
            Modulation: ?*ModulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Modulation: fn(
            self: *const ILocator,
            Modulation: ModulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SymbolRate: fn(
            self: *const ILocator,
            Rate: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SymbolRate: fn(
            self: *const ILocator,
            Rate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const ILocator,
            NewLocator: ?*?*ILocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_CarrierFrequency(self: *const T, Frequency: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).get_CarrierFrequency(@ptrCast(*const ILocator, self), Frequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_CarrierFrequency(self: *const T, Frequency: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).put_CarrierFrequency(@ptrCast(*const ILocator, self), Frequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_InnerFEC(self: *const T, FEC: ?*FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).get_InnerFEC(@ptrCast(*const ILocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_InnerFEC(self: *const T, FEC: FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).put_InnerFEC(@ptrCast(*const ILocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_InnerFECRate(self: *const T, FEC: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).get_InnerFECRate(@ptrCast(*const ILocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_InnerFECRate(self: *const T, FEC: BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).put_InnerFECRate(@ptrCast(*const ILocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_OuterFEC(self: *const T, FEC: ?*FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).get_OuterFEC(@ptrCast(*const ILocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_OuterFEC(self: *const T, FEC: FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).put_OuterFEC(@ptrCast(*const ILocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_OuterFECRate(self: *const T, FEC: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).get_OuterFECRate(@ptrCast(*const ILocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_OuterFECRate(self: *const T, FEC: BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).put_OuterFECRate(@ptrCast(*const ILocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_Modulation(self: *const T, Modulation: ?*ModulationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).get_Modulation(@ptrCast(*const ILocator, self), Modulation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_Modulation(self: *const T, Modulation: ModulationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).put_Modulation(@ptrCast(*const ILocator, self), Modulation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_SymbolRate(self: *const T, Rate: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).get_SymbolRate(@ptrCast(*const ILocator, self), Rate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_SymbolRate(self: *const T, Rate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).put_SymbolRate(@ptrCast(*const ILocator, self), Rate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_Clone(self: *const T, NewLocator: ?*?*ILocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocator.VTable, self.vtable).Clone(@ptrCast(*const ILocator, self), NewLocator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAnalogLocator_Value = @import("../zig.zig").Guid.initString("34d1f26b-e339-430d-abce-738cb48984dc");
pub const IID_IAnalogLocator = &IID_IAnalogLocator_Value;
pub const IAnalogLocator = extern struct {
    pub const VTable = extern struct {
        base: ILocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoStandard: fn(
            self: *const IAnalogLocator,
            AVS: ?*AnalogVideoStandard,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VideoStandard: fn(
            self: *const IAnalogLocator,
            AVS: AnalogVideoStandard,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ILocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogLocator_get_VideoStandard(self: *const T, AVS: ?*AnalogVideoStandard) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogLocator.VTable, self.vtable).get_VideoStandard(@ptrCast(*const IAnalogLocator, self), AVS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogLocator_put_VideoStandard(self: *const T, AVS: AnalogVideoStandard) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnalogLocator.VTable, self.vtable).put_VideoStandard(@ptrCast(*const IAnalogLocator, self), AVS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalLocator_Value = @import("../zig.zig").Guid.initString("19b595d8-839a-47f0-96df-4f194f3c768c");
pub const IID_IDigitalLocator = &IID_IDigitalLocator_Value;
pub const IDigitalLocator = extern struct {
    pub const VTable = extern struct {
        base: ILocator.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ILocator.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCLocator_Value = @import("../zig.zig").Guid.initString("bf8d986f-8c2b-4131-94d7-4d3d9fcc21ef");
pub const IID_IATSCLocator = &IID_IATSCLocator_Value;
pub const IATSCLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhysicalChannel: fn(
            self: *const IATSCLocator,
            PhysicalChannel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PhysicalChannel: fn(
            self: *const IATSCLocator,
            PhysicalChannel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TSID: fn(
            self: *const IATSCLocator,
            TSID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TSID: fn(
            self: *const IATSCLocator,
            TSID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDigitalLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator_get_PhysicalChannel(self: *const T, PhysicalChannel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCLocator.VTable, self.vtable).get_PhysicalChannel(@ptrCast(*const IATSCLocator, self), PhysicalChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator_put_PhysicalChannel(self: *const T, PhysicalChannel: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCLocator.VTable, self.vtable).put_PhysicalChannel(@ptrCast(*const IATSCLocator, self), PhysicalChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator_get_TSID(self: *const T, TSID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCLocator.VTable, self.vtable).get_TSID(@ptrCast(*const IATSCLocator, self), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator_put_TSID(self: *const T, TSID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCLocator.VTable, self.vtable).put_TSID(@ptrCast(*const IATSCLocator, self), TSID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IATSCLocator2_Value = @import("../zig.zig").Guid.initString("612aa885-66cf-4090-ba0a-566f5312e4ca");
pub const IID_IATSCLocator2 = &IID_IATSCLocator2_Value;
pub const IATSCLocator2 = extern struct {
    pub const VTable = extern struct {
        base: IATSCLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgramNumber: fn(
            self: *const IATSCLocator2,
            ProgramNumber: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProgramNumber: fn(
            self: *const IATSCLocator2,
            ProgramNumber: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IATSCLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator2_get_ProgramNumber(self: *const T, ProgramNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCLocator2.VTable, self.vtable).get_ProgramNumber(@ptrCast(*const IATSCLocator2, self), ProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator2_put_ProgramNumber(self: *const T, ProgramNumber: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSCLocator2.VTable, self.vtable).put_ProgramNumber(@ptrCast(*const IATSCLocator2, self), ProgramNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalCableLocator_Value = @import("../zig.zig").Guid.initString("48f66a11-171a-419a-9525-beeecd51584c");
pub const IID_IDigitalCableLocator = &IID_IDigitalCableLocator_Value;
pub const IDigitalCableLocator = extern struct {
    pub const VTable = extern struct {
        base: IATSCLocator2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IATSCLocator2.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTLocator_Value = @import("../zig.zig").Guid.initString("8664da16-dda2-42ac-926a-c18f9127c302");
pub const IID_IDVBTLocator = &IID_IDVBTLocator_Value;
pub const IDVBTLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bandwidth: fn(
            self: *const IDVBTLocator,
            BandWidthVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bandwidth: fn(
            self: *const IDVBTLocator,
            BandwidthVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LPInnerFEC: fn(
            self: *const IDVBTLocator,
            FEC: ?*FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LPInnerFEC: fn(
            self: *const IDVBTLocator,
            FEC: FECMethod,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LPInnerFECRate: fn(
            self: *const IDVBTLocator,
            FEC: ?*BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LPInnerFECRate: fn(
            self: *const IDVBTLocator,
            FEC: BinaryConvolutionCodeRate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HAlpha: fn(
            self: *const IDVBTLocator,
            Alpha: ?*HierarchyAlpha,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HAlpha: fn(
            self: *const IDVBTLocator,
            Alpha: HierarchyAlpha,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guard: fn(
            self: *const IDVBTLocator,
            GI: ?*GuardInterval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Guard: fn(
            self: *const IDVBTLocator,
            GI: GuardInterval,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: fn(
            self: *const IDVBTLocator,
            mode: ?*TransmissionMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: fn(
            self: *const IDVBTLocator,
            mode: TransmissionMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OtherFrequencyInUse: fn(
            self: *const IDVBTLocator,
            OtherFrequencyInUseVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OtherFrequencyInUse: fn(
            self: *const IDVBTLocator,
            OtherFrequencyInUseVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDigitalLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_Bandwidth(self: *const T, BandWidthVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).get_Bandwidth(@ptrCast(*const IDVBTLocator, self), BandWidthVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_Bandwidth(self: *const T, BandwidthVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).put_Bandwidth(@ptrCast(*const IDVBTLocator, self), BandwidthVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_LPInnerFEC(self: *const T, FEC: ?*FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).get_LPInnerFEC(@ptrCast(*const IDVBTLocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_LPInnerFEC(self: *const T, FEC: FECMethod) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).put_LPInnerFEC(@ptrCast(*const IDVBTLocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_LPInnerFECRate(self: *const T, FEC: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).get_LPInnerFECRate(@ptrCast(*const IDVBTLocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_LPInnerFECRate(self: *const T, FEC: BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).put_LPInnerFECRate(@ptrCast(*const IDVBTLocator, self), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_HAlpha(self: *const T, Alpha: ?*HierarchyAlpha) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).get_HAlpha(@ptrCast(*const IDVBTLocator, self), Alpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_HAlpha(self: *const T, Alpha: HierarchyAlpha) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).put_HAlpha(@ptrCast(*const IDVBTLocator, self), Alpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_Guard(self: *const T, GI: ?*GuardInterval) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).get_Guard(@ptrCast(*const IDVBTLocator, self), GI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_Guard(self: *const T, GI: GuardInterval) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).put_Guard(@ptrCast(*const IDVBTLocator, self), GI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_Mode(self: *const T, mode: ?*TransmissionMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).get_Mode(@ptrCast(*const IDVBTLocator, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_Mode(self: *const T, mode: TransmissionMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).put_Mode(@ptrCast(*const IDVBTLocator, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_OtherFrequencyInUse(self: *const T, OtherFrequencyInUseVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).get_OtherFrequencyInUse(@ptrCast(*const IDVBTLocator, self), OtherFrequencyInUseVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_OtherFrequencyInUse(self: *const T, OtherFrequencyInUseVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator.VTable, self.vtable).put_OtherFrequencyInUse(@ptrCast(*const IDVBTLocator, self), OtherFrequencyInUseVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDVBTLocator2_Value = @import("../zig.zig").Guid.initString("448a2edf-ae95-4b43-a3cc-747843c453d4");
pub const IID_IDVBTLocator2 = &IID_IDVBTLocator2_Value;
pub const IDVBTLocator2 = extern struct {
    pub const VTable = extern struct {
        base: IDVBTLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhysicalLayerPipeId: fn(
            self: *const IDVBTLocator2,
            PhysicalLayerPipeIdVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PhysicalLayerPipeId: fn(
            self: *const IDVBTLocator2,
            PhysicalLayerPipeIdVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBTLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator2_get_PhysicalLayerPipeId(self: *const T, PhysicalLayerPipeIdVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator2.VTable, self.vtable).get_PhysicalLayerPipeId(@ptrCast(*const IDVBTLocator2, self), PhysicalLayerPipeIdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator2_put_PhysicalLayerPipeId(self: *const T, PhysicalLayerPipeIdVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBTLocator2.VTable, self.vtable).put_PhysicalLayerPipeId(@ptrCast(*const IDVBTLocator2, self), PhysicalLayerPipeIdVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBSLocator_Value = @import("../zig.zig").Guid.initString("3d7c353c-0d04-45f1-a742-f97cc1188dc8");
pub const IID_IDVBSLocator = &IID_IDVBSLocator_Value;
pub const IDVBSLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalPolarisation: fn(
            self: *const IDVBSLocator,
            PolarisationVal: ?*Polarisation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalPolarisation: fn(
            self: *const IDVBSLocator,
            PolarisationVal: Polarisation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WestPosition: fn(
            self: *const IDVBSLocator,
            WestLongitude: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WestPosition: fn(
            self: *const IDVBSLocator,
            WestLongitude: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OrbitalPosition: fn(
            self: *const IDVBSLocator,
            longitude: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OrbitalPosition: fn(
            self: *const IDVBSLocator,
            longitude: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Azimuth: fn(
            self: *const IDVBSLocator,
            Azimuth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Azimuth: fn(
            self: *const IDVBSLocator,
            Azimuth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Elevation: fn(
            self: *const IDVBSLocator,
            Elevation: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Elevation: fn(
            self: *const IDVBSLocator,
            Elevation: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDigitalLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_SignalPolarisation(self: *const T, PolarisationVal: ?*Polarisation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).get_SignalPolarisation(@ptrCast(*const IDVBSLocator, self), PolarisationVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_SignalPolarisation(self: *const T, PolarisationVal: Polarisation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).put_SignalPolarisation(@ptrCast(*const IDVBSLocator, self), PolarisationVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_WestPosition(self: *const T, WestLongitude: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).get_WestPosition(@ptrCast(*const IDVBSLocator, self), WestLongitude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_WestPosition(self: *const T, WestLongitude: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).put_WestPosition(@ptrCast(*const IDVBSLocator, self), WestLongitude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_OrbitalPosition(self: *const T, longitude: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).get_OrbitalPosition(@ptrCast(*const IDVBSLocator, self), longitude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_OrbitalPosition(self: *const T, longitude: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).put_OrbitalPosition(@ptrCast(*const IDVBSLocator, self), longitude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_Azimuth(self: *const T, Azimuth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).get_Azimuth(@ptrCast(*const IDVBSLocator, self), Azimuth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_Azimuth(self: *const T, Azimuth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).put_Azimuth(@ptrCast(*const IDVBSLocator, self), Azimuth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_Elevation(self: *const T, Elevation: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).get_Elevation(@ptrCast(*const IDVBSLocator, self), Elevation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_Elevation(self: *const T, Elevation: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator.VTable, self.vtable).put_Elevation(@ptrCast(*const IDVBSLocator, self), Elevation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDVBSLocator2_Value = @import("../zig.zig").Guid.initString("6044634a-1733-4f99-b982-5fb12afce4f0");
pub const IID_IDVBSLocator2 = &IID_IDVBSLocator2_Value;
pub const IDVBSLocator2 = extern struct {
    pub const VTable = extern struct {
        base: IDVBSLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiseqLNBSource: fn(
            self: *const IDVBSLocator2,
            DiseqLNBSourceVal: ?*LNB_Source,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqLNBSource: fn(
            self: *const IDVBSLocator2,
            DiseqLNBSourceVal: LNB_Source,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscillatorOverrideLow: fn(
            self: *const IDVBSLocator2,
            LocalOscillatorOverrideLowVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscillatorOverrideLow: fn(
            self: *const IDVBSLocator2,
            LocalOscillatorOverrideLowVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscillatorOverrideHigh: fn(
            self: *const IDVBSLocator2,
            LocalOscillatorOverrideHighVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscillatorOverrideHigh: fn(
            self: *const IDVBSLocator2,
            LocalOscillatorOverrideHighVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalLNBSwitchOverride: fn(
            self: *const IDVBSLocator2,
            LocalLNBSwitchOverrideVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalLNBSwitchOverride: fn(
            self: *const IDVBSLocator2,
            LocalLNBSwitchOverrideVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalSpectralInversionOverride: fn(
            self: *const IDVBSLocator2,
            LocalSpectralInversionOverrideVal: ?*SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalSpectralInversionOverride: fn(
            self: *const IDVBSLocator2,
            LocalSpectralInversionOverrideVal: SpectralInversion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalRollOff: fn(
            self: *const IDVBSLocator2,
            RollOffVal: ?*RollOff,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalRollOff: fn(
            self: *const IDVBSLocator2,
            RollOffVal: RollOff,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalPilot: fn(
            self: *const IDVBSLocator2,
            PilotVal: ?*Pilot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalPilot: fn(
            self: *const IDVBSLocator2,
            PilotVal: Pilot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBSLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_DiseqLNBSource(self: *const T, DiseqLNBSourceVal: ?*LNB_Source) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).get_DiseqLNBSource(@ptrCast(*const IDVBSLocator2, self), DiseqLNBSourceVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_DiseqLNBSource(self: *const T, DiseqLNBSourceVal: LNB_Source) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).put_DiseqLNBSource(@ptrCast(*const IDVBSLocator2, self), DiseqLNBSourceVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_LocalOscillatorOverrideLow(self: *const T, LocalOscillatorOverrideLowVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).get_LocalOscillatorOverrideLow(@ptrCast(*const IDVBSLocator2, self), LocalOscillatorOverrideLowVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_LocalOscillatorOverrideLow(self: *const T, LocalOscillatorOverrideLowVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).put_LocalOscillatorOverrideLow(@ptrCast(*const IDVBSLocator2, self), LocalOscillatorOverrideLowVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_LocalOscillatorOverrideHigh(self: *const T, LocalOscillatorOverrideHighVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).get_LocalOscillatorOverrideHigh(@ptrCast(*const IDVBSLocator2, self), LocalOscillatorOverrideHighVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_LocalOscillatorOverrideHigh(self: *const T, LocalOscillatorOverrideHighVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).put_LocalOscillatorOverrideHigh(@ptrCast(*const IDVBSLocator2, self), LocalOscillatorOverrideHighVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_LocalLNBSwitchOverride(self: *const T, LocalLNBSwitchOverrideVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).get_LocalLNBSwitchOverride(@ptrCast(*const IDVBSLocator2, self), LocalLNBSwitchOverrideVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_LocalLNBSwitchOverride(self: *const T, LocalLNBSwitchOverrideVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).put_LocalLNBSwitchOverride(@ptrCast(*const IDVBSLocator2, self), LocalLNBSwitchOverrideVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_LocalSpectralInversionOverride(self: *const T, LocalSpectralInversionOverrideVal: ?*SpectralInversion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).get_LocalSpectralInversionOverride(@ptrCast(*const IDVBSLocator2, self), LocalSpectralInversionOverrideVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_LocalSpectralInversionOverride(self: *const T, LocalSpectralInversionOverrideVal: SpectralInversion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).put_LocalSpectralInversionOverride(@ptrCast(*const IDVBSLocator2, self), LocalSpectralInversionOverrideVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_SignalRollOff(self: *const T, RollOffVal: ?*RollOff) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).get_SignalRollOff(@ptrCast(*const IDVBSLocator2, self), RollOffVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_SignalRollOff(self: *const T, RollOffVal: RollOff) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).put_SignalRollOff(@ptrCast(*const IDVBSLocator2, self), RollOffVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_SignalPilot(self: *const T, PilotVal: ?*Pilot) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).get_SignalPilot(@ptrCast(*const IDVBSLocator2, self), PilotVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_SignalPilot(self: *const T, PilotVal: Pilot) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVBSLocator2.VTable, self.vtable).put_SignalPilot(@ptrCast(*const IDVBSLocator2, self), PilotVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBCLocator_Value = @import("../zig.zig").Guid.initString("6e42f36e-1dd2-43c4-9f78-69d25ae39034");
pub const IID_IDVBCLocator = &IID_IDVBCLocator_Value;
pub const IDVBCLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDigitalLocator.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IISDBSLocator_Value = @import("../zig.zig").Guid.initString("c9897087-e29c-473f-9e4b-7072123dea14");
pub const IID_IISDBSLocator = &IID_IISDBSLocator_Value;
pub const IISDBSLocator = extern struct {
    pub const VTable = extern struct {
        base: IDVBSLocator.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBSLocator.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESOpenMmiEvent_Value = @import("../zig.zig").Guid.initString("ba4b6526-1a35-4635-8b56-3ec612746a8c");
pub const IID_IESOpenMmiEvent = &IID_IESOpenMmiEvent_Value;
pub const IESOpenMmiEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetDialogNumber: fn(
            self: *const IESOpenMmiEvent,
            pDialogRequest: ?*u32,
            pDialogNumber: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDialogType: fn(
            self: *const IESOpenMmiEvent,
            guidDialogType: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDialogData: fn(
            self: *const IESOpenMmiEvent,
            pbData: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDialogStringData: fn(
            self: *const IESOpenMmiEvent,
            pbstrBaseUrl: ?*?BSTR,
            pbstrData: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESOpenMmiEvent_GetDialogNumber(self: *const T, pDialogRequest: ?*u32, pDialogNumber: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESOpenMmiEvent.VTable, self.vtable).GetDialogNumber(@ptrCast(*const IESOpenMmiEvent, self), pDialogRequest, pDialogNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESOpenMmiEvent_GetDialogType(self: *const T, guidDialogType: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESOpenMmiEvent.VTable, self.vtable).GetDialogType(@ptrCast(*const IESOpenMmiEvent, self), guidDialogType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESOpenMmiEvent_GetDialogData(self: *const T, pbData: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESOpenMmiEvent.VTable, self.vtable).GetDialogData(@ptrCast(*const IESOpenMmiEvent, self), pbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESOpenMmiEvent_GetDialogStringData(self: *const T, pbstrBaseUrl: ?*?BSTR, pbstrData: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESOpenMmiEvent.VTable, self.vtable).GetDialogStringData(@ptrCast(*const IESOpenMmiEvent, self), pbstrBaseUrl, pbstrData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESCloseMmiEvent_Value = @import("../zig.zig").Guid.initString("6b80e96f-55e2-45aa-b754-0c23c8e7d5c1");
pub const IID_IESCloseMmiEvent = &IID_IESCloseMmiEvent_Value;
pub const IESCloseMmiEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetDialogNumber: fn(
            self: *const IESCloseMmiEvent,
            pDialogNumber: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESCloseMmiEvent_GetDialogNumber(self: *const T, pDialogNumber: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESCloseMmiEvent.VTable, self.vtable).GetDialogNumber(@ptrCast(*const IESCloseMmiEvent, self), pDialogNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESValueUpdatedEvent_Value = @import("../zig.zig").Guid.initString("8a24c46e-bb63-4664-8602-5d9c718c146d");
pub const IID_IESValueUpdatedEvent = &IID_IESValueUpdatedEvent_Value;
pub const IESValueUpdatedEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetValueNames: fn(
            self: *const IESValueUpdatedEvent,
            pbstrNames: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESValueUpdatedEvent_GetValueNames(self: *const T, pbstrNames: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESValueUpdatedEvent.VTable, self.vtable).GetValueNames(@ptrCast(*const IESValueUpdatedEvent, self), pbstrNames);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESRequestTunerEvent_Value = @import("../zig.zig").Guid.initString("54c7a5e8-c3bb-4f51-af14-e0e2c0e34c6d");
pub const IID_IESRequestTunerEvent = &IID_IESRequestTunerEvent_Value;
pub const IESRequestTunerEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetPriority: fn(
            self: *const IESRequestTunerEvent,
            pbyPriority: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReason: fn(
            self: *const IESRequestTunerEvent,
            pbyReason: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConsequences: fn(
            self: *const IESRequestTunerEvent,
            pbyConsequences: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEstimatedTime: fn(
            self: *const IESRequestTunerEvent,
            pdwEstimatedTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESRequestTunerEvent_GetPriority(self: *const T, pbyPriority: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESRequestTunerEvent.VTable, self.vtable).GetPriority(@ptrCast(*const IESRequestTunerEvent, self), pbyPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESRequestTunerEvent_GetReason(self: *const T, pbyReason: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESRequestTunerEvent.VTable, self.vtable).GetReason(@ptrCast(*const IESRequestTunerEvent, self), pbyReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESRequestTunerEvent_GetConsequences(self: *const T, pbyConsequences: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESRequestTunerEvent.VTable, self.vtable).GetConsequences(@ptrCast(*const IESRequestTunerEvent, self), pbyConsequences);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESRequestTunerEvent_GetEstimatedTime(self: *const T, pdwEstimatedTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESRequestTunerEvent.VTable, self.vtable).GetEstimatedTime(@ptrCast(*const IESRequestTunerEvent, self), pdwEstimatedTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESIsdbCasResponseEvent_Value = @import("../zig.zig").Guid.initString("2017cb03-dc0f-4c24-83ca-36307b2cd19f");
pub const IID_IESIsdbCasResponseEvent = &IID_IESIsdbCasResponseEvent_Value;
pub const IESIsdbCasResponseEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetRequestId: fn(
            self: *const IESIsdbCasResponseEvent,
            pRequestId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const IESIsdbCasResponseEvent,
            pStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataLength: fn(
            self: *const IESIsdbCasResponseEvent,
            pRequestLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResponseData: fn(
            self: *const IESIsdbCasResponseEvent,
            pbData: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESIsdbCasResponseEvent_GetRequestId(self: *const T, pRequestId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESIsdbCasResponseEvent.VTable, self.vtable).GetRequestId(@ptrCast(*const IESIsdbCasResponseEvent, self), pRequestId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESIsdbCasResponseEvent_GetStatus(self: *const T, pStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESIsdbCasResponseEvent.VTable, self.vtable).GetStatus(@ptrCast(*const IESIsdbCasResponseEvent, self), pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESIsdbCasResponseEvent_GetDataLength(self: *const T, pRequestLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESIsdbCasResponseEvent.VTable, self.vtable).GetDataLength(@ptrCast(*const IESIsdbCasResponseEvent, self), pRequestLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESIsdbCasResponseEvent_GetResponseData(self: *const T, pbData: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESIsdbCasResponseEvent.VTable, self.vtable).GetResponseData(@ptrCast(*const IESIsdbCasResponseEvent, self), pbData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGpnvsCommonBase_Value = @import("../zig.zig").Guid.initString("907e0b5c-e42d-4f04-91f0-26f401f36907");
pub const IID_IGpnvsCommonBase = &IID_IGpnvsCommonBase_Value;
pub const IGpnvsCommonBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValueUpdateName: fn(
            self: *const IGpnvsCommonBase,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGpnvsCommonBase_GetValueUpdateName(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGpnvsCommonBase.VTable, self.vtable).GetValueUpdateName(@ptrCast(*const IGpnvsCommonBase, self), pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IESEventFactory_Value = @import("../zig.zig").Guid.initString("506a09b8-7f86-4e04-ac05-3303bfe8fc49");
pub const IID_IESEventFactory = &IID_IESEventFactory_Value;
pub const IESEventFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateESEvent: fn(
            self: *const IESEventFactory,
            pServiceProvider: ?*IUnknown,
            dwEventId: u32,
            guidEventType: Guid,
            dwEventDataLength: u32,
            pEventData: [*:0]u8,
            bstrBaseUrl: ?BSTR,
            pInitContext: ?*IUnknown,
            ppESEvent: ?*?*IESEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventFactory_CreateESEvent(self: *const T, pServiceProvider: ?*IUnknown, dwEventId: u32, guidEventType: Guid, dwEventDataLength: u32, pEventData: [*:0]u8, bstrBaseUrl: ?BSTR, pInitContext: ?*IUnknown, ppESEvent: ?*?*IESEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEventFactory.VTable, self.vtable).CreateESEvent(@ptrCast(*const IESEventFactory, self), pServiceProvider, dwEventId, guidEventType, dwEventDataLength, pEventData, bstrBaseUrl, pInitContext, ppESEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESLicenseRenewalResultEvent_Value = @import("../zig.zig").Guid.initString("d5a48ef5-a81b-4df0-acaa-5e35e7ea45d4");
pub const IID_IESLicenseRenewalResultEvent = &IID_IESLicenseRenewalResultEvent_Value;
pub const IESLicenseRenewalResultEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetCallersId: fn(
            self: *const IESLicenseRenewalResultEvent,
            pdwCallersId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: fn(
            self: *const IESLicenseRenewalResultEvent,
            pbstrFilename: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRenewalSuccessful: fn(
            self: *const IESLicenseRenewalResultEvent,
            pfRenewalSuccessful: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCheckEntitlementCallRequired: fn(
            self: *const IESLicenseRenewalResultEvent,
            pfCheckEntTokenCallNeeded: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescrambledStatus: fn(
            self: *const IESLicenseRenewalResultEvent,
            pDescrambledStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenewalResultCode: fn(
            self: *const IESLicenseRenewalResultEvent,
            pdwRenewalResultCode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASFailureCode: fn(
            self: *const IESLicenseRenewalResultEvent,
            pdwCASFailureCode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenewalHResult: fn(
            self: *const IESLicenseRenewalResultEvent,
            phr: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntitlementTokenLength: fn(
            self: *const IESLicenseRenewalResultEvent,
            pdwLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntitlementToken: fn(
            self: *const IESLicenseRenewalResultEvent,
            pbData: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpiryDate: fn(
            self: *const IESLicenseRenewalResultEvent,
            pqwExpiryDate: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetCallersId(self: *const T, pdwCallersId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).GetCallersId(@ptrCast(*const IESLicenseRenewalResultEvent, self), pdwCallersId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetFileName(self: *const T, pbstrFilename: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).GetFileName(@ptrCast(*const IESLicenseRenewalResultEvent, self), pbstrFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_IsRenewalSuccessful(self: *const T, pfRenewalSuccessful: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).IsRenewalSuccessful(@ptrCast(*const IESLicenseRenewalResultEvent, self), pfRenewalSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_IsCheckEntitlementCallRequired(self: *const T, pfCheckEntTokenCallNeeded: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).IsCheckEntitlementCallRequired(@ptrCast(*const IESLicenseRenewalResultEvent, self), pfCheckEntTokenCallNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetDescrambledStatus(self: *const T, pDescrambledStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).GetDescrambledStatus(@ptrCast(*const IESLicenseRenewalResultEvent, self), pDescrambledStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetRenewalResultCode(self: *const T, pdwRenewalResultCode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).GetRenewalResultCode(@ptrCast(*const IESLicenseRenewalResultEvent, self), pdwRenewalResultCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetCASFailureCode(self: *const T, pdwCASFailureCode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).GetCASFailureCode(@ptrCast(*const IESLicenseRenewalResultEvent, self), pdwCASFailureCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetRenewalHResult(self: *const T, phr: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).GetRenewalHResult(@ptrCast(*const IESLicenseRenewalResultEvent, self), phr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetEntitlementTokenLength(self: *const T, pdwLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).GetEntitlementTokenLength(@ptrCast(*const IESLicenseRenewalResultEvent, self), pdwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetEntitlementToken(self: *const T, pbData: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).GetEntitlementToken(@ptrCast(*const IESLicenseRenewalResultEvent, self), pbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetExpiryDate(self: *const T, pqwExpiryDate: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESLicenseRenewalResultEvent.VTable, self.vtable).GetExpiryDate(@ptrCast(*const IESLicenseRenewalResultEvent, self), pqwExpiryDate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESFileExpiryDateEvent_Value = @import("../zig.zig").Guid.initString("ba9edcb6-4d36-4cfe-8c56-87a6b0ca48e1");
pub const IID_IESFileExpiryDateEvent = &IID_IESFileExpiryDateEvent_Value;
pub const IESFileExpiryDateEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetTunerId: fn(
            self: *const IESFileExpiryDateEvent,
            pguidTunerId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpiryDate: fn(
            self: *const IESFileExpiryDateEvent,
            pqwExpiryDate: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFinalExpiryDate: fn(
            self: *const IESFileExpiryDateEvent,
            pqwExpiryDate: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxRenewalCount: fn(
            self: *const IESFileExpiryDateEvent,
            dwMaxRenewalCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEntitlementTokenPresent: fn(
            self: *const IESFileExpiryDateEvent,
            pfEntTokenPresent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoesExpireAfterFirstUse: fn(
            self: *const IESFileExpiryDateEvent,
            pfExpireAfterFirstUse: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_GetTunerId(self: *const T, pguidTunerId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESFileExpiryDateEvent.VTable, self.vtable).GetTunerId(@ptrCast(*const IESFileExpiryDateEvent, self), pguidTunerId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_GetExpiryDate(self: *const T, pqwExpiryDate: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESFileExpiryDateEvent.VTable, self.vtable).GetExpiryDate(@ptrCast(*const IESFileExpiryDateEvent, self), pqwExpiryDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_GetFinalExpiryDate(self: *const T, pqwExpiryDate: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESFileExpiryDateEvent.VTable, self.vtable).GetFinalExpiryDate(@ptrCast(*const IESFileExpiryDateEvent, self), pqwExpiryDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_GetMaxRenewalCount(self: *const T, dwMaxRenewalCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESFileExpiryDateEvent.VTable, self.vtable).GetMaxRenewalCount(@ptrCast(*const IESFileExpiryDateEvent, self), dwMaxRenewalCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_IsEntitlementTokenPresent(self: *const T, pfEntTokenPresent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESFileExpiryDateEvent.VTable, self.vtable).IsEntitlementTokenPresent(@ptrCast(*const IESFileExpiryDateEvent, self), pfEntTokenPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_DoesExpireAfterFirstUse(self: *const T, pfExpireAfterFirstUse: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESFileExpiryDateEvent.VTable, self.vtable).DoesExpireAfterFirstUse(@ptrCast(*const IESFileExpiryDateEvent, self), pfExpireAfterFirstUse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEventService_Value = @import("../zig.zig").Guid.initString("ed89a619-4c06-4b2f-99eb-c7669b13047c");
pub const IID_IESEventService = &IID_IESEventService_Value;
pub const IESEventService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireESEvent: fn(
            self: *const IESEventService,
            pESEvent: ?*IESEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventService_FireESEvent(self: *const T, pESEvent: ?*IESEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEventService.VTable, self.vtable).FireESEvent(@ptrCast(*const IESEventService, self), pESEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEventServiceConfiguration_Value = @import("../zig.zig").Guid.initString("33b9daae-9309-491d-a051-bcad2a70cd66");
pub const IID_IESEventServiceConfiguration = &IID_IESEventServiceConfiguration_Value;
pub const IESEventServiceConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetParent: fn(
            self: *const IESEventServiceConfiguration,
            pEventService: ?*IESEventService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveParent: fn(
            self: *const IESEventServiceConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOwner: fn(
            self: *const IESEventServiceConfiguration,
            pESEvents: ?*IESEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveOwner: fn(
            self: *const IESEventServiceConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGraph: fn(
            self: *const IESEventServiceConfiguration,
            pGraph: ?*IFilterGraph,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveGraph: fn(
            self: *const IESEventServiceConfiguration,
            pGraph: ?*IFilterGraph,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_SetParent(self: *const T, pEventService: ?*IESEventService) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEventServiceConfiguration.VTable, self.vtable).SetParent(@ptrCast(*const IESEventServiceConfiguration, self), pEventService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_RemoveParent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEventServiceConfiguration.VTable, self.vtable).RemoveParent(@ptrCast(*const IESEventServiceConfiguration, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_SetOwner(self: *const T, pESEvents: ?*IESEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEventServiceConfiguration.VTable, self.vtable).SetOwner(@ptrCast(*const IESEventServiceConfiguration, self), pESEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_RemoveOwner(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEventServiceConfiguration.VTable, self.vtable).RemoveOwner(@ptrCast(*const IESEventServiceConfiguration, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_SetGraph(self: *const T, pGraph: ?*IFilterGraph) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEventServiceConfiguration.VTable, self.vtable).SetGraph(@ptrCast(*const IESEventServiceConfiguration, self), pGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_RemoveGraph(self: *const T, pGraph: ?*IFilterGraph) callconv(.Inline) HRESULT {
            return @ptrCast(*const IESEventServiceConfiguration.VTable, self.vtable).RemoveGraph(@ptrCast(*const IESEventServiceConfiguration, self), pGraph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRegisterTuner_Value = @import("../zig.zig").Guid.initString("359b3901-572c-4854-bb49-cdef66606a25");
pub const IID_IRegisterTuner = &IID_IRegisterTuner_Value;
pub const IRegisterTuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: fn(
            self: *const IRegisterTuner,
            pTuner: ?*ITuner,
            pGraph: ?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: fn(
            self: *const IRegisterTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisterTuner_Register(self: *const T, pTuner: ?*ITuner, pGraph: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisterTuner.VTable, self.vtable).Register(@ptrCast(*const IRegisterTuner, self), pTuner, pGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisterTuner_Unregister(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisterTuner.VTable, self.vtable).Unregister(@ptrCast(*const IRegisterTuner, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDAComparable_Value = @import("../zig.zig").Guid.initString("b34505e0-2f0e-497b-80bc-d43f3b24ed7f");
pub const IID_IBDAComparable = &IID_IBDAComparable_Value;
pub const IBDAComparable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareExact: fn(
            self: *const IBDAComparable,
            CompareTo: ?*IDispatch,
            Result: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEquivalent: fn(
            self: *const IBDAComparable,
            CompareTo: ?*IDispatch,
            dwFlags: u32,
            Result: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HashExact: fn(
            self: *const IBDAComparable,
            Result: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HashExactIncremental: fn(
            self: *const IBDAComparable,
            PartialResult: i64,
            Result: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HashEquivalent: fn(
            self: *const IBDAComparable,
            dwFlags: u32,
            Result: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HashEquivalentIncremental: fn(
            self: *const IBDAComparable,
            PartialResult: i64,
            dwFlags: u32,
            Result: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_CompareExact(self: *const T, CompareTo: ?*IDispatch, Result: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDAComparable.VTable, self.vtable).CompareExact(@ptrCast(*const IBDAComparable, self), CompareTo, Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_CompareEquivalent(self: *const T, CompareTo: ?*IDispatch, dwFlags: u32, Result: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDAComparable.VTable, self.vtable).CompareEquivalent(@ptrCast(*const IBDAComparable, self), CompareTo, dwFlags, Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_HashExact(self: *const T, Result: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDAComparable.VTable, self.vtable).HashExact(@ptrCast(*const IBDAComparable, self), Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_HashExactIncremental(self: *const T, PartialResult: i64, Result: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDAComparable.VTable, self.vtable).HashExactIncremental(@ptrCast(*const IBDAComparable, self), PartialResult, Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_HashEquivalent(self: *const T, dwFlags: u32, Result: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDAComparable.VTable, self.vtable).HashEquivalent(@ptrCast(*const IBDAComparable, self), dwFlags, Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_HashEquivalentIncremental(self: *const T, PartialResult: i64, dwFlags: u32, Result: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDAComparable.VTable, self.vtable).HashEquivalentIncremental(@ptrCast(*const IBDAComparable, self), PartialResult, dwFlags, Result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPersistTuneXml_Value = @import("../zig.zig").Guid.initString("0754cd31-8d15-47a9-8215-d20064157244");
pub const IID_IPersistTuneXml = &IID_IPersistTuneXml_Value;
pub const IPersistTuneXml = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: fn(
            self: *const IPersistTuneXml,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistTuneXml,
            varValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistTuneXml,
            pvarFragment: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXml_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistTuneXml.VTable, self.vtable).InitNew(@ptrCast(*const IPersistTuneXml, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXml_Load(self: *const T, varValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistTuneXml.VTable, self.vtable).Load(@ptrCast(*const IPersistTuneXml, self), varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXml_Save(self: *const T, pvarFragment: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistTuneXml.VTable, self.vtable).Save(@ptrCast(*const IPersistTuneXml, self), pvarFragment);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPersistTuneXmlUtility_Value = @import("../zig.zig").Guid.initString("990237ae-ac11-4614-be8f-dd217a4cb4cb");
pub const IID_IPersistTuneXmlUtility = &IID_IPersistTuneXmlUtility_Value;
pub const IPersistTuneXmlUtility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Deserialize: fn(
            self: *const IPersistTuneXmlUtility,
            varValue: VARIANT,
            ppObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXmlUtility_Deserialize(self: *const T, varValue: VARIANT, ppObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistTuneXmlUtility.VTable, self.vtable).Deserialize(@ptrCast(*const IPersistTuneXmlUtility, self), varValue, ppObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPersistTuneXmlUtility2_Value = @import("../zig.zig").Guid.initString("992e165f-ea24-4b2f-9a1d-009d92120451");
pub const IID_IPersistTuneXmlUtility2 = &IID_IPersistTuneXmlUtility2_Value;
pub const IPersistTuneXmlUtility2 = extern struct {
    pub const VTable = extern struct {
        base: IPersistTuneXmlUtility.VTable,
        Serialize: fn(
            self: *const IPersistTuneXmlUtility2,
            piTuneRequest: ?*ITuneRequest,
            pString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistTuneXmlUtility.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXmlUtility2_Serialize(self: *const T, piTuneRequest: ?*ITuneRequest, pString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistTuneXmlUtility2.VTable, self.vtable).Serialize(@ptrCast(*const IPersistTuneXmlUtility2, self), piTuneRequest, pString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDACreateTuneRequestEx_Value = @import("../zig.zig").Guid.initString("c0a4a1d4-2b3c-491a-ba22-499fbadd4d12");
pub const IID_IBDACreateTuneRequestEx = &IID_IBDACreateTuneRequestEx_Value;
pub const IBDACreateTuneRequestEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTuneRequestEx: fn(
            self: *const IBDACreateTuneRequestEx,
            TuneRequestIID: ?*const Guid,
            TuneRequest: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDACreateTuneRequestEx_CreateTuneRequestEx(self: *const T, TuneRequestIID: ?*const Guid, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDACreateTuneRequestEx.VTable, self.vtable).CreateTuneRequestEx(@ptrCast(*const IBDACreateTuneRequestEx, self), TuneRequestIID, TuneRequest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_XDSToRat_Value = @import("../zig.zig").Guid.initString("c5c5c5f0-3abc-11d6-b25b-00c04fa0c026");
pub const CLSID_XDSToRat = &CLSID_XDSToRat_Value;

const CLSID_EvalRat_Value = @import("../zig.zig").Guid.initString("c5c5c5f1-3abc-11d6-b25b-00c04fa0c026");
pub const CLSID_EvalRat = &CLSID_EvalRat_Value;

const CLSID_ETFilter_Value = @import("../zig.zig").Guid.initString("c4c4c4f1-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_ETFilter = &CLSID_ETFilter_Value;

const CLSID_DTFilter_Value = @import("../zig.zig").Guid.initString("c4c4c4f2-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_DTFilter = &CLSID_DTFilter_Value;

const CLSID_XDSCodec_Value = @import("../zig.zig").Guid.initString("c4c4c4f3-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_XDSCodec = &CLSID_XDSCodec_Value;

const CLSID_CXDSData_Value = @import("../zig.zig").Guid.initString("c4c4c4f4-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_CXDSData = &CLSID_CXDSData_Value;

pub const EnTvRat_System = enum(i32) {
    MPAA = 0,
    US_TV = 1,
    Canadian_English = 2,
    Canadian_French = 3,
    Reserved4 = 4,
    System5 = 5,
    System6 = 6,
    Reserved7 = 7,
    PBDA = 8,
    AgeBased = 9,
    TvRat_kSystems = 10,
    TvRat_SystemDontKnow = 255,
};
pub const MPAA = EnTvRat_System.MPAA;
pub const US_TV = EnTvRat_System.US_TV;
pub const Canadian_English = EnTvRat_System.Canadian_English;
pub const Canadian_French = EnTvRat_System.Canadian_French;
pub const Reserved4 = EnTvRat_System.Reserved4;
pub const System5 = EnTvRat_System.System5;
pub const System6 = EnTvRat_System.System6;
pub const Reserved7 = EnTvRat_System.Reserved7;
pub const PBDA = EnTvRat_System.PBDA;
pub const AgeBased = EnTvRat_System.AgeBased;
pub const TvRat_kSystems = EnTvRat_System.TvRat_kSystems;
pub const TvRat_SystemDontKnow = EnTvRat_System.TvRat_SystemDontKnow;

pub const EnTvRat_GenericLevel = enum(i32) {
    @"0" = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    @"5" = 5,
    @"6" = 6,
    @"7" = 7,
    @"8" = 8,
    @"9" = 9,
    @"10" = 10,
    @"11" = 11,
    @"12" = 12,
    @"13" = 13,
    @"14" = 14,
    @"15" = 15,
    @"16" = 16,
    @"17" = 17,
    @"18" = 18,
    @"19" = 19,
    @"20" = 20,
    @"21" = 21,
    kLevels = 22,
    Unblock = -1,
    LevelDontKnow = 255,
};
pub const TvRat_0 = EnTvRat_GenericLevel.@"0";
pub const TvRat_1 = EnTvRat_GenericLevel.@"1";
pub const TvRat_2 = EnTvRat_GenericLevel.@"2";
pub const TvRat_3 = EnTvRat_GenericLevel.@"3";
pub const TvRat_4 = EnTvRat_GenericLevel.@"4";
pub const TvRat_5 = EnTvRat_GenericLevel.@"5";
pub const TvRat_6 = EnTvRat_GenericLevel.@"6";
pub const TvRat_7 = EnTvRat_GenericLevel.@"7";
pub const TvRat_8 = EnTvRat_GenericLevel.@"8";
pub const TvRat_9 = EnTvRat_GenericLevel.@"9";
pub const TvRat_10 = EnTvRat_GenericLevel.@"10";
pub const TvRat_11 = EnTvRat_GenericLevel.@"11";
pub const TvRat_12 = EnTvRat_GenericLevel.@"12";
pub const TvRat_13 = EnTvRat_GenericLevel.@"13";
pub const TvRat_14 = EnTvRat_GenericLevel.@"14";
pub const TvRat_15 = EnTvRat_GenericLevel.@"15";
pub const TvRat_16 = EnTvRat_GenericLevel.@"16";
pub const TvRat_17 = EnTvRat_GenericLevel.@"17";
pub const TvRat_18 = EnTvRat_GenericLevel.@"18";
pub const TvRat_19 = EnTvRat_GenericLevel.@"19";
pub const TvRat_20 = EnTvRat_GenericLevel.@"20";
pub const TvRat_21 = EnTvRat_GenericLevel.@"21";
pub const TvRat_kLevels = EnTvRat_GenericLevel.kLevels;
pub const TvRat_Unblock = EnTvRat_GenericLevel.Unblock;
pub const TvRat_LevelDontKnow = EnTvRat_GenericLevel.LevelDontKnow;

pub const EnTvRat_MPAA = enum(i32) {
    NotApplicable = 0,
    G = 1,
    PG = 2,
    PG13 = 3,
    R = 4,
    NC17 = 5,
    X = 6,
    NotRated = 7,
};
pub const MPAA_NotApplicable = EnTvRat_MPAA.NotApplicable;
pub const MPAA_G = EnTvRat_MPAA.G;
pub const MPAA_PG = EnTvRat_MPAA.PG;
pub const MPAA_PG13 = EnTvRat_MPAA.PG13;
pub const MPAA_R = EnTvRat_MPAA.R;
pub const MPAA_NC17 = EnTvRat_MPAA.NC17;
pub const MPAA_X = EnTvRat_MPAA.X;
pub const MPAA_NotRated = EnTvRat_MPAA.NotRated;

pub const EnTvRat_US_TV = enum(i32) {
    None = 0,
    Y = 1,
    Y7 = 2,
    G = 3,
    PG = 4,
    @"14" = 5,
    MA = 6,
    None7 = 7,
};
pub const US_TV_None = EnTvRat_US_TV.None;
pub const US_TV_Y = EnTvRat_US_TV.Y;
pub const US_TV_Y7 = EnTvRat_US_TV.Y7;
pub const US_TV_G = EnTvRat_US_TV.G;
pub const US_TV_PG = EnTvRat_US_TV.PG;
pub const US_TV_14 = EnTvRat_US_TV.@"14";
pub const US_TV_MA = EnTvRat_US_TV.MA;
pub const US_TV_None7 = EnTvRat_US_TV.None7;

pub const EnTvRat_CAE_TV = enum(i32) {
    Exempt = 0,
    C = 1,
    C8 = 2,
    G = 3,
    PG = 4,
    @"14" = 5,
    @"18" = 6,
    Reserved = 7,
};
pub const CAE_TV_Exempt = EnTvRat_CAE_TV.Exempt;
pub const CAE_TV_C = EnTvRat_CAE_TV.C;
pub const CAE_TV_C8 = EnTvRat_CAE_TV.C8;
pub const CAE_TV_G = EnTvRat_CAE_TV.G;
pub const CAE_TV_PG = EnTvRat_CAE_TV.PG;
pub const CAE_TV_14 = EnTvRat_CAE_TV.@"14";
pub const CAE_TV_18 = EnTvRat_CAE_TV.@"18";
pub const CAE_TV_Reserved = EnTvRat_CAE_TV.Reserved;

pub const EnTvRat_CAF_TV = enum(i32) {
    Exempt = 0,
    G = 1,
    @"8" = 2,
    @"13" = 3,
    @"16" = 4,
    @"18" = 5,
    Reserved6 = 6,
    Reserved = 7,
};
pub const CAF_TV_Exempt = EnTvRat_CAF_TV.Exempt;
pub const CAF_TV_G = EnTvRat_CAF_TV.G;
pub const CAF_TV_8 = EnTvRat_CAF_TV.@"8";
pub const CAF_TV_13 = EnTvRat_CAF_TV.@"13";
pub const CAF_TV_16 = EnTvRat_CAF_TV.@"16";
pub const CAF_TV_18 = EnTvRat_CAF_TV.@"18";
pub const CAF_TV_Reserved6 = EnTvRat_CAF_TV.Reserved6;
pub const CAF_TV_Reserved = EnTvRat_CAF_TV.Reserved;

pub const BfEnTvRat_GenericAttributes = enum(i32) {
    AttrNone = 0,
    IsBlocked = 1,
    IsAttr_1 = 2,
    IsAttr_2 = 4,
    IsAttr_3 = 8,
    IsAttr_4 = 16,
    IsAttr_5 = 32,
    IsAttr_6 = 64,
    IsAttr_7 = 128,
    ValidAttrSubmask = 255,
};
pub const BfAttrNone = BfEnTvRat_GenericAttributes.AttrNone;
pub const BfIsBlocked = BfEnTvRat_GenericAttributes.IsBlocked;
pub const BfIsAttr_1 = BfEnTvRat_GenericAttributes.IsAttr_1;
pub const BfIsAttr_2 = BfEnTvRat_GenericAttributes.IsAttr_2;
pub const BfIsAttr_3 = BfEnTvRat_GenericAttributes.IsAttr_3;
pub const BfIsAttr_4 = BfEnTvRat_GenericAttributes.IsAttr_4;
pub const BfIsAttr_5 = BfEnTvRat_GenericAttributes.IsAttr_5;
pub const BfIsAttr_6 = BfEnTvRat_GenericAttributes.IsAttr_6;
pub const BfIsAttr_7 = BfEnTvRat_GenericAttributes.IsAttr_7;
pub const BfValidAttrSubmask = BfEnTvRat_GenericAttributes.ValidAttrSubmask;

pub const BfEnTvRat_Attributes_US_TV = enum(i32) {
    IsBlocked = 1,
    IsViolent = 2,
    IsSexualSituation = 4,
    IsAdultLanguage = 8,
    IsSexuallySuggestiveDialog = 16,
    ValidAttrSubmask = 31,
};
pub const US_TV_IsBlocked = BfEnTvRat_Attributes_US_TV.IsBlocked;
pub const US_TV_IsViolent = BfEnTvRat_Attributes_US_TV.IsViolent;
pub const US_TV_IsSexualSituation = BfEnTvRat_Attributes_US_TV.IsSexualSituation;
pub const US_TV_IsAdultLanguage = BfEnTvRat_Attributes_US_TV.IsAdultLanguage;
pub const US_TV_IsSexuallySuggestiveDialog = BfEnTvRat_Attributes_US_TV.IsSexuallySuggestiveDialog;
pub const US_TV_ValidAttrSubmask = BfEnTvRat_Attributes_US_TV.ValidAttrSubmask;

pub const BfEnTvRat_Attributes_MPAA = enum(i32) {
    IsBlocked = 1,
    // ValidAttrSubmask = 1, this enum value conflicts with IsBlocked
};
pub const MPAA_IsBlocked = BfEnTvRat_Attributes_MPAA.IsBlocked;
pub const MPAA_ValidAttrSubmask = BfEnTvRat_Attributes_MPAA.IsBlocked;

pub const BfEnTvRat_Attributes_CAE_TV = enum(i32) {
    IsBlocked = 1,
    // ValidAttrSubmask = 1, this enum value conflicts with IsBlocked
};
pub const CAE_IsBlocked = BfEnTvRat_Attributes_CAE_TV.IsBlocked;
pub const CAE_ValidAttrSubmask = BfEnTvRat_Attributes_CAE_TV.IsBlocked;

pub const BfEnTvRat_Attributes_CAF_TV = enum(i32) {
    IsBlocked = 1,
    // ValidAttrSubmask = 1, this enum value conflicts with IsBlocked
};
pub const CAF_IsBlocked = BfEnTvRat_Attributes_CAF_TV.IsBlocked;
pub const CAF_ValidAttrSubmask = BfEnTvRat_Attributes_CAF_TV.IsBlocked;

pub const FormatNotSupportedEvents = enum(i32) {
    CLEAR = 0,
    NOTSUPPORTED = 1,
};
pub const FORMATNOTSUPPORTED_CLEAR = FormatNotSupportedEvents.CLEAR;
pub const FORMATNOTSUPPORTED_NOTSUPPORTED = FormatNotSupportedEvents.NOTSUPPORTED;

pub const WMDRMProtectionInfo = packed struct {
    wszKID: [25]u16,
    qwCounter: u64,
    qwIndex: u64,
    bOffset: u8,
};

pub const BadSampleInfo = packed struct {
    hrReason: HRESULT,
};

pub const ProtType = enum(i32) {
    FREE = 1,
    ONCE = 2,
    NEVER = 3,
    NEVER_REALLY = 4,
    NO_MORE = 5,
    FREE_CIT = 6,
    BF = 7,
    CN_RECORDING_STOP = 8,
    FREE_SECURE = 9,
    INVALID = 50,
};
pub const PROT_COPY_FREE = ProtType.FREE;
pub const PROT_COPY_ONCE = ProtType.ONCE;
pub const PROT_COPY_NEVER = ProtType.NEVER;
pub const PROT_COPY_NEVER_REALLY = ProtType.NEVER_REALLY;
pub const PROT_COPY_NO_MORE = ProtType.NO_MORE;
pub const PROT_COPY_FREE_CIT = ProtType.FREE_CIT;
pub const PROT_COPY_BF = ProtType.BF;
pub const PROT_COPY_CN_RECORDING_STOP = ProtType.CN_RECORDING_STOP;
pub const PROT_COPY_FREE_SECURE = ProtType.FREE_SECURE;
pub const PROT_COPY_INVALID = ProtType.INVALID;

pub const EncDecEvents = enum(i32) {
    CPEVENT = 0,
    RECORDING_STATUS = 1,
};
pub const ENCDEC_CPEVENT = EncDecEvents.CPEVENT;
pub const ENCDEC_RECORDING_STATUS = EncDecEvents.RECORDING_STATUS;

pub const CPRecordingStatus = enum(i32) {
    OPPED = 0,
    ARTED = 1,
};
pub const RECORDING_STOPPED = CPRecordingStatus.OPPED;
pub const RECORDING_STARTED = CPRecordingStatus.ARTED;

pub const CPEventBitShift = enum(i32) {
    RATINGS = 0,
    COPP = 1,
    LICENSE = 2,
    ROLLBACK = 3,
    SAC = 4,
    DOWNRES = 5,
    STUBLIB = 6,
    UNTRUSTEDGRAPH = 7,
    PENDING_CERTIFICATE = 8,
    NO_PLAYREADY = 9,
};
pub const CPEVENT_BITSHIFT_RATINGS = CPEventBitShift.RATINGS;
pub const CPEVENT_BITSHIFT_COPP = CPEventBitShift.COPP;
pub const CPEVENT_BITSHIFT_LICENSE = CPEventBitShift.LICENSE;
pub const CPEVENT_BITSHIFT_ROLLBACK = CPEventBitShift.ROLLBACK;
pub const CPEVENT_BITSHIFT_SAC = CPEventBitShift.SAC;
pub const CPEVENT_BITSHIFT_DOWNRES = CPEventBitShift.DOWNRES;
pub const CPEVENT_BITSHIFT_STUBLIB = CPEventBitShift.STUBLIB;
pub const CPEVENT_BITSHIFT_UNTRUSTEDGRAPH = CPEventBitShift.UNTRUSTEDGRAPH;
pub const CPEVENT_BITSHIFT_PENDING_CERTIFICATE = CPEventBitShift.PENDING_CERTIFICATE;
pub const CPEVENT_BITSHIFT_NO_PLAYREADY = CPEventBitShift.NO_PLAYREADY;

pub const CPEvents = enum(i32) {
    NONE = 0,
    RATINGS = 1,
    COPP = 2,
    LICENSE = 3,
    ROLLBACK = 4,
    SAC = 5,
    DOWNRES = 6,
    STUBLIB = 7,
    UNTRUSTEDGRAPH = 8,
    PROTECTWINDOWED = 9,
};
pub const CPEVENT_NONE = CPEvents.NONE;
pub const CPEVENT_RATINGS = CPEvents.RATINGS;
pub const CPEVENT_COPP = CPEvents.COPP;
pub const CPEVENT_LICENSE = CPEvents.LICENSE;
pub const CPEVENT_ROLLBACK = CPEvents.ROLLBACK;
pub const CPEVENT_SAC = CPEvents.SAC;
pub const CPEVENT_DOWNRES = CPEvents.DOWNRES;
pub const CPEVENT_STUBLIB = CPEvents.STUBLIB;
pub const CPEVENT_UNTRUSTEDGRAPH = CPEvents.UNTRUSTEDGRAPH;
pub const CPEVENT_PROTECTWINDOWED = CPEvents.PROTECTWINDOWED;

pub const RevokedComponent = enum(i32) {
    COPP = 0,
    SAC = 1,
    APP_STUB = 2,
    SECURE_PIPELINE = 3,
    MAX_TYPES = 4,
};
pub const REVOKED_COPP = RevokedComponent.COPP;
pub const REVOKED_SAC = RevokedComponent.SAC;
pub const REVOKED_APP_STUB = RevokedComponent.APP_STUB;
pub const REVOKED_SECURE_PIPELINE = RevokedComponent.SECURE_PIPELINE;
pub const REVOKED_MAX_TYPES = RevokedComponent.MAX_TYPES;

pub const EnTag_Mode = enum(i32) {
    Remove = 0,
    Once = 1,
    Repeat = 2,
};
pub const EnTag_Remove = EnTag_Mode.Remove;
pub const EnTag_Once = EnTag_Mode.Once;
pub const EnTag_Repeat = EnTag_Mode.Repeat;

pub const COPPEventBlockReason = enum(i32) {
    Unknown = -1,
    BadDriver = 0,
    NoCardHDCPSupport = 1,
    NoMonitorHDCPSupport = 2,
    BadCertificate = 3,
    InvalidBusProtection = 4,
    AeroGlassOff = 5,
    RogueApp = 6,
    ForbiddenVideo = 7,
    Activate = 8,
    DigitalAudioUnprotected = 9,
};
pub const COPP_Unknown = COPPEventBlockReason.Unknown;
pub const COPP_BadDriver = COPPEventBlockReason.BadDriver;
pub const COPP_NoCardHDCPSupport = COPPEventBlockReason.NoCardHDCPSupport;
pub const COPP_NoMonitorHDCPSupport = COPPEventBlockReason.NoMonitorHDCPSupport;
pub const COPP_BadCertificate = COPPEventBlockReason.BadCertificate;
pub const COPP_InvalidBusProtection = COPPEventBlockReason.InvalidBusProtection;
pub const COPP_AeroGlassOff = COPPEventBlockReason.AeroGlassOff;
pub const COPP_RogueApp = COPPEventBlockReason.RogueApp;
pub const COPP_ForbiddenVideo = COPPEventBlockReason.ForbiddenVideo;
pub const COPP_Activate = COPPEventBlockReason.Activate;
pub const COPP_DigitalAudioUnprotected = COPPEventBlockReason.DigitalAudioUnprotected;

pub const LicenseEventBlockReason = enum(i32) {
    BadLicense = 0,
    NeedIndiv = 1,
    Expired = 2,
    NeedActivation = 3,
    ExtenderBlocked = 4,
};
pub const LIC_BadLicense = LicenseEventBlockReason.BadLicense;
pub const LIC_NeedIndiv = LicenseEventBlockReason.NeedIndiv;
pub const LIC_Expired = LicenseEventBlockReason.Expired;
pub const LIC_NeedActivation = LicenseEventBlockReason.NeedActivation;
pub const LIC_ExtenderBlocked = LicenseEventBlockReason.ExtenderBlocked;

pub const DownResEventParam = enum(i32) {
    Always = 0,
    InWindowOnly = 1,
    Undefined = 2,
};
pub const DOWNRES_Always = DownResEventParam.Always;
pub const DOWNRES_InWindowOnly = DownResEventParam.InWindowOnly;
pub const DOWNRES_Undefined = DownResEventParam.Undefined;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IETFilterConfig_Value = @import("../zig.zig").Guid.initString("c4c4c4d1-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IETFilterConfig = &IID_IETFilterConfig_Value;
pub const IETFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitLicense: fn(
            self: *const IETFilterConfig,
            LicenseId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecureChannelObject: fn(
            self: *const IETFilterConfig,
            ppUnkDRMSecureChannel: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilterConfig_InitLicense(self: *const T, LicenseId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IETFilterConfig.VTable, self.vtable).InitLicense(@ptrCast(*const IETFilterConfig, self), LicenseId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilterConfig_GetSecureChannelObject(self: *const T, ppUnkDRMSecureChannel: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IETFilterConfig.VTable, self.vtable).GetSecureChannelObject(@ptrCast(*const IETFilterConfig, self), ppUnkDRMSecureChannel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDTFilterConfig_Value = @import("../zig.zig").Guid.initString("c4c4c4d2-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilterConfig = &IID_IDTFilterConfig_Value;
pub const IDTFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecureChannelObject: fn(
            self: *const IDTFilterConfig,
            ppUnkDRMSecureChannel: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilterConfig_GetSecureChannelObject(self: *const T, ppUnkDRMSecureChannel: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilterConfig.VTable, self.vtable).GetSecureChannelObject(@ptrCast(*const IDTFilterConfig, self), ppUnkDRMSecureChannel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXDSCodecConfig_Value = @import("../zig.zig").Guid.initString("c4c4c4d3-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IXDSCodecConfig = &IID_IXDSCodecConfig_Value;
pub const IXDSCodecConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecureChannelObject: fn(
            self: *const IXDSCodecConfig,
            ppUnkDRMSecureChannel: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPauseBufferTime: fn(
            self: *const IXDSCodecConfig,
            dwPauseBufferTime: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodecConfig_GetSecureChannelObject(self: *const T, ppUnkDRMSecureChannel: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSCodecConfig.VTable, self.vtable).GetSecureChannelObject(@ptrCast(*const IXDSCodecConfig, self), ppUnkDRMSecureChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodecConfig_SetPauseBufferTime(self: *const T, dwPauseBufferTime: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSCodecConfig.VTable, self.vtable).SetPauseBufferTime(@ptrCast(*const IXDSCodecConfig, self), dwPauseBufferTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDTFilterLicenseRenewal_Value = @import("../zig.zig").Guid.initString("8a78b317-e405-4a43-994a-620d8f5ce25e");
pub const IID_IDTFilterLicenseRenewal = &IID_IDTFilterLicenseRenewal_Value;
pub const IDTFilterLicenseRenewal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLicenseRenewalData: fn(
            self: *const IDTFilterLicenseRenewal,
            ppwszFileName: ?*?PWSTR,
            ppwszExpiredKid: ?*?PWSTR,
            ppwszTunerId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilterLicenseRenewal_GetLicenseRenewalData(self: *const T, ppwszFileName: ?*?PWSTR, ppwszExpiredKid: ?*?PWSTR, ppwszTunerId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilterLicenseRenewal.VTable, self.vtable).GetLicenseRenewalData(@ptrCast(*const IDTFilterLicenseRenewal, self), ppwszFileName, ppwszExpiredKid, ppwszTunerId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPTFilterLicenseRenewal_Value = @import("../zig.zig").Guid.initString("26d836a5-0c15-44c7-ac59-b0da8728f240");
pub const IID_IPTFilterLicenseRenewal = &IID_IPTFilterLicenseRenewal_Value;
pub const IPTFilterLicenseRenewal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenewLicenses: fn(
            self: *const IPTFilterLicenseRenewal,
            wszFileName: ?PWSTR,
            wszExpiredKid: ?PWSTR,
            dwCallersId: u32,
            bHighPriority: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelLicenseRenewal: fn(
            self: *const IPTFilterLicenseRenewal,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPTFilterLicenseRenewal_RenewLicenses(self: *const T, wszFileName: ?PWSTR, wszExpiredKid: ?PWSTR, dwCallersId: u32, bHighPriority: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPTFilterLicenseRenewal.VTable, self.vtable).RenewLicenses(@ptrCast(*const IPTFilterLicenseRenewal, self), wszFileName, wszExpiredKid, dwCallersId, bHighPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPTFilterLicenseRenewal_CancelLicenseRenewal(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPTFilterLicenseRenewal.VTable, self.vtable).CancelLicenseRenewal(@ptrCast(*const IPTFilterLicenseRenewal, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMceBurnerControl_Value = @import("../zig.zig").Guid.initString("5a86b91a-e71e-46c1-88a9-9bb338710552");
pub const IID_IMceBurnerControl = &IID_IMceBurnerControl_Value;
pub const IMceBurnerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBurnerNoDecryption: fn(
            self: *const IMceBurnerControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMceBurnerControl_GetBurnerNoDecryption(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMceBurnerControl.VTable, self.vtable).GetBurnerNoDecryption(@ptrCast(*const IMceBurnerControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IETFilter_Value = @import("../zig.zig").Guid.initString("c4c4c4b1-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IETFilter = &IID_IETFilter_Value;
pub const IETFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EvalRatObjOK: fn(
            self: *const IETFilter,
            pHrCoCreateRetVal: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrRating: fn(
            self: *const IETFilter,
            pEnSystem: ?*EnTvRat_System,
            pEnRating: ?*EnTvRat_GenericLevel,
            plbfEnAttr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrLicenseExpDate: fn(
            self: *const IETFilter,
            protType: ?*ProtType,
            lpDateTime: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastErrorCode: fn(
            self: *const IETFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRecordingOn: fn(
            self: *const IETFilter,
            fRecState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_get_EvalRatObjOK(self: *const T, pHrCoCreateRetVal: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IETFilter.VTable, self.vtable).get_EvalRatObjOK(@ptrCast(*const IETFilter, self), pHrCoCreateRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_GetCurrRating(self: *const T, pEnSystem: ?*EnTvRat_System, pEnRating: ?*EnTvRat_GenericLevel, plbfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IETFilter.VTable, self.vtable).GetCurrRating(@ptrCast(*const IETFilter, self), pEnSystem, pEnRating, plbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_GetCurrLicenseExpDate(self: *const T, protType: ?*ProtType, lpDateTime: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IETFilter.VTable, self.vtable).GetCurrLicenseExpDate(@ptrCast(*const IETFilter, self), protType, lpDateTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_GetLastErrorCode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IETFilter.VTable, self.vtable).GetLastErrorCode(@ptrCast(*const IETFilter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_SetRecordingOn(self: *const T, fRecState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IETFilter.VTable, self.vtable).SetRecordingOn(@ptrCast(*const IETFilter, self), fRecState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IETFilterEvents_Value = @import("../zig.zig").Guid.initString("c4c4c4c1-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IETFilterEvents = &IID_IETFilterEvents_Value;
pub const IETFilterEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDTFilter_Value = @import("../zig.zig").Guid.initString("c4c4c4b2-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilter = &IID_IDTFilter_Value;
pub const IDTFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EvalRatObjOK: fn(
            self: *const IDTFilter,
            pHrCoCreateRetVal: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrRating: fn(
            self: *const IDTFilter,
            pEnSystem: ?*EnTvRat_System,
            pEnRating: ?*EnTvRat_GenericLevel,
            plbfEnAttr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockedRatingAttributes: fn(
            self: *const IDTFilter,
            enSystem: EnTvRat_System,
            enLevel: EnTvRat_GenericLevel,
            plbfEnAttr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockedRatingAttributes: fn(
            self: *const IDTFilter,
            enSystem: EnTvRat_System,
            enLevel: EnTvRat_GenericLevel,
            lbfAttrs: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockUnRated: fn(
            self: *const IDTFilter,
            pfBlockUnRatedShows: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnRated: fn(
            self: *const IDTFilter,
            fBlockUnRatedShows: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockUnRatedDelay: fn(
            self: *const IDTFilter,
            pmsecsDelayBeforeBlock: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnRatedDelay: fn(
            self: *const IDTFilter,
            msecsDelayBeforeBlock: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_get_EvalRatObjOK(self: *const T, pHrCoCreateRetVal: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter.VTable, self.vtable).get_EvalRatObjOK(@ptrCast(*const IDTFilter, self), pHrCoCreateRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_GetCurrRating(self: *const T, pEnSystem: ?*EnTvRat_System, pEnRating: ?*EnTvRat_GenericLevel, plbfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter.VTable, self.vtable).GetCurrRating(@ptrCast(*const IDTFilter, self), pEnSystem, pEnRating, plbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_get_BlockedRatingAttributes(self: *const T, enSystem: EnTvRat_System, enLevel: EnTvRat_GenericLevel, plbfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter.VTable, self.vtable).get_BlockedRatingAttributes(@ptrCast(*const IDTFilter, self), enSystem, enLevel, plbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_put_BlockedRatingAttributes(self: *const T, enSystem: EnTvRat_System, enLevel: EnTvRat_GenericLevel, lbfAttrs: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter.VTable, self.vtable).put_BlockedRatingAttributes(@ptrCast(*const IDTFilter, self), enSystem, enLevel, lbfAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_get_BlockUnRated(self: *const T, pfBlockUnRatedShows: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter.VTable, self.vtable).get_BlockUnRated(@ptrCast(*const IDTFilter, self), pfBlockUnRatedShows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_put_BlockUnRated(self: *const T, fBlockUnRatedShows: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter.VTable, self.vtable).put_BlockUnRated(@ptrCast(*const IDTFilter, self), fBlockUnRatedShows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_get_BlockUnRatedDelay(self: *const T, pmsecsDelayBeforeBlock: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter.VTable, self.vtable).get_BlockUnRatedDelay(@ptrCast(*const IDTFilter, self), pmsecsDelayBeforeBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_put_BlockUnRatedDelay(self: *const T, msecsDelayBeforeBlock: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter.VTable, self.vtable).put_BlockUnRatedDelay(@ptrCast(*const IDTFilter, self), msecsDelayBeforeBlock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDTFilter2_Value = @import("../zig.zig").Guid.initString("c4c4c4b4-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilter2 = &IID_IDTFilter2_Value;
pub const IDTFilter2 = extern struct {
    pub const VTable = extern struct {
        base: IDTFilter.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChallengeUrl: fn(
            self: *const IDTFilter2,
            pbstrChallengeUrl: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrLicenseExpDate: fn(
            self: *const IDTFilter2,
            protType: ?*ProtType,
            lpDateTime: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastErrorCode: fn(
            self: *const IDTFilter2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDTFilter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter2_get_ChallengeUrl(self: *const T, pbstrChallengeUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter2.VTable, self.vtable).get_ChallengeUrl(@ptrCast(*const IDTFilter2, self), pbstrChallengeUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter2_GetCurrLicenseExpDate(self: *const T, protType: ?*ProtType, lpDateTime: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter2.VTable, self.vtable).GetCurrLicenseExpDate(@ptrCast(*const IDTFilter2, self), protType, lpDateTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter2_GetLastErrorCode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter2.VTable, self.vtable).GetLastErrorCode(@ptrCast(*const IDTFilter2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDTFilter3_Value = @import("../zig.zig").Guid.initString("513998cc-e929-4cdf-9fbd-bad1e0314866");
pub const IID_IDTFilter3 = &IID_IDTFilter3_Value;
pub const IDTFilter3 = extern struct {
    pub const VTable = extern struct {
        base: IDTFilter2.VTable,
        GetProtectionType: fn(
            self: *const IDTFilter3,
            pProtectionType: ?*ProtType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LicenseHasExpirationDate: fn(
            self: *const IDTFilter3,
            pfLicenseHasExpirationDate: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRights: fn(
            self: *const IDTFilter3,
            bstrRights: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDTFilter2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter3_GetProtectionType(self: *const T, pProtectionType: ?*ProtType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter3.VTable, self.vtable).GetProtectionType(@ptrCast(*const IDTFilter3, self), pProtectionType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter3_LicenseHasExpirationDate(self: *const T, pfLicenseHasExpirationDate: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter3.VTable, self.vtable).LicenseHasExpirationDate(@ptrCast(*const IDTFilter3, self), pfLicenseHasExpirationDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter3_SetRights(self: *const T, bstrRights: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDTFilter3.VTable, self.vtable).SetRights(@ptrCast(*const IDTFilter3, self), bstrRights);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDTFilterEvents_Value = @import("../zig.zig").Guid.initString("c4c4c4c2-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilterEvents = &IID_IDTFilterEvents_Value;
pub const IDTFilterEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IXDSCodec_Value = @import("../zig.zig").Guid.initString("c4c4c4b3-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IXDSCodec = &IID_IXDSCodec_Value;
pub const IXDSCodec = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XDSToRatObjOK: fn(
            self: *const IXDSCodec,
            pHrCoCreateRetVal: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CCSubstreamService: fn(
            self: *const IXDSCodec,
            SubstreamMask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCSubstreamService: fn(
            self: *const IXDSCodec,
            pSubstreamMask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContentAdvisoryRating: fn(
            self: *const IXDSCodec,
            pRat: ?*i32,
            pPktSeqID: ?*i32,
            pCallSeqID: ?*i32,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetXDSPacket: fn(
            self: *const IXDSCodec,
            pXDSClassPkt: ?*i32,
            pXDSTypePkt: ?*i32,
            pBstrXDSPkt: ?*?BSTR,
            pPktSeqID: ?*i32,
            pCallSeqID: ?*i32,
            pTimeStart: ?*i64,
            pTimeEnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrLicenseExpDate: fn(
            self: *const IXDSCodec,
            protType: ?*ProtType,
            lpDateTime: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastErrorCode: fn(
            self: *const IXDSCodec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_get_XDSToRatObjOK(self: *const T, pHrCoCreateRetVal: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSCodec.VTable, self.vtable).get_XDSToRatObjOK(@ptrCast(*const IXDSCodec, self), pHrCoCreateRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_put_CCSubstreamService(self: *const T, SubstreamMask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSCodec.VTable, self.vtable).put_CCSubstreamService(@ptrCast(*const IXDSCodec, self), SubstreamMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_get_CCSubstreamService(self: *const T, pSubstreamMask: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSCodec.VTable, self.vtable).get_CCSubstreamService(@ptrCast(*const IXDSCodec, self), pSubstreamMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_GetContentAdvisoryRating(self: *const T, pRat: ?*i32, pPktSeqID: ?*i32, pCallSeqID: ?*i32, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSCodec.VTable, self.vtable).GetContentAdvisoryRating(@ptrCast(*const IXDSCodec, self), pRat, pPktSeqID, pCallSeqID, pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_GetXDSPacket(self: *const T, pXDSClassPkt: ?*i32, pXDSTypePkt: ?*i32, pBstrXDSPkt: ?*?BSTR, pPktSeqID: ?*i32, pCallSeqID: ?*i32, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSCodec.VTable, self.vtable).GetXDSPacket(@ptrCast(*const IXDSCodec, self), pXDSClassPkt, pXDSTypePkt, pBstrXDSPkt, pPktSeqID, pCallSeqID, pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_GetCurrLicenseExpDate(self: *const T, protType: ?*ProtType, lpDateTime: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSCodec.VTable, self.vtable).GetCurrLicenseExpDate(@ptrCast(*const IXDSCodec, self), protType, lpDateTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_GetLastErrorCode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSCodec.VTable, self.vtable).GetLastErrorCode(@ptrCast(*const IXDSCodec, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXDSCodecEvents_Value = @import("../zig.zig").Guid.initString("c4c4c4c3-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IXDSCodecEvents = &IID_IXDSCodecEvents_Value;
pub const IXDSCodecEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IXDSToRat_Value = @import("../zig.zig").Guid.initString("c5c5c5b0-3abc-11d6-b25b-00c04fa0c026");
pub const IID_IXDSToRat = &IID_IXDSToRat_Value;
pub const IXDSToRat = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Init: fn(
            self: *const IXDSToRat,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseXDSBytePair: fn(
            self: *const IXDSToRat,
            byte1: u8,
            byte2: u8,
            pEnSystem: ?*EnTvRat_System,
            pEnLevel: ?*EnTvRat_GenericLevel,
            plBfEnAttributes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSToRat_Init(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSToRat.VTable, self.vtable).Init(@ptrCast(*const IXDSToRat, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSToRat_ParseXDSBytePair(self: *const T, byte1: u8, byte2: u8, pEnSystem: ?*EnTvRat_System, pEnLevel: ?*EnTvRat_GenericLevel, plBfEnAttributes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXDSToRat.VTable, self.vtable).ParseXDSBytePair(@ptrCast(*const IXDSToRat, self), byte1, byte2, pEnSystem, pEnLevel, plBfEnAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEvalRat_Value = @import("../zig.zig").Guid.initString("c5c5c5b1-3abc-11d6-b25b-00c04fa0c026");
pub const IID_IEvalRat = &IID_IEvalRat_Value;
pub const IEvalRat = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockedRatingAttributes: fn(
            self: *const IEvalRat,
            enSystem: EnTvRat_System,
            enLevel: EnTvRat_GenericLevel,
            plbfAttrs: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockedRatingAttributes: fn(
            self: *const IEvalRat,
            enSystem: EnTvRat_System,
            enLevel: EnTvRat_GenericLevel,
            lbfAttrs: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockUnRated: fn(
            self: *const IEvalRat,
            pfBlockUnRatedShows: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnRated: fn(
            self: *const IEvalRat,
            fBlockUnRatedShows: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MostRestrictiveRating: fn(
            self: *const IEvalRat,
            enSystem1: EnTvRat_System,
            enEnLevel1: EnTvRat_GenericLevel,
            lbfEnAttr1: i32,
            enSystem2: EnTvRat_System,
            enEnLevel2: EnTvRat_GenericLevel,
            lbfEnAttr2: i32,
            penSystem: ?*EnTvRat_System,
            penEnLevel: ?*EnTvRat_GenericLevel,
            plbfEnAttr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestRating: fn(
            self: *const IEvalRat,
            enShowSystem: EnTvRat_System,
            enShowLevel: EnTvRat_GenericLevel,
            lbfEnShowAttributes: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_get_BlockedRatingAttributes(self: *const T, enSystem: EnTvRat_System, enLevel: EnTvRat_GenericLevel, plbfAttrs: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEvalRat.VTable, self.vtable).get_BlockedRatingAttributes(@ptrCast(*const IEvalRat, self), enSystem, enLevel, plbfAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_put_BlockedRatingAttributes(self: *const T, enSystem: EnTvRat_System, enLevel: EnTvRat_GenericLevel, lbfAttrs: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEvalRat.VTable, self.vtable).put_BlockedRatingAttributes(@ptrCast(*const IEvalRat, self), enSystem, enLevel, lbfAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_get_BlockUnRated(self: *const T, pfBlockUnRatedShows: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEvalRat.VTable, self.vtable).get_BlockUnRated(@ptrCast(*const IEvalRat, self), pfBlockUnRatedShows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_put_BlockUnRated(self: *const T, fBlockUnRatedShows: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEvalRat.VTable, self.vtable).put_BlockUnRated(@ptrCast(*const IEvalRat, self), fBlockUnRatedShows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_MostRestrictiveRating(self: *const T, enSystem1: EnTvRat_System, enEnLevel1: EnTvRat_GenericLevel, lbfEnAttr1: i32, enSystem2: EnTvRat_System, enEnLevel2: EnTvRat_GenericLevel, lbfEnAttr2: i32, penSystem: ?*EnTvRat_System, penEnLevel: ?*EnTvRat_GenericLevel, plbfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEvalRat.VTable, self.vtable).MostRestrictiveRating(@ptrCast(*const IEvalRat, self), enSystem1, enEnLevel1, lbfEnAttr1, enSystem2, enEnLevel2, lbfEnAttr2, penSystem, penEnLevel, plbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_TestRating(self: *const T, enShowSystem: EnTvRat_System, enShowLevel: EnTvRat_GenericLevel, lbfEnShowAttributes: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEvalRat.VTable, self.vtable).TestRating(@ptrCast(*const IEvalRat, self), enShowSystem, enShowLevel, lbfEnShowAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SegDispidList = enum(i32) {
    dispidName = 0,
    dispidStatus = 1,
    dispidDevImageSourceWidth = 2,
    dispidDevImageSourceHeight = 3,
    dispidDevCountryCode = 4,
    dispidDevOverScan = 5,
    dispidSegment = 6,
    dispidDevVolume = 7,
    dispidDevBalance = 8,
    dispidDevPower = 9,
    dispidTuneChan = 10,
    dispidDevVideoSubchannel = 11,
    dispidDevAudioSubchannel = 12,
    dispidChannelAvailable = 13,
    dispidDevVideoFrequency = 14,
    dispidDevAudioFrequency = 15,
    dispidCount = 16,
    dispidDevFileName = 17,
    dispidVisible = 18,
    dispidOwner = 19,
    dispidMessageDrain = 20,
    dispidViewable = 21,
    dispidDevView = 22,
    dispidKSCat = 23,
    dispidCLSID = 24,
    dispid_KSCat = 25,
    dispid_CLSID = 26,
    dispidTune = 27,
    dispidTS = 28,
    dispidDevSAP = 29,
    dispidClip = 30,
    dispidRequestedClipRect = 31,
    dispidClippedSourceRect = 32,
    dispidAvailableSourceRect = 33,
    dispidMediaPosition = 34,
    dispidDevRun = 35,
    dispidDevPause = 36,
    dispidDevStop = 37,
    dispidCCEnable = 38,
    dispidDevStep = 39,
    dispidDevCanStep = 40,
    dispidSourceSize = 41,
    dispid_playtitle = 42,
    dispid_playchapterintitle = 43,
    dispid_playchapter = 44,
    dispid_playchaptersautostop = 45,
    dispid_playattime = 46,
    dispid_playattimeintitle = 47,
    dispid_playperiodintitleautostop = 48,
    dispid_replaychapter = 49,
    dispid_playprevchapter = 50,
    dispid_playnextchapter = 51,
    dispid_playforwards = 52,
    dispid_playbackwards = 53,
    dispid_stilloff = 54,
    dispid_audiolanguage = 55,
    dispid_showmenu = 56,
    dispid_resume = 57,
    dispid_returnfromsubmenu = 58,
    dispid_buttonsavailable = 59,
    dispid_currentbutton = 60,
    dispid_SelectAndActivateButton = 61,
    dispid_ActivateButton = 62,
    dispid_SelectRightButton = 63,
    dispid_SelectLeftButton = 64,
    dispid_SelectLowerButton = 65,
    dispid_SelectUpperButton = 66,
    dispid_ActivateAtPosition = 67,
    dispid_SelectAtPosition = 68,
    dispid_ButtonAtPosition = 69,
    dispid_NumberOfChapters = 70,
    dispid_TotalTitleTime = 71,
    dispid_TitlesAvailable = 72,
    dispid_VolumesAvailable = 73,
    dispid_CurrentVolume = 74,
    dispid_CurrentDiscSide = 75,
    dispid_CurrentDomain = 76,
    dispid_CurrentChapter = 77,
    dispid_CurrentTitle = 78,
    dispid_CurrentTime = 79,
    dispid_FramesPerSecond = 80,
    dispid_DVDTimeCode2bstr = 81,
    dispid_DVDDirectory = 82,
    dispid_IsSubpictureStreamEnabled = 83,
    dispid_IsAudioStreamEnabled = 84,
    dispid_CurrentSubpictureStream = 85,
    dispid_SubpictureLanguage = 86,
    dispid_CurrentAudioStream = 87,
    dispid_AudioStreamsAvailable = 88,
    dispid_AnglesAvailable = 89,
    dispid_CurrentAngle = 90,
    dispid_CCActive = 91,
    dispid_CurrentCCService = 92,
    dispid_SubpictureStreamsAvailable = 93,
    dispid_SubpictureOn = 94,
    dispid_DVDUniqueID = 95,
    dispid_EnableResetOnStop = 96,
    dispid_AcceptParentalLevelChange = 97,
    dispid_NotifyParentalLevelChange = 98,
    dispid_SelectParentalCountry = 99,
    dispid_SelectParentalLevel = 100,
    dispid_TitleParentalLevels = 101,
    dispid_PlayerParentalCountry = 102,
    dispid_PlayerParentalLevel = 103,
    dispid_Eject = 104,
    dispid_UOPValid = 105,
    dispid_SPRM = 106,
    dispid_GPRM = 107,
    dispid_DVDTextStringType = 108,
    dispid_DVDTextString = 109,
    dispid_DVDTextNumberOfStrings = 110,
    dispid_DVDTextNumberOfLanguages = 111,
    dispid_DVDTextLanguageLCID = 112,
    dispid_RegionChange = 113,
    dispid_DVDAdm = 114,
    dispid_DeleteBookmark = 115,
    dispid_RestoreBookmark = 116,
    dispid_SaveBookmark = 117,
    dispid_SelectDefaultAudioLanguage = 118,
    dispid_SelectDefaultSubpictureLanguage = 119,
    dispid_PreferredSubpictureStream = 120,
    dispid_DefaultMenuLanguage = 121,
    dispid_DefaultSubpictureLanguage = 122,
    dispid_DefaultAudioLanguage = 123,
    dispid_DefaultSubpictureLanguageExt = 124,
    dispid_DefaultAudioLanguageExt = 125,
    dispid_LanguageFromLCID = 126,
    dispid_KaraokeAudioPresentationMode = 127,
    dispid_KaraokeChannelContent = 128,
    dispid_KaraokeChannelAssignment = 129,
    dispid_RestorePreferredSettings = 130,
    dispid_ButtonRect = 131,
    dispid_DVDScreenInMouseCoordinates = 132,
    dispid_CustomCompositorClass = 133,
    dispidCustomCompositorClass = 134,
    dispid_CustomCompositor = 135,
    dispidMixerBitmap = 136,
    dispid_MixerBitmap = 137,
    dispidMixerBitmapOpacity = 138,
    dispidMixerBitmapRect = 139,
    dispidSetupMixerBitmap = 140,
    dispidUsingOverlay = 141,
    dispidDisplayChange = 142,
    dispidRePaint = 143,
    dispid_IsEqualDevice = 144,
    dispidrate = 145,
    dispidposition = 146,
    dispidpositionmode = 147,
    dispidlength = 148,
    dispidChangePassword = 149,
    dispidSaveParentalLevel = 150,
    dispidSaveParentalCountry = 151,
    dispidConfirmPassword = 152,
    dispidGetParentalLevel = 153,
    dispidGetParentalCountry = 154,
    dispidDefaultAudioLCID = 155,
    dispidDefaultSubpictureLCID = 156,
    dispidDefaultMenuLCID = 157,
    dispidBookmarkOnStop = 158,
    dispidMaxVidRect = 159,
    dispidMinVidRect = 160,
    dispidCapture = 161,
    dispid_DecimateInput = 162,
    dispidAlloctor = 163,
    dispid_Allocator = 164,
    dispidAllocPresentID = 165,
    dispidSetAllocator = 166,
    dispid_SetAllocator = 167,
    dispidStreamBufferSinkName = 168,
    dispidStreamBufferSourceName = 169,
    dispidStreamBufferContentRecording = 170,
    dispidStreamBufferReferenceRecording = 171,
    dispidstarttime = 172,
    dispidstoptime = 173,
    dispidrecordingstopped = 174,
    dispidrecordingstarted = 175,
    dispidNameSetLock = 176,
    dispidrecordingtype = 177,
    dispidstart = 178,
    dispidRecordingAttribute = 179,
    dispid_RecordingAttribute = 180,
    dispidSBEConfigure = 181,
    dispid_CurrentRatings = 182,
    dispid_MaxRatingsLevel = 183,
    dispid_audioencoderint = 184,
    dispid_videoencoderint = 185,
    dispidService = 186,
    dispid_BlockUnrated = 187,
    dispid_UnratedDelay = 188,
    dispid_SuppressEffects = 189,
    dispidsbesource = 190,
    dispidSetSinkFilter = 191,
    dispid_SinkStreams = 192,
    dispidTVFormats = 193,
    dispidModes = 194,
    dispidAuxInputs = 195,
    dispidTeleTextFilter = 196,
    dispid_channelchangeint = 197,
    dispidUnlockProfile = 198,
    dispid_AddFilter = 199,
    dispidSetMinSeek = 200,
    dispidRateEx = 201,
    dispidaudiocounter = 202,
    dispidvideocounter = 203,
    dispidcccounter = 204,
    dispidwstcounter = 205,
    dispid_audiocounter = 206,
    dispid_videocounter = 207,
    dispid_cccounter = 208,
    dispid_wstcounter = 209,
    dispidaudioanalysis = 210,
    dispidvideoanalysis = 211,
    dispiddataanalysis = 212,
    dispidaudio_analysis = 213,
    dispidvideo_analysis = 214,
    dispiddata_analysis = 215,
    dispid_resetFilterList = 216,
    dispidDevicePath = 217,
    dispid_SourceFilter = 218,
    dispid__SourceFilter = 219,
    dispidUserEvent = 220,
    dispid_Bookmark = 221,
    LastReservedDeviceDispid = 16383,
};
pub const dispidName = SegDispidList.dispidName;
pub const dispidStatus = SegDispidList.dispidStatus;
pub const dispidDevImageSourceWidth = SegDispidList.dispidDevImageSourceWidth;
pub const dispidDevImageSourceHeight = SegDispidList.dispidDevImageSourceHeight;
pub const dispidDevCountryCode = SegDispidList.dispidDevCountryCode;
pub const dispidDevOverScan = SegDispidList.dispidDevOverScan;
pub const dispidSegment = SegDispidList.dispidSegment;
pub const dispidDevVolume = SegDispidList.dispidDevVolume;
pub const dispidDevBalance = SegDispidList.dispidDevBalance;
pub const dispidDevPower = SegDispidList.dispidDevPower;
pub const dispidTuneChan = SegDispidList.dispidTuneChan;
pub const dispidDevVideoSubchannel = SegDispidList.dispidDevVideoSubchannel;
pub const dispidDevAudioSubchannel = SegDispidList.dispidDevAudioSubchannel;
pub const dispidChannelAvailable = SegDispidList.dispidChannelAvailable;
pub const dispidDevVideoFrequency = SegDispidList.dispidDevVideoFrequency;
pub const dispidDevAudioFrequency = SegDispidList.dispidDevAudioFrequency;
pub const dispidCount = SegDispidList.dispidCount;
pub const dispidDevFileName = SegDispidList.dispidDevFileName;
pub const dispidVisible = SegDispidList.dispidVisible;
pub const dispidOwner = SegDispidList.dispidOwner;
pub const dispidMessageDrain = SegDispidList.dispidMessageDrain;
pub const dispidViewable = SegDispidList.dispidViewable;
pub const dispidDevView = SegDispidList.dispidDevView;
pub const dispidKSCat = SegDispidList.dispidKSCat;
pub const dispidCLSID = SegDispidList.dispidCLSID;
pub const dispid_KSCat = SegDispidList.dispid_KSCat;
pub const dispid_CLSID = SegDispidList.dispid_CLSID;
pub const dispidTune = SegDispidList.dispidTune;
pub const dispidTS = SegDispidList.dispidTS;
pub const dispidDevSAP = SegDispidList.dispidDevSAP;
pub const dispidClip = SegDispidList.dispidClip;
pub const dispidRequestedClipRect = SegDispidList.dispidRequestedClipRect;
pub const dispidClippedSourceRect = SegDispidList.dispidClippedSourceRect;
pub const dispidAvailableSourceRect = SegDispidList.dispidAvailableSourceRect;
pub const dispidMediaPosition = SegDispidList.dispidMediaPosition;
pub const dispidDevRun = SegDispidList.dispidDevRun;
pub const dispidDevPause = SegDispidList.dispidDevPause;
pub const dispidDevStop = SegDispidList.dispidDevStop;
pub const dispidCCEnable = SegDispidList.dispidCCEnable;
pub const dispidDevStep = SegDispidList.dispidDevStep;
pub const dispidDevCanStep = SegDispidList.dispidDevCanStep;
pub const dispidSourceSize = SegDispidList.dispidSourceSize;
pub const dispid_playtitle = SegDispidList.dispid_playtitle;
pub const dispid_playchapterintitle = SegDispidList.dispid_playchapterintitle;
pub const dispid_playchapter = SegDispidList.dispid_playchapter;
pub const dispid_playchaptersautostop = SegDispidList.dispid_playchaptersautostop;
pub const dispid_playattime = SegDispidList.dispid_playattime;
pub const dispid_playattimeintitle = SegDispidList.dispid_playattimeintitle;
pub const dispid_playperiodintitleautostop = SegDispidList.dispid_playperiodintitleautostop;
pub const dispid_replaychapter = SegDispidList.dispid_replaychapter;
pub const dispid_playprevchapter = SegDispidList.dispid_playprevchapter;
pub const dispid_playnextchapter = SegDispidList.dispid_playnextchapter;
pub const dispid_playforwards = SegDispidList.dispid_playforwards;
pub const dispid_playbackwards = SegDispidList.dispid_playbackwards;
pub const dispid_stilloff = SegDispidList.dispid_stilloff;
pub const dispid_audiolanguage = SegDispidList.dispid_audiolanguage;
pub const dispid_showmenu = SegDispidList.dispid_showmenu;
pub const dispid_resume = SegDispidList.dispid_resume;
pub const dispid_returnfromsubmenu = SegDispidList.dispid_returnfromsubmenu;
pub const dispid_buttonsavailable = SegDispidList.dispid_buttonsavailable;
pub const dispid_currentbutton = SegDispidList.dispid_currentbutton;
pub const dispid_SelectAndActivateButton = SegDispidList.dispid_SelectAndActivateButton;
pub const dispid_ActivateButton = SegDispidList.dispid_ActivateButton;
pub const dispid_SelectRightButton = SegDispidList.dispid_SelectRightButton;
pub const dispid_SelectLeftButton = SegDispidList.dispid_SelectLeftButton;
pub const dispid_SelectLowerButton = SegDispidList.dispid_SelectLowerButton;
pub const dispid_SelectUpperButton = SegDispidList.dispid_SelectUpperButton;
pub const dispid_ActivateAtPosition = SegDispidList.dispid_ActivateAtPosition;
pub const dispid_SelectAtPosition = SegDispidList.dispid_SelectAtPosition;
pub const dispid_ButtonAtPosition = SegDispidList.dispid_ButtonAtPosition;
pub const dispid_NumberOfChapters = SegDispidList.dispid_NumberOfChapters;
pub const dispid_TotalTitleTime = SegDispidList.dispid_TotalTitleTime;
pub const dispid_TitlesAvailable = SegDispidList.dispid_TitlesAvailable;
pub const dispid_VolumesAvailable = SegDispidList.dispid_VolumesAvailable;
pub const dispid_CurrentVolume = SegDispidList.dispid_CurrentVolume;
pub const dispid_CurrentDiscSide = SegDispidList.dispid_CurrentDiscSide;
pub const dispid_CurrentDomain = SegDispidList.dispid_CurrentDomain;
pub const dispid_CurrentChapter = SegDispidList.dispid_CurrentChapter;
pub const dispid_CurrentTitle = SegDispidList.dispid_CurrentTitle;
pub const dispid_CurrentTime = SegDispidList.dispid_CurrentTime;
pub const dispid_FramesPerSecond = SegDispidList.dispid_FramesPerSecond;
pub const dispid_DVDTimeCode2bstr = SegDispidList.dispid_DVDTimeCode2bstr;
pub const dispid_DVDDirectory = SegDispidList.dispid_DVDDirectory;
pub const dispid_IsSubpictureStreamEnabled = SegDispidList.dispid_IsSubpictureStreamEnabled;
pub const dispid_IsAudioStreamEnabled = SegDispidList.dispid_IsAudioStreamEnabled;
pub const dispid_CurrentSubpictureStream = SegDispidList.dispid_CurrentSubpictureStream;
pub const dispid_SubpictureLanguage = SegDispidList.dispid_SubpictureLanguage;
pub const dispid_CurrentAudioStream = SegDispidList.dispid_CurrentAudioStream;
pub const dispid_AudioStreamsAvailable = SegDispidList.dispid_AudioStreamsAvailable;
pub const dispid_AnglesAvailable = SegDispidList.dispid_AnglesAvailable;
pub const dispid_CurrentAngle = SegDispidList.dispid_CurrentAngle;
pub const dispid_CCActive = SegDispidList.dispid_CCActive;
pub const dispid_CurrentCCService = SegDispidList.dispid_CurrentCCService;
pub const dispid_SubpictureStreamsAvailable = SegDispidList.dispid_SubpictureStreamsAvailable;
pub const dispid_SubpictureOn = SegDispidList.dispid_SubpictureOn;
pub const dispid_DVDUniqueID = SegDispidList.dispid_DVDUniqueID;
pub const dispid_EnableResetOnStop = SegDispidList.dispid_EnableResetOnStop;
pub const dispid_AcceptParentalLevelChange = SegDispidList.dispid_AcceptParentalLevelChange;
pub const dispid_NotifyParentalLevelChange = SegDispidList.dispid_NotifyParentalLevelChange;
pub const dispid_SelectParentalCountry = SegDispidList.dispid_SelectParentalCountry;
pub const dispid_SelectParentalLevel = SegDispidList.dispid_SelectParentalLevel;
pub const dispid_TitleParentalLevels = SegDispidList.dispid_TitleParentalLevels;
pub const dispid_PlayerParentalCountry = SegDispidList.dispid_PlayerParentalCountry;
pub const dispid_PlayerParentalLevel = SegDispidList.dispid_PlayerParentalLevel;
pub const dispid_Eject = SegDispidList.dispid_Eject;
pub const dispid_UOPValid = SegDispidList.dispid_UOPValid;
pub const dispid_SPRM = SegDispidList.dispid_SPRM;
pub const dispid_GPRM = SegDispidList.dispid_GPRM;
pub const dispid_DVDTextStringType = SegDispidList.dispid_DVDTextStringType;
pub const dispid_DVDTextString = SegDispidList.dispid_DVDTextString;
pub const dispid_DVDTextNumberOfStrings = SegDispidList.dispid_DVDTextNumberOfStrings;
pub const dispid_DVDTextNumberOfLanguages = SegDispidList.dispid_DVDTextNumberOfLanguages;
pub const dispid_DVDTextLanguageLCID = SegDispidList.dispid_DVDTextLanguageLCID;
pub const dispid_RegionChange = SegDispidList.dispid_RegionChange;
pub const dispid_DVDAdm = SegDispidList.dispid_DVDAdm;
pub const dispid_DeleteBookmark = SegDispidList.dispid_DeleteBookmark;
pub const dispid_RestoreBookmark = SegDispidList.dispid_RestoreBookmark;
pub const dispid_SaveBookmark = SegDispidList.dispid_SaveBookmark;
pub const dispid_SelectDefaultAudioLanguage = SegDispidList.dispid_SelectDefaultAudioLanguage;
pub const dispid_SelectDefaultSubpictureLanguage = SegDispidList.dispid_SelectDefaultSubpictureLanguage;
pub const dispid_PreferredSubpictureStream = SegDispidList.dispid_PreferredSubpictureStream;
pub const dispid_DefaultMenuLanguage = SegDispidList.dispid_DefaultMenuLanguage;
pub const dispid_DefaultSubpictureLanguage = SegDispidList.dispid_DefaultSubpictureLanguage;
pub const dispid_DefaultAudioLanguage = SegDispidList.dispid_DefaultAudioLanguage;
pub const dispid_DefaultSubpictureLanguageExt = SegDispidList.dispid_DefaultSubpictureLanguageExt;
pub const dispid_DefaultAudioLanguageExt = SegDispidList.dispid_DefaultAudioLanguageExt;
pub const dispid_LanguageFromLCID = SegDispidList.dispid_LanguageFromLCID;
pub const dispid_KaraokeAudioPresentationMode = SegDispidList.dispid_KaraokeAudioPresentationMode;
pub const dispid_KaraokeChannelContent = SegDispidList.dispid_KaraokeChannelContent;
pub const dispid_KaraokeChannelAssignment = SegDispidList.dispid_KaraokeChannelAssignment;
pub const dispid_RestorePreferredSettings = SegDispidList.dispid_RestorePreferredSettings;
pub const dispid_ButtonRect = SegDispidList.dispid_ButtonRect;
pub const dispid_DVDScreenInMouseCoordinates = SegDispidList.dispid_DVDScreenInMouseCoordinates;
pub const dispid_CustomCompositorClass = SegDispidList.dispid_CustomCompositorClass;
pub const dispidCustomCompositorClass = SegDispidList.dispidCustomCompositorClass;
pub const dispid_CustomCompositor = SegDispidList.dispid_CustomCompositor;
pub const dispidMixerBitmap = SegDispidList.dispidMixerBitmap;
pub const dispid_MixerBitmap = SegDispidList.dispid_MixerBitmap;
pub const dispidMixerBitmapOpacity = SegDispidList.dispidMixerBitmapOpacity;
pub const dispidMixerBitmapRect = SegDispidList.dispidMixerBitmapRect;
pub const dispidSetupMixerBitmap = SegDispidList.dispidSetupMixerBitmap;
pub const dispidUsingOverlay = SegDispidList.dispidUsingOverlay;
pub const dispidDisplayChange = SegDispidList.dispidDisplayChange;
pub const dispidRePaint = SegDispidList.dispidRePaint;
pub const dispid_IsEqualDevice = SegDispidList.dispid_IsEqualDevice;
pub const dispidrate = SegDispidList.dispidrate;
pub const dispidposition = SegDispidList.dispidposition;
pub const dispidpositionmode = SegDispidList.dispidpositionmode;
pub const dispidlength = SegDispidList.dispidlength;
pub const dispidChangePassword = SegDispidList.dispidChangePassword;
pub const dispidSaveParentalLevel = SegDispidList.dispidSaveParentalLevel;
pub const dispidSaveParentalCountry = SegDispidList.dispidSaveParentalCountry;
pub const dispidConfirmPassword = SegDispidList.dispidConfirmPassword;
pub const dispidGetParentalLevel = SegDispidList.dispidGetParentalLevel;
pub const dispidGetParentalCountry = SegDispidList.dispidGetParentalCountry;
pub const dispidDefaultAudioLCID = SegDispidList.dispidDefaultAudioLCID;
pub const dispidDefaultSubpictureLCID = SegDispidList.dispidDefaultSubpictureLCID;
pub const dispidDefaultMenuLCID = SegDispidList.dispidDefaultMenuLCID;
pub const dispidBookmarkOnStop = SegDispidList.dispidBookmarkOnStop;
pub const dispidMaxVidRect = SegDispidList.dispidMaxVidRect;
pub const dispidMinVidRect = SegDispidList.dispidMinVidRect;
pub const dispidCapture = SegDispidList.dispidCapture;
pub const dispid_DecimateInput = SegDispidList.dispid_DecimateInput;
pub const dispidAlloctor = SegDispidList.dispidAlloctor;
pub const dispid_Allocator = SegDispidList.dispid_Allocator;
pub const dispidAllocPresentID = SegDispidList.dispidAllocPresentID;
pub const dispidSetAllocator = SegDispidList.dispidSetAllocator;
pub const dispid_SetAllocator = SegDispidList.dispid_SetAllocator;
pub const dispidStreamBufferSinkName = SegDispidList.dispidStreamBufferSinkName;
pub const dispidStreamBufferSourceName = SegDispidList.dispidStreamBufferSourceName;
pub const dispidStreamBufferContentRecording = SegDispidList.dispidStreamBufferContentRecording;
pub const dispidStreamBufferReferenceRecording = SegDispidList.dispidStreamBufferReferenceRecording;
pub const dispidstarttime = SegDispidList.dispidstarttime;
pub const dispidstoptime = SegDispidList.dispidstoptime;
pub const dispidrecordingstopped = SegDispidList.dispidrecordingstopped;
pub const dispidrecordingstarted = SegDispidList.dispidrecordingstarted;
pub const dispidNameSetLock = SegDispidList.dispidNameSetLock;
pub const dispidrecordingtype = SegDispidList.dispidrecordingtype;
pub const dispidstart = SegDispidList.dispidstart;
pub const dispidRecordingAttribute = SegDispidList.dispidRecordingAttribute;
pub const dispid_RecordingAttribute = SegDispidList.dispid_RecordingAttribute;
pub const dispidSBEConfigure = SegDispidList.dispidSBEConfigure;
pub const dispid_CurrentRatings = SegDispidList.dispid_CurrentRatings;
pub const dispid_MaxRatingsLevel = SegDispidList.dispid_MaxRatingsLevel;
pub const dispid_audioencoderint = SegDispidList.dispid_audioencoderint;
pub const dispid_videoencoderint = SegDispidList.dispid_videoencoderint;
pub const dispidService = SegDispidList.dispidService;
pub const dispid_BlockUnrated = SegDispidList.dispid_BlockUnrated;
pub const dispid_UnratedDelay = SegDispidList.dispid_UnratedDelay;
pub const dispid_SuppressEffects = SegDispidList.dispid_SuppressEffects;
pub const dispidsbesource = SegDispidList.dispidsbesource;
pub const dispidSetSinkFilter = SegDispidList.dispidSetSinkFilter;
pub const dispid_SinkStreams = SegDispidList.dispid_SinkStreams;
pub const dispidTVFormats = SegDispidList.dispidTVFormats;
pub const dispidModes = SegDispidList.dispidModes;
pub const dispidAuxInputs = SegDispidList.dispidAuxInputs;
pub const dispidTeleTextFilter = SegDispidList.dispidTeleTextFilter;
pub const dispid_channelchangeint = SegDispidList.dispid_channelchangeint;
pub const dispidUnlockProfile = SegDispidList.dispidUnlockProfile;
pub const dispid_AddFilter = SegDispidList.dispid_AddFilter;
pub const dispidSetMinSeek = SegDispidList.dispidSetMinSeek;
pub const dispidRateEx = SegDispidList.dispidRateEx;
pub const dispidaudiocounter = SegDispidList.dispidaudiocounter;
pub const dispidvideocounter = SegDispidList.dispidvideocounter;
pub const dispidcccounter = SegDispidList.dispidcccounter;
pub const dispidwstcounter = SegDispidList.dispidwstcounter;
pub const dispid_audiocounter = SegDispidList.dispid_audiocounter;
pub const dispid_videocounter = SegDispidList.dispid_videocounter;
pub const dispid_cccounter = SegDispidList.dispid_cccounter;
pub const dispid_wstcounter = SegDispidList.dispid_wstcounter;
pub const dispidaudioanalysis = SegDispidList.dispidaudioanalysis;
pub const dispidvideoanalysis = SegDispidList.dispidvideoanalysis;
pub const dispiddataanalysis = SegDispidList.dispiddataanalysis;
pub const dispidaudio_analysis = SegDispidList.dispidaudio_analysis;
pub const dispidvideo_analysis = SegDispidList.dispidvideo_analysis;
pub const dispiddata_analysis = SegDispidList.dispiddata_analysis;
pub const dispid_resetFilterList = SegDispidList.dispid_resetFilterList;
pub const dispidDevicePath = SegDispidList.dispidDevicePath;
pub const dispid_SourceFilter = SegDispidList.dispid_SourceFilter;
pub const dispid__SourceFilter = SegDispidList.dispid__SourceFilter;
pub const dispidUserEvent = SegDispidList.dispidUserEvent;
pub const dispid_Bookmark = SegDispidList.dispid_Bookmark;
pub const LastReservedDeviceDispid = SegDispidList.LastReservedDeviceDispid;

pub const SegEventidList = enum(i32) {
    eventidStateChange = 0,
    eventidOnTuneChanged = 1,
    eventidEndOfMedia = 2,
    eventidDVDNotify = 3,
    eventidPlayForwards = 4,
    eventidPlayBackwards = 5,
    eventidShowMenu = 6,
    eventidResume = 7,
    eventidSelectOrActivateButton = 8,
    eventidStillOff = 9,
    eventidPauseOn = 10,
    eventidChangeCurrentAudioStream = 11,
    eventidChangeCurrentSubpictureStream = 12,
    eventidChangeCurrentAngle = 13,
    eventidPlayAtTimeInTitle = 14,
    eventidPlayAtTime = 15,
    eventidPlayChapterInTitle = 16,
    eventidPlayChapter = 17,
    eventidReplayChapter = 18,
    eventidPlayNextChapter = 19,
    eventidStop = 20,
    eventidReturnFromSubmenu = 21,
    eventidPlayTitle = 22,
    eventidPlayPrevChapter = 23,
    eventidChangeKaraokePresMode = 24,
    eventidChangeVideoPresMode = 25,
    eventidOverlayUnavailable = 26,
    eventidSinkCertificateFailure = 27,
    eventidSinkCertificateSuccess = 28,
    eventidSourceCertificateFailure = 29,
    eventidSourceCertificateSuccess = 30,
    eventidRatingsBlocked = 31,
    eventidRatingsUnlocked = 32,
    eventidRatingsChanged = 33,
    eventidWriteFailure = 34,
    eventidTimeHole = 35,
    eventidStaleDataRead = 36,
    eventidContentBecomingStale = 37,
    eventidStaleFileDeleted = 38,
    eventidEncryptionOn = 39,
    eventidEncryptionOff = 40,
    eventidRateChange = 41,
    eventidLicenseChange = 42,
    eventidCOPPBlocked = 43,
    eventidCOPPUnblocked = 44,
    dispidlicenseerrorcode = 45,
    eventidBroadcastEvent = 46,
    eventidBroadcastEventEx = 47,
    eventidContentPrimarilyAudio = 48,
    dispidAVDecAudioDualMonoEvent = 49,
    dispidAVAudioSampleRateEvent = 50,
    dispidAVAudioChannelConfigEvent = 51,
    dispidAVAudioChannelCountEvent = 52,
    dispidAVDecCommonMeanBitRateEvent = 53,
    dispidAVDDSurroundModeEvent = 54,
    dispidAVDecCommonInputFormatEvent = 55,
    dispidAVDecCommonOutputFormatEvent = 56,
    eventidWriteFailureClear = 57,
    LastReservedDeviceEvent = 16383,
};
pub const eventidStateChange = SegEventidList.eventidStateChange;
pub const eventidOnTuneChanged = SegEventidList.eventidOnTuneChanged;
pub const eventidEndOfMedia = SegEventidList.eventidEndOfMedia;
pub const eventidDVDNotify = SegEventidList.eventidDVDNotify;
pub const eventidPlayForwards = SegEventidList.eventidPlayForwards;
pub const eventidPlayBackwards = SegEventidList.eventidPlayBackwards;
pub const eventidShowMenu = SegEventidList.eventidShowMenu;
pub const eventidResume = SegEventidList.eventidResume;
pub const eventidSelectOrActivateButton = SegEventidList.eventidSelectOrActivateButton;
pub const eventidStillOff = SegEventidList.eventidStillOff;
pub const eventidPauseOn = SegEventidList.eventidPauseOn;
pub const eventidChangeCurrentAudioStream = SegEventidList.eventidChangeCurrentAudioStream;
pub const eventidChangeCurrentSubpictureStream = SegEventidList.eventidChangeCurrentSubpictureStream;
pub const eventidChangeCurrentAngle = SegEventidList.eventidChangeCurrentAngle;
pub const eventidPlayAtTimeInTitle = SegEventidList.eventidPlayAtTimeInTitle;
pub const eventidPlayAtTime = SegEventidList.eventidPlayAtTime;
pub const eventidPlayChapterInTitle = SegEventidList.eventidPlayChapterInTitle;
pub const eventidPlayChapter = SegEventidList.eventidPlayChapter;
pub const eventidReplayChapter = SegEventidList.eventidReplayChapter;
pub const eventidPlayNextChapter = SegEventidList.eventidPlayNextChapter;
pub const eventidStop = SegEventidList.eventidStop;
pub const eventidReturnFromSubmenu = SegEventidList.eventidReturnFromSubmenu;
pub const eventidPlayTitle = SegEventidList.eventidPlayTitle;
pub const eventidPlayPrevChapter = SegEventidList.eventidPlayPrevChapter;
pub const eventidChangeKaraokePresMode = SegEventidList.eventidChangeKaraokePresMode;
pub const eventidChangeVideoPresMode = SegEventidList.eventidChangeVideoPresMode;
pub const eventidOverlayUnavailable = SegEventidList.eventidOverlayUnavailable;
pub const eventidSinkCertificateFailure = SegEventidList.eventidSinkCertificateFailure;
pub const eventidSinkCertificateSuccess = SegEventidList.eventidSinkCertificateSuccess;
pub const eventidSourceCertificateFailure = SegEventidList.eventidSourceCertificateFailure;
pub const eventidSourceCertificateSuccess = SegEventidList.eventidSourceCertificateSuccess;
pub const eventidRatingsBlocked = SegEventidList.eventidRatingsBlocked;
pub const eventidRatingsUnlocked = SegEventidList.eventidRatingsUnlocked;
pub const eventidRatingsChanged = SegEventidList.eventidRatingsChanged;
pub const eventidWriteFailure = SegEventidList.eventidWriteFailure;
pub const eventidTimeHole = SegEventidList.eventidTimeHole;
pub const eventidStaleDataRead = SegEventidList.eventidStaleDataRead;
pub const eventidContentBecomingStale = SegEventidList.eventidContentBecomingStale;
pub const eventidStaleFileDeleted = SegEventidList.eventidStaleFileDeleted;
pub const eventidEncryptionOn = SegEventidList.eventidEncryptionOn;
pub const eventidEncryptionOff = SegEventidList.eventidEncryptionOff;
pub const eventidRateChange = SegEventidList.eventidRateChange;
pub const eventidLicenseChange = SegEventidList.eventidLicenseChange;
pub const eventidCOPPBlocked = SegEventidList.eventidCOPPBlocked;
pub const eventidCOPPUnblocked = SegEventidList.eventidCOPPUnblocked;
pub const dispidlicenseerrorcode = SegEventidList.dispidlicenseerrorcode;
pub const eventidBroadcastEvent = SegEventidList.eventidBroadcastEvent;
pub const eventidBroadcastEventEx = SegEventidList.eventidBroadcastEventEx;
pub const eventidContentPrimarilyAudio = SegEventidList.eventidContentPrimarilyAudio;
pub const dispidAVDecAudioDualMonoEvent = SegEventidList.dispidAVDecAudioDualMonoEvent;
pub const dispidAVAudioSampleRateEvent = SegEventidList.dispidAVAudioSampleRateEvent;
pub const dispidAVAudioChannelConfigEvent = SegEventidList.dispidAVAudioChannelConfigEvent;
pub const dispidAVAudioChannelCountEvent = SegEventidList.dispidAVAudioChannelCountEvent;
pub const dispidAVDecCommonMeanBitRateEvent = SegEventidList.dispidAVDecCommonMeanBitRateEvent;
pub const dispidAVDDSurroundModeEvent = SegEventidList.dispidAVDDSurroundModeEvent;
pub const dispidAVDecCommonInputFormatEvent = SegEventidList.dispidAVDecCommonInputFormatEvent;
pub const dispidAVDecCommonOutputFormatEvent = SegEventidList.dispidAVDecCommonOutputFormatEvent;
pub const eventidWriteFailureClear = SegEventidList.eventidWriteFailureClear;
pub const LastReservedDeviceEvent = SegEventidList.LastReservedDeviceEvent;

pub const PositionModeList = enum(i32) {
    FrameMode = 0,
    TenthsSecondsMode = 1,
};
pub const FrameMode = PositionModeList.FrameMode;
pub const TenthsSecondsMode = PositionModeList.TenthsSecondsMode;

pub const RecordingType = enum(i32) {
    CONTENT = 0,
    REFERENCE = 1,
};
pub const CONTENT = RecordingType.CONTENT;
pub const REFERENCE = RecordingType.REFERENCE;

pub const MSVidCCService = enum(i32) {
    None = 0,
    Caption1 = 1,
    Caption2 = 2,
    Text1 = 3,
    Text2 = 4,
    XDS = 5,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const MSVidSinkStreams = enum(i32) {
    Video = 1,
    Audio = 2,
    Other = 4,
};
pub const MSVidSink_Video = MSVidSinkStreams.Video;
pub const MSVidSink_Audio = MSVidSinkStreams.Audio;
pub const MSVidSink_Other = MSVidSinkStreams.Other;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidRect_Value = @import("../zig.zig").Guid.initString("7f5000a6-a440-47ca-8acc-c0e75531a2c2");
pub const IID_IMSVidRect = &IID_IMSVidRect_Value;
pub const IMSVidRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: fn(
            self: *const IMSVidRect,
            TopVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: fn(
            self: *const IMSVidRect,
            TopVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: fn(
            self: *const IMSVidRect,
            LeftVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: fn(
            self: *const IMSVidRect,
            LeftVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: fn(
            self: *const IMSVidRect,
            WidthVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: fn(
            self: *const IMSVidRect,
            WidthVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: fn(
            self: *const IMSVidRect,
            HeightVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: fn(
            self: *const IMSVidRect,
            HeightVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWnd: fn(
            self: *const IMSVidRect,
            HWndVal: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HWnd: fn(
            self: *const IMSVidRect,
            HWndVal: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rect: fn(
            self: *const IMSVidRect,
            RectVal: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_Top(self: *const T, TopVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).get_Top(@ptrCast(*const IMSVidRect, self), TopVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Top(self: *const T, TopVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).put_Top(@ptrCast(*const IMSVidRect, self), TopVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_Left(self: *const T, LeftVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).get_Left(@ptrCast(*const IMSVidRect, self), LeftVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Left(self: *const T, LeftVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).put_Left(@ptrCast(*const IMSVidRect, self), LeftVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_Width(self: *const T, WidthVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).get_Width(@ptrCast(*const IMSVidRect, self), WidthVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Width(self: *const T, WidthVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).put_Width(@ptrCast(*const IMSVidRect, self), WidthVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_Height(self: *const T, HeightVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).get_Height(@ptrCast(*const IMSVidRect, self), HeightVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Height(self: *const T, HeightVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).put_Height(@ptrCast(*const IMSVidRect, self), HeightVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_HWnd(self: *const T, HWndVal: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).get_HWnd(@ptrCast(*const IMSVidRect, self), HWndVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_HWnd(self: *const T, HWndVal: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).put_HWnd(@ptrCast(*const IMSVidRect, self), HWndVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Rect(self: *const T, RectVal: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidRect.VTable, self.vtable).put_Rect(@ptrCast(*const IMSVidRect, self), RectVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidGraphSegmentContainer_Value = @import("../zig.zig").Guid.initString("3dd2903d-e0aa-11d2-b63a-00c04f79498e");
pub const IID_IMSVidGraphSegmentContainer = &IID_IMSVidGraphSegmentContainer_Value;
pub const IMSVidGraphSegmentContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Graph: fn(
            self: *const IMSVidGraphSegmentContainer,
            ppGraph: ?*?*IGraphBuilder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Input: fn(
            self: *const IMSVidGraphSegmentContainer,
            ppInput: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Outputs: fn(
            self: *const IMSVidGraphSegmentContainer,
            ppOutputs: ?*?*IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoRenderer: fn(
            self: *const IMSVidGraphSegmentContainer,
            ppVR: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioRenderer: fn(
            self: *const IMSVidGraphSegmentContainer,
            ppAR: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Features: fn(
            self: *const IMSVidGraphSegmentContainer,
            ppFeatures: ?*?*IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Composites: fn(
            self: *const IMSVidGraphSegmentContainer,
            ppComposites: ?*?*IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentContainer: fn(
            self: *const IMSVidGraphSegmentContainer,
            ppContainer: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Decompose: fn(
            self: *const IMSVidGraphSegmentContainer,
            pSegment: ?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsWindowless: fn(
            self: *const IMSVidGraphSegmentContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocus: fn(
            self: *const IMSVidGraphSegmentContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Graph(self: *const T, ppGraph: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).get_Graph(@ptrCast(*const IMSVidGraphSegmentContainer, self), ppGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Input(self: *const T, ppInput: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).get_Input(@ptrCast(*const IMSVidGraphSegmentContainer, self), ppInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Outputs(self: *const T, ppOutputs: ?*?*IEnumMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).get_Outputs(@ptrCast(*const IMSVidGraphSegmentContainer, self), ppOutputs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_VideoRenderer(self: *const T, ppVR: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).get_VideoRenderer(@ptrCast(*const IMSVidGraphSegmentContainer, self), ppVR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_AudioRenderer(self: *const T, ppAR: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).get_AudioRenderer(@ptrCast(*const IMSVidGraphSegmentContainer, self), ppAR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Features(self: *const T, ppFeatures: ?*?*IEnumMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).get_Features(@ptrCast(*const IMSVidGraphSegmentContainer, self), ppFeatures);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Composites(self: *const T, ppComposites: ?*?*IEnumMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).get_Composites(@ptrCast(*const IMSVidGraphSegmentContainer, self), ppComposites);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_ParentContainer(self: *const T, ppContainer: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).get_ParentContainer(@ptrCast(*const IMSVidGraphSegmentContainer, self), ppContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_Decompose(self: *const T, pSegment: ?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).Decompose(@ptrCast(*const IMSVidGraphSegmentContainer, self), pSegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_IsWindowless(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).IsWindowless(@ptrCast(*const IMSVidGraphSegmentContainer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_GetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentContainer.VTable, self.vtable).GetFocus(@ptrCast(*const IMSVidGraphSegmentContainer, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MSVidSegmentType = enum(i32) {
    SOURCE = 0,
    XFORM = 1,
    DEST = 2,
};
pub const MSVidSEG_SOURCE = MSVidSegmentType.SOURCE;
pub const MSVidSEG_XFORM = MSVidSegmentType.XFORM;
pub const MSVidSEG_DEST = MSVidSegmentType.DEST;

const IID_IMSVidGraphSegment_Value = @import("../zig.zig").Guid.initString("238dec54-adeb-4005-a349-f772b9afebc4");
pub const IID_IMSVidGraphSegment = &IID_IMSVidGraphSegment_Value;
pub const IMSVidGraphSegment = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Init: fn(
            self: *const IMSVidGraphSegment,
            pInit: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Init: fn(
            self: *const IMSVidGraphSegment,
            pInit: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFilters: fn(
            self: *const IMSVidGraphSegment,
            pNewEnum: ?*?*IEnumFilters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Container: fn(
            self: *const IMSVidGraphSegment,
            ppCtl: ?*?*IMSVidGraphSegmentContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Container: fn(
            self: *const IMSVidGraphSegment,
            pCtl: ?*IMSVidGraphSegmentContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IMSVidGraphSegment,
            pType: ?*MSVidSegmentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: fn(
            self: *const IMSVidGraphSegment,
            pGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Build: fn(
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostBuild: fn(
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreRun: fn(
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostRun: fn(
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreStop: fn(
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostStop: fn(
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEventNotify: fn(
            self: *const IMSVidGraphSegment,
            lEventCode: i32,
            lEventParm1: isize,
            lEventParm2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Decompose: fn(
            self: *const IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_get_Init(self: *const T, pInit: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).get_Init(@ptrCast(*const IMSVidGraphSegment, self), pInit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_put_Init(self: *const T, pInit: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).put_Init(@ptrCast(*const IMSVidGraphSegment, self), pInit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_EnumFilters(self: *const T, pNewEnum: ?*?*IEnumFilters) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).EnumFilters(@ptrCast(*const IMSVidGraphSegment, self), pNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_get_Container(self: *const T, ppCtl: ?*?*IMSVidGraphSegmentContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).get_Container(@ptrCast(*const IMSVidGraphSegment, self), ppCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_put_Container(self: *const T, pCtl: ?*IMSVidGraphSegmentContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).put_Container(@ptrCast(*const IMSVidGraphSegment, self), pCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_get_Type(self: *const T, pType: ?*MSVidSegmentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).get_Type(@ptrCast(*const IMSVidGraphSegment, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_get_Category(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).get_Category(@ptrCast(*const IMSVidGraphSegment, self), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_Build(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).Build(@ptrCast(*const IMSVidGraphSegment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PostBuild(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).PostBuild(@ptrCast(*const IMSVidGraphSegment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PreRun(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).PreRun(@ptrCast(*const IMSVidGraphSegment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PostRun(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).PostRun(@ptrCast(*const IMSVidGraphSegment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PreStop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).PreStop(@ptrCast(*const IMSVidGraphSegment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PostStop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).PostStop(@ptrCast(*const IMSVidGraphSegment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_OnEventNotify(self: *const T, lEventCode: i32, lEventParm1: isize, lEventParm2: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).OnEventNotify(@ptrCast(*const IMSVidGraphSegment, self), lEventCode, lEventParm1, lEventParm2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_Decompose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegment.VTable, self.vtable).Decompose(@ptrCast(*const IMSVidGraphSegment, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MSVidCtlButtonstate = enum(i32) {
    LEFT_BUTTON = 1,
    RIGHT_BUTTON = 2,
    MIDDLE_BUTTON = 4,
    X_BUTTON1 = 8,
    X_BUTTON2 = 16,
    // SHIFT = 1, this enum value conflicts with LEFT_BUTTON
    // CTRL = 2, this enum value conflicts with RIGHT_BUTTON
    // ALT = 4, this enum value conflicts with MIDDLE_BUTTON
};
pub const MSVIDCTL_LEFT_BUTTON = MSVidCtlButtonstate.LEFT_BUTTON;
pub const MSVIDCTL_RIGHT_BUTTON = MSVidCtlButtonstate.RIGHT_BUTTON;
pub const MSVIDCTL_MIDDLE_BUTTON = MSVidCtlButtonstate.MIDDLE_BUTTON;
pub const MSVIDCTL_X_BUTTON1 = MSVidCtlButtonstate.X_BUTTON1;
pub const MSVIDCTL_X_BUTTON2 = MSVidCtlButtonstate.X_BUTTON2;
pub const MSVIDCTL_SHIFT = MSVidCtlButtonstate.LEFT_BUTTON;
pub const MSVIDCTL_CTRL = MSVidCtlButtonstate.RIGHT_BUTTON;
pub const MSVIDCTL_ALT = MSVidCtlButtonstate.MIDDLE_BUTTON;

const IID_IMSVidGraphSegmentUserInput_Value = @import("../zig.zig").Guid.initString("301c060e-20d9-4587-9b03-f82ed9a9943c");
pub const IID_IMSVidGraphSegmentUserInput = &IID_IMSVidGraphSegmentUserInput_Value;
pub const IMSVidGraphSegmentUserInput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Click: fn(
            self: *const IMSVidGraphSegmentUserInput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DblClick: fn(
            self: *const IMSVidGraphSegmentUserInput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyDown: fn(
            self: *const IMSVidGraphSegmentUserInput,
            KeyCode: ?*i16,
            ShiftState: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyPress: fn(
            self: *const IMSVidGraphSegmentUserInput,
            KeyAscii: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyUp: fn(
            self: *const IMSVidGraphSegmentUserInput,
            KeyCode: ?*i16,
            ShiftState: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseDown: fn(
            self: *const IMSVidGraphSegmentUserInput,
            ButtonState: i16,
            ShiftState: i16,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseMove: fn(
            self: *const IMSVidGraphSegmentUserInput,
            ButtonState: i16,
            ShiftState: i16,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MouseUp: fn(
            self: *const IMSVidGraphSegmentUserInput,
            ButtonState: i16,
            ShiftState: i16,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_Click(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentUserInput.VTable, self.vtable).Click(@ptrCast(*const IMSVidGraphSegmentUserInput, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_DblClick(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentUserInput.VTable, self.vtable).DblClick(@ptrCast(*const IMSVidGraphSegmentUserInput, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_KeyDown(self: *const T, KeyCode: ?*i16, ShiftState: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentUserInput.VTable, self.vtable).KeyDown(@ptrCast(*const IMSVidGraphSegmentUserInput, self), KeyCode, ShiftState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_KeyPress(self: *const T, KeyAscii: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentUserInput.VTable, self.vtable).KeyPress(@ptrCast(*const IMSVidGraphSegmentUserInput, self), KeyAscii);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_KeyUp(self: *const T, KeyCode: ?*i16, ShiftState: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentUserInput.VTable, self.vtable).KeyUp(@ptrCast(*const IMSVidGraphSegmentUserInput, self), KeyCode, ShiftState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_MouseDown(self: *const T, ButtonState: i16, ShiftState: i16, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentUserInput.VTable, self.vtable).MouseDown(@ptrCast(*const IMSVidGraphSegmentUserInput, self), ButtonState, ShiftState, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_MouseMove(self: *const T, ButtonState: i16, ShiftState: i16, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentUserInput.VTable, self.vtable).MouseMove(@ptrCast(*const IMSVidGraphSegmentUserInput, self), ButtonState, ShiftState, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_MouseUp(self: *const T, ButtonState: i16, ShiftState: i16, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGraphSegmentUserInput.VTable, self.vtable).MouseUp(@ptrCast(*const IMSVidGraphSegmentUserInput, self), ButtonState, ShiftState, x, y);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidCompositionSegment_Value = @import("../zig.zig").Guid.initString("1c15d483-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidCompositionSegment = &IID_IMSVidCompositionSegment_Value;
pub const IMSVidCompositionSegment = extern struct {
    pub const VTable = extern struct {
        base: IMSVidGraphSegment.VTable,
        Compose: fn(
            self: *const IMSVidCompositionSegment,
            upstream: ?*IMSVidGraphSegment,
            downstream: ?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Up: fn(
            self: *const IMSVidCompositionSegment,
            upstream: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Down: fn(
            self: *const IMSVidCompositionSegment,
            downstream: ?*?*IMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidGraphSegment.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCompositionSegment_Compose(self: *const T, upstream: ?*IMSVidGraphSegment, downstream: ?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCompositionSegment.VTable, self.vtable).Compose(@ptrCast(*const IMSVidCompositionSegment, self), upstream, downstream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCompositionSegment_get_Up(self: *const T, upstream: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCompositionSegment.VTable, self.vtable).get_Up(@ptrCast(*const IMSVidCompositionSegment, self), upstream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCompositionSegment_get_Down(self: *const T, downstream: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCompositionSegment.VTable, self.vtable).get_Down(@ptrCast(*const IMSVidCompositionSegment, self), downstream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMSVidGraphSegment_Value = @import("../zig.zig").Guid.initString("3dd2903e-e0aa-11d2-b63a-00c04f79498e");
pub const IID_IEnumMSVidGraphSegment = &IID_IEnumMSVidGraphSegment_Value;
pub const IEnumMSVidGraphSegment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMSVidGraphSegment,
            celt: u32,
            rgelt: ?*?*IMSVidGraphSegment,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMSVidGraphSegment,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMSVidGraphSegment,
            ppenum: ?*?*IEnumMSVidGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMSVidGraphSegment_Next(self: *const T, celt: u32, rgelt: ?*?*IMSVidGraphSegment, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMSVidGraphSegment.VTable, self.vtable).Next(@ptrCast(*const IEnumMSVidGraphSegment, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMSVidGraphSegment_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMSVidGraphSegment.VTable, self.vtable).Skip(@ptrCast(*const IEnumMSVidGraphSegment, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMSVidGraphSegment_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMSVidGraphSegment.VTable, self.vtable).Reset(@ptrCast(*const IEnumMSVidGraphSegment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMSVidGraphSegment_Clone(self: *const T, ppenum: ?*?*IEnumMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMSVidGraphSegment.VTable, self.vtable).Clone(@ptrCast(*const IEnumMSVidGraphSegment, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVRGraphSegment_Value = @import("../zig.zig").Guid.initString("dd47de3f-9874-4f7b-8b22-7cb2688461e7");
pub const IID_IMSVidVRGraphSegment = &IID_IMSVidVRGraphSegment_Value;
pub const IMSVidVRGraphSegment = extern struct {
    pub const VTable = extern struct {
        base: IMSVidGraphSegment.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__VMRendererMode: fn(
            self: *const IMSVidVRGraphSegment,
            dwMode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Owner: fn(
            self: *const IMSVidVRGraphSegment,
            Window: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Owner: fn(
            self: *const IMSVidVRGraphSegment,
            Window: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseOverlay: fn(
            self: *const IMSVidVRGraphSegment,
            UseOverlayVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseOverlay: fn(
            self: *const IMSVidVRGraphSegment,
            UseOverlayVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: fn(
            self: *const IMSVidVRGraphSegment,
            Visible: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: fn(
            self: *const IMSVidVRGraphSegment,
            Visible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColorKey: fn(
            self: *const IMSVidVRGraphSegment,
            ColorKey: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ColorKey: fn(
            self: *const IMSVidVRGraphSegment,
            ColorKey: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Source: fn(
            self: *const IMSVidVRGraphSegment,
            r: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Source: fn(
            self: *const IMSVidVRGraphSegment,
            r: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Destination: fn(
            self: *const IMSVidVRGraphSegment,
            r: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Destination: fn(
            self: *const IMSVidVRGraphSegment,
            r: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NativeSize: fn(
            self: *const IMSVidVRGraphSegment,
            sizeval: ?*SIZE,
            aspectratio: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BorderColor: fn(
            self: *const IMSVidVRGraphSegment,
            color: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BorderColor: fn(
            self: *const IMSVidVRGraphSegment,
            color: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaintainAspectRatio: fn(
            self: *const IMSVidVRGraphSegment,
            fMaintain: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaintainAspectRatio: fn(
            self: *const IMSVidVRGraphSegment,
            fMaintain: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IMSVidVRGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayChange: fn(
            self: *const IMSVidVRGraphSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RePaint: fn(
            self: *const IMSVidVRGraphSegment,
            hdc: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidGraphSegment.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put__VMRendererMode(self: *const T, dwMode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).put__VMRendererMode(@ptrCast(*const IMSVidVRGraphSegment, self), dwMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_Owner(self: *const T, Window: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).put_Owner(@ptrCast(*const IMSVidVRGraphSegment, self), Window);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_Owner(self: *const T, Window: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).get_Owner(@ptrCast(*const IMSVidVRGraphSegment, self), Window);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_UseOverlay(self: *const T, UseOverlayVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).get_UseOverlay(@ptrCast(*const IMSVidVRGraphSegment, self), UseOverlayVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_UseOverlay(self: *const T, UseOverlayVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).put_UseOverlay(@ptrCast(*const IMSVidVRGraphSegment, self), UseOverlayVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_Visible(self: *const T, Visible: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).get_Visible(@ptrCast(*const IMSVidVRGraphSegment, self), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_Visible(self: *const T, Visible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).put_Visible(@ptrCast(*const IMSVidVRGraphSegment, self), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_ColorKey(self: *const T, ColorKey: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).get_ColorKey(@ptrCast(*const IMSVidVRGraphSegment, self), ColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_ColorKey(self: *const T, ColorKey: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).put_ColorKey(@ptrCast(*const IMSVidVRGraphSegment, self), ColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_Source(self: *const T, r: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).get_Source(@ptrCast(*const IMSVidVRGraphSegment, self), r);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_Source(self: *const T, r: RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).put_Source(@ptrCast(*const IMSVidVRGraphSegment, self), r);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_Destination(self: *const T, r: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).get_Destination(@ptrCast(*const IMSVidVRGraphSegment, self), r);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_Destination(self: *const T, r: RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).put_Destination(@ptrCast(*const IMSVidVRGraphSegment, self), r);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_NativeSize(self: *const T, sizeval: ?*SIZE, aspectratio: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).get_NativeSize(@ptrCast(*const IMSVidVRGraphSegment, self), sizeval, aspectratio);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_BorderColor(self: *const T, color: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).get_BorderColor(@ptrCast(*const IMSVidVRGraphSegment, self), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_BorderColor(self: *const T, color: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).put_BorderColor(@ptrCast(*const IMSVidVRGraphSegment, self), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_MaintainAspectRatio(self: *const T, fMaintain: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).get_MaintainAspectRatio(@ptrCast(*const IMSVidVRGraphSegment, self), fMaintain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_MaintainAspectRatio(self: *const T, fMaintain: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).put_MaintainAspectRatio(@ptrCast(*const IMSVidVRGraphSegment, self), fMaintain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).Refresh(@ptrCast(*const IMSVidVRGraphSegment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_DisplayChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).DisplayChange(@ptrCast(*const IMSVidVRGraphSegment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_RePaint(self: *const T, hdc: ?HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVRGraphSegment.VTable, self.vtable).RePaint(@ptrCast(*const IMSVidVRGraphSegment, self), hdc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidDevice_Value = @import("../zig.zig").Guid.initString("1c15d47c-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidDevice = &IID_IMSVidDevice_Value;
pub const IMSVidDevice = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IMSVidDevice,
            Name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: fn(
            self: *const IMSVidDevice,
            Status: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Power: fn(
            self: *const IMSVidDevice,
            Power: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Power: fn(
            self: *const IMSVidDevice,
            Power: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: fn(
            self: *const IMSVidDevice,
            Guid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassID: fn(
            self: *const IMSVidDevice,
            Clsid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__Category: fn(
            self: *const IMSVidDevice,
            Guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__ClassID: fn(
            self: *const IMSVidDevice,
            Clsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualDevice: fn(
            self: *const IMSVidDevice,
            Device: ?*IMSVidDevice,
            IsEqual: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_Name(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice.VTable, self.vtable).get_Name(@ptrCast(*const IMSVidDevice, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_Status(self: *const T, Status: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice.VTable, self.vtable).get_Status(@ptrCast(*const IMSVidDevice, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_put_Power(self: *const T, Power: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice.VTable, self.vtable).put_Power(@ptrCast(*const IMSVidDevice, self), Power);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_Power(self: *const T, Power: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice.VTable, self.vtable).get_Power(@ptrCast(*const IMSVidDevice, self), Power);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_Category(self: *const T, _param_Guid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice.VTable, self.vtable).get_Category(@ptrCast(*const IMSVidDevice, self), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_ClassID(self: *const T, Clsid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice.VTable, self.vtable).get_ClassID(@ptrCast(*const IMSVidDevice, self), Clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get__Category(self: *const T, _param_Guid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice.VTable, self.vtable).get__Category(@ptrCast(*const IMSVidDevice, self), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get__ClassID(self: *const T, Clsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice.VTable, self.vtable).get__ClassID(@ptrCast(*const IMSVidDevice, self), Clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_IsEqualDevice(self: *const T, Device: ?*IMSVidDevice, IsEqual: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice.VTable, self.vtable).IsEqualDevice(@ptrCast(*const IMSVidDevice, self), Device, IsEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidDevice2_Value = @import("../zig.zig").Guid.initString("87bd2783-ebc0-478c-b4a0-e8e7f43ab78e");
pub const IID_IMSVidDevice2 = &IID_IMSVidDevice2_Value;
pub const IMSVidDevice2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevicePath: fn(
            self: *const IMSVidDevice2,
            DevPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice2_get_DevicePath(self: *const T, DevPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDevice2.VTable, self.vtable).get_DevicePath(@ptrCast(*const IMSVidDevice2, self), DevPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidInputDevice_Value = @import("../zig.zig").Guid.initString("37b0353d-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidInputDevice = &IID_IMSVidInputDevice_Value;
pub const IMSVidInputDevice = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDevice.VTable,
        IsViewable: fn(
            self: *const IMSVidInputDevice,
            v: ?*VARIANT,
            pfViewable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        View: fn(
            self: *const IMSVidInputDevice,
            v: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevice_IsViewable(self: *const T, v: ?*VARIANT, pfViewable: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidInputDevice.VTable, self.vtable).IsViewable(@ptrCast(*const IMSVidInputDevice, self), v, pfViewable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevice_View(self: *const T, v: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidInputDevice.VTable, self.vtable).View(@ptrCast(*const IMSVidInputDevice, self), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidDeviceEvent_Value = @import("../zig.zig").Guid.initString("1c15d480-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidDeviceEvent = &IID_IMSVidDeviceEvent_Value;
pub const IMSVidDeviceEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        StateChange: fn(
            self: *const IMSVidDeviceEvent,
            lpd: ?*IMSVidDevice,
            oldState: i32,
            newState: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDeviceEvent_StateChange(self: *const T, lpd: ?*IMSVidDevice, oldState: i32, newState: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidDeviceEvent.VTable, self.vtable).StateChange(@ptrCast(*const IMSVidDeviceEvent, self), lpd, oldState, newState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidInputDeviceEvent_Value = @import("../zig.zig").Guid.initString("37b0353e-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidInputDeviceEvent = &IID_IMSVidInputDeviceEvent_Value;
pub const IMSVidInputDeviceEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoInputDevice_Value = @import("../zig.zig").Guid.initString("1c15d47f-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidVideoInputDevice = &IID_IMSVidVideoInputDevice_Value;
pub const IMSVidVideoInputDevice = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDevice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidInputDevice.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidPlayback_Value = @import("../zig.zig").Guid.initString("37b03538-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidPlayback = &IID_IMSVidPlayback_Value;
pub const IMSVidPlayback = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableResetOnStop: fn(
            self: *const IMSVidPlayback,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableResetOnStop: fn(
            self: *const IMSVidPlayback,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IMSVidPlayback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IMSVidPlayback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IMSVidPlayback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CanStep: fn(
            self: *const IMSVidPlayback,
            fBackwards: i16,
            pfCan: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Step: fn(
            self: *const IMSVidPlayback,
            lStep: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: fn(
            self: *const IMSVidPlayback,
            plRate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: fn(
            self: *const IMSVidPlayback,
            plRate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentPosition: fn(
            self: *const IMSVidPlayback,
            lPosition: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPosition: fn(
            self: *const IMSVidPlayback,
            lPosition: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PositionMode: fn(
            self: *const IMSVidPlayback,
            lPositionMode: PositionModeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PositionMode: fn(
            self: *const IMSVidPlayback,
            lPositionMode: ?*PositionModeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: fn(
            self: *const IMSVidPlayback,
            lLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidInputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_EnableResetOnStop(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).get_EnableResetOnStop(@ptrCast(*const IMSVidPlayback, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_put_EnableResetOnStop(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).put_EnableResetOnStop(@ptrCast(*const IMSVidPlayback, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_Run(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).Run(@ptrCast(*const IMSVidPlayback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).Pause(@ptrCast(*const IMSVidPlayback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).Stop(@ptrCast(*const IMSVidPlayback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_CanStep(self: *const T, fBackwards: i16, pfCan: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).get_CanStep(@ptrCast(*const IMSVidPlayback, self), fBackwards, pfCan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_Step(self: *const T, lStep: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).Step(@ptrCast(*const IMSVidPlayback, self), lStep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_put_Rate(self: *const T, plRate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).put_Rate(@ptrCast(*const IMSVidPlayback, self), plRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_Rate(self: *const T, plRate: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).get_Rate(@ptrCast(*const IMSVidPlayback, self), plRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_put_CurrentPosition(self: *const T, lPosition: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).put_CurrentPosition(@ptrCast(*const IMSVidPlayback, self), lPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_CurrentPosition(self: *const T, lPosition: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).get_CurrentPosition(@ptrCast(*const IMSVidPlayback, self), lPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_put_PositionMode(self: *const T, lPositionMode: PositionModeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).put_PositionMode(@ptrCast(*const IMSVidPlayback, self), lPositionMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_PositionMode(self: *const T, lPositionMode: ?*PositionModeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).get_PositionMode(@ptrCast(*const IMSVidPlayback, self), lPositionMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_Length(self: *const T, lLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlayback.VTable, self.vtable).get_Length(@ptrCast(*const IMSVidPlayback, self), lLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidPlaybackEvent_Value = @import("../zig.zig").Guid.initString("37b0353b-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidPlaybackEvent = &IID_IMSVidPlaybackEvent_Value;
pub const IMSVidPlaybackEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDeviceEvent.VTable,
        EndOfMedia: fn(
            self: *const IMSVidPlaybackEvent,
            lpd: ?*IMSVidPlayback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidInputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlaybackEvent_EndOfMedia(self: *const T, lpd: ?*IMSVidPlayback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidPlaybackEvent.VTable, self.vtable).EndOfMedia(@ptrCast(*const IMSVidPlaybackEvent, self), lpd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidTuner_Value = @import("../zig.zig").Guid.initString("1c15d47d-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidTuner = &IID_IMSVidTuner_Value;
pub const IMSVidTuner = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoInputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tune: fn(
            self: *const IMSVidTuner,
            ppTR: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Tune: fn(
            self: *const IMSVidTuner,
            pTR: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: fn(
            self: *const IMSVidTuner,
            plTS: ?*?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuningSpace: fn(
            self: *const IMSVidTuner,
            plTS: ?*ITuningSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidVideoInputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTuner_get_Tune(self: *const T, ppTR: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidTuner.VTable, self.vtable).get_Tune(@ptrCast(*const IMSVidTuner, self), ppTR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTuner_put_Tune(self: *const T, pTR: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidTuner.VTable, self.vtable).put_Tune(@ptrCast(*const IMSVidTuner, self), pTR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTuner_get_TuningSpace(self: *const T, plTS: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidTuner.VTable, self.vtable).get_TuningSpace(@ptrCast(*const IMSVidTuner, self), plTS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTuner_put_TuningSpace(self: *const T, plTS: ?*ITuningSpace) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidTuner.VTable, self.vtable).put_TuningSpace(@ptrCast(*const IMSVidTuner, self), plTS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidTunerEvent_Value = @import("../zig.zig").Guid.initString("1c15d485-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidTunerEvent = &IID_IMSVidTunerEvent_Value;
pub const IMSVidTunerEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDeviceEvent.VTable,
        TuneChanged: fn(
            self: *const IMSVidTunerEvent,
            lpd: ?*IMSVidTuner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidInputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTunerEvent_TuneChanged(self: *const T, lpd: ?*IMSVidTuner) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidTunerEvent.VTable, self.vtable).TuneChanged(@ptrCast(*const IMSVidTunerEvent, self), lpd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidAnalogTuner_Value = @import("../zig.zig").Guid.initString("1c15d47e-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidAnalogTuner = &IID_IMSVidAnalogTuner_Value;
pub const IMSVidAnalogTuner = extern struct {
    pub const VTable = extern struct {
        base: IMSVidTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channel: fn(
            self: *const IMSVidAnalogTuner,
            Channel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channel: fn(
            self: *const IMSVidAnalogTuner,
            Channel: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoFrequency: fn(
            self: *const IMSVidAnalogTuner,
            lcc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFrequency: fn(
            self: *const IMSVidAnalogTuner,
            lcc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: fn(
            self: *const IMSVidAnalogTuner,
            lcc: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: fn(
            self: *const IMSVidAnalogTuner,
            lcc: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SAP: fn(
            self: *const IMSVidAnalogTuner,
            pfSapOn: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SAP: fn(
            self: *const IMSVidAnalogTuner,
            fSapOn: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChannelAvailable: fn(
            self: *const IMSVidAnalogTuner,
            nChannel: i32,
            SignalStrength: ?*i32,
            fSignalPresent: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_Channel(self: *const T, Channel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner.VTable, self.vtable).get_Channel(@ptrCast(*const IMSVidAnalogTuner, self), Channel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_put_Channel(self: *const T, Channel: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner.VTable, self.vtable).put_Channel(@ptrCast(*const IMSVidAnalogTuner, self), Channel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_VideoFrequency(self: *const T, lcc: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner.VTable, self.vtable).get_VideoFrequency(@ptrCast(*const IMSVidAnalogTuner, self), lcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_AudioFrequency(self: *const T, lcc: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner.VTable, self.vtable).get_AudioFrequency(@ptrCast(*const IMSVidAnalogTuner, self), lcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_CountryCode(self: *const T, lcc: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner.VTable, self.vtable).get_CountryCode(@ptrCast(*const IMSVidAnalogTuner, self), lcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_put_CountryCode(self: *const T, lcc: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner.VTable, self.vtable).put_CountryCode(@ptrCast(*const IMSVidAnalogTuner, self), lcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_SAP(self: *const T, pfSapOn: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner.VTable, self.vtable).get_SAP(@ptrCast(*const IMSVidAnalogTuner, self), pfSapOn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_put_SAP(self: *const T, fSapOn: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner.VTable, self.vtable).put_SAP(@ptrCast(*const IMSVidAnalogTuner, self), fSapOn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_ChannelAvailable(self: *const T, nChannel: i32, SignalStrength: ?*i32, fSignalPresent: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner.VTable, self.vtable).ChannelAvailable(@ptrCast(*const IMSVidAnalogTuner, self), nChannel, SignalStrength, fSignalPresent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidAnalogTuner2_Value = @import("../zig.zig").Guid.initString("37647bf7-3dde-4cc8-a4dc-0d534d3d0037");
pub const IID_IMSVidAnalogTuner2 = &IID_IMSVidAnalogTuner2_Value;
pub const IMSVidAnalogTuner2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidAnalogTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormats: fn(
            self: *const IMSVidAnalogTuner2,
            Formats: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TunerModes: fn(
            self: *const IMSVidAnalogTuner2,
            Modes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumAuxInputs: fn(
            self: *const IMSVidAnalogTuner2,
            Inputs: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidAnalogTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner2_get_TVFormats(self: *const T, Formats: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner2.VTable, self.vtable).get_TVFormats(@ptrCast(*const IMSVidAnalogTuner2, self), Formats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner2_get_TunerModes(self: *const T, Modes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner2.VTable, self.vtable).get_TunerModes(@ptrCast(*const IMSVidAnalogTuner2, self), Modes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner2_get_NumAuxInputs(self: *const T, Inputs: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAnalogTuner2.VTable, self.vtable).get_NumAuxInputs(@ptrCast(*const IMSVidAnalogTuner2, self), Inputs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidAnalogTunerEvent_Value = @import("../zig.zig").Guid.initString("1c15d486-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidAnalogTunerEvent = &IID_IMSVidAnalogTunerEvent_Value;
pub const IMSVidAnalogTunerEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidTunerEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidTunerEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidFilePlayback_Value = @import("../zig.zig").Guid.initString("37b03539-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidFilePlayback = &IID_IMSVidFilePlayback_Value;
pub const IMSVidFilePlayback = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlayback.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileName: fn(
            self: *const IMSVidFilePlayback,
            FileName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileName: fn(
            self: *const IMSVidFilePlayback,
            FileName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidPlayback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFilePlayback_get_FileName(self: *const T, FileName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidFilePlayback.VTable, self.vtable).get_FileName(@ptrCast(*const IMSVidFilePlayback, self), FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFilePlayback_put_FileName(self: *const T, FileName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidFilePlayback.VTable, self.vtable).put_FileName(@ptrCast(*const IMSVidFilePlayback, self), FileName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidFilePlayback2_Value = @import("../zig.zig").Guid.initString("2f7e44af-6e52-4660-bc08-d8d542587d72");
pub const IID_IMSVidFilePlayback2 = &IID_IMSVidFilePlayback2_Value;
pub const IMSVidFilePlayback2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlayback.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__SourceFilter: fn(
            self: *const IMSVidFilePlayback2,
            FileName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put___SourceFilter: fn(
            self: *const IMSVidFilePlayback2,
            FileName: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFilePlayback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFilePlayback2_put__SourceFilter(self: *const T, FileName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidFilePlayback2.VTable, self.vtable).put__SourceFilter(@ptrCast(*const IMSVidFilePlayback2, self), FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFilePlayback2_put___SourceFilter(self: *const T, FileName: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidFilePlayback2.VTable, self.vtable).put___SourceFilter(@ptrCast(*const IMSVidFilePlayback2, self), FileName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidFilePlaybackEvent_Value = @import("../zig.zig").Guid.initString("37b0353a-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidFilePlaybackEvent = &IID_IMSVidFilePlaybackEvent_Value;
pub const IMSVidFilePlaybackEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlaybackEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidPlaybackEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVDMenuIDConstants = enum(i32) {
    Title = 2,
    Root = 3,
    Subpicture = 4,
    Audio = 5,
    Angle = 6,
    Chapter = 7,
};
pub const dvdMenu_Title = DVDMenuIDConstants.Title;
pub const dvdMenu_Root = DVDMenuIDConstants.Root;
pub const dvdMenu_Subpicture = DVDMenuIDConstants.Subpicture;
pub const dvdMenu_Audio = DVDMenuIDConstants.Audio;
pub const dvdMenu_Angle = DVDMenuIDConstants.Angle;
pub const dvdMenu_Chapter = DVDMenuIDConstants.Chapter;

pub const DVDFilterState = enum(i32) {
    Undefined = -2,
    Unitialized = -1,
    Stopped = 0,
    Paused = 1,
    Running = 2,
};
pub const dvdState_Undefined = DVDFilterState.Undefined;
pub const dvdState_Unitialized = DVDFilterState.Unitialized;
pub const dvdState_Stopped = DVDFilterState.Stopped;
pub const dvdState_Paused = DVDFilterState.Paused;
pub const dvdState_Running = DVDFilterState.Running;

pub const DVDTextStringType = enum(i32) {
    Struct_Volume = 1,
    Struct_Title = 2,
    Struct_ParentalID = 3,
    Struct_PartOfTitle = 4,
    Struct_Cell = 5,
    Stream_Audio = 16,
    Stream_Subpicture = 17,
    Stream_Angle = 18,
    Channel_Audio = 32,
    General_Name = 48,
    General_Comments = 49,
    Title_Series = 56,
    Title_Movie = 57,
    Title_Video = 58,
    Title_Album = 59,
    Title_Song = 60,
    Title_Other = 63,
    Title_Sub_Series = 64,
    Title_Sub_Movie = 65,
    Title_Sub_Video = 66,
    Title_Sub_Album = 67,
    Title_Sub_Song = 68,
    Title_Sub_Other = 71,
    Title_Orig_Series = 72,
    Title_Orig_Movie = 73,
    Title_Orig_Video = 74,
    Title_Orig_Album = 75,
    Title_Orig_Song = 76,
    Title_Orig_Other = 79,
    Other_Scene = 80,
    Other_Cut = 81,
    Other_Take = 82,
};
pub const dvdStruct_Volume = DVDTextStringType.Struct_Volume;
pub const dvdStruct_Title = DVDTextStringType.Struct_Title;
pub const dvdStruct_ParentalID = DVDTextStringType.Struct_ParentalID;
pub const dvdStruct_PartOfTitle = DVDTextStringType.Struct_PartOfTitle;
pub const dvdStruct_Cell = DVDTextStringType.Struct_Cell;
pub const dvdStream_Audio = DVDTextStringType.Stream_Audio;
pub const dvdStream_Subpicture = DVDTextStringType.Stream_Subpicture;
pub const dvdStream_Angle = DVDTextStringType.Stream_Angle;
pub const dvdChannel_Audio = DVDTextStringType.Channel_Audio;
pub const dvdGeneral_Name = DVDTextStringType.General_Name;
pub const dvdGeneral_Comments = DVDTextStringType.General_Comments;
pub const dvdTitle_Series = DVDTextStringType.Title_Series;
pub const dvdTitle_Movie = DVDTextStringType.Title_Movie;
pub const dvdTitle_Video = DVDTextStringType.Title_Video;
pub const dvdTitle_Album = DVDTextStringType.Title_Album;
pub const dvdTitle_Song = DVDTextStringType.Title_Song;
pub const dvdTitle_Other = DVDTextStringType.Title_Other;
pub const dvdTitle_Sub_Series = DVDTextStringType.Title_Sub_Series;
pub const dvdTitle_Sub_Movie = DVDTextStringType.Title_Sub_Movie;
pub const dvdTitle_Sub_Video = DVDTextStringType.Title_Sub_Video;
pub const dvdTitle_Sub_Album = DVDTextStringType.Title_Sub_Album;
pub const dvdTitle_Sub_Song = DVDTextStringType.Title_Sub_Song;
pub const dvdTitle_Sub_Other = DVDTextStringType.Title_Sub_Other;
pub const dvdTitle_Orig_Series = DVDTextStringType.Title_Orig_Series;
pub const dvdTitle_Orig_Movie = DVDTextStringType.Title_Orig_Movie;
pub const dvdTitle_Orig_Video = DVDTextStringType.Title_Orig_Video;
pub const dvdTitle_Orig_Album = DVDTextStringType.Title_Orig_Album;
pub const dvdTitle_Orig_Song = DVDTextStringType.Title_Orig_Song;
pub const dvdTitle_Orig_Other = DVDTextStringType.Title_Orig_Other;
pub const dvdOther_Scene = DVDTextStringType.Other_Scene;
pub const dvdOther_Cut = DVDTextStringType.Other_Cut;
pub const dvdOther_Take = DVDTextStringType.Other_Take;

pub const DVDSPExt = enum(i32) {
    NotSpecified = 0,
    Caption_Normal = 1,
    Caption_Big = 2,
    Caption_Children = 3,
    CC_Normal = 5,
    CC_Big = 6,
    CC_Children = 7,
    Forced = 9,
    DirectorComments_Normal = 13,
    DirectorComments_Big = 14,
    DirectorComments_Children = 15,
};
pub const dvdSPExt_NotSpecified = DVDSPExt.NotSpecified;
pub const dvdSPExt_Caption_Normal = DVDSPExt.Caption_Normal;
pub const dvdSPExt_Caption_Big = DVDSPExt.Caption_Big;
pub const dvdSPExt_Caption_Children = DVDSPExt.Caption_Children;
pub const dvdSPExt_CC_Normal = DVDSPExt.CC_Normal;
pub const dvdSPExt_CC_Big = DVDSPExt.CC_Big;
pub const dvdSPExt_CC_Children = DVDSPExt.CC_Children;
pub const dvdSPExt_Forced = DVDSPExt.Forced;
pub const dvdSPExt_DirectorComments_Normal = DVDSPExt.DirectorComments_Normal;
pub const dvdSPExt_DirectorComments_Big = DVDSPExt.DirectorComments_Big;
pub const dvdSPExt_DirectorComments_Children = DVDSPExt.DirectorComments_Children;

const IID_IMSVidWebDVD_Value = @import("../zig.zig").Guid.initString("cf45f88b-ac56-4ee2-a73a-ed04e2885d3c");
pub const IID_IMSVidWebDVD = &IID_IMSVidWebDVD_Value;
pub const IMSVidWebDVD = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlayback.VTable,
        OnDVDEvent: fn(
            self: *const IMSVidWebDVD,
            lEvent: i32,
            lParam1: isize,
            lParam2: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayTitle: fn(
            self: *const IMSVidWebDVD,
            lTitle: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapterInTitle: fn(
            self: *const IMSVidWebDVD,
            lTitle: i32,
            lChapter: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapter: fn(
            self: *const IMSVidWebDVD,
            lChapter: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChaptersAutoStop: fn(
            self: *const IMSVidWebDVD,
            lTitle: i32,
            lstrChapter: i32,
            lChapterCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTime: fn(
            self: *const IMSVidWebDVD,
            strTime: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTimeInTitle: fn(
            self: *const IMSVidWebDVD,
            lTitle: i32,
            strTime: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPeriodInTitleAutoStop: fn(
            self: *const IMSVidWebDVD,
            lTitle: i32,
            strStartTime: ?BSTR,
            strEndTime: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplayChapter: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPrevChapter: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayNextChapter: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StillOff: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioLanguage: fn(
            self: *const IMSVidWebDVD,
            lStream: i32,
            fFormat: i16,
            strAudioLang: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowMenu: fn(
            self: *const IMSVidWebDVD,
            MenuID: DVDMenuIDConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnFromSubmenu: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonsAvailable: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentButton: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAndActivateButton: fn(
            self: *const IMSVidWebDVD,
            lButton: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateButton: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectRightButton: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectLeftButton: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectLowerButton: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectUpperButton: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAtPosition: fn(
            self: *const IMSVidWebDVD,
            xPos: i32,
            yPos: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAtPosition: fn(
            self: *const IMSVidWebDVD,
            xPos: i32,
            yPos: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonAtPosition: fn(
            self: *const IMSVidWebDVD,
            xPos: i32,
            yPos: i32,
            plButton: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfChapters: fn(
            self: *const IMSVidWebDVD,
            lTitle: i32,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalTitleTime: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TitlesAvailable: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumesAvailable: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentVolume: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDiscSide: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDomain: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentChapter: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTitle: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTime: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DVDTimeCode2bstr: fn(
            self: *const IMSVidWebDVD,
            timeCode: i32,
            pTimeStr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDDirectory: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DVDDirectory: fn(
            self: *const IMSVidWebDVD,
            newVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubpictureStreamEnabled: fn(
            self: *const IMSVidWebDVD,
            lstream: i32,
            fEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAudioStreamEnabled: fn(
            self: *const IMSVidWebDVD,
            lstream: i32,
            fEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentSubpictureStream: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentSubpictureStream: fn(
            self: *const IMSVidWebDVD,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubpictureLanguage: fn(
            self: *const IMSVidWebDVD,
            lStream: i32,
            strLanguage: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAudioStream: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentAudioStream: fn(
            self: *const IMSVidWebDVD,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioStreamsAvailable: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AnglesAvailable: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAngle: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentAngle: fn(
            self: *const IMSVidWebDVD,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubpictureStreamsAvailable: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubpictureOn: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SubpictureOn: fn(
            self: *const IMSVidWebDVD,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDUniqueID: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AcceptParentalLevelChange: fn(
            self: *const IMSVidWebDVD,
            fAccept: i16,
            strUserName: ?BSTR,
            strPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyParentalLevelChange: fn(
            self: *const IMSVidWebDVD,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectParentalCountry: fn(
            self: *const IMSVidWebDVD,
            lCountry: i32,
            strUserName: ?BSTR,
            strPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectParentalLevel: fn(
            self: *const IMSVidWebDVD,
            lParentalLevel: i32,
            strUserName: ?BSTR,
            strPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TitleParentalLevels: fn(
            self: *const IMSVidWebDVD,
            lTitle: i32,
            plParentalLevels: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlayerParentalCountry: fn(
            self: *const IMSVidWebDVD,
            plCountryCode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlayerParentalLevel: fn(
            self: *const IMSVidWebDVD,
            plParentalLevel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Eject: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UOPValid: fn(
            self: *const IMSVidWebDVD,
            lUOP: i32,
            pfValid: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SPRM: fn(
            self: *const IMSVidWebDVD,
            lIndex: i32,
            psSPRM: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GPRM: fn(
            self: *const IMSVidWebDVD,
            lIndex: i32,
            psSPRM: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GPRM: fn(
            self: *const IMSVidWebDVD,
            lIndex: i32,
            sValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextStringType: fn(
            self: *const IMSVidWebDVD,
            lLangIndex: i32,
            lStringIndex: i32,
            pType: ?*DVDTextStringType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextString: fn(
            self: *const IMSVidWebDVD,
            lLangIndex: i32,
            lStringIndex: i32,
            pstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextNumberOfStrings: fn(
            self: *const IMSVidWebDVD,
            lLangIndex: i32,
            plNumOfStrings: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextNumberOfLanguages: fn(
            self: *const IMSVidWebDVD,
            plNumOfLangs: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextLanguageLCID: fn(
            self: *const IMSVidWebDVD,
            lLangIndex: i32,
            lcid: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegionChange: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDAdm: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteBookmark: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreBookmark: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveBookmark: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultAudioLanguage: fn(
            self: *const IMSVidWebDVD,
            lang: i32,
            ext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectDefaultSubpictureLanguage: fn(
            self: *const IMSVidWebDVD,
            lang: i32,
            ext: DVDSPExt,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredSubpictureStream: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultMenuLanguage: fn(
            self: *const IMSVidWebDVD,
            lang: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultMenuLanguage: fn(
            self: *const IMSVidWebDVD,
            lang: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubpictureLanguage: fn(
            self: *const IMSVidWebDVD,
            lang: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAudioLanguage: fn(
            self: *const IMSVidWebDVD,
            lang: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubpictureLanguageExt: fn(
            self: *const IMSVidWebDVD,
            ext: ?*DVDSPExt,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAudioLanguageExt: fn(
            self: *const IMSVidWebDVD,
            ext: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageFromLCID: fn(
            self: *const IMSVidWebDVD,
            lcid: i32,
            lang: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KaraokeAudioPresentationMode: fn(
            self: *const IMSVidWebDVD,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KaraokeAudioPresentationMode: fn(
            self: *const IMSVidWebDVD,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KaraokeChannelContent: fn(
            self: *const IMSVidWebDVD,
            lStream: i32,
            lChan: i32,
            lContent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KaraokeChannelAssignment: fn(
            self: *const IMSVidWebDVD,
            lStream: i32,
            lChannelAssignment: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestorePreferredSettings: fn(
            self: *const IMSVidWebDVD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonRect: fn(
            self: *const IMSVidWebDVD,
            lButton: i32,
            pRect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDScreenInMouseCoordinates: fn(
            self: *const IMSVidWebDVD,
            ppRect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DVDScreenInMouseCoordinates: fn(
            self: *const IMSVidWebDVD,
            pRect: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidPlayback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_OnDVDEvent(self: *const T, lEvent: i32, lParam1: isize, lParam2: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).OnDVDEvent(@ptrCast(*const IMSVidWebDVD, self), lEvent, lParam1, lParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayTitle(self: *const T, lTitle: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).PlayTitle(@ptrCast(*const IMSVidWebDVD, self), lTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayChapterInTitle(self: *const T, lTitle: i32, lChapter: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).PlayChapterInTitle(@ptrCast(*const IMSVidWebDVD, self), lTitle, lChapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayChapter(self: *const T, lChapter: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).PlayChapter(@ptrCast(*const IMSVidWebDVD, self), lChapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayChaptersAutoStop(self: *const T, lTitle: i32, lstrChapter: i32, lChapterCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).PlayChaptersAutoStop(@ptrCast(*const IMSVidWebDVD, self), lTitle, lstrChapter, lChapterCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayAtTime(self: *const T, strTime: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).PlayAtTime(@ptrCast(*const IMSVidWebDVD, self), strTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayAtTimeInTitle(self: *const T, lTitle: i32, strTime: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).PlayAtTimeInTitle(@ptrCast(*const IMSVidWebDVD, self), lTitle, strTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayPeriodInTitleAutoStop(self: *const T, lTitle: i32, strStartTime: ?BSTR, strEndTime: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).PlayPeriodInTitleAutoStop(@ptrCast(*const IMSVidWebDVD, self), lTitle, strStartTime, strEndTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ReplayChapter(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).ReplayChapter(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayPrevChapter(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).PlayPrevChapter(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayNextChapter(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).PlayNextChapter(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_StillOff(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).StillOff(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_AudioLanguage(self: *const T, lStream: i32, fFormat: i16, strAudioLang: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_AudioLanguage(@ptrCast(*const IMSVidWebDVD, self), lStream, fFormat, strAudioLang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ShowMenu(self: *const T, MenuID: DVDMenuIDConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).ShowMenu(@ptrCast(*const IMSVidWebDVD, self), MenuID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).Resume(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ReturnFromSubmenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).ReturnFromSubmenu(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_ButtonsAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_ButtonsAvailable(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentButton(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentButton(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectAndActivateButton(self: *const T, lButton: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectAndActivateButton(@ptrCast(*const IMSVidWebDVD, self), lButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ActivateButton(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).ActivateButton(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectRightButton(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectRightButton(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectLeftButton(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectLeftButton(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectLowerButton(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectLowerButton(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectUpperButton(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectUpperButton(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ActivateAtPosition(self: *const T, xPos: i32, yPos: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).ActivateAtPosition(@ptrCast(*const IMSVidWebDVD, self), xPos, yPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectAtPosition(self: *const T, xPos: i32, yPos: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectAtPosition(@ptrCast(*const IMSVidWebDVD, self), xPos, yPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_ButtonAtPosition(self: *const T, xPos: i32, yPos: i32, plButton: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_ButtonAtPosition(@ptrCast(*const IMSVidWebDVD, self), xPos, yPos, plButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_NumberOfChapters(self: *const T, lTitle: i32, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_NumberOfChapters(@ptrCast(*const IMSVidWebDVD, self), lTitle, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_TotalTitleTime(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_TotalTitleTime(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_TitlesAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_TitlesAvailable(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_VolumesAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_VolumesAvailable(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentVolume(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentVolume(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentDiscSide(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentDiscSide(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentDomain(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentDomain(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentChapter(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentChapter(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentTitle(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentTitle(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentTime(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentTime(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_DVDTimeCode2bstr(self: *const T, timeCode: i32, pTimeStr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).DVDTimeCode2bstr(@ptrCast(*const IMSVidWebDVD, self), timeCode, pTimeStr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDDirectory(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DVDDirectory(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_DVDDirectory(self: *const T, newVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).put_DVDDirectory(@ptrCast(*const IMSVidWebDVD, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_IsSubpictureStreamEnabled(self: *const T, lstream: i32, fEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).IsSubpictureStreamEnabled(@ptrCast(*const IMSVidWebDVD, self), lstream, fEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_IsAudioStreamEnabled(self: *const T, lstream: i32, fEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).IsAudioStreamEnabled(@ptrCast(*const IMSVidWebDVD, self), lstream, fEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentSubpictureStream(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentSubpictureStream(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_CurrentSubpictureStream(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).put_CurrentSubpictureStream(@ptrCast(*const IMSVidWebDVD, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_SubpictureLanguage(self: *const T, lStream: i32, strLanguage: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_SubpictureLanguage(@ptrCast(*const IMSVidWebDVD, self), lStream, strLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentAudioStream(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentAudioStream(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_CurrentAudioStream(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).put_CurrentAudioStream(@ptrCast(*const IMSVidWebDVD, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_AudioStreamsAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_AudioStreamsAvailable(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_AnglesAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_AnglesAvailable(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentAngle(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_CurrentAngle(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_CurrentAngle(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).put_CurrentAngle(@ptrCast(*const IMSVidWebDVD, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_SubpictureStreamsAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_SubpictureStreamsAvailable(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_SubpictureOn(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_SubpictureOn(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_SubpictureOn(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).put_SubpictureOn(@ptrCast(*const IMSVidWebDVD, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDUniqueID(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DVDUniqueID(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_AcceptParentalLevelChange(self: *const T, fAccept: i16, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).AcceptParentalLevelChange(@ptrCast(*const IMSVidWebDVD, self), fAccept, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_NotifyParentalLevelChange(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).NotifyParentalLevelChange(@ptrCast(*const IMSVidWebDVD, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectParentalCountry(self: *const T, lCountry: i32, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectParentalCountry(@ptrCast(*const IMSVidWebDVD, self), lCountry, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectParentalLevel(self: *const T, lParentalLevel: i32, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectParentalLevel(@ptrCast(*const IMSVidWebDVD, self), lParentalLevel, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_TitleParentalLevels(self: *const T, lTitle: i32, plParentalLevels: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_TitleParentalLevels(@ptrCast(*const IMSVidWebDVD, self), lTitle, plParentalLevels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_PlayerParentalCountry(self: *const T, plCountryCode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_PlayerParentalCountry(@ptrCast(*const IMSVidWebDVD, self), plCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_PlayerParentalLevel(self: *const T, plParentalLevel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_PlayerParentalLevel(@ptrCast(*const IMSVidWebDVD, self), plParentalLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_Eject(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).Eject(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_UOPValid(self: *const T, lUOP: i32, pfValid: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).UOPValid(@ptrCast(*const IMSVidWebDVD, self), lUOP, pfValid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_SPRM(self: *const T, lIndex: i32, psSPRM: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_SPRM(@ptrCast(*const IMSVidWebDVD, self), lIndex, psSPRM);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_GPRM(self: *const T, lIndex: i32, psSPRM: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_GPRM(@ptrCast(*const IMSVidWebDVD, self), lIndex, psSPRM);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_GPRM(self: *const T, lIndex: i32, sValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).put_GPRM(@ptrCast(*const IMSVidWebDVD, self), lIndex, sValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextStringType(self: *const T, lLangIndex: i32, lStringIndex: i32, pType: ?*DVDTextStringType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DVDTextStringType(@ptrCast(*const IMSVidWebDVD, self), lLangIndex, lStringIndex, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextString(self: *const T, lLangIndex: i32, lStringIndex: i32, pstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DVDTextString(@ptrCast(*const IMSVidWebDVD, self), lLangIndex, lStringIndex, pstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextNumberOfStrings(self: *const T, lLangIndex: i32, plNumOfStrings: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DVDTextNumberOfStrings(@ptrCast(*const IMSVidWebDVD, self), lLangIndex, plNumOfStrings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextNumberOfLanguages(self: *const T, plNumOfLangs: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DVDTextNumberOfLanguages(@ptrCast(*const IMSVidWebDVD, self), plNumOfLangs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextLanguageLCID(self: *const T, lLangIndex: i32, lcid: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DVDTextLanguageLCID(@ptrCast(*const IMSVidWebDVD, self), lLangIndex, lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_RegionChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).RegionChange(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDAdm(self: *const T, pVal: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DVDAdm(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_DeleteBookmark(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).DeleteBookmark(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_RestoreBookmark(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).RestoreBookmark(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SaveBookmark(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SaveBookmark(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectDefaultAudioLanguage(self: *const T, lang: i32, ext: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectDefaultAudioLanguage(@ptrCast(*const IMSVidWebDVD, self), lang, ext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectDefaultSubpictureLanguage(self: *const T, lang: i32, ext: DVDSPExt) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).SelectDefaultSubpictureLanguage(@ptrCast(*const IMSVidWebDVD, self), lang, ext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_PreferredSubpictureStream(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_PreferredSubpictureStream(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultMenuLanguage(self: *const T, lang: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DefaultMenuLanguage(@ptrCast(*const IMSVidWebDVD, self), lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_DefaultMenuLanguage(self: *const T, lang: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).put_DefaultMenuLanguage(@ptrCast(*const IMSVidWebDVD, self), lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultSubpictureLanguage(self: *const T, lang: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DefaultSubpictureLanguage(@ptrCast(*const IMSVidWebDVD, self), lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultAudioLanguage(self: *const T, lang: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DefaultAudioLanguage(@ptrCast(*const IMSVidWebDVD, self), lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultSubpictureLanguageExt(self: *const T, ext: ?*DVDSPExt) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DefaultSubpictureLanguageExt(@ptrCast(*const IMSVidWebDVD, self), ext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultAudioLanguageExt(self: *const T, ext: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DefaultAudioLanguageExt(@ptrCast(*const IMSVidWebDVD, self), ext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_LanguageFromLCID(self: *const T, lcid: i32, lang: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_LanguageFromLCID(@ptrCast(*const IMSVidWebDVD, self), lcid, lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_KaraokeAudioPresentationMode(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_KaraokeAudioPresentationMode(@ptrCast(*const IMSVidWebDVD, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_KaraokeAudioPresentationMode(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).put_KaraokeAudioPresentationMode(@ptrCast(*const IMSVidWebDVD, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_KaraokeChannelContent(self: *const T, lStream: i32, lChan: i32, lContent: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_KaraokeChannelContent(@ptrCast(*const IMSVidWebDVD, self), lStream, lChan, lContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_KaraokeChannelAssignment(self: *const T, lStream: i32, lChannelAssignment: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_KaraokeChannelAssignment(@ptrCast(*const IMSVidWebDVD, self), lStream, lChannelAssignment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_RestorePreferredSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).RestorePreferredSettings(@ptrCast(*const IMSVidWebDVD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_ButtonRect(self: *const T, lButton: i32, pRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_ButtonRect(@ptrCast(*const IMSVidWebDVD, self), lButton, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDScreenInMouseCoordinates(self: *const T, ppRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).get_DVDScreenInMouseCoordinates(@ptrCast(*const IMSVidWebDVD, self), ppRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_DVDScreenInMouseCoordinates(self: *const T, pRect: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD.VTable, self.vtable).put_DVDScreenInMouseCoordinates(@ptrCast(*const IMSVidWebDVD, self), pRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidWebDVD2_Value = @import("../zig.zig").Guid.initString("7027212f-ee9a-4a7c-8b67-f023714cdaff");
pub const IID_IMSVidWebDVD2 = &IID_IMSVidWebDVD2_Value;
pub const IMSVidWebDVD2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidWebDVD.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bookmark: fn(
            self: *const IMSVidWebDVD2,
            ppData: [*]?*u8,
            pDataLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bookmark: fn(
            self: *const IMSVidWebDVD2,
            pData: ?*u8,
            dwDataLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidWebDVD.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD2_get_Bookmark(self: *const T, ppData: [*]?*u8, pDataLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD2.VTable, self.vtable).get_Bookmark(@ptrCast(*const IMSVidWebDVD2, self), ppData, pDataLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD2_put_Bookmark(self: *const T, pData: ?*u8, dwDataLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVD2.VTable, self.vtable).put_Bookmark(@ptrCast(*const IMSVidWebDVD2, self), pData, dwDataLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidWebDVDEvent_Value = @import("../zig.zig").Guid.initString("b4f7a674-9b83-49cb-a357-c63b871be958");
pub const IID_IMSVidWebDVDEvent = &IID_IMSVidWebDVDEvent_Value;
pub const IMSVidWebDVDEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlaybackEvent.VTable,
        DVDNotify: fn(
            self: *const IMSVidWebDVDEvent,
            lEventCode: i32,
            lParam1: VARIANT,
            lParam2: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayForwards: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayBackwards: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowMenu: fn(
            self: *const IMSVidWebDVDEvent,
            MenuID: DVDMenuIDConstants,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectOrActivateButton: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StillOff: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseOn: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCurrentAudioStream: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCurrentSubpictureStream: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCurrentAngle: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTimeInTitle: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayAtTime: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapterInTitle: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayChapter: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplayChapter: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayNextChapter: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnFromSubmenu: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayTitle: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlayPrevChapter: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeKaraokePresMode: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeVideoPresMode: fn(
            self: *const IMSVidWebDVDEvent,
            bEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidPlaybackEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_DVDNotify(self: *const T, lEventCode: i32, lParam1: VARIANT, lParam2: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).DVDNotify(@ptrCast(*const IMSVidWebDVDEvent, self), lEventCode, lParam1, lParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayForwards(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PlayForwards(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayBackwards(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PlayBackwards(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ShowMenu(self: *const T, MenuID: DVDMenuIDConstants, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).ShowMenu(@ptrCast(*const IMSVidWebDVDEvent, self), MenuID, bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_Resume(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).Resume(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_SelectOrActivateButton(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).SelectOrActivateButton(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_StillOff(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).StillOff(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PauseOn(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PauseOn(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeCurrentAudioStream(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).ChangeCurrentAudioStream(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeCurrentSubpictureStream(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).ChangeCurrentSubpictureStream(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeCurrentAngle(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).ChangeCurrentAngle(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayAtTimeInTitle(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PlayAtTimeInTitle(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayAtTime(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PlayAtTime(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayChapterInTitle(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PlayChapterInTitle(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayChapter(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PlayChapter(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ReplayChapter(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).ReplayChapter(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayNextChapter(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PlayNextChapter(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_Stop(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).Stop(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ReturnFromSubmenu(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).ReturnFromSubmenu(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayTitle(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PlayTitle(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayPrevChapter(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).PlayPrevChapter(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeKaraokePresMode(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).ChangeKaraokePresMode(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeVideoPresMode(self: *const T, bEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDEvent.VTable, self.vtable).ChangeVideoPresMode(@ptrCast(*const IMSVidWebDVDEvent, self), bEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidWebDVDAdm_Value = @import("../zig.zig").Guid.initString("b8be681a-eb2c-47f0-b415-94d5452f0e05");
pub const IID_IMSVidWebDVDAdm = &IID_IMSVidWebDVDAdm_Value;
pub const IMSVidWebDVDAdm = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ChangePassword: fn(
            self: *const IMSVidWebDVDAdm,
            strUserName: ?BSTR,
            strOld: ?BSTR,
            strNew: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveParentalLevel: fn(
            self: *const IMSVidWebDVDAdm,
            level: i32,
            strUserName: ?BSTR,
            strPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveParentalCountry: fn(
            self: *const IMSVidWebDVDAdm,
            country: i32,
            strUserName: ?BSTR,
            strPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfirmPassword: fn(
            self: *const IMSVidWebDVDAdm,
            strUserName: ?BSTR,
            strPassword: ?BSTR,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentalLevel: fn(
            self: *const IMSVidWebDVDAdm,
            lLevel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentalCountry: fn(
            self: *const IMSVidWebDVDAdm,
            lCountry: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAudioLCID: fn(
            self: *const IMSVidWebDVDAdm,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultAudioLCID: fn(
            self: *const IMSVidWebDVDAdm,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubpictureLCID: fn(
            self: *const IMSVidWebDVDAdm,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultSubpictureLCID: fn(
            self: *const IMSVidWebDVDAdm,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultMenuLCID: fn(
            self: *const IMSVidWebDVDAdm,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultMenuLCID: fn(
            self: *const IMSVidWebDVDAdm,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BookmarkOnStop: fn(
            self: *const IMSVidWebDVDAdm,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BookmarkOnStop: fn(
            self: *const IMSVidWebDVDAdm,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_ChangePassword(self: *const T, strUserName: ?BSTR, strOld: ?BSTR, strNew: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).ChangePassword(@ptrCast(*const IMSVidWebDVDAdm, self), strUserName, strOld, strNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_SaveParentalLevel(self: *const T, level: i32, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).SaveParentalLevel(@ptrCast(*const IMSVidWebDVDAdm, self), level, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_SaveParentalCountry(self: *const T, country: i32, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).SaveParentalCountry(@ptrCast(*const IMSVidWebDVDAdm, self), country, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_ConfirmPassword(self: *const T, strUserName: ?BSTR, strPassword: ?BSTR, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).ConfirmPassword(@ptrCast(*const IMSVidWebDVDAdm, self), strUserName, strPassword, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_GetParentalLevel(self: *const T, lLevel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).GetParentalLevel(@ptrCast(*const IMSVidWebDVDAdm, self), lLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_GetParentalCountry(self: *const T, lCountry: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).GetParentalCountry(@ptrCast(*const IMSVidWebDVDAdm, self), lCountry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_get_DefaultAudioLCID(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).get_DefaultAudioLCID(@ptrCast(*const IMSVidWebDVDAdm, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_put_DefaultAudioLCID(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).put_DefaultAudioLCID(@ptrCast(*const IMSVidWebDVDAdm, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_get_DefaultSubpictureLCID(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).get_DefaultSubpictureLCID(@ptrCast(*const IMSVidWebDVDAdm, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_put_DefaultSubpictureLCID(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).put_DefaultSubpictureLCID(@ptrCast(*const IMSVidWebDVDAdm, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_get_DefaultMenuLCID(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).get_DefaultMenuLCID(@ptrCast(*const IMSVidWebDVDAdm, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_put_DefaultMenuLCID(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).put_DefaultMenuLCID(@ptrCast(*const IMSVidWebDVDAdm, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_get_BookmarkOnStop(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).get_BookmarkOnStop(@ptrCast(*const IMSVidWebDVDAdm, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_put_BookmarkOnStop(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidWebDVDAdm.VTable, self.vtable).put_BookmarkOnStop(@ptrCast(*const IMSVidWebDVDAdm, self), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidOutputDevice_Value = @import("../zig.zig").Guid.initString("37b03546-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidOutputDevice = &IID_IMSVidOutputDevice_Value;
pub const IMSVidOutputDevice = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDevice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDevice.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidOutputDeviceEvent_Value = @import("../zig.zig").Guid.initString("2e6a14e2-571c-11d3-b652-00c04f79498e");
pub const IID_IMSVidOutputDeviceEvent = &IID_IMSVidOutputDeviceEvent_Value;
pub const IMSVidOutputDeviceEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDeviceEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidFeature_Value = @import("../zig.zig").Guid.initString("37b03547-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidFeature = &IID_IMSVidFeature_Value;
pub const IMSVidFeature = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDevice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDevice.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidFeatureEvent_Value = @import("../zig.zig").Guid.initString("3dd2903c-e0aa-11d2-b63a-00c04f79498e");
pub const IID_IMSVidFeatureEvent = &IID_IMSVidFeatureEvent_Value;
pub const IMSVidFeatureEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDeviceEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidEncoder_Value = @import("../zig.zig").Guid.initString("c0020fd4-bee7-43d9-a495-9f213117103d");
pub const IID_IMSVidEncoder = &IID_IMSVidEncoder_Value;
pub const IMSVidEncoder = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoEncoderInterface: fn(
            self: *const IMSVidEncoder,
            ppEncInt: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioEncoderInterface: fn(
            self: *const IMSVidEncoder,
            ppEncInt: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeature.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEncoder_get_VideoEncoderInterface(self: *const T, ppEncInt: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidEncoder.VTable, self.vtable).get_VideoEncoderInterface(@ptrCast(*const IMSVidEncoder, self), ppEncInt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEncoder_get_AudioEncoderInterface(self: *const T, ppEncInt: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidEncoder.VTable, self.vtable).get_AudioEncoderInterface(@ptrCast(*const IMSVidEncoder, self), ppEncInt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidClosedCaptioning_Value = @import("../zig.zig").Guid.initString("99652ea1-c1f7-414f-bb7b-1c967de75983");
pub const IID_IMSVidClosedCaptioning = &IID_IMSVidClosedCaptioning_Value;
pub const IMSVidClosedCaptioning = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enable: fn(
            self: *const IMSVidClosedCaptioning,
            On: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enable: fn(
            self: *const IMSVidClosedCaptioning,
            On: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeature.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning_get_Enable(self: *const T, On: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidClosedCaptioning.VTable, self.vtable).get_Enable(@ptrCast(*const IMSVidClosedCaptioning, self), On);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning_put_Enable(self: *const T, On: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidClosedCaptioning.VTable, self.vtable).put_Enable(@ptrCast(*const IMSVidClosedCaptioning, self), On);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidClosedCaptioning2_Value = @import("../zig.zig").Guid.initString("e00cb864-a029-4310-9987-a873f5887d97");
pub const IID_IMSVidClosedCaptioning2 = &IID_IMSVidClosedCaptioning2_Value;
pub const IMSVidClosedCaptioning2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidClosedCaptioning.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Service: fn(
            self: *const IMSVidClosedCaptioning2,
            On: ?*MSVidCCService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Service: fn(
            self: *const IMSVidClosedCaptioning2,
            On: MSVidCCService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidClosedCaptioning.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning2_get_Service(self: *const T, On: ?*MSVidCCService) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidClosedCaptioning2.VTable, self.vtable).get_Service(@ptrCast(*const IMSVidClosedCaptioning2, self), On);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning2_put_Service(self: *const T, On: MSVidCCService) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidClosedCaptioning2.VTable, self.vtable).put_Service(@ptrCast(*const IMSVidClosedCaptioning2, self), On);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidClosedCaptioning3_Value = @import("../zig.zig").Guid.initString("c8638e8a-7625-4c51-9366-2f40a9831fc0");
pub const IID_IMSVidClosedCaptioning3 = &IID_IMSVidClosedCaptioning3_Value;
pub const IMSVidClosedCaptioning3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidClosedCaptioning2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TeleTextFilter: fn(
            self: *const IMSVidClosedCaptioning3,
            punkTTFilter: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidClosedCaptioning2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning3_get_TeleTextFilter(self: *const T, punkTTFilter: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidClosedCaptioning3.VTable, self.vtable).get_TeleTextFilter(@ptrCast(*const IMSVidClosedCaptioning3, self), punkTTFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidXDS_Value = @import("../zig.zig").Guid.initString("11ebc158-e712-4d1f-8bb3-01ed5274c4ce");
pub const IID_IMSVidXDS = &IID_IMSVidXDS_Value;
pub const IMSVidXDS = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelChangeInterface: fn(
            self: *const IMSVidXDS,
            punkCC: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeature.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidXDS_get_ChannelChangeInterface(self: *const T, punkCC: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidXDS.VTable, self.vtable).get_ChannelChangeInterface(@ptrCast(*const IMSVidXDS, self), punkCC);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidXDSEvent_Value = @import("../zig.zig").Guid.initString("6db2317d-3b23-41ec-ba4b-701f407eaf3a");
pub const IID_IMSVidXDSEvent = &IID_IMSVidXDSEvent_Value;
pub const IMSVidXDSEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeatureEvent.VTable,
        RatingChange: fn(
            self: *const IMSVidXDSEvent,
            PrevRatingSystem: EnTvRat_System,
            PrevLevel: EnTvRat_GenericLevel,
            PrevAttributes: BfEnTvRat_GenericAttributes,
            NewRatingSystem: EnTvRat_System,
            NewLevel: EnTvRat_GenericLevel,
            NewAttributes: BfEnTvRat_GenericAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeatureEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidXDSEvent_RatingChange(self: *const T, PrevRatingSystem: EnTvRat_System, PrevLevel: EnTvRat_GenericLevel, PrevAttributes: BfEnTvRat_GenericAttributes, NewRatingSystem: EnTvRat_System, NewLevel: EnTvRat_GenericLevel, NewAttributes: BfEnTvRat_GenericAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidXDSEvent.VTable, self.vtable).RatingChange(@ptrCast(*const IMSVidXDSEvent, self), PrevRatingSystem, PrevLevel, PrevAttributes, NewRatingSystem, NewLevel, NewAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidDataServices_Value = @import("../zig.zig").Guid.initString("334125c1-77e5-11d3-b653-00c04f79498e");
pub const IID_IMSVidDataServices = &IID_IMSVidDataServices_Value;
pub const IMSVidDataServices = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeature.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidDataServicesEvent_Value = @import("../zig.zig").Guid.initString("334125c2-77e5-11d3-b653-00c04f79498e");
pub const IID_IMSVidDataServicesEvent = &IID_IMSVidDataServicesEvent_Value;
pub const IMSVidDataServicesEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDeviceEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SourceSizeList = enum(i32) {
    FullSize = 0,
    ClipByOverScan = 1,
    ClipByClipRect = 2,
};
pub const sslFullSize = SourceSizeList.FullSize;
pub const sslClipByOverScan = SourceSizeList.ClipByOverScan;
pub const sslClipByClipRect = SourceSizeList.ClipByClipRect;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoRenderer_Value = @import("../zig.zig").Guid.initString("37b03540-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidVideoRenderer = &IID_IMSVidVideoRenderer_Value;
pub const IMSVidVideoRenderer = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CustomCompositorClass: fn(
            self: *const IMSVidVideoRenderer,
            CompositorCLSID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CustomCompositorClass: fn(
            self: *const IMSVidVideoRenderer,
            CompositorCLSID: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__CustomCompositorClass: fn(
            self: *const IMSVidVideoRenderer,
            CompositorCLSID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__CustomCompositorClass: fn(
            self: *const IMSVidVideoRenderer,
            CompositorCLSID: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__CustomCompositor: fn(
            self: *const IMSVidVideoRenderer,
            Compositor: ?*?*IVMRImageCompositor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__CustomCompositor: fn(
            self: *const IMSVidVideoRenderer,
            Compositor: ?*IVMRImageCompositor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixerBitmap: fn(
            self: *const IMSVidVideoRenderer,
            MixerPictureDisp: ?*?*IPictureDisp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MixerBitmap: fn(
            self: *const IMSVidVideoRenderer,
            MixerPicture: ?*?*IVMRMixerBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixerBitmap: fn(
            self: *const IMSVidVideoRenderer,
            MixerPictureDisp: ?*IPictureDisp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MixerBitmap: fn(
            self: *const IMSVidVideoRenderer,
            MixerPicture: ?*VMRALPHABITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixerBitmapPositionRect: fn(
            self: *const IMSVidVideoRenderer,
            rDest: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixerBitmapPositionRect: fn(
            self: *const IMSVidVideoRenderer,
            rDest: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixerBitmapOpacity: fn(
            self: *const IMSVidVideoRenderer,
            opacity: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixerBitmapOpacity: fn(
            self: *const IMSVidVideoRenderer,
            opacity: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetupMixerBitmap: fn(
            self: *const IMSVidVideoRenderer,
            MixerPictureDisp: ?*IPictureDisp,
            Opacity: i32,
            rDest: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceSize: fn(
            self: *const IMSVidVideoRenderer,
            CurrentSize: ?*SourceSizeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceSize: fn(
            self: *const IMSVidVideoRenderer,
            NewSize: SourceSizeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OverScan: fn(
            self: *const IMSVidVideoRenderer,
            plPercent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OverScan: fn(
            self: *const IMSVidVideoRenderer,
            lPercent: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableSourceRect: fn(
            self: *const IMSVidVideoRenderer,
            pRect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxVidRect: fn(
            self: *const IMSVidVideoRenderer,
            ppVidRect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinVidRect: fn(
            self: *const IMSVidVideoRenderer,
            ppVidRect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClippedSourceRect: fn(
            self: *const IMSVidVideoRenderer,
            pRect: ?*?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClippedSourceRect: fn(
            self: *const IMSVidVideoRenderer,
            pRect: ?*IMSVidRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsingOverlay: fn(
            self: *const IMSVidVideoRenderer,
            UseOverlayVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UsingOverlay: fn(
            self: *const IMSVidVideoRenderer,
            UseOverlayVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Capture: fn(
            self: *const IMSVidVideoRenderer,
            currentImage: ?*?*IPictureDisp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FramesPerSecond: fn(
            self: *const IMSVidVideoRenderer,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DecimateInput: fn(
            self: *const IMSVidVideoRenderer,
            pDeci: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DecimateInput: fn(
            self: *const IMSVidVideoRenderer,
            pDeci: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_CustomCompositorClass(self: *const T, CompositorCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_CustomCompositorClass(@ptrCast(*const IMSVidVideoRenderer, self), CompositorCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_CustomCompositorClass(self: *const T, CompositorCLSID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put_CustomCompositorClass(@ptrCast(*const IMSVidVideoRenderer, self), CompositorCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get__CustomCompositorClass(self: *const T, CompositorCLSID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get__CustomCompositorClass(@ptrCast(*const IMSVidVideoRenderer, self), CompositorCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put__CustomCompositorClass(self: *const T, CompositorCLSID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put__CustomCompositorClass(@ptrCast(*const IMSVidVideoRenderer, self), CompositorCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get__CustomCompositor(self: *const T, Compositor: ?*?*IVMRImageCompositor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get__CustomCompositor(@ptrCast(*const IMSVidVideoRenderer, self), Compositor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put__CustomCompositor(self: *const T, Compositor: ?*IVMRImageCompositor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put__CustomCompositor(@ptrCast(*const IMSVidVideoRenderer, self), Compositor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MixerBitmap(self: *const T, MixerPictureDisp: ?*?*IPictureDisp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_MixerBitmap(@ptrCast(*const IMSVidVideoRenderer, self), MixerPictureDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get__MixerBitmap(self: *const T, MixerPicture: ?*?*IVMRMixerBitmap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get__MixerBitmap(@ptrCast(*const IMSVidVideoRenderer, self), MixerPicture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_MixerBitmap(self: *const T, MixerPictureDisp: ?*IPictureDisp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put_MixerBitmap(@ptrCast(*const IMSVidVideoRenderer, self), MixerPictureDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put__MixerBitmap(self: *const T, MixerPicture: ?*VMRALPHABITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put__MixerBitmap(@ptrCast(*const IMSVidVideoRenderer, self), MixerPicture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MixerBitmapPositionRect(self: *const T, rDest: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_MixerBitmapPositionRect(@ptrCast(*const IMSVidVideoRenderer, self), rDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_MixerBitmapPositionRect(self: *const T, rDest: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put_MixerBitmapPositionRect(@ptrCast(*const IMSVidVideoRenderer, self), rDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MixerBitmapOpacity(self: *const T, opacity: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_MixerBitmapOpacity(@ptrCast(*const IMSVidVideoRenderer, self), opacity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_MixerBitmapOpacity(self: *const T, opacity: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put_MixerBitmapOpacity(@ptrCast(*const IMSVidVideoRenderer, self), opacity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_SetupMixerBitmap(self: *const T, MixerPictureDisp: ?*IPictureDisp, Opacity: i32, rDest: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).SetupMixerBitmap(@ptrCast(*const IMSVidVideoRenderer, self), MixerPictureDisp, Opacity, rDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_SourceSize(self: *const T, CurrentSize: ?*SourceSizeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_SourceSize(@ptrCast(*const IMSVidVideoRenderer, self), CurrentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_SourceSize(self: *const T, NewSize: SourceSizeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put_SourceSize(@ptrCast(*const IMSVidVideoRenderer, self), NewSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_OverScan(self: *const T, plPercent: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_OverScan(@ptrCast(*const IMSVidVideoRenderer, self), plPercent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_OverScan(self: *const T, lPercent: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put_OverScan(@ptrCast(*const IMSVidVideoRenderer, self), lPercent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_AvailableSourceRect(self: *const T, pRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_AvailableSourceRect(@ptrCast(*const IMSVidVideoRenderer, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MaxVidRect(self: *const T, ppVidRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_MaxVidRect(@ptrCast(*const IMSVidVideoRenderer, self), ppVidRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MinVidRect(self: *const T, ppVidRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_MinVidRect(@ptrCast(*const IMSVidVideoRenderer, self), ppVidRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_ClippedSourceRect(self: *const T, pRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_ClippedSourceRect(@ptrCast(*const IMSVidVideoRenderer, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_ClippedSourceRect(self: *const T, pRect: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put_ClippedSourceRect(@ptrCast(*const IMSVidVideoRenderer, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_UsingOverlay(self: *const T, UseOverlayVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_UsingOverlay(@ptrCast(*const IMSVidVideoRenderer, self), UseOverlayVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_UsingOverlay(self: *const T, UseOverlayVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put_UsingOverlay(@ptrCast(*const IMSVidVideoRenderer, self), UseOverlayVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_Capture(self: *const T, currentImage: ?*?*IPictureDisp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).Capture(@ptrCast(*const IMSVidVideoRenderer, self), currentImage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_FramesPerSecond(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_FramesPerSecond(@ptrCast(*const IMSVidVideoRenderer, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_DecimateInput(self: *const T, pDeci: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).get_DecimateInput(@ptrCast(*const IMSVidVideoRenderer, self), pDeci);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_DecimateInput(self: *const T, pDeci: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer.VTable, self.vtable).put_DecimateInput(@ptrCast(*const IMSVidVideoRenderer, self), pDeci);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVideoRendererEvent_Value = @import("../zig.zig").Guid.initString("37b03545-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidVideoRendererEvent = &IID_IMSVidVideoRendererEvent_Value;
pub const IMSVidVideoRendererEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        OverlayUnavailable: fn(
            self: *const IMSVidVideoRendererEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererEvent_OverlayUnavailable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRendererEvent.VTable, self.vtable).OverlayUnavailable(@ptrCast(*const IMSVidVideoRendererEvent, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidGenericSink_Value = @import("../zig.zig").Guid.initString("6c29b41d-455b-4c33-963a-0d28e5e555ea");
pub const IID_IMSVidGenericSink = &IID_IMSVidGenericSink_Value;
pub const IMSVidGenericSink = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        SetSinkFilter: fn(
            self: *const IMSVidGenericSink,
            bstrName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SinkStreams: fn(
            self: *const IMSVidGenericSink,
            pStreams: ?*MSVidSinkStreams,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SinkStreams: fn(
            self: *const IMSVidGenericSink,
            Streams: MSVidSinkStreams,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink_SetSinkFilter(self: *const T, bstrName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGenericSink.VTable, self.vtable).SetSinkFilter(@ptrCast(*const IMSVidGenericSink, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink_get_SinkStreams(self: *const T, pStreams: ?*MSVidSinkStreams) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGenericSink.VTable, self.vtable).get_SinkStreams(@ptrCast(*const IMSVidGenericSink, self), pStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink_put_SinkStreams(self: *const T, Streams: MSVidSinkStreams) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGenericSink.VTable, self.vtable).put_SinkStreams(@ptrCast(*const IMSVidGenericSink, self), Streams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidGenericSink2_Value = @import("../zig.zig").Guid.initString("6b5a28f3-47f1-4092-b168-60cabec08f1c");
pub const IID_IMSVidGenericSink2 = &IID_IMSVidGenericSink2_Value;
pub const IMSVidGenericSink2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidGenericSink.VTable,
        AddFilter: fn(
            self: *const IMSVidGenericSink2,
            bstrName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetFilterList: fn(
            self: *const IMSVidGenericSink2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidGenericSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink2_AddFilter(self: *const T, bstrName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGenericSink2.VTable, self.vtable).AddFilter(@ptrCast(*const IMSVidGenericSink2, self), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink2_ResetFilterList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidGenericSink2.VTable, self.vtable).ResetFilterList(@ptrCast(*const IMSVidGenericSink2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidStreamBufferRecordingControl_Value = @import("../zig.zig").Guid.initString("160621aa-bbbc-4326-a824-c395aebc6e74");
pub const IID_IMSVidStreamBufferRecordingControl = &IID_IMSVidStreamBufferRecordingControl_Value;
pub const IMSVidStreamBufferRecordingControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTime: fn(
            self: *const IMSVidStreamBufferRecordingControl,
            rtStart: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartTime: fn(
            self: *const IMSVidStreamBufferRecordingControl,
            rtStart: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopTime: fn(
            self: *const IMSVidStreamBufferRecordingControl,
            rtStop: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopTime: fn(
            self: *const IMSVidStreamBufferRecordingControl,
            rtStop: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingStopped: fn(
            self: *const IMSVidStreamBufferRecordingControl,
            phResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingStarted: fn(
            self: *const IMSVidStreamBufferRecordingControl,
            phResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingType: fn(
            self: *const IMSVidStreamBufferRecordingControl,
            dwType: ?*RecordingType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingAttribute: fn(
            self: *const IMSVidStreamBufferRecordingControl,
            pRecordingAttribute: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_StartTime(self: *const T, rtStart: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferRecordingControl.VTable, self.vtable).get_StartTime(@ptrCast(*const IMSVidStreamBufferRecordingControl, self), rtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_put_StartTime(self: *const T, rtStart: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferRecordingControl.VTable, self.vtable).put_StartTime(@ptrCast(*const IMSVidStreamBufferRecordingControl, self), rtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_StopTime(self: *const T, rtStop: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferRecordingControl.VTable, self.vtable).get_StopTime(@ptrCast(*const IMSVidStreamBufferRecordingControl, self), rtStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_put_StopTime(self: *const T, rtStop: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferRecordingControl.VTable, self.vtable).put_StopTime(@ptrCast(*const IMSVidStreamBufferRecordingControl, self), rtStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_RecordingStopped(self: *const T, phResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferRecordingControl.VTable, self.vtable).get_RecordingStopped(@ptrCast(*const IMSVidStreamBufferRecordingControl, self), phResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_RecordingStarted(self: *const T, phResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferRecordingControl.VTable, self.vtable).get_RecordingStarted(@ptrCast(*const IMSVidStreamBufferRecordingControl, self), phResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_RecordingType(self: *const T, dwType: ?*RecordingType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferRecordingControl.VTable, self.vtable).get_RecordingType(@ptrCast(*const IMSVidStreamBufferRecordingControl, self), dwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_RecordingAttribute(self: *const T, pRecordingAttribute: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferRecordingControl.VTable, self.vtable).get_RecordingAttribute(@ptrCast(*const IMSVidStreamBufferRecordingControl, self), pRecordingAttribute);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidStreamBufferSink_Value = @import("../zig.zig").Guid.initString("159dbb45-cd1b-4dab-83ea-5cb1f4f21d07");
pub const IID_IMSVidStreamBufferSink = &IID_IMSVidStreamBufferSink_Value;
pub const IMSVidStreamBufferSink = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContentRecorder: fn(
            self: *const IMSVidStreamBufferSink,
            pszFilename: ?BSTR,
            pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReferenceRecorder: fn(
            self: *const IMSVidStreamBufferSink,
            pszFilename: ?BSTR,
            pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SinkName: fn(
            self: *const IMSVidStreamBufferSink,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SinkName: fn(
            self: *const IMSVidStreamBufferSink,
            Name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NameSetLock: fn(
            self: *const IMSVidStreamBufferSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SBESink: fn(
            self: *const IMSVidStreamBufferSink,
            sbeConfig: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_get_ContentRecorder(self: *const T, pszFilename: ?BSTR, pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink.VTable, self.vtable).get_ContentRecorder(@ptrCast(*const IMSVidStreamBufferSink, self), pszFilename, pRecordingIUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_get_ReferenceRecorder(self: *const T, pszFilename: ?BSTR, pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink.VTable, self.vtable).get_ReferenceRecorder(@ptrCast(*const IMSVidStreamBufferSink, self), pszFilename, pRecordingIUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_get_SinkName(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink.VTable, self.vtable).get_SinkName(@ptrCast(*const IMSVidStreamBufferSink, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_put_SinkName(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink.VTable, self.vtable).put_SinkName(@ptrCast(*const IMSVidStreamBufferSink, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_NameSetLock(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink.VTable, self.vtable).NameSetLock(@ptrCast(*const IMSVidStreamBufferSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_get_SBESink(self: *const T, sbeConfig: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink.VTable, self.vtable).get_SBESink(@ptrCast(*const IMSVidStreamBufferSink, self), sbeConfig);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSink2_Value = @import("../zig.zig").Guid.initString("2ca9fc63-c131-4e5a-955a-544a47c67146");
pub const IID_IMSVidStreamBufferSink2 = &IID_IMSVidStreamBufferSink2_Value;
pub const IMSVidStreamBufferSink2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSink.VTable,
        UnlockProfile: fn(
            self: *const IMSVidStreamBufferSink2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink2_UnlockProfile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink2.VTable, self.vtable).UnlockProfile(@ptrCast(*const IMSVidStreamBufferSink2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSink3_Value = @import("../zig.zig").Guid.initString("4f8721d7-7d59-4d8b-99f5-a77775586bd5");
pub const IID_IMSVidStreamBufferSink3 = &IID_IMSVidStreamBufferSink3_Value;
pub const IMSVidStreamBufferSink3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSink2.VTable,
        SetMinSeek: fn(
            self: *const IMSVidStreamBufferSink3,
            pdwMin: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioCounter: fn(
            self: *const IMSVidStreamBufferSink3,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoCounter: fn(
            self: *const IMSVidStreamBufferSink3,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCCounter: fn(
            self: *const IMSVidStreamBufferSink3,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WSTCounter: fn(
            self: *const IMSVidStreamBufferSink3,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            szCLSID: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            pszCLSID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__AudioAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            guid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__AudioAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            pGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VideoAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            szCLSID: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            pszCLSID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__VideoAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            guid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__VideoAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            pGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DataAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            szCLSID: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            pszCLSID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__DataAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            guid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__DataAnalysisFilter: fn(
            self: *const IMSVidStreamBufferSink3,
            pGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LicenseErrorCode: fn(
            self: *const IMSVidStreamBufferSink3,
            hres: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSink2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_SetMinSeek(self: *const T, pdwMin: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).SetMinSeek(@ptrCast(*const IMSVidStreamBufferSink3, self), pdwMin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_AudioCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get_AudioCounter(@ptrCast(*const IMSVidStreamBufferSink3, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_VideoCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get_VideoCounter(@ptrCast(*const IMSVidStreamBufferSink3, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_CCCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get_CCCounter(@ptrCast(*const IMSVidStreamBufferSink3, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_WSTCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get_WSTCounter(@ptrCast(*const IMSVidStreamBufferSink3, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put_AudioAnalysisFilter(self: *const T, szCLSID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).put_AudioAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), szCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_AudioAnalysisFilter(self: *const T, pszCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get_AudioAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), pszCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put__AudioAnalysisFilter(self: *const T, guid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).put__AudioAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get__AudioAnalysisFilter(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get__AudioAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put_VideoAnalysisFilter(self: *const T, szCLSID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).put_VideoAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), szCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_VideoAnalysisFilter(self: *const T, pszCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get_VideoAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), pszCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put__VideoAnalysisFilter(self: *const T, guid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).put__VideoAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get__VideoAnalysisFilter(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get__VideoAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put_DataAnalysisFilter(self: *const T, szCLSID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).put_DataAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), szCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_DataAnalysisFilter(self: *const T, pszCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get_DataAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), pszCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put__DataAnalysisFilter(self: *const T, guid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).put__DataAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get__DataAnalysisFilter(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get__DataAnalysisFilter(@ptrCast(*const IMSVidStreamBufferSink3, self), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_LicenseErrorCode(self: *const T, hres: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSink3.VTable, self.vtable).get_LicenseErrorCode(@ptrCast(*const IMSVidStreamBufferSink3, self), hres);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSinkEvent_Value = @import("../zig.zig").Guid.initString("f798a36b-b05b-4bbe-9703-eaea7d61cd51");
pub const IID_IMSVidStreamBufferSinkEvent = &IID_IMSVidStreamBufferSinkEvent_Value;
pub const IMSVidStreamBufferSinkEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        CertificateFailure: fn(
            self: *const IMSVidStreamBufferSinkEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CertificateSuccess: fn(
            self: *const IMSVidStreamBufferSinkEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteFailure: fn(
            self: *const IMSVidStreamBufferSinkEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent_CertificateFailure(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSinkEvent.VTable, self.vtable).CertificateFailure(@ptrCast(*const IMSVidStreamBufferSinkEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent_CertificateSuccess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSinkEvent.VTable, self.vtable).CertificateSuccess(@ptrCast(*const IMSVidStreamBufferSinkEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent_WriteFailure(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSinkEvent.VTable, self.vtable).WriteFailure(@ptrCast(*const IMSVidStreamBufferSinkEvent, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSinkEvent2_Value = @import("../zig.zig").Guid.initString("3d7a5166-72d7-484b-a06f-286187b80ca1");
pub const IID_IMSVidStreamBufferSinkEvent2 = &IID_IMSVidStreamBufferSinkEvent2_Value;
pub const IMSVidStreamBufferSinkEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSinkEvent.VTable,
        EncryptionOn: fn(
            self: *const IMSVidStreamBufferSinkEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncryptionOff: fn(
            self: *const IMSVidStreamBufferSinkEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSinkEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent2_EncryptionOn(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSinkEvent2.VTable, self.vtable).EncryptionOn(@ptrCast(*const IMSVidStreamBufferSinkEvent2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent2_EncryptionOff(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSinkEvent2.VTable, self.vtable).EncryptionOff(@ptrCast(*const IMSVidStreamBufferSinkEvent2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSinkEvent3_Value = @import("../zig.zig").Guid.initString("735ad8d5-c259-48e9-81e7-d27953665b23");
pub const IID_IMSVidStreamBufferSinkEvent3 = &IID_IMSVidStreamBufferSinkEvent3_Value;
pub const IMSVidStreamBufferSinkEvent3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSinkEvent2.VTable,
        LicenseChange: fn(
            self: *const IMSVidStreamBufferSinkEvent3,
            dwProt: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSinkEvent2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent3_LicenseChange(self: *const T, dwProt: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSinkEvent3.VTable, self.vtable).LicenseChange(@ptrCast(*const IMSVidStreamBufferSinkEvent3, self), dwProt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidStreamBufferSinkEvent4_Value = @import("../zig.zig").Guid.initString("1b01dcb0-daf0-412c-a5d1-590c7f62e2b8");
pub const IID_IMSVidStreamBufferSinkEvent4 = &IID_IMSVidStreamBufferSinkEvent4_Value;
pub const IMSVidStreamBufferSinkEvent4 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSinkEvent3.VTable,
        WriteFailureClear: fn(
            self: *const IMSVidStreamBufferSinkEvent4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSinkEvent3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent4_WriteFailureClear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSinkEvent4.VTable, self.vtable).WriteFailureClear(@ptrCast(*const IMSVidStreamBufferSinkEvent4, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidStreamBufferSource_Value = @import("../zig.zig").Guid.initString("eb0c8cf9-6950-4772-87b1-47d11cf3a02f");
pub const IID_IMSVidStreamBufferSource = &IID_IMSVidStreamBufferSource_Value;
pub const IMSVidStreamBufferSource = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlayback.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Start: fn(
            self: *const IMSVidStreamBufferSource,
            lStart: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingAttribute: fn(
            self: *const IMSVidStreamBufferSource,
            pRecordingAttribute: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CurrentRatings: fn(
            self: *const IMSVidStreamBufferSource,
            pEnSystem: ?*EnTvRat_System,
            pEnRating: ?*EnTvRat_GenericLevel,
            pBfEnAttr: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MaxRatingsLevel: fn(
            self: *const IMSVidStreamBufferSource,
            enSystem: EnTvRat_System,
            enRating: EnTvRat_GenericLevel,
            lbfEnAttr: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnrated: fn(
            self: *const IMSVidStreamBufferSource,
            bBlock: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UnratedDelay: fn(
            self: *const IMSVidStreamBufferSource,
            dwDelay: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SBESource: fn(
            self: *const IMSVidStreamBufferSource,
            sbeFilter: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFilePlayback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_get_Start(self: *const T, lStart: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource.VTable, self.vtable).get_Start(@ptrCast(*const IMSVidStreamBufferSource, self), lStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_get_RecordingAttribute(self: *const T, pRecordingAttribute: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource.VTable, self.vtable).get_RecordingAttribute(@ptrCast(*const IMSVidStreamBufferSource, self), pRecordingAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_CurrentRatings(self: *const T, pEnSystem: ?*EnTvRat_System, pEnRating: ?*EnTvRat_GenericLevel, pBfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource.VTable, self.vtable).CurrentRatings(@ptrCast(*const IMSVidStreamBufferSource, self), pEnSystem, pEnRating, pBfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_MaxRatingsLevel(self: *const T, enSystem: EnTvRat_System, enRating: EnTvRat_GenericLevel, lbfEnAttr: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource.VTable, self.vtable).MaxRatingsLevel(@ptrCast(*const IMSVidStreamBufferSource, self), enSystem, enRating, lbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_put_BlockUnrated(self: *const T, bBlock: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource.VTable, self.vtable).put_BlockUnrated(@ptrCast(*const IMSVidStreamBufferSource, self), bBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_put_UnratedDelay(self: *const T, dwDelay: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource.VTable, self.vtable).put_UnratedDelay(@ptrCast(*const IMSVidStreamBufferSource, self), dwDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_get_SBESource(self: *const T, sbeFilter: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource.VTable, self.vtable).get_SBESource(@ptrCast(*const IMSVidStreamBufferSource, self), sbeFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSource2_Value = @import("../zig.zig").Guid.initString("e4ba9059-b1ce-40d8-b9a0-d4ea4a9989d3");
pub const IID_IMSVidStreamBufferSource2 = &IID_IMSVidStreamBufferSource2_Value;
pub const IMSVidStreamBufferSource2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSource.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RateEx: fn(
            self: *const IMSVidStreamBufferSource2,
            dwRate: f64,
            dwFramesPerSecond: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioCounter: fn(
            self: *const IMSVidStreamBufferSource2,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoCounter: fn(
            self: *const IMSVidStreamBufferSource2,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCCounter: fn(
            self: *const IMSVidStreamBufferSource2,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WSTCounter: fn(
            self: *const IMSVidStreamBufferSource2,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_put_RateEx(self: *const T, dwRate: f64, dwFramesPerSecond: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource2.VTable, self.vtable).put_RateEx(@ptrCast(*const IMSVidStreamBufferSource2, self), dwRate, dwFramesPerSecond);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_get_AudioCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource2.VTable, self.vtable).get_AudioCounter(@ptrCast(*const IMSVidStreamBufferSource2, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_get_VideoCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource2.VTable, self.vtable).get_VideoCounter(@ptrCast(*const IMSVidStreamBufferSource2, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_get_CCCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource2.VTable, self.vtable).get_CCCounter(@ptrCast(*const IMSVidStreamBufferSource2, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_get_WSTCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSource2.VTable, self.vtable).get_WSTCounter(@ptrCast(*const IMSVidStreamBufferSource2, self), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSourceEvent_Value = @import("../zig.zig").Guid.initString("50ce8a7d-9c28-4da8-9042-cdfa7116f979");
pub const IID_IMSVidStreamBufferSourceEvent = &IID_IMSVidStreamBufferSourceEvent_Value;
pub const IMSVidStreamBufferSourceEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlaybackEvent.VTable,
        CertificateFailure: fn(
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CertificateSuccess: fn(
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RatingsBlocked: fn(
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RatingsUnblocked: fn(
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RatingsChanged: fn(
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TimeHole: fn(
            self: *const IMSVidStreamBufferSourceEvent,
            StreamOffsetMS: i32,
            SizeMS: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StaleDataRead: fn(
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentBecomingStale: fn(
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StaleFileDeleted: fn(
            self: *const IMSVidStreamBufferSourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFilePlaybackEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_CertificateFailure(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent.VTable, self.vtable).CertificateFailure(@ptrCast(*const IMSVidStreamBufferSourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_CertificateSuccess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent.VTable, self.vtable).CertificateSuccess(@ptrCast(*const IMSVidStreamBufferSourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_RatingsBlocked(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent.VTable, self.vtable).RatingsBlocked(@ptrCast(*const IMSVidStreamBufferSourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_RatingsUnblocked(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent.VTable, self.vtable).RatingsUnblocked(@ptrCast(*const IMSVidStreamBufferSourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_RatingsChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent.VTable, self.vtable).RatingsChanged(@ptrCast(*const IMSVidStreamBufferSourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_TimeHole(self: *const T, StreamOffsetMS: i32, SizeMS: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent.VTable, self.vtable).TimeHole(@ptrCast(*const IMSVidStreamBufferSourceEvent, self), StreamOffsetMS, SizeMS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_StaleDataRead(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent.VTable, self.vtable).StaleDataRead(@ptrCast(*const IMSVidStreamBufferSourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_ContentBecomingStale(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent.VTable, self.vtable).ContentBecomingStale(@ptrCast(*const IMSVidStreamBufferSourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_StaleFileDeleted(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent.VTable, self.vtable).StaleFileDeleted(@ptrCast(*const IMSVidStreamBufferSourceEvent, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSourceEvent2_Value = @import("../zig.zig").Guid.initString("7aef50ce-8e22-4ba8-bc06-a92a458b4ef2");
pub const IID_IMSVidStreamBufferSourceEvent2 = &IID_IMSVidStreamBufferSourceEvent2_Value;
pub const IMSVidStreamBufferSourceEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSourceEvent.VTable,
        RateChange: fn(
            self: *const IMSVidStreamBufferSourceEvent2,
            qwNewRate: f64,
            qwOldRate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSourceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent2_RateChange(self: *const T, qwNewRate: f64, qwOldRate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent2.VTable, self.vtable).RateChange(@ptrCast(*const IMSVidStreamBufferSourceEvent2, self), qwNewRate, qwOldRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSourceEvent3_Value = @import("../zig.zig").Guid.initString("ceabd6ab-9b90-4570-adf1-3ce76e00a763");
pub const IID_IMSVidStreamBufferSourceEvent3 = &IID_IMSVidStreamBufferSourceEvent3_Value;
pub const IMSVidStreamBufferSourceEvent3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSourceEvent2.VTable,
        BroadcastEvent: fn(
            self: *const IMSVidStreamBufferSourceEvent3,
            Guid: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BroadcastEventEx: fn(
            self: *const IMSVidStreamBufferSourceEvent3,
            Guid: ?BSTR,
            Param1: u32,
            Param2: u32,
            Param3: u32,
            Param4: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        COPPBlocked: fn(
            self: *const IMSVidStreamBufferSourceEvent3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        COPPUnblocked: fn(
            self: *const IMSVidStreamBufferSourceEvent3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentPrimarilyAudio: fn(
            self: *const IMSVidStreamBufferSourceEvent3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSourceEvent2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_BroadcastEvent(self: *const T, _param_Guid: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent3.VTable, self.vtable).BroadcastEvent(@ptrCast(*const IMSVidStreamBufferSourceEvent3, self), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_BroadcastEventEx(self: *const T, _param_Guid: ?BSTR, Param1: u32, Param2: u32, Param3: u32, Param4: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent3.VTable, self.vtable).BroadcastEventEx(@ptrCast(*const IMSVidStreamBufferSourceEvent3, self), _param_Guid, Param1, Param2, Param3, Param4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_COPPBlocked(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent3.VTable, self.vtable).COPPBlocked(@ptrCast(*const IMSVidStreamBufferSourceEvent3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_COPPUnblocked(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent3.VTable, self.vtable).COPPUnblocked(@ptrCast(*const IMSVidStreamBufferSourceEvent3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_ContentPrimarilyAudio(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferSourceEvent3.VTable, self.vtable).ContentPrimarilyAudio(@ptrCast(*const IMSVidStreamBufferSourceEvent3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidStreamBufferV2SourceEvent_Value = @import("../zig.zig").Guid.initString("49c771f9-41b2-4cf7-9f9a-a313a8f6027e");
pub const IID_IMSVidStreamBufferV2SourceEvent = &IID_IMSVidStreamBufferV2SourceEvent_Value;
pub const IMSVidStreamBufferV2SourceEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlaybackEvent.VTable,
        RatingsChanged: fn(
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TimeHole: fn(
            self: *const IMSVidStreamBufferV2SourceEvent,
            StreamOffsetMS: i32,
            SizeMS: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StaleDataRead: fn(
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentBecomingStale: fn(
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StaleFileDeleted: fn(
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RateChange: fn(
            self: *const IMSVidStreamBufferV2SourceEvent,
            qwNewRate: f64,
            qwOldRate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BroadcastEvent: fn(
            self: *const IMSVidStreamBufferV2SourceEvent,
            Guid: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BroadcastEventEx: fn(
            self: *const IMSVidStreamBufferV2SourceEvent,
            Guid: ?BSTR,
            Param1: u32,
            Param2: u32,
            Param3: u32,
            Param4: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentPrimarilyAudio: fn(
            self: *const IMSVidStreamBufferV2SourceEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFilePlaybackEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_RatingsChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferV2SourceEvent.VTable, self.vtable).RatingsChanged(@ptrCast(*const IMSVidStreamBufferV2SourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_TimeHole(self: *const T, StreamOffsetMS: i32, SizeMS: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferV2SourceEvent.VTable, self.vtable).TimeHole(@ptrCast(*const IMSVidStreamBufferV2SourceEvent, self), StreamOffsetMS, SizeMS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_StaleDataRead(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferV2SourceEvent.VTable, self.vtable).StaleDataRead(@ptrCast(*const IMSVidStreamBufferV2SourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_ContentBecomingStale(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferV2SourceEvent.VTable, self.vtable).ContentBecomingStale(@ptrCast(*const IMSVidStreamBufferV2SourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_StaleFileDeleted(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferV2SourceEvent.VTable, self.vtable).StaleFileDeleted(@ptrCast(*const IMSVidStreamBufferV2SourceEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_RateChange(self: *const T, qwNewRate: f64, qwOldRate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferV2SourceEvent.VTable, self.vtable).RateChange(@ptrCast(*const IMSVidStreamBufferV2SourceEvent, self), qwNewRate, qwOldRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_BroadcastEvent(self: *const T, _param_Guid: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferV2SourceEvent.VTable, self.vtable).BroadcastEvent(@ptrCast(*const IMSVidStreamBufferV2SourceEvent, self), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_BroadcastEventEx(self: *const T, _param_Guid: ?BSTR, Param1: u32, Param2: u32, Param3: u32, Param4: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferV2SourceEvent.VTable, self.vtable).BroadcastEventEx(@ptrCast(*const IMSVidStreamBufferV2SourceEvent, self), _param_Guid, Param1, Param2, Param3, Param4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_ContentPrimarilyAudio(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidStreamBufferV2SourceEvent.VTable, self.vtable).ContentPrimarilyAudio(@ptrCast(*const IMSVidStreamBufferV2SourceEvent, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoRenderer2_Value = @import("../zig.zig").Guid.initString("6bdd5c1e-2810-4159-94bc-05511ae8549b");
pub const IID_IMSVidVideoRenderer2 = &IID_IMSVidVideoRenderer2_Value;
pub const IMSVidVideoRenderer2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoRenderer.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator: fn(
            self: *const IMSVidVideoRenderer2,
            AllocPresent: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__Allocator: fn(
            self: *const IMSVidVideoRenderer2,
            AllocPresent: ?*?*IVMRSurfaceAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator_ID: fn(
            self: *const IMSVidVideoRenderer2,
            ID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllocator: fn(
            self: *const IMSVidVideoRenderer2,
            AllocPresent: ?*IUnknown,
            ID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _SetAllocator2: fn(
            self: *const IMSVidVideoRenderer2,
            AllocPresent: ?*IVMRSurfaceAllocator,
            ID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressEffects: fn(
            self: *const IMSVidVideoRenderer2,
            bSuppress: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressEffects: fn(
            self: *const IMSVidVideoRenderer2,
            bSuppress: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidVideoRenderer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_get_Allocator(self: *const T, AllocPresent: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer2.VTable, self.vtable).get_Allocator(@ptrCast(*const IMSVidVideoRenderer2, self), AllocPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_get__Allocator(self: *const T, AllocPresent: ?*?*IVMRSurfaceAllocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer2.VTable, self.vtable).get__Allocator(@ptrCast(*const IMSVidVideoRenderer2, self), AllocPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_get_Allocator_ID(self: *const T, ID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer2.VTable, self.vtable).get_Allocator_ID(@ptrCast(*const IMSVidVideoRenderer2, self), ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_SetAllocator(self: *const T, AllocPresent: ?*IUnknown, ID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer2.VTable, self.vtable).SetAllocator(@ptrCast(*const IMSVidVideoRenderer2, self), AllocPresent, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2__SetAllocator2(self: *const T, AllocPresent: ?*IVMRSurfaceAllocator, ID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer2.VTable, self.vtable)._SetAllocator2(@ptrCast(*const IMSVidVideoRenderer2, self), AllocPresent, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_put_SuppressEffects(self: *const T, bSuppress: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer2.VTable, self.vtable).put_SuppressEffects(@ptrCast(*const IMSVidVideoRenderer2, self), bSuppress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_get_SuppressEffects(self: *const T, bSuppress: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRenderer2.VTable, self.vtable).get_SuppressEffects(@ptrCast(*const IMSVidVideoRenderer2, self), bSuppress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVideoRendererEvent2_Value = @import("../zig.zig").Guid.initString("7145ed66-4730-4fdb-8a53-fde7508d3e5e");
pub const IID_IMSVidVideoRendererEvent2 = &IID_IMSVidVideoRendererEvent2_Value;
pub const IMSVidVideoRendererEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        OverlayUnavailable: fn(
            self: *const IMSVidVideoRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererEvent2_OverlayUnavailable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRendererEvent2.VTable, self.vtable).OverlayUnavailable(@ptrCast(*const IMSVidVideoRendererEvent2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVMR9_Value = @import("../zig.zig").Guid.initString("d58b0015-ebef-44bb-bbdd-3f3699d76ea1");
pub const IID_IMSVidVMR9 = &IID_IMSVidVMR9_Value;
pub const IMSVidVMR9 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoRenderer.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator_ID: fn(
            self: *const IMSVidVMR9,
            ID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllocator: fn(
            self: *const IMSVidVMR9,
            AllocPresent: ?*IUnknown,
            ID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressEffects: fn(
            self: *const IMSVidVMR9,
            bSuppress: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressEffects: fn(
            self: *const IMSVidVMR9,
            bSuppress: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator: fn(
            self: *const IMSVidVMR9,
            AllocPresent: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidVideoRenderer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_get_Allocator_ID(self: *const T, ID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVMR9.VTable, self.vtable).get_Allocator_ID(@ptrCast(*const IMSVidVMR9, self), ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_SetAllocator(self: *const T, AllocPresent: ?*IUnknown, ID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVMR9.VTable, self.vtable).SetAllocator(@ptrCast(*const IMSVidVMR9, self), AllocPresent, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_put_SuppressEffects(self: *const T, bSuppress: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVMR9.VTable, self.vtable).put_SuppressEffects(@ptrCast(*const IMSVidVMR9, self), bSuppress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_get_SuppressEffects(self: *const T, bSuppress: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVMR9.VTable, self.vtable).get_SuppressEffects(@ptrCast(*const IMSVidVMR9, self), bSuppress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_get_Allocator(self: *const T, AllocPresent: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVMR9.VTable, self.vtable).get_Allocator(@ptrCast(*const IMSVidVMR9, self), AllocPresent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMSVidEVR_Value = @import("../zig.zig").Guid.initString("15e496ae-82a8-4cf9-a6b6-c561dc60398f");
pub const IID_IMSVidEVR = &IID_IMSVidEVR_Value;
pub const IMSVidEVR = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoRenderer.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Presenter: fn(
            self: *const IMSVidEVR,
            ppAllocPresent: ?*?*IMFVideoPresenter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Presenter: fn(
            self: *const IMSVidEVR,
            pAllocPresent: ?*IMFVideoPresenter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressEffects: fn(
            self: *const IMSVidEVR,
            bSuppress: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressEffects: fn(
            self: *const IMSVidEVR,
            bSuppress: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidVideoRenderer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVR_get_Presenter(self: *const T, ppAllocPresent: ?*?*IMFVideoPresenter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidEVR.VTable, self.vtable).get_Presenter(@ptrCast(*const IMSVidEVR, self), ppAllocPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVR_put_Presenter(self: *const T, pAllocPresent: ?*IMFVideoPresenter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidEVR.VTable, self.vtable).put_Presenter(@ptrCast(*const IMSVidEVR, self), pAllocPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVR_put_SuppressEffects(self: *const T, bSuppress: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidEVR.VTable, self.vtable).put_SuppressEffects(@ptrCast(*const IMSVidEVR, self), bSuppress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVR_get_SuppressEffects(self: *const T, bSuppress: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidEVR.VTable, self.vtable).get_SuppressEffects(@ptrCast(*const IMSVidEVR, self), bSuppress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidEVREvent_Value = @import("../zig.zig").Guid.initString("349abb10-883c-4f22-8714-cecaeee45d62");
pub const IID_IMSVidEVREvent = &IID_IMSVidEVREvent_Value;
pub const IMSVidEVREvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        OnUserEvent: fn(
            self: *const IMSVidEVREvent,
            lEventCode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVREvent_OnUserEvent(self: *const T, lEventCode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidEVREvent.VTable, self.vtable).OnUserEvent(@ptrCast(*const IMSVidEVREvent, self), lEventCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidAudioRenderer_Value = @import("../zig.zig").Guid.initString("37b0353f-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidAudioRenderer = &IID_IMSVidAudioRenderer_Value;
pub const IMSVidAudioRenderer = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: fn(
            self: *const IMSVidAudioRenderer,
            lVol: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: fn(
            self: *const IMSVidAudioRenderer,
            lVol: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Balance: fn(
            self: *const IMSVidAudioRenderer,
            lBal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Balance: fn(
            self: *const IMSVidAudioRenderer,
            lBal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRenderer_put_Volume(self: *const T, lVol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRenderer.VTable, self.vtable).put_Volume(@ptrCast(*const IMSVidAudioRenderer, self), lVol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRenderer_get_Volume(self: *const T, lVol: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRenderer.VTable, self.vtable).get_Volume(@ptrCast(*const IMSVidAudioRenderer, self), lVol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRenderer_put_Balance(self: *const T, lBal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRenderer.VTable, self.vtable).put_Balance(@ptrCast(*const IMSVidAudioRenderer, self), lBal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRenderer_get_Balance(self: *const T, lBal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRenderer.VTable, self.vtable).get_Balance(@ptrCast(*const IMSVidAudioRenderer, self), lBal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidAudioRendererEvent_Value = @import("../zig.zig").Guid.initString("37b03541-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidAudioRendererEvent = &IID_IMSVidAudioRendererEvent_Value;
pub const IMSVidAudioRendererEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidAudioRendererEvent2_Value = @import("../zig.zig").Guid.initString("e3f55729-353b-4c43-a028-50f79aa9a907");
pub const IID_IMSVidAudioRendererEvent2 = &IID_IMSVidAudioRendererEvent2_Value;
pub const IMSVidAudioRendererEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidAudioRendererEvent.VTable,
        AVDecAudioDualMono: fn(
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVAudioSampleRate: fn(
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVAudioChannelConfig: fn(
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVAudioChannelCount: fn(
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVDecCommonMeanBitRate: fn(
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVDDSurroundMode: fn(
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVDecCommonInputFormat: fn(
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AVDecCommonOutputFormat: fn(
            self: *const IMSVidAudioRendererEvent2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidAudioRendererEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDecAudioDualMono(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererEvent2.VTable, self.vtable).AVDecAudioDualMono(@ptrCast(*const IMSVidAudioRendererEvent2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVAudioSampleRate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererEvent2.VTable, self.vtable).AVAudioSampleRate(@ptrCast(*const IMSVidAudioRendererEvent2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVAudioChannelConfig(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererEvent2.VTable, self.vtable).AVAudioChannelConfig(@ptrCast(*const IMSVidAudioRendererEvent2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVAudioChannelCount(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererEvent2.VTable, self.vtable).AVAudioChannelCount(@ptrCast(*const IMSVidAudioRendererEvent2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDecCommonMeanBitRate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererEvent2.VTable, self.vtable).AVDecCommonMeanBitRate(@ptrCast(*const IMSVidAudioRendererEvent2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDDSurroundMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererEvent2.VTable, self.vtable).AVDDSurroundMode(@ptrCast(*const IMSVidAudioRendererEvent2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDecCommonInputFormat(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererEvent2.VTable, self.vtable).AVDecCommonInputFormat(@ptrCast(*const IMSVidAudioRendererEvent2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDecCommonOutputFormat(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererEvent2.VTable, self.vtable).AVDecCommonOutputFormat(@ptrCast(*const IMSVidAudioRendererEvent2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidInputDevices_Value = @import("../zig.zig").Guid.initString("c5702cd1-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidInputDevices = &IID_IMSVidInputDevices_Value;
pub const IMSVidInputDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMSVidInputDevices,
            lCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMSVidInputDevices,
            pD: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMSVidInputDevices,
            v: VARIANT,
            pDB: ?*?*IMSVidInputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IMSVidInputDevices,
            pDB: ?*IMSVidInputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMSVidInputDevices,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidInputDevices.VTable, self.vtable).get_Count(@ptrCast(*const IMSVidInputDevices, self), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidInputDevices.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMSVidInputDevices, self), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidInputDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidInputDevices.VTable, self.vtable).get_Item(@ptrCast(*const IMSVidInputDevices, self), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_Add(self: *const T, pDB: ?*IMSVidInputDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidInputDevices.VTable, self.vtable).Add(@ptrCast(*const IMSVidInputDevices, self), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidInputDevices.VTable, self.vtable).Remove(@ptrCast(*const IMSVidInputDevices, self), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidOutputDevices_Value = @import("../zig.zig").Guid.initString("c5702cd2-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidOutputDevices = &IID_IMSVidOutputDevices_Value;
pub const IMSVidOutputDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMSVidOutputDevices,
            lCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMSVidOutputDevices,
            pD: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMSVidOutputDevices,
            v: VARIANT,
            pDB: ?*?*IMSVidOutputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IMSVidOutputDevices,
            pDB: ?*IMSVidOutputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMSVidOutputDevices,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidOutputDevices.VTable, self.vtable).get_Count(@ptrCast(*const IMSVidOutputDevices, self), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidOutputDevices.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMSVidOutputDevices, self), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidOutputDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidOutputDevices.VTable, self.vtable).get_Item(@ptrCast(*const IMSVidOutputDevices, self), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_Add(self: *const T, pDB: ?*IMSVidOutputDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidOutputDevices.VTable, self.vtable).Add(@ptrCast(*const IMSVidOutputDevices, self), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidOutputDevices.VTable, self.vtable).Remove(@ptrCast(*const IMSVidOutputDevices, self), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoRendererDevices_Value = @import("../zig.zig").Guid.initString("c5702cd3-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidVideoRendererDevices = &IID_IMSVidVideoRendererDevices_Value;
pub const IMSVidVideoRendererDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMSVidVideoRendererDevices,
            lCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMSVidVideoRendererDevices,
            pD: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMSVidVideoRendererDevices,
            v: VARIANT,
            pDB: ?*?*IMSVidVideoRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IMSVidVideoRendererDevices,
            pDB: ?*IMSVidVideoRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMSVidVideoRendererDevices,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRendererDevices.VTable, self.vtable).get_Count(@ptrCast(*const IMSVidVideoRendererDevices, self), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRendererDevices.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMSVidVideoRendererDevices, self), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidVideoRenderer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRendererDevices.VTable, self.vtable).get_Item(@ptrCast(*const IMSVidVideoRendererDevices, self), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_Add(self: *const T, pDB: ?*IMSVidVideoRenderer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRendererDevices.VTable, self.vtable).Add(@ptrCast(*const IMSVidVideoRendererDevices, self), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidVideoRendererDevices.VTable, self.vtable).Remove(@ptrCast(*const IMSVidVideoRendererDevices, self), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidAudioRendererDevices_Value = @import("../zig.zig").Guid.initString("c5702cd4-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidAudioRendererDevices = &IID_IMSVidAudioRendererDevices_Value;
pub const IMSVidAudioRendererDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMSVidAudioRendererDevices,
            lCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMSVidAudioRendererDevices,
            pD: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMSVidAudioRendererDevices,
            v: VARIANT,
            pDB: ?*?*IMSVidAudioRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IMSVidAudioRendererDevices,
            pDB: ?*IMSVidAudioRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMSVidAudioRendererDevices,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererDevices.VTable, self.vtable).get_Count(@ptrCast(*const IMSVidAudioRendererDevices, self), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererDevices.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMSVidAudioRendererDevices, self), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidAudioRenderer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererDevices.VTable, self.vtable).get_Item(@ptrCast(*const IMSVidAudioRendererDevices, self), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_Add(self: *const T, pDB: ?*IMSVidAudioRenderer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererDevices.VTable, self.vtable).Add(@ptrCast(*const IMSVidAudioRendererDevices, self), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidAudioRendererDevices.VTable, self.vtable).Remove(@ptrCast(*const IMSVidAudioRendererDevices, self), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidFeatures_Value = @import("../zig.zig").Guid.initString("c5702cd5-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidFeatures = &IID_IMSVidFeatures_Value;
pub const IMSVidFeatures = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMSVidFeatures,
            lCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMSVidFeatures,
            pD: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMSVidFeatures,
            v: VARIANT,
            pDB: ?*?*IMSVidFeature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IMSVidFeatures,
            pDB: ?*IMSVidFeature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMSVidFeatures,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidFeatures.VTable, self.vtable).get_Count(@ptrCast(*const IMSVidFeatures, self), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidFeatures.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMSVidFeatures, self), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidFeature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidFeatures.VTable, self.vtable).get_Item(@ptrCast(*const IMSVidFeatures, self), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_Add(self: *const T, pDB: ?*IMSVidFeature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidFeatures.VTable, self.vtable).Add(@ptrCast(*const IMSVidFeatures, self), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidFeatures.VTable, self.vtable).Remove(@ptrCast(*const IMSVidFeatures, self), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSVidAnalogTunerDevice_Value = @import("../zig.zig").Guid.initString("1c15d484-911d-11d2-b632-00c04f79498e");
pub const CLSID_MSVidAnalogTunerDevice = &CLSID_MSVidAnalogTunerDevice_Value;

const CLSID_MSVidBDATunerDevice_Value = @import("../zig.zig").Guid.initString("a2e3074e-6c3d-11d3-b653-00c04f79498e");
pub const CLSID_MSVidBDATunerDevice = &CLSID_MSVidBDATunerDevice_Value;

const CLSID_MSVidFilePlaybackDevice_Value = @import("../zig.zig").Guid.initString("37b0353c-a4c8-11d2-b634-00c04f79498e");
pub const CLSID_MSVidFilePlaybackDevice = &CLSID_MSVidFilePlaybackDevice_Value;

const CLSID_MSVidWebDVD_Value = @import("../zig.zig").Guid.initString("011b3619-fe63-4814-8a84-15a194ce9ce3");
pub const CLSID_MSVidWebDVD = &CLSID_MSVidWebDVD_Value;

const CLSID_MSVidWebDVDAdm_Value = @import("../zig.zig").Guid.initString("fa7c375b-66a7-4280-879d-fd459c84bb02");
pub const CLSID_MSVidWebDVDAdm = &CLSID_MSVidWebDVDAdm_Value;

const CLSID_MSVidVideoRenderer_Value = @import("../zig.zig").Guid.initString("37b03543-a4c8-11d2-b634-00c04f79498e");
pub const CLSID_MSVidVideoRenderer = &CLSID_MSVidVideoRenderer_Value;

const CLSID_MSVidVMR9_Value = @import("../zig.zig").Guid.initString("24dc3975-09bf-4231-8655-3ee71f43837d");
pub const CLSID_MSVidVMR9 = &CLSID_MSVidVMR9_Value;

const CLSID_MSVidEVR_Value = @import("../zig.zig").Guid.initString("c45268a2-fa81-4e19-b1e3-72edbd60aeda");
pub const CLSID_MSVidEVR = &CLSID_MSVidEVR_Value;

const CLSID_MSVidAudioRenderer_Value = @import("../zig.zig").Guid.initString("37b03544-a4c8-11d2-b634-00c04f79498e");
pub const CLSID_MSVidAudioRenderer = &CLSID_MSVidAudioRenderer_Value;

const CLSID_MSVidGenericSink_Value = @import("../zig.zig").Guid.initString("4a5869cf-929d-4040-ae03-fcafc5b9cd42");
pub const CLSID_MSVidGenericSink = &CLSID_MSVidGenericSink_Value;

const CLSID_MSVidStreamBufferSink_Value = @import("../zig.zig").Guid.initString("9e77aac4-35e5-42a1-bdc2-8f3ff399847c");
pub const CLSID_MSVidStreamBufferSink = &CLSID_MSVidStreamBufferSink_Value;

const CLSID_MSVidStreamBufferSource_Value = @import("../zig.zig").Guid.initString("ad8e510d-217f-409b-8076-29c5e73b98e8");
pub const CLSID_MSVidStreamBufferSource = &CLSID_MSVidStreamBufferSource_Value;

const CLSID_MSVidStreamBufferV2Source_Value = @import("../zig.zig").Guid.initString("fd351ea1-4173-4af4-821d-80d4ae979048");
pub const CLSID_MSVidStreamBufferV2Source = &CLSID_MSVidStreamBufferV2Source_Value;

const CLSID_MSVidEncoder_Value = @import("../zig.zig").Guid.initString("bb530c63-d9df-4b49-9439-63453962e598");
pub const CLSID_MSVidEncoder = &CLSID_MSVidEncoder_Value;

const CLSID_MSVidITVCapture_Value = @import("../zig.zig").Guid.initString("5740a302-ef0b-45ce-bf3b-4470a14a8980");
pub const CLSID_MSVidITVCapture = &CLSID_MSVidITVCapture_Value;

const CLSID_MSVidITVPlayback_Value = @import("../zig.zig").Guid.initString("9e797ed0-5253-4243-a9b7-bd06c58f8ef3");
pub const CLSID_MSVidITVPlayback = &CLSID_MSVidITVPlayback_Value;

const CLSID_MSVidCCA_Value = @import("../zig.zig").Guid.initString("86151827-e47b-45ee-8421-d10e6e690979");
pub const CLSID_MSVidCCA = &CLSID_MSVidCCA_Value;

const CLSID_MSVidClosedCaptioning_Value = @import("../zig.zig").Guid.initString("7f9cb14d-48e4-43b6-9346-1aebc39c64d3");
pub const CLSID_MSVidClosedCaptioning = &CLSID_MSVidClosedCaptioning_Value;

const CLSID_MSVidClosedCaptioningSI_Value = @import("../zig.zig").Guid.initString("92ed88bf-879e-448f-b6b6-a385bceb846d");
pub const CLSID_MSVidClosedCaptioningSI = &CLSID_MSVidClosedCaptioningSI_Value;

const CLSID_MSVidDataServices_Value = @import("../zig.zig").Guid.initString("334125c0-77e5-11d3-b653-00c04f79498e");
pub const CLSID_MSVidDataServices = &CLSID_MSVidDataServices_Value;

const CLSID_MSVidXDS_Value = @import("../zig.zig").Guid.initString("0149eedf-d08f-4142-8d73-d23903d21e90");
pub const CLSID_MSVidXDS = &CLSID_MSVidXDS_Value;

const CLSID_MSVidAnalogCaptureToDataServices_Value = @import("../zig.zig").Guid.initString("c5702cd6-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidAnalogCaptureToDataServices = &CLSID_MSVidAnalogCaptureToDataServices_Value;

const CLSID_MSVidDataServicesToStreamBufferSink_Value = @import("../zig.zig").Guid.initString("38f03426-e83b-4e68-b65b-dcae73304838");
pub const CLSID_MSVidDataServicesToStreamBufferSink = &CLSID_MSVidDataServicesToStreamBufferSink_Value;

const CLSID_MSVidDataServicesToXDS_Value = @import("../zig.zig").Guid.initString("0429ec6e-1144-4bed-b88b-2fb9899a4a3d");
pub const CLSID_MSVidDataServicesToXDS = &CLSID_MSVidDataServicesToXDS_Value;

const CLSID_MSVidAnalogCaptureToXDS_Value = @import("../zig.zig").Guid.initString("3540d440-5b1d-49cb-821a-e84b8cf065a7");
pub const CLSID_MSVidAnalogCaptureToXDS = &CLSID_MSVidAnalogCaptureToXDS_Value;

const CLSID_MSVidCtl_Value = @import("../zig.zig").Guid.initString("b0edf163-910a-11d2-b632-00c04f79498e");
pub const CLSID_MSVidCtl = &CLSID_MSVidCtl_Value;

const CLSID_MSVidInputDevices_Value = @import("../zig.zig").Guid.initString("c5702ccc-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidInputDevices = &CLSID_MSVidInputDevices_Value;

const CLSID_MSVidOutputDevices_Value = @import("../zig.zig").Guid.initString("c5702ccd-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidOutputDevices = &CLSID_MSVidOutputDevices_Value;

const CLSID_MSVidVideoRendererDevices_Value = @import("../zig.zig").Guid.initString("c5702cce-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidVideoRendererDevices = &CLSID_MSVidVideoRendererDevices_Value;

const CLSID_MSVidAudioRendererDevices_Value = @import("../zig.zig").Guid.initString("c5702ccf-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidAudioRendererDevices = &CLSID_MSVidAudioRendererDevices_Value;

const CLSID_MSVidFeatures_Value = @import("../zig.zig").Guid.initString("c5702cd0-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidFeatures = &CLSID_MSVidFeatures_Value;

const CLSID_MSVidGenericComposite_Value = @import("../zig.zig").Guid.initString("2764bce5-cc39-11d2-b639-00c04f79498e");
pub const CLSID_MSVidGenericComposite = &CLSID_MSVidGenericComposite_Value;

const CLSID_MSVidAnalogCaptureToOverlayMixer_Value = @import("../zig.zig").Guid.initString("e18af75a-08af-11d3-b64a-00c04f79498e");
pub const CLSID_MSVidAnalogCaptureToOverlayMixer = &CLSID_MSVidAnalogCaptureToOverlayMixer_Value;

const CLSID_MSVidWebDVDToVideoRenderer_Value = @import("../zig.zig").Guid.initString("267db0b3-55e3-4902-949b-df8f5cec0191");
pub const CLSID_MSVidWebDVDToVideoRenderer = &CLSID_MSVidWebDVDToVideoRenderer_Value;

const CLSID_MSVidWebDVDToAudioRenderer_Value = @import("../zig.zig").Guid.initString("8d04238e-9fd1-41c6-8de3-9e1ee309e935");
pub const CLSID_MSVidWebDVDToAudioRenderer = &CLSID_MSVidWebDVDToAudioRenderer_Value;

const CLSID_MSVidMPEG2DecoderToClosedCaptioning_Value = @import("../zig.zig").Guid.initString("6ad28ee1-5002-4e71-aaf7-bd077907b1a4");
pub const CLSID_MSVidMPEG2DecoderToClosedCaptioning = &CLSID_MSVidMPEG2DecoderToClosedCaptioning_Value;

const CLSID_MSVidAnalogCaptureToStreamBufferSink_Value = @import("../zig.zig").Guid.initString("9f50e8b1-9530-4ddc-825e-1af81d47aed6");
pub const CLSID_MSVidAnalogCaptureToStreamBufferSink = &CLSID_MSVidAnalogCaptureToStreamBufferSink_Value;

const CLSID_MSVidDigitalCaptureToStreamBufferSink_Value = @import("../zig.zig").Guid.initString("abe40035-27c3-4a2f-8153-6624471608af");
pub const CLSID_MSVidDigitalCaptureToStreamBufferSink = &CLSID_MSVidDigitalCaptureToStreamBufferSink_Value;

const CLSID_MSVidITVToStreamBufferSink_Value = @import("../zig.zig").Guid.initString("92b94828-1af7-4e6e-9ebf-770657f77af5");
pub const CLSID_MSVidITVToStreamBufferSink = &CLSID_MSVidITVToStreamBufferSink_Value;

const CLSID_MSVidCCAToStreamBufferSink_Value = @import("../zig.zig").Guid.initString("3ef76d68-8661-4843-8b8f-c37163d8c9ce");
pub const CLSID_MSVidCCAToStreamBufferSink = &CLSID_MSVidCCAToStreamBufferSink_Value;

const CLSID_MSVidEncoderToStreamBufferSink_Value = @import("../zig.zig").Guid.initString("a0b9b497-afbc-45ad-a8a6-9b077c40d4f2");
pub const CLSID_MSVidEncoderToStreamBufferSink = &CLSID_MSVidEncoderToStreamBufferSink_Value;

const CLSID_MSVidFilePlaybackToVideoRenderer_Value = @import("../zig.zig").Guid.initString("b401c5eb-8457-427f-84ea-a4d2363364b0");
pub const CLSID_MSVidFilePlaybackToVideoRenderer = &CLSID_MSVidFilePlaybackToVideoRenderer_Value;

const CLSID_MSVidFilePlaybackToAudioRenderer_Value = @import("../zig.zig").Guid.initString("cc23f537-18d4-4ece-93bd-207a84726979");
pub const CLSID_MSVidFilePlaybackToAudioRenderer = &CLSID_MSVidFilePlaybackToAudioRenderer_Value;

const CLSID_MSVidAnalogTVToEncoder_Value = @import("../zig.zig").Guid.initString("28953661-0231-41db-8986-21ff4388ee9b");
pub const CLSID_MSVidAnalogTVToEncoder = &CLSID_MSVidAnalogTVToEncoder_Value;

const CLSID_MSVidStreamBufferSourceToVideoRenderer_Value = @import("../zig.zig").Guid.initString("3c4708dc-b181-46a8-8da8-4ab0371758cd");
pub const CLSID_MSVidStreamBufferSourceToVideoRenderer = &CLSID_MSVidStreamBufferSourceToVideoRenderer_Value;

const CLSID_MSVidAnalogCaptureToCCA_Value = @import("../zig.zig").Guid.initString("942b7909-a28e-49a1-a207-34ebcbcb4b3b");
pub const CLSID_MSVidAnalogCaptureToCCA = &CLSID_MSVidAnalogCaptureToCCA_Value;

const CLSID_MSVidDigitalCaptureToCCA_Value = @import("../zig.zig").Guid.initString("73d14237-b9db-4efa-a6dd-84350421fb2f");
pub const CLSID_MSVidDigitalCaptureToCCA = &CLSID_MSVidDigitalCaptureToCCA_Value;

const CLSID_MSVidDigitalCaptureToITV_Value = @import("../zig.zig").Guid.initString("5d8e73f7-4989-4ac8-8a98-39ba0d325302");
pub const CLSID_MSVidDigitalCaptureToITV = &CLSID_MSVidDigitalCaptureToITV_Value;

const CLSID_MSVidSBESourceToITV_Value = @import("../zig.zig").Guid.initString("2291478c-5ee3-4bef-ab5d-b5ff2cf58352");
pub const CLSID_MSVidSBESourceToITV = &CLSID_MSVidSBESourceToITV_Value;

const CLSID_MSVidSBESourceToCC_Value = @import("../zig.zig").Guid.initString("9193a8f9-0cba-400e-aa97-eb4709164576");
pub const CLSID_MSVidSBESourceToCC = &CLSID_MSVidSBESourceToCC_Value;

const CLSID_MSVidSBESourceToGenericSink_Value = @import("../zig.zig").Guid.initString("991da7e5-953f-435b-be5e-b92a05edfc42");
pub const CLSID_MSVidSBESourceToGenericSink = &CLSID_MSVidSBESourceToGenericSink_Value;

const CLSID_MSVidCCToVMR_Value = @import("../zig.zig").Guid.initString("c4bf2784-ae00-41ba-9828-9c953bd3c54a");
pub const CLSID_MSVidCCToVMR = &CLSID_MSVidCCToVMR_Value;

const CLSID_MSVidCCToAR_Value = @import("../zig.zig").Guid.initString("d76334ca-d89e-4baf-86ab-ddb59372afc2");
pub const CLSID_MSVidCCToAR = &CLSID_MSVidCCToAR_Value;

const CLSID_MSEventBinder_Value = @import("../zig.zig").Guid.initString("577faa18-4518-445e-8f70-1473f8cf4ba4");
pub const CLSID_MSEventBinder = &CLSID_MSEventBinder_Value;

const CLSID_MSVidStreamBufferRecordingControl_Value = @import("../zig.zig").Guid.initString("caafdd83-cefc-4e3d-ba03-175f17a24f91");
pub const CLSID_MSVidStreamBufferRecordingControl = &CLSID_MSVidStreamBufferRecordingControl_Value;

const CLSID_MSVidRect_Value = @import("../zig.zig").Guid.initString("cb4276e6-7d5f-4cf1-9727-629c5e6db6ae");
pub const CLSID_MSVidRect = &CLSID_MSVidRect_Value;

const CLSID_MSVidDevice_Value = @import("../zig.zig").Guid.initString("6e40476f-9c49-4c3e-8bb9-8587958eff74");
pub const CLSID_MSVidDevice = &CLSID_MSVidDevice_Value;

const CLSID_MSVidDevice2_Value = @import("../zig.zig").Guid.initString("30997f7d-b3b5-4a1c-983a-1fe8098cb77d");
pub const CLSID_MSVidDevice2 = &CLSID_MSVidDevice2_Value;

const CLSID_MSVidInputDevice_Value = @import("../zig.zig").Guid.initString("ac1972f2-138a-4ca3-90da-ae51112eda28");
pub const CLSID_MSVidInputDevice = &CLSID_MSVidInputDevice_Value;

const CLSID_MSVidVideoInputDevice_Value = @import("../zig.zig").Guid.initString("95f4820b-bb3a-4e2d-bc64-5b817bc2c30e");
pub const CLSID_MSVidVideoInputDevice = &CLSID_MSVidVideoInputDevice_Value;

const CLSID_MSVidVideoPlaybackDevice_Value = @import("../zig.zig").Guid.initString("1990d634-1a5e-4071-a34a-53aaffce9f36");
pub const CLSID_MSVidVideoPlaybackDevice = &CLSID_MSVidVideoPlaybackDevice_Value;

const CLSID_MSVidFeature_Value = @import("../zig.zig").Guid.initString("7748530b-c08a-47ea-b24c-be8695ff405f");
pub const CLSID_MSVidFeature = &CLSID_MSVidFeature_Value;

const CLSID_MSVidOutput_Value = @import("../zig.zig").Guid.initString("87eb890d-03ad-4e9d-9866-376e5ec572ed");
pub const CLSID_MSVidOutput = &CLSID_MSVidOutput_Value;

pub const MSViddispidList = enum(i32) {
    Inputs = 0,
    Outputs = 1,
    _Inputs = 2,
    _Outputs = 3,
    VideoRenderers = 4,
    AudioRenderers = 5,
    Features = 6,
    Input = 7,
    Output = 8,
    VideoRenderer = 9,
    AudioRenderer = 10,
    SelectedFeatures = 11,
    View = 12,
    Build = 13,
    Pause = 14,
    Run = 15,
    Stop = 16,
    Decompose = 17,
    DisplaySize = 18,
    MaintainAspectRatio = 19,
    ColorKey = 20,
    StateChange = 21,
    getState = 22,
    unbind = 23,
    bind = 24,
    DisableVideo = 25,
    DisableAudio = 26,
    ViewNext = 27,
    ServiceP = 28,
};
pub const dispidInputs = MSViddispidList.Inputs;
pub const dispidOutputs = MSViddispidList.Outputs;
pub const dispid_Inputs = MSViddispidList._Inputs;
pub const dispid_Outputs = MSViddispidList._Outputs;
pub const dispidVideoRenderers = MSViddispidList.VideoRenderers;
pub const dispidAudioRenderers = MSViddispidList.AudioRenderers;
pub const dispidFeatures = MSViddispidList.Features;
pub const dispidInput = MSViddispidList.Input;
pub const dispidOutput = MSViddispidList.Output;
pub const dispidVideoRenderer = MSViddispidList.VideoRenderer;
pub const dispidAudioRenderer = MSViddispidList.AudioRenderer;
pub const dispidSelectedFeatures = MSViddispidList.SelectedFeatures;
pub const dispidView = MSViddispidList.View;
pub const dispidBuild = MSViddispidList.Build;
pub const dispidPause = MSViddispidList.Pause;
pub const dispidRun = MSViddispidList.Run;
pub const dispidStop = MSViddispidList.Stop;
pub const dispidDecompose = MSViddispidList.Decompose;
pub const dispidDisplaySize = MSViddispidList.DisplaySize;
pub const dispidMaintainAspectRatio = MSViddispidList.MaintainAspectRatio;
pub const dispidColorKey = MSViddispidList.ColorKey;
pub const dispidStateChange = MSViddispidList.StateChange;
pub const dispidgetState = MSViddispidList.getState;
pub const dispidunbind = MSViddispidList.unbind;
pub const dispidbind = MSViddispidList.bind;
pub const dispidDisableVideo = MSViddispidList.DisableVideo;
pub const dispidDisableAudio = MSViddispidList.DisableAudio;
pub const dispidViewNext = MSViddispidList.ViewNext;
pub const dispidServiceP = MSViddispidList.ServiceP;

pub const DisplaySizeList = enum(i32) {
    DefaultSize = 0,
    // SourceSize = 0, this enum value conflicts with DefaultSize
    HalfSourceSize = 1,
    DoubleSourceSize = 2,
    FullScreen = 3,
    HalfScreen = 4,
    QuarterScreen = 5,
    SixteenthScreen = 6,
};
pub const dslDefaultSize = DisplaySizeList.DefaultSize;
pub const dslSourceSize = DisplaySizeList.DefaultSize;
pub const dslHalfSourceSize = DisplaySizeList.HalfSourceSize;
pub const dslDoubleSourceSize = DisplaySizeList.DoubleSourceSize;
pub const dslFullScreen = DisplaySizeList.FullScreen;
pub const dslHalfScreen = DisplaySizeList.HalfScreen;
pub const dslQuarterScreen = DisplaySizeList.QuarterScreen;
pub const dslSixteenthScreen = DisplaySizeList.SixteenthScreen;

pub const MSVidCtlStateList = enum(i32) {
    UNBUILT = -1,
    STOP = 0,
    PAUSE = 1,
    PLAY = 2,
};
pub const STATE_UNBUILT = MSVidCtlStateList.UNBUILT;
pub const STATE_STOP = MSVidCtlStateList.STOP;
pub const STATE_PAUSE = MSVidCtlStateList.PAUSE;
pub const STATE_PLAY = MSVidCtlStateList.PLAY;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidCtl_Value = @import("../zig.zig").Guid.initString("b0edf162-910a-11d2-b632-00c04f79498e");
pub const IID_IMSVidCtl = &IID_IMSVidCtl_Value;
pub const IMSVidCtl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoSize: fn(
            self: *const IMSVidCtl,
            pbool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoSize: fn(
            self: *const IMSVidCtl,
            vbool: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackColor: fn(
            self: *const IMSVidCtl,
            backcolor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BackColor: fn(
            self: *const IMSVidCtl,
            backcolor: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const IMSVidCtl,
            pbool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const IMSVidCtl,
            vbool: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TabStop: fn(
            self: *const IMSVidCtl,
            pbool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TabStop: fn(
            self: *const IMSVidCtl,
            vbool: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Window: fn(
            self: *const IMSVidCtl,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplaySize: fn(
            self: *const IMSVidCtl,
            CurrentValue: ?*DisplaySizeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplaySize: fn(
            self: *const IMSVidCtl,
            NewValue: DisplaySizeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaintainAspectRatio: fn(
            self: *const IMSVidCtl,
            CurrentValue: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaintainAspectRatio: fn(
            self: *const IMSVidCtl,
            NewValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColorKey: fn(
            self: *const IMSVidCtl,
            CurrentValue: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ColorKey: fn(
            self: *const IMSVidCtl,
            NewValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputsAvailable: fn(
            self: *const IMSVidCtl,
            CategoryGuid: ?BSTR,
            pVal: ?*?*IMSVidInputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputsAvailable: fn(
            self: *const IMSVidCtl,
            CategoryGuid: ?BSTR,
            pVal: ?*?*IMSVidOutputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__InputsAvailable: fn(
            self: *const IMSVidCtl,
            CategoryGuid: ?*const Guid,
            pVal: ?*?*IMSVidInputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__OutputsAvailable: fn(
            self: *const IMSVidCtl,
            CategoryGuid: ?*const Guid,
            pVal: ?*?*IMSVidOutputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoRenderersAvailable: fn(
            self: *const IMSVidCtl,
            pVal: ?*?*IMSVidVideoRendererDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioRenderersAvailable: fn(
            self: *const IMSVidCtl,
            pVal: ?*?*IMSVidAudioRendererDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FeaturesAvailable: fn(
            self: *const IMSVidCtl,
            pVal: ?*?*IMSVidFeatures,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*?*IMSVidInputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*IMSVidInputDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputsActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*?*IMSVidOutputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OutputsActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*IMSVidOutputDevices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoRendererActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*?*IMSVidVideoRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VideoRendererActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*IMSVidVideoRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioRendererActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*?*IMSVidAudioRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioRendererActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*IMSVidAudioRenderer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FeaturesActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*?*IMSVidFeatures,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FeaturesActive: fn(
            self: *const IMSVidCtl,
            pVal: ?*IMSVidFeatures,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: fn(
            self: *const IMSVidCtl,
            lState: ?*MSVidCtlStateList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        View: fn(
            self: *const IMSVidCtl,
            v: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Build: fn(
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Decompose: fn(
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableVideo: fn(
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableAudio: fn(
            self: *const IMSVidCtl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ViewNext: fn(
            self: *const IMSVidCtl,
            v: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_AutoSize(self: *const T, pbool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_AutoSize(@ptrCast(*const IMSVidCtl, self), pbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_AutoSize(self: *const T, vbool: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_AutoSize(@ptrCast(*const IMSVidCtl, self), vbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_BackColor(self: *const T, backcolor: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_BackColor(@ptrCast(*const IMSVidCtl, self), backcolor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_BackColor(self: *const T, backcolor: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_BackColor(@ptrCast(*const IMSVidCtl, self), backcolor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_Enabled(self: *const T, pbool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_Enabled(@ptrCast(*const IMSVidCtl, self), pbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_Enabled(self: *const T, vbool: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_Enabled(@ptrCast(*const IMSVidCtl, self), vbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_TabStop(self: *const T, pbool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_TabStop(@ptrCast(*const IMSVidCtl, self), pbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_TabStop(self: *const T, vbool: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_TabStop(@ptrCast(*const IMSVidCtl, self), vbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_Window(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_Window(@ptrCast(*const IMSVidCtl, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).Refresh(@ptrCast(*const IMSVidCtl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_DisplaySize(self: *const T, CurrentValue: ?*DisplaySizeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_DisplaySize(@ptrCast(*const IMSVidCtl, self), CurrentValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_DisplaySize(self: *const T, NewValue: DisplaySizeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_DisplaySize(@ptrCast(*const IMSVidCtl, self), NewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_MaintainAspectRatio(self: *const T, CurrentValue: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_MaintainAspectRatio(@ptrCast(*const IMSVidCtl, self), CurrentValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_MaintainAspectRatio(self: *const T, NewValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_MaintainAspectRatio(@ptrCast(*const IMSVidCtl, self), NewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_ColorKey(self: *const T, CurrentValue: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_ColorKey(@ptrCast(*const IMSVidCtl, self), CurrentValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_ColorKey(self: *const T, NewValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_ColorKey(@ptrCast(*const IMSVidCtl, self), NewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_InputsAvailable(self: *const T, CategoryGuid: ?BSTR, pVal: ?*?*IMSVidInputDevices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_InputsAvailable(@ptrCast(*const IMSVidCtl, self), CategoryGuid, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_OutputsAvailable(self: *const T, CategoryGuid: ?BSTR, pVal: ?*?*IMSVidOutputDevices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_OutputsAvailable(@ptrCast(*const IMSVidCtl, self), CategoryGuid, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get__InputsAvailable(self: *const T, CategoryGuid: ?*const Guid, pVal: ?*?*IMSVidInputDevices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get__InputsAvailable(@ptrCast(*const IMSVidCtl, self), CategoryGuid, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get__OutputsAvailable(self: *const T, CategoryGuid: ?*const Guid, pVal: ?*?*IMSVidOutputDevices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get__OutputsAvailable(@ptrCast(*const IMSVidCtl, self), CategoryGuid, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_VideoRenderersAvailable(self: *const T, pVal: ?*?*IMSVidVideoRendererDevices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_VideoRenderersAvailable(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_AudioRenderersAvailable(self: *const T, pVal: ?*?*IMSVidAudioRendererDevices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_AudioRenderersAvailable(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_FeaturesAvailable(self: *const T, pVal: ?*?*IMSVidFeatures) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_FeaturesAvailable(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_InputActive(self: *const T, pVal: ?*?*IMSVidInputDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_InputActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_InputActive(self: *const T, pVal: ?*IMSVidInputDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_InputActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_OutputsActive(self: *const T, pVal: ?*?*IMSVidOutputDevices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_OutputsActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_OutputsActive(self: *const T, pVal: ?*IMSVidOutputDevices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_OutputsActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_VideoRendererActive(self: *const T, pVal: ?*?*IMSVidVideoRenderer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_VideoRendererActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_VideoRendererActive(self: *const T, pVal: ?*IMSVidVideoRenderer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_VideoRendererActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_AudioRendererActive(self: *const T, pVal: ?*?*IMSVidAudioRenderer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_AudioRendererActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_AudioRendererActive(self: *const T, pVal: ?*IMSVidAudioRenderer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_AudioRendererActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_FeaturesActive(self: *const T, pVal: ?*?*IMSVidFeatures) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_FeaturesActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_FeaturesActive(self: *const T, pVal: ?*IMSVidFeatures) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).put_FeaturesActive(@ptrCast(*const IMSVidCtl, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_State(self: *const T, lState: ?*MSVidCtlStateList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).get_State(@ptrCast(*const IMSVidCtl, self), lState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_View(self: *const T, v: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).View(@ptrCast(*const IMSVidCtl, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Build(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).Build(@ptrCast(*const IMSVidCtl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).Pause(@ptrCast(*const IMSVidCtl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Run(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).Run(@ptrCast(*const IMSVidCtl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).Stop(@ptrCast(*const IMSVidCtl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Decompose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).Decompose(@ptrCast(*const IMSVidCtl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_DisableVideo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).DisableVideo(@ptrCast(*const IMSVidCtl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_DisableAudio(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).DisableAudio(@ptrCast(*const IMSVidCtl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_ViewNext(self: *const T, v: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSVidCtl.VTable, self.vtable).ViewNext(@ptrCast(*const IMSVidCtl, self), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSEventBinder_Value = @import("../zig.zig").Guid.initString("c3a9f406-2222-436d-86d5-ba3229279efb");
pub const IID_IMSEventBinder = &IID_IMSEventBinder_Value;
pub const IMSEventBinder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Bind: fn(
            self: *const IMSEventBinder,
            pEventObject: ?*IDispatch,
            EventName: ?BSTR,
            EventHandler: ?BSTR,
            CancelID: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unbind: fn(
            self: *const IMSEventBinder,
            CancelCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSEventBinder_Bind(self: *const T, pEventObject: ?*IDispatch, EventName: ?BSTR, EventHandler: ?BSTR, CancelID: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSEventBinder.VTable, self.vtable).Bind(@ptrCast(*const IMSEventBinder, self), pEventObject, EventName, EventHandler, CancelID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSEventBinder_Unbind(self: *const T, CancelCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSEventBinder.VTable, self.vtable).Unbind(@ptrCast(*const IMSEventBinder, self), CancelCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID__IMSVidCtlEvents_Value = @import("../zig.zig").Guid.initString("b0edf164-910a-11d2-b632-00c04f79498e");
pub const IID__IMSVidCtlEvents = &IID__IMSVidCtlEvents_Value;
pub const _IMSVidCtlEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferInitialize_Value = @import("../zig.zig").Guid.initString("9ce50f2d-6ba7-40fb-a034-50b1a674ec78");
pub const IID_IStreamBufferInitialize = &IID_IStreamBufferInitialize_Value;
pub const IStreamBufferInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHKEY: fn(
            self: *const IStreamBufferInitialize,
            hkeyRoot: ?HKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSIDs: fn(
            self: *const IStreamBufferInitialize,
            cSIDs: u32,
            ppSID: ?*?PSID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferInitialize_SetHKEY(self: *const T, hkeyRoot: ?HKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferInitialize.VTable, self.vtable).SetHKEY(@ptrCast(*const IStreamBufferInitialize, self), hkeyRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferInitialize_SetSIDs(self: *const T, cSIDs: u32, ppSID: ?*?PSID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferInitialize.VTable, self.vtable).SetSIDs(@ptrCast(*const IStreamBufferInitialize, self), cSIDs, ppSID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RECORDING_TYPE = enum(i32) {
    CONTENT = 0,
    REFERENCE = 1,
};
pub const RECORDING_TYPE_CONTENT = RECORDING_TYPE.CONTENT;
pub const RECORDING_TYPE_REFERENCE = RECORDING_TYPE.REFERENCE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSink_Value = @import("../zig.zig").Guid.initString("afd1f242-7efd-45ee-ba4e-407a25c9a77a");
pub const IID_IStreamBufferSink = &IID_IStreamBufferSink_Value;
pub const IStreamBufferSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockProfile: fn(
            self: *const IStreamBufferSink,
            pszStreamBufferFilename: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRecorder: fn(
            self: *const IStreamBufferSink,
            pszFilename: ?[*:0]const u16,
            dwRecordType: u32,
            pRecordingIUnknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsProfileLocked: fn(
            self: *const IStreamBufferSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink_LockProfile(self: *const T, pszStreamBufferFilename: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferSink.VTable, self.vtable).LockProfile(@ptrCast(*const IStreamBufferSink, self), pszStreamBufferFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink_CreateRecorder(self: *const T, pszFilename: ?[*:0]const u16, dwRecordType: u32, pRecordingIUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferSink.VTable, self.vtable).CreateRecorder(@ptrCast(*const IStreamBufferSink, self), pszFilename, dwRecordType, pRecordingIUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink_IsProfileLocked(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferSink.VTable, self.vtable).IsProfileLocked(@ptrCast(*const IStreamBufferSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSink2_Value = @import("../zig.zig").Guid.initString("db94a660-f4fb-4bfa-bcc6-fe159a4eea93");
pub const IID_IStreamBufferSink2 = &IID_IStreamBufferSink2_Value;
pub const IStreamBufferSink2 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferSink.VTable,
        UnlockProfile: fn(
            self: *const IStreamBufferSink2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink2_UnlockProfile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferSink2.VTable, self.vtable).UnlockProfile(@ptrCast(*const IStreamBufferSink2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSink3_Value = @import("../zig.zig").Guid.initString("974723f2-887a-4452-9366-2cff3057bc8f");
pub const IID_IStreamBufferSink3 = &IID_IStreamBufferSink3_Value;
pub const IStreamBufferSink3 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferSink2.VTable,
        SetAvailableFilter: fn(
            self: *const IStreamBufferSink3,
            prtMin: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferSink2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink3_SetAvailableFilter(self: *const T, prtMin: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferSink3.VTable, self.vtable).SetAvailableFilter(@ptrCast(*const IStreamBufferSink3, self), prtMin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSource_Value = @import("../zig.zig").Guid.initString("1c5bd776-6ced-4f44-8164-5eab0e98db12");
pub const IID_IStreamBufferSource = &IID_IStreamBufferSource_Value;
pub const IStreamBufferSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamSink: fn(
            self: *const IStreamBufferSource,
            pIStreamBufferSink: ?*IStreamBufferSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSource_SetStreamSink(self: *const T, pIStreamBufferSink: ?*IStreamBufferSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferSource.VTable, self.vtable).SetStreamSink(@ptrCast(*const IStreamBufferSource, self), pIStreamBufferSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferRecordControl_Value = @import("../zig.zig").Guid.initString("ba9b6c99-f3c7-4ff2-92db-cfdd4851bf31");
pub const IID_IStreamBufferRecordControl = &IID_IStreamBufferRecordControl_Value;
pub const IStreamBufferRecordControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const IStreamBufferRecordControl,
            prtStart: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IStreamBufferRecordControl,
            rtStop: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordingStatus: fn(
            self: *const IStreamBufferRecordControl,
            phResult: ?*HRESULT,
            pbStarted: ?*BOOL,
            pbStopped: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordControl_Start(self: *const T, prtStart: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecordControl.VTable, self.vtable).Start(@ptrCast(*const IStreamBufferRecordControl, self), prtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordControl_Stop(self: *const T, rtStop: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecordControl.VTable, self.vtable).Stop(@ptrCast(*const IStreamBufferRecordControl, self), rtStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordControl_GetRecordingStatus(self: *const T, phResult: ?*HRESULT, pbStarted: ?*BOOL, pbStopped: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecordControl.VTable, self.vtable).GetRecordingStatus(@ptrCast(*const IStreamBufferRecordControl, self), phResult, pbStarted, pbStopped);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferRecComp_Value = @import("../zig.zig").Guid.initString("9e259a9b-8815-42ae-b09f-221970b154fd");
pub const IID_IStreamBufferRecComp = &IID_IStreamBufferRecComp_Value;
pub const IStreamBufferRecComp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IStreamBufferRecComp,
            pszTargetFilename: ?[*:0]const u16,
            pszSBRecProfileRef: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: fn(
            self: *const IStreamBufferRecComp,
            pszSBRecording: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendEx: fn(
            self: *const IStreamBufferRecComp,
            pszSBRecording: ?[*:0]const u16,
            rtStart: i64,
            rtStop: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLength: fn(
            self: *const IStreamBufferRecComp,
            pcSeconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IStreamBufferRecComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IStreamBufferRecComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_Initialize(self: *const T, pszTargetFilename: ?[*:0]const u16, pszSBRecProfileRef: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecComp.VTable, self.vtable).Initialize(@ptrCast(*const IStreamBufferRecComp, self), pszTargetFilename, pszSBRecProfileRef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_Append(self: *const T, pszSBRecording: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecComp.VTable, self.vtable).Append(@ptrCast(*const IStreamBufferRecComp, self), pszSBRecording);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_AppendEx(self: *const T, pszSBRecording: ?[*:0]const u16, rtStart: i64, rtStop: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecComp.VTable, self.vtable).AppendEx(@ptrCast(*const IStreamBufferRecComp, self), pszSBRecording, rtStart, rtStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_GetCurrentLength(self: *const T, pcSeconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecComp.VTable, self.vtable).GetCurrentLength(@ptrCast(*const IStreamBufferRecComp, self), pcSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecComp.VTable, self.vtable).Close(@ptrCast(*const IStreamBufferRecComp, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecComp.VTable, self.vtable).Cancel(@ptrCast(*const IStreamBufferRecComp, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STREAMBUFFER_ATTR_DATATYPE = enum(i32) {
    DWORD = 0,
    STRING = 1,
    BINARY = 2,
    BOOL = 3,
    QWORD = 4,
    WORD = 5,
    GUID = 6,
};
pub const STREAMBUFFER_TYPE_DWORD = STREAMBUFFER_ATTR_DATATYPE.DWORD;
pub const STREAMBUFFER_TYPE_STRING = STREAMBUFFER_ATTR_DATATYPE.STRING;
pub const STREAMBUFFER_TYPE_BINARY = STREAMBUFFER_ATTR_DATATYPE.BINARY;
pub const STREAMBUFFER_TYPE_BOOL = STREAMBUFFER_ATTR_DATATYPE.BOOL;
pub const STREAMBUFFER_TYPE_QWORD = STREAMBUFFER_ATTR_DATATYPE.QWORD;
pub const STREAMBUFFER_TYPE_WORD = STREAMBUFFER_ATTR_DATATYPE.WORD;
pub const STREAMBUFFER_TYPE_GUID = STREAMBUFFER_ATTR_DATATYPE.GUID;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferRecordingAttribute_Value = @import("../zig.zig").Guid.initString("16ca4e03-fe69-4705-bd41-5b7dfc0c95f3");
pub const IID_IStreamBufferRecordingAttribute = &IID_IStreamBufferRecordingAttribute_Value;
pub const IStreamBufferRecordingAttribute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAttribute: fn(
            self: *const IStreamBufferRecordingAttribute,
            ulReserved: u32,
            pszAttributeName: ?[*:0]const u16,
            StreamBufferAttributeType: STREAMBUFFER_ATTR_DATATYPE,
            pbAttribute: [*:0]u8,
            cbAttributeLength: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeCount: fn(
            self: *const IStreamBufferRecordingAttribute,
            ulReserved: u32,
            pcAttributes: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeByName: fn(
            self: *const IStreamBufferRecordingAttribute,
            pszAttributeName: ?[*:0]const u16,
            pulReserved: ?*u32,
            pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE,
            pbAttribute: [*:0]u8,
            pcbLength: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeByIndex: fn(
            self: *const IStreamBufferRecordingAttribute,
            wIndex: u16,
            pulReserved: ?*u32,
            pszAttributeName: ?PWSTR,
            pcchNameLength: ?*u16,
            pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE,
            pbAttribute: [*:0]u8,
            pcbLength: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAttributes: fn(
            self: *const IStreamBufferRecordingAttribute,
            ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_SetAttribute(self: *const T, ulReserved: u32, pszAttributeName: ?[*:0]const u16, StreamBufferAttributeType: STREAMBUFFER_ATTR_DATATYPE, pbAttribute: [*:0]u8, cbAttributeLength: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecordingAttribute.VTable, self.vtable).SetAttribute(@ptrCast(*const IStreamBufferRecordingAttribute, self), ulReserved, pszAttributeName, StreamBufferAttributeType, pbAttribute, cbAttributeLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_GetAttributeCount(self: *const T, ulReserved: u32, pcAttributes: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecordingAttribute.VTable, self.vtable).GetAttributeCount(@ptrCast(*const IStreamBufferRecordingAttribute, self), ulReserved, pcAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_GetAttributeByName(self: *const T, pszAttributeName: ?[*:0]const u16, pulReserved: ?*u32, pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE, pbAttribute: [*:0]u8, pcbLength: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecordingAttribute.VTable, self.vtable).GetAttributeByName(@ptrCast(*const IStreamBufferRecordingAttribute, self), pszAttributeName, pulReserved, pStreamBufferAttributeType, pbAttribute, pcbLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_GetAttributeByIndex(self: *const T, wIndex: u16, pulReserved: ?*u32, pszAttributeName: ?PWSTR, pcchNameLength: ?*u16, pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE, pbAttribute: [*:0]u8, pcbLength: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecordingAttribute.VTable, self.vtable).GetAttributeByIndex(@ptrCast(*const IStreamBufferRecordingAttribute, self), wIndex, pulReserved, pszAttributeName, pcchNameLength, pStreamBufferAttributeType, pbAttribute, pcbLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_EnumAttributes(self: *const T, ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferRecordingAttribute.VTable, self.vtable).EnumAttributes(@ptrCast(*const IStreamBufferRecordingAttribute, self), ppIEnumStreamBufferAttrib);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STREAMBUFFER_ATTRIBUTE = extern struct {
    pszName: ?PWSTR,
    StreamBufferAttributeType: STREAMBUFFER_ATTR_DATATYPE,
    pbAttribute: ?*u8,
    cbLength: u16,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumStreamBufferRecordingAttrib_Value = @import("../zig.zig").Guid.initString("c18a9162-1e82-4142-8c73-5690fa62fe33");
pub const IID_IEnumStreamBufferRecordingAttrib = &IID_IEnumStreamBufferRecordingAttrib_Value;
pub const IEnumStreamBufferRecordingAttrib = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumStreamBufferRecordingAttrib,
            cRequest: u32,
            pStreamBufferAttribute: [*]STREAMBUFFER_ATTRIBUTE,
            pcReceived: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumStreamBufferRecordingAttrib,
            cRecords: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumStreamBufferRecordingAttrib,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumStreamBufferRecordingAttrib,
            ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamBufferRecordingAttrib_Next(self: *const T, cRequest: u32, pStreamBufferAttribute: [*]STREAMBUFFER_ATTRIBUTE, pcReceived: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumStreamBufferRecordingAttrib.VTable, self.vtable).Next(@ptrCast(*const IEnumStreamBufferRecordingAttrib, self), cRequest, pStreamBufferAttribute, pcReceived);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamBufferRecordingAttrib_Skip(self: *const T, cRecords: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumStreamBufferRecordingAttrib.VTable, self.vtable).Skip(@ptrCast(*const IEnumStreamBufferRecordingAttrib, self), cRecords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamBufferRecordingAttrib_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumStreamBufferRecordingAttrib.VTable, self.vtable).Reset(@ptrCast(*const IEnumStreamBufferRecordingAttrib, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamBufferRecordingAttrib_Clone(self: *const T, ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumStreamBufferRecordingAttrib.VTable, self.vtable).Clone(@ptrCast(*const IEnumStreamBufferRecordingAttrib, self), ppIEnumStreamBufferAttrib);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferConfigure_Value = @import("../zig.zig").Guid.initString("ce14dfae-4098-4af7-bbf7-d6511f835414");
pub const IID_IStreamBufferConfigure = &IID_IStreamBufferConfigure_Value;
pub const IStreamBufferConfigure = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDirectory: fn(
            self: *const IStreamBufferConfigure,
            pszDirectoryName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectory: fn(
            self: *const IStreamBufferConfigure,
            ppszDirectoryName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackingFileCount: fn(
            self: *const IStreamBufferConfigure,
            dwMin: u32,
            dwMax: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackingFileCount: fn(
            self: *const IStreamBufferConfigure,
            pdwMin: ?*u32,
            pdwMax: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackingFileDuration: fn(
            self: *const IStreamBufferConfigure,
            dwSeconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackingFileDuration: fn(
            self: *const IStreamBufferConfigure,
            pdwSeconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_SetDirectory(self: *const T, pszDirectoryName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure.VTable, self.vtable).SetDirectory(@ptrCast(*const IStreamBufferConfigure, self), pszDirectoryName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_GetDirectory(self: *const T, ppszDirectoryName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure.VTable, self.vtable).GetDirectory(@ptrCast(*const IStreamBufferConfigure, self), ppszDirectoryName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_SetBackingFileCount(self: *const T, dwMin: u32, dwMax: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure.VTable, self.vtable).SetBackingFileCount(@ptrCast(*const IStreamBufferConfigure, self), dwMin, dwMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_GetBackingFileCount(self: *const T, pdwMin: ?*u32, pdwMax: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure.VTable, self.vtable).GetBackingFileCount(@ptrCast(*const IStreamBufferConfigure, self), pdwMin, pdwMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_SetBackingFileDuration(self: *const T, dwSeconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure.VTable, self.vtable).SetBackingFileDuration(@ptrCast(*const IStreamBufferConfigure, self), dwSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_GetBackingFileDuration(self: *const T, pdwSeconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure.VTable, self.vtable).GetBackingFileDuration(@ptrCast(*const IStreamBufferConfigure, self), pdwSeconds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferConfigure2_Value = @import("../zig.zig").Guid.initString("53e037bf-3992-4282-ae34-2487b4dae06b");
pub const IID_IStreamBufferConfigure2 = &IID_IStreamBufferConfigure2_Value;
pub const IStreamBufferConfigure2 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferConfigure.VTable,
        SetMultiplexedPacketSize: fn(
            self: *const IStreamBufferConfigure2,
            cbBytesPerPacket: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMultiplexedPacketSize: fn(
            self: *const IStreamBufferConfigure2,
            pcbBytesPerPacket: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFFTransitionRates: fn(
            self: *const IStreamBufferConfigure2,
            dwMaxFullFrameRate: u32,
            dwMaxNonSkippingRate: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFFTransitionRates: fn(
            self: *const IStreamBufferConfigure2,
            pdwMaxFullFrameRate: ?*u32,
            pdwMaxNonSkippingRate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferConfigure.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure2_SetMultiplexedPacketSize(self: *const T, cbBytesPerPacket: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure2.VTable, self.vtable).SetMultiplexedPacketSize(@ptrCast(*const IStreamBufferConfigure2, self), cbBytesPerPacket);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure2_GetMultiplexedPacketSize(self: *const T, pcbBytesPerPacket: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure2.VTable, self.vtable).GetMultiplexedPacketSize(@ptrCast(*const IStreamBufferConfigure2, self), pcbBytesPerPacket);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure2_SetFFTransitionRates(self: *const T, dwMaxFullFrameRate: u32, dwMaxNonSkippingRate: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure2.VTable, self.vtable).SetFFTransitionRates(@ptrCast(*const IStreamBufferConfigure2, self), dwMaxFullFrameRate, dwMaxNonSkippingRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure2_GetFFTransitionRates(self: *const T, pdwMaxFullFrameRate: ?*u32, pdwMaxNonSkippingRate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure2.VTable, self.vtable).GetFFTransitionRates(@ptrCast(*const IStreamBufferConfigure2, self), pdwMaxFullFrameRate, pdwMaxNonSkippingRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamBufferConfigure3_Value = @import("../zig.zig").Guid.initString("7e2d2a1e-7192-4bd7-80c1-061fd1d10402");
pub const IID_IStreamBufferConfigure3 = &IID_IStreamBufferConfigure3_Value;
pub const IStreamBufferConfigure3 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferConfigure2.VTable,
        SetStartRecConfig: fn(
            self: *const IStreamBufferConfigure3,
            fStartStopsCur: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartRecConfig: fn(
            self: *const IStreamBufferConfigure3,
            pfStartStopsCur: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNamespace: fn(
            self: *const IStreamBufferConfigure3,
            pszNamespace: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamespace: fn(
            self: *const IStreamBufferConfigure3,
            ppszNamespace: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferConfigure2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure3_SetStartRecConfig(self: *const T, fStartStopsCur: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure3.VTable, self.vtable).SetStartRecConfig(@ptrCast(*const IStreamBufferConfigure3, self), fStartStopsCur);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure3_GetStartRecConfig(self: *const T, pfStartStopsCur: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure3.VTable, self.vtable).GetStartRecConfig(@ptrCast(*const IStreamBufferConfigure3, self), pfStartStopsCur);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure3_SetNamespace(self: *const T, pszNamespace: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure3.VTable, self.vtable).SetNamespace(@ptrCast(*const IStreamBufferConfigure3, self), pszNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure3_GetNamespace(self: *const T, ppszNamespace: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferConfigure3.VTable, self.vtable).GetNamespace(@ptrCast(*const IStreamBufferConfigure3, self), ppszNamespace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferMediaSeeking_Value = @import("../zig.zig").Guid.initString("f61f5c26-863d-4afa-b0ba-2f81dc978596");
pub const IID_IStreamBufferMediaSeeking = &IID_IStreamBufferMediaSeeking_Value;
pub const IStreamBufferMediaSeeking = extern struct {
    pub const VTable = extern struct {
        base: IMediaSeeking.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaSeeking.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferMediaSeeking2_Value = @import("../zig.zig").Guid.initString("3a439ab0-155f-470a-86a6-9ea54afd6eaf");
pub const IID_IStreamBufferMediaSeeking2 = &IID_IStreamBufferMediaSeeking2_Value;
pub const IStreamBufferMediaSeeking2 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferMediaSeeking.VTable,
        SetRateEx: fn(
            self: *const IStreamBufferMediaSeeking2,
            dRate: f64,
            dwFramesPerSec: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferMediaSeeking.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferMediaSeeking2_SetRateEx(self: *const T, dRate: f64, dwFramesPerSec: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferMediaSeeking2.VTable, self.vtable).SetRateEx(@ptrCast(*const IStreamBufferMediaSeeking2, self), dRate, dwFramesPerSec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SBE_PIN_DATA = extern struct {
    cDataBytes: u64,
    cSamplesProcessed: u64,
    cDiscontinuities: u64,
    cSyncPoints: u64,
    cTimestamps: u64,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferDataCounters_Value = @import("../zig.zig").Guid.initString("9d2a2563-31ab-402e-9a6b-adb903489440");
pub const IID_IStreamBufferDataCounters = &IID_IStreamBufferDataCounters_Value;
pub const IStreamBufferDataCounters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: fn(
            self: *const IStreamBufferDataCounters,
            pPinData: ?*SBE_PIN_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetData: fn(
            self: *const IStreamBufferDataCounters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferDataCounters_GetData(self: *const T, pPinData: ?*SBE_PIN_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferDataCounters.VTable, self.vtable).GetData(@ptrCast(*const IStreamBufferDataCounters, self), pPinData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferDataCounters_ResetData(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamBufferDataCounters.VTable, self.vtable).ResetData(@ptrCast(*const IStreamBufferDataCounters, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CROSSBAR_DEFAULT_FLAGS = enum(i32) {
    PROFILE = 1,
    STREAMS = 2,
};
pub const DEF_MODE_PROFILE = CROSSBAR_DEFAULT_FLAGS.PROFILE;
pub const DEF_MODE_STREAMS = CROSSBAR_DEFAULT_FLAGS.STREAMS;

pub const SBE2_STREAM_DESC = extern struct {
    Version: u32,
    StreamId: u32,
    Default: u32,
    Reserved: u32,
};

pub const DVR_STREAM_DESC = extern struct {
    Version: u32,
    StreamId: u32,
    Default: BOOL,
    Creation: BOOL,
    Reserved: u32,
    guidSubMediaType: Guid,
    guidFormatType: Guid,
    MediaType: AM_MEDIA_TYPE,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2GlobalEvent_Value = @import("../zig.zig").Guid.initString("caede759-b6b1-11db-a578-0018f3fa24c6");
pub const IID_ISBE2GlobalEvent = &IID_ISBE2GlobalEvent_Value;
pub const ISBE2GlobalEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: fn(
            self: *const ISBE2GlobalEvent,
            idEvt: ?*const Guid,
            param1: u32,
            param2: u32,
            param3: u32,
            param4: u32,
            pSpanning: ?*BOOL,
            pcb: ?*u32,
            pb: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2GlobalEvent_GetEvent(self: *const T, idEvt: ?*const Guid, param1: u32, param2: u32, param3: u32, param4: u32, pSpanning: ?*BOOL, pcb: ?*u32, pb: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2GlobalEvent.VTable, self.vtable).GetEvent(@ptrCast(*const ISBE2GlobalEvent, self), idEvt, param1, param2, param3, param4, pSpanning, pcb, pb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2GlobalEvent2_Value = @import("../zig.zig").Guid.initString("6d8309bf-00fe-4506-8b03-f8c65b5c9b39");
pub const IID_ISBE2GlobalEvent2 = &IID_ISBE2GlobalEvent2_Value;
pub const ISBE2GlobalEvent2 = extern struct {
    pub const VTable = extern struct {
        base: ISBE2GlobalEvent.VTable,
        GetEventEx: fn(
            self: *const ISBE2GlobalEvent2,
            idEvt: ?*const Guid,
            param1: u32,
            param2: u32,
            param3: u32,
            param4: u32,
            pSpanning: ?*BOOL,
            pcb: ?*u32,
            pb: ?*u8,
            pStreamTime: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISBE2GlobalEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2GlobalEvent2_GetEventEx(self: *const T, idEvt: ?*const Guid, param1: u32, param2: u32, param3: u32, param4: u32, pSpanning: ?*BOOL, pcb: ?*u32, pb: ?*u8, pStreamTime: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2GlobalEvent2.VTable, self.vtable).GetEventEx(@ptrCast(*const ISBE2GlobalEvent2, self), idEvt, param1, param2, param3, param4, pSpanning, pcb, pb, pStreamTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2SpanningEvent_Value = @import("../zig.zig").Guid.initString("caede760-b6b1-11db-a578-0018f3fa24c6");
pub const IID_ISBE2SpanningEvent = &IID_ISBE2SpanningEvent_Value;
pub const ISBE2SpanningEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: fn(
            self: *const ISBE2SpanningEvent,
            idEvt: ?*const Guid,
            streamId: u32,
            pcb: ?*u32,
            pb: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2SpanningEvent_GetEvent(self: *const T, idEvt: ?*const Guid, streamId: u32, pcb: ?*u32, pb: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2SpanningEvent.VTable, self.vtable).GetEvent(@ptrCast(*const ISBE2SpanningEvent, self), idEvt, streamId, pcb, pb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2Crossbar_Value = @import("../zig.zig").Guid.initString("547b6d26-3226-487e-8253-8aa168749434");
pub const IID_ISBE2Crossbar = &IID_ISBE2Crossbar_Value;
pub const ISBE2Crossbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableDefaultMode: fn(
            self: *const ISBE2Crossbar,
            DefaultFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInitialProfile: fn(
            self: *const ISBE2Crossbar,
            ppProfile: ?*?*ISBE2MediaTypeProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputProfile: fn(
            self: *const ISBE2Crossbar,
            pProfile: ?*ISBE2MediaTypeProfile,
            pcOutputPins: ?*u32,
            ppOutputPins: ?*?*IPin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumStreams: fn(
            self: *const ISBE2Crossbar,
            ppStreams: ?*?*ISBE2EnumStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2Crossbar_EnableDefaultMode(self: *const T, DefaultFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2Crossbar.VTable, self.vtable).EnableDefaultMode(@ptrCast(*const ISBE2Crossbar, self), DefaultFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2Crossbar_GetInitialProfile(self: *const T, ppProfile: ?*?*ISBE2MediaTypeProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2Crossbar.VTable, self.vtable).GetInitialProfile(@ptrCast(*const ISBE2Crossbar, self), ppProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2Crossbar_SetOutputProfile(self: *const T, pProfile: ?*ISBE2MediaTypeProfile, pcOutputPins: ?*u32, ppOutputPins: ?*?*IPin) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2Crossbar.VTable, self.vtable).SetOutputProfile(@ptrCast(*const ISBE2Crossbar, self), pProfile, pcOutputPins, ppOutputPins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2Crossbar_EnumStreams(self: *const T, ppStreams: ?*?*ISBE2EnumStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2Crossbar.VTable, self.vtable).EnumStreams(@ptrCast(*const ISBE2Crossbar, self), ppStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2StreamMap_Value = @import("../zig.zig").Guid.initString("667c7745-85b1-4c55-ae55-4e25056159fc");
pub const IID_ISBE2StreamMap = &IID_ISBE2StreamMap_Value;
pub const ISBE2StreamMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapStream: fn(
            self: *const ISBE2StreamMap,
            Stream: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnmapStream: fn(
            self: *const ISBE2StreamMap,
            Stream: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMappedStreams: fn(
            self: *const ISBE2StreamMap,
            ppStreams: ?*?*ISBE2EnumStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2StreamMap_MapStream(self: *const T, Stream: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2StreamMap.VTable, self.vtable).MapStream(@ptrCast(*const ISBE2StreamMap, self), Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2StreamMap_UnmapStream(self: *const T, Stream: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2StreamMap.VTable, self.vtable).UnmapStream(@ptrCast(*const ISBE2StreamMap, self), Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2StreamMap_EnumMappedStreams(self: *const T, ppStreams: ?*?*ISBE2EnumStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2StreamMap.VTable, self.vtable).EnumMappedStreams(@ptrCast(*const ISBE2StreamMap, self), ppStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2EnumStream_Value = @import("../zig.zig").Guid.initString("f7611092-9fbc-46ec-a7c7-548ea78b71a4");
pub const IID_ISBE2EnumStream = &IID_ISBE2EnumStream_Value;
pub const ISBE2EnumStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const ISBE2EnumStream,
            cRequest: u32,
            pStreamDesc: [*]SBE2_STREAM_DESC,
            pcReceived: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const ISBE2EnumStream,
            cRecords: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ISBE2EnumStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const ISBE2EnumStream,
            ppIEnumStream: ?*?*ISBE2EnumStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2EnumStream_Next(self: *const T, cRequest: u32, pStreamDesc: [*]SBE2_STREAM_DESC, pcReceived: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2EnumStream.VTable, self.vtable).Next(@ptrCast(*const ISBE2EnumStream, self), cRequest, pStreamDesc, pcReceived);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2EnumStream_Skip(self: *const T, cRecords: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2EnumStream.VTable, self.vtable).Skip(@ptrCast(*const ISBE2EnumStream, self), cRecords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2EnumStream_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2EnumStream.VTable, self.vtable).Reset(@ptrCast(*const ISBE2EnumStream, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2EnumStream_Clone(self: *const T, ppIEnumStream: ?*?*ISBE2EnumStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2EnumStream.VTable, self.vtable).Clone(@ptrCast(*const ISBE2EnumStream, self), ppIEnumStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2MediaTypeProfile_Value = @import("../zig.zig").Guid.initString("f238267d-4671-40d7-997e-25dc32cfed2a");
pub const IID_ISBE2MediaTypeProfile = &IID_ISBE2MediaTypeProfile_Value;
pub const ISBE2MediaTypeProfile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: fn(
            self: *const ISBE2MediaTypeProfile,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: fn(
            self: *const ISBE2MediaTypeProfile,
            Index: u32,
            ppMediaType: ?*?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStream: fn(
            self: *const ISBE2MediaTypeProfile,
            pMediaType: ?*AM_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteStream: fn(
            self: *const ISBE2MediaTypeProfile,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2MediaTypeProfile_GetStreamCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2MediaTypeProfile.VTable, self.vtable).GetStreamCount(@ptrCast(*const ISBE2MediaTypeProfile, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2MediaTypeProfile_GetStream(self: *const T, Index: u32, ppMediaType: ?*?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2MediaTypeProfile.VTable, self.vtable).GetStream(@ptrCast(*const ISBE2MediaTypeProfile, self), Index, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2MediaTypeProfile_AddStream(self: *const T, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2MediaTypeProfile.VTable, self.vtable).AddStream(@ptrCast(*const ISBE2MediaTypeProfile, self), pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2MediaTypeProfile_DeleteStream(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2MediaTypeProfile.VTable, self.vtable).DeleteStream(@ptrCast(*const ISBE2MediaTypeProfile, self), Index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2FileScan_Value = @import("../zig.zig").Guid.initString("3e2bf5a5-4f96-4899-a1a3-75e8be9a5ac0");
pub const IID_ISBE2FileScan = &IID_ISBE2FileScan_Value;
pub const ISBE2FileScan = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RepairFile: fn(
            self: *const ISBE2FileScan,
            filename: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2FileScan_RepairFile(self: *const T, filename: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISBE2FileScan.VTable, self.vtable).RepairFile(@ptrCast(*const ISBE2FileScan, self), filename);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SectionList_Value = @import("../zig.zig").Guid.initString("73da5d04-4347-45d3-a9dc-fae9ddbe558d");
pub const CLSID_SectionList = &CLSID_SectionList_Value;

const CLSID_Mpeg2Stream_Value = @import("../zig.zig").Guid.initString("f91d96c7-8509-4d0b-ab26-a0dd10904bb7");
pub const CLSID_Mpeg2Stream = &CLSID_Mpeg2Stream_Value;

const CLSID_Mpeg2Data_Value = @import("../zig.zig").Guid.initString("c666e115-bb62-4027-a113-82d643fe2d99");
pub const CLSID_Mpeg2Data = &CLSID_Mpeg2Data_Value;

pub const PID_BITS_MIDL = packed struct {
    Bits: u16,
};

pub const MPEG_HEADER_BITS_MIDL = packed struct {
    Bits: u16,
};

pub const MPEG_HEADER_VERSION_BITS_MIDL = extern struct {
    Bits: u8,
};

pub const MPEG_CURRENT_NEXT_BIT = enum(i32) {
    NEXT = 0,
    CURRENT = 1,
};
pub const MPEG_SECTION_IS_NEXT = MPEG_CURRENT_NEXT_BIT.NEXT;
pub const MPEG_SECTION_IS_CURRENT = MPEG_CURRENT_NEXT_BIT.CURRENT;

pub const TID_EXTENSION = packed struct {
    wTidExt: u16,
    wCount: u16,
};

pub const SECTION = extern struct {
    TableId: u8,
    Header: packed union {
        S: MPEG_HEADER_BITS_MIDL,
        W: u16,
    },
    SectionData: [1]u8,
};

pub const LONG_SECTION = packed struct {
    TableId: u8,
    Header: packed union {
        S: MPEG_HEADER_BITS_MIDL,
        W: u16,
    },
    TableIdExtension: u16,
    Version: extern union {
        S: MPEG_HEADER_VERSION_BITS_MIDL,
        B: u8,
    },
    SectionNumber: u8,
    LastSectionNumber: u8,
    RemainingData: [1]u8,
};

pub const DSMCC_SECTION = packed struct {
    TableId: u8,
    Header: packed union {
        S: MPEG_HEADER_BITS_MIDL,
        W: u16,
    },
    TableIdExtension: u16,
    Version: extern union {
        S: MPEG_HEADER_VERSION_BITS_MIDL,
        B: u8,
    },
    SectionNumber: u8,
    LastSectionNumber: u8,
    ProtocolDiscriminator: u8,
    DsmccType: u8,
    MessageId: u16,
    TransactionId: u32,
    Reserved: u8,
    AdaptationLength: u8,
    MessageLength: u16,
    RemainingData: [1]u8,
};

pub const MPEG_RQST_PACKET = packed struct {
    dwLength: u32,
    pSection: ?*SECTION,
};

pub const MPEG_PACKET_LIST = packed struct {
    wPacketCount: u16,
    PacketList: [1]?*MPEG_RQST_PACKET,
};

pub const DSMCC_FILTER_OPTIONS = packed struct {
    fSpecifyProtocol: BOOL,
    Protocol: u8,
    fSpecifyType: BOOL,
    Type: u8,
    fSpecifyMessageId: BOOL,
    MessageId: u16,
    fSpecifyTransactionId: BOOL,
    fUseTrxIdMessageIdMask: BOOL,
    TransactionId: u32,
    fSpecifyModuleVersion: BOOL,
    ModuleVersion: u8,
    fSpecifyBlockNumber: BOOL,
    BlockNumber: u16,
    fGetModuleCall: BOOL,
    NumberOfBlocksInModule: u16,
};

pub const ATSC_FILTER_OPTIONS = packed struct {
    fSpecifyEtmId: BOOL,
    EtmId: u32,
};

pub const DVB_EIT_FILTER_OPTIONS = packed struct {
    fSpecifySegment: BOOL,
    bSegment: u8,
};

pub const MPEG2_FILTER = packed struct {
    bVersionNumber: u8,
    wFilterSize: u16,
    fUseRawFilteringBits: BOOL,
    Filter: [16]u8,
    Mask: [16]u8,
    fSpecifyTableIdExtension: BOOL,
    TableIdExtension: u16,
    fSpecifyVersion: BOOL,
    Version: u8,
    fSpecifySectionNumber: BOOL,
    SectionNumber: u8,
    fSpecifyCurrentNext: BOOL,
    fNext: BOOL,
    fSpecifyDsmccOptions: BOOL,
    Dsmcc: DSMCC_FILTER_OPTIONS,
    fSpecifyAtscOptions: BOOL,
    Atsc: ATSC_FILTER_OPTIONS,
};

pub const MPEG2_FILTER2 = packed struct {
    Anonymous: extern union {
        Anonymous: packed struct {
            bVersionNumber: u8,
            wFilterSize: u16,
            fUseRawFilteringBits: BOOL,
            Filter: [16]u8,
            Mask: [16]u8,
            fSpecifyTableIdExtension: BOOL,
            TableIdExtension: u16,
            fSpecifyVersion: BOOL,
            Version: u8,
            fSpecifySectionNumber: BOOL,
            SectionNumber: u8,
            fSpecifyCurrentNext: BOOL,
            fNext: BOOL,
            fSpecifyDsmccOptions: BOOL,
            Dsmcc: DSMCC_FILTER_OPTIONS,
            fSpecifyAtscOptions: BOOL,
            Atsc: ATSC_FILTER_OPTIONS,
        },
        bVersion1Bytes: [124]u8,
    },
    fSpecifyDvbEitOptions: BOOL,
    DvbEit: DVB_EIT_FILTER_OPTIONS,
};

pub const MPEG_STREAM_BUFFER = packed struct {
    hr: HRESULT,
    dwDataBufferSize: u32,
    dwSizeOfDataRead: u32,
    pDataBuffer: ?*u8,
};

pub const MPEG_TIME = extern struct {
    Hours: u8,
    Minutes: u8,
    Seconds: u8,
};

pub const MPEG_DATE = packed struct {
    Date: u8,
    Month: u8,
    Year: u16,
};

pub const MPEG_DATE_AND_TIME = extern struct {
    D: MPEG_DATE,
    T: MPEG_TIME,
};

pub const MPEG_CONTEXT_TYPE = enum(i32) {
    BCS_DEMUX = 0,
    WINSOCK = 1,
};
pub const MPEG_CONTEXT_BCS_DEMUX = MPEG_CONTEXT_TYPE.BCS_DEMUX;
pub const MPEG_CONTEXT_WINSOCK = MPEG_CONTEXT_TYPE.WINSOCK;

pub const MPEG_BCS_DEMUX = packed struct {
    AVMGraphId: u32,
};

pub const MPEG_WINSOCK = packed struct {
    AVMGraphId: u32,
};

pub const MPEG_CONTEXT = packed struct {
    Type: MPEG_CONTEXT_TYPE,
    U: extern union {
        Demux: MPEG_BCS_DEMUX,
        Winsock: MPEG_WINSOCK,
    },
};

pub const MPEG_REQUEST_TYPE = enum(i32) {
    UNKNOWN = 0,
    GET_SECTION = 1,
    GET_SECTION_ASYNC = 2,
    GET_TABLE = 3,
    GET_TABLE_ASYNC = 4,
    GET_SECTIONS_STREAM = 5,
    GET_PES_STREAM = 6,
    GET_TS_STREAM = 7,
    START_MPE_STREAM = 8,
};
pub const MPEG_RQST_UNKNOWN = MPEG_REQUEST_TYPE.UNKNOWN;
pub const MPEG_RQST_GET_SECTION = MPEG_REQUEST_TYPE.GET_SECTION;
pub const MPEG_RQST_GET_SECTION_ASYNC = MPEG_REQUEST_TYPE.GET_SECTION_ASYNC;
pub const MPEG_RQST_GET_TABLE = MPEG_REQUEST_TYPE.GET_TABLE;
pub const MPEG_RQST_GET_TABLE_ASYNC = MPEG_REQUEST_TYPE.GET_TABLE_ASYNC;
pub const MPEG_RQST_GET_SECTIONS_STREAM = MPEG_REQUEST_TYPE.GET_SECTIONS_STREAM;
pub const MPEG_RQST_GET_PES_STREAM = MPEG_REQUEST_TYPE.GET_PES_STREAM;
pub const MPEG_RQST_GET_TS_STREAM = MPEG_REQUEST_TYPE.GET_TS_STREAM;
pub const MPEG_RQST_START_MPE_STREAM = MPEG_REQUEST_TYPE.START_MPE_STREAM;

pub const MPEG_SERVICE_REQUEST = packed struct {
    Type: MPEG_REQUEST_TYPE,
    Context: MPEG_CONTEXT,
    Pid: u16,
    TableId: u8,
    Filter: MPEG2_FILTER,
    Flags: u32,
};

pub const MPEG_SERVICE_RESPONSE = packed struct {
    IPAddress: u32,
    Port: u16,
};

pub const DSMCC_ELEMENT = packed struct {
    pid: u16,
    bComponentTag: u8,
    dwCarouselId: u32,
    dwTransactionId: u32,
    pNext: ?*DSMCC_ELEMENT,
};

pub const MPE_ELEMENT = packed struct {
    pid: u16,
    bComponentTag: u8,
    pNext: ?*MPE_ELEMENT,
};

pub const MPEG_STREAM_FILTER = packed struct {
    wPidValue: u16,
    dwFilterSize: u32,
    fCrcEnabled: BOOL,
    rgchFilter: [16]u8,
    rgchMask: [16]u8,
};

const IID_IMpeg2TableFilter_Value = @import("../zig.zig").Guid.initString("bdcdd913-9ecd-4fb2-81ae-adf747ea75a5");
pub const IID_IMpeg2TableFilter = &IID_IMpeg2TableFilter_Value;
pub const IMpeg2TableFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPID: fn(
            self: *const IMpeg2TableFilter,
            p: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTable: fn(
            self: *const IMpeg2TableFilter,
            p: u16,
            t: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: fn(
            self: *const IMpeg2TableFilter,
            p: u16,
            t: u8,
            e: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePID: fn(
            self: *const IMpeg2TableFilter,
            p: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTable: fn(
            self: *const IMpeg2TableFilter,
            p: u16,
            t: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveExtension: fn(
            self: *const IMpeg2TableFilter,
            p: u16,
            t: u8,
            e: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_AddPID(self: *const T, p: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2TableFilter.VTable, self.vtable).AddPID(@ptrCast(*const IMpeg2TableFilter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_AddTable(self: *const T, p: u16, t: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2TableFilter.VTable, self.vtable).AddTable(@ptrCast(*const IMpeg2TableFilter, self), p, t);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_AddExtension(self: *const T, p: u16, t: u8, e: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2TableFilter.VTable, self.vtable).AddExtension(@ptrCast(*const IMpeg2TableFilter, self), p, t, e);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_RemovePID(self: *const T, p: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2TableFilter.VTable, self.vtable).RemovePID(@ptrCast(*const IMpeg2TableFilter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_RemoveTable(self: *const T, p: u16, t: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2TableFilter.VTable, self.vtable).RemoveTable(@ptrCast(*const IMpeg2TableFilter, self), p, t);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_RemoveExtension(self: *const T, p: u16, t: u8, e: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2TableFilter.VTable, self.vtable).RemoveExtension(@ptrCast(*const IMpeg2TableFilter, self), p, t, e);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Mpeg2TableSampleHdr = packed struct {
    SectionCount: u8,
    Reserved: [3]u8,
    SectionOffsets: [1]i32,
};

const CLSID_Mpeg2DataLib_Value = @import("../zig.zig").Guid.initString("dbaf6c1b-b6a4-4898-ae65-204f0d9509a1");
pub const CLSID_Mpeg2DataLib = &CLSID_Mpeg2DataLib_Value;

const IID_IMpeg2Data_Value = @import("../zig.zig").Guid.initString("9b396d40-f380-4e3c-a514-1a82bf6ebfe6");
pub const IID_IMpeg2Data = &IID_IMpeg2Data_Value;
pub const IMpeg2Data = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSection: fn(
            self: *const IMpeg2Data,
            pid: u16,
            tid: u8,
            pFilter: ?*MPEG2_FILTER,
            dwTimeout: u32,
            ppSectionList: ?*?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTable: fn(
            self: *const IMpeg2Data,
            pid: u16,
            tid: u8,
            pFilter: ?*MPEG2_FILTER,
            dwTimeout: u32,
            ppSectionList: ?*?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamOfSections: fn(
            self: *const IMpeg2Data,
            pid: u16,
            tid: u8,
            pFilter: ?*MPEG2_FILTER,
            hDataReadyEvent: ?HANDLE,
            ppMpegStream: ?*?*IMpeg2Stream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Data_GetSection(self: *const T, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, dwTimeout: u32, ppSectionList: ?*?*ISectionList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2Data.VTable, self.vtable).GetSection(@ptrCast(*const IMpeg2Data, self), pid, tid, pFilter, dwTimeout, ppSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Data_GetTable(self: *const T, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, dwTimeout: u32, ppSectionList: ?*?*ISectionList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2Data.VTable, self.vtable).GetTable(@ptrCast(*const IMpeg2Data, self), pid, tid, pFilter, dwTimeout, ppSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Data_GetStreamOfSections(self: *const T, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, hDataReadyEvent: ?HANDLE, ppMpegStream: ?*?*IMpeg2Stream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2Data.VTable, self.vtable).GetStreamOfSections(@ptrCast(*const IMpeg2Data, self), pid, tid, pFilter, hDataReadyEvent, ppMpegStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISectionList_Value = @import("../zig.zig").Guid.initString("afec1eb5-2a64-46c6-bf4b-ae3ccb6afdb0");
pub const IID_ISectionList = &IID_ISectionList_Value;
pub const ISectionList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const ISectionList,
            requestType: MPEG_REQUEST_TYPE,
            pMpeg2Data: ?*IMpeg2Data,
            pContext: ?*MPEG_CONTEXT,
            pid: u16,
            tid: u8,
            pFilter: ?*MPEG2_FILTER,
            timeout: u32,
            hDoneEvent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeWithRawSections: fn(
            self: *const ISectionList,
            pmplSections: ?*MPEG_PACKET_LIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelPendingRequest: fn(
            self: *const ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfSections: fn(
            self: *const ISectionList,
            pCount: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSectionData: fn(
            self: *const ISectionList,
            sectionNumber: u16,
            pdwRawPacketLength: ?*u32,
            ppSection: ?*?*SECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgramIdentifier: fn(
            self: *const ISectionList,
            pPid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableIdentifier: fn(
            self: *const ISectionList,
            pTableId: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_Initialize(self: *const T, requestType: MPEG_REQUEST_TYPE, pMpeg2Data: ?*IMpeg2Data, pContext: ?*MPEG_CONTEXT, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, timeout: u32, hDoneEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISectionList.VTable, self.vtable).Initialize(@ptrCast(*const ISectionList, self), requestType, pMpeg2Data, pContext, pid, tid, pFilter, timeout, hDoneEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_InitializeWithRawSections(self: *const T, pmplSections: ?*MPEG_PACKET_LIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISectionList.VTable, self.vtable).InitializeWithRawSections(@ptrCast(*const ISectionList, self), pmplSections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_CancelPendingRequest(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISectionList.VTable, self.vtable).CancelPendingRequest(@ptrCast(*const ISectionList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_GetNumberOfSections(self: *const T, pCount: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISectionList.VTable, self.vtable).GetNumberOfSections(@ptrCast(*const ISectionList, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_GetSectionData(self: *const T, sectionNumber: u16, pdwRawPacketLength: ?*u32, ppSection: ?*?*SECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISectionList.VTable, self.vtable).GetSectionData(@ptrCast(*const ISectionList, self), sectionNumber, pdwRawPacketLength, ppSection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_GetProgramIdentifier(self: *const T, pPid: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISectionList.VTable, self.vtable).GetProgramIdentifier(@ptrCast(*const ISectionList, self), pPid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_GetTableIdentifier(self: *const T, pTableId: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISectionList.VTable, self.vtable).GetTableIdentifier(@ptrCast(*const ISectionList, self), pTableId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMpeg2Stream_Value = @import("../zig.zig").Guid.initString("400cc286-32a0-4ce4-9041-39571125a635");
pub const IID_IMpeg2Stream = &IID_IMpeg2Stream_Value;
pub const IMpeg2Stream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IMpeg2Stream,
            requestType: MPEG_REQUEST_TYPE,
            pMpeg2Data: ?*IMpeg2Data,
            pContext: ?*MPEG_CONTEXT,
            pid: u16,
            tid: u8,
            pFilter: ?*MPEG2_FILTER,
            hDataReadyEvent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupplyDataBuffer: fn(
            self: *const IMpeg2Stream,
            pStreamBuffer: ?*MPEG_STREAM_BUFFER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Stream_Initialize(self: *const T, requestType: MPEG_REQUEST_TYPE, pMpeg2Data: ?*IMpeg2Data, pContext: ?*MPEG_CONTEXT, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, hDataReadyEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2Stream.VTable, self.vtable).Initialize(@ptrCast(*const IMpeg2Stream, self), requestType, pMpeg2Data, pContext, pid, tid, pFilter, hDataReadyEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Stream_SupplyDataBuffer(self: *const T, pStreamBuffer: ?*MPEG_STREAM_BUFFER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMpeg2Stream.VTable, self.vtable).SupplyDataBuffer(@ptrCast(*const IMpeg2Stream, self), pStreamBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGenericDescriptor_Value = @import("../zig.zig").Guid.initString("6a5918f8-a77a-4f61-aed0-5702bdcda3e6");
pub const IID_IGenericDescriptor = &IID_IGenericDescriptor_Value;
pub const IGenericDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IGenericDescriptor,
            pbDesc: ?*u8,
            bCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTag: fn(
            self: *const IGenericDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IGenericDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBody: fn(
            self: *const IGenericDescriptor,
            ppbVal: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor_Initialize(self: *const T, pbDesc: ?*u8, bCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGenericDescriptor.VTable, self.vtable).Initialize(@ptrCast(*const IGenericDescriptor, self), pbDesc, bCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGenericDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IGenericDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGenericDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IGenericDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor_GetBody(self: *const T, ppbVal: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGenericDescriptor.VTable, self.vtable).GetBody(@ptrCast(*const IGenericDescriptor, self), ppbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGenericDescriptor2_Value = @import("../zig.zig").Guid.initString("bf02fb7e-9792-4e10-a68d-033a2cc246a5");
pub const IID_IGenericDescriptor2 = &IID_IGenericDescriptor2_Value;
pub const IGenericDescriptor2 = extern struct {
    pub const VTable = extern struct {
        base: IGenericDescriptor.VTable,
        Initialize: fn(
            self: *const IGenericDescriptor2,
            pbDesc: ?*u8,
            wCount: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IGenericDescriptor2,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IGenericDescriptor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor2_Initialize(self: *const T, pbDesc: ?*u8, wCount: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGenericDescriptor2.VTable, self.vtable).Initialize(@ptrCast(*const IGenericDescriptor2, self), pbDesc, wCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor2_GetLength(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGenericDescriptor2.VTable, self.vtable).GetLength(@ptrCast(*const IGenericDescriptor2, self), pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ProgramElement = extern struct {
    wProgramNumber: u16,
    wProgramMapPID: u16,
};

const IID_IPAT_Value = @import("../zig.zig").Guid.initString("6623b511-4b5f-43c3-9a01-e8ff84188060");
pub const IID_IPAT = &IID_IPAT_Value;
pub const IPAT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IPAT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: fn(
            self: *const IPAT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IPAT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IPAT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordProgramNumber: fn(
            self: *const IPAT,
            dwIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordProgramMapPid: fn(
            self: *const IPAT,
            dwIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindRecordProgramMapPid: fn(
            self: *const IPAT,
            wProgramNumber: u16,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: fn(
            self: *const IPAT,
            hNextTableAvailable: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: fn(
            self: *const IPAT,
            ppPAT: ?*?*IPAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: fn(
            self: *const IPAT,
            hNextTableIsCurrent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: fn(
            self: *const IPAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).Initialize(@ptrCast(*const IPAT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).GetTransportStreamId(@ptrCast(*const IPAT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IPAT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IPAT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetRecordProgramNumber(self: *const T, dwIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).GetRecordProgramNumber(@ptrCast(*const IPAT, self), dwIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetRecordProgramMapPid(self: *const T, dwIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).GetRecordProgramMapPid(@ptrCast(*const IPAT, self), dwIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_FindRecordProgramMapPid(self: *const T, wProgramNumber: u16, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).FindRecordProgramMapPid(@ptrCast(*const IPAT, self), wProgramNumber, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).RegisterForNextTable(@ptrCast(*const IPAT, self), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetNextTable(self: *const T, ppPAT: ?*?*IPAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).GetNextTable(@ptrCast(*const IPAT, self), ppPAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).RegisterForWhenCurrent(@ptrCast(*const IPAT, self), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPAT.VTable, self.vtable).ConvertNextToCurrent(@ptrCast(*const IPAT, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICAT_Value = @import("../zig.zig").Guid.initString("7c6995fb-2a31-4bd7-953e-b1ad7fb7d31c");
pub const IID_ICAT = &IID_ICAT_Value;
pub const ICAT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const ICAT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const ICAT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const ICAT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const ICAT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const ICAT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: fn(
            self: *const ICAT,
            hNextTableAvailable: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: fn(
            self: *const ICAT,
            dwTimeout: u32,
            ppCAT: ?*?*ICAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: fn(
            self: *const ICAT,
            hNextTableIsCurrent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: fn(
            self: *const ICAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICAT.VTable, self.vtable).Initialize(@ptrCast(*const ICAT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICAT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const ICAT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICAT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const ICAT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICAT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const ICAT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICAT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const ICAT, self), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICAT.VTable, self.vtable).RegisterForNextTable(@ptrCast(*const ICAT, self), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetNextTable(self: *const T, dwTimeout: u32, ppCAT: ?*?*ICAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICAT.VTable, self.vtable).GetNextTable(@ptrCast(*const ICAT, self), dwTimeout, ppCAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICAT.VTable, self.vtable).RegisterForWhenCurrent(@ptrCast(*const ICAT, self), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICAT.VTable, self.vtable).ConvertNextToCurrent(@ptrCast(*const ICAT, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMT_Value = @import("../zig.zig").Guid.initString("01f3b398-9527-4736-94db-5195878e97a8");
pub const IID_IPMT = &IID_IPMT_Value;
pub const IPMT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IPMT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgramNumber: fn(
            self: *const IPMT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IPMT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPcrPid: fn(
            self: *const IPMT,
            pPidVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IPMT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IPMT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IPMT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IPMT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStreamType: fn(
            self: *const IPMT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordElementaryPid: fn(
            self: *const IPMT,
            dwRecordIndex: u32,
            pPidVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IPMT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IPMT,
            dwRecordIndex: u32,
            dwDescIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IPMT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryServiceGatewayInfo: fn(
            self: *const IPMT,
            ppDSMCCList: ?*?*DSMCC_ELEMENT,
            puiCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMPEInfo: fn(
            self: *const IPMT,
            ppMPEList: ?*?*MPE_ELEMENT,
            puiCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: fn(
            self: *const IPMT,
            hNextTableAvailable: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: fn(
            self: *const IPMT,
            ppPMT: ?*?*IPMT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: fn(
            self: *const IPMT,
            hNextTableIsCurrent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: fn(
            self: *const IPMT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).Initialize(@ptrCast(*const IPMT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetProgramNumber(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetProgramNumber(@ptrCast(*const IPMT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IPMT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetPcrPid(self: *const T, pPidVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetPcrPid(@ptrCast(*const IPMT, self), pPidVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IPMT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IPMT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IPMT, self), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetCountOfRecords(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IPMT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordStreamType(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetRecordStreamType(@ptrCast(*const IPMT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordElementaryPid(self: *const T, dwRecordIndex: u32, pPidVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetRecordElementaryPid(@ptrCast(*const IPMT, self), dwRecordIndex, pPidVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IPMT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwDescIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IPMT, self), dwRecordIndex, dwDescIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IPMT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_QueryServiceGatewayInfo(self: *const T, ppDSMCCList: ?*?*DSMCC_ELEMENT, puiCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).QueryServiceGatewayInfo(@ptrCast(*const IPMT, self), ppDSMCCList, puiCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_QueryMPEInfo(self: *const T, ppMPEList: ?*?*MPE_ELEMENT, puiCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).QueryMPEInfo(@ptrCast(*const IPMT, self), ppMPEList, puiCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).RegisterForNextTable(@ptrCast(*const IPMT, self), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetNextTable(self: *const T, ppPMT: ?*?*IPMT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).GetNextTable(@ptrCast(*const IPMT, self), ppPMT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).RegisterForWhenCurrent(@ptrCast(*const IPMT, self), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMT.VTable, self.vtable).ConvertNextToCurrent(@ptrCast(*const IPMT, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITSDT_Value = @import("../zig.zig").Guid.initString("d19bdb43-405b-4a7c-a791-c89110c33165");
pub const IID_ITSDT = &IID_ITSDT_Value;
pub const ITSDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const ITSDT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const ITSDT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const ITSDT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const ITSDT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const ITSDT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: fn(
            self: *const ITSDT,
            hNextTableAvailable: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: fn(
            self: *const ITSDT,
            ppTSDT: ?*?*ITSDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: fn(
            self: *const ITSDT,
            hNextTableIsCurrent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: fn(
            self: *const ITSDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITSDT.VTable, self.vtable).Initialize(@ptrCast(*const ITSDT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITSDT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const ITSDT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITSDT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const ITSDT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITSDT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const ITSDT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITSDT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const ITSDT, self), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITSDT.VTable, self.vtable).RegisterForNextTable(@ptrCast(*const ITSDT, self), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetNextTable(self: *const T, ppTSDT: ?*?*ITSDT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITSDT.VTable, self.vtable).GetNextTable(@ptrCast(*const ITSDT, self), ppTSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITSDT.VTable, self.vtable).RegisterForWhenCurrent(@ptrCast(*const ITSDT, self), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITSDT.VTable, self.vtable).ConvertNextToCurrent(@ptrCast(*const ITSDT, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPSITables_Value = @import("../zig.zig").Guid.initString("919f24c5-7b14-42ac-a4b0-2ae08daf00ac");
pub const IID_IPSITables = &IID_IPSITables_Value;
pub const IPSITables = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTable: fn(
            self: *const IPSITables,
            dwTSID: u32,
            dwTID_PID: u32,
            dwHashedVer: u32,
            dwPara4: u32,
            ppIUnknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPSITables_GetTable(self: *const T, dwTSID: u32, dwTID_PID: u32, dwHashedVer: u32, dwPara4: u32, ppIUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPSITables.VTable, self.vtable).GetTable(@ptrCast(*const IPSITables, self), dwTSID, dwTID_PID, dwHashedVer, dwPara4, ppIUnknown);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAtscPsipParser_Value = @import("../zig.zig").Guid.initString("b2c98995-5eb2-4fb1-b406-f3e8e2026a9a");
pub const IID_IAtscPsipParser = &IID_IAtscPsipParser_Value;
pub const IAtscPsipParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IAtscPsipParser,
            punkMpeg2Data: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPAT: fn(
            self: *const IAtscPsipParser,
            ppPAT: ?*?*IPAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAT: fn(
            self: *const IAtscPsipParser,
            dwTimeout: u32,
            ppCAT: ?*?*ICAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPMT: fn(
            self: *const IAtscPsipParser,
            pid: u16,
            pwProgramNumber: ?*u16,
            ppPMT: ?*?*IPMT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSDT: fn(
            self: *const IAtscPsipParser,
            ppTSDT: ?*?*ITSDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMGT: fn(
            self: *const IAtscPsipParser,
            ppMGT: ?*?*IATSC_MGT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVCT: fn(
            self: *const IAtscPsipParser,
            tableId: u8,
            fGetNextTable: BOOL,
            ppVCT: ?*?*IATSC_VCT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEIT: fn(
            self: *const IAtscPsipParser,
            pid: u16,
            pwSourceId: ?*u16,
            dwTimeout: u32,
            ppEIT: ?*?*IATSC_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetETT: fn(
            self: *const IAtscPsipParser,
            pid: u16,
            wSourceId: ?*u16,
            pwEventId: ?*u16,
            ppETT: ?*?*IATSC_ETT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSTT: fn(
            self: *const IAtscPsipParser,
            ppSTT: ?*?*IATSC_STT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEAS: fn(
            self: *const IAtscPsipParser,
            pid: u16,
            ppEAS: ?*?*ISCTE_EAS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_Initialize(self: *const T, punkMpeg2Data: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).Initialize(@ptrCast(*const IAtscPsipParser, self), punkMpeg2Data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetPAT(self: *const T, ppPAT: ?*?*IPAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetPAT(@ptrCast(*const IAtscPsipParser, self), ppPAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetCAT(self: *const T, dwTimeout: u32, ppCAT: ?*?*ICAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetCAT(@ptrCast(*const IAtscPsipParser, self), dwTimeout, ppCAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetPMT(self: *const T, pid: u16, pwProgramNumber: ?*u16, ppPMT: ?*?*IPMT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetPMT(@ptrCast(*const IAtscPsipParser, self), pid, pwProgramNumber, ppPMT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetTSDT(self: *const T, ppTSDT: ?*?*ITSDT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetTSDT(@ptrCast(*const IAtscPsipParser, self), ppTSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetMGT(self: *const T, ppMGT: ?*?*IATSC_MGT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetMGT(@ptrCast(*const IAtscPsipParser, self), ppMGT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetVCT(self: *const T, tableId: u8, fGetNextTable: BOOL, ppVCT: ?*?*IATSC_VCT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetVCT(@ptrCast(*const IAtscPsipParser, self), tableId, fGetNextTable, ppVCT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetEIT(self: *const T, pid: u16, pwSourceId: ?*u16, dwTimeout: u32, ppEIT: ?*?*IATSC_EIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetEIT(@ptrCast(*const IAtscPsipParser, self), pid, pwSourceId, dwTimeout, ppEIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetETT(self: *const T, pid: u16, wSourceId: ?*u16, pwEventId: ?*u16, ppETT: ?*?*IATSC_ETT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetETT(@ptrCast(*const IAtscPsipParser, self), pid, wSourceId, pwEventId, ppETT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetSTT(self: *const T, ppSTT: ?*?*IATSC_STT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetSTT(@ptrCast(*const IAtscPsipParser, self), ppSTT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetEAS(self: *const T, pid: u16, ppEAS: ?*?*ISCTE_EAS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscPsipParser.VTable, self.vtable).GetEAS(@ptrCast(*const IAtscPsipParser, self), pid, ppEAS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_MGT_Value = @import("../zig.zig").Guid.initString("8877dabd-c137-4073-97e3-779407a5d87a");
pub const IID_IATSC_MGT = &IID_IATSC_MGT_Value;
pub const IATSC_MGT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IATSC_MGT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IATSC_MGT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: fn(
            self: *const IATSC_MGT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IATSC_MGT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordType: fn(
            self: *const IATSC_MGT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTypePid: fn(
            self: *const IATSC_MGT,
            dwRecordIndex: u32,
            ppidVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordVersionNumber: fn(
            self: *const IATSC_MGT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IATSC_MGT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IATSC_MGT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IATSC_MGT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IATSC_MGT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IATSC_MGT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IATSC_MGT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).Initialize(@ptrCast(*const IATSC_MGT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IATSC_MGT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetProtocolVersion(@ptrCast(*const IATSC_MGT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IATSC_MGT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordType(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetRecordType(@ptrCast(*const IATSC_MGT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordTypePid(self: *const T, dwRecordIndex: u32, ppidVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetRecordTypePid(@ptrCast(*const IATSC_MGT, self), dwRecordIndex, ppidVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordVersionNumber(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetRecordVersionNumber(@ptrCast(*const IATSC_MGT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IATSC_MGT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IATSC_MGT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IATSC_MGT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IATSC_MGT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IATSC_MGT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_MGT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IATSC_MGT, self), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_VCT_Value = @import("../zig.zig").Guid.initString("26879a18-32f9-46c6-91f0-fb6479270e8c");
pub const IID_IATSC_VCT = &IID_IATSC_VCT_Value;
pub const IATSC_VCT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IATSC_VCT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IATSC_VCT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: fn(
            self: *const IATSC_VCT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: fn(
            self: *const IATSC_VCT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IATSC_VCT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordName: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pwsName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordMajorChannelNumber: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordMinorChannelNumber: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModulationMode: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCarrierFrequency: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransportStreamId: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordProgramNumber: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEtmLocation: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsAccessControlledBitSet: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsHiddenBitSet: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsPathSelectBitSet: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsOutOfBandBitSet: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordIsHideGuideBitSet: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceType: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordSourceId: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IATSC_VCT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IATSC_VCT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IATSC_VCT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IATSC_VCT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).Initialize(@ptrCast(*const IATSC_VCT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IATSC_VCT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetTransportStreamId(@ptrCast(*const IATSC_VCT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetProtocolVersion(@ptrCast(*const IATSC_VCT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IATSC_VCT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordName(self: *const T, dwRecordIndex: u32, pwsName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordName(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pwsName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordMajorChannelNumber(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordMajorChannelNumber(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordMinorChannelNumber(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordMinorChannelNumber(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordModulationMode(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordModulationMode(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordCarrierFrequency(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordCarrierFrequency(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordTransportStreamId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordTransportStreamId(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordProgramNumber(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordProgramNumber(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordEtmLocation(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordEtmLocation(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsAccessControlledBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordIsAccessControlledBitSet(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsHiddenBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordIsHiddenBitSet(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsPathSelectBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordIsPathSelectBitSet(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsOutOfBandBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordIsOutOfBandBitSet(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsHideGuideBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordIsHideGuideBitSet(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordServiceType(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordServiceType(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordSourceId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordSourceId(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IATSC_VCT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IATSC_VCT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IATSC_VCT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_VCT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IATSC_VCT, self), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_EIT_Value = @import("../zig.zig").Guid.initString("d7c212d7-76a2-4b4b-aa56-846879a80096");
pub const IID_IATSC_EIT = &IID_IATSC_EIT_Value;
pub const IATSC_EIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IATSC_EIT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IATSC_EIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceId: fn(
            self: *const IATSC_EIT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: fn(
            self: *const IATSC_EIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IATSC_EIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEventId: fn(
            self: *const IATSC_EIT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStartTime: fn(
            self: *const IATSC_EIT,
            dwRecordIndex: u32,
            pmdtVal: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEtmLocation: fn(
            self: *const IATSC_EIT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDuration: fn(
            self: *const IATSC_EIT,
            dwRecordIndex: u32,
            pmdVal: ?*MPEG_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTitleText: fn(
            self: *const IATSC_EIT,
            dwRecordIndex: u32,
            pdwLength: ?*u32,
            ppText: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IATSC_EIT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IATSC_EIT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IATSC_EIT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).Initialize(@ptrCast(*const IATSC_EIT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IATSC_EIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetSourceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetSourceId(@ptrCast(*const IATSC_EIT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetProtocolVersion(@ptrCast(*const IATSC_EIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IATSC_EIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordEventId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetRecordEventId(@ptrCast(*const IATSC_EIT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordStartTime(self: *const T, dwRecordIndex: u32, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetRecordStartTime(@ptrCast(*const IATSC_EIT, self), dwRecordIndex, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordEtmLocation(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetRecordEtmLocation(@ptrCast(*const IATSC_EIT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordDuration(self: *const T, dwRecordIndex: u32, pmdVal: ?*MPEG_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetRecordDuration(@ptrCast(*const IATSC_EIT, self), dwRecordIndex, pmdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordTitleText(self: *const T, dwRecordIndex: u32, pdwLength: ?*u32, ppText: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetRecordTitleText(@ptrCast(*const IATSC_EIT, self), dwRecordIndex, pdwLength, ppText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IATSC_EIT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IATSC_EIT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_EIT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IATSC_EIT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_ETT_Value = @import("../zig.zig").Guid.initString("5a142cc9-b8cf-4a86-a040-e9cadf3ef3e7");
pub const IID_IATSC_ETT = &IID_IATSC_ETT_Value;
pub const IATSC_ETT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IATSC_ETT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IATSC_ETT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: fn(
            self: *const IATSC_ETT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEtmId: fn(
            self: *const IATSC_ETT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtendedMessageText: fn(
            self: *const IATSC_ETT,
            pdwLength: ?*u32,
            ppText: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_ETT.VTable, self.vtable).Initialize(@ptrCast(*const IATSC_ETT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_ETT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IATSC_ETT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_ETT.VTable, self.vtable).GetProtocolVersion(@ptrCast(*const IATSC_ETT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_GetEtmId(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_ETT.VTable, self.vtable).GetEtmId(@ptrCast(*const IATSC_ETT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_GetExtendedMessageText(self: *const T, pdwLength: ?*u32, ppText: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_ETT.VTable, self.vtable).GetExtendedMessageText(@ptrCast(*const IATSC_ETT, self), pdwLength, ppText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_STT_Value = @import("../zig.zig").Guid.initString("6bf42423-217d-4d6f-81e1-3a7b360ec896");
pub const IID_IATSC_STT = &IID_IATSC_STT_Value;
pub const IATSC_STT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IATSC_STT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: fn(
            self: *const IATSC_STT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemTime: fn(
            self: *const IATSC_STT,
            pmdtSystemTime: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGpsUtcOffset: fn(
            self: *const IATSC_STT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDaylightSavings: fn(
            self: *const IATSC_STT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IATSC_STT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IATSC_STT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IATSC_STT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_STT.VTable, self.vtable).Initialize(@ptrCast(*const IATSC_STT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_STT.VTable, self.vtable).GetProtocolVersion(@ptrCast(*const IATSC_STT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetSystemTime(self: *const T, pmdtSystemTime: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_STT.VTable, self.vtable).GetSystemTime(@ptrCast(*const IATSC_STT, self), pmdtSystemTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetGpsUtcOffset(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_STT.VTable, self.vtable).GetGpsUtcOffset(@ptrCast(*const IATSC_STT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetDaylightSavings(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_STT.VTable, self.vtable).GetDaylightSavings(@ptrCast(*const IATSC_STT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_STT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IATSC_STT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_STT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IATSC_STT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IATSC_STT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IATSC_STT, self), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISCTE_EAS_Value = @import("../zig.zig").Guid.initString("1ff544d6-161d-4fae-9faa-4f9f492ae999");
pub const IID_ISCTE_EAS = &IID_ISCTE_EAS_Value;
pub const ISCTE_EAS = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const ISCTE_EAS,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSequencyNumber: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtocolVersion: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEASEventID: fn(
            self: *const ISCTE_EAS,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginatorCode: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEASEventCodeLen: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEASEventCode: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawNatureOfActivationTextLen: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawNatureOfActivationText: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNatureOfActivationText: fn(
            self: *const ISCTE_EAS,
            bstrIS0639code: ?BSTR,
            pbstrString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeRemaining: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartTime: fn(
            self: *const ISCTE_EAS,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuration: fn(
            self: *const ISCTE_EAS,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlertPriority: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsOOBSourceID: fn(
            self: *const ISCTE_EAS,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsMajor: fn(
            self: *const ISCTE_EAS,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsMinor: fn(
            self: *const ISCTE_EAS,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsAudioOOBSourceID: fn(
            self: *const ISCTE_EAS,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlertText: fn(
            self: *const ISCTE_EAS,
            bstrIS0639code: ?BSTR,
            pbstrString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawAlertTextLen: fn(
            self: *const ISCTE_EAS,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawAlertText: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocationCount: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocationCodes: fn(
            self: *const ISCTE_EAS,
            bIndex: u8,
            pbState: ?*u8,
            pbCountySubdivision: ?*u8,
            pwCounty: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionCount: fn(
            self: *const ISCTE_EAS,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionService: fn(
            self: *const ISCTE_EAS,
            bIndex: u8,
            pbIBRef: ?*u8,
            pwFirst: ?*u16,
            pwSecond: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const ISCTE_EAS,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const ISCTE_EAS,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const ISCTE_EAS,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).Initialize(@ptrCast(*const ISCTE_EAS, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetVersionNumber(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetSequencyNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetSequencyNumber(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetProtocolVersion(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetEASEventID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetEASEventID(@ptrCast(*const ISCTE_EAS, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetOriginatorCode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetOriginatorCode(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetEASEventCodeLen(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetEASEventCodeLen(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetEASEventCode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetEASEventCode(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetRawNatureOfActivationTextLen(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetRawNatureOfActivationTextLen(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetRawNatureOfActivationText(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetRawNatureOfActivationText(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetNatureOfActivationText(self: *const T, bstrIS0639code: ?BSTR, pbstrString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetNatureOfActivationText(@ptrCast(*const ISCTE_EAS, self), bstrIS0639code, pbstrString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetTimeRemaining(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetTimeRemaining(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetStartTime(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetStartTime(@ptrCast(*const ISCTE_EAS, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDuration(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetDuration(@ptrCast(*const ISCTE_EAS, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetAlertPriority(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetAlertPriority(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDetailsOOBSourceID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetDetailsOOBSourceID(@ptrCast(*const ISCTE_EAS, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDetailsMajor(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetDetailsMajor(@ptrCast(*const ISCTE_EAS, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDetailsMinor(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetDetailsMinor(@ptrCast(*const ISCTE_EAS, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDetailsAudioOOBSourceID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetDetailsAudioOOBSourceID(@ptrCast(*const ISCTE_EAS, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetAlertText(self: *const T, bstrIS0639code: ?BSTR, pbstrString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetAlertText(@ptrCast(*const ISCTE_EAS, self), bstrIS0639code, pbstrString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetRawAlertTextLen(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetRawAlertTextLen(@ptrCast(*const ISCTE_EAS, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetRawAlertText(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetRawAlertText(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetLocationCount(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetLocationCount(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetLocationCodes(self: *const T, bIndex: u8, pbState: ?*u8, pbCountySubdivision: ?*u8, pwCounty: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetLocationCodes(@ptrCast(*const ISCTE_EAS, self), bIndex, pbState, pbCountySubdivision, pwCounty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetExceptionCount(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetExceptionCount(@ptrCast(*const ISCTE_EAS, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetExceptionService(self: *const T, bIndex: u8, pbIBRef: ?*u8, pwFirst: ?*u16, pwSecond: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetExceptionService(@ptrCast(*const ISCTE_EAS, self), bIndex, pbIBRef, pwFirst, pwSecond);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const ISCTE_EAS, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const ISCTE_EAS, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISCTE_EAS.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const ISCTE_EAS, self), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAtscContentAdvisoryDescriptor_Value = @import("../zig.zig").Guid.initString("ff76e60c-0283-43ea-ba32-b422238547ee");
pub const IID_IAtscContentAdvisoryDescriptor = &IID_IAtscContentAdvisoryDescriptor_Value;
pub const IAtscContentAdvisoryDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IAtscContentAdvisoryDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IAtscContentAdvisoryDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRatingRegionCount: fn(
            self: *const IAtscContentAdvisoryDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatingRegion: fn(
            self: *const IAtscContentAdvisoryDescriptor,
            bIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatedDimensions: fn(
            self: *const IAtscContentAdvisoryDescriptor,
            bIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatingDimension: fn(
            self: *const IAtscContentAdvisoryDescriptor,
            bIndexOuter: u8,
            bIndexInner: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatingValue: fn(
            self: *const IAtscContentAdvisoryDescriptor,
            bIndexOuter: u8,
            bIndexInner: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRatingDescriptionText: fn(
            self: *const IAtscContentAdvisoryDescriptor,
            bIndex: u8,
            pbLength: ?*u8,
            ppText: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscContentAdvisoryDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IAtscContentAdvisoryDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscContentAdvisoryDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IAtscContentAdvisoryDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRatingRegionCount(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscContentAdvisoryDescriptor.VTable, self.vtable).GetRatingRegionCount(@ptrCast(*const IAtscContentAdvisoryDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatingRegion(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscContentAdvisoryDescriptor.VTable, self.vtable).GetRecordRatingRegion(@ptrCast(*const IAtscContentAdvisoryDescriptor, self), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatedDimensions(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscContentAdvisoryDescriptor.VTable, self.vtable).GetRecordRatedDimensions(@ptrCast(*const IAtscContentAdvisoryDescriptor, self), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatingDimension(self: *const T, bIndexOuter: u8, bIndexInner: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscContentAdvisoryDescriptor.VTable, self.vtable).GetRecordRatingDimension(@ptrCast(*const IAtscContentAdvisoryDescriptor, self), bIndexOuter, bIndexInner, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatingValue(self: *const T, bIndexOuter: u8, bIndexInner: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscContentAdvisoryDescriptor.VTable, self.vtable).GetRecordRatingValue(@ptrCast(*const IAtscContentAdvisoryDescriptor, self), bIndexOuter, bIndexInner, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatingDescriptionText(self: *const T, bIndex: u8, pbLength: ?*u8, ppText: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAtscContentAdvisoryDescriptor.VTable, self.vtable).GetRecordRatingDescriptionText(@ptrCast(*const IAtscContentAdvisoryDescriptor, self), bIndex, pbLength, ppText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICaptionServiceDescriptor_Value = @import("../zig.zig").Guid.initString("40834007-6834-46f0-bd45-d5f6a6be258c");
pub const IID_ICaptionServiceDescriptor = &IID_ICaptionServiceDescriptor_Value;
pub const ICaptionServiceDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfServices: fn(
            self: *const ICaptionServiceDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: fn(
            self: *const ICaptionServiceDescriptor,
            bIndex: u8,
            LangCode: *[3]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaptionServiceNumber: fn(
            self: *const ICaptionServiceDescriptor,
            bIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCCType: fn(
            self: *const ICaptionServiceDescriptor,
            bIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEasyReader: fn(
            self: *const ICaptionServiceDescriptor,
            bIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWideAspectRatio: fn(
            self: *const ICaptionServiceDescriptor,
            bIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetNumberOfServices(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptionServiceDescriptor.VTable, self.vtable).GetNumberOfServices(@ptrCast(*const ICaptionServiceDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetLanguageCode(self: *const T, bIndex: u8, LangCode: *[3]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptionServiceDescriptor.VTable, self.vtable).GetLanguageCode(@ptrCast(*const ICaptionServiceDescriptor, self), bIndex, LangCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetCaptionServiceNumber(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptionServiceDescriptor.VTable, self.vtable).GetCaptionServiceNumber(@ptrCast(*const ICaptionServiceDescriptor, self), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetCCType(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptionServiceDescriptor.VTable, self.vtable).GetCCType(@ptrCast(*const ICaptionServiceDescriptor, self), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetEasyReader(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptionServiceDescriptor.VTable, self.vtable).GetEasyReader(@ptrCast(*const ICaptionServiceDescriptor, self), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetWideAspectRatio(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICaptionServiceDescriptor.VTable, self.vtable).GetWideAspectRatio(@ptrCast(*const ICaptionServiceDescriptor, self), bIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IServiceLocationDescriptor_Value = @import("../zig.zig").Guid.initString("58c3c827-9d91-4215-bff3-820a49f0904c");
pub const IID_IServiceLocationDescriptor = &IID_IServiceLocationDescriptor_Value;
pub const IServiceLocationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPCR_PID: fn(
            self: *const IServiceLocationDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfElements: fn(
            self: *const IServiceLocationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElementStreamType: fn(
            self: *const IServiceLocationDescriptor,
            bIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElementPID: fn(
            self: *const IServiceLocationDescriptor,
            bIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElementLanguageCode: fn(
            self: *const IServiceLocationDescriptor,
            bIndex: u8,
            LangCode: *[3]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetPCR_PID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServiceLocationDescriptor.VTable, self.vtable).GetPCR_PID(@ptrCast(*const IServiceLocationDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetNumberOfElements(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServiceLocationDescriptor.VTable, self.vtable).GetNumberOfElements(@ptrCast(*const IServiceLocationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetElementStreamType(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServiceLocationDescriptor.VTable, self.vtable).GetElementStreamType(@ptrCast(*const IServiceLocationDescriptor, self), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetElementPID(self: *const T, bIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServiceLocationDescriptor.VTable, self.vtable).GetElementPID(@ptrCast(*const IServiceLocationDescriptor, self), bIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetElementLanguageCode(self: *const T, bIndex: u8, LangCode: *[3]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServiceLocationDescriptor.VTable, self.vtable).GetElementLanguageCode(@ptrCast(*const IServiceLocationDescriptor, self), bIndex, LangCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAttributeSet_Value = @import("../zig.zig").Guid.initString("583ec3cc-4960-4857-982b-41a33ea0a006");
pub const IID_IAttributeSet = &IID_IAttributeSet_Value;
pub const IAttributeSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAttrib: fn(
            self: *const IAttributeSet,
            guidAttribute: Guid,
            pbAttribute: ?*u8,
            dwAttributeLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttributeSet_SetAttrib(self: *const T, guidAttribute: Guid, pbAttribute: ?*u8, dwAttributeLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttributeSet.VTable, self.vtable).SetAttrib(@ptrCast(*const IAttributeSet, self), guidAttribute, pbAttribute, dwAttributeLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAttributeGet_Value = @import("../zig.zig").Guid.initString("52dbd1ec-e48f-4528-9232-f442a68f0ae1");
pub const IID_IAttributeGet = &IID_IAttributeGet_Value;
pub const IAttributeGet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IAttributeGet,
            plCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttribIndexed: fn(
            self: *const IAttributeGet,
            lIndex: i32,
            pguidAttribute: ?*Guid,
            pbAttribute: ?*u8,
            pdwAttributeLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttrib: fn(
            self: *const IAttributeGet,
            guidAttribute: Guid,
            pbAttribute: ?*u8,
            pdwAttributeLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttributeGet_GetCount(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttributeGet.VTable, self.vtable).GetCount(@ptrCast(*const IAttributeGet, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttributeGet_GetAttribIndexed(self: *const T, lIndex: i32, pguidAttribute: ?*Guid, pbAttribute: ?*u8, pdwAttributeLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttributeGet.VTable, self.vtable).GetAttribIndexed(@ptrCast(*const IAttributeGet, self), lIndex, pguidAttribute, pbAttribute, pdwAttributeLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttributeGet_GetAttrib(self: *const T, guidAttribute: Guid, pbAttribute: ?*u8, pdwAttributeLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttributeGet.VTable, self.vtable).GetAttrib(@ptrCast(*const IAttributeGet, self), guidAttribute, pbAttribute, pdwAttributeLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const UDCR_TAG = extern struct {
    bVersion: u8,
    KID: [25]u8,
    ullBaseCounter: u64,
    ullBaseCounterRange: u64,
    fScrambled: BOOL,
    bStreamMark: u8,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const PIC_SEQ_SAMPLE = extern struct {
    _bitfield: u32,
};

pub const SAMPLE_SEQ_OFFSET = extern struct {
    _bitfield: u32,
};

pub const VA_VIDEO_FORMAT = enum(i32) {
    COMPONENT = 0,
    PAL = 1,
    NTSC = 2,
    SECAM = 3,
    MAC = 4,
    UNSPECIFIED = 5,
};
pub const VA_VIDEO_COMPONENT = VA_VIDEO_FORMAT.COMPONENT;
pub const VA_VIDEO_PAL = VA_VIDEO_FORMAT.PAL;
pub const VA_VIDEO_NTSC = VA_VIDEO_FORMAT.NTSC;
pub const VA_VIDEO_SECAM = VA_VIDEO_FORMAT.SECAM;
pub const VA_VIDEO_MAC = VA_VIDEO_FORMAT.MAC;
pub const VA_VIDEO_UNSPECIFIED = VA_VIDEO_FORMAT.UNSPECIFIED;

pub const VA_COLOR_PRIMARIES = enum(i32) {
    ITU_R_BT_709 = 1,
    UNSPECIFIED = 2,
    ITU_R_BT_470_SYSTEM_M = 4,
    ITU_R_BT_470_SYSTEM_B_G = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    H264_GENERIC_FILM = 8,
};
pub const VA_PRIMARIES_ITU_R_BT_709 = VA_COLOR_PRIMARIES.ITU_R_BT_709;
pub const VA_PRIMARIES_UNSPECIFIED = VA_COLOR_PRIMARIES.UNSPECIFIED;
pub const VA_PRIMARIES_ITU_R_BT_470_SYSTEM_M = VA_COLOR_PRIMARIES.ITU_R_BT_470_SYSTEM_M;
pub const VA_PRIMARIES_ITU_R_BT_470_SYSTEM_B_G = VA_COLOR_PRIMARIES.ITU_R_BT_470_SYSTEM_B_G;
pub const VA_PRIMARIES_SMPTE_170M = VA_COLOR_PRIMARIES.SMPTE_170M;
pub const VA_PRIMARIES_SMPTE_240M = VA_COLOR_PRIMARIES.SMPTE_240M;
pub const VA_PRIMARIES_H264_GENERIC_FILM = VA_COLOR_PRIMARIES.H264_GENERIC_FILM;

pub const VA_TRANSFER_CHARACTERISTICS = enum(i32) {
    ITU_R_BT_709 = 1,
    UNSPECIFIED = 2,
    ITU_R_BT_470_SYSTEM_M = 4,
    ITU_R_BT_470_SYSTEM_B_G = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    LINEAR = 8,
    H264_LOG_100_TO_1 = 9,
    H264_LOG_316_TO_1 = 10,
};
pub const VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_709 = VA_TRANSFER_CHARACTERISTICS.ITU_R_BT_709;
pub const VA_TRANSFER_CHARACTERISTICS_UNSPECIFIED = VA_TRANSFER_CHARACTERISTICS.UNSPECIFIED;
pub const VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_M = VA_TRANSFER_CHARACTERISTICS.ITU_R_BT_470_SYSTEM_M;
pub const VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_B_G = VA_TRANSFER_CHARACTERISTICS.ITU_R_BT_470_SYSTEM_B_G;
pub const VA_TRANSFER_CHARACTERISTICS_SMPTE_170M = VA_TRANSFER_CHARACTERISTICS.SMPTE_170M;
pub const VA_TRANSFER_CHARACTERISTICS_SMPTE_240M = VA_TRANSFER_CHARACTERISTICS.SMPTE_240M;
pub const VA_TRANSFER_CHARACTERISTICS_LINEAR = VA_TRANSFER_CHARACTERISTICS.LINEAR;
pub const VA_TRANSFER_CHARACTERISTICS_H264_LOG_100_TO_1 = VA_TRANSFER_CHARACTERISTICS.H264_LOG_100_TO_1;
pub const VA_TRANSFER_CHARACTERISTICS_H264_LOG_316_TO_1 = VA_TRANSFER_CHARACTERISTICS.H264_LOG_316_TO_1;

pub const VA_MATRIX_COEFFICIENTS = enum(i32) {
    H264_RGB = 0,
    ITU_R_BT_709 = 1,
    UNSPECIFIED = 2,
    FCC = 4,
    ITU_R_BT_470_SYSTEM_B_G = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    H264_YCgCo = 8,
};
pub const VA_MATRIX_COEFF_H264_RGB = VA_MATRIX_COEFFICIENTS.H264_RGB;
pub const VA_MATRIX_COEFF_ITU_R_BT_709 = VA_MATRIX_COEFFICIENTS.ITU_R_BT_709;
pub const VA_MATRIX_COEFF_UNSPECIFIED = VA_MATRIX_COEFFICIENTS.UNSPECIFIED;
pub const VA_MATRIX_COEFF_FCC = VA_MATRIX_COEFFICIENTS.FCC;
pub const VA_MATRIX_COEFF_ITU_R_BT_470_SYSTEM_B_G = VA_MATRIX_COEFFICIENTS.ITU_R_BT_470_SYSTEM_B_G;
pub const VA_MATRIX_COEFF_SMPTE_170M = VA_MATRIX_COEFFICIENTS.SMPTE_170M;
pub const VA_MATRIX_COEFF_SMPTE_240M = VA_MATRIX_COEFFICIENTS.SMPTE_240M;
pub const VA_MATRIX_COEFF_H264_YCgCo = VA_MATRIX_COEFFICIENTS.H264_YCgCo;

pub const VA_OPTIONAL_VIDEO_PROPERTIES = extern struct {
    dwPictureHeight: u16,
    dwPictureWidth: u16,
    dwAspectRatioX: u16,
    dwAspectRatioY: u16,
    VAVideoFormat: VA_VIDEO_FORMAT,
    VAColorPrimaries: VA_COLOR_PRIMARIES,
    VATransferCharacteristics: VA_TRANSFER_CHARACTERISTICS,
    VAMatrixCoefficients: VA_MATRIX_COEFFICIENTS,
};

pub const TRANSPORT_PROPERTIES = extern struct {
    PID: u32,
    PCR: i64,
    Fields: extern union {
        pub const _Others = extern struct {
            _bitfield: i64,
        };
        Others: _Others,
        Value: i64,
    },
};

pub const PBDA_TAG_ATTRIBUTE = extern struct {
    TableUUId: Guid,
    TableId: u8,
    VersionNo: u16,
    TableDataSize: u32,
    TableData: [1]u8,
};

pub const CAPTURE_STREAMTIME = extern struct {
    StreamTime: i64,
};

pub const DSHOW_STREAM_DESC = extern struct {
    VersionNo: u32,
    StreamId: u32,
    Default: BOOL,
    Creation: BOOL,
    Reserved: u32,
};

pub const SAMPLE_LIVE_STREAM_TIME = extern struct {
    qwStreamTime: u64,
    qwLiveTime: u64,
};

const CLSID_TIFLoad_Value = @import("../zig.zig").Guid.initString("14eb8748-1753-4393-95ae-4f7e7a87aad6");
pub const CLSID_TIFLoad = &CLSID_TIFLoad_Value;

pub const DVB_STRCONV_MODE = enum(i32) {
    DVB = 0,
    DVB_EMPHASIS = 1,
    DVB_WITHOUT_EMPHASIS = 2,
    ISDB = 3,
};
pub const STRCONV_MODE_DVB = DVB_STRCONV_MODE.DVB;
pub const STRCONV_MODE_DVB_EMPHASIS = DVB_STRCONV_MODE.DVB_EMPHASIS;
pub const STRCONV_MODE_DVB_WITHOUT_EMPHASIS = DVB_STRCONV_MODE.DVB_WITHOUT_EMPHASIS;
pub const STRCONV_MODE_ISDB = DVB_STRCONV_MODE.ISDB;

const IID_IDvbSiParser_Value = @import("../zig.zig").Guid.initString("b758a7bd-14dc-449d-b828-35909acb3b1e");
pub const IID_IDvbSiParser = &IID_IDvbSiParser_Value;
pub const IDvbSiParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDvbSiParser,
            punkMpeg2Data: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPAT: fn(
            self: *const IDvbSiParser,
            ppPAT: ?*?*IPAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAT: fn(
            self: *const IDvbSiParser,
            dwTimeout: u32,
            ppCAT: ?*?*ICAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPMT: fn(
            self: *const IDvbSiParser,
            pid: u16,
            pwProgramNumber: ?*u16,
            ppPMT: ?*?*IPMT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSDT: fn(
            self: *const IDvbSiParser,
            ppTSDT: ?*?*ITSDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNIT: fn(
            self: *const IDvbSiParser,
            tableId: u8,
            pwNetworkId: ?*u16,
            ppNIT: ?*?*IDVB_NIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSDT: fn(
            self: *const IDvbSiParser,
            tableId: u8,
            pwTransportStreamId: ?*u16,
            ppSDT: ?*?*IDVB_SDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEIT: fn(
            self: *const IDvbSiParser,
            tableId: u8,
            pwServiceId: ?*u16,
            ppEIT: ?*?*IDVB_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBAT: fn(
            self: *const IDvbSiParser,
            pwBouquetId: ?*u16,
            ppBAT: ?*?*IDVB_BAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRST: fn(
            self: *const IDvbSiParser,
            dwTimeout: u32,
            ppRST: ?*?*IDVB_RST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetST: fn(
            self: *const IDvbSiParser,
            pid: u16,
            dwTimeout: u32,
            ppST: ?*?*IDVB_ST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTDT: fn(
            self: *const IDvbSiParser,
            ppTDT: ?*?*IDVB_TDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTOT: fn(
            self: *const IDvbSiParser,
            ppTOT: ?*?*IDVB_TOT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDIT: fn(
            self: *const IDvbSiParser,
            dwTimeout: u32,
            ppDIT: ?*?*IDVB_DIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSIT: fn(
            self: *const IDvbSiParser,
            dwTimeout: u32,
            ppSIT: ?*?*IDVB_SIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_Initialize(self: *const T, punkMpeg2Data: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).Initialize(@ptrCast(*const IDvbSiParser, self), punkMpeg2Data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetPAT(self: *const T, ppPAT: ?*?*IPAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetPAT(@ptrCast(*const IDvbSiParser, self), ppPAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetCAT(self: *const T, dwTimeout: u32, ppCAT: ?*?*ICAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetCAT(@ptrCast(*const IDvbSiParser, self), dwTimeout, ppCAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetPMT(self: *const T, pid: u16, pwProgramNumber: ?*u16, ppPMT: ?*?*IPMT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetPMT(@ptrCast(*const IDvbSiParser, self), pid, pwProgramNumber, ppPMT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetTSDT(self: *const T, ppTSDT: ?*?*ITSDT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetTSDT(@ptrCast(*const IDvbSiParser, self), ppTSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetNIT(self: *const T, tableId: u8, pwNetworkId: ?*u16, ppNIT: ?*?*IDVB_NIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetNIT(@ptrCast(*const IDvbSiParser, self), tableId, pwNetworkId, ppNIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetSDT(self: *const T, tableId: u8, pwTransportStreamId: ?*u16, ppSDT: ?*?*IDVB_SDT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetSDT(@ptrCast(*const IDvbSiParser, self), tableId, pwTransportStreamId, ppSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetEIT(self: *const T, tableId: u8, pwServiceId: ?*u16, ppEIT: ?*?*IDVB_EIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetEIT(@ptrCast(*const IDvbSiParser, self), tableId, pwServiceId, ppEIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetBAT(self: *const T, pwBouquetId: ?*u16, ppBAT: ?*?*IDVB_BAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetBAT(@ptrCast(*const IDvbSiParser, self), pwBouquetId, ppBAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetRST(self: *const T, dwTimeout: u32, ppRST: ?*?*IDVB_RST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetRST(@ptrCast(*const IDvbSiParser, self), dwTimeout, ppRST);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetST(self: *const T, pid: u16, dwTimeout: u32, ppST: ?*?*IDVB_ST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetST(@ptrCast(*const IDvbSiParser, self), pid, dwTimeout, ppST);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetTDT(self: *const T, ppTDT: ?*?*IDVB_TDT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetTDT(@ptrCast(*const IDvbSiParser, self), ppTDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetTOT(self: *const T, ppTOT: ?*?*IDVB_TOT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetTOT(@ptrCast(*const IDvbSiParser, self), ppTOT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetDIT(self: *const T, dwTimeout: u32, ppDIT: ?*?*IDVB_DIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetDIT(@ptrCast(*const IDvbSiParser, self), dwTimeout, ppDIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetSIT(self: *const T, dwTimeout: u32, ppSIT: ?*?*IDVB_SIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser.VTable, self.vtable).GetSIT(@ptrCast(*const IDvbSiParser, self), dwTimeout, ppSIT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbSiParser2_Value = @import("../zig.zig").Guid.initString("0ac5525f-f816-42f4-93ba-4c0f32f46e54");
pub const IID_IDvbSiParser2 = &IID_IDvbSiParser2_Value;
pub const IDvbSiParser2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbSiParser.VTable,
        GetEIT2: fn(
            self: *const IDvbSiParser2,
            tableId: u8,
            pwServiceId: ?*u16,
            pbSegment: ?*u8,
            ppEIT: ?*?*IDVB_EIT2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbSiParser.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser2_GetEIT2(self: *const T, tableId: u8, pwServiceId: ?*u16, pbSegment: ?*u8, ppEIT: ?*?*IDVB_EIT2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSiParser2.VTable, self.vtable).GetEIT2(@ptrCast(*const IDvbSiParser2, self), tableId, pwServiceId, pbSegment, ppEIT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIsdbSiParser2_Value = @import("../zig.zig").Guid.initString("900e4bb7-18cd-453f-98be-3be6aa211772");
pub const IID_IIsdbSiParser2 = &IID_IIsdbSiParser2_Value;
pub const IIsdbSiParser2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbSiParser2.VTable,
        GetSDT: fn(
            self: *const IIsdbSiParser2,
            tableId: u8,
            pwTransportStreamId: ?*u16,
            ppSDT: ?*?*IISDB_SDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBIT: fn(
            self: *const IIsdbSiParser2,
            tableId: u8,
            pwOriginalNetworkId: ?*u16,
            ppBIT: ?*?*IISDB_BIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNBIT: fn(
            self: *const IIsdbSiParser2,
            tableId: u8,
            pwOriginalNetworkId: ?*u16,
            ppNBIT: ?*?*IISDB_NBIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLDT: fn(
            self: *const IIsdbSiParser2,
            tableId: u8,
            pwOriginalServiceId: ?*u16,
            ppLDT: ?*?*IISDB_LDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSDTT: fn(
            self: *const IIsdbSiParser2,
            tableId: u8,
            pwTableIdExt: ?*u16,
            ppSDTT: ?*?*IISDB_SDTT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCDT: fn(
            self: *const IIsdbSiParser2,
            tableId: u8,
            bSectionNumber: u8,
            pwDownloadDataId: ?*u16,
            ppCDT: ?*?*IISDB_CDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEMM: fn(
            self: *const IIsdbSiParser2,
            pid: u16,
            wTableIdExt: u16,
            ppEMM: ?*?*IISDB_EMM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbSiParser2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetSDT(self: *const T, tableId: u8, pwTransportStreamId: ?*u16, ppSDT: ?*?*IISDB_SDT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSiParser2.VTable, self.vtable).GetSDT(@ptrCast(*const IIsdbSiParser2, self), tableId, pwTransportStreamId, ppSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetBIT(self: *const T, tableId: u8, pwOriginalNetworkId: ?*u16, ppBIT: ?*?*IISDB_BIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSiParser2.VTable, self.vtable).GetBIT(@ptrCast(*const IIsdbSiParser2, self), tableId, pwOriginalNetworkId, ppBIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetNBIT(self: *const T, tableId: u8, pwOriginalNetworkId: ?*u16, ppNBIT: ?*?*IISDB_NBIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSiParser2.VTable, self.vtable).GetNBIT(@ptrCast(*const IIsdbSiParser2, self), tableId, pwOriginalNetworkId, ppNBIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetLDT(self: *const T, tableId: u8, pwOriginalServiceId: ?*u16, ppLDT: ?*?*IISDB_LDT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSiParser2.VTable, self.vtable).GetLDT(@ptrCast(*const IIsdbSiParser2, self), tableId, pwOriginalServiceId, ppLDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetSDTT(self: *const T, tableId: u8, pwTableIdExt: ?*u16, ppSDTT: ?*?*IISDB_SDTT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSiParser2.VTable, self.vtable).GetSDTT(@ptrCast(*const IIsdbSiParser2, self), tableId, pwTableIdExt, ppSDTT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetCDT(self: *const T, tableId: u8, bSectionNumber: u8, pwDownloadDataId: ?*u16, ppCDT: ?*?*IISDB_CDT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSiParser2.VTable, self.vtable).GetCDT(@ptrCast(*const IIsdbSiParser2, self), tableId, bSectionNumber, pwDownloadDataId, ppCDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetEMM(self: *const T, pid: u16, wTableIdExt: u16, ppEMM: ?*?*IISDB_EMM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSiParser2.VTable, self.vtable).GetEMM(@ptrCast(*const IIsdbSiParser2, self), pid, wTableIdExt, ppEMM);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_NIT_Value = @import("../zig.zig").Guid.initString("c64935f4-29e4-4e22-911a-63f7f55cb097");
pub const IID_IDVB_NIT = &IID_IDVB_NIT_Value;
pub const IDVB_NIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_NIT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IDVB_NIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkId: fn(
            self: *const IDVB_NIT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IDVB_NIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IDVB_NIT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IDVB_NIT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDVB_NIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransportStreamId: fn(
            self: *const IDVB_NIT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordOriginalNetworkId: fn(
            self: *const IDVB_NIT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IDVB_NIT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IDVB_NIT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IDVB_NIT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: fn(
            self: *const IDVB_NIT,
            hNextTableAvailable: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: fn(
            self: *const IDVB_NIT,
            ppNIT: ?*?*IDVB_NIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: fn(
            self: *const IDVB_NIT,
            hNextTableIsCurrent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: fn(
            self: *const IDVB_NIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: fn(
            self: *const IDVB_NIT,
            pdwVersionHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_NIT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IDVB_NIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetNetworkId(@ptrCast(*const IDVB_NIT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IDVB_NIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IDVB_NIT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IDVB_NIT, self), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDVB_NIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordTransportStreamId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetRecordTransportStreamId(@ptrCast(*const IDVB_NIT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordOriginalNetworkId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetRecordOriginalNetworkId(@ptrCast(*const IDVB_NIT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IDVB_NIT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IDVB_NIT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IDVB_NIT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).RegisterForNextTable(@ptrCast(*const IDVB_NIT, self), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetNextTable(self: *const T, ppNIT: ?*?*IDVB_NIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetNextTable(@ptrCast(*const IDVB_NIT, self), ppNIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).RegisterForWhenCurrent(@ptrCast(*const IDVB_NIT, self), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).ConvertNextToCurrent(@ptrCast(*const IDVB_NIT, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_NIT.VTable, self.vtable).GetVersionHash(@ptrCast(*const IDVB_NIT, self), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_SDT_Value = @import("../zig.zig").Guid.initString("02cad8d3-fe43-48e2-90bd-450ed9a8a5fd");
pub const IID_IDVB_SDT = &IID_IDVB_SDT_Value;
pub const IDVB_SDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_SDT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IDVB_SDT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: fn(
            self: *const IDVB_SDT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: fn(
            self: *const IDVB_SDT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDVB_SDT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: fn(
            self: *const IDVB_SDT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEITScheduleFlag: fn(
            self: *const IDVB_SDT,
            dwRecordIndex: u32,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEITPresentFollowingFlag: fn(
            self: *const IDVB_SDT,
            dwRecordIndex: u32,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRunningStatus: fn(
            self: *const IDVB_SDT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordFreeCAMode: fn(
            self: *const IDVB_SDT,
            dwRecordIndex: u32,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IDVB_SDT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IDVB_SDT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IDVB_SDT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: fn(
            self: *const IDVB_SDT,
            hNextTableAvailable: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: fn(
            self: *const IDVB_SDT,
            ppSDT: ?*?*IDVB_SDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: fn(
            self: *const IDVB_SDT,
            hNextTableIsCurrent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: fn(
            self: *const IDVB_SDT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: fn(
            self: *const IDVB_SDT,
            pdwVersionHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_SDT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IDVB_SDT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetTransportStreamId(@ptrCast(*const IDVB_SDT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetOriginalNetworkId(@ptrCast(*const IDVB_SDT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDVB_SDT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordServiceId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetRecordServiceId(@ptrCast(*const IDVB_SDT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordEITScheduleFlag(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetRecordEITScheduleFlag(@ptrCast(*const IDVB_SDT, self), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordEITPresentFollowingFlag(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetRecordEITPresentFollowingFlag(@ptrCast(*const IDVB_SDT, self), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordRunningStatus(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetRecordRunningStatus(@ptrCast(*const IDVB_SDT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordFreeCAMode(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetRecordFreeCAMode(@ptrCast(*const IDVB_SDT, self), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IDVB_SDT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IDVB_SDT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IDVB_SDT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).RegisterForNextTable(@ptrCast(*const IDVB_SDT, self), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetNextTable(self: *const T, ppSDT: ?*?*IDVB_SDT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetNextTable(@ptrCast(*const IDVB_SDT, self), ppSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).RegisterForWhenCurrent(@ptrCast(*const IDVB_SDT, self), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).ConvertNextToCurrent(@ptrCast(*const IDVB_SDT, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SDT.VTable, self.vtable).GetVersionHash(@ptrCast(*const IDVB_SDT, self), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_SDT_Value = @import("../zig.zig").Guid.initString("3f3dc9a2-bb32-4fb9-ae9e-d856848927a3");
pub const IID_IISDB_SDT = &IID_IISDB_SDT_Value;
pub const IISDB_SDT = extern struct {
    pub const VTable = extern struct {
        base: IDVB_SDT.VTable,
        GetRecordEITUserDefinedFlags: fn(
            self: *const IISDB_SDT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVB_SDT.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDT_GetRecordEITUserDefinedFlags(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDT.VTable, self.vtable).GetRecordEITUserDefinedFlags(@ptrCast(*const IISDB_SDT, self), dwRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_EIT_Value = @import("../zig.zig").Guid.initString("442db029-02cb-4495-8b92-1c13375bce99");
pub const IID_IDVB_EIT = &IID_IDVB_EIT_Value;
pub const IDVB_EIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_EIT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IDVB_EIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceId: fn(
            self: *const IDVB_EIT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: fn(
            self: *const IDVB_EIT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: fn(
            self: *const IDVB_EIT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSegmentLastSectionNumber: fn(
            self: *const IDVB_EIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastTableId: fn(
            self: *const IDVB_EIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDVB_EIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEventId: fn(
            self: *const IDVB_EIT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStartTime: fn(
            self: *const IDVB_EIT,
            dwRecordIndex: u32,
            pmdtVal: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDuration: fn(
            self: *const IDVB_EIT,
            dwRecordIndex: u32,
            pmdVal: ?*MPEG_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRunningStatus: fn(
            self: *const IDVB_EIT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordFreeCAMode: fn(
            self: *const IDVB_EIT,
            dwRecordIndex: u32,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IDVB_EIT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IDVB_EIT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IDVB_EIT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: fn(
            self: *const IDVB_EIT,
            hNextTableAvailable: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: fn(
            self: *const IDVB_EIT,
            ppEIT: ?*?*IDVB_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: fn(
            self: *const IDVB_EIT,
            hNextTableIsCurrent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: fn(
            self: *const IDVB_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: fn(
            self: *const IDVB_EIT,
            pdwVersionHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_EIT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IDVB_EIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetServiceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetServiceId(@ptrCast(*const IDVB_EIT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetTransportStreamId(@ptrCast(*const IDVB_EIT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetOriginalNetworkId(@ptrCast(*const IDVB_EIT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetSegmentLastSectionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetSegmentLastSectionNumber(@ptrCast(*const IDVB_EIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetLastTableId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetLastTableId(@ptrCast(*const IDVB_EIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDVB_EIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordEventId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetRecordEventId(@ptrCast(*const IDVB_EIT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordStartTime(self: *const T, dwRecordIndex: u32, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetRecordStartTime(@ptrCast(*const IDVB_EIT, self), dwRecordIndex, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordDuration(self: *const T, dwRecordIndex: u32, pmdVal: ?*MPEG_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetRecordDuration(@ptrCast(*const IDVB_EIT, self), dwRecordIndex, pmdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordRunningStatus(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetRecordRunningStatus(@ptrCast(*const IDVB_EIT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordFreeCAMode(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetRecordFreeCAMode(@ptrCast(*const IDVB_EIT, self), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IDVB_EIT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IDVB_EIT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IDVB_EIT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).RegisterForNextTable(@ptrCast(*const IDVB_EIT, self), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetNextTable(self: *const T, ppEIT: ?*?*IDVB_EIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetNextTable(@ptrCast(*const IDVB_EIT, self), ppEIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).RegisterForWhenCurrent(@ptrCast(*const IDVB_EIT, self), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).ConvertNextToCurrent(@ptrCast(*const IDVB_EIT, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT.VTable, self.vtable).GetVersionHash(@ptrCast(*const IDVB_EIT, self), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDVB_EIT2_Value = @import("../zig.zig").Guid.initString("61a389e0-9b9e-4ba0-aeea-5ddd159820ea");
pub const IID_IDVB_EIT2 = &IID_IDVB_EIT2_Value;
pub const IDVB_EIT2 = extern struct {
    pub const VTable = extern struct {
        base: IDVB_EIT.VTable,
        GetSegmentInfo: fn(
            self: *const IDVB_EIT2,
            pbTid: ?*u8,
            pbSegment: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordSection: fn(
            self: *const IDVB_EIT2,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVB_EIT.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT2_GetSegmentInfo(self: *const T, pbTid: ?*u8, pbSegment: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT2.VTable, self.vtable).GetSegmentInfo(@ptrCast(*const IDVB_EIT2, self), pbTid, pbSegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT2_GetRecordSection(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_EIT2.VTable, self.vtable).GetRecordSection(@ptrCast(*const IDVB_EIT2, self), dwRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_BAT_Value = @import("../zig.zig").Guid.initString("ece9bb0c-43b6-4558-a0ec-1812c34cd6ca");
pub const IID_IDVB_BAT = &IID_IDVB_BAT_Value;
pub const IDVB_BAT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_BAT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IDVB_BAT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBouquetId: fn(
            self: *const IDVB_BAT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IDVB_BAT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IDVB_BAT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IDVB_BAT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDVB_BAT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransportStreamId: fn(
            self: *const IDVB_BAT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordOriginalNetworkId: fn(
            self: *const IDVB_BAT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IDVB_BAT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IDVB_BAT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IDVB_BAT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: fn(
            self: *const IDVB_BAT,
            hNextTableAvailable: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: fn(
            self: *const IDVB_BAT,
            ppBAT: ?*?*IDVB_BAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: fn(
            self: *const IDVB_BAT,
            hNextTableIsCurrent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: fn(
            self: *const IDVB_BAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_BAT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IDVB_BAT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetBouquetId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetBouquetId(@ptrCast(*const IDVB_BAT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IDVB_BAT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IDVB_BAT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IDVB_BAT, self), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDVB_BAT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordTransportStreamId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetRecordTransportStreamId(@ptrCast(*const IDVB_BAT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordOriginalNetworkId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetRecordOriginalNetworkId(@ptrCast(*const IDVB_BAT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IDVB_BAT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IDVB_BAT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IDVB_BAT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).RegisterForNextTable(@ptrCast(*const IDVB_BAT, self), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetNextTable(self: *const T, ppBAT: ?*?*IDVB_BAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).GetNextTable(@ptrCast(*const IDVB_BAT, self), ppBAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).RegisterForWhenCurrent(@ptrCast(*const IDVB_BAT, self), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_BAT.VTable, self.vtable).ConvertNextToCurrent(@ptrCast(*const IDVB_BAT, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_RST_Value = @import("../zig.zig").Guid.initString("f47dcd04-1e23-4fb7-9f96-b40eead10b2b");
pub const IID_IDVB_RST = &IID_IDVB_RST_Value;
pub const IDVB_RST = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_RST,
            pSectionList: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDVB_RST,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransportStreamId: fn(
            self: *const IDVB_RST,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordOriginalNetworkId: fn(
            self: *const IDVB_RST,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: fn(
            self: *const IDVB_RST,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEventId: fn(
            self: *const IDVB_RST,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRunningStatus: fn(
            self: *const IDVB_RST,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_RST.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_RST, self), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_RST.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDVB_RST, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordTransportStreamId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_RST.VTable, self.vtable).GetRecordTransportStreamId(@ptrCast(*const IDVB_RST, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordOriginalNetworkId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_RST.VTable, self.vtable).GetRecordOriginalNetworkId(@ptrCast(*const IDVB_RST, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordServiceId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_RST.VTable, self.vtable).GetRecordServiceId(@ptrCast(*const IDVB_RST, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordEventId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_RST.VTable, self.vtable).GetRecordEventId(@ptrCast(*const IDVB_RST, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordRunningStatus(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_RST.VTable, self.vtable).GetRecordRunningStatus(@ptrCast(*const IDVB_RST, self), dwRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_ST_Value = @import("../zig.zig").Guid.initString("4d5b9f23-2a02-45de-bcda-5d5dbfbfbe62");
pub const IID_IDVB_ST = &IID_IDVB_ST_Value;
pub const IDVB_ST = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_ST,
            pSectionList: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataLength: fn(
            self: *const IDVB_ST,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: fn(
            self: *const IDVB_ST,
            ppData: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_ST_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_ST.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_ST, self), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_ST_GetDataLength(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_ST.VTable, self.vtable).GetDataLength(@ptrCast(*const IDVB_ST, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_ST_GetData(self: *const T, ppData: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_ST.VTable, self.vtable).GetData(@ptrCast(*const IDVB_ST, self), ppData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_TDT_Value = @import("../zig.zig").Guid.initString("0780dc7d-d55c-4aef-97e6-6b75906e2796");
pub const IID_IDVB_TDT = &IID_IDVB_TDT_Value;
pub const IDVB_TDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_TDT,
            pSectionList: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUTCTime: fn(
            self: *const IDVB_TDT,
            pmdtVal: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TDT_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_TDT.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_TDT, self), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TDT_GetUTCTime(self: *const T, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_TDT.VTable, self.vtable).GetUTCTime(@ptrCast(*const IDVB_TDT, self), pmdtVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_TOT_Value = @import("../zig.zig").Guid.initString("83295d6a-faba-4ee1-9b15-8067696910ae");
pub const IID_IDVB_TOT = &IID_IDVB_TOT_Value;
pub const IDVB_TOT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_TOT,
            pSectionList: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUTCTime: fn(
            self: *const IDVB_TOT,
            pmdtVal: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IDVB_TOT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IDVB_TOT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IDVB_TOT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_TOT.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_TOT, self), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_GetUTCTime(self: *const T, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_TOT.VTable, self.vtable).GetUTCTime(@ptrCast(*const IDVB_TOT, self), pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_TOT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IDVB_TOT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_TOT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IDVB_TOT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_TOT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IDVB_TOT, self), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_DIT_Value = @import("../zig.zig").Guid.initString("91bffdf9-9432-410f-86ef-1c228ed0ad70");
pub const IID_IDVB_DIT = &IID_IDVB_DIT_Value;
pub const IDVB_DIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_DIT,
            pSectionList: ?*ISectionList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransitionFlag: fn(
            self: *const IDVB_DIT,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_DIT_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_DIT.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_DIT, self), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_DIT_GetTransitionFlag(self: *const T, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_DIT.VTable, self.vtable).GetTransitionFlag(@ptrCast(*const IDVB_DIT, self), pfVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_SIT_Value = @import("../zig.zig").Guid.initString("68cdce53-8bea-45c2-9d9d-acf575a089b5");
pub const IID_IDVB_SIT = &IID_IDVB_SIT_Value;
pub const IDVB_SIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDVB_SIT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IDVB_SIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IDVB_SIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IDVB_SIT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IDVB_SIT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDVB_SIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: fn(
            self: *const IDVB_SIT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRunningStatus: fn(
            self: *const IDVB_SIT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IDVB_SIT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IDVB_SIT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IDVB_SIT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForNextTable: fn(
            self: *const IDVB_SIT,
            hNextTableAvailable: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTable: fn(
            self: *const IDVB_SIT,
            dwTimeout: u32,
            ppSIT: ?*?*IDVB_SIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForWhenCurrent: fn(
            self: *const IDVB_SIT,
            hNextTableIsCurrent: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertNextToCurrent: fn(
            self: *const IDVB_SIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).Initialize(@ptrCast(*const IDVB_SIT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IDVB_SIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IDVB_SIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IDVB_SIT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IDVB_SIT, self), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDVB_SIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordServiceId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetRecordServiceId(@ptrCast(*const IDVB_SIT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordRunningStatus(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetRecordRunningStatus(@ptrCast(*const IDVB_SIT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IDVB_SIT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IDVB_SIT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IDVB_SIT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).RegisterForNextTable(@ptrCast(*const IDVB_SIT, self), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetNextTable(self: *const T, dwTimeout: u32, ppSIT: ?*?*IDVB_SIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).GetNextTable(@ptrCast(*const IDVB_SIT, self), dwTimeout, ppSIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).RegisterForWhenCurrent(@ptrCast(*const IDVB_SIT, self), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDVB_SIT.VTable, self.vtable).ConvertNextToCurrent(@ptrCast(*const IDVB_SIT, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_BIT_Value = @import("../zig.zig").Guid.initString("537cd71e-0e46-4173-9001-ba043f3e49e2");
pub const IID_IISDB_BIT = &IID_IISDB_BIT_Value;
pub const IISDB_BIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IISDB_BIT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IISDB_BIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: fn(
            self: *const IISDB_BIT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBroadcastViewPropriety: fn(
            self: *const IISDB_BIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IISDB_BIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IISDB_BIT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IISDB_BIT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IISDB_BIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordBroadcasterId: fn(
            self: *const IISDB_BIT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IISDB_BIT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IISDB_BIT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IISDB_BIT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: fn(
            self: *const IISDB_BIT,
            pdwVersionHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).Initialize(@ptrCast(*const IISDB_BIT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IISDB_BIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetOriginalNetworkId(@ptrCast(*const IISDB_BIT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetBroadcastViewPropriety(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetBroadcastViewPropriety(@ptrCast(*const IISDB_BIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IISDB_BIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IISDB_BIT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IISDB_BIT, self), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IISDB_BIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetRecordBroadcasterId(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetRecordBroadcasterId(@ptrCast(*const IISDB_BIT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IISDB_BIT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IISDB_BIT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IISDB_BIT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_BIT.VTable, self.vtable).GetVersionHash(@ptrCast(*const IISDB_BIT, self), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_NBIT_Value = @import("../zig.zig").Guid.initString("1b1863ef-08f1-40b7-a559-3b1eff8cafa6");
pub const IID_IISDB_NBIT = &IID_IISDB_NBIT_Value;
pub const IISDB_NBIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IISDB_NBIT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IISDB_NBIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: fn(
            self: *const IISDB_NBIT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IISDB_NBIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordInformationId: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordInformationType: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptionBodyLocation: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordMessageSectionNumber: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordUserDefined: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumberOfKeys: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordKeys: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            pbKeys: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IISDB_NBIT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: fn(
            self: *const IISDB_NBIT,
            pdwVersionHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).Initialize(@ptrCast(*const IISDB_NBIT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IISDB_NBIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetOriginalNetworkId(@ptrCast(*const IISDB_NBIT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IISDB_NBIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordInformationId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordInformationId(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordInformationType(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordInformationType(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordDescriptionBodyLocation(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordDescriptionBodyLocation(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordMessageSectionNumber(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordMessageSectionNumber(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordUserDefined(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordUserDefined(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordNumberOfKeys(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordNumberOfKeys(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordKeys(self: *const T, dwRecordIndex: u32, pbKeys: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordKeys(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, pbKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IISDB_NBIT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_NBIT.VTable, self.vtable).GetVersionHash(@ptrCast(*const IISDB_NBIT, self), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_LDT_Value = @import("../zig.zig").Guid.initString("141a546b-02ff-4fb9-a3a3-2f074b74a9a9");
pub const IID_IISDB_LDT = &IID_IISDB_LDT_Value;
pub const IISDB_LDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IISDB_LDT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IISDB_LDT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalServiceId: fn(
            self: *const IISDB_LDT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: fn(
            self: *const IISDB_LDT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: fn(
            self: *const IISDB_LDT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IISDB_LDT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptionId: fn(
            self: *const IISDB_LDT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IISDB_LDT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IISDB_LDT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IISDB_LDT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: fn(
            self: *const IISDB_LDT,
            pdwVersionHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).Initialize(@ptrCast(*const IISDB_LDT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IISDB_LDT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetOriginalServiceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetOriginalServiceId(@ptrCast(*const IISDB_LDT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetTransportStreamId(@ptrCast(*const IISDB_LDT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetOriginalNetworkId(@ptrCast(*const IISDB_LDT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IISDB_LDT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetRecordDescriptionId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetRecordDescriptionId(@ptrCast(*const IISDB_LDT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IISDB_LDT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IISDB_LDT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IISDB_LDT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_LDT.VTable, self.vtable).GetVersionHash(@ptrCast(*const IISDB_LDT, self), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_SDTT_Value = @import("../zig.zig").Guid.initString("ee60ef2d-813a-4dc7-bf92-ea13dac85313");
pub const IID_IISDB_SDTT = &IID_IISDB_SDTT_Value;
pub const IISDB_SDTT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IISDB_SDTT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IISDB_SDTT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableIdExt: fn(
            self: *const IISDB_SDTT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransportStreamId: fn(
            self: *const IISDB_SDTT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: fn(
            self: *const IISDB_SDTT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceId: fn(
            self: *const IISDB_SDTT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IISDB_SDTT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordGroup: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTargetVersion: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNewVersion: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDownloadLevel: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordVersionIndicator: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordScheduleTimeShiftInformation: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfSchedules: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStartTimeByIndex: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            dwIndex: u32,
            pmdtVal: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDurationByIndex: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            dwIndex: u32,
            pmdVal: ?*MPEG_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IISDB_SDTT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: fn(
            self: *const IISDB_SDTT,
            pdwVersionHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).Initialize(@ptrCast(*const IISDB_SDTT, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IISDB_SDTT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetTableIdExt(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetTableIdExt(@ptrCast(*const IISDB_SDTT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetTransportStreamId(@ptrCast(*const IISDB_SDTT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetOriginalNetworkId(@ptrCast(*const IISDB_SDTT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetServiceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetServiceId(@ptrCast(*const IISDB_SDTT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IISDB_SDTT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordGroup(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordGroup(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordTargetVersion(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordTargetVersion(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordNewVersion(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordNewVersion(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordDownloadLevel(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordDownloadLevel(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordVersionIndicator(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordVersionIndicator(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordScheduleTimeShiftInformation(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordScheduleTimeShiftInformation(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordCountOfSchedules(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordCountOfSchedules(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordStartTimeByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordStartTimeByIndex(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, dwIndex, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordDurationByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, pmdVal: ?*MPEG_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordDurationByIndex(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, dwIndex, pmdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IISDB_SDTT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_SDTT.VTable, self.vtable).GetVersionHash(@ptrCast(*const IISDB_SDTT, self), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_CDT_Value = @import("../zig.zig").Guid.initString("25fa92c2-8b80-4787-a841-3a0e8f17984b");
pub const IID_IISDB_CDT = &IID_IISDB_CDT_Value;
pub const IISDB_CDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IISDB_CDT,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
            bSectionNumber: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IISDB_CDT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDownloadDataId: fn(
            self: *const IISDB_CDT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSectionNumber: fn(
            self: *const IISDB_CDT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalNetworkId: fn(
            self: *const IISDB_CDT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataType: fn(
            self: *const IISDB_CDT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfTableDescriptors: fn(
            self: *const IISDB_CDT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByIndex: fn(
            self: *const IISDB_CDT,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptorByTag: fn(
            self: *const IISDB_CDT,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeOfDataModule: fn(
            self: *const IISDB_CDT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataModule: fn(
            self: *const IISDB_CDT,
            pbData: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: fn(
            self: *const IISDB_CDT,
            pdwVersionHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data, bSectionNumber: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).Initialize(@ptrCast(*const IISDB_CDT, self), pSectionList, pMPEGData, bSectionNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IISDB_CDT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetDownloadDataId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetDownloadDataId(@ptrCast(*const IISDB_CDT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetSectionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetSectionNumber(@ptrCast(*const IISDB_CDT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetOriginalNetworkId(@ptrCast(*const IISDB_CDT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetDataType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetDataType(@ptrCast(*const IISDB_CDT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetCountOfTableDescriptors(@ptrCast(*const IISDB_CDT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetTableDescriptorByIndex(@ptrCast(*const IISDB_CDT, self), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetTableDescriptorByTag(@ptrCast(*const IISDB_CDT, self), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetSizeOfDataModule(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetSizeOfDataModule(@ptrCast(*const IISDB_CDT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetDataModule(self: *const T, pbData: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetDataModule(@ptrCast(*const IISDB_CDT, self), pbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_CDT.VTable, self.vtable).GetVersionHash(@ptrCast(*const IISDB_CDT, self), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_EMM_Value = @import("../zig.zig").Guid.initString("0edb556d-43ad-4938-9668-321b2ffecfd3");
pub const IID_IISDB_EMM = &IID_IISDB_EMM_Value;
pub const IISDB_EMM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IISDB_EMM,
            pSectionList: ?*ISectionList,
            pMPEGData: ?*IMpeg2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IISDB_EMM,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableIdExtension: fn(
            self: *const IISDB_EMM,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataBytes: fn(
            self: *const IISDB_EMM,
            pwBufferLength: ?*u16,
            pbBuffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSharedEmmMessage: fn(
            self: *const IISDB_EMM,
            pwLength: ?*u16,
            ppbMessage: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndividualEmmMessage: fn(
            self: *const IISDB_EMM,
            pUnknown: ?*IUnknown,
            pwLength: ?*u16,
            ppbMessage: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionHash: fn(
            self: *const IISDB_EMM,
            pdwVersionHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_EMM.VTable, self.vtable).Initialize(@ptrCast(*const IISDB_EMM, self), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_EMM.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IISDB_EMM, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetTableIdExtension(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_EMM.VTable, self.vtable).GetTableIdExtension(@ptrCast(*const IISDB_EMM, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetDataBytes(self: *const T, pwBufferLength: ?*u16, pbBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_EMM.VTable, self.vtable).GetDataBytes(@ptrCast(*const IISDB_EMM, self), pwBufferLength, pbBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetSharedEmmMessage(self: *const T, pwLength: ?*u16, ppbMessage: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_EMM.VTable, self.vtable).GetSharedEmmMessage(@ptrCast(*const IISDB_EMM, self), pwLength, ppbMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetIndividualEmmMessage(self: *const T, pUnknown: ?*IUnknown, pwLength: ?*u16, ppbMessage: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_EMM.VTable, self.vtable).GetIndividualEmmMessage(@ptrCast(*const IISDB_EMM, self), pUnknown, pwLength, ppbMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IISDB_EMM.VTable, self.vtable).GetVersionHash(@ptrCast(*const IISDB_EMM, self), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbServiceAttributeDescriptor_Value = @import("../zig.zig").Guid.initString("0f37bd92-d6a1-4854-b950-3a969d27f30e");
pub const IID_IDvbServiceAttributeDescriptor = &IID_IDvbServiceAttributeDescriptor_Value;
pub const IDvbServiceAttributeDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbServiceAttributeDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbServiceAttributeDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbServiceAttributeDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: fn(
            self: *const IDvbServiceAttributeDescriptor,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumericSelectionFlag: fn(
            self: *const IDvbServiceAttributeDescriptor,
            bRecordIndex: u8,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordVisibleServiceFlag: fn(
            self: *const IDvbServiceAttributeDescriptor,
            bRecordIndex: u8,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceAttributeDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbServiceAttributeDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceAttributeDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbServiceAttributeDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceAttributeDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbServiceAttributeDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetRecordServiceId(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceAttributeDescriptor.VTable, self.vtable).GetRecordServiceId(@ptrCast(*const IDvbServiceAttributeDescriptor, self), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetRecordNumericSelectionFlag(self: *const T, bRecordIndex: u8, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceAttributeDescriptor.VTable, self.vtable).GetRecordNumericSelectionFlag(@ptrCast(*const IDvbServiceAttributeDescriptor, self), bRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetRecordVisibleServiceFlag(self: *const T, bRecordIndex: u8, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceAttributeDescriptor.VTable, self.vtable).GetRecordVisibleServiceFlag(@ptrCast(*const IDvbServiceAttributeDescriptor, self), bRecordIndex, pfVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CRID_LOCATION = enum(i32) {
    IN_DESCRIPTOR = 0,
    IN_CIT = 1,
    DVB_RESERVED1 = 2,
    DVB_RESERVED2 = 3,
};
pub const CRID_LOCATION_IN_DESCRIPTOR = CRID_LOCATION.IN_DESCRIPTOR;
pub const CRID_LOCATION_IN_CIT = CRID_LOCATION.IN_CIT;
pub const CRID_LOCATION_DVB_RESERVED1 = CRID_LOCATION.DVB_RESERVED1;
pub const CRID_LOCATION_DVB_RESERVED2 = CRID_LOCATION.DVB_RESERVED2;

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbContentIdentifierDescriptor_Value = @import("../zig.zig").Guid.initString("05e0c1ea-f661-4053-9fbf-d93b28359838");
pub const IID_IDvbContentIdentifierDescriptor = &IID_IDvbContentIdentifierDescriptor_Value;
pub const IDvbContentIdentifierDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbContentIdentifierDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbContentIdentifierDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbContentIdentifierDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCrid: fn(
            self: *const IDvbContentIdentifierDescriptor,
            bRecordIndex: u8,
            pbType: ?*u8,
            pbLocation: ?*u8,
            pbLength: ?*u8,
            ppbBytes: [*]?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentIdentifierDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbContentIdentifierDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbContentIdentifierDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentIdentifierDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbContentIdentifierDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbContentIdentifierDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentIdentifierDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbContentIdentifierDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbContentIdentifierDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentIdentifierDescriptor_GetRecordCrid(self: *const T, bRecordIndex: u8, pbType: ?*u8, pbLocation: ?*u8, pbLength: ?*u8, ppbBytes: [*]?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbContentIdentifierDescriptor.VTable, self.vtable).GetRecordCrid(@ptrCast(*const IDvbContentIdentifierDescriptor, self), bRecordIndex, pbType, pbLocation, pbLength, ppbBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbDefaultAuthorityDescriptor_Value = @import("../zig.zig").Guid.initString("05ec24d1-3a31-44e7-b408-67c60a352276");
pub const IID_IDvbDefaultAuthorityDescriptor = &IID_IDvbDefaultAuthorityDescriptor_Value;
pub const IDvbDefaultAuthorityDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbDefaultAuthorityDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbDefaultAuthorityDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultAuthority: fn(
            self: *const IDvbDefaultAuthorityDescriptor,
            pbLength: ?*u8,
            ppbBytes: [*]?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDefaultAuthorityDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDefaultAuthorityDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbDefaultAuthorityDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDefaultAuthorityDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDefaultAuthorityDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbDefaultAuthorityDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDefaultAuthorityDescriptor_GetDefaultAuthority(self: *const T, pbLength: ?*u8, ppbBytes: [*]?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDefaultAuthorityDescriptor.VTable, self.vtable).GetDefaultAuthority(@ptrCast(*const IDvbDefaultAuthorityDescriptor, self), pbLength, ppbBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbSatelliteDeliverySystemDescriptor_Value = @import("../zig.zig").Guid.initString("02f2225a-805b-4ec5-a9a6-f9b5913cd470");
pub const IID_IDvbSatelliteDeliverySystemDescriptor = &IID_IDvbSatelliteDeliverySystemDescriptor_Value;
pub const IDvbSatelliteDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrequency: fn(
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOrbitalPosition: fn(
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWestEastFlag: fn(
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPolarization: fn(
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModulation: fn(
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolRate: fn(
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFECInner: fn(
            self: *const IDvbSatelliteDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSatelliteDeliverySystemDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbSatelliteDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSatelliteDeliverySystemDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbSatelliteDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetFrequency(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSatelliteDeliverySystemDescriptor.VTable, self.vtable).GetFrequency(@ptrCast(*const IDvbSatelliteDeliverySystemDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetOrbitalPosition(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSatelliteDeliverySystemDescriptor.VTable, self.vtable).GetOrbitalPosition(@ptrCast(*const IDvbSatelliteDeliverySystemDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetWestEastFlag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSatelliteDeliverySystemDescriptor.VTable, self.vtable).GetWestEastFlag(@ptrCast(*const IDvbSatelliteDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetPolarization(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSatelliteDeliverySystemDescriptor.VTable, self.vtable).GetPolarization(@ptrCast(*const IDvbSatelliteDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetModulation(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSatelliteDeliverySystemDescriptor.VTable, self.vtable).GetModulation(@ptrCast(*const IDvbSatelliteDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetSymbolRate(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSatelliteDeliverySystemDescriptor.VTable, self.vtable).GetSymbolRate(@ptrCast(*const IDvbSatelliteDeliverySystemDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetFECInner(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSatelliteDeliverySystemDescriptor.VTable, self.vtable).GetFECInner(@ptrCast(*const IDvbSatelliteDeliverySystemDescriptor, self), pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbCableDeliverySystemDescriptor_Value = @import("../zig.zig").Guid.initString("dfb98e36-9e1a-4862-9946-993a4e59017b");
pub const IID_IDvbCableDeliverySystemDescriptor = &IID_IDvbCableDeliverySystemDescriptor_Value;
pub const IDvbCableDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbCableDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbCableDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrequency: fn(
            self: *const IDvbCableDeliverySystemDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFECOuter: fn(
            self: *const IDvbCableDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModulation: fn(
            self: *const IDvbCableDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolRate: fn(
            self: *const IDvbCableDeliverySystemDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFECInner: fn(
            self: *const IDvbCableDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbCableDeliverySystemDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbCableDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbCableDeliverySystemDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbCableDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetFrequency(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbCableDeliverySystemDescriptor.VTable, self.vtable).GetFrequency(@ptrCast(*const IDvbCableDeliverySystemDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetFECOuter(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbCableDeliverySystemDescriptor.VTable, self.vtable).GetFECOuter(@ptrCast(*const IDvbCableDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetModulation(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbCableDeliverySystemDescriptor.VTable, self.vtable).GetModulation(@ptrCast(*const IDvbCableDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetSymbolRate(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbCableDeliverySystemDescriptor.VTable, self.vtable).GetSymbolRate(@ptrCast(*const IDvbCableDeliverySystemDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetFECInner(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbCableDeliverySystemDescriptor.VTable, self.vtable).GetFECInner(@ptrCast(*const IDvbCableDeliverySystemDescriptor, self), pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbTerrestrialDeliverySystemDescriptor_Value = @import("../zig.zig").Guid.initString("ed7e1b91-d12e-420c-b41d-a49d84fe1823");
pub const IID_IDvbTerrestrialDeliverySystemDescriptor = &IID_IDvbTerrestrialDeliverySystemDescriptor_Value;
pub const IDvbTerrestrialDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCentreFrequency: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBandwidth: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConstellation: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHierarchyInformation: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeRateHPStream: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeRateLPStream: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuardInterval: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransmissionMode: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherFrequencyFlag: fn(
            self: *const IDvbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetCentreFrequency(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetCentreFrequency(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetBandwidth(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetBandwidth(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetConstellation(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetConstellation(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetHierarchyInformation(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetHierarchyInformation(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetCodeRateHPStream(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetCodeRateHPStream(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetCodeRateLPStream(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetCodeRateLPStream(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetGuardInterval(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetGuardInterval(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetTransmissionMode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetTransmissionMode(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetOtherFrequencyFlag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetOtherFrequencyFlag(@ptrCast(*const IDvbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbTerrestrial2DeliverySystemDescriptor_Value = @import("../zig.zig").Guid.initString("20ee9be9-cd57-49ab-8f6e-1d07aeb8e482");
pub const IID_IDvbTerrestrial2DeliverySystemDescriptor = &IID_IDvbTerrestrial2DeliverySystemDescriptor_Value;
pub const IDvbTerrestrial2DeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTagExtension: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCentreFrequency: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPLPId: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetT2SystemId: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMultipleInputMode: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBandwidth: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuardInterval: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransmissionMode: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellId: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherFrequencyFlag: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTFSFlag: fn(
            self: *const IDvbTerrestrial2DeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetTagExtension(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetTagExtension(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetCentreFrequency(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetCentreFrequency(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetPLPId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetPLPId(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetT2SystemId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetT2SystemId(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetMultipleInputMode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetMultipleInputMode(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetBandwidth(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetBandwidth(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetGuardInterval(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetGuardInterval(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetTransmissionMode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetTransmissionMode(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetCellId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetCellId(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetOtherFrequencyFlag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetOtherFrequencyFlag(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetTFSFlag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, self.vtable).GetTFSFlag(@ptrCast(*const IDvbTerrestrial2DeliverySystemDescriptor, self), pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbFrequencyListDescriptor_Value = @import("../zig.zig").Guid.initString("1cadb613-e1dd-4512-afa8-bb7a007ef8b1");
pub const IID_IDvbFrequencyListDescriptor = &IID_IDvbFrequencyListDescriptor_Value;
pub const IDvbFrequencyListDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbFrequencyListDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbFrequencyListDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodingType: fn(
            self: *const IDvbFrequencyListDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbFrequencyListDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCentreFrequency: fn(
            self: *const IDvbFrequencyListDescriptor,
            bRecordIndex: u8,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbFrequencyListDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbFrequencyListDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbFrequencyListDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbFrequencyListDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetCodingType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbFrequencyListDescriptor.VTable, self.vtable).GetCodingType(@ptrCast(*const IDvbFrequencyListDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbFrequencyListDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbFrequencyListDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetRecordCentreFrequency(self: *const T, bRecordIndex: u8, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbFrequencyListDescriptor.VTable, self.vtable).GetRecordCentreFrequency(@ptrCast(*const IDvbFrequencyListDescriptor, self), bRecordIndex, pdwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbPrivateDataSpecifierDescriptor_Value = @import("../zig.zig").Guid.initString("5660a019-e75a-4b82-9b4c-ed2256d165a2");
pub const IID_IDvbPrivateDataSpecifierDescriptor = &IID_IDvbPrivateDataSpecifierDescriptor_Value;
pub const IDvbPrivateDataSpecifierDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbPrivateDataSpecifierDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbPrivateDataSpecifierDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateDataSpecifier: fn(
            self: *const IDvbPrivateDataSpecifierDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbPrivateDataSpecifierDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbPrivateDataSpecifierDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbPrivateDataSpecifierDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbPrivateDataSpecifierDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbPrivateDataSpecifierDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbPrivateDataSpecifierDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbPrivateDataSpecifierDescriptor_GetPrivateDataSpecifier(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbPrivateDataSpecifierDescriptor.VTable, self.vtable).GetPrivateDataSpecifier(@ptrCast(*const IDvbPrivateDataSpecifierDescriptor, self), pdwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbLogicalChannelDescriptor_Value = @import("../zig.zig").Guid.initString("cf1edaff-3ffd-4cf7-8201-35756acbf85f");
pub const IID_IDvbLogicalChannelDescriptor = &IID_IDvbLogicalChannelDescriptor_Value;
pub const IDvbLogicalChannelDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbLogicalChannelDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbLogicalChannelDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbLogicalChannelDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: fn(
            self: *const IDvbLogicalChannelDescriptor,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordLogicalChannelNumber: fn(
            self: *const IDvbLogicalChannelDescriptor,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannelDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbLogicalChannelDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannelDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbLogicalChannelDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannelDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbLogicalChannelDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetRecordServiceId(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannelDescriptor.VTable, self.vtable).GetRecordServiceId(@ptrCast(*const IDvbLogicalChannelDescriptor, self), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetRecordLogicalChannelNumber(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannelDescriptor.VTable, self.vtable).GetRecordLogicalChannelNumber(@ptrCast(*const IDvbLogicalChannelDescriptor, self), bRecordIndex, pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbLogicalChannelDescriptor2_Value = @import("../zig.zig").Guid.initString("43aca974-4be8-4b98-bc17-9eafd788b1d7");
pub const IID_IDvbLogicalChannelDescriptor2 = &IID_IDvbLogicalChannelDescriptor2_Value;
pub const IDvbLogicalChannelDescriptor2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbLogicalChannelDescriptor.VTable,
        GetRecordLogicalChannelAndVisibility: fn(
            self: *const IDvbLogicalChannelDescriptor2,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbLogicalChannelDescriptor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor2_GetRecordLogicalChannelAndVisibility(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannelDescriptor2.VTable, self.vtable).GetRecordLogicalChannelAndVisibility(@ptrCast(*const IDvbLogicalChannelDescriptor2, self), bRecordIndex, pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbLogicalChannel2Descriptor_Value = @import("../zig.zig").Guid.initString("f69c3747-8a30-4980-998c-01fe7f0ba35a");
pub const IID_IDvbLogicalChannel2Descriptor = &IID_IDvbLogicalChannel2Descriptor_Value;
pub const IDvbLogicalChannel2Descriptor = extern struct {
    pub const VTable = extern struct {
        base: IDvbLogicalChannelDescriptor2.VTable,
        GetCountOfLists: fn(
            self: *const IDvbLogicalChannel2Descriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListId: fn(
            self: *const IDvbLogicalChannel2Descriptor,
            bListIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListNameW: fn(
            self: *const IDvbLogicalChannel2Descriptor,
            bListIndex: u8,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListCountryCode: fn(
            self: *const IDvbLogicalChannel2Descriptor,
            bListIndex: u8,
            pszCode: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListCountOfRecords: fn(
            self: *const IDvbLogicalChannel2Descriptor,
            bChannelListIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListRecordServiceId: fn(
            self: *const IDvbLogicalChannel2Descriptor,
            bListIndex: u8,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListRecordLogicalChannelNumber: fn(
            self: *const IDvbLogicalChannel2Descriptor,
            bListIndex: u8,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListRecordLogicalChannelAndVisibility: fn(
            self: *const IDvbLogicalChannel2Descriptor,
            bListIndex: u8,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbLogicalChannelDescriptor2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetCountOfLists(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannel2Descriptor.VTable, self.vtable).GetCountOfLists(@ptrCast(*const IDvbLogicalChannel2Descriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListId(self: *const T, bListIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannel2Descriptor.VTable, self.vtable).GetListId(@ptrCast(*const IDvbLogicalChannel2Descriptor, self), bListIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListNameW(self: *const T, bListIndex: u8, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannel2Descriptor.VTable, self.vtable).GetListNameW(@ptrCast(*const IDvbLogicalChannel2Descriptor, self), bListIndex, convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListCountryCode(self: *const T, bListIndex: u8, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannel2Descriptor.VTable, self.vtable).GetListCountryCode(@ptrCast(*const IDvbLogicalChannel2Descriptor, self), bListIndex, pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListCountOfRecords(self: *const T, bChannelListIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannel2Descriptor.VTable, self.vtable).GetListCountOfRecords(@ptrCast(*const IDvbLogicalChannel2Descriptor, self), bChannelListIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListRecordServiceId(self: *const T, bListIndex: u8, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannel2Descriptor.VTable, self.vtable).GetListRecordServiceId(@ptrCast(*const IDvbLogicalChannel2Descriptor, self), bListIndex, bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListRecordLogicalChannelNumber(self: *const T, bListIndex: u8, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannel2Descriptor.VTable, self.vtable).GetListRecordLogicalChannelNumber(@ptrCast(*const IDvbLogicalChannel2Descriptor, self), bListIndex, bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListRecordLogicalChannelAndVisibility(self: *const T, bListIndex: u8, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLogicalChannel2Descriptor.VTable, self.vtable).GetListRecordLogicalChannelAndVisibility(@ptrCast(*const IDvbLogicalChannel2Descriptor, self), bListIndex, bRecordIndex, pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbHDSimulcastLogicalChannelDescriptor_Value = @import("../zig.zig").Guid.initString("1ea8b738-a307-4680-9e26-d0a908c824f4");
pub const IID_IDvbHDSimulcastLogicalChannelDescriptor = &IID_IDvbHDSimulcastLogicalChannelDescriptor_Value;
pub const IDvbHDSimulcastLogicalChannelDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IDvbLogicalChannelDescriptor2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbLogicalChannelDescriptor2.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbDataBroadcastIDDescriptor_Value = @import("../zig.zig").Guid.initString("5f26f518-65c8-4048-91f2-9290f59f7b90");
pub const IID_IDvbDataBroadcastIDDescriptor = &IID_IDvbDataBroadcastIDDescriptor_Value;
pub const IDvbDataBroadcastIDDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbDataBroadcastIDDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbDataBroadcastIDDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataBroadcastID: fn(
            self: *const IDvbDataBroadcastIDDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDSelectorBytes: fn(
            self: *const IDvbDataBroadcastIDDescriptor,
            pbLen: ?*u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastIDDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastIDDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbDataBroadcastIDDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastIDDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastIDDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbDataBroadcastIDDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastIDDescriptor_GetDataBroadcastID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastIDDescriptor.VTable, self.vtable).GetDataBroadcastID(@ptrCast(*const IDvbDataBroadcastIDDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastIDDescriptor_GetIDSelectorBytes(self: *const T, pbLen: ?*u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastIDDescriptor.VTable, self.vtable).GetIDSelectorBytes(@ptrCast(*const IDvbDataBroadcastIDDescriptor, self), pbLen, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbDataBroadcastDescriptor_Value = @import("../zig.zig").Guid.initString("d1ebc1d6-8b60-4c20-9caf-e59382e7c400");
pub const IID_IDvbDataBroadcastDescriptor = &IID_IDvbDataBroadcastDescriptor_Value;
pub const IDvbDataBroadcastDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbDataBroadcastDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbDataBroadcastDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataBroadcastID: fn(
            self: *const IDvbDataBroadcastDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentTag: fn(
            self: *const IDvbDataBroadcastDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectorLength: fn(
            self: *const IDvbDataBroadcastDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectorBytes: fn(
            self: *const IDvbDataBroadcastDescriptor,
            pbLen: ?*u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangID: fn(
            self: *const IDvbDataBroadcastDescriptor,
            pulVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextLength: fn(
            self: *const IDvbDataBroadcastDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const IDvbDataBroadcastDescriptor,
            pbLen: ?*u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbDataBroadcastDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbDataBroadcastDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetDataBroadcastID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastDescriptor.VTable, self.vtable).GetDataBroadcastID(@ptrCast(*const IDvbDataBroadcastDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetComponentTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastDescriptor.VTable, self.vtable).GetComponentTag(@ptrCast(*const IDvbDataBroadcastDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetSelectorLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastDescriptor.VTable, self.vtable).GetSelectorLength(@ptrCast(*const IDvbDataBroadcastDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetSelectorBytes(self: *const T, pbLen: ?*u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastDescriptor.VTable, self.vtable).GetSelectorBytes(@ptrCast(*const IDvbDataBroadcastDescriptor, self), pbLen, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetLangID(self: *const T, pulVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastDescriptor.VTable, self.vtable).GetLangID(@ptrCast(*const IDvbDataBroadcastDescriptor, self), pulVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetTextLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastDescriptor.VTable, self.vtable).GetTextLength(@ptrCast(*const IDvbDataBroadcastDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetText(self: *const T, pbLen: ?*u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbDataBroadcastDescriptor.VTable, self.vtable).GetText(@ptrCast(*const IDvbDataBroadcastDescriptor, self), pbLen, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DESC_LINKAGE_TYPE = enum(i32) {
    RESERVED0 = 0,
    INFORMATION = 1,
    EPG = 2,
    CA_REPLACEMENT = 3,
    COMPLETE_NET_BOUQUET_SI = 4,
    REPLACEMENT = 5,
    DATA = 6,
    RESERVED1 = 7,
    USER = 8,
    RESERVED2 = 255,
};
pub const DESC_LINKAGE_RESERVED0 = DESC_LINKAGE_TYPE.RESERVED0;
pub const DESC_LINKAGE_INFORMATION = DESC_LINKAGE_TYPE.INFORMATION;
pub const DESC_LINKAGE_EPG = DESC_LINKAGE_TYPE.EPG;
pub const DESC_LINKAGE_CA_REPLACEMENT = DESC_LINKAGE_TYPE.CA_REPLACEMENT;
pub const DESC_LINKAGE_COMPLETE_NET_BOUQUET_SI = DESC_LINKAGE_TYPE.COMPLETE_NET_BOUQUET_SI;
pub const DESC_LINKAGE_REPLACEMENT = DESC_LINKAGE_TYPE.REPLACEMENT;
pub const DESC_LINKAGE_DATA = DESC_LINKAGE_TYPE.DATA;
pub const DESC_LINKAGE_RESERVED1 = DESC_LINKAGE_TYPE.RESERVED1;
pub const DESC_LINKAGE_USER = DESC_LINKAGE_TYPE.USER;
pub const DESC_LINKAGE_RESERVED2 = DESC_LINKAGE_TYPE.RESERVED2;

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbLinkageDescriptor_Value = @import("../zig.zig").Guid.initString("1cdf8b31-994a-46fc-acfd-6a6be8934dd5");
pub const IID_IDvbLinkageDescriptor = &IID_IDvbLinkageDescriptor_Value;
pub const IDvbLinkageDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbLinkageDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbLinkageDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSId: fn(
            self: *const IDvbLinkageDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetONId: fn(
            self: *const IDvbLinkageDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceId: fn(
            self: *const IDvbLinkageDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkageType: fn(
            self: *const IDvbLinkageDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateDataLength: fn(
            self: *const IDvbLinkageDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateData: fn(
            self: *const IDvbLinkageDescriptor,
            pbLen: ?*u8,
            pbData: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLinkageDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbLinkageDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLinkageDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbLinkageDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetTSId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLinkageDescriptor.VTable, self.vtable).GetTSId(@ptrCast(*const IDvbLinkageDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetONId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLinkageDescriptor.VTable, self.vtable).GetONId(@ptrCast(*const IDvbLinkageDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetServiceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLinkageDescriptor.VTable, self.vtable).GetServiceId(@ptrCast(*const IDvbLinkageDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetLinkageType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLinkageDescriptor.VTable, self.vtable).GetLinkageType(@ptrCast(*const IDvbLinkageDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetPrivateDataLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLinkageDescriptor.VTable, self.vtable).GetPrivateDataLength(@ptrCast(*const IDvbLinkageDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetPrivateData(self: *const T, pbLen: ?*u8, pbData: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbLinkageDescriptor.VTable, self.vtable).GetPrivateData(@ptrCast(*const IDvbLinkageDescriptor, self), pbLen, pbData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbTeletextDescriptor_Value = @import("../zig.zig").Guid.initString("9cd29d47-69c6-4f92-98a9-210af1b7303a");
pub const IID_IDvbTeletextDescriptor = &IID_IDvbTeletextDescriptor_Value;
pub const IDvbTeletextDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbTeletextDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbTeletextDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbTeletextDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordLangId: fn(
            self: *const IDvbTeletextDescriptor,
            bRecordIndex: u8,
            pulVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTeletextType: fn(
            self: *const IDvbTeletextDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordMagazineNumber: fn(
            self: *const IDvbTeletextDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordPageNumber: fn(
            self: *const IDvbTeletextDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTeletextDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbTeletextDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTeletextDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbTeletextDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTeletextDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbTeletextDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetRecordLangId(self: *const T, bRecordIndex: u8, pulVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTeletextDescriptor.VTable, self.vtable).GetRecordLangId(@ptrCast(*const IDvbTeletextDescriptor, self), bRecordIndex, pulVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetRecordTeletextType(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTeletextDescriptor.VTable, self.vtable).GetRecordTeletextType(@ptrCast(*const IDvbTeletextDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetRecordMagazineNumber(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTeletextDescriptor.VTable, self.vtable).GetRecordMagazineNumber(@ptrCast(*const IDvbTeletextDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetRecordPageNumber(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbTeletextDescriptor.VTable, self.vtable).GetRecordPageNumber(@ptrCast(*const IDvbTeletextDescriptor, self), bRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbSubtitlingDescriptor_Value = @import("../zig.zig").Guid.initString("9b25fe1d-fa23-4e50-9784-6df8b26f8a49");
pub const IID_IDvbSubtitlingDescriptor = &IID_IDvbSubtitlingDescriptor_Value;
pub const IDvbSubtitlingDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbSubtitlingDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbSubtitlingDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbSubtitlingDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordLangId: fn(
            self: *const IDvbSubtitlingDescriptor,
            bRecordIndex: u8,
            pulVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordSubtitlingType: fn(
            self: *const IDvbSubtitlingDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCompositionPageID: fn(
            self: *const IDvbSubtitlingDescriptor,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordAncillaryPageID: fn(
            self: *const IDvbSubtitlingDescriptor,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSubtitlingDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbSubtitlingDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSubtitlingDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbSubtitlingDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSubtitlingDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbSubtitlingDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetRecordLangId(self: *const T, bRecordIndex: u8, pulVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSubtitlingDescriptor.VTable, self.vtable).GetRecordLangId(@ptrCast(*const IDvbSubtitlingDescriptor, self), bRecordIndex, pulVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetRecordSubtitlingType(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSubtitlingDescriptor.VTable, self.vtable).GetRecordSubtitlingType(@ptrCast(*const IDvbSubtitlingDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetRecordCompositionPageID(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSubtitlingDescriptor.VTable, self.vtable).GetRecordCompositionPageID(@ptrCast(*const IDvbSubtitlingDescriptor, self), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetRecordAncillaryPageID(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbSubtitlingDescriptor.VTable, self.vtable).GetRecordAncillaryPageID(@ptrCast(*const IDvbSubtitlingDescriptor, self), bRecordIndex, pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbServiceDescriptor_Value = @import("../zig.zig").Guid.initString("f9c7fbcf-e2d6-464d-b32d-2ef526e49290");
pub const IID_IDvbServiceDescriptor = &IID_IDvbServiceDescriptor_Value;
pub const IDvbServiceDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbServiceDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbServiceDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceType: fn(
            self: *const IDvbServiceDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceProviderName: fn(
            self: *const IDvbServiceDescriptor,
            pszName: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceProviderNameW: fn(
            self: *const IDvbServiceDescriptor,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceName: fn(
            self: *const IDvbServiceDescriptor,
            pszName: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessedServiceName: fn(
            self: *const IDvbServiceDescriptor,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceNameEmphasized: fn(
            self: *const IDvbServiceDescriptor,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbServiceDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbServiceDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor.VTable, self.vtable).GetServiceType(@ptrCast(*const IDvbServiceDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceProviderName(self: *const T, pszName: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor.VTable, self.vtable).GetServiceProviderName(@ptrCast(*const IDvbServiceDescriptor, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceProviderNameW(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor.VTable, self.vtable).GetServiceProviderNameW(@ptrCast(*const IDvbServiceDescriptor, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceName(self: *const T, pszName: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor.VTable, self.vtable).GetServiceName(@ptrCast(*const IDvbServiceDescriptor, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetProcessedServiceName(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor.VTable, self.vtable).GetProcessedServiceName(@ptrCast(*const IDvbServiceDescriptor, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceNameEmphasized(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor.VTable, self.vtable).GetServiceNameEmphasized(@ptrCast(*const IDvbServiceDescriptor, self), pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbServiceDescriptor2_Value = @import("../zig.zig").Guid.initString("d6c76506-85ab-487c-9b2b-36416511e4a2");
pub const IID_IDvbServiceDescriptor2 = &IID_IDvbServiceDescriptor2_Value;
pub const IDvbServiceDescriptor2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbServiceDescriptor.VTable,
        GetServiceProviderNameW: fn(
            self: *const IDvbServiceDescriptor2,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceNameW: fn(
            self: *const IDvbServiceDescriptor2,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbServiceDescriptor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor2_GetServiceProviderNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor2.VTable, self.vtable).GetServiceProviderNameW(@ptrCast(*const IDvbServiceDescriptor2, self), convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor2_GetServiceNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceDescriptor2.VTable, self.vtable).GetServiceNameW(@ptrCast(*const IDvbServiceDescriptor2, self), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbServiceListDescriptor_Value = @import("../zig.zig").Guid.initString("05db0d8f-6008-491a-acd3-7090952707d0");
pub const IID_IDvbServiceListDescriptor = &IID_IDvbServiceListDescriptor_Value;
pub const IDvbServiceListDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbServiceListDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbServiceListDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbServiceListDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceId: fn(
            self: *const IDvbServiceListDescriptor,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceType: fn(
            self: *const IDvbServiceListDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceListDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbServiceListDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceListDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbServiceListDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceListDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbServiceListDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetRecordServiceId(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceListDescriptor.VTable, self.vtable).GetRecordServiceId(@ptrCast(*const IDvbServiceListDescriptor, self), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetRecordServiceType(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbServiceListDescriptor.VTable, self.vtable).GetRecordServiceType(@ptrCast(*const IDvbServiceListDescriptor, self), bRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbMultilingualServiceNameDescriptor_Value = @import("../zig.zig").Guid.initString("2d80433b-b32c-47ef-987f-e78ebb773e34");
pub const IID_IDvbMultilingualServiceNameDescriptor = &IID_IDvbMultilingualServiceNameDescriptor_Value;
pub const IDvbMultilingualServiceNameDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbMultilingualServiceNameDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbMultilingualServiceNameDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbMultilingualServiceNameDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordLangId: fn(
            self: *const IDvbMultilingualServiceNameDescriptor,
            bRecordIndex: u8,
            ulVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceProviderNameW: fn(
            self: *const IDvbMultilingualServiceNameDescriptor,
            bRecordIndex: u8,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceNameW: fn(
            self: *const IDvbMultilingualServiceNameDescriptor,
            bRecordIndex: u8,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbMultilingualServiceNameDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbMultilingualServiceNameDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbMultilingualServiceNameDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbMultilingualServiceNameDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbMultilingualServiceNameDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbMultilingualServiceNameDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetRecordLangId(self: *const T, bRecordIndex: u8, ulVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbMultilingualServiceNameDescriptor.VTable, self.vtable).GetRecordLangId(@ptrCast(*const IDvbMultilingualServiceNameDescriptor, self), bRecordIndex, ulVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetRecordServiceProviderNameW(self: *const T, bRecordIndex: u8, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbMultilingualServiceNameDescriptor.VTable, self.vtable).GetRecordServiceProviderNameW(@ptrCast(*const IDvbMultilingualServiceNameDescriptor, self), bRecordIndex, convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetRecordServiceNameW(self: *const T, bRecordIndex: u8, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbMultilingualServiceNameDescriptor.VTable, self.vtable).GetRecordServiceNameW(@ptrCast(*const IDvbMultilingualServiceNameDescriptor, self), bRecordIndex, convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbNetworkNameDescriptor_Value = @import("../zig.zig").Guid.initString("5b2a80cf-35b9-446c-b3e4-048b761dbc51");
pub const IID_IDvbNetworkNameDescriptor = &IID_IDvbNetworkNameDescriptor_Value;
pub const IDvbNetworkNameDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbNetworkNameDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbNetworkNameDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkName: fn(
            self: *const IDvbNetworkNameDescriptor,
            pszName: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkNameW: fn(
            self: *const IDvbNetworkNameDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbNetworkNameDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbNetworkNameDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbNetworkNameDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbNetworkNameDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbNetworkNameDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbNetworkNameDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbNetworkNameDescriptor_GetNetworkName(self: *const T, pszName: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbNetworkNameDescriptor.VTable, self.vtable).GetNetworkName(@ptrCast(*const IDvbNetworkNameDescriptor, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbNetworkNameDescriptor_GetNetworkNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbNetworkNameDescriptor.VTable, self.vtable).GetNetworkNameW(@ptrCast(*const IDvbNetworkNameDescriptor, self), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbShortEventDescriptor_Value = @import("../zig.zig").Guid.initString("b170be92-5b75-458e-9c6e-b0008231491a");
pub const IID_IDvbShortEventDescriptor = &IID_IDvbShortEventDescriptor_Value;
pub const IDvbShortEventDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbShortEventDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbShortEventDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: fn(
            self: *const IDvbShortEventDescriptor,
            pszCode: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventNameW: fn(
            self: *const IDvbShortEventDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: fn(
            self: *const IDvbShortEventDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbShortEventDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbShortEventDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbShortEventDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbShortEventDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbShortEventDescriptor.VTable, self.vtable).GetLanguageCode(@ptrCast(*const IDvbShortEventDescriptor, self), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetEventNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbShortEventDescriptor.VTable, self.vtable).GetEventNameW(@ptrCast(*const IDvbShortEventDescriptor, self), convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbShortEventDescriptor.VTable, self.vtable).GetTextW(@ptrCast(*const IDvbShortEventDescriptor, self), convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbExtendedEventDescriptor_Value = @import("../zig.zig").Guid.initString("c9b22eca-85f4-499f-b1db-efa93a91ee57");
pub const IID_IDvbExtendedEventDescriptor = &IID_IDvbExtendedEventDescriptor_Value;
pub const IDvbExtendedEventDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbExtendedEventDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbExtendedEventDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptorNumber: fn(
            self: *const IDvbExtendedEventDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastDescriptorNumber: fn(
            self: *const IDvbExtendedEventDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: fn(
            self: *const IDvbExtendedEventDescriptor,
            pszCode: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbExtendedEventDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordItemW: fn(
            self: *const IDvbExtendedEventDescriptor,
            bRecordIndex: u8,
            convMode: DVB_STRCONV_MODE,
            pbstrDesc: ?*?BSTR,
            pbstrItem: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConcatenatedItemW: fn(
            self: *const IDvbExtendedEventDescriptor,
            pFollowingDescriptor: ?*IDvbExtendedEventDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrDesc: ?*?BSTR,
            pbstrItem: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: fn(
            self: *const IDvbExtendedEventDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConcatenatedTextW: fn(
            self: *const IDvbExtendedEventDescriptor,
            FollowingDescriptor: ?*IDvbExtendedEventDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordItemRawBytes: fn(
            self: *const IDvbExtendedEventDescriptor,
            bRecordIndex: u8,
            ppbRawItem: ?*?*u8,
            pbItemLength: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbExtendedEventDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbExtendedEventDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetDescriptorNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetDescriptorNumber(@ptrCast(*const IDvbExtendedEventDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetLastDescriptorNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetLastDescriptorNumber(@ptrCast(*const IDvbExtendedEventDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetLanguageCode(@ptrCast(*const IDvbExtendedEventDescriptor, self), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbExtendedEventDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetRecordItemW(self: *const T, bRecordIndex: u8, convMode: DVB_STRCONV_MODE, pbstrDesc: ?*?BSTR, pbstrItem: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetRecordItemW(@ptrCast(*const IDvbExtendedEventDescriptor, self), bRecordIndex, convMode, pbstrDesc, pbstrItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetConcatenatedItemW(self: *const T, pFollowingDescriptor: ?*IDvbExtendedEventDescriptor, convMode: DVB_STRCONV_MODE, pbstrDesc: ?*?BSTR, pbstrItem: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetConcatenatedItemW(@ptrCast(*const IDvbExtendedEventDescriptor, self), pFollowingDescriptor, convMode, pbstrDesc, pbstrItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetTextW(@ptrCast(*const IDvbExtendedEventDescriptor, self), convMode, pbstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetConcatenatedTextW(self: *const T, FollowingDescriptor: ?*IDvbExtendedEventDescriptor, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetConcatenatedTextW(@ptrCast(*const IDvbExtendedEventDescriptor, self), FollowingDescriptor, convMode, pbstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetRecordItemRawBytes(self: *const T, bRecordIndex: u8, ppbRawItem: ?*?*u8, pbItemLength: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbExtendedEventDescriptor.VTable, self.vtable).GetRecordItemRawBytes(@ptrCast(*const IDvbExtendedEventDescriptor, self), bRecordIndex, ppbRawItem, pbItemLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbComponentDescriptor_Value = @import("../zig.zig").Guid.initString("91e405cf-80e7-457f-9096-1b9d1ce32141");
pub const IID_IDvbComponentDescriptor = &IID_IDvbComponentDescriptor_Value;
pub const IDvbComponentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamContent: fn(
            self: *const IDvbComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentType: fn(
            self: *const IDvbComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentTag: fn(
            self: *const IDvbComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: fn(
            self: *const IDvbComponentDescriptor,
            pszCode: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: fn(
            self: *const IDvbComponentDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbComponentDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbComponentDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetStreamContent(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbComponentDescriptor.VTable, self.vtable).GetStreamContent(@ptrCast(*const IDvbComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetComponentType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbComponentDescriptor.VTable, self.vtable).GetComponentType(@ptrCast(*const IDvbComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetComponentTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbComponentDescriptor.VTable, self.vtable).GetComponentTag(@ptrCast(*const IDvbComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbComponentDescriptor.VTable, self.vtable).GetLanguageCode(@ptrCast(*const IDvbComponentDescriptor, self), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbComponentDescriptor.VTable, self.vtable).GetTextW(@ptrCast(*const IDvbComponentDescriptor, self), convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbContentDescriptor_Value = @import("../zig.zig").Guid.initString("2e883881-a467-412a-9d63-6f2b6da05bf0");
pub const IID_IDvbContentDescriptor = &IID_IDvbContentDescriptor_Value;
pub const IDvbContentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordContentNibbles: fn(
            self: *const IDvbContentDescriptor,
            bRecordIndex: u8,
            pbValLevel1: ?*u8,
            pbValLevel2: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordUserNibbles: fn(
            self: *const IDvbContentDescriptor,
            bRecordIndex: u8,
            pbVal1: ?*u8,
            pbVal2: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbContentDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbContentDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbContentDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetRecordContentNibbles(self: *const T, bRecordIndex: u8, pbValLevel1: ?*u8, pbValLevel2: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbContentDescriptor.VTable, self.vtable).GetRecordContentNibbles(@ptrCast(*const IDvbContentDescriptor, self), bRecordIndex, pbValLevel1, pbValLevel2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetRecordUserNibbles(self: *const T, bRecordIndex: u8, pbVal1: ?*u8, pbVal2: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbContentDescriptor.VTable, self.vtable).GetRecordUserNibbles(@ptrCast(*const IDvbContentDescriptor, self), bRecordIndex, pbVal1, pbVal2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbParentalRatingDescriptor_Value = @import("../zig.zig").Guid.initString("3ad9dde1-fb1b-4186-937f-22e6b5a72a10");
pub const IID_IDvbParentalRatingDescriptor = &IID_IDvbParentalRatingDescriptor_Value;
pub const IDvbParentalRatingDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IDvbParentalRatingDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IDvbParentalRatingDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IDvbParentalRatingDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordRating: fn(
            self: *const IDvbParentalRatingDescriptor,
            bRecordIndex: u8,
            pszCountryCode: *[4]u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbParentalRatingDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbParentalRatingDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IDvbParentalRatingDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbParentalRatingDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbParentalRatingDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IDvbParentalRatingDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbParentalRatingDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbParentalRatingDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IDvbParentalRatingDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbParentalRatingDescriptor_GetRecordRating(self: *const T, bRecordIndex: u8, pszCountryCode: *[4]u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDvbParentalRatingDescriptor.VTable, self.vtable).GetRecordRating(@ptrCast(*const IDvbParentalRatingDescriptor, self), bRecordIndex, pszCountryCode, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbTerrestrialDeliverySystemDescriptor_Value = @import("../zig.zig").Guid.initString("39fae0a6-d151-44dd-a28a-765de5991670");
pub const IID_IIsdbTerrestrialDeliverySystemDescriptor = &IID_IIsdbTerrestrialDeliverySystemDescriptor_Value;
pub const IIsdbTerrestrialDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAreaCode: fn(
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuardInterval: fn(
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransmissionMode: fn(
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordFrequency: fn(
            self: *const IIsdbTerrestrialDeliverySystemDescriptor,
            bRecordIndex: u8,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetAreaCode(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetAreaCode(@ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetGuardInterval(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetGuardInterval(@ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetTransmissionMode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetTransmissionMode(@ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetRecordFrequency(self: *const T, bRecordIndex: u8, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, self.vtable).GetRecordFrequency(@ptrCast(*const IIsdbTerrestrialDeliverySystemDescriptor, self), bRecordIndex, pdwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbTSInformationDescriptor_Value = @import("../zig.zig").Guid.initString("d7ad183e-38f5-4210-b55f-ec8d601bbd47");
pub const IID_IIsdbTSInformationDescriptor = &IID_IIsdbTSInformationDescriptor_Value;
pub const IIsdbTSInformationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbTSInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbTSInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRemoteControlKeyId: fn(
            self: *const IIsdbTSInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTSNameW: fn(
            self: *const IIsdbTSInformationDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IIsdbTSInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTransmissionTypeInfo: fn(
            self: *const IIsdbTSInformationDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumberOfServices: fn(
            self: *const IIsdbTSInformationDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordServiceIdByIndex: fn(
            self: *const IIsdbTSInformationDescriptor,
            bRecordIndex: u8,
            bServiceIndex: u8,
            pdwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTSInformationDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbTSInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTSInformationDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbTSInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetRemoteControlKeyId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTSInformationDescriptor.VTable, self.vtable).GetRemoteControlKeyId(@ptrCast(*const IIsdbTSInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetTSNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTSInformationDescriptor.VTable, self.vtable).GetTSNameW(@ptrCast(*const IIsdbTSInformationDescriptor, self), convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTSInformationDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IIsdbTSInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetRecordTransmissionTypeInfo(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTSInformationDescriptor.VTable, self.vtable).GetRecordTransmissionTypeInfo(@ptrCast(*const IIsdbTSInformationDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetRecordNumberOfServices(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTSInformationDescriptor.VTable, self.vtable).GetRecordNumberOfServices(@ptrCast(*const IIsdbTSInformationDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetRecordServiceIdByIndex(self: *const T, bRecordIndex: u8, bServiceIndex: u8, pdwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbTSInformationDescriptor.VTable, self.vtable).GetRecordServiceIdByIndex(@ptrCast(*const IIsdbTSInformationDescriptor, self), bRecordIndex, bServiceIndex, pdwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbDigitalCopyControlDescriptor_Value = @import("../zig.zig").Guid.initString("1a28417e-266a-4bb8-a4bd-d782bcfb8161");
pub const IID_IIsdbDigitalCopyControlDescriptor = &IID_IIsdbDigitalCopyControlDescriptor_Value;
pub const IIsdbDigitalCopyControlDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbDigitalCopyControlDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbDigitalCopyControlDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCopyControl: fn(
            self: *const IIsdbDigitalCopyControlDescriptor,
            pbDigitalRecordingControlData: ?*u8,
            pbCopyControlType: ?*u8,
            pbAPSControlData: ?*u8,
            pbMaximumBitrate: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IIsdbDigitalCopyControlDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCopyControl: fn(
            self: *const IIsdbDigitalCopyControlDescriptor,
            bRecordIndex: u8,
            pbComponentTag: ?*u8,
            pbDigitalRecordingControlData: ?*u8,
            pbCopyControlType: ?*u8,
            pbAPSControlData: ?*u8,
            pbMaximumBitrate: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDigitalCopyControlDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbDigitalCopyControlDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDigitalCopyControlDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbDigitalCopyControlDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetCopyControl(self: *const T, pbDigitalRecordingControlData: ?*u8, pbCopyControlType: ?*u8, pbAPSControlData: ?*u8, pbMaximumBitrate: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDigitalCopyControlDescriptor.VTable, self.vtable).GetCopyControl(@ptrCast(*const IIsdbDigitalCopyControlDescriptor, self), pbDigitalRecordingControlData, pbCopyControlType, pbAPSControlData, pbMaximumBitrate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDigitalCopyControlDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IIsdbDigitalCopyControlDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetRecordCopyControl(self: *const T, bRecordIndex: u8, pbComponentTag: ?*u8, pbDigitalRecordingControlData: ?*u8, pbCopyControlType: ?*u8, pbAPSControlData: ?*u8, pbMaximumBitrate: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDigitalCopyControlDescriptor.VTable, self.vtable).GetRecordCopyControl(@ptrCast(*const IIsdbDigitalCopyControlDescriptor, self), bRecordIndex, pbComponentTag, pbDigitalRecordingControlData, pbCopyControlType, pbAPSControlData, pbMaximumBitrate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbAudioComponentDescriptor_Value = @import("../zig.zig").Guid.initString("679d2002-2425-4be4-a4c7-d6632a574f4d");
pub const IID_IIsdbAudioComponentDescriptor = &IID_IIsdbAudioComponentDescriptor_Value;
pub const IIsdbAudioComponentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamContent: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentType: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentTag: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamType: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSimulcastGroupTag: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetESMultiLingualFlag: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainComponentFlag: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pfVal: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQualityIndicator: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSamplingRate: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pszCode: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode2: fn(
            self: *const IIsdbAudioComponentDescriptor,
            pszCode: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: fn(
            self: *const IIsdbAudioComponentDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetStreamContent(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetStreamContent(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetComponentType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetComponentType(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetComponentTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetComponentTag(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetStreamType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetStreamType(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetSimulcastGroupTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetSimulcastGroupTag(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetESMultiLingualFlag(self: *const T, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetESMultiLingualFlag(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetMainComponentFlag(self: *const T, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetMainComponentFlag(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetQualityIndicator(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetQualityIndicator(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetSamplingRate(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetSamplingRate(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetLanguageCode(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetLanguageCode2(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetLanguageCode2(@ptrCast(*const IIsdbAudioComponentDescriptor, self), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbAudioComponentDescriptor.VTable, self.vtable).GetTextW(@ptrCast(*const IIsdbAudioComponentDescriptor, self), convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbDataContentDescriptor_Value = @import("../zig.zig").Guid.initString("a428100a-e646-4bd6-aa14-6087bdc08cd5");
pub const IID_IIsdbDataContentDescriptor = &IID_IIsdbDataContentDescriptor_Value;
pub const IIsdbDataContentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbDataContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbDataContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataComponentId: fn(
            self: *const IIsdbDataContentDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntryComponent: fn(
            self: *const IIsdbDataContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectorLength: fn(
            self: *const IIsdbDataContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectorBytes: fn(
            self: *const IIsdbDataContentDescriptor,
            bBufLength: u8,
            pbBuf: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IIsdbDataContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordComponentRef: fn(
            self: *const IIsdbDataContentDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageCode: fn(
            self: *const IIsdbDataContentDescriptor,
            pszCode: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: fn(
            self: *const IIsdbDataContentDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbDataContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbDataContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetDataComponentId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetDataComponentId(@ptrCast(*const IIsdbDataContentDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetEntryComponent(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetEntryComponent(@ptrCast(*const IIsdbDataContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetSelectorLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetSelectorLength(@ptrCast(*const IIsdbDataContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetSelectorBytes(self: *const T, bBufLength: u8, pbBuf: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetSelectorBytes(@ptrCast(*const IIsdbDataContentDescriptor, self), bBufLength, pbBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IIsdbDataContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetRecordComponentRef(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetRecordComponentRef(@ptrCast(*const IIsdbDataContentDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetLanguageCode(@ptrCast(*const IIsdbDataContentDescriptor, self), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDataContentDescriptor.VTable, self.vtable).GetTextW(@ptrCast(*const IIsdbDataContentDescriptor, self), convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbCAContractInformationDescriptor_Value = @import("../zig.zig").Guid.initString("08e18b25-a28f-4e92-821e-4fced5cc2291");
pub const IID_IIsdbCAContractInformationDescriptor = &IID_IIsdbCAContractInformationDescriptor_Value;
pub const IIsdbCAContractInformationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbCAContractInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbCAContractInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASystemId: fn(
            self: *const IIsdbCAContractInformationDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAUnitId: fn(
            self: *const IIsdbCAContractInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IIsdbCAContractInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordComponentTag: fn(
            self: *const IIsdbCAContractInformationDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContractVerificationInfoLength: fn(
            self: *const IIsdbCAContractInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContractVerificationInfo: fn(
            self: *const IIsdbCAContractInformationDescriptor,
            bBufLength: u8,
            pbBuf: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFeeNameW: fn(
            self: *const IIsdbCAContractInformationDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAContractInformationDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbCAContractInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAContractInformationDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbCAContractInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetCASystemId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAContractInformationDescriptor.VTable, self.vtable).GetCASystemId(@ptrCast(*const IIsdbCAContractInformationDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetCAUnitId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAContractInformationDescriptor.VTable, self.vtable).GetCAUnitId(@ptrCast(*const IIsdbCAContractInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAContractInformationDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IIsdbCAContractInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetRecordComponentTag(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAContractInformationDescriptor.VTable, self.vtable).GetRecordComponentTag(@ptrCast(*const IIsdbCAContractInformationDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetContractVerificationInfoLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAContractInformationDescriptor.VTable, self.vtable).GetContractVerificationInfoLength(@ptrCast(*const IIsdbCAContractInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetContractVerificationInfo(self: *const T, bBufLength: u8, pbBuf: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAContractInformationDescriptor.VTable, self.vtable).GetContractVerificationInfo(@ptrCast(*const IIsdbCAContractInformationDescriptor, self), bBufLength, pbBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetFeeNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAContractInformationDescriptor.VTable, self.vtable).GetFeeNameW(@ptrCast(*const IIsdbCAContractInformationDescriptor, self), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbEventGroupDescriptor_Value = @import("../zig.zig").Guid.initString("94b06780-2e2a-44dc-a966-cc56fdabc6c2");
pub const IID_IIsdbEventGroupDescriptor = &IID_IIsdbEventGroupDescriptor_Value;
pub const IIsdbEventGroupDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbEventGroupDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbEventGroupDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroupType: fn(
            self: *const IIsdbEventGroupDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IIsdbEventGroupDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEvent: fn(
            self: *const IIsdbEventGroupDescriptor,
            bRecordIndex: u8,
            pwServiceId: ?*u16,
            pwEventId: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRefRecords: fn(
            self: *const IIsdbEventGroupDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRefRecordEvent: fn(
            self: *const IIsdbEventGroupDescriptor,
            bRecordIndex: u8,
            pwOriginalNetworkId: ?*u16,
            pwTransportStreamId: ?*u16,
            pwServiceId: ?*u16,
            pwEventId: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEventGroupDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbEventGroupDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEventGroupDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbEventGroupDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetGroupType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEventGroupDescriptor.VTable, self.vtable).GetGroupType(@ptrCast(*const IIsdbEventGroupDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEventGroupDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IIsdbEventGroupDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetRecordEvent(self: *const T, bRecordIndex: u8, pwServiceId: ?*u16, pwEventId: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEventGroupDescriptor.VTable, self.vtable).GetRecordEvent(@ptrCast(*const IIsdbEventGroupDescriptor, self), bRecordIndex, pwServiceId, pwEventId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetCountOfRefRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEventGroupDescriptor.VTable, self.vtable).GetCountOfRefRecords(@ptrCast(*const IIsdbEventGroupDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetRefRecordEvent(self: *const T, bRecordIndex: u8, pwOriginalNetworkId: ?*u16, pwTransportStreamId: ?*u16, pwServiceId: ?*u16, pwEventId: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEventGroupDescriptor.VTable, self.vtable).GetRefRecordEvent(@ptrCast(*const IIsdbEventGroupDescriptor, self), bRecordIndex, pwOriginalNetworkId, pwTransportStreamId, pwServiceId, pwEventId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbComponentGroupDescriptor_Value = @import("../zig.zig").Guid.initString("a494f17f-c592-47d8-8943-64c9a34be7b9");
pub const IID_IIsdbComponentGroupDescriptor = &IID_IIsdbComponentGroupDescriptor_Value;
pub const IIsdbComponentGroupDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbComponentGroupDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbComponentGroupDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentGroupType: fn(
            self: *const IIsdbComponentGroupDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IIsdbComponentGroupDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordGroupId: fn(
            self: *const IIsdbComponentGroupDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumberOfCAUnit: fn(
            self: *const IIsdbComponentGroupDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCAUnitCAUnitId: fn(
            self: *const IIsdbComponentGroupDescriptor,
            bRecordIndex: u8,
            bCAUnitIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCAUnitNumberOfComponents: fn(
            self: *const IIsdbComponentGroupDescriptor,
            bRecordIndex: u8,
            bCAUnitIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCAUnitComponentTag: fn(
            self: *const IIsdbComponentGroupDescriptor,
            bRecordIndex: u8,
            bCAUnitIndex: u8,
            bComponentIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTotalBitRate: fn(
            self: *const IIsdbComponentGroupDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordTextW: fn(
            self: *const IIsdbComponentGroupDescriptor,
            bRecordIndex: u8,
            convMode: DVB_STRCONV_MODE,
            pbstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbComponentGroupDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbComponentGroupDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetComponentGroupType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetComponentGroupType(@ptrCast(*const IIsdbComponentGroupDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IIsdbComponentGroupDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordGroupId(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetRecordGroupId(@ptrCast(*const IIsdbComponentGroupDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordNumberOfCAUnit(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetRecordNumberOfCAUnit(@ptrCast(*const IIsdbComponentGroupDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordCAUnitCAUnitId(self: *const T, bRecordIndex: u8, bCAUnitIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetRecordCAUnitCAUnitId(@ptrCast(*const IIsdbComponentGroupDescriptor, self), bRecordIndex, bCAUnitIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordCAUnitNumberOfComponents(self: *const T, bRecordIndex: u8, bCAUnitIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetRecordCAUnitNumberOfComponents(@ptrCast(*const IIsdbComponentGroupDescriptor, self), bRecordIndex, bCAUnitIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordCAUnitComponentTag(self: *const T, bRecordIndex: u8, bCAUnitIndex: u8, bComponentIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetRecordCAUnitComponentTag(@ptrCast(*const IIsdbComponentGroupDescriptor, self), bRecordIndex, bCAUnitIndex, bComponentIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordTotalBitRate(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetRecordTotalBitRate(@ptrCast(*const IIsdbComponentGroupDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordTextW(self: *const T, bRecordIndex: u8, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbComponentGroupDescriptor.VTable, self.vtable).GetRecordTextW(@ptrCast(*const IIsdbComponentGroupDescriptor, self), bRecordIndex, convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbSeriesDescriptor_Value = @import("../zig.zig").Guid.initString("07ef6370-1660-4f26-87fc-614adab24b11");
pub const IID_IIsdbSeriesDescriptor = &IID_IIsdbSeriesDescriptor_Value;
pub const IIsdbSeriesDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbSeriesDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbSeriesDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSeriesId: fn(
            self: *const IIsdbSeriesDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRepeatLabel: fn(
            self: *const IIsdbSeriesDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgramPattern: fn(
            self: *const IIsdbSeriesDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpireDate: fn(
            self: *const IIsdbSeriesDescriptor,
            pfValid: ?*BOOL,
            pmdtVal: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEpisodeNumber: fn(
            self: *const IIsdbSeriesDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEpisodeNumber: fn(
            self: *const IIsdbSeriesDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSeriesNameW: fn(
            self: *const IIsdbSeriesDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSeriesDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbSeriesDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSeriesDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbSeriesDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetSeriesId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSeriesDescriptor.VTable, self.vtable).GetSeriesId(@ptrCast(*const IIsdbSeriesDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetRepeatLabel(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSeriesDescriptor.VTable, self.vtable).GetRepeatLabel(@ptrCast(*const IIsdbSeriesDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetProgramPattern(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSeriesDescriptor.VTable, self.vtable).GetProgramPattern(@ptrCast(*const IIsdbSeriesDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetExpireDate(self: *const T, pfValid: ?*BOOL, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSeriesDescriptor.VTable, self.vtable).GetExpireDate(@ptrCast(*const IIsdbSeriesDescriptor, self), pfValid, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetEpisodeNumber(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSeriesDescriptor.VTable, self.vtable).GetEpisodeNumber(@ptrCast(*const IIsdbSeriesDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetLastEpisodeNumber(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSeriesDescriptor.VTable, self.vtable).GetLastEpisodeNumber(@ptrCast(*const IIsdbSeriesDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetSeriesNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSeriesDescriptor.VTable, self.vtable).GetSeriesNameW(@ptrCast(*const IIsdbSeriesDescriptor, self), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbDownloadContentDescriptor_Value = @import("../zig.zig").Guid.initString("5298661e-cb88-4f5f-a1de-5f440c185b92");
pub const IID_IIsdbDownloadContentDescriptor = &IID_IIsdbDownloadContentDescriptor_Value;
pub const IIsdbDownloadContentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pfReboot: ?*BOOL,
            pfAddOn: ?*BOOL,
            pfCompatibility: ?*BOOL,
            pfModuleInfo: ?*BOOL,
            pfTextInfo: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentSize: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDownloadId: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeOutValueDII: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeakRate: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentTag: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompatiblityDescriptorLength: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pwLength: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompatiblityDescriptor: fn(
            self: *const IIsdbDownloadContentDescriptor,
            ppbData: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IIsdbDownloadContentDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModuleId: fn(
            self: *const IIsdbDownloadContentDescriptor,
            wRecordIndex: u16,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModuleSize: fn(
            self: *const IIsdbDownloadContentDescriptor,
            wRecordIndex: u16,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModuleInfoLength: fn(
            self: *const IIsdbDownloadContentDescriptor,
            wRecordIndex: u16,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordModuleInfo: fn(
            self: *const IIsdbDownloadContentDescriptor,
            wRecordIndex: u16,
            ppbData: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextLanguageCode: fn(
            self: *const IIsdbDownloadContentDescriptor,
            szCode: *[4]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextW: fn(
            self: *const IIsdbDownloadContentDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetFlags(self: *const T, pfReboot: ?*BOOL, pfAddOn: ?*BOOL, pfCompatibility: ?*BOOL, pfModuleInfo: ?*BOOL, pfTextInfo: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetFlags(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pfReboot, pfAddOn, pfCompatibility, pfModuleInfo, pfTextInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetComponentSize(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetComponentSize(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetDownloadId(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetDownloadId(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetTimeOutValueDII(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetTimeOutValueDII(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetLeakRate(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetLeakRate(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetComponentTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetComponentTag(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetCompatiblityDescriptorLength(self: *const T, pwLength: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetCompatiblityDescriptorLength(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetCompatiblityDescriptor(self: *const T, ppbData: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetCompatiblityDescriptor(@ptrCast(*const IIsdbDownloadContentDescriptor, self), ppbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetCountOfRecords(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IIsdbDownloadContentDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetRecordModuleId(self: *const T, wRecordIndex: u16, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetRecordModuleId(@ptrCast(*const IIsdbDownloadContentDescriptor, self), wRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetRecordModuleSize(self: *const T, wRecordIndex: u16, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetRecordModuleSize(@ptrCast(*const IIsdbDownloadContentDescriptor, self), wRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetRecordModuleInfoLength(self: *const T, wRecordIndex: u16, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetRecordModuleInfoLength(@ptrCast(*const IIsdbDownloadContentDescriptor, self), wRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetRecordModuleInfo(self: *const T, wRecordIndex: u16, ppbData: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetRecordModuleInfo(@ptrCast(*const IIsdbDownloadContentDescriptor, self), wRecordIndex, ppbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetTextLanguageCode(self: *const T, szCode: *[4]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetTextLanguageCode(@ptrCast(*const IIsdbDownloadContentDescriptor, self), szCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbDownloadContentDescriptor.VTable, self.vtable).GetTextW(@ptrCast(*const IIsdbDownloadContentDescriptor, self), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbLogoTransmissionDescriptor_Value = @import("../zig.zig").Guid.initString("e0103f49-4ae1-4f07-9098-756db1fa88cd");
pub const IID_IIsdbLogoTransmissionDescriptor = &IID_IIsdbLogoTransmissionDescriptor_Value;
pub const IIsdbLogoTransmissionDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbLogoTransmissionDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbLogoTransmissionDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogoTransmissionType: fn(
            self: *const IIsdbLogoTransmissionDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogoId: fn(
            self: *const IIsdbLogoTransmissionDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogoVersion: fn(
            self: *const IIsdbLogoTransmissionDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDownloadDataId: fn(
            self: *const IIsdbLogoTransmissionDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogoCharW: fn(
            self: *const IIsdbLogoTransmissionDescriptor,
            convMode: DVB_STRCONV_MODE,
            pbstrChar: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbLogoTransmissionDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbLogoTransmissionDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbLogoTransmissionDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbLogoTransmissionDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLogoTransmissionType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbLogoTransmissionDescriptor.VTable, self.vtable).GetLogoTransmissionType(@ptrCast(*const IIsdbLogoTransmissionDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLogoId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbLogoTransmissionDescriptor.VTable, self.vtable).GetLogoId(@ptrCast(*const IIsdbLogoTransmissionDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLogoVersion(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbLogoTransmissionDescriptor.VTable, self.vtable).GetLogoVersion(@ptrCast(*const IIsdbLogoTransmissionDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetDownloadDataId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbLogoTransmissionDescriptor.VTable, self.vtable).GetDownloadDataId(@ptrCast(*const IIsdbLogoTransmissionDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLogoCharW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrChar: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbLogoTransmissionDescriptor.VTable, self.vtable).GetLogoCharW(@ptrCast(*const IIsdbLogoTransmissionDescriptor, self), convMode, pbstrChar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbSIParameterDescriptor_Value = @import("../zig.zig").Guid.initString("f837dc36-867c-426a-9111-f62093951a45");
pub const IID_IIsdbSIParameterDescriptor = &IID_IIsdbSIParameterDescriptor_Value;
pub const IIsdbSIParameterDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbSIParameterDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbSIParameterDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameterVersion: fn(
            self: *const IIsdbSIParameterDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUpdateTime: fn(
            self: *const IIsdbSIParameterDescriptor,
            pVal: ?*MPEG_DATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordNumberOfTable: fn(
            self: *const IIsdbSIParameterDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableId: fn(
            self: *const IIsdbSIParameterDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptionLength: fn(
            self: *const IIsdbSIParameterDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableDescriptionBytes: fn(
            self: *const IIsdbSIParameterDescriptor,
            bRecordIndex: u8,
            pbBufferLength: ?*u8,
            pbBuffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSIParameterDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbSIParameterDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSIParameterDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbSIParameterDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetParameterVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSIParameterDescriptor.VTable, self.vtable).GetParameterVersion(@ptrCast(*const IIsdbSIParameterDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetUpdateTime(self: *const T, pVal: ?*MPEG_DATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSIParameterDescriptor.VTable, self.vtable).GetUpdateTime(@ptrCast(*const IIsdbSIParameterDescriptor, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetRecordNumberOfTable(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSIParameterDescriptor.VTable, self.vtable).GetRecordNumberOfTable(@ptrCast(*const IIsdbSIParameterDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetTableId(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSIParameterDescriptor.VTable, self.vtable).GetTableId(@ptrCast(*const IIsdbSIParameterDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetTableDescriptionLength(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSIParameterDescriptor.VTable, self.vtable).GetTableDescriptionLength(@ptrCast(*const IIsdbSIParameterDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetTableDescriptionBytes(self: *const T, bRecordIndex: u8, pbBufferLength: ?*u8, pbBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbSIParameterDescriptor.VTable, self.vtable).GetTableDescriptionBytes(@ptrCast(*const IIsdbSIParameterDescriptor, self), bRecordIndex, pbBufferLength, pbBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbEmergencyInformationDescriptor_Value = @import("../zig.zig").Guid.initString("ba6fa681-b973-4da1-9207-ac3e7f0341eb");
pub const IID_IIsdbEmergencyInformationDescriptor = &IID_IIsdbEmergencyInformationDescriptor_Value;
pub const IIsdbEmergencyInformationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbEmergencyInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbEmergencyInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IIsdbEmergencyInformationDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceId: fn(
            self: *const IIsdbEmergencyInformationDescriptor,
            bRecordIndex: u8,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartEndFlag: fn(
            self: *const IIsdbEmergencyInformationDescriptor,
            bRecordIndex: u8,
            pVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignalLevel: fn(
            self: *const IIsdbEmergencyInformationDescriptor,
            bRecordIndex: u8,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAreaCode: fn(
            self: *const IIsdbEmergencyInformationDescriptor,
            bRecordIndex: u8,
            ppwVal: ?*?*u16,
            pbNumAreaCodes: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEmergencyInformationDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbEmergencyInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEmergencyInformationDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbEmergencyInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEmergencyInformationDescriptor.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IIsdbEmergencyInformationDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetServiceId(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEmergencyInformationDescriptor.VTable, self.vtable).GetServiceId(@ptrCast(*const IIsdbEmergencyInformationDescriptor, self), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetStartEndFlag(self: *const T, bRecordIndex: u8, pVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEmergencyInformationDescriptor.VTable, self.vtable).GetStartEndFlag(@ptrCast(*const IIsdbEmergencyInformationDescriptor, self), bRecordIndex, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetSignalLevel(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEmergencyInformationDescriptor.VTable, self.vtable).GetSignalLevel(@ptrCast(*const IIsdbEmergencyInformationDescriptor, self), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetAreaCode(self: *const T, bRecordIndex: u8, ppwVal: ?*?*u16, pbNumAreaCodes: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbEmergencyInformationDescriptor.VTable, self.vtable).GetAreaCode(@ptrCast(*const IIsdbEmergencyInformationDescriptor, self), bRecordIndex, ppwVal, pbNumAreaCodes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbCADescriptor_Value = @import("../zig.zig").Guid.initString("0570aa47-52bc-42ae-8ca5-969f41e81aea");
pub const IID_IIsdbCADescriptor = &IID_IIsdbCADescriptor_Value;
pub const IIsdbCADescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbCADescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbCADescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASystemId: fn(
            self: *const IIsdbCADescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReservedBits: fn(
            self: *const IIsdbCADescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCAPID: fn(
            self: *const IIsdbCADescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateDataBytes: fn(
            self: *const IIsdbCADescriptor,
            pbBufferLength: ?*u8,
            pbBuffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCADescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbCADescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCADescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbCADescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetCASystemId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCADescriptor.VTable, self.vtable).GetCASystemId(@ptrCast(*const IIsdbCADescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetReservedBits(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCADescriptor.VTable, self.vtable).GetReservedBits(@ptrCast(*const IIsdbCADescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetCAPID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCADescriptor.VTable, self.vtable).GetCAPID(@ptrCast(*const IIsdbCADescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetPrivateDataBytes(self: *const T, pbBufferLength: ?*u8, pbBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCADescriptor.VTable, self.vtable).GetPrivateDataBytes(@ptrCast(*const IIsdbCADescriptor, self), pbBufferLength, pbBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbCAServiceDescriptor_Value = @import("../zig.zig").Guid.initString("39cbeb97-ff0b-42a7-9ab9-7b9cfe70a77a");
pub const IID_IIsdbCAServiceDescriptor = &IID_IIsdbCAServiceDescriptor_Value;
pub const IIsdbCAServiceDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbCAServiceDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbCAServiceDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASystemId: fn(
            self: *const IIsdbCAServiceDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCABroadcasterGroupId: fn(
            self: *const IIsdbCAServiceDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageControl: fn(
            self: *const IIsdbCAServiceDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceIds: fn(
            self: *const IIsdbCAServiceDescriptor,
            pbNumServiceIds: ?*u8,
            pwServiceIds: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAServiceDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbCAServiceDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAServiceDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbCAServiceDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetCASystemId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAServiceDescriptor.VTable, self.vtable).GetCASystemId(@ptrCast(*const IIsdbCAServiceDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetCABroadcasterGroupId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAServiceDescriptor.VTable, self.vtable).GetCABroadcasterGroupId(@ptrCast(*const IIsdbCAServiceDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetMessageControl(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAServiceDescriptor.VTable, self.vtable).GetMessageControl(@ptrCast(*const IIsdbCAServiceDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetServiceIds(self: *const T, pbNumServiceIds: ?*u8, pwServiceIds: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbCAServiceDescriptor.VTable, self.vtable).GetServiceIds(@ptrCast(*const IIsdbCAServiceDescriptor, self), pbNumServiceIds, pwServiceIds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbHierarchicalTransmissionDescriptor_Value = @import("../zig.zig").Guid.initString("b7b3ae90-ee0b-446d-8769-f7e2aa266aa6");
pub const IID_IIsdbHierarchicalTransmissionDescriptor = &IID_IIsdbHierarchicalTransmissionDescriptor_Value;
pub const IIsdbHierarchicalTransmissionDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFutureUse1: fn(
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQualityLevel: fn(
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFutureUse2: fn(
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReferencePid: fn(
            self: *const IIsdbHierarchicalTransmissionDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbHierarchicalTransmissionDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IIsdbHierarchicalTransmissionDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbHierarchicalTransmissionDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IIsdbHierarchicalTransmissionDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetFutureUse1(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbHierarchicalTransmissionDescriptor.VTable, self.vtable).GetFutureUse1(@ptrCast(*const IIsdbHierarchicalTransmissionDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetQualityLevel(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbHierarchicalTransmissionDescriptor.VTable, self.vtable).GetQualityLevel(@ptrCast(*const IIsdbHierarchicalTransmissionDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetFutureUse2(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbHierarchicalTransmissionDescriptor.VTable, self.vtable).GetFutureUse2(@ptrCast(*const IIsdbHierarchicalTransmissionDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetReferencePid(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsdbHierarchicalTransmissionDescriptor.VTable, self.vtable).GetReferencePid(@ptrCast(*const IIsdbHierarchicalTransmissionDescriptor, self), pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDASiParser_Value = @import("../zig.zig").Guid.initString("9de49a74-aba2-4a18-93e1-21f17f95c3c3");
pub const IID_IPBDASiParser = &IID_IPBDASiParser_Value;
pub const IPBDASiParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IPBDASiParser,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEIT: fn(
            self: *const IPBDASiParser,
            dwSize: u32,
            pBuffer: ?*u8,
            ppEIT: ?*?*IPBDA_EIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServices: fn(
            self: *const IPBDASiParser,
            dwSize: u32,
            pBuffer: ?*const u8,
            ppServices: ?*?*IPBDA_Services,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDASiParser_Initialize(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDASiParser.VTable, self.vtable).Initialize(@ptrCast(*const IPBDASiParser, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDASiParser_GetEIT(self: *const T, dwSize: u32, pBuffer: ?*u8, ppEIT: ?*?*IPBDA_EIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDASiParser.VTable, self.vtable).GetEIT(@ptrCast(*const IPBDASiParser, self), dwSize, pBuffer, ppEIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDASiParser_GetServices(self: *const T, dwSize: u32, pBuffer: ?*const u8, ppServices: ?*?*IPBDA_Services) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDASiParser.VTable, self.vtable).GetServices(@ptrCast(*const IPBDASiParser, self), dwSize, pBuffer, ppServices);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDA_EIT_Value = @import("../zig.zig").Guid.initString("a35f2dea-098f-4ebd-984c-2bd4c3c8ce0a");
pub const IID_IPBDA_EIT = &IID_IPBDA_EIT_Value;
pub const IPBDA_EIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IPBDA_EIT,
            size: u32,
            pBuffer: ?*const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTableId: fn(
            self: *const IPBDA_EIT,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IPBDA_EIT,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceIdx: fn(
            self: *const IPBDA_EIT,
            plwVal: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IPBDA_EIT,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordEventId: fn(
            self: *const IPBDA_EIT,
            dwRecordIndex: u32,
            plwVal: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordStartTime: fn(
            self: *const IPBDA_EIT,
            dwRecordIndex: u32,
            pmdtVal: ?*MPEG_DATE_AND_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDuration: fn(
            self: *const IPBDA_EIT,
            dwRecordIndex: u32,
            pmdVal: ?*MPEG_TIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCountOfDescriptors: fn(
            self: *const IPBDA_EIT,
            dwRecordIndex: u32,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByIndex: fn(
            self: *const IPBDA_EIT,
            dwRecordIndex: u32,
            dwIndex: u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordDescriptorByTag: fn(
            self: *const IPBDA_EIT,
            dwRecordIndex: u32,
            bTag: u8,
            pdwCookie: ?*u32,
            ppDescriptor: ?*?*IGenericDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_Initialize(self: *const T, size: u32, pBuffer: ?*const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).Initialize(@ptrCast(*const IPBDA_EIT, self), size, pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetTableId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetTableId(@ptrCast(*const IPBDA_EIT, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetVersionNumber(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IPBDA_EIT, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetServiceIdx(self: *const T, plwVal: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetServiceIdx(@ptrCast(*const IPBDA_EIT, self), plwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IPBDA_EIT, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordEventId(self: *const T, dwRecordIndex: u32, plwVal: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetRecordEventId(@ptrCast(*const IPBDA_EIT, self), dwRecordIndex, plwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordStartTime(self: *const T, dwRecordIndex: u32, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetRecordStartTime(@ptrCast(*const IPBDA_EIT, self), dwRecordIndex, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordDuration(self: *const T, dwRecordIndex: u32, pmdVal: ?*MPEG_TIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetRecordDuration(@ptrCast(*const IPBDA_EIT, self), dwRecordIndex, pmdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetRecordCountOfDescriptors(@ptrCast(*const IPBDA_EIT, self), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetRecordDescriptorByIndex(@ptrCast(*const IPBDA_EIT, self), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_EIT.VTable, self.vtable).GetRecordDescriptorByTag(@ptrCast(*const IPBDA_EIT, self), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDA_Services_Value = @import("../zig.zig").Guid.initString("944eab37-eed4-4850-afd2-77e7efeb4427");
pub const IID_IPBDA_Services = &IID_IPBDA_Services_Value;
pub const IPBDA_Services = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IPBDA_Services,
            size: u32,
            pBuffer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCountOfRecords: fn(
            self: *const IPBDA_Services,
            pdwVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordByIndex: fn(
            self: *const IPBDA_Services,
            dwRecordIndex: u32,
            pul64ServiceIdx: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_Services_Initialize(self: *const T, size: u32, pBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_Services.VTable, self.vtable).Initialize(@ptrCast(*const IPBDA_Services, self), size, pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_Services_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_Services.VTable, self.vtable).GetCountOfRecords(@ptrCast(*const IPBDA_Services, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_Services_GetRecordByIndex(self: *const T, dwRecordIndex: u32, pul64ServiceIdx: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDA_Services.VTable, self.vtable).GetRecordByIndex(@ptrCast(*const IPBDA_Services, self), dwRecordIndex, pul64ServiceIdx);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDAEntitlementDescriptor_Value = @import("../zig.zig").Guid.initString("22632497-0de3-4587-aadc-d8d99017e760");
pub const IID_IPBDAEntitlementDescriptor = &IID_IPBDAEntitlementDescriptor_Value;
pub const IPBDAEntitlementDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IPBDAEntitlementDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IPBDAEntitlementDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetToken: fn(
            self: *const IPBDAEntitlementDescriptor,
            ppbTokenBuffer: ?*?*u8,
            pdwTokenLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAEntitlementDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDAEntitlementDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IPBDAEntitlementDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAEntitlementDescriptor_GetLength(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDAEntitlementDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IPBDAEntitlementDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAEntitlementDescriptor_GetToken(self: *const T, ppbTokenBuffer: ?*?*u8, pdwTokenLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDAEntitlementDescriptor.VTable, self.vtable).GetToken(@ptrCast(*const IPBDAEntitlementDescriptor, self), ppbTokenBuffer, pdwTokenLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDAAttributesDescriptor_Value = @import("../zig.zig").Guid.initString("313b3620-3263-45a6-9533-968befbeac03");
pub const IID_IPBDAAttributesDescriptor = &IID_IPBDAAttributesDescriptor_Value;
pub const IPBDAAttributesDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: fn(
            self: *const IPBDAAttributesDescriptor,
            pbVal: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IPBDAAttributesDescriptor,
            pwVal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributePayload: fn(
            self: *const IPBDAAttributesDescriptor,
            ppbAttributeBuffer: ?*?*u8,
            pdwAttributeLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAAttributesDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDAAttributesDescriptor.VTable, self.vtable).GetTag(@ptrCast(*const IPBDAAttributesDescriptor, self), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAAttributesDescriptor_GetLength(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDAAttributesDescriptor.VTable, self.vtable).GetLength(@ptrCast(*const IPBDAAttributesDescriptor, self), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAAttributesDescriptor_GetAttributePayload(self: *const T, ppbAttributeBuffer: ?*?*u8, pdwAttributeLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPBDAAttributesDescriptor.VTable, self.vtable).GetAttributePayload(@ptrCast(*const IPBDAAttributesDescriptor, self), ppbAttributeBuffer, pdwAttributeLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_TIF_REGISTRATION_Value = @import("../zig.zig").Guid.initString("dfef4a68-ee61-415f-9ccb-cd95f2f98a3a");
pub const IID_IBDA_TIF_REGISTRATION = &IID_IBDA_TIF_REGISTRATION_Value;
pub const IBDA_TIF_REGISTRATION = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterTIFEx: fn(
            self: *const IBDA_TIF_REGISTRATION,
            pTIFInputPin: ?*IPin,
            ppvRegistrationContext: ?*u32,
            ppMpeg2DataControl: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterTIF: fn(
            self: *const IBDA_TIF_REGISTRATION,
            pvRegistrationContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TIF_REGISTRATION_RegisterTIFEx(self: *const T, pTIFInputPin: ?*IPin, ppvRegistrationContext: ?*u32, ppMpeg2DataControl: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_TIF_REGISTRATION.VTable, self.vtable).RegisterTIFEx(@ptrCast(*const IBDA_TIF_REGISTRATION, self), pTIFInputPin, ppvRegistrationContext, ppMpeg2DataControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TIF_REGISTRATION_UnregisterTIF(self: *const T, pvRegistrationContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBDA_TIF_REGISTRATION.VTable, self.vtable).UnregisterTIF(@ptrCast(*const IBDA_TIF_REGISTRATION, self), pvRegistrationContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMPEG2_TIF_CONTROL_Value = @import("../zig.zig").Guid.initString("f9bac2f9-4149-4916-b2ef-faa202326862");
pub const IID_IMPEG2_TIF_CONTROL = &IID_IMPEG2_TIF_CONTROL_Value;
pub const IMPEG2_TIF_CONTROL = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterTIF: fn(
            self: *const IMPEG2_TIF_CONTROL,
            pUnkTIF: ?*IUnknown,
            ppvRegistrationContext: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterTIF: fn(
            self: *const IMPEG2_TIF_CONTROL,
            pvRegistrationContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPIDs: fn(
            self: *const IMPEG2_TIF_CONTROL,
            ulcPIDs: u32,
            pulPIDs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePIDs: fn(
            self: *const IMPEG2_TIF_CONTROL,
            ulcPIDs: u32,
            pulPIDs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPIDCount: fn(
            self: *const IMPEG2_TIF_CONTROL,
            pulcPIDs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPIDs: fn(
            self: *const IMPEG2_TIF_CONTROL,
            pulcPIDs: ?*u32,
            pulPIDs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_RegisterTIF(self: *const T, pUnkTIF: ?*IUnknown, ppvRegistrationContext: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2_TIF_CONTROL.VTable, self.vtable).RegisterTIF(@ptrCast(*const IMPEG2_TIF_CONTROL, self), pUnkTIF, ppvRegistrationContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_UnregisterTIF(self: *const T, pvRegistrationContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2_TIF_CONTROL.VTable, self.vtable).UnregisterTIF(@ptrCast(*const IMPEG2_TIF_CONTROL, self), pvRegistrationContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_AddPIDs(self: *const T, ulcPIDs: u32, pulPIDs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2_TIF_CONTROL.VTable, self.vtable).AddPIDs(@ptrCast(*const IMPEG2_TIF_CONTROL, self), ulcPIDs, pulPIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_DeletePIDs(self: *const T, ulcPIDs: u32, pulPIDs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2_TIF_CONTROL.VTable, self.vtable).DeletePIDs(@ptrCast(*const IMPEG2_TIF_CONTROL, self), ulcPIDs, pulPIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_GetPIDCount(self: *const T, pulcPIDs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2_TIF_CONTROL.VTable, self.vtable).GetPIDCount(@ptrCast(*const IMPEG2_TIF_CONTROL, self), pulcPIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_GetPIDs(self: *const T, pulcPIDs: ?*u32, pulPIDs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMPEG2_TIF_CONTROL.VTable, self.vtable).GetPIDs(@ptrCast(*const IMPEG2_TIF_CONTROL, self), pulcPIDs, pulPIDs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITuneRequestInfo_Value = @import("../zig.zig").Guid.initString("a3b152df-7a90-4218-ac54-9830bee8c0b6");
pub const IID_ITuneRequestInfo = &IID_ITuneRequestInfo_Value;
pub const ITuneRequestInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLocatorData: fn(
            self: *const ITuneRequestInfo,
            Request: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentData: fn(
            self: *const ITuneRequestInfo,
            CurrentRequest: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateComponentList: fn(
            self: *const ITuneRequestInfo,
            CurrentRequest: ?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextProgram: fn(
            self: *const ITuneRequestInfo,
            CurrentRequest: ?*ITuneRequest,
            TuneRequest: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreviousProgram: fn(
            self: *const ITuneRequestInfo,
            CurrentRequest: ?*ITuneRequest,
            TuneRequest: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextLocator: fn(
            self: *const ITuneRequestInfo,
            CurrentRequest: ?*ITuneRequest,
            TuneRequest: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreviousLocator: fn(
            self: *const ITuneRequestInfo,
            CurrentRequest: ?*ITuneRequest,
            TuneRequest: ?*?*ITuneRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetLocatorData(self: *const T, Request: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequestInfo.VTable, self.vtable).GetLocatorData(@ptrCast(*const ITuneRequestInfo, self), Request);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetComponentData(self: *const T, CurrentRequest: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequestInfo.VTable, self.vtable).GetComponentData(@ptrCast(*const ITuneRequestInfo, self), CurrentRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_CreateComponentList(self: *const T, CurrentRequest: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequestInfo.VTable, self.vtable).CreateComponentList(@ptrCast(*const ITuneRequestInfo, self), CurrentRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetNextProgram(self: *const T, CurrentRequest: ?*ITuneRequest, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequestInfo.VTable, self.vtable).GetNextProgram(@ptrCast(*const ITuneRequestInfo, self), CurrentRequest, TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetPreviousProgram(self: *const T, CurrentRequest: ?*ITuneRequest, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequestInfo.VTable, self.vtable).GetPreviousProgram(@ptrCast(*const ITuneRequestInfo, self), CurrentRequest, TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetNextLocator(self: *const T, CurrentRequest: ?*ITuneRequest, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequestInfo.VTable, self.vtable).GetNextLocator(@ptrCast(*const ITuneRequestInfo, self), CurrentRequest, TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetPreviousLocator(self: *const T, CurrentRequest: ?*ITuneRequest, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequestInfo.VTable, self.vtable).GetPreviousLocator(@ptrCast(*const ITuneRequestInfo, self), CurrentRequest, TuneRequest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITuneRequestInfoEx_Value = @import("../zig.zig").Guid.initString("ee957c52-b0d0-4e78-8dd1-b87a08bfd893");
pub const IID_ITuneRequestInfoEx = &IID_ITuneRequestInfoEx_Value;
pub const ITuneRequestInfoEx = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequestInfo.VTable,
        CreateComponentListEx: fn(
            self: *const ITuneRequestInfoEx,
            CurrentRequest: ?*ITuneRequest,
            ppCurPMT: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequestInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfoEx_CreateComponentListEx(self: *const T, CurrentRequest: ?*ITuneRequest, ppCurPMT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITuneRequestInfoEx.VTable, self.vtable).CreateComponentListEx(@ptrCast(*const ITuneRequestInfoEx, self), CurrentRequest, ppCurPMT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISIInbandEPGEvent_Value = @import("../zig.zig").Guid.initString("7e47913a-5a89-423d-9a2b-e15168858934");
pub const IID_ISIInbandEPGEvent = &IID_ISIInbandEPGEvent_Value;
pub const ISIInbandEPGEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SIObjectEvent: fn(
            self: *const ISIInbandEPGEvent,
            pIDVB_EIT: ?*IDVB_EIT2,
            dwTable_ID: u32,
            dwService_ID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISIInbandEPGEvent_SIObjectEvent(self: *const T, pIDVB_EIT: ?*IDVB_EIT2, dwTable_ID: u32, dwService_ID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISIInbandEPGEvent.VTable, self.vtable).SIObjectEvent(@ptrCast(*const ISIInbandEPGEvent, self), pIDVB_EIT, dwTable_ID, dwService_ID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISIInbandEPG_Value = @import("../zig.zig").Guid.initString("f90ad9d0-b854-4b68-9cc1-b2cc96119d85");
pub const IID_ISIInbandEPG = &IID_ISIInbandEPG_Value;
pub const ISIInbandEPG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartSIEPGScan: fn(
            self: *const ISIInbandEPG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopSIEPGScan: fn(
            self: *const ISIInbandEPG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSIEPGScanRunning: fn(
            self: *const ISIInbandEPG,
            bRunning: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISIInbandEPG_StartSIEPGScan(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISIInbandEPG.VTable, self.vtable).StartSIEPGScan(@ptrCast(*const ISIInbandEPG, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISIInbandEPG_StopSIEPGScan(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISIInbandEPG.VTable, self.vtable).StopSIEPGScan(@ptrCast(*const ISIInbandEPG, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISIInbandEPG_IsSIEPGScanRunning(self: *const T, bRunning: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISIInbandEPG.VTable, self.vtable).IsSIEPGScanRunning(@ptrCast(*const ISIInbandEPG, self), bRunning);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideDataEvent_Value = @import("../zig.zig").Guid.initString("efda0c80-f395-42c3-9b3c-56b37dec7bb7");
pub const IID_IGuideDataEvent = &IID_IGuideDataEvent_Value;
pub const IGuideDataEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GuideDataAcquired: fn(
            self: *const IGuideDataEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgramChanged: fn(
            self: *const IGuideDataEvent,
            varProgramDescriptionID: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ServiceChanged: fn(
            self: *const IGuideDataEvent,
            varServiceDescriptionID: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScheduleEntryChanged: fn(
            self: *const IGuideDataEvent,
            varScheduleEntryDescriptionID: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgramDeleted: fn(
            self: *const IGuideDataEvent,
            varProgramDescriptionID: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ServiceDeleted: fn(
            self: *const IGuideDataEvent,
            varServiceDescriptionID: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScheduleDeleted: fn(
            self: *const IGuideDataEvent,
            varScheduleEntryDescriptionID: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_GuideDataAcquired(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataEvent.VTable, self.vtable).GuideDataAcquired(@ptrCast(*const IGuideDataEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ProgramChanged(self: *const T, varProgramDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataEvent.VTable, self.vtable).ProgramChanged(@ptrCast(*const IGuideDataEvent, self), varProgramDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ServiceChanged(self: *const T, varServiceDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataEvent.VTable, self.vtable).ServiceChanged(@ptrCast(*const IGuideDataEvent, self), varServiceDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ScheduleEntryChanged(self: *const T, varScheduleEntryDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataEvent.VTable, self.vtable).ScheduleEntryChanged(@ptrCast(*const IGuideDataEvent, self), varScheduleEntryDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ProgramDeleted(self: *const T, varProgramDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataEvent.VTable, self.vtable).ProgramDeleted(@ptrCast(*const IGuideDataEvent, self), varProgramDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ServiceDeleted(self: *const T, varServiceDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataEvent.VTable, self.vtable).ServiceDeleted(@ptrCast(*const IGuideDataEvent, self), varServiceDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ScheduleDeleted(self: *const T, varScheduleEntryDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataEvent.VTable, self.vtable).ScheduleDeleted(@ptrCast(*const IGuideDataEvent, self), varScheduleEntryDescriptionID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideDataProperty_Value = @import("../zig.zig").Guid.initString("88ec5e58-bb73-41d6-99ce-66c524b8b591");
pub const IID_IGuideDataProperty = &IID_IGuideDataProperty_Value;
pub const IGuideDataProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IGuideDataProperty,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: fn(
            self: *const IGuideDataProperty,
            idLang: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IGuideDataProperty,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataProperty_get_Name(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataProperty.VTable, self.vtable).get_Name(@ptrCast(*const IGuideDataProperty, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataProperty_get_Language(self: *const T, idLang: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataProperty.VTable, self.vtable).get_Language(@ptrCast(*const IGuideDataProperty, self), idLang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataProperty_get_Value(self: *const T, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataProperty.VTable, self.vtable).get_Value(@ptrCast(*const IGuideDataProperty, self), pvar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumGuideDataProperties_Value = @import("../zig.zig").Guid.initString("ae44423b-4571-475c-ad2c-f40a771d80ef");
pub const IID_IEnumGuideDataProperties = &IID_IEnumGuideDataProperties_Value;
pub const IEnumGuideDataProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumGuideDataProperties,
            celt: u32,
            ppprop: ?*?*IGuideDataProperty,
            pcelt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumGuideDataProperties,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumGuideDataProperties,
            ppenum: ?*?*IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGuideDataProperties_Next(self: *const T, celt: u32, ppprop: ?*?*IGuideDataProperty, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGuideDataProperties.VTable, self.vtable).Next(@ptrCast(*const IEnumGuideDataProperties, self), celt, ppprop, pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGuideDataProperties_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGuideDataProperties.VTable, self.vtable).Skip(@ptrCast(*const IEnumGuideDataProperties, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGuideDataProperties_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGuideDataProperties.VTable, self.vtable).Reset(@ptrCast(*const IEnumGuideDataProperties, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGuideDataProperties_Clone(self: *const T, ppenum: ?*?*IEnumGuideDataProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGuideDataProperties.VTable, self.vtable).Clone(@ptrCast(*const IEnumGuideDataProperties, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTuneRequests_Value = @import("../zig.zig").Guid.initString("1993299c-ced6-4788-87a3-420067dce0c7");
pub const IID_IEnumTuneRequests = &IID_IEnumTuneRequests_Value;
pub const IEnumTuneRequests = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumTuneRequests,
            celt: u32,
            ppprop: ?*?*ITuneRequest,
            pcelt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTuneRequests,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTuneRequests,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumTuneRequests,
            ppenum: ?*?*IEnumTuneRequests,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuneRequests_Next(self: *const T, celt: u32, ppprop: ?*?*ITuneRequest, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTuneRequests.VTable, self.vtable).Next(@ptrCast(*const IEnumTuneRequests, self), celt, ppprop, pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuneRequests_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTuneRequests.VTable, self.vtable).Skip(@ptrCast(*const IEnumTuneRequests, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuneRequests_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTuneRequests.VTable, self.vtable).Reset(@ptrCast(*const IEnumTuneRequests, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuneRequests_Clone(self: *const T, ppenum: ?*?*IEnumTuneRequests) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTuneRequests.VTable, self.vtable).Clone(@ptrCast(*const IEnumTuneRequests, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideData_Value = @import("../zig.zig").Guid.initString("61571138-5b01-43cd-aeaf-60b784a0bf93");
pub const IID_IGuideData = &IID_IGuideData_Value;
pub const IGuideData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetServices: fn(
            self: *const IGuideData,
            ppEnumTuneRequests: ?*?*IEnumTuneRequests,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceProperties: fn(
            self: *const IGuideData,
            pTuneRequest: ?*ITuneRequest,
            ppEnumProperties: ?*?*IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideProgramIDs: fn(
            self: *const IGuideData,
            pEnumPrograms: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgramProperties: fn(
            self: *const IGuideData,
            varProgramDescriptionID: VARIANT,
            ppEnumProperties: ?*?*IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScheduleEntryIDs: fn(
            self: *const IGuideData,
            pEnumScheduleEntries: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScheduleEntryProperties: fn(
            self: *const IGuideData,
            varScheduleEntryDescriptionID: VARIANT,
            ppEnumProperties: ?*?*IEnumGuideDataProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetServices(self: *const T, ppEnumTuneRequests: ?*?*IEnumTuneRequests) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideData.VTable, self.vtable).GetServices(@ptrCast(*const IGuideData, self), ppEnumTuneRequests);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetServiceProperties(self: *const T, pTuneRequest: ?*ITuneRequest, ppEnumProperties: ?*?*IEnumGuideDataProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideData.VTable, self.vtable).GetServiceProperties(@ptrCast(*const IGuideData, self), pTuneRequest, ppEnumProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetGuideProgramIDs(self: *const T, pEnumPrograms: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideData.VTable, self.vtable).GetGuideProgramIDs(@ptrCast(*const IGuideData, self), pEnumPrograms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetProgramProperties(self: *const T, varProgramDescriptionID: VARIANT, ppEnumProperties: ?*?*IEnumGuideDataProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideData.VTable, self.vtable).GetProgramProperties(@ptrCast(*const IGuideData, self), varProgramDescriptionID, ppEnumProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetScheduleEntryIDs(self: *const T, pEnumScheduleEntries: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideData.VTable, self.vtable).GetScheduleEntryIDs(@ptrCast(*const IGuideData, self), pEnumScheduleEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetScheduleEntryProperties(self: *const T, varScheduleEntryDescriptionID: VARIANT, ppEnumProperties: ?*?*IEnumGuideDataProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideData.VTable, self.vtable).GetScheduleEntryProperties(@ptrCast(*const IGuideData, self), varScheduleEntryDescriptionID, ppEnumProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideDataLoader_Value = @import("../zig.zig").Guid.initString("4764ff7c-fa95-4525-af4d-d32236db9e38");
pub const IID_IGuideDataLoader = &IID_IGuideDataLoader_Value;
pub const IGuideDataLoader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IGuideDataLoader,
            pGuideStore: ?*IGuideData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Terminate: fn(
            self: *const IGuideDataLoader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataLoader_Init(self: *const T, pGuideStore: ?*IGuideData) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataLoader.VTable, self.vtable).Init(@ptrCast(*const IGuideDataLoader, self), pGuideStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataLoader_Terminate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGuideDataLoader.VTable, self.vtable).Terminate(@ptrCast(*const IGuideDataLoader, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const KSP_BDA_NODE_PIN = extern struct {
    Property: KSIDENTIFIER,
    ulNodeType: u32,
    ulInputPinId: u32,
    ulOutputPinId: u32,
};

pub const KSM_BDA_PIN = extern struct {
    Method: KSIDENTIFIER,
    Anonymous: extern union {
        PinId: u32,
        PinType: u32,
    },
    Reserved: u32,
};

pub const KSM_BDA_PIN_PAIR = extern struct {
    Method: KSIDENTIFIER,
    Anonymous1: extern union {
        InputPinId: u32,
        InputPinType: u32,
    },
    Anonymous2: extern union {
        OutputPinId: u32,
        OutputPinType: u32,
    },
};

pub const KSP_NODE_ESPID = extern struct {
    Property: KSP_NODE,
    EsPid: u32,
};

pub const KSM_BDA_DEBUG_LEVEL = extern struct {
    Method: KSIDENTIFIER,
    ucDebugLevel: u8,
    ulDebugStringSize: u32,
    argbDebugString: [1]u8,
};

pub const BDA_DEBUG_DATA = extern struct {
    lResult: i32,
    uuidDebugDataType: Guid,
    ulDataSize: u32,
    argbDebugData: [1]u8,
};

pub const BDA_EVENT_DATA = extern struct {
    lResult: i32,
    ulEventID: u32,
    uuidEventType: Guid,
    ulEventDataLength: u32,
    argbEventData: [1]u8,
};

pub const KSM_BDA_EVENT_COMPLETE = extern struct {
    Method: KSIDENTIFIER,
    ulEventID: u32,
    ulEventResult: u32,
};

pub const KSM_BDA_DRM_SETDRM = extern struct {
    NodeMethod: KSM_NODE,
    NewDRMuuid: Guid,
};

pub const KSM_BDA_BUFFER = extern struct {
    NodeMethod: KSM_NODE,
    ulBufferSize: u32,
    argbBuffer: [1]u8,
};

pub const KSM_BDA_WMDRM_LICENSE = extern struct {
    NodeMethod: KSM_NODE,
    uuidKeyID: Guid,
};

pub const KSM_BDA_WMDRM_RENEWLICENSE = extern struct {
    NodeMethod: KSM_NODE,
    ulXMRLicenseLength: u32,
    ulEntitlementTokenLength: u32,
    argbDataBuffer: [1]u8,
};

pub const KSM_BDA_WMDRMTUNER_PURCHASEENTITLEMENT = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulPurchaseTokenLength: u32,
    argbDataBuffer: [1]u8,
};

pub const KSM_BDA_WMDRMTUNER_SETPIDPROTECTION = extern struct {
    NodeMethod: KSM_NODE,
    ulPID: u32,
    uuidKeyID: Guid,
};

pub const KSM_BDA_WMDRMTUNER_GETPIDPROTECTION = extern struct {
    NodeMethod: KSM_NODE,
    ulPID: u32,
};

pub const KSM_BDA_WMDRMTUNER_SYNCVALUE = extern struct {
    NodeMethod: KSM_NODE,
    ulSyncValue: u32,
};

pub const KSM_BDA_TUNER_TUNEREQUEST = extern struct {
    Method: KSIDENTIFIER,
    ulTuneLength: u32,
    argbTuneData: [1]u8,
};

pub const KSM_BDA_GPNV_GETVALUE = extern struct {
    Method: KSIDENTIFIER,
    ulNameLength: u32,
    cLanguage: [12]CHAR,
    argbData: [1]u8,
};

pub const KSM_BDA_GPNV_SETVALUE = extern struct {
    Method: KSIDENTIFIER,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulNameLength: u32,
    ulValueLength: u32,
    argbName: [1]u8,
};

pub const KSM_BDA_GPNV_NAMEINDEX = extern struct {
    Method: KSIDENTIFIER,
    ulValueNameIndex: u32,
};

pub const KSM_BDA_SCAN_CAPABILTIES = extern struct {
    Method: KSIDENTIFIER,
    uuidBroadcastStandard: Guid,
};

pub const KSM_BDA_SCAN_FILTER = extern struct {
    Method: KSIDENTIFIER,
    ulScanModulationTypeSize: u32,
    AnalogVideoStandards: u64,
    argbScanModulationTypes: [1]u8,
};

pub const KSM_BDA_SCAN_START = extern struct {
    Method: KSIDENTIFIER,
    LowerFrequency: u32,
    HigherFrequency: u32,
};

pub const KSM_BDA_GDDS_TUNEXMLFROMIDX = extern struct {
    Method: KSIDENTIFIER,
    ulIdx: u64,
};

pub const KSM_BDA_GDDS_SERVICEFROMTUNEXML = extern struct {
    Method: KSIDENTIFIER,
    ulTuneXmlLength: u32,
    argbTuneXml: [1]u8,
};

pub const KSM_BDA_USERACTIVITY_USEREASON = extern struct {
    Method: KSIDENTIFIER,
    ulUseReason: u32,
};

pub const KSM_BDA_CAS_ENTITLEMENTTOKEN = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulRequestType: u32,
    ulEntitlementTokenLen: u32,
    argbEntitlementToken: [1]u8,
};

pub const KSM_BDA_CAS_CAPTURETOKEN = extern struct {
    NodeMethod: KSM_NODE,
    ulTokenLength: u32,
    argbToken: [1]u8,
};

pub const KSM_BDA_CAS_OPENBROADCASTMMI = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulEventId: u32,
};

pub const KSM_BDA_CAS_CLOSEMMIDIALOG = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulDialogNumber: u32,
    ulReason: u32,
};

pub const KSM_BDA_ISDBCAS_REQUEST = extern struct {
    NodeMethod: KSM_NODE,
    ulRequestID: u32,
    ulIsdbCommandSize: u32,
    argbIsdbCommandData: [1]u8,
};

pub const KSM_BDA_TS_SELECTOR_SETTSID = extern struct {
    NodeMethod: KSM_NODE,
    usTSID: u16,
};

pub const KS_DATARANGE_BDA_ANTENNA = extern struct {
    DataRange: KSDATAFORMAT,
};

pub const BDA_TRANSPORT_INFO = extern struct {
    ulcbPhyiscalPacket: u32,
    ulcbPhyiscalFrame: u32,
    ulcbPhyiscalFrameAlignment: u32,
    AvgTimePerFrame: i64,
};

pub const KS_DATARANGE_BDA_TRANSPORT = extern struct {
    DataRange: KSDATAFORMAT,
    BdaTransportInfo: BDA_TRANSPORT_INFO,
};

const CLSID_EVENTID_TuningChanging_Value = @import("../zig.zig").Guid.initString("83183c03-c09e-45c4-a719-807a94952bf9");
pub const CLSID_EVENTID_TuningChanging = &CLSID_EVENTID_TuningChanging_Value;

const CLSID_EVENTID_TuningChanged_Value = @import("../zig.zig").Guid.initString("9d7e6235-4b7d-425d-a6d1-d717c33b9c4c");
pub const CLSID_EVENTID_TuningChanged = &CLSID_EVENTID_TuningChanged_Value;

const CLSID_EVENTID_CandidatePostTuneData_Value = @import("../zig.zig").Guid.initString("9f02d3d0-9f06-4369-9f1e-3ad6ca19807e");
pub const CLSID_EVENTID_CandidatePostTuneData = &CLSID_EVENTID_CandidatePostTuneData_Value;

const CLSID_EVENTID_CADenialCountChanged_Value = @import("../zig.zig").Guid.initString("2a65c528-2249-4070-ac16-00390cdfb2dd");
pub const CLSID_EVENTID_CADenialCountChanged = &CLSID_EVENTID_CADenialCountChanged_Value;

const CLSID_EVENTID_SignalStatusChanged_Value = @import("../zig.zig").Guid.initString("6d9cfaf2-702d-4b01-8dff-6892ad20d191");
pub const CLSID_EVENTID_SignalStatusChanged = &CLSID_EVENTID_SignalStatusChanged_Value;

const CLSID_EVENTID_NewSignalAcquired_Value = @import("../zig.zig").Guid.initString("c87ec52d-cd18-404a-a076-c02a273d3de7");
pub const CLSID_EVENTID_NewSignalAcquired = &CLSID_EVENTID_NewSignalAcquired_Value;

const CLSID_EVENTID_EASMessageReceived_Value = @import("../zig.zig").Guid.initString("d10df9d5-c261-4b85-9e8a-517b3299cab2");
pub const CLSID_EVENTID_EASMessageReceived = &CLSID_EVENTID_EASMessageReceived_Value;

const CLSID_EVENTID_PSITable_Value = @import("../zig.zig").Guid.initString("1b9c3703-d447-4e16-97bb-01799fc031ed");
pub const CLSID_EVENTID_PSITable = &CLSID_EVENTID_PSITable_Value;

const CLSID_EVENTID_ServiceTerminated_Value = @import("../zig.zig").Guid.initString("0a1d591c-e0d2-4f8e-8960-2335bef45ccb");
pub const CLSID_EVENTID_ServiceTerminated = &CLSID_EVENTID_ServiceTerminated_Value;

const CLSID_EVENTID_CardStatusChanged_Value = @import("../zig.zig").Guid.initString("a265faea-f874-4b38-9ff7-c53d02969996");
pub const CLSID_EVENTID_CardStatusChanged = &CLSID_EVENTID_CardStatusChanged_Value;

const CLSID_EVENTID_DRMParingStatusChanged_Value = @import("../zig.zig").Guid.initString("000906f5-f0d1-41d6-a7df-4028697669f6");
pub const CLSID_EVENTID_DRMParingStatusChanged = &CLSID_EVENTID_DRMParingStatusChanged_Value;

const CLSID_EVENTID_DRMParingStepComplete_Value = @import("../zig.zig").Guid.initString("5b2ebf78-b752-4420-b41e-a472dc95828e");
pub const CLSID_EVENTID_DRMParingStepComplete = &CLSID_EVENTID_DRMParingStepComplete_Value;

const CLSID_EVENTID_MMIMessage_Value = @import("../zig.zig").Guid.initString("052c29af-09a4-4b93-890f-bd6a348968a4");
pub const CLSID_EVENTID_MMIMessage = &CLSID_EVENTID_MMIMessage_Value;

const CLSID_EVENTID_EntitlementChanged_Value = @import("../zig.zig").Guid.initString("9071ad5d-2359-4c95-8694-afa81d70bfd5");
pub const CLSID_EVENTID_EntitlementChanged = &CLSID_EVENTID_EntitlementChanged_Value;

const CLSID_EVENTID_STBChannelNumber_Value = @import("../zig.zig").Guid.initString("17c4d730-d0f0-413a-8c99-500469de35ad");
pub const CLSID_EVENTID_STBChannelNumber = &CLSID_EVENTID_STBChannelNumber_Value;

const CLSID_EVENTID_BDAEventingServicePendingEvent_Value = @import("../zig.zig").Guid.initString("5ca51711-5ddc-41a6-9430-e41b8b3bbc5b");
pub const CLSID_EVENTID_BDAEventingServicePendingEvent = &CLSID_EVENTID_BDAEventingServicePendingEvent_Value;

const CLSID_EVENTID_BDAConditionalAccessTAG_Value = @import("../zig.zig").Guid.initString("efc3a459-ae8b-4b4a-8fe9-79a0d097f3ea");
pub const CLSID_EVENTID_BDAConditionalAccessTAG = &CLSID_EVENTID_BDAConditionalAccessTAG_Value;

const CLSID_EVENTTYPE_CASDescrambleFailureEvent_Value = @import("../zig.zig").Guid.initString("b2127d42-7be5-4f4b-9130-6679899f4f4b");
pub const CLSID_EVENTTYPE_CASDescrambleFailureEvent = &CLSID_EVENTTYPE_CASDescrambleFailureEvent_Value;

const CLSID_EVENTID_CASFailureSpanningEvent_Value = @import("../zig.zig").Guid.initString("ead831ae-5529-4d1f-afce-0d8cd1257d30");
pub const CLSID_EVENTID_CASFailureSpanningEvent = &CLSID_EVENTID_CASFailureSpanningEvent_Value;

pub const ChannelChangeSpanningEvent_State = enum(i32) {
    Start = 0,
    End = 2,
};
pub const ChannelChangeSpanningEvent_Start = ChannelChangeSpanningEvent_State.Start;
pub const ChannelChangeSpanningEvent_End = ChannelChangeSpanningEvent_State.End;

const CLSID_EVENTID_ChannelChangeSpanningEvent_Value = @import("../zig.zig").Guid.initString("9067c5e5-4c5c-4205-86c8-7afe20fe1efa");
pub const CLSID_EVENTID_ChannelChangeSpanningEvent = &CLSID_EVENTID_ChannelChangeSpanningEvent_Value;

pub const ChannelChangeInfo = extern struct {
    state: ChannelChangeSpanningEvent_State,
    TimeStamp: u64,
};

const CLSID_EVENTID_ChannelTypeSpanningEvent_Value = @import("../zig.zig").Guid.initString("72ab1d51-87d2-489b-ba11-0e08dc210243");
pub const CLSID_EVENTID_ChannelTypeSpanningEvent = &CLSID_EVENTID_ChannelTypeSpanningEvent_Value;

pub const ChannelType = enum(i32) {
    None = 0,
    Other = 1,
    Video = 2,
    Audio = 4,
    Text = 8,
    Subtitles = 16,
    Captions = 32,
    Superimpose = 64,
    Data = 128,
};
pub const ChannelTypeNone = ChannelType.None;
pub const ChannelTypeOther = ChannelType.Other;
pub const ChannelTypeVideo = ChannelType.Video;
pub const ChannelTypeAudio = ChannelType.Audio;
pub const ChannelTypeText = ChannelType.Text;
pub const ChannelTypeSubtitles = ChannelType.Subtitles;
pub const ChannelTypeCaptions = ChannelType.Captions;
pub const ChannelTypeSuperimpose = ChannelType.Superimpose;
pub const ChannelTypeData = ChannelType.Data;

pub const ChannelTypeInfo = extern struct {
    channelType: ChannelType,
    timeStamp: u64,
};

pub const ChannelInfo = extern struct {
    lFrequency: i32,
    Anonymous: extern union {
        DVB: extern struct {
            lONID: i32,
            lTSID: i32,
            lSID: i32,
        },
        DC: extern struct {
            lProgNumber: i32,
        },
        ATSC: extern struct {
            lProgNumber: i32,
        },
    },
};

const CLSID_EVENTID_ChannelInfoSpanningEvent_Value = @import("../zig.zig").Guid.initString("41f36d80-4132-4cc2-b121-01a43219d81b");
pub const CLSID_EVENTID_ChannelInfoSpanningEvent = &CLSID_EVENTID_ChannelInfoSpanningEvent_Value;

const CLSID_EVENTID_RRTSpanningEvent_Value = @import("../zig.zig").Guid.initString("f6cfc8f4-da93-4f2f-bff8-ba1ee6fca3a2");
pub const CLSID_EVENTID_RRTSpanningEvent = &CLSID_EVENTID_RRTSpanningEvent_Value;

pub const SpanningEventDescriptor = extern struct {
    wDataLen: u16,
    wProgNumber: u16,
    wSID: u16,
    bDescriptor: [1]u8,
};

const CLSID_EVENTID_CSDescriptorSpanningEvent_Value = @import("../zig.zig").Guid.initString("efe779d9-97f0-4786-800d-95cf505ddc66");
pub const CLSID_EVENTID_CSDescriptorSpanningEvent = &CLSID_EVENTID_CSDescriptorSpanningEvent_Value;

const CLSID_EVENTID_CtxADescriptorSpanningEvent_Value = @import("../zig.zig").Guid.initString("3ab4a2e6-4247-4b34-896c-30afa5d21c24");
pub const CLSID_EVENTID_CtxADescriptorSpanningEvent = &CLSID_EVENTID_CtxADescriptorSpanningEvent_Value;

pub const DVBScramblingControlSpanningEvent = extern struct {
    ulPID: u32,
    fScrambled: BOOL,
};

const CLSID_EVENTID_DVBScramblingControlSpanningEvent_Value = @import("../zig.zig").Guid.initString("4bd4e1c4-90a1-4109-8236-27f00e7dcc5b");
pub const CLSID_EVENTID_DVBScramblingControlSpanningEvent = &CLSID_EVENTID_DVBScramblingControlSpanningEvent_Value;

pub const SignalAndServiceStatusSpanningEvent_State = enum(i32) {
    None = -1,
    Clear = 0,
    NoTVSignal = 1,
    ServiceOffAir = 2,
    WeakTVSignal = 3,
    NoSubscription = 4,
    AllAVScrambled = 5,
};
pub const SignalAndServiceStatusSpanningEvent_None = SignalAndServiceStatusSpanningEvent_State.None;
pub const SignalAndServiceStatusSpanningEvent_Clear = SignalAndServiceStatusSpanningEvent_State.Clear;
pub const SignalAndServiceStatusSpanningEvent_NoTVSignal = SignalAndServiceStatusSpanningEvent_State.NoTVSignal;
pub const SignalAndServiceStatusSpanningEvent_ServiceOffAir = SignalAndServiceStatusSpanningEvent_State.ServiceOffAir;
pub const SignalAndServiceStatusSpanningEvent_WeakTVSignal = SignalAndServiceStatusSpanningEvent_State.WeakTVSignal;
pub const SignalAndServiceStatusSpanningEvent_NoSubscription = SignalAndServiceStatusSpanningEvent_State.NoSubscription;
pub const SignalAndServiceStatusSpanningEvent_AllAVScrambled = SignalAndServiceStatusSpanningEvent_State.AllAVScrambled;

const CLSID_EVENTID_SignalAndServiceStatusSpanningEvent_Value = @import("../zig.zig").Guid.initString("8068c5cb-3c04-492b-b47d-0308820dce51");
pub const CLSID_EVENTID_SignalAndServiceStatusSpanningEvent = &CLSID_EVENTID_SignalAndServiceStatusSpanningEvent_Value;

pub const SpanningEventEmmMessage = extern struct {
    bCAbroadcasterGroupId: u8,
    bMessageControl: u8,
    wServiceId: u16,
    wTableIdExtension: u16,
    bDeletionStatus: u8,
    bDisplayingDuration1: u8,
    bDisplayingDuration2: u8,
    bDisplayingDuration3: u8,
    bDisplayingCycle: u8,
    bFormatVersion: u8,
    bDisplayPosition: u8,
    wMessageLength: u16,
    szMessageArea: [1]u16,
};

const CLSID_EVENTID_EmmMessageSpanningEvent_Value = @import("../zig.zig").Guid.initString("6bf00268-4f7e-4294-aa87-e9e953e43f14");
pub const CLSID_EVENTID_EmmMessageSpanningEvent = &CLSID_EVENTID_EmmMessageSpanningEvent_Value;

const CLSID_EVENTID_AudioTypeSpanningEvent_Value = @import("../zig.zig").Guid.initString("501cbfbe-b849-42ce-9be9-3db869fb82b3");
pub const CLSID_EVENTID_AudioTypeSpanningEvent = &CLSID_EVENTID_AudioTypeSpanningEvent_Value;

const CLSID_EVENTID_StreamTypeSpanningEvent_Value = @import("../zig.zig").Guid.initString("82af2ebc-30a6-4264-a80b-ad2e1372ac60");
pub const CLSID_EVENTID_StreamTypeSpanningEvent = &CLSID_EVENTID_StreamTypeSpanningEvent_Value;

const CLSID_EVENTID_ARIBcontentSpanningEvent_Value = @import("../zig.zig").Guid.initString("3a954083-93d0-463e-90b2-0742c496edf0");
pub const CLSID_EVENTID_ARIBcontentSpanningEvent = &CLSID_EVENTID_ARIBcontentSpanningEvent_Value;

const CLSID_EVENTID_LanguageSpanningEvent_Value = @import("../zig.zig").Guid.initString("e292666d-9c02-448d-aa8d-781a93fdc395");
pub const CLSID_EVENTID_LanguageSpanningEvent = &CLSID_EVENTID_LanguageSpanningEvent_Value;

pub const LanguageInfo = extern struct {
    LangID: u16,
    lISOLangCode: i32,
};

const CLSID_EVENTID_DualMonoSpanningEvent_Value = @import("../zig.zig").Guid.initString("a9a29b56-a84b-488c-89d5-0d4e7657c8ce");
pub const CLSID_EVENTID_DualMonoSpanningEvent = &CLSID_EVENTID_DualMonoSpanningEvent_Value;

pub const DualMonoInfo = extern struct {
    LangID1: u16,
    LangID2: u16,
    lISOLangCode1: i32,
    lISOLangCode2: i32,
};

const CLSID_EVENTID_PIDListSpanningEvent_Value = @import("../zig.zig").Guid.initString("47fc8f65-e2bb-4634-9cef-fdbfe6261d5c");
pub const CLSID_EVENTID_PIDListSpanningEvent = &CLSID_EVENTID_PIDListSpanningEvent_Value;

pub const PIDListSpanningEvent = extern struct {
    wPIDCount: u16,
    pulPIDs: [1]u32,
};

const CLSID_EVENTID_AudioDescriptorSpanningEvent_Value = @import("../zig.zig").Guid.initString("107bd41c-a6da-4691-8369-11b2cdaa288e");
pub const CLSID_EVENTID_AudioDescriptorSpanningEvent = &CLSID_EVENTID_AudioDescriptorSpanningEvent_Value;

const CLSID_EVENTID_SubtitleSpanningEvent_Value = @import("../zig.zig").Guid.initString("5dcec048-d0b9-4163-872c-4f32223be88a");
pub const CLSID_EVENTID_SubtitleSpanningEvent = &CLSID_EVENTID_SubtitleSpanningEvent_Value;

const CLSID_EVENTID_TeletextSpanningEvent_Value = @import("../zig.zig").Guid.initString("9599d950-5f33-4617-af7c-1e54b510daa3");
pub const CLSID_EVENTID_TeletextSpanningEvent = &CLSID_EVENTID_TeletextSpanningEvent_Value;

const CLSID_EVENTID_StreamIDSpanningEvent_Value = @import("../zig.zig").Guid.initString("caf1ab68-e153-4d41-a6b3-a7c998db75ee");
pub const CLSID_EVENTID_StreamIDSpanningEvent = &CLSID_EVENTID_StreamIDSpanningEvent_Value;

const CLSID_EVENTID_PBDAParentalControlEvent_Value = @import("../zig.zig").Guid.initString("f947aa85-fb52-48e8-b9c5-e1e1f411a51a");
pub const CLSID_EVENTID_PBDAParentalControlEvent = &CLSID_EVENTID_PBDAParentalControlEvent_Value;

pub const RATING_ATTRIBUTE = packed struct {
    rating_attribute_id: u32,
    rating_attribute_value: u32,
};

pub const RATING_SYSTEM = packed struct {
    rating_system_id: Guid,
    _bitfield: u8,
    country_code: [3]u8,
    rating_attribute_count: u32,
    lpratingattrib: ?*RATING_ATTRIBUTE,
};

pub const RATING_INFO = packed struct {
    rating_system_count: u32,
    lpratingsystem: ?*RATING_SYSTEM,
};

pub const PBDAParentalControl = packed struct {
    rating_system_count: u32,
    rating_systems: ?*RATING_SYSTEM,
};

const CLSID_EVENTID_TuneFailureEvent_Value = @import("../zig.zig").Guid.initString("d97287b2-2dfd-436a-9485-99d7d4ab5a69");
pub const CLSID_EVENTID_TuneFailureEvent = &CLSID_EVENTID_TuneFailureEvent_Value;

const CLSID_EVENTID_TuneFailureSpanningEvent_Value = @import("../zig.zig").Guid.initString("6f8aa455-5ee1-48ab-a27c-4c8d70b9aeba");
pub const CLSID_EVENTID_TuneFailureSpanningEvent = &CLSID_EVENTID_TuneFailureSpanningEvent_Value;

const CLSID_EVENTID_DvbParentalRatingDescriptor_Value = @import("../zig.zig").Guid.initString("2a67a58d-eca5-4eac-abcb-e734d3776d0a");
pub const CLSID_EVENTID_DvbParentalRatingDescriptor = &CLSID_EVENTID_DvbParentalRatingDescriptor_Value;

pub const DvbParentalRatingParam = extern struct {
    szCountryCode: [4]CHAR,
    bRating: u8,
};

pub const DvbParentalRatingDescriptor = extern struct {
    ulNumParams: u32,
    pParams: [1]DvbParentalRatingParam,
};

const CLSID_EVENTID_DFNWithNoActualAVData_Value = @import("../zig.zig").Guid.initString("f5689ffe-55f9-4bb3-96be-ae971c63bae0");
pub const CLSID_EVENTID_DFNWithNoActualAVData = &CLSID_EVENTID_DFNWithNoActualAVData_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA_Value = @import("../zig.zig").Guid.initString("71985f41-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA = &CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT_Value = @import("../zig.zig").Guid.initString("f4aeb342-0329-4fdd-a8fd-4aff4926c978");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT_Value;

const CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT_Value = @import("../zig.zig").Guid.initString("8deda6fd-ac5f-4334-8ecf-a4ba8fa7d0f0");
pub const CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT = &CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL_Value = @import("../zig.zig").Guid.initString("61be0b47-a5eb-499b-9a85-5b16c07f1258");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL = &CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL_Value;

const CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS_Value = @import("../zig.zig").Guid.initString("455f176c-4b06-47ce-9aef-8caef73df7b5");
pub const CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS = &CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI_Value = @import("../zig.zig").Guid.initString("b3c7397c-d303-414d-b33c-4ed2c9d29733");
pub const CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI = &CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI_Value = @import("../zig.zig").Guid.initString("e9dd31a3-221d-4adb-8532-9af309c1a408");
pub const CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI = &CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP_Value = @import("../zig.zig").Guid.initString("762e3f66-336f-48d1-bf83-2b00352c11f0");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP_Value = @import("../zig.zig").Guid.initString("951727db-d2ce-4528-96f6-3301fabb2de0");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI_Value = @import("../zig.zig").Guid.initString("4a2eeb99-6458-4538-b187-04017c41413f");
pub const CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI = &CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW_Value = @import("../zig.zig").Guid.initString("0d7aed42-cb9a-11db-9705-005056c00008");
pub const CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW = &CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW_Value;

const CLSID_PINNAME_BDA_TRANSPORT_Value = @import("../zig.zig").Guid.initString("78216a81-cfa8-493e-9711-36a61c08bd9d");
pub const CLSID_PINNAME_BDA_TRANSPORT = &CLSID_PINNAME_BDA_TRANSPORT_Value;

const CLSID_PINNAME_BDA_ANALOG_VIDEO_Value = @import("../zig.zig").Guid.initString("5c0c8281-5667-486c-8482-63e31f01a6e9");
pub const CLSID_PINNAME_BDA_ANALOG_VIDEO = &CLSID_PINNAME_BDA_ANALOG_VIDEO_Value;

const CLSID_PINNAME_BDA_ANALOG_AUDIO_Value = @import("../zig.zig").Guid.initString("d28a580a-9b1f-4b0c-9c33-9bf0a8ea636b");
pub const CLSID_PINNAME_BDA_ANALOG_AUDIO = &CLSID_PINNAME_BDA_ANALOG_AUDIO_Value;

const CLSID_PINNAME_BDA_FM_RADIO_Value = @import("../zig.zig").Guid.initString("d2855fed-b2d3-4eeb-9bd0-193436a2f890");
pub const CLSID_PINNAME_BDA_FM_RADIO = &CLSID_PINNAME_BDA_FM_RADIO_Value;

const CLSID_PINNAME_BDA_IF_PIN_Value = @import("../zig.zig").Guid.initString("1a9d4a42-f3cd-48a1-9aea-71de133cbe14");
pub const CLSID_PINNAME_BDA_IF_PIN = &CLSID_PINNAME_BDA_IF_PIN_Value;

const CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN_Value = @import("../zig.zig").Guid.initString("297bb104-e5c9-4ace-b123-95c3cbb24d4f");
pub const CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN = &CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN_Value;

const CLSID_KSPROPSETID_BdaEthernetFilter_Value = @import("../zig.zig").Guid.initString("71985f43-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaEthernetFilter = &CLSID_KSPROPSETID_BdaEthernetFilter_Value;

pub const KSPROPERTY_BDA_ETHERNET_FILTER = enum(i32) {
    LIST_SIZE = 0,
    LIST = 1,
    MODE = 2,
};
pub const KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE = KSPROPERTY_BDA_ETHERNET_FILTER.LIST_SIZE;
pub const KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST = KSPROPERTY_BDA_ETHERNET_FILTER.LIST;
pub const KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE = KSPROPERTY_BDA_ETHERNET_FILTER.MODE;

const CLSID_KSPROPSETID_BdaIPv4Filter_Value = @import("../zig.zig").Guid.initString("71985f44-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaIPv4Filter = &CLSID_KSPROPSETID_BdaIPv4Filter_Value;

pub const KSPROPERTY_BDA_IPv4_FILTER = enum(i32) {
    LIST_SIZE = 0,
    LIST = 1,
    MODE = 2,
};
pub const KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE = KSPROPERTY_BDA_IPv4_FILTER.LIST_SIZE;
pub const KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST = KSPROPERTY_BDA_IPv4_FILTER.LIST;
pub const KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE = KSPROPERTY_BDA_IPv4_FILTER.MODE;

const CLSID_KSPROPSETID_BdaIPv6Filter_Value = @import("../zig.zig").Guid.initString("e1785a74-2a23-4fb3-9245-a8f88017ef33");
pub const CLSID_KSPROPSETID_BdaIPv6Filter = &CLSID_KSPROPSETID_BdaIPv6Filter_Value;

pub const KSPROPERTY_BDA_IPv6_FILTER = enum(i32) {
    LIST_SIZE = 0,
    LIST = 1,
    MODE = 2,
};
pub const KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE = KSPROPERTY_BDA_IPv6_FILTER.LIST_SIZE;
pub const KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST = KSPROPERTY_BDA_IPv6_FILTER.LIST;
pub const KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE = KSPROPERTY_BDA_IPv6_FILTER.MODE;

const CLSID_KSPROPSETID_BdaSignalStats_Value = @import("../zig.zig").Guid.initString("1347d106-cf3a-428a-a5cb-ac0d9a2a4338");
pub const CLSID_KSPROPSETID_BdaSignalStats = &CLSID_KSPROPSETID_BdaSignalStats_Value;

pub const KSPROPERTY_BDA_SIGNAL_STATS = enum(i32) {
    IGNAL_STRENGTH = 0,
    IGNAL_QUALITY = 1,
    IGNAL_PRESENT = 2,
    IGNAL_LOCKED = 3,
    AMPLE_TIME = 4,
    IGNAL_LOCK_CAPS = 5,
    IGNAL_LOCK_TYPE = 6,
};
pub const KSPROPERTY_BDA_SIGNAL_STRENGTH = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_STRENGTH;
pub const KSPROPERTY_BDA_SIGNAL_QUALITY = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_QUALITY;
pub const KSPROPERTY_BDA_SIGNAL_PRESENT = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_PRESENT;
pub const KSPROPERTY_BDA_SIGNAL_LOCKED = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_LOCKED;
pub const KSPROPERTY_BDA_SAMPLE_TIME = KSPROPERTY_BDA_SIGNAL_STATS.AMPLE_TIME;
pub const KSPROPERTY_BDA_SIGNAL_LOCK_CAPS = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_LOCK_CAPS;
pub const KSPROPERTY_BDA_SIGNAL_LOCK_TYPE = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_LOCK_TYPE;

pub const BDA_LockType = enum(i32) {
    None = 0,
    PLL = 1,
    DecoderDemod = 2,
    Complete = 128,
};
pub const Bda_LockType_None = BDA_LockType.None;
pub const Bda_LockType_PLL = BDA_LockType.PLL;
pub const Bda_LockType_DecoderDemod = BDA_LockType.DecoderDemod;
pub const Bda_LockType_Complete = BDA_LockType.Complete;

const CLSID_KSMETHODSETID_BdaChangeSync_Value = @import("../zig.zig").Guid.initString("fd0a5af3-b41d-11d2-9c95-00c04f7971e0");
pub const CLSID_KSMETHODSETID_BdaChangeSync = &CLSID_KSMETHODSETID_BdaChangeSync_Value;

pub const KSMETHOD_BDA_CHANGE_SYNC = enum(i32) {
    START_CHANGES = 0,
    CHECK_CHANGES = 1,
    COMMIT_CHANGES = 2,
    GET_CHANGE_STATE = 3,
};
pub const KSMETHOD_BDA_START_CHANGES = KSMETHOD_BDA_CHANGE_SYNC.START_CHANGES;
pub const KSMETHOD_BDA_CHECK_CHANGES = KSMETHOD_BDA_CHANGE_SYNC.CHECK_CHANGES;
pub const KSMETHOD_BDA_COMMIT_CHANGES = KSMETHOD_BDA_CHANGE_SYNC.COMMIT_CHANGES;
pub const KSMETHOD_BDA_GET_CHANGE_STATE = KSMETHOD_BDA_CHANGE_SYNC.GET_CHANGE_STATE;

const CLSID_KSMETHODSETID_BdaDeviceConfiguration_Value = @import("../zig.zig").Guid.initString("71985f45-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSMETHODSETID_BdaDeviceConfiguration = &CLSID_KSMETHODSETID_BdaDeviceConfiguration_Value;

pub const KSMETHOD_BDA_DEVICE_CONFIGURATION = enum(i32) {
    CREATE_PIN_FACTORY = 0,
    DELETE_PIN_FACTORY = 1,
    CREATE_TOPOLOGY = 2,
};
pub const KSMETHOD_BDA_CREATE_PIN_FACTORY = KSMETHOD_BDA_DEVICE_CONFIGURATION.CREATE_PIN_FACTORY;
pub const KSMETHOD_BDA_DELETE_PIN_FACTORY = KSMETHOD_BDA_DEVICE_CONFIGURATION.DELETE_PIN_FACTORY;
pub const KSMETHOD_BDA_CREATE_TOPOLOGY = KSMETHOD_BDA_DEVICE_CONFIGURATION.CREATE_TOPOLOGY;

const CLSID_KSPROPSETID_BdaTopology_Value = @import("../zig.zig").Guid.initString("a14ee835-0a23-11d3-9cc7-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaTopology = &CLSID_KSPROPSETID_BdaTopology_Value;

pub const KSPROPERTY_BDA_TOPOLOGY = enum(i32) {
    NODE_TYPES = 0,
    PIN_TYPES = 1,
    TEMPLATE_CONNECTIONS = 2,
    NODE_METHODS = 3,
    NODE_PROPERTIES = 4,
    NODE_EVENTS = 5,
    CONTROLLING_PIN_ID = 6,
    NODE_DESCRIPTORS = 7,
};
pub const KSPROPERTY_BDA_NODE_TYPES = KSPROPERTY_BDA_TOPOLOGY.NODE_TYPES;
pub const KSPROPERTY_BDA_PIN_TYPES = KSPROPERTY_BDA_TOPOLOGY.PIN_TYPES;
pub const KSPROPERTY_BDA_TEMPLATE_CONNECTIONS = KSPROPERTY_BDA_TOPOLOGY.TEMPLATE_CONNECTIONS;
pub const KSPROPERTY_BDA_NODE_METHODS = KSPROPERTY_BDA_TOPOLOGY.NODE_METHODS;
pub const KSPROPERTY_BDA_NODE_PROPERTIES = KSPROPERTY_BDA_TOPOLOGY.NODE_PROPERTIES;
pub const KSPROPERTY_BDA_NODE_EVENTS = KSPROPERTY_BDA_TOPOLOGY.NODE_EVENTS;
pub const KSPROPERTY_BDA_CONTROLLING_PIN_ID = KSPROPERTY_BDA_TOPOLOGY.CONTROLLING_PIN_ID;
pub const KSPROPERTY_BDA_NODE_DESCRIPTORS = KSPROPERTY_BDA_TOPOLOGY.NODE_DESCRIPTORS;

const CLSID_KSPROPSETID_BdaPinControl_Value = @import("../zig.zig").Guid.initString("0ded49d5-a8b7-4d5d-97a1-12b0c195874d");
pub const CLSID_KSPROPSETID_BdaPinControl = &CLSID_KSPROPSETID_BdaPinControl_Value;

pub const KSPROPERTY_BDA_PIN_CONTROL = enum(i32) {
    ID = 0,
    TYPE = 1,
};
pub const KSPROPERTY_BDA_PIN_ID = KSPROPERTY_BDA_PIN_CONTROL.ID;
pub const KSPROPERTY_BDA_PIN_TYPE = KSPROPERTY_BDA_PIN_CONTROL.TYPE;

const CLSID_KSEVENTSETID_BdaPinEvent_Value = @import("../zig.zig").Guid.initString("104781cd-50bd-40d5-95fb-087e0e86a591");
pub const CLSID_KSEVENTSETID_BdaPinEvent = &CLSID_KSEVENTSETID_BdaPinEvent_Value;

pub const KSPROPERTY_BDA_PIN_EVENT = enum(i32) {
    CONNECTED = 0,
    DISCONNECTED = 1,
};
pub const KSEVENT_BDA_PIN_CONNECTED = KSPROPERTY_BDA_PIN_EVENT.CONNECTED;
pub const KSEVENT_BDA_PIN_DISCONNECTED = KSPROPERTY_BDA_PIN_EVENT.DISCONNECTED;

const CLSID_KSPROPSETID_BdaVoidTransform_Value = @import("../zig.zig").Guid.initString("71985f46-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaVoidTransform = &CLSID_KSPROPSETID_BdaVoidTransform_Value;

pub const KSPROPERTY_BDA_VOID_TRANSFORM = enum(i32) {
    ART = 0,
    OP = 1,
};
pub const KSPROPERTY_BDA_VOID_TRANSFORM_START = KSPROPERTY_BDA_VOID_TRANSFORM.ART;
pub const KSPROPERTY_BDA_VOID_TRANSFORM_STOP = KSPROPERTY_BDA_VOID_TRANSFORM.OP;

const CLSID_KSPROPSETID_BdaNullTransform_Value = @import("../zig.zig").Guid.initString("ddf15b0d-bd25-11d2-9ca0-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaNullTransform = &CLSID_KSPROPSETID_BdaNullTransform_Value;

pub const KSPROPERTY_BDA_NULL_TRANSFORM = enum(i32) {
    ART = 0,
    OP = 1,
};
pub const KSPROPERTY_BDA_NULL_TRANSFORM_START = KSPROPERTY_BDA_NULL_TRANSFORM.ART;
pub const KSPROPERTY_BDA_NULL_TRANSFORM_STOP = KSPROPERTY_BDA_NULL_TRANSFORM.OP;

const CLSID_KSPROPSETID_BdaFrequencyFilter_Value = @import("../zig.zig").Guid.initString("71985f47-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaFrequencyFilter = &CLSID_KSPROPSETID_BdaFrequencyFilter_Value;

pub const KSPROPERTY_BDA_FREQUENCY_FILTER = enum(i32) {
    FREQUENCY = 0,
    POLARITY = 1,
    RANGE = 2,
    TRANSPONDER = 3,
    BANDWIDTH = 4,
    FREQUENCY_MULTIPLIER = 5,
    CAPS = 6,
    SCAN_STATUS = 7,
    STANDARD = 8,
    STANDARD_MODE = 9,
};
pub const KSPROPERTY_BDA_RF_TUNER_FREQUENCY = KSPROPERTY_BDA_FREQUENCY_FILTER.FREQUENCY;
pub const KSPROPERTY_BDA_RF_TUNER_POLARITY = KSPROPERTY_BDA_FREQUENCY_FILTER.POLARITY;
pub const KSPROPERTY_BDA_RF_TUNER_RANGE = KSPROPERTY_BDA_FREQUENCY_FILTER.RANGE;
pub const KSPROPERTY_BDA_RF_TUNER_TRANSPONDER = KSPROPERTY_BDA_FREQUENCY_FILTER.TRANSPONDER;
pub const KSPROPERTY_BDA_RF_TUNER_BANDWIDTH = KSPROPERTY_BDA_FREQUENCY_FILTER.BANDWIDTH;
pub const KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER = KSPROPERTY_BDA_FREQUENCY_FILTER.FREQUENCY_MULTIPLIER;
pub const KSPROPERTY_BDA_RF_TUNER_CAPS = KSPROPERTY_BDA_FREQUENCY_FILTER.CAPS;
pub const KSPROPERTY_BDA_RF_TUNER_SCAN_STATUS = KSPROPERTY_BDA_FREQUENCY_FILTER.SCAN_STATUS;
pub const KSPROPERTY_BDA_RF_TUNER_STANDARD = KSPROPERTY_BDA_FREQUENCY_FILTER.STANDARD;
pub const KSPROPERTY_BDA_RF_TUNER_STANDARD_MODE = KSPROPERTY_BDA_FREQUENCY_FILTER.STANDARD_MODE;

pub const BDA_SignalType = enum(i32) {
    Unknown = 0,
    Analog = 1,
    Digital = 2,
};
pub const Bda_SignalType_Unknown = BDA_SignalType.Unknown;
pub const Bda_SignalType_Analog = BDA_SignalType.Analog;
pub const Bda_SignalType_Digital = BDA_SignalType.Digital;

pub const BDA_DigitalSignalStandard = enum(i32) {
    None = 0,
    DVB_T = 1,
    DVB_S = 2,
    DVB_C = 4,
    ATSC = 8,
    ISDB_T = 16,
    ISDB_S = 32,
    ISDB_C = 64,
};
pub const Bda_DigitalStandard_None = BDA_DigitalSignalStandard.None;
pub const Bda_DigitalStandard_DVB_T = BDA_DigitalSignalStandard.DVB_T;
pub const Bda_DigitalStandard_DVB_S = BDA_DigitalSignalStandard.DVB_S;
pub const Bda_DigitalStandard_DVB_C = BDA_DigitalSignalStandard.DVB_C;
pub const Bda_DigitalStandard_ATSC = BDA_DigitalSignalStandard.ATSC;
pub const Bda_DigitalStandard_ISDB_T = BDA_DigitalSignalStandard.ISDB_T;
pub const Bda_DigitalStandard_ISDB_S = BDA_DigitalSignalStandard.ISDB_S;
pub const Bda_DigitalStandard_ISDB_C = BDA_DigitalSignalStandard.ISDB_C;

pub const KSPROPERTY_BDA_RF_TUNER_CAPS_S = extern struct {
    Property: KSP_NODE,
    Mode: u32,
    AnalogStandardsSupported: u32,
    DigitalStandardsSupported: u32,
    MinFrequency: u32,
    MaxFrequency: u32,
    SettlingTime: u32,
    AnalogSensingRange: u32,
    DigitalSensingRange: u32,
    MilliSecondsPerMHz: u32,
};

pub const KSPROPERTY_BDA_RF_TUNER_SCAN_STATUS_S = extern struct {
    Property: KSP_NODE,
    CurrentFrequency: u32,
    FrequencyRangeMin: u32,
    FrequencyRangeMax: u32,
    MilliSecondsLeft: u32,
};

pub const KSPROPERTY_BDA_RF_TUNER_STANDARD_S = extern struct {
    Property: KSP_NODE,
    SignalType: BDA_SignalType,
    SignalStandard: u32,
};

pub const KSPROPERTY_BDA_RF_TUNER_STANDARD_MODE_S = extern struct {
    Property: KSP_NODE,
    AutoDetect: BOOL,
};

const CLSID_KSEVENTSETID_BdaTunerEvent_Value = @import("../zig.zig").Guid.initString("aab59e17-01c9-4ebf-93f2-fc3b79b46f91");
pub const CLSID_KSEVENTSETID_BdaTunerEvent = &CLSID_KSEVENTSETID_BdaTunerEvent_Value;

pub const KSEVENT_BDA_TUNER = enum(i32) {
    N = 0,
};
pub const KSEVENT_BDA_TUNER_SCAN = KSEVENT_BDA_TUNER.N;

pub const KSEVENTDATA_BDA_RF_TUNER_SCAN_S = extern struct {
    EventData: KSEVENTDATA,
    StartFrequency: u32,
    EndFrequency: u32,
    LockRequested: BDA_LockType,
};

const CLSID_KSPROPSETID_BdaLNBInfo_Value = @import("../zig.zig").Guid.initString("992cf102-49f9-4719-a664-c4f23e2408f4");
pub const CLSID_KSPROPSETID_BdaLNBInfo = &CLSID_KSPROPSETID_BdaLNBInfo_Value;

pub const KSPROPERTY_BDA_LNB_INFO = enum(i32) {
    LOF_LOW_BAND = 0,
    LOF_HIGH_BAND = 1,
    SWITCH_FREQUENCY = 2,
};
pub const KSPROPERTY_BDA_LNB_LOF_LOW_BAND = KSPROPERTY_BDA_LNB_INFO.LOF_LOW_BAND;
pub const KSPROPERTY_BDA_LNB_LOF_HIGH_BAND = KSPROPERTY_BDA_LNB_INFO.LOF_HIGH_BAND;
pub const KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY = KSPROPERTY_BDA_LNB_INFO.SWITCH_FREQUENCY;

const CLSID_KSPROPSETID_BdaDiseqCommand_Value = @import("../zig.zig").Guid.initString("f84e2ab0-3c6b-45e3-a0fc-8669d4b81f11");
pub const CLSID_KSPROPSETID_BdaDiseqCommand = &CLSID_KSPROPSETID_BdaDiseqCommand_Value;

pub const KSPROPERTY_BDA_DISEQC_COMMAND = enum(i32) {
    ENABLE = 0,
    LNB_SOURCE = 1,
    USETONEBURST = 2,
    REPEATS = 3,
    SEND = 4,
    RESPONSE = 5,
};
pub const KSPROPERTY_BDA_DISEQC_ENABLE = KSPROPERTY_BDA_DISEQC_COMMAND.ENABLE;
pub const KSPROPERTY_BDA_DISEQC_LNB_SOURCE = KSPROPERTY_BDA_DISEQC_COMMAND.LNB_SOURCE;
pub const KSPROPERTY_BDA_DISEQC_USETONEBURST = KSPROPERTY_BDA_DISEQC_COMMAND.USETONEBURST;
pub const KSPROPERTY_BDA_DISEQC_REPEATS = KSPROPERTY_BDA_DISEQC_COMMAND.REPEATS;
pub const KSPROPERTY_BDA_DISEQC_SEND = KSPROPERTY_BDA_DISEQC_COMMAND.SEND;
pub const KSPROPERTY_BDA_DISEQC_RESPONSE = KSPROPERTY_BDA_DISEQC_COMMAND.RESPONSE;

const CLSID_KSEVENTSETID_BdaDiseqCEvent_Value = @import("../zig.zig").Guid.initString("8b19bbf0-4184-43ac-ad3c-0c889be4c212");
pub const CLSID_KSEVENTSETID_BdaDiseqCEvent = &CLSID_KSEVENTSETID_BdaDiseqCEvent_Value;

pub const KSPROPERTY_BDA_DISEQC_EVENT = enum(i32) {
    D = 0,
};
pub const KSEVENT_BDA_DISEQC_DATA_RECEIVED = KSPROPERTY_BDA_DISEQC_EVENT.D;

const CLSID_KSPROPSETID_BdaDigitalDemodulator_Value = @import("../zig.zig").Guid.initString("ef30f379-985b-4d10-b640-a79d5e04e1e0");
pub const CLSID_KSPROPSETID_BdaDigitalDemodulator = &CLSID_KSPROPSETID_BdaDigitalDemodulator_Value;

pub const KSPROPERTY_BDA_DIGITAL_DEMODULATOR = enum(i32) {
    MODULATION_TYPE = 0,
    INNER_FEC_TYPE = 1,
    INNER_FEC_RATE = 2,
    OUTER_FEC_TYPE = 3,
    OUTER_FEC_RATE = 4,
    SYMBOL_RATE = 5,
    SPECTRAL_INVERSION = 6,
    GUARD_INTERVAL = 7,
    TRANSMISSION_MODE = 8,
    ROLL_OFF = 9,
    PILOT = 10,
    SIGNALTIMEOUTS = 11,
    PLP_NUMBER = 12,
};
pub const KSPROPERTY_BDA_MODULATION_TYPE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.MODULATION_TYPE;
pub const KSPROPERTY_BDA_INNER_FEC_TYPE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.INNER_FEC_TYPE;
pub const KSPROPERTY_BDA_INNER_FEC_RATE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.INNER_FEC_RATE;
pub const KSPROPERTY_BDA_OUTER_FEC_TYPE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.OUTER_FEC_TYPE;
pub const KSPROPERTY_BDA_OUTER_FEC_RATE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.OUTER_FEC_RATE;
pub const KSPROPERTY_BDA_SYMBOL_RATE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.SYMBOL_RATE;
pub const KSPROPERTY_BDA_SPECTRAL_INVERSION = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.SPECTRAL_INVERSION;
pub const KSPROPERTY_BDA_GUARD_INTERVAL = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.GUARD_INTERVAL;
pub const KSPROPERTY_BDA_TRANSMISSION_MODE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.TRANSMISSION_MODE;
pub const KSPROPERTY_BDA_ROLL_OFF = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.ROLL_OFF;
pub const KSPROPERTY_BDA_PILOT = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.PILOT;
pub const KSPROPERTY_BDA_SIGNALTIMEOUTS = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.SIGNALTIMEOUTS;
pub const KSPROPERTY_BDA_PLP_NUMBER = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.PLP_NUMBER;

const CLSID_KSPROPSETID_BdaAutodemodulate_Value = @import("../zig.zig").Guid.initString("ddf15b12-bd25-11d2-9ca0-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaAutodemodulate = &CLSID_KSPROPSETID_BdaAutodemodulate_Value;

pub const KSPROPERTY_BDA_AUTODEMODULATE = enum(i32) {
    ART = 0,
    OP = 1,
};
pub const KSPROPERTY_BDA_AUTODEMODULATE_START = KSPROPERTY_BDA_AUTODEMODULATE.ART;
pub const KSPROPERTY_BDA_AUTODEMODULATE_STOP = KSPROPERTY_BDA_AUTODEMODULATE.OP;

const CLSID_KSPROPSETID_BdaTableSection_Value = @import("../zig.zig").Guid.initString("516b99c5-971c-4aaf-b3f3-d9fda8a15e16");
pub const CLSID_KSPROPSETID_BdaTableSection = &CLSID_KSPROPSETID_BdaTableSection_Value;

pub const KSPROPERTY_IDS_BDA_TABLE = enum(i32) {
    N = 0,
};
pub const KSPROPERTY_BDA_TABLE_SECTION = KSPROPERTY_IDS_BDA_TABLE.N;

const CLSID_KSPROPSETID_BdaPIDFilter_Value = @import("../zig.zig").Guid.initString("d0a67d65-08df-4fec-8533-e5b550410b85");
pub const CLSID_KSPROPSETID_BdaPIDFilter = &CLSID_KSPROPSETID_BdaPIDFilter_Value;

pub const KSPROPERTY_BDA_PIDFILTER = enum(i32) {
    MAP_PIDS = 0,
    UNMAP_PIDS = 1,
    LIST_PIDS = 2,
};
pub const KSPROPERTY_BDA_PIDFILTER_MAP_PIDS = KSPROPERTY_BDA_PIDFILTER.MAP_PIDS;
pub const KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS = KSPROPERTY_BDA_PIDFILTER.UNMAP_PIDS;
pub const KSPROPERTY_BDA_PIDFILTER_LIST_PIDS = KSPROPERTY_BDA_PIDFILTER.LIST_PIDS;

const CLSID_KSPROPSETID_BdaCA_Value = @import("../zig.zig").Guid.initString("b0693766-5278-4ec6-b9e1-3ce40560ef5a");
pub const CLSID_KSPROPSETID_BdaCA = &CLSID_KSPROPSETID_BdaCA_Value;

pub const KSPROPERTY_BDA_CA = enum(i32) {
    ECM_MAP_STATUS = 0,
    CA_MODULE_STATUS = 1,
    CA_SMART_CARD_STATUS = 2,
    CA_MODULE_UI = 3,
    CA_SET_PROGRAM_PIDS = 4,
    CA_REMOVE_PROGRAM = 5,
};
pub const KSPROPERTY_BDA_ECM_MAP_STATUS = KSPROPERTY_BDA_CA.ECM_MAP_STATUS;
pub const KSPROPERTY_BDA_CA_MODULE_STATUS = KSPROPERTY_BDA_CA.CA_MODULE_STATUS;
pub const KSPROPERTY_BDA_CA_SMART_CARD_STATUS = KSPROPERTY_BDA_CA.CA_SMART_CARD_STATUS;
pub const KSPROPERTY_BDA_CA_MODULE_UI = KSPROPERTY_BDA_CA.CA_MODULE_UI;
pub const KSPROPERTY_BDA_CA_SET_PROGRAM_PIDS = KSPROPERTY_BDA_CA.CA_SET_PROGRAM_PIDS;
pub const KSPROPERTY_BDA_CA_REMOVE_PROGRAM = KSPROPERTY_BDA_CA.CA_REMOVE_PROGRAM;

const CLSID_KSEVENTSETID_BdaCAEvent_Value = @import("../zig.zig").Guid.initString("488c4ccc-b768-4129-8eb1-b00a071f9068");
pub const CLSID_KSEVENTSETID_BdaCAEvent = &CLSID_KSEVENTSETID_BdaCAEvent_Value;

pub const KSPROPERTY_BDA_CA_EVENT = enum(i32) {
    PROGRAM_FLOW_STATUS_CHANGED = 0,
    CA_MODULE_STATUS_CHANGED = 1,
    CA_SMART_CARD_STATUS_CHANGED = 2,
    CA_MODULE_UI_REQUESTED = 3,
};
pub const KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED = KSPROPERTY_BDA_CA_EVENT.PROGRAM_FLOW_STATUS_CHANGED;
pub const KSEVENT_BDA_CA_MODULE_STATUS_CHANGED = KSPROPERTY_BDA_CA_EVENT.CA_MODULE_STATUS_CHANGED;
pub const KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED = KSPROPERTY_BDA_CA_EVENT.CA_SMART_CARD_STATUS_CHANGED;
pub const KSEVENT_BDA_CA_MODULE_UI_REQUESTED = KSPROPERTY_BDA_CA_EVENT.CA_MODULE_UI_REQUESTED;

const CLSID_KSMETHODSETID_BdaDrmService_Value = @import("../zig.zig").Guid.initString("bff6b5bb-b0ae-484c-9dca-73528fb0b46e");
pub const CLSID_KSMETHODSETID_BdaDrmService = &CLSID_KSMETHODSETID_BdaDrmService_Value;

pub const KSMETHOD_BDA_DRM = enum(i32) {
    CURRENT = 0,
    DRMSTATUS = 1,
};
pub const KSMETHOD_BDA_DRM_CURRENT = KSMETHOD_BDA_DRM.CURRENT;
pub const KSMETHOD_BDA_DRM_DRMSTATUS = KSMETHOD_BDA_DRM.DRMSTATUS;

const CLSID_KSMETHODSETID_BdaWmdrmSession_Value = @import("../zig.zig").Guid.initString("4be6fa3d-07cd-4139-8b80-8c18ba3aec88");
pub const CLSID_KSMETHODSETID_BdaWmdrmSession = &CLSID_KSMETHODSETID_BdaWmdrmSession_Value;

pub const KSMETHOD_BDA_WMDRM = enum(i32) {
    STATUS = 0,
    REVINFO = 1,
    CRL = 2,
    MESSAGE = 3,
    REISSUELICENSE = 4,
    RENEWLICENSE = 5,
    LICENSE = 6,
    KEYINFO = 7,
};
pub const KSMETHOD_BDA_WMDRM_STATUS = KSMETHOD_BDA_WMDRM.STATUS;
pub const KSMETHOD_BDA_WMDRM_REVINFO = KSMETHOD_BDA_WMDRM.REVINFO;
pub const KSMETHOD_BDA_WMDRM_CRL = KSMETHOD_BDA_WMDRM.CRL;
pub const KSMETHOD_BDA_WMDRM_MESSAGE = KSMETHOD_BDA_WMDRM.MESSAGE;
pub const KSMETHOD_BDA_WMDRM_REISSUELICENSE = KSMETHOD_BDA_WMDRM.REISSUELICENSE;
pub const KSMETHOD_BDA_WMDRM_RENEWLICENSE = KSMETHOD_BDA_WMDRM.RENEWLICENSE;
pub const KSMETHOD_BDA_WMDRM_LICENSE = KSMETHOD_BDA_WMDRM.LICENSE;
pub const KSMETHOD_BDA_WMDRM_KEYINFO = KSMETHOD_BDA_WMDRM.KEYINFO;

const CLSID_KSMETHODSETID_BdaWmdrmTuner_Value = @import("../zig.zig").Guid.initString("86d979cf-a8a7-4f94-b5fb-14c0aca68fe6");
pub const CLSID_KSMETHODSETID_BdaWmdrmTuner = &CLSID_KSMETHODSETID_BdaWmdrmTuner_Value;

pub const KSMETHOD_BDA_WMDRM_TUNER = enum(i32) {
    CANCELCAPTURETOKEN = 0,
    SETPIDPROTECTION = 1,
    GETPIDPROTECTION = 2,
    SETSYNCVALUE = 3,
    STARTCODEPROFILE = 4,
    PURCHASE_ENTITLEMENT = 5,
};
pub const KSMETHOD_BDA_WMDRMTUNER_CANCELCAPTURETOKEN = KSMETHOD_BDA_WMDRM_TUNER.CANCELCAPTURETOKEN;
pub const KSMETHOD_BDA_WMDRMTUNER_SETPIDPROTECTION = KSMETHOD_BDA_WMDRM_TUNER.SETPIDPROTECTION;
pub const KSMETHOD_BDA_WMDRMTUNER_GETPIDPROTECTION = KSMETHOD_BDA_WMDRM_TUNER.GETPIDPROTECTION;
pub const KSMETHOD_BDA_WMDRMTUNER_SETSYNCVALUE = KSMETHOD_BDA_WMDRM_TUNER.SETSYNCVALUE;
pub const KSMETHOD_BDA_WMDRMTUNER_STARTCODEPROFILE = KSMETHOD_BDA_WMDRM_TUNER.STARTCODEPROFILE;
pub const KSMETHOD_BDA_WMDRMTUNER_PURCHASE_ENTITLEMENT = KSMETHOD_BDA_WMDRM_TUNER.PURCHASE_ENTITLEMENT;

const CLSID_KSMETHODSETID_BdaEventing_Value = @import("../zig.zig").Guid.initString("f99492da-6193-4eb0-8690-6686cbff713e");
pub const CLSID_KSMETHODSETID_BdaEventing = &CLSID_KSMETHODSETID_BdaEventing_Value;

pub const KSMETHOD_BDA_EVENTING_SERVICE = enum(i32) {
    DATA = 0,
    COMPLETE = 1,
};
pub const KSMETHOD_BDA_EVENT_DATA = KSMETHOD_BDA_EVENTING_SERVICE.DATA;
pub const KSMETHOD_BDA_EVENT_COMPLETE = KSMETHOD_BDA_EVENTING_SERVICE.COMPLETE;

const CLSID_KSEVENTSETID_BdaEvent_Value = @import("../zig.zig").Guid.initString("ae7e55b2-96d7-4e29-908f-62f95b2a1679");
pub const CLSID_KSEVENTSETID_BdaEvent = &CLSID_KSEVENTSETID_BdaEvent_Value;

pub const KSEVENT_BDA_EVENT_TYPE = enum(i32) {
    T = 0,
};
pub const KSEVENT_BDA_EVENT_PENDINGEVENT = KSEVENT_BDA_EVENT_TYPE.T;

const CLSID_KSMETHODSETID_BdaDebug_Value = @import("../zig.zig").Guid.initString("0d4a90ec-c69d-4ee2-8c5a-fb1f63a50da1");
pub const CLSID_KSMETHODSETID_BdaDebug = &CLSID_KSMETHODSETID_BdaDebug_Value;

pub const KSMETHOD_BDA_DEBUG_SERVICE = enum(i32) {
    LEVEL = 0,
    DATA = 1,
};
pub const KSMETHOD_BDA_DEBUG_LEVEL = KSMETHOD_BDA_DEBUG_SERVICE.LEVEL;
pub const KSMETHOD_BDA_DEBUG_DATA = KSMETHOD_BDA_DEBUG_SERVICE.DATA;

const CLSID_KSMETHODSETID_BdaTuner_Value = @import("../zig.zig").Guid.initString("b774102f-ac07-478a-8228-2742d961fa7e");
pub const CLSID_KSMETHODSETID_BdaTuner = &CLSID_KSMETHODSETID_BdaTuner_Value;

pub const KSMETHOD_BDA_TUNER_SERVICE = enum(i32) {
    SETTUNER = 0,
    GETTUNERSTATE = 1,
    SIGNALNOISERATIO = 2,
};
pub const KSMETHOD_BDA_TUNER_SETTUNER = KSMETHOD_BDA_TUNER_SERVICE.SETTUNER;
pub const KSMETHOD_BDA_TUNER_GETTUNERSTATE = KSMETHOD_BDA_TUNER_SERVICE.GETTUNERSTATE;
pub const KSMETHOD_BDA_TUNER_SIGNALNOISERATIO = KSMETHOD_BDA_TUNER_SERVICE.SIGNALNOISERATIO;

const CLSID_KSMETHODSETID_BdaNameValueA_Value = @import("../zig.zig").Guid.initString("0c24096d-5ff5-47de-a856-062e587e3727");
pub const CLSID_KSMETHODSETID_BdaNameValueA = &CLSID_KSMETHODSETID_BdaNameValueA_Value;

const CLSID_KSMETHODSETID_BdaNameValue_Value = @import("../zig.zig").Guid.initString("36e07304-9f0d-4e88-9118-ac0ba317b7f2");
pub const CLSID_KSMETHODSETID_BdaNameValue = &CLSID_KSMETHODSETID_BdaNameValue_Value;

pub const KSMETHOD_BDA_GPNV_SERVICE = enum(i32) {
    GETVALUE = 0,
    SETVALUE = 1,
    NAMEFROMINDEX = 2,
    GETVALUEUPDATENAME = 3,
};
pub const KSMETHOD_BDA_GPNV_GETVALUE = KSMETHOD_BDA_GPNV_SERVICE.GETVALUE;
pub const KSMETHOD_BDA_GPNV_SETVALUE = KSMETHOD_BDA_GPNV_SERVICE.SETVALUE;
pub const KSMETHOD_BDA_GPNV_NAMEFROMINDEX = KSMETHOD_BDA_GPNV_SERVICE.NAMEFROMINDEX;
pub const KSMETHOD_BDA_GPNV_GETVALUEUPDATENAME = KSMETHOD_BDA_GPNV_SERVICE.GETVALUEUPDATENAME;

const CLSID_KSMETHODSETID_BdaMux_Value = @import("../zig.zig").Guid.initString("942aafec-4c05-4c74-b8eb-8706c2a4943f");
pub const CLSID_KSMETHODSETID_BdaMux = &CLSID_KSMETHODSETID_BdaMux_Value;

pub const KSMETHOD_BDA_MUX_SERVICE = enum(i32) {
    GETPIDLIST = 0,
    SETPIDLIST = 1,
};
pub const KSMETHOD_BDA_MUX_GETPIDLIST = KSMETHOD_BDA_MUX_SERVICE.GETPIDLIST;
pub const KSMETHOD_BDA_MUX_SETPIDLIST = KSMETHOD_BDA_MUX_SERVICE.SETPIDLIST;

const CLSID_KSMETHODSETID_BdaScanning_Value = @import("../zig.zig").Guid.initString("12eb49df-6249-47f3-b190-e21e6e2f8a9c");
pub const CLSID_KSMETHODSETID_BdaScanning = &CLSID_KSMETHODSETID_BdaScanning_Value;

pub const KSMETHOD_BDA_SCAN_SERVICE = enum(i32) {
    _CAPABILTIES = 0,
    NING_STATE = 1,
    _FILTER = 2,
    _START = 3,
    _RESUME = 4,
    _STOP = 5,
};
pub const KSMETHOD_BDA_SCAN_CAPABILTIES = KSMETHOD_BDA_SCAN_SERVICE._CAPABILTIES;
pub const KSMETHOD_BDA_SCANNING_STATE = KSMETHOD_BDA_SCAN_SERVICE.NING_STATE;
pub const KSMETHOD_BDA_SCAN_FILTER = KSMETHOD_BDA_SCAN_SERVICE._FILTER;
pub const KSMETHOD_BDA_SCAN_START = KSMETHOD_BDA_SCAN_SERVICE._START;
pub const KSMETHOD_BDA_SCAN_RESUME = KSMETHOD_BDA_SCAN_SERVICE._RESUME;
pub const KSMETHOD_BDA_SCAN_STOP = KSMETHOD_BDA_SCAN_SERVICE._STOP;

const CLSID_KSMETHODSETID_BdaGuideDataDeliveryService_Value = @import("../zig.zig").Guid.initString("8d9d5562-1589-417d-99ce-ac531dda19f9");
pub const CLSID_KSMETHODSETID_BdaGuideDataDeliveryService = &CLSID_KSMETHODSETID_BdaGuideDataDeliveryService_Value;

pub const KSMETHOD_BDA_GDDS_SERVICE = enum(i32) {
    DATATYPE = 0,
    DATA = 1,
    TUNEXMLFROMIDX = 2,
    GETSERVICES = 3,
    SERVICEFROMTUNEXML = 4,
    DATAUPDATE = 5,
};
pub const KSMETHOD_BDA_GDDS_DATATYPE = KSMETHOD_BDA_GDDS_SERVICE.DATATYPE;
pub const KSMETHOD_BDA_GDDS_DATA = KSMETHOD_BDA_GDDS_SERVICE.DATA;
pub const KSMETHOD_BDA_GDDS_TUNEXMLFROMIDX = KSMETHOD_BDA_GDDS_SERVICE.TUNEXMLFROMIDX;
pub const KSMETHOD_BDA_GDDS_GETSERVICES = KSMETHOD_BDA_GDDS_SERVICE.GETSERVICES;
pub const KSMETHOD_BDA_GDDS_SERVICEFROMTUNEXML = KSMETHOD_BDA_GDDS_SERVICE.SERVICEFROMTUNEXML;
pub const KSMETHOD_BDA_GDDS_DATAUPDATE = KSMETHOD_BDA_GDDS_SERVICE.DATAUPDATE;

const CLSID_KSMETHODSETID_BdaConditionalAccessService_Value = @import("../zig.zig").Guid.initString("10ced3b4-320b-41bf-9824-1b2e68e71eb9");
pub const CLSID_KSMETHODSETID_BdaConditionalAccessService = &CLSID_KSMETHODSETID_BdaConditionalAccessService_Value;

pub const KSMETHOD_BDA_CAS_SERVICE = enum(i32) {
    CHECKENTITLEMENTTOKEN = 0,
    SETCAPTURETOKEN = 1,
    OPENBROADCASTMMI = 2,
    CLOSEMMIDIALOG = 3,
};
pub const KSMETHOD_BDA_CAS_CHECKENTITLEMENTTOKEN = KSMETHOD_BDA_CAS_SERVICE.CHECKENTITLEMENTTOKEN;
pub const KSMETHOD_BDA_CAS_SETCAPTURETOKEN = KSMETHOD_BDA_CAS_SERVICE.SETCAPTURETOKEN;
pub const KSMETHOD_BDA_CAS_OPENBROADCASTMMI = KSMETHOD_BDA_CAS_SERVICE.OPENBROADCASTMMI;
pub const KSMETHOD_BDA_CAS_CLOSEMMIDIALOG = KSMETHOD_BDA_CAS_SERVICE.CLOSEMMIDIALOG;

const CLSID_KSMETHODSETID_BdaIsdbConditionalAccess_Value = @import("../zig.zig").Guid.initString("5e68c627-16c2-4e6c-b1e2-d00170cdaa0f");
pub const CLSID_KSMETHODSETID_BdaIsdbConditionalAccess = &CLSID_KSMETHODSETID_BdaIsdbConditionalAccess_Value;

pub const KSMETHOD_BDA_ISDB_CAS = enum(i32) {
    SETREQUEST = 0,
    RESPONSEDATA = 1,
};
pub const KSMETHOD_BDA_ISDBCAS_SETREQUEST = KSMETHOD_BDA_ISDB_CAS.SETREQUEST;
pub const KSMETHOD_BDA_ISDBCAS_RESPONSEDATA = KSMETHOD_BDA_ISDB_CAS.RESPONSEDATA;

const CLSID_KSMETHODSETID_BdaTSSelector_Value = @import("../zig.zig").Guid.initString("1dcfafe9-b45e-41b3-bb2a-561eb129ae98");
pub const CLSID_KSMETHODSETID_BdaTSSelector = &CLSID_KSMETHODSETID_BdaTSSelector_Value;

pub const KSMETHOD_BDA_TS_SELECTOR = enum(i32) {
    SETTSID = 0,
    GETTSINFORMATION = 1,
};
pub const KSMETHOD_BDA_TS_SELECTOR_SETTSID = KSMETHOD_BDA_TS_SELECTOR.SETTSID;
pub const KSMETHOD_BDA_TS_SELECTOR_GETTSINFORMATION = KSMETHOD_BDA_TS_SELECTOR.GETTSINFORMATION;

const CLSID_KSMETHODSETID_BdaUserActivity_Value = @import("../zig.zig").Guid.initString("eda5c834-4531-483c-be0a-94e6c96ff396");
pub const CLSID_KSMETHODSETID_BdaUserActivity = &CLSID_KSMETHODSETID_BdaUserActivity_Value;

pub const KSMETHOD_BDA_USERACTIVITY_SERVICE = enum(i32) {
    USEREASON = 0,
    INTERVAL = 1,
    DETECTED = 2,
};
pub const KSMETHOD_BDA_USERACTIVITY_USEREASON = KSMETHOD_BDA_USERACTIVITY_SERVICE.USEREASON;
pub const KSMETHOD_BDA_USERACTIVITY_INTERVAL = KSMETHOD_BDA_USERACTIVITY_SERVICE.INTERVAL;
pub const KSMETHOD_BDA_USERACTIVITY_DETECTED = KSMETHOD_BDA_USERACTIVITY_SERVICE.DETECTED;

const CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT_Value = @import("../zig.zig").Guid.initString("fd0a5af4-b41d-11d2-9c95-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT = &CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT_Value;

const CLSID_KSCATEGORY_BDA_NETWORK_TUNER_Value = @import("../zig.zig").Guid.initString("71985f48-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_NETWORK_TUNER = &CLSID_KSCATEGORY_BDA_NETWORK_TUNER_Value;

const CLSID_KSCATEGORY_BDA_NETWORK_EPG_Value = @import("../zig.zig").Guid.initString("71985f49-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_NETWORK_EPG = &CLSID_KSCATEGORY_BDA_NETWORK_EPG_Value;

const CLSID_KSCATEGORY_BDA_IP_SINK_Value = @import("../zig.zig").Guid.initString("71985f4a-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_IP_SINK = &CLSID_KSCATEGORY_BDA_IP_SINK_Value;

const CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER_Value = @import("../zig.zig").Guid.initString("71985f4b-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER = &CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER_Value;

const CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION_Value = @import("../zig.zig").Guid.initString("a2e3074f-6c3d-11d3-b653-00c04f79498e");
pub const CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION = &CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION_Value;

const CLSID_KSNODE_BDA_RF_TUNER_Value = @import("../zig.zig").Guid.initString("71985f4c-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_RF_TUNER = &CLSID_KSNODE_BDA_RF_TUNER_Value;

const CLSID_KSNODE_BDA_ANALOG_DEMODULATOR_Value = @import("../zig.zig").Guid.initString("634db199-27dd-46b8-acfb-ecc98e61a2ad");
pub const CLSID_KSNODE_BDA_ANALOG_DEMODULATOR = &CLSID_KSNODE_BDA_ANALOG_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_QAM_DEMODULATOR_Value = @import("../zig.zig").Guid.initString("71985f4d-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_QAM_DEMODULATOR = &CLSID_KSNODE_BDA_QAM_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_QPSK_DEMODULATOR_Value = @import("../zig.zig").Guid.initString("6390c905-27c1-4d67-bdb7-77c50d079300");
pub const CLSID_KSNODE_BDA_QPSK_DEMODULATOR = &CLSID_KSNODE_BDA_QPSK_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_8VSB_DEMODULATOR_Value = @import("../zig.zig").Guid.initString("71985f4f-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_8VSB_DEMODULATOR = &CLSID_KSNODE_BDA_8VSB_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_COFDM_DEMODULATOR_Value = @import("../zig.zig").Guid.initString("2dac6e05-edbe-4b9c-b387-1b6fad7d6495");
pub const CLSID_KSNODE_BDA_COFDM_DEMODULATOR = &CLSID_KSNODE_BDA_COFDM_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_8PSK_DEMODULATOR_Value = @import("../zig.zig").Guid.initString("e957a0e7-dd98-4a3c-810b-3525157ab62e");
pub const CLSID_KSNODE_BDA_8PSK_DEMODULATOR = &CLSID_KSNODE_BDA_8PSK_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR_Value = @import("../zig.zig").Guid.initString("fcea3ae3-2cb2-464d-8f5d-305c0bb778a2");
pub const CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR = &CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR_Value = @import("../zig.zig").Guid.initString("edde230a-9086-432d-b8a5-6670263807e9");
pub const CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR = &CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_OPENCABLE_POD_Value = @import("../zig.zig").Guid.initString("345812a0-fb7c-4790-aa7e-b1db88ac19c9");
pub const CLSID_KSNODE_BDA_OPENCABLE_POD = &CLSID_KSNODE_BDA_OPENCABLE_POD_Value;

const CLSID_KSNODE_BDA_COMMON_CA_POD_Value = @import("../zig.zig").Guid.initString("d83ef8fc-f3b8-45ab-8b71-ecf7c339deb4");
pub const CLSID_KSNODE_BDA_COMMON_CA_POD = &CLSID_KSNODE_BDA_COMMON_CA_POD_Value;

const CLSID_KSNODE_BDA_PID_FILTER_Value = @import("../zig.zig").Guid.initString("f5412789-b0a0-44e1-ae4f-ee999b1b7fbe");
pub const CLSID_KSNODE_BDA_PID_FILTER = &CLSID_KSNODE_BDA_PID_FILTER_Value;

const CLSID_KSNODE_BDA_IP_SINK_Value = @import("../zig.zig").Guid.initString("71985f4e-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_IP_SINK = &CLSID_KSNODE_BDA_IP_SINK_Value;

const CLSID_KSNODE_BDA_VIDEO_ENCODER_Value = @import("../zig.zig").Guid.initString("d98429e3-65c9-4ac4-93aa-766782833b7a");
pub const CLSID_KSNODE_BDA_VIDEO_ENCODER = &CLSID_KSNODE_BDA_VIDEO_ENCODER_Value;

const CLSID_KSNODE_BDA_PBDA_CAS_Value = @import("../zig.zig").Guid.initString("c026869f-7129-4e71-8696-ec8f75299b77");
pub const CLSID_KSNODE_BDA_PBDA_CAS = &CLSID_KSNODE_BDA_PBDA_CAS_Value;

const CLSID_KSNODE_BDA_PBDA_ISDBCAS_Value = @import("../zig.zig").Guid.initString("f2cf2ab3-5b9d-40ae-ab7c-4e7ad0bd1c52");
pub const CLSID_KSNODE_BDA_PBDA_ISDBCAS = &CLSID_KSNODE_BDA_PBDA_ISDBCAS_Value;

const CLSID_KSNODE_BDA_PBDA_TUNER_Value = @import("../zig.zig").Guid.initString("aa5e8286-593c-4979-9494-46a2a9dfe076");
pub const CLSID_KSNODE_BDA_PBDA_TUNER = &CLSID_KSNODE_BDA_PBDA_TUNER_Value;

const CLSID_KSNODE_BDA_PBDA_MUX_Value = @import("../zig.zig").Guid.initString("f88c7787-6678-4f4b-a13e-da09861d682b");
pub const CLSID_KSNODE_BDA_PBDA_MUX = &CLSID_KSNODE_BDA_PBDA_MUX_Value;

const CLSID_KSNODE_BDA_PBDA_DRM_Value = @import("../zig.zig").Guid.initString("9eeebd03-eea1-450f-96ae-633e6de63cce");
pub const CLSID_KSNODE_BDA_PBDA_DRM = &CLSID_KSNODE_BDA_PBDA_DRM_Value;

const CLSID_KSNODE_BDA_DRI_DRM_Value = @import("../zig.zig").Guid.initString("4f95ad74-cefb-42d2-94a9-68c5b2c1aabe");
pub const CLSID_KSNODE_BDA_DRI_DRM = &CLSID_KSNODE_BDA_DRI_DRM_Value;

const CLSID_KSNODE_BDA_TS_SELECTOR_Value = @import("../zig.zig").Guid.initString("5eddf185-fed1-4f45-9685-bbb73c323cfc");
pub const CLSID_KSNODE_BDA_TS_SELECTOR = &CLSID_KSNODE_BDA_TS_SELECTOR_Value;

const CLSID_PINNAME_IPSINK_INPUT_Value = @import("../zig.zig").Guid.initString("3fdffa70-ac9a-11d2-8f17-00c04f7971e2");
pub const CLSID_PINNAME_IPSINK_INPUT = &CLSID_PINNAME_IPSINK_INPUT_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_IP_Value = @import("../zig.zig").Guid.initString("e25f7b8e-cccc-11d2-8f25-00c04f7971e2");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_IP = &CLSID_KSDATAFORMAT_TYPE_BDA_IP_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_Value = @import("../zig.zig").Guid.initString("5a9a213c-db08-11d2-8f32-00c04f7971e2");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_Value;

const CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP_Value = @import("../zig.zig").Guid.initString("6b891420-db09-11d2-8f32-00c04f7971e2");
pub const CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP = &CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL_Value = @import("../zig.zig").Guid.initString("dadd5799-7d5b-4b63-80fb-d1442f26b621");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL = &CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL_Value = @import("../zig.zig").Guid.initString("499856e8-e85b-48ed-9bea-410d0dd4ef81");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL_Value;

const CLSID_PINNAME_MPE_Value = @import("../zig.zig").Guid.initString("c1b06d73-1dbb-11d3-8f46-00c04f7971e2");
pub const CLSID_PINNAME_MPE = &CLSID_PINNAME_MPE_Value;

const CLSID_KSDATAFORMAT_TYPE_MPE_Value = @import("../zig.zig").Guid.initString("455f176c-4b06-47ce-9aef-8caef73df7b5");
pub const CLSID_KSDATAFORMAT_TYPE_MPE = &CLSID_KSDATAFORMAT_TYPE_MPE_Value;

const CLSID_DIGITAL_CABLE_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("143827ab-f77b-498d-81ca-5a007aec28bf");
pub const CLSID_DIGITAL_CABLE_NETWORK_TYPE = &CLSID_DIGITAL_CABLE_NETWORK_TYPE_Value;

const CLSID_ANALOG_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("b820d87e-e0e3-478f-8a38-4e13f7b3df42");
pub const CLSID_ANALOG_TV_NETWORK_TYPE = &CLSID_ANALOG_TV_NETWORK_TYPE_Value;

const CLSID_ANALOG_AUXIN_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("742ef867-09e1-40a3-82d3-9669ba35325f");
pub const CLSID_ANALOG_AUXIN_NETWORK_TYPE = &CLSID_ANALOG_AUXIN_NETWORK_TYPE_Value;

const CLSID_ANALOG_FM_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("7728087b-2bb9-4e30-8078-449476e59dbb");
pub const CLSID_ANALOG_FM_NETWORK_TYPE = &CLSID_ANALOG_FM_NETWORK_TYPE_Value;

const CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("95037f6f-3ac7-4452-b6c4-45a9ce9292a2");
pub const CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_ISDB_T_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("fc3855a6-c901-4f2e-aba8-90815afc6c83");
pub const CLSID_ISDB_T_NETWORK_TYPE = &CLSID_ISDB_T_NETWORK_TYPE_Value;

const CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("b0a4e6a0-6a1a-4b83-bb5b-903e1d90e6b6");
pub const CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE = &CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_ISDB_S_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("a1e78202-1459-41b1-9ca9-2a92587a42cc");
pub const CLSID_ISDB_S_NETWORK_TYPE = &CLSID_ISDB_S_NETWORK_TYPE_Value;

const CLSID_ISDB_CABLE_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("c974ddb5-41fe-4b25-9741-92f049f1d5d1");
pub const CLSID_ISDB_CABLE_TV_NETWORK_TYPE = &CLSID_ISDB_CABLE_TV_NETWORK_TYPE_Value;

const CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("93b66fb5-93d4-4323-921c-c1f52df61d3f");
pub const CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE = &CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("c4f6b31b-c6bf-4759-886f-a7386dca27a0");
pub const CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE = &CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("0dad2fdd-5fd7-11d3-8f50-00c04f7971e2");
pub const CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("216c62df-6d7f-4e9a-8571-05f14edb766a");
pub const CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("9e9e46c6-3aba-4f08-ad0e-cc5ac8148c2b");
pub const CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_DVB_SATELLITE_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("fa4b375a-45b4-4d45-8440-263957b11623");
pub const CLSID_DVB_SATELLITE_TV_NETWORK_TYPE = &CLSID_DVB_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_DVB_CABLE_TV_NETWORK_TYPE_Value = @import("../zig.zig").Guid.initString("dc0c0fe7-0485-4266-b93f-68fbf80ed834");
pub const CLSID_DVB_CABLE_TV_NETWORK_TYPE = &CLSID_DVB_CABLE_TV_NETWORK_TYPE_Value;

const CLSID_BDA_DEBUG_DATA_AVAILABLE_Value = @import("../zig.zig").Guid.initString("69c24f54-9983-497e-b415-282be4c555fb");
pub const CLSID_BDA_DEBUG_DATA_AVAILABLE = &CLSID_BDA_DEBUG_DATA_AVAILABLE_Value;

const CLSID_BDA_DEBUG_DATA_TYPE_STRING_Value = @import("../zig.zig").Guid.initString("a806e767-de5c-430c-80bf-a21ebe06c748");
pub const CLSID_BDA_DEBUG_DATA_TYPE_STRING = &CLSID_BDA_DEBUG_DATA_TYPE_STRING_Value;

const CLSID_EVENTID_BDA_IsdbCASResponse_Value = @import("../zig.zig").Guid.initString("d4cb1966-41bc-4ced-9a20-fdceac78f70d");
pub const CLSID_EVENTID_BDA_IsdbCASResponse = &CLSID_EVENTID_BDA_IsdbCASResponse_Value;

const CLSID_EVENTID_BDA_CASRequestTuner_Value = @import("../zig.zig").Guid.initString("cf39a9d8-f5d3-4685-be57-ed81dba46b27");
pub const CLSID_EVENTID_BDA_CASRequestTuner = &CLSID_EVENTID_BDA_CASRequestTuner_Value;

const CLSID_EVENTID_BDA_CASReleaseTuner_Value = @import("../zig.zig").Guid.initString("20c1a16b-441f-49a5-bb5c-e9a04495c6c1");
pub const CLSID_EVENTID_BDA_CASReleaseTuner = &CLSID_EVENTID_BDA_CASReleaseTuner_Value;

const CLSID_EVENTID_BDA_CASOpenMMI_Value = @import("../zig.zig").Guid.initString("85dac915-e593-410d-8471-d6812105f28e");
pub const CLSID_EVENTID_BDA_CASOpenMMI = &CLSID_EVENTID_BDA_CASOpenMMI_Value;

const CLSID_EVENTID_BDA_CASCloseMMI_Value = @import("../zig.zig").Guid.initString("5d0f550f-de2e-479d-8345-ec0e9557e8a2");
pub const CLSID_EVENTID_BDA_CASCloseMMI = &CLSID_EVENTID_BDA_CASCloseMMI_Value;

const CLSID_EVENTID_BDA_CASBroadcastMMI_Value = @import("../zig.zig").Guid.initString("676876f0-1132-404c-a7ca-e72069a9d54f");
pub const CLSID_EVENTID_BDA_CASBroadcastMMI = &CLSID_EVENTID_BDA_CASBroadcastMMI_Value;

const CLSID_EVENTID_BDA_TunerSignalLock_Value = @import("../zig.zig").Guid.initString("1872e740-f573-429b-a00e-d9c1e408af09");
pub const CLSID_EVENTID_BDA_TunerSignalLock = &CLSID_EVENTID_BDA_TunerSignalLock_Value;

const CLSID_EVENTID_BDA_TunerNoSignal_Value = @import("../zig.zig").Guid.initString("e29b382b-1edd-4930-bc46-682fd72d2dfb");
pub const CLSID_EVENTID_BDA_TunerNoSignal = &CLSID_EVENTID_BDA_TunerNoSignal_Value;

const CLSID_EVENTID_BDA_GPNVValueUpdate_Value = @import("../zig.zig").Guid.initString("ff75c68c-f416-4e7e-bf17-6d55c5df1575");
pub const CLSID_EVENTID_BDA_GPNVValueUpdate = &CLSID_EVENTID_BDA_GPNVValueUpdate_Value;

const CLSID_EVENTID_BDA_UpdateDrmStatus_Value = @import("../zig.zig").Guid.initString("65a6f681-1462-473b-88ce-cb731427bdb5");
pub const CLSID_EVENTID_BDA_UpdateDrmStatus = &CLSID_EVENTID_BDA_UpdateDrmStatus_Value;

const CLSID_EVENTID_BDA_UpdateScanState_Value = @import("../zig.zig").Guid.initString("55702b50-7b49-42b8-a82f-4afb691b0628");
pub const CLSID_EVENTID_BDA_UpdateScanState = &CLSID_EVENTID_BDA_UpdateScanState_Value;

const CLSID_EVENTID_BDA_GuideDataAvailable_Value = @import("../zig.zig").Guid.initString("98db717a-478a-4cd4-92d0-95f66b89e5b1");
pub const CLSID_EVENTID_BDA_GuideDataAvailable = &CLSID_EVENTID_BDA_GuideDataAvailable_Value;

const CLSID_EVENTID_BDA_GuideServiceInformationUpdated_Value = @import("../zig.zig").Guid.initString("a1c3ea2b-175f-4458-b735-507d22db23a6");
pub const CLSID_EVENTID_BDA_GuideServiceInformationUpdated = &CLSID_EVENTID_BDA_GuideServiceInformationUpdated_Value;

const CLSID_EVENTID_BDA_GuideDataError_Value = @import("../zig.zig").Guid.initString("ac33c448-6f73-4fd7-b341-594c360d8d74");
pub const CLSID_EVENTID_BDA_GuideDataError = &CLSID_EVENTID_BDA_GuideDataError_Value;

const CLSID_EVENTID_BDA_DiseqCResponseAvailable_Value = @import("../zig.zig").Guid.initString("efa628f8-1f2c-4b67-9ea5-acf6fa9a1f36");
pub const CLSID_EVENTID_BDA_DiseqCResponseAvailable = &CLSID_EVENTID_BDA_DiseqCResponseAvailable_Value;

const CLSID_EVENTID_BDA_LbigsOpenConnection_Value = @import("../zig.zig").Guid.initString("356207b2-6f31-4eb0-a271-b3fa6bb7680f");
pub const CLSID_EVENTID_BDA_LbigsOpenConnection = &CLSID_EVENTID_BDA_LbigsOpenConnection_Value;

const CLSID_EVENTID_BDA_LbigsSendData_Value = @import("../zig.zig").Guid.initString("1123277b-f1c6-4154-8b0d-48e6157059aa");
pub const CLSID_EVENTID_BDA_LbigsSendData = &CLSID_EVENTID_BDA_LbigsSendData_Value;

const CLSID_EVENTID_BDA_LbigsCloseConnectionHandle_Value = @import("../zig.zig").Guid.initString("c2f08b99-65ef-4314-9671-e99d4cce0bae");
pub const CLSID_EVENTID_BDA_LbigsCloseConnectionHandle = &CLSID_EVENTID_BDA_LbigsCloseConnectionHandle_Value;

const CLSID_EVENTID_BDA_EncoderSignalLock_Value = @import("../zig.zig").Guid.initString("5ec90eb9-39fa-4cfc-b93f-00bb11077f5e");
pub const CLSID_EVENTID_BDA_EncoderSignalLock = &CLSID_EVENTID_BDA_EncoderSignalLock_Value;

const CLSID_EVENTID_BDA_FdcStatus_Value = @import("../zig.zig").Guid.initString("05f25366-d0eb-43d2-bc3c-682b863df142");
pub const CLSID_EVENTID_BDA_FdcStatus = &CLSID_EVENTID_BDA_FdcStatus_Value;

const CLSID_EVENTID_BDA_FdcTableSection_Value = @import("../zig.zig").Guid.initString("6a0cd757-4ce3-4e5b-9444-7187b87152c5");
pub const CLSID_EVENTID_BDA_FdcTableSection = &CLSID_EVENTID_BDA_FdcTableSection_Value;

const CLSID_EVENTID_BDA_TransprtStreamSelectorInfo_Value = @import("../zig.zig").Guid.initString("c40f9f85-09d0-489c-9e9c-0abbb56951b0");
pub const CLSID_EVENTID_BDA_TransprtStreamSelectorInfo = &CLSID_EVENTID_BDA_TransprtStreamSelectorInfo_Value;

const CLSID_EVENTID_BDA_RatingPinReset_Value = @import("../zig.zig").Guid.initString("c6e048c0-c574-4c26-bcda-2f4d35eb5e85");
pub const CLSID_EVENTID_BDA_RatingPinReset = &CLSID_EVENTID_BDA_RatingPinReset_Value;

const CLSID_PBDA_ALWAYS_TUNE_IN_MUX_Value = @import("../zig.zig").Guid.initString("1e1d7141-583f-4ac2-b019-1f430eda0f4c");
pub const CLSID_PBDA_ALWAYS_TUNE_IN_MUX = &CLSID_PBDA_ALWAYS_TUNE_IN_MUX_Value;

pub const PID_BITS = packed struct {
    _bitfield: u16,
};

pub const MPEG_HEADER_BITS = packed struct {
    _bitfield: u16,
};

pub const MPEG_HEADER_VERSION_BITS = extern struct {
    _bitfield: u8,
};

const CLSID_BDANETWORKTYPE_ATSC_Value = @import("../zig.zig").Guid.initString("71985f51-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_BDANETWORKTYPE_ATSC = &CLSID_BDANETWORKTYPE_ATSC_Value;

pub const MPEG1WAVEFORMAT = packed struct {
    wfx: WAVEFORMATEX,
    fwHeadLayer: u16,
    dwHeadBitrate: u32,
    fwHeadMode: u16,
    fwHeadModeExt: u16,
    wHeadEmphasis: u16,
    fwHeadFlags: u16,
    dwPTSLow: u32,
    dwPTSHigh: u32,
};

pub const MPEGLAYER3WAVEFORMAT = packed struct {
    wfx: WAVEFORMATEX,
    wID: u16,
    fdwFlags: MPEGLAYER3WAVEFORMAT_FLAGS,
    nBlockSize: u16,
    nFramesPerBlock: u16,
    nCodecDelay: u16,
};

pub const HEAACWAVEINFO = packed struct {
    wfx: WAVEFORMATEX,
    wPayloadType: u16,
    wAudioProfileLevelIndication: u16,
    wStructType: u16,
    wReserved1: u16,
    dwReserved2: u32,
};

pub const HEAACWAVEFORMAT = extern struct {
    wfInfo: HEAACWAVEINFO,
    pbAudioSpecificConfig: [1]u8,
};

pub const VIDEOENCODER_BITRATE_MODE = enum(i32) {
    ConstantBitRate = 0,
    VariableBitRateAverage = 1,
    VariableBitRatePeak = 2,
};
pub const ConstantBitRate = VIDEOENCODER_BITRATE_MODE.ConstantBitRate;
pub const VariableBitRateAverage = VIDEOENCODER_BITRATE_MODE.VariableBitRateAverage;
pub const VariableBitRatePeak = VIDEOENCODER_BITRATE_MODE.VariableBitRatePeak;

pub const DXVA_COPPSetProtectionLevelCmdData = extern struct {
    ProtType: u32,
    ProtLevel: u32,
    ExtendedInfoChangeMask: u32,
    ExtendedInfoData: u32,
};

pub const COPP_HDCP_Protection_Level = enum(i32) {
    Level0 = 0,
    // LevelMin = 0, this enum value conflicts with Level0
    Level1 = 1,
    // LevelMax = 1, this enum value conflicts with Level1
    ForceDWORD = 2147483647,
};
pub const COPP_HDCP_Level0 = COPP_HDCP_Protection_Level.Level0;
pub const COPP_HDCP_LevelMin = COPP_HDCP_Protection_Level.Level0;
pub const COPP_HDCP_Level1 = COPP_HDCP_Protection_Level.Level1;
pub const COPP_HDCP_LevelMax = COPP_HDCP_Protection_Level.Level1;
pub const COPP_HDCP_ForceDWORD = COPP_HDCP_Protection_Level.ForceDWORD;

pub const COPP_CGMSA_Protection_Level = enum(i32) {
    Disabled = 0,
    // LevelMin = 0, this enum value conflicts with Disabled
    CopyFreely = 1,
    CopyNoMore = 2,
    CopyOneGeneration = 3,
    CopyNever = 4,
    RedistributionControlRequired = 8,
    LevelMax = 12,
    ForceDWORD = 2147483647,
};
pub const COPP_CGMSA_Disabled = COPP_CGMSA_Protection_Level.Disabled;
pub const COPP_CGMSA_LevelMin = COPP_CGMSA_Protection_Level.Disabled;
pub const COPP_CGMSA_CopyFreely = COPP_CGMSA_Protection_Level.CopyFreely;
pub const COPP_CGMSA_CopyNoMore = COPP_CGMSA_Protection_Level.CopyNoMore;
pub const COPP_CGMSA_CopyOneGeneration = COPP_CGMSA_Protection_Level.CopyOneGeneration;
pub const COPP_CGMSA_CopyNever = COPP_CGMSA_Protection_Level.CopyNever;
pub const COPP_CGMSA_RedistributionControlRequired = COPP_CGMSA_Protection_Level.RedistributionControlRequired;
pub const COPP_CGMSA_LevelMax = COPP_CGMSA_Protection_Level.LevelMax;
pub const COPP_CGMSA_ForceDWORD = COPP_CGMSA_Protection_Level.ForceDWORD;

pub const COPP_ACP_Protection_Level = enum(i32) {
    Level0 = 0,
    // LevelMin = 0, this enum value conflicts with Level0
    Level1 = 1,
    Level2 = 2,
    Level3 = 3,
    // LevelMax = 3, this enum value conflicts with Level3
    ForceDWORD = 2147483647,
};
pub const COPP_ACP_Level0 = COPP_ACP_Protection_Level.Level0;
pub const COPP_ACP_LevelMin = COPP_ACP_Protection_Level.Level0;
pub const COPP_ACP_Level1 = COPP_ACP_Protection_Level.Level1;
pub const COPP_ACP_Level2 = COPP_ACP_Protection_Level.Level2;
pub const COPP_ACP_Level3 = COPP_ACP_Protection_Level.Level3;
pub const COPP_ACP_LevelMax = COPP_ACP_Protection_Level.Level3;
pub const COPP_ACP_ForceDWORD = COPP_ACP_Protection_Level.ForceDWORD;

pub const DXVA_COPPSetSignalingCmdData = extern struct {
    ActiveTVProtectionStandard: u32,
    AspectRatioChangeMask1: u32,
    AspectRatioData1: u32,
    AspectRatioChangeMask2: u32,
    AspectRatioData2: u32,
    AspectRatioChangeMask3: u32,
    AspectRatioData3: u32,
    ExtendedInfoChangeMask: [4]u32,
    ExtendedInfoData: [4]u32,
    Reserved: u32,
};

pub const COPP_TVProtectionStandard = enum(i32) {
    Unknown = -2147483648,
    None = 0,
    IEC61880_525i = 1,
    IEC61880_2_525i = 2,
    IEC62375_625p = 4,
    EIA608B_525 = 8,
    EN300294_625i = 16,
    CEA805A_TypeA_525p = 32,
    CEA805A_TypeA_750p = 64,
    CEA805A_TypeA_1125i = 128,
    CEA805A_TypeB_525p = 256,
    CEA805A_TypeB_750p = 512,
    CEA805A_TypeB_1125i = 1024,
    ARIBTRB15_525i = 2048,
    ARIBTRB15_525p = 4096,
    ARIBTRB15_750p = 8192,
    ARIBTRB15_1125i = 16384,
    Mask = -2147450881,
    Reserved = 2147450880,
};
pub const COPP_ProtectionStandard_Unknown = COPP_TVProtectionStandard.Unknown;
pub const COPP_ProtectionStandard_None = COPP_TVProtectionStandard.None;
pub const COPP_ProtectionStandard_IEC61880_525i = COPP_TVProtectionStandard.IEC61880_525i;
pub const COPP_ProtectionStandard_IEC61880_2_525i = COPP_TVProtectionStandard.IEC61880_2_525i;
pub const COPP_ProtectionStandard_IEC62375_625p = COPP_TVProtectionStandard.IEC62375_625p;
pub const COPP_ProtectionStandard_EIA608B_525 = COPP_TVProtectionStandard.EIA608B_525;
pub const COPP_ProtectionStandard_EN300294_625i = COPP_TVProtectionStandard.EN300294_625i;
pub const COPP_ProtectionStandard_CEA805A_TypeA_525p = COPP_TVProtectionStandard.CEA805A_TypeA_525p;
pub const COPP_ProtectionStandard_CEA805A_TypeA_750p = COPP_TVProtectionStandard.CEA805A_TypeA_750p;
pub const COPP_ProtectionStandard_CEA805A_TypeA_1125i = COPP_TVProtectionStandard.CEA805A_TypeA_1125i;
pub const COPP_ProtectionStandard_CEA805A_TypeB_525p = COPP_TVProtectionStandard.CEA805A_TypeB_525p;
pub const COPP_ProtectionStandard_CEA805A_TypeB_750p = COPP_TVProtectionStandard.CEA805A_TypeB_750p;
pub const COPP_ProtectionStandard_CEA805A_TypeB_1125i = COPP_TVProtectionStandard.CEA805A_TypeB_1125i;
pub const COPP_ProtectionStandard_ARIBTRB15_525i = COPP_TVProtectionStandard.ARIBTRB15_525i;
pub const COPP_ProtectionStandard_ARIBTRB15_525p = COPP_TVProtectionStandard.ARIBTRB15_525p;
pub const COPP_ProtectionStandard_ARIBTRB15_750p = COPP_TVProtectionStandard.ARIBTRB15_750p;
pub const COPP_ProtectionStandard_ARIBTRB15_1125i = COPP_TVProtectionStandard.ARIBTRB15_1125i;
pub const COPP_ProtectionStandard_Mask = COPP_TVProtectionStandard.Mask;
pub const COPP_ProtectionStandard_Reserved = COPP_TVProtectionStandard.Reserved;

pub const COPP_ImageAspectRatio_EN300294 = enum(i32) {
    EN300294_FullFormat4by3 = 0,
    EN300294_Box14by9Center = 1,
    EN300294_Box14by9Top = 2,
    EN300294_Box16by9Center = 3,
    EN300294_Box16by9Top = 4,
    EN300294_BoxGT16by9Center = 5,
    EN300294_FullFormat4by3ProtectedCenter = 6,
    EN300294_FullFormat16by9Anamorphic = 7,
    ForceDWORD = 2147483647,
};
pub const COPP_AspectRatio_EN300294_FullFormat4by3 = COPP_ImageAspectRatio_EN300294.EN300294_FullFormat4by3;
pub const COPP_AspectRatio_EN300294_Box14by9Center = COPP_ImageAspectRatio_EN300294.EN300294_Box14by9Center;
pub const COPP_AspectRatio_EN300294_Box14by9Top = COPP_ImageAspectRatio_EN300294.EN300294_Box14by9Top;
pub const COPP_AspectRatio_EN300294_Box16by9Center = COPP_ImageAspectRatio_EN300294.EN300294_Box16by9Center;
pub const COPP_AspectRatio_EN300294_Box16by9Top = COPP_ImageAspectRatio_EN300294.EN300294_Box16by9Top;
pub const COPP_AspectRatio_EN300294_BoxGT16by9Center = COPP_ImageAspectRatio_EN300294.EN300294_BoxGT16by9Center;
pub const COPP_AspectRatio_EN300294_FullFormat4by3ProtectedCenter = COPP_ImageAspectRatio_EN300294.EN300294_FullFormat4by3ProtectedCenter;
pub const COPP_AspectRatio_EN300294_FullFormat16by9Anamorphic = COPP_ImageAspectRatio_EN300294.EN300294_FullFormat16by9Anamorphic;
pub const COPP_AspectRatio_ForceDWORD = COPP_ImageAspectRatio_EN300294.ForceDWORD;

pub const COPP_StatusFlags = enum(i32) {
    StatusNormal = 0,
    LinkLost = 1,
    RenegotiationRequired = 2,
    StatusFlagsReserved = -4,
};
pub const COPP_StatusNormal = COPP_StatusFlags.StatusNormal;
pub const COPP_LinkLost = COPP_StatusFlags.LinkLost;
pub const COPP_RenegotiationRequired = COPP_StatusFlags.RenegotiationRequired;
pub const COPP_StatusFlagsReserved = COPP_StatusFlags.StatusFlagsReserved;

pub const DXVA_COPPStatusData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    dwData: u32,
    ExtendedInfoValidMask: u32,
    ExtendedInfoData: u32,
};

pub const DXVA_COPPStatusDisplayData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    DisplayWidth: u32,
    DisplayHeight: u32,
    Format: u32,
    d3dFormat: u32,
    FreqNumerator: u32,
    FreqDenominator: u32,
};

pub const COPP_StatusHDCPFlags = enum(i32) {
    Repeater = 1,
    FlagsReserved = -2,
};
pub const COPP_HDCPRepeater = COPP_StatusHDCPFlags.Repeater;
pub const COPP_HDCPFlagsReserved = COPP_StatusHDCPFlags.FlagsReserved;

pub const DXVA_COPPStatusHDCPKeyData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    dwHDCPFlags: u32,
    BKey: Guid,
    Reserved1: Guid,
    Reserved2: Guid,
};

pub const COPP_ConnectorType = enum(i32) {
    Unknown = -1,
    VGA = 0,
    SVideo = 1,
    CompositeVideo = 2,
    ComponentVideo = 3,
    DVI = 4,
    HDMI = 5,
    LVDS = 6,
    TMDS = 7,
    D_JPN = 8,
    Internal = -2147483648,
    ForceDWORD = 2147483647,
};
pub const COPP_ConnectorType_Unknown = COPP_ConnectorType.Unknown;
pub const COPP_ConnectorType_VGA = COPP_ConnectorType.VGA;
pub const COPP_ConnectorType_SVideo = COPP_ConnectorType.SVideo;
pub const COPP_ConnectorType_CompositeVideo = COPP_ConnectorType.CompositeVideo;
pub const COPP_ConnectorType_ComponentVideo = COPP_ConnectorType.ComponentVideo;
pub const COPP_ConnectorType_DVI = COPP_ConnectorType.DVI;
pub const COPP_ConnectorType_HDMI = COPP_ConnectorType.HDMI;
pub const COPP_ConnectorType_LVDS = COPP_ConnectorType.LVDS;
pub const COPP_ConnectorType_TMDS = COPP_ConnectorType.TMDS;
pub const COPP_ConnectorType_D_JPN = COPP_ConnectorType.D_JPN;
pub const COPP_ConnectorType_Internal = COPP_ConnectorType.Internal;
pub const COPP_ConnectorType_ForceDWORD = COPP_ConnectorType.ForceDWORD;

pub const COPP_BusType = enum(i32) {
    Unknown = 0,
    PCI = 1,
    PCIX = 2,
    PCIExpress = 3,
    AGP = 4,
    Integrated = -2147483648,
    ForceDWORD = 2147483647,
};
pub const COPP_BusType_Unknown = COPP_BusType.Unknown;
pub const COPP_BusType_PCI = COPP_BusType.PCI;
pub const COPP_BusType_PCIX = COPP_BusType.PCIX;
pub const COPP_BusType_PCIExpress = COPP_BusType.PCIExpress;
pub const COPP_BusType_AGP = COPP_BusType.AGP;
pub const COPP_BusType_Integrated = COPP_BusType.Integrated;
pub const COPP_BusType_ForceDWORD = COPP_BusType.ForceDWORD;

pub const DXVA_COPPStatusSignalingCmdData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    AvailableTVProtectionStandards: u32,
    ActiveTVProtectionStandard: u32,
    TVType: u32,
    AspectRatioValidMask1: u32,
    AspectRatioData1: u32,
    AspectRatioValidMask2: u32,
    AspectRatioData2: u32,
    AspectRatioValidMask3: u32,
    AspectRatioData3: u32,
    ExtendedInfoValidMask: [4]u32,
    ExtendedInfoData: [4]u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (2)
//--------------------------------------------------------------------------------
pub extern "QUARTZ" fn AMGetErrorTextA(
    hr: HRESULT,
    pbuffer: [*:0]u8,
    MaxLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "QUARTZ" fn AMGetErrorTextW(
    hr: HRESULT,
    pbuffer: [*:0]u16,
    MaxLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (2)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const AMGETERRORTEXTPROC = thismodule.AMGETERRORTEXTPROCA;
        pub const AMGetErrorText = thismodule.AMGetErrorTextA;
    },
    .wide => struct {
        pub const AMGETERRORTEXTPROC = thismodule.AMGETERRORTEXTPROCW;
        pub const AMGetErrorText = thismodule.AMGetErrorTextW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const AMGETERRORTEXTPROC = *opaque{};
        pub const AMGetErrorText = *opaque{};
    } else struct {
        pub const AMGETERRORTEXTPROC = @compileError("'AMGETERRORTEXTPROC' requires that UNICODE be set to true or false in the root module");
        pub const AMGetErrorText = @compileError("'AMGetErrorText' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (79)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BITMAPINFO = @import("../graphics/gdi.zig").BITMAPINFO;
const BITMAPINFOHEADER = @import("../graphics/gdi.zig").BITMAPINFOHEADER;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const CAUUID = @import("../system/ole.zig").CAUUID;
const CHAR = @import("../foundation.zig").CHAR;
const D3DFORMAT = @import("../graphics/direct3d9.zig").D3DFORMAT;
const D3DPOOL = @import("../graphics/direct3d9.zig").D3DPOOL;
const DDCAPS_DX7 = @import("../graphics/direct_draw.zig").DDCAPS_DX7;
const DDCOLORCONTROL = @import("../graphics/direct_draw.zig").DDCOLORCONTROL;
const DDCOLORKEY = @import("../graphics/direct_draw.zig").DDCOLORKEY;
const DDPIXELFORMAT = @import("../graphics/direct_draw.zig").DDPIXELFORMAT;
const DDSCAPS2 = @import("../graphics/direct_draw.zig").DDSCAPS2;
const DDSURFACEDESC = @import("../graphics/direct_draw.zig").DDSURFACEDESC;
const DDVIDEOPORTCONNECT = @import("../graphics/direct_draw.zig").DDVIDEOPORTCONNECT;
const DXVA2_AYUVSample16 = @import("../media/media_foundation.zig").DXVA2_AYUVSample16;
const DXVA2_AYUVSample8 = @import("../media/media_foundation.zig").DXVA2_AYUVSample8;
const DXVA2_ExtendedFormat = @import("../media/media_foundation.zig").DXVA2_ExtendedFormat;
const DXVA2_FilterValues = @import("../media/media_foundation.zig").DXVA2_FilterValues;
const DXVA2_Fixed32 = @import("../media/media_foundation.zig").DXVA2_Fixed32;
const DXVA2_ProcAmpValues = @import("../media/media_foundation.zig").DXVA2_ProcAmpValues;
const DXVA2_ValueRange = @import("../media/media_foundation.zig").DXVA2_ValueRange;
const DXVA2_VideoDesc = @import("../media/media_foundation.zig").DXVA2_VideoDesc;
const DXVA2_VideoProcessorCaps = @import("../media/media_foundation.zig").DXVA2_VideoProcessorCaps;
const EVENT_TRACE_HEADER = @import("../system/diagnostics/etw.zig").EVENT_TRACE_HEADER;
const HACCEL = @import("../ui/windows_and_messaging.zig").HACCEL;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDC = @import("../graphics/gdi.zig").HDC;
const HKEY = @import("../system/registry.zig").HKEY;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IBindCtx = @import("../system/com.zig").IBindCtx;
const IDirect3DDevice9 = @import("../graphics/direct3d9.zig").IDirect3DDevice9;
const IDirect3DSurface9 = @import("../graphics/direct3d9.zig").IDirect3DSurface9;
const IDirectDraw = @import("../graphics/direct_draw.zig").IDirectDraw;
const IDirectDraw7 = @import("../graphics/direct_draw.zig").IDirectDraw7;
const IDirectDrawPalette = @import("../graphics/direct_draw.zig").IDirectDrawPalette;
const IDirectDrawSurface = @import("../graphics/direct_draw.zig").IDirectDrawSurface;
const IDirectDrawSurface7 = @import("../graphics/direct_draw.zig").IDirectDrawSurface7;
const IDirectSound = @import("../media/audio/direct_sound.zig").IDirectSound;
const IDirectSoundBuffer = @import("../media/audio/direct_sound.zig").IDirectSoundBuffer;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumGUID = @import("../system/com.zig").IEnumGUID;
const IEnumMoniker = @import("../system/com.zig").IEnumMoniker;
const IEnumVARIANT = @import("../system/ole.zig").IEnumVARIANT;
const IErrorLog = @import("../system/com.zig").IErrorLog;
const IMFVideoPresenter = @import("../media/media_foundation.zig").IMFVideoPresenter;
const IMoniker = @import("../system/com.zig").IMoniker;
const IPersist = @import("../system/com.zig").IPersist;
const IPictureDisp = @import("../system/ole.zig").IPictureDisp;
const IPropertyBag = @import("../system/com/structured_storage.zig").IPropertyBag;
const IReferenceClock = @import("../media.zig").IReferenceClock;
const IUnknown = @import("../system/com.zig").IUnknown;
const IWMProfile = @import("../media/windows_media_format.zig").IWMProfile;
const KSDATAFORMAT = @import("../media/kernel_streaming.zig").KSDATAFORMAT;
const KSEVENTDATA = @import("../media/kernel_streaming.zig").KSEVENTDATA;
const KSIDENTIFIER = @import("../media/kernel_streaming.zig").KSIDENTIFIER;
const KSM_NODE = @import("../media/kernel_streaming.zig").KSM_NODE;
const KSP_NODE = @import("../media/kernel_streaming.zig").KSP_NODE;
const KSTOPOLOGY_CONNECTION = @import("../media/kernel_streaming.zig").KSTOPOLOGY_CONNECTION;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PALETTEENTRY = @import("../graphics/gdi.zig").PALETTEENTRY;
const PAPCFUNC = @import("../foundation.zig").PAPCFUNC;
const POINT = @import("../foundation.zig").POINT;
const PSID = @import("../foundation.zig").PSID;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const RGBQUAD = @import("../graphics/gdi.zig").RGBQUAD;
const RGNDATA = @import("../graphics/gdi.zig").RGNDATA;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const SIZE = @import("../foundation.zig").SIZE;
const TIMECODE = @import("../media.zig").TIMECODE;
const TIMECODE_SAMPLE = @import("../media.zig").TIMECODE_SAMPLE;
const VARIANT = @import("../system/com.zig").VARIANT;
const WAVEFORMATEX = @import("../media/audio.zig").WAVEFORMATEX;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "AMGETERRORTEXTPROCA")) { _ = AMGETERRORTEXTPROCA; }
    if (@hasDecl(@This(), "AMGETERRORTEXTPROCW")) { _ = AMGETERRORTEXTPROCW; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT")) { _ = PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS")) { _ = PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORCAPS")) { _ = PDXVA2SW_GETVIDEOPROCESSORCAPS; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT")) { _ = PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS")) { _ = PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS; }
    if (@hasDecl(@This(), "PDXVA2SW_GETPROCAMPRANGE")) { _ = PDXVA2SW_GETPROCAMPRANGE; }
    if (@hasDecl(@This(), "PDXVA2SW_GETFILTERPROPERTYRANGE")) { _ = PDXVA2SW_GETFILTERPROPERTYRANGE; }
    if (@hasDecl(@This(), "PDXVA2SW_CREATEVIDEOPROCESSDEVICE")) { _ = PDXVA2SW_CREATEVIDEOPROCESSDEVICE; }
    if (@hasDecl(@This(), "PDXVA2SW_DESTROYVIDEOPROCESSDEVICE")) { _ = PDXVA2SW_DESTROYVIDEOPROCESSDEVICE; }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSBEGINFRAME")) { _ = PDXVA2SW_VIDEOPROCESSBEGINFRAME; }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSENDFRAME")) { _ = PDXVA2SW_VIDEOPROCESSENDFRAME; }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSSETRENDERTARGET")) { _ = PDXVA2SW_VIDEOPROCESSSETRENDERTARGET; }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSBLT")) { _ = PDXVA2SW_VIDEOPROCESSBLT; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (1)
//--------------------------------------------------------------------------------
pub const xml = @import("direct_show/xml.zig");
