//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (459)
//--------------------------------------------------------------------------------
pub const MIXERCONTROL_CONTROLTYPE_CUSTOM = @as(u32, 0);
pub const MIXERCONTROL_CONTROLTYPE_BOOLEANMETER = @as(u32, 268500992);
pub const MIXERCONTROL_CONTROLTYPE_SIGNEDMETER = @as(u32, 268566528);
pub const MIXERCONTROL_CONTROLTYPE_PEAKMETER = @as(u32, 268566529);
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER = @as(u32, 268632064);
pub const MIXERCONTROL_CONTROLTYPE_BOOLEAN = @as(u32, 536936448);
pub const MIXERCONTROL_CONTROLTYPE_ONOFF = @as(u32, 536936449);
pub const MIXERCONTROL_CONTROLTYPE_MUTE = @as(u32, 536936450);
pub const MIXERCONTROL_CONTROLTYPE_MONO = @as(u32, 536936451);
pub const MIXERCONTROL_CONTROLTYPE_LOUDNESS = @as(u32, 536936452);
pub const MIXERCONTROL_CONTROLTYPE_STEREOENH = @as(u32, 536936453);
pub const MIXERCONTROL_CONTROLTYPE_BASS_BOOST = @as(u32, 536945271);
pub const MIXERCONTROL_CONTROLTYPE_BUTTON = @as(u32, 553713664);
pub const MIXERCONTROL_CONTROLTYPE_DECIBELS = @as(u32, 805568512);
pub const MIXERCONTROL_CONTROLTYPE_SIGNED = @as(u32, 805437440);
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNED = @as(u32, 805502976);
pub const MIXERCONTROL_CONTROLTYPE_PERCENT = @as(u32, 805634048);
pub const MIXERCONTROL_CONTROLTYPE_SLIDER = @as(u32, 1073872896);
pub const MIXERCONTROL_CONTROLTYPE_PAN = @as(u32, 1073872897);
pub const MIXERCONTROL_CONTROLTYPE_QSOUNDPAN = @as(u32, 1073872898);
pub const MIXERCONTROL_CONTROLTYPE_FADER = @as(u32, 1342373888);
pub const MIXERCONTROL_CONTROLTYPE_VOLUME = @as(u32, 1342373889);
pub const MIXERCONTROL_CONTROLTYPE_BASS = @as(u32, 1342373890);
pub const MIXERCONTROL_CONTROLTYPE_TREBLE = @as(u32, 1342373891);
pub const MIXERCONTROL_CONTROLTYPE_EQUALIZER = @as(u32, 1342373892);
pub const MIXERCONTROL_CONTROLTYPE_SINGLESELECT = @as(u32, 1879113728);
pub const MIXERCONTROL_CONTROLTYPE_MUX = @as(u32, 1879113729);
pub const MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT = @as(u32, 1895890944);
pub const MIXERCONTROL_CONTROLTYPE_MIXER = @as(u32, 1895890945);
pub const MIXERCONTROL_CONTROLTYPE_MICROTIME = @as(u32, 1610809344);
pub const MIXERCONTROL_CONTROLTYPE_MILLITIME = @as(u32, 1627586560);
pub const WAVE_MAPPER = @as(u32, 4294967295);
pub const ENDPOINT_FORMAT_RESET_MIX_ONLY = @as(u32, 1);
pub const ENDPOINT_HARDWARE_SUPPORT_VOLUME = @as(u32, 1);
pub const ENDPOINT_HARDWARE_SUPPORT_MUTE = @as(u32, 2);
pub const ENDPOINT_HARDWARE_SUPPORT_METER = @as(u32, 4);
pub const AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ = @as(u32, 1);
pub const AMBISONICS_PARAM_VERSION_1 = @as(u32, 1);
pub const AUDCLNT_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287487));
pub const AUDCLNT_E_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287486));
pub const AUDCLNT_E_WRONG_ENDPOINT_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287485));
pub const AUDCLNT_E_DEVICE_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287484));
pub const AUDCLNT_E_NOT_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287483));
pub const AUDCLNT_E_BUFFER_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287482));
pub const AUDCLNT_E_OUT_OF_ORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287481));
pub const AUDCLNT_E_UNSUPPORTED_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287480));
pub const AUDCLNT_E_INVALID_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287479));
pub const AUDCLNT_E_DEVICE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287478));
pub const AUDCLNT_E_BUFFER_OPERATION_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287477));
pub const AUDCLNT_E_THREAD_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287476));
pub const AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287474));
pub const AUDCLNT_E_ENDPOINT_CREATE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287473));
pub const AUDCLNT_E_SERVICE_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287472));
pub const AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287471));
pub const AUDCLNT_E_EXCLUSIVE_MODE_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287470));
pub const AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287469));
pub const AUDCLNT_E_EVENTHANDLE_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287468));
pub const AUDCLNT_E_INCORRECT_BUFFER_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287467));
pub const AUDCLNT_E_BUFFER_SIZE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287466));
pub const AUDCLNT_E_CPUUSAGE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287465));
pub const AUDCLNT_E_BUFFER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287464));
pub const AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287463));
pub const AUDCLNT_E_INVALID_DEVICE_PERIOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287456));
pub const AUDCLNT_E_INVALID_STREAM_FLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287455));
pub const AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287454));
pub const AUDCLNT_E_OUT_OF_OFFLOAD_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287453));
pub const AUDCLNT_E_OFFLOAD_MODE_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287452));
pub const AUDCLNT_E_NONOFFLOAD_MODE_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287451));
pub const AUDCLNT_E_RESOURCES_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287450));
pub const AUDCLNT_E_RAW_MODE_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287449));
pub const AUDCLNT_E_ENGINE_PERIODICITY_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287448));
pub const AUDCLNT_E_ENGINE_FORMAT_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287447));
pub const AUDCLNT_E_HEADTRACKING_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287440));
pub const AUDCLNT_E_HEADTRACKING_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287424));
pub const AUDCLNT_E_EFFECT_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287423));
pub const AUDCLNT_E_EFFECT_STATE_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287422));
pub const AUDCLNT_S_BUFFER_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 143196161));
pub const AUDCLNT_S_THREAD_ALREADY_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 143196162));
pub const AUDCLNT_S_POSITION_STALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 143196163));
pub const AUDCLNT_STREAMFLAGS_CROSSPROCESS = @as(u32, 65536);
pub const AUDCLNT_STREAMFLAGS_LOOPBACK = @as(u32, 131072);
pub const AUDCLNT_STREAMFLAGS_EVENTCALLBACK = @as(u32, 262144);
pub const AUDCLNT_STREAMFLAGS_NOPERSIST = @as(u32, 524288);
pub const AUDCLNT_STREAMFLAGS_RATEADJUST = @as(u32, 1048576);
pub const AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY = @as(u32, 134217728);
pub const AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM = @as(u32, 2147483648);
pub const AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED = @as(u32, 268435456);
pub const AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE = @as(u32, 536870912);
pub const AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED = @as(u32, 1073741824);
pub const SPTLAUDCLNT_E_DESTROYED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287232));
pub const SPTLAUDCLNT_E_OUT_OF_ORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287231));
pub const SPTLAUDCLNT_E_RESOURCES_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287230));
pub const SPTLAUDCLNT_E_NO_MORE_OBJECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287229));
pub const SPTLAUDCLNT_E_PROPERTY_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287228));
pub const SPTLAUDCLNT_E_ERRORS_IN_OBJECT_CALLS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287227));
pub const SPTLAUDCLNT_E_METADATA_FORMAT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287226));
pub const SPTLAUDCLNT_E_STREAM_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287225));
pub const SPTLAUDCLNT_E_INVALID_LICENSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287224));
pub const SPTLAUDCLNT_E_STREAM_NOT_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287222));
pub const SPTLAUDCLNT_E_STATIC_OBJECT_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287221));
pub const SPTLAUDCLNT_E_OBJECT_ALREADY_ACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287220));
pub const SPTLAUDCLNT_E_INTERNAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287219));
pub const DEVICE_STATE_ACTIVE = @as(u32, 1);
pub const DEVICE_STATE_DISABLED = @as(u32, 2);
pub const DEVICE_STATE_NOTPRESENT = @as(u32, 4);
pub const DEVICE_STATE_UNPLUGGED = @as(u32, 8);
pub const DEVICE_STATEMASK_ALL = @as(u32, 15);
pub const ENDPOINT_SYSFX_ENABLED = @as(u32, 0);
pub const ENDPOINT_SYSFX_DISABLED = @as(u32, 1);
pub const DEVINTERFACE_AUDIO_RENDER = Guid.initString("e6327cad-dcec-4949-ae8a-991e976a79d2");
pub const DEVINTERFACE_AUDIO_CAPTURE = Guid.initString("2eef81be-33fa-4800-9670-1cd474972c3f");
pub const DEVINTERFACE_MIDI_OUTPUT = Guid.initString("6dc23320-ab33-4ce4-80d4-bbb3ebbf2814");
pub const DEVINTERFACE_MIDI_INPUT = Guid.initString("504be32c-ccf6-4d2c-b73f-6f8b3747e22b");
pub const EVENTCONTEXT_VOLUMESLIDER = Guid.initString("e2c2e9de-09b1-4b04-84e5-07931225ee04");
pub const SPATIAL_AUDIO_STANDARD_COMMANDS_START = @as(u32, 200);
pub const SPATIAL_AUDIO_POSITION = @as(u32, 200);
pub const SPTLAUD_MD_CLNT_E_COMMAND_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286976));
pub const SPTLAUD_MD_CLNT_E_OBJECT_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286975));
pub const SPTLAUD_MD_CLNT_E_INVALID_ARGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286974));
pub const SPTLAUD_MD_CLNT_E_METADATA_FORMAT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286973));
pub const SPTLAUD_MD_CLNT_E_VALUE_BUFFER_INCORRECT_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286972));
pub const SPTLAUD_MD_CLNT_E_MEMORY_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286971));
pub const SPTLAUD_MD_CLNT_E_NO_MORE_COMMANDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286970));
pub const SPTLAUD_MD_CLNT_E_BUFFER_ALREADY_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286969));
pub const SPTLAUD_MD_CLNT_E_BUFFER_NOT_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286968));
pub const SPTLAUD_MD_CLNT_E_FRAMECOUNT_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286967));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMS_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286960));
pub const SPTLAUD_MD_CLNT_E_ITEM_COPY_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286959));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMS_OPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286958));
pub const SPTLAUD_MD_CLNT_E_ITEMS_ALREADY_OPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286957));
pub const SPTLAUD_MD_CLNT_E_ATTACH_FAILED_INTERNAL_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286956));
pub const SPTLAUD_MD_CLNT_E_DETACH_FAILED_INTERNAL_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286955));
pub const SPTLAUD_MD_CLNT_E_NO_BUFFER_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286954));
pub const SPTLAUD_MD_CLNT_E_NO_MORE_ITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286953));
pub const SPTLAUD_MD_CLNT_E_FRAMEOFFSET_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286952));
pub const SPTLAUD_MD_CLNT_E_ITEM_MUST_HAVE_COMMANDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286951));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMOFFSET_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286944));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMS_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286943));
pub const SPTLAUD_MD_CLNT_E_COMMAND_ALREADY_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286942));
pub const SPTLAUD_MD_CLNT_E_FORMAT_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286941));
pub const SPTLAUD_MD_CLNT_E_BUFFER_STILL_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286940));
pub const SPTLAUD_MD_CLNT_E_ITEMS_LOCKED_FOR_WRITING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286939));
pub const WAVERR_BADFORMAT = @as(u32, 32);
pub const WAVERR_STILLPLAYING = @as(u32, 33);
pub const WAVERR_UNPREPARED = @as(u32, 34);
pub const WAVERR_SYNC = @as(u32, 35);
pub const WAVERR_LASTERROR = @as(u32, 35);
pub const WHDR_DONE = @as(u32, 1);
pub const WHDR_PREPARED = @as(u32, 2);
pub const WHDR_BEGINLOOP = @as(u32, 4);
pub const WHDR_ENDLOOP = @as(u32, 8);
pub const WHDR_INQUEUE = @as(u32, 16);
pub const WAVECAPS_PITCH = @as(u32, 1);
pub const WAVECAPS_PLAYBACKRATE = @as(u32, 2);
pub const WAVECAPS_VOLUME = @as(u32, 4);
pub const WAVECAPS_LRVOLUME = @as(u32, 8);
pub const WAVECAPS_SYNC = @as(u32, 16);
pub const WAVECAPS_SAMPLEACCURATE = @as(u32, 32);
pub const WAVE_INVALIDFORMAT = @as(u32, 0);
pub const WAVE_FORMAT_1M08 = @as(u32, 1);
pub const WAVE_FORMAT_1S08 = @as(u32, 2);
pub const WAVE_FORMAT_1M16 = @as(u32, 4);
pub const WAVE_FORMAT_1S16 = @as(u32, 8);
pub const WAVE_FORMAT_2M08 = @as(u32, 16);
pub const WAVE_FORMAT_2S08 = @as(u32, 32);
pub const WAVE_FORMAT_2M16 = @as(u32, 64);
pub const WAVE_FORMAT_2S16 = @as(u32, 128);
pub const WAVE_FORMAT_4M08 = @as(u32, 256);
pub const WAVE_FORMAT_4S08 = @as(u32, 512);
pub const WAVE_FORMAT_4M16 = @as(u32, 1024);
pub const WAVE_FORMAT_4S16 = @as(u32, 2048);
pub const WAVE_FORMAT_44M08 = @as(u32, 256);
pub const WAVE_FORMAT_44S08 = @as(u32, 512);
pub const WAVE_FORMAT_44M16 = @as(u32, 1024);
pub const WAVE_FORMAT_44S16 = @as(u32, 2048);
pub const WAVE_FORMAT_48M08 = @as(u32, 4096);
pub const WAVE_FORMAT_48S08 = @as(u32, 8192);
pub const WAVE_FORMAT_48M16 = @as(u32, 16384);
pub const WAVE_FORMAT_48S16 = @as(u32, 32768);
pub const WAVE_FORMAT_96M08 = @as(u32, 65536);
pub const WAVE_FORMAT_96S08 = @as(u32, 131072);
pub const WAVE_FORMAT_96M16 = @as(u32, 262144);
pub const WAVE_FORMAT_96S16 = @as(u32, 524288);
pub const WAVE_FORMAT_PCM = @as(u32, 1);
pub const MIDIERR_UNPREPARED = @as(u32, 64);
pub const MIDIERR_STILLPLAYING = @as(u32, 65);
pub const MIDIERR_NOMAP = @as(u32, 66);
pub const MIDIERR_NOTREADY = @as(u32, 67);
pub const MIDIERR_NODEVICE = @as(u32, 68);
pub const MIDIERR_INVALIDSETUP = @as(u32, 69);
pub const MIDIERR_BADOPENMODE = @as(u32, 70);
pub const MIDIERR_DONT_CONTINUE = @as(u32, 71);
pub const MIDIERR_LASTERROR = @as(u32, 71);
pub const MIDIPATCHSIZE = @as(u32, 128);
pub const MIDI_CACHE_ALL = @as(u32, 1);
pub const MIDI_CACHE_BESTFIT = @as(u32, 2);
pub const MIDI_CACHE_QUERY = @as(u32, 3);
pub const MIDI_UNCACHE = @as(u32, 4);
pub const MOD_MIDIPORT = @as(u32, 1);
pub const MOD_SYNTH = @as(u32, 2);
pub const MOD_SQSYNTH = @as(u32, 3);
pub const MOD_FMSYNTH = @as(u32, 4);
pub const MOD_MAPPER = @as(u32, 5);
pub const MOD_WAVETABLE = @as(u32, 6);
pub const MOD_SWSYNTH = @as(u32, 7);
pub const MIDICAPS_VOLUME = @as(u32, 1);
pub const MIDICAPS_LRVOLUME = @as(u32, 2);
pub const MIDICAPS_CACHE = @as(u32, 4);
pub const MIDICAPS_STREAM = @as(u32, 8);
pub const MHDR_DONE = @as(u32, 1);
pub const MHDR_PREPARED = @as(u32, 2);
pub const MHDR_INQUEUE = @as(u32, 4);
pub const MHDR_ISSTRM = @as(u32, 8);
pub const MEVT_F_SHORT = @as(i32, 0);
pub const MEVT_F_LONG = @as(i32, -2147483648);
pub const MEVT_F_CALLBACK = @as(i32, 1073741824);
pub const MIDISTRM_ERROR = @as(i32, -2);
pub const MIDIPROP_SET = @as(i32, -2147483648);
pub const MIDIPROP_GET = @as(i32, 1073741824);
pub const MIDIPROP_TIMEDIV = @as(i32, 1);
pub const MIDIPROP_TEMPO = @as(i32, 2);
pub const AUXCAPS_CDAUDIO = @as(u32, 1);
pub const AUXCAPS_AUXIN = @as(u32, 2);
pub const AUXCAPS_VOLUME = @as(u32, 1);
pub const AUXCAPS_LRVOLUME = @as(u32, 2);
pub const MIXER_SHORT_NAME_CHARS = @as(u32, 16);
pub const MIXER_LONG_NAME_CHARS = @as(u32, 64);
pub const MIXERR_INVALLINE = @as(u32, 1024);
pub const MIXERR_INVALCONTROL = @as(u32, 1025);
pub const MIXERR_INVALVALUE = @as(u32, 1026);
pub const MIXERR_LASTERROR = @as(u32, 1026);
pub const MIXER_OBJECTF_HANDLE = @as(i32, -2147483648);
pub const MIXER_OBJECTF_MIXER = @as(i32, 0);
pub const MIXER_OBJECTF_WAVEOUT = @as(i32, 268435456);
pub const MIXER_OBJECTF_WAVEIN = @as(i32, 536870912);
pub const MIXER_OBJECTF_MIDIOUT = @as(i32, 805306368);
pub const MIXER_OBJECTF_MIDIIN = @as(i32, 1073741824);
pub const MIXER_OBJECTF_AUX = @as(i32, 1342177280);
pub const MIXERLINE_LINEF_ACTIVE = @as(i32, 1);
pub const MIXERLINE_LINEF_DISCONNECTED = @as(i32, 32768);
pub const MIXERLINE_LINEF_SOURCE = @as(i32, -2147483648);
pub const MIXERLINE_COMPONENTTYPE_DST_FIRST = @as(i32, 0);
pub const MIXERLINE_COMPONENTTYPE_DST_LAST = @as(u32, 8);
pub const MIXERLINE_COMPONENTTYPE_SRC_FIRST = @as(i32, 4096);
pub const MIXERLINE_COMPONENTTYPE_SRC_LAST = @as(u32, 4106);
pub const MIXERLINE_TARGETTYPE_UNDEFINED = @as(u32, 0);
pub const MIXERLINE_TARGETTYPE_WAVEOUT = @as(u32, 1);
pub const MIXERLINE_TARGETTYPE_WAVEIN = @as(u32, 2);
pub const MIXERLINE_TARGETTYPE_MIDIOUT = @as(u32, 3);
pub const MIXERLINE_TARGETTYPE_MIDIIN = @as(u32, 4);
pub const MIXERLINE_TARGETTYPE_AUX = @as(u32, 5);
pub const MIXER_GETLINEINFOF_DESTINATION = @as(i32, 0);
pub const MIXER_GETLINEINFOF_SOURCE = @as(i32, 1);
pub const MIXER_GETLINEINFOF_LINEID = @as(i32, 2);
pub const MIXER_GETLINEINFOF_COMPONENTTYPE = @as(i32, 3);
pub const MIXER_GETLINEINFOF_TARGETTYPE = @as(i32, 4);
pub const MIXER_GETLINEINFOF_QUERYMASK = @as(i32, 15);
pub const MIXERCONTROL_CONTROLF_UNIFORM = @as(i32, 1);
pub const MIXERCONTROL_CONTROLF_MULTIPLE = @as(i32, 2);
pub const MIXERCONTROL_CONTROLF_DISABLED = @as(i32, -2147483648);
pub const MIXERCONTROL_CT_CLASS_MASK = @as(i32, -268435456);
pub const MIXERCONTROL_CT_CLASS_CUSTOM = @as(i32, 0);
pub const MIXERCONTROL_CT_CLASS_METER = @as(i32, 268435456);
pub const MIXERCONTROL_CT_CLASS_SWITCH = @as(i32, 536870912);
pub const MIXERCONTROL_CT_CLASS_NUMBER = @as(i32, 805306368);
pub const MIXERCONTROL_CT_CLASS_SLIDER = @as(i32, 1073741824);
pub const MIXERCONTROL_CT_CLASS_FADER = @as(i32, 1342177280);
pub const MIXERCONTROL_CT_CLASS_TIME = @as(i32, 1610612736);
pub const MIXERCONTROL_CT_CLASS_LIST = @as(i32, 1879048192);
pub const MIXERCONTROL_CT_SUBCLASS_MASK = @as(i32, 251658240);
pub const MIXERCONTROL_CT_SC_SWITCH_BOOLEAN = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_SWITCH_BUTTON = @as(i32, 16777216);
pub const MIXERCONTROL_CT_SC_METER_POLLED = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_TIME_MICROSECS = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_TIME_MILLISECS = @as(i32, 16777216);
pub const MIXERCONTROL_CT_SC_LIST_SINGLE = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_LIST_MULTIPLE = @as(i32, 16777216);
pub const MIXERCONTROL_CT_UNITS_MASK = @as(i32, 16711680);
pub const MIXERCONTROL_CT_UNITS_CUSTOM = @as(i32, 0);
pub const MIXERCONTROL_CT_UNITS_BOOLEAN = @as(i32, 65536);
pub const MIXERCONTROL_CT_UNITS_SIGNED = @as(i32, 131072);
pub const MIXERCONTROL_CT_UNITS_UNSIGNED = @as(i32, 196608);
pub const MIXERCONTROL_CT_UNITS_DECIBELS = @as(i32, 262144);
pub const MIXERCONTROL_CT_UNITS_PERCENT = @as(i32, 327680);
pub const MIXER_GETLINECONTROLSF_ALL = @as(i32, 0);
pub const MIXER_GETLINECONTROLSF_ONEBYID = @as(i32, 1);
pub const MIXER_GETLINECONTROLSF_ONEBYTYPE = @as(i32, 2);
pub const MIXER_GETLINECONTROLSF_QUERYMASK = @as(i32, 15);
pub const MIXER_GETCONTROLDETAILSF_VALUE = @as(i32, 0);
pub const MIXER_GETCONTROLDETAILSF_LISTTEXT = @as(i32, 1);
pub const MIXER_GETCONTROLDETAILSF_QUERYMASK = @as(i32, 15);
pub const MIXER_SETCONTROLDETAILSF_VALUE = @as(i32, 0);
pub const MIXER_SETCONTROLDETAILSF_CUSTOM = @as(i32, 1);
pub const MIXER_SETCONTROLDETAILSF_QUERYMASK = @as(i32, 15);
pub const DRV_MAPPER_PREFERRED_INPUT_GET = @as(u32, 16384);
pub const DRV_MAPPER_PREFERRED_OUTPUT_GET = @as(u32, 16386);
pub const DRVM_MAPPER = @as(u32, 8192);
pub const DRVM_MAPPER_STATUS = @as(u32, 8192);
pub const WIDM_MAPPER_STATUS = @as(u32, 8192);
pub const WAVEIN_MAPPER_STATUS_DEVICE = @as(u32, 0);
pub const WAVEIN_MAPPER_STATUS_MAPPED = @as(u32, 1);
pub const WAVEIN_MAPPER_STATUS_FORMAT = @as(u32, 2);
pub const WODM_MAPPER_STATUS = @as(u32, 8192);
pub const WAVEOUT_MAPPER_STATUS_DEVICE = @as(u32, 0);
pub const WAVEOUT_MAPPER_STATUS_MAPPED = @as(u32, 1);
pub const WAVEOUT_MAPPER_STATUS_FORMAT = @as(u32, 2);
pub const ACMERR_BASE = @as(u32, 512);
pub const ACMERR_NOTPOSSIBLE = @as(u32, 512);
pub const ACMERR_BUSY = @as(u32, 513);
pub const ACMERR_UNPREPARED = @as(u32, 514);
pub const ACMERR_CANCELED = @as(u32, 515);
pub const ACM_METRIC_COUNT_DRIVERS = @as(u32, 1);
pub const ACM_METRIC_COUNT_CODECS = @as(u32, 2);
pub const ACM_METRIC_COUNT_CONVERTERS = @as(u32, 3);
pub const ACM_METRIC_COUNT_FILTERS = @as(u32, 4);
pub const ACM_METRIC_COUNT_DISABLED = @as(u32, 5);
pub const ACM_METRIC_COUNT_HARDWARE = @as(u32, 6);
pub const ACM_METRIC_COUNT_LOCAL_DRIVERS = @as(u32, 20);
pub const ACM_METRIC_COUNT_LOCAL_CODECS = @as(u32, 21);
pub const ACM_METRIC_COUNT_LOCAL_CONVERTERS = @as(u32, 22);
pub const ACM_METRIC_COUNT_LOCAL_FILTERS = @as(u32, 23);
pub const ACM_METRIC_COUNT_LOCAL_DISABLED = @as(u32, 24);
pub const ACM_METRIC_HARDWARE_WAVE_INPUT = @as(u32, 30);
pub const ACM_METRIC_HARDWARE_WAVE_OUTPUT = @as(u32, 31);
pub const ACM_METRIC_MAX_SIZE_FORMAT = @as(u32, 50);
pub const ACM_METRIC_MAX_SIZE_FILTER = @as(u32, 51);
pub const ACM_METRIC_DRIVER_SUPPORT = @as(u32, 100);
pub const ACM_METRIC_DRIVER_PRIORITY = @as(u32, 101);
pub const ACM_DRIVERENUMF_NOLOCAL = @as(i32, 1073741824);
pub const ACM_DRIVERENUMF_DISABLED = @as(i32, -2147483648);
pub const ACM_DRIVERADDF_NAME = @as(i32, 1);
pub const ACM_DRIVERADDF_FUNCTION = @as(i32, 3);
pub const ACM_DRIVERADDF_NOTIFYHWND = @as(i32, 4);
pub const ACM_DRIVERADDF_TYPEMASK = @as(i32, 7);
pub const ACM_DRIVERADDF_LOCAL = @as(i32, 0);
pub const ACM_DRIVERADDF_GLOBAL = @as(i32, 8);
pub const ACMDM_USER = @as(u32, 16384);
pub const ACMDM_RESERVED_LOW = @as(u32, 24576);
pub const ACMDM_RESERVED_HIGH = @as(u32, 28671);
pub const ACMDM_DRIVER_ABOUT = @as(u32, 24587);
pub const ACM_DRIVERPRIORITYF_ENABLE = @as(i32, 1);
pub const ACM_DRIVERPRIORITYF_DISABLE = @as(i32, 2);
pub const ACM_DRIVERPRIORITYF_ABLEMASK = @as(i32, 3);
pub const ACM_DRIVERPRIORITYF_BEGIN = @as(i32, 65536);
pub const ACM_DRIVERPRIORITYF_END = @as(i32, 131072);
pub const ACM_DRIVERPRIORITYF_DEFERMASK = @as(i32, 196608);
pub const ACMDRIVERDETAILS_SHORTNAME_CHARS = @as(u32, 32);
pub const ACMDRIVERDETAILS_LONGNAME_CHARS = @as(u32, 128);
pub const ACMDRIVERDETAILS_COPYRIGHT_CHARS = @as(u32, 80);
pub const ACMDRIVERDETAILS_LICENSING_CHARS = @as(u32, 128);
pub const ACMDRIVERDETAILS_FEATURES_CHARS = @as(u32, 512);
pub const ACMDRIVERDETAILS_SUPPORTF_CODEC = @as(i32, 1);
pub const ACMDRIVERDETAILS_SUPPORTF_CONVERTER = @as(i32, 2);
pub const ACMDRIVERDETAILS_SUPPORTF_FILTER = @as(i32, 4);
pub const ACMDRIVERDETAILS_SUPPORTF_HARDWARE = @as(i32, 8);
pub const ACMDRIVERDETAILS_SUPPORTF_ASYNC = @as(i32, 16);
pub const ACMDRIVERDETAILS_SUPPORTF_LOCAL = @as(i32, 1073741824);
pub const ACMDRIVERDETAILS_SUPPORTF_DISABLED = @as(i32, -2147483648);
pub const ACMFORMATTAGDETAILS_FORMATTAG_CHARS = @as(u32, 48);
pub const ACM_FORMATTAGDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FORMATTAGDETAILSF_FORMATTAG = @as(i32, 1);
pub const ACM_FORMATTAGDETAILSF_LARGESTSIZE = @as(i32, 2);
pub const ACM_FORMATTAGDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACMFORMATDETAILS_FORMAT_CHARS = @as(u32, 128);
pub const ACM_FORMATDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FORMATDETAILSF_FORMAT = @as(i32, 1);
pub const ACM_FORMATDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACM_FORMATENUMF_WFORMATTAG = @as(i32, 65536);
pub const ACM_FORMATENUMF_NCHANNELS = @as(i32, 131072);
pub const ACM_FORMATENUMF_NSAMPLESPERSEC = @as(i32, 262144);
pub const ACM_FORMATENUMF_WBITSPERSAMPLE = @as(i32, 524288);
pub const ACM_FORMATENUMF_CONVERT = @as(i32, 1048576);
pub const ACM_FORMATENUMF_SUGGEST = @as(i32, 2097152);
pub const ACM_FORMATENUMF_HARDWARE = @as(i32, 4194304);
pub const ACM_FORMATENUMF_INPUT = @as(i32, 8388608);
pub const ACM_FORMATENUMF_OUTPUT = @as(i32, 16777216);
pub const ACM_FORMATSUGGESTF_WFORMATTAG = @as(i32, 65536);
pub const ACM_FORMATSUGGESTF_NCHANNELS = @as(i32, 131072);
pub const ACM_FORMATSUGGESTF_NSAMPLESPERSEC = @as(i32, 262144);
pub const ACM_FORMATSUGGESTF_WBITSPERSAMPLE = @as(i32, 524288);
pub const ACM_FORMATSUGGESTF_TYPEMASK = @as(i32, 16711680);
pub const MM_ACM_FORMATCHOOSE = @as(u32, 32768);
pub const FORMATCHOOSE_MESSAGE = @as(u32, 0);
pub const FORMATCHOOSE_FORMATTAG_VERIFY = @as(u32, 0);
pub const FORMATCHOOSE_FORMAT_VERIFY = @as(u32, 1);
pub const FORMATCHOOSE_CUSTOM_VERIFY = @as(u32, 2);
pub const ACMFORMATCHOOSE_STYLEF_SHOWHELP = @as(i32, 4);
pub const ACMFORMATCHOOSE_STYLEF_ENABLEHOOK = @as(i32, 8);
pub const ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE = @as(i32, 16);
pub const ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = @as(i32, 32);
pub const ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT = @as(i32, 64);
pub const ACMFORMATCHOOSE_STYLEF_CONTEXTHELP = @as(i32, 128);
pub const ACMFILTERTAGDETAILS_FILTERTAG_CHARS = @as(u32, 48);
pub const ACM_FILTERTAGDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FILTERTAGDETAILSF_FILTERTAG = @as(i32, 1);
pub const ACM_FILTERTAGDETAILSF_LARGESTSIZE = @as(i32, 2);
pub const ACM_FILTERTAGDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACMFILTERDETAILS_FILTER_CHARS = @as(u32, 128);
pub const ACM_FILTERDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FILTERDETAILSF_FILTER = @as(i32, 1);
pub const ACM_FILTERDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACM_FILTERENUMF_DWFILTERTAG = @as(i32, 65536);
pub const MM_ACM_FILTERCHOOSE = @as(u32, 32768);
pub const FILTERCHOOSE_MESSAGE = @as(u32, 0);
pub const FILTERCHOOSE_FILTERTAG_VERIFY = @as(u32, 0);
pub const FILTERCHOOSE_FILTER_VERIFY = @as(u32, 1);
pub const FILTERCHOOSE_CUSTOM_VERIFY = @as(u32, 2);
pub const ACMFILTERCHOOSE_STYLEF_SHOWHELP = @as(i32, 4);
pub const ACMFILTERCHOOSE_STYLEF_ENABLEHOOK = @as(i32, 8);
pub const ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE = @as(i32, 16);
pub const ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = @as(i32, 32);
pub const ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT = @as(i32, 64);
pub const ACMFILTERCHOOSE_STYLEF_CONTEXTHELP = @as(i32, 128);
pub const ACMSTREAMHEADER_STATUSF_DONE = @as(i32, 65536);
pub const ACMSTREAMHEADER_STATUSF_PREPARED = @as(i32, 131072);
pub const ACMSTREAMHEADER_STATUSF_INQUEUE = @as(i32, 1048576);
pub const ACM_STREAMOPENF_QUERY = @as(u32, 1);
pub const ACM_STREAMOPENF_ASYNC = @as(u32, 2);
pub const ACM_STREAMOPENF_NONREALTIME = @as(u32, 4);
pub const ACM_STREAMSIZEF_SOURCE = @as(i32, 0);
pub const ACM_STREAMSIZEF_DESTINATION = @as(i32, 1);
pub const ACM_STREAMSIZEF_QUERYMASK = @as(i32, 15);
pub const ACM_STREAMCONVERTF_BLOCKALIGN = @as(u32, 4);
pub const ACM_STREAMCONVERTF_START = @as(u32, 16);
pub const ACM_STREAMCONVERTF_END = @as(u32, 32);
pub const SND_SYNC = @as(u32, 0);
pub const SND_ASYNC = @as(u32, 1);
pub const SND_NODEFAULT = @as(u32, 2);
pub const SND_MEMORY = @as(u32, 4);
pub const SND_LOOP = @as(u32, 8);
pub const SND_NOSTOP = @as(u32, 16);
pub const SND_NOWAIT = @as(i32, 8192);
pub const SND_ALIAS = @as(i32, 65536);
pub const SND_ALIAS_ID = @as(i32, 1114112);
pub const SND_FILENAME = @as(i32, 131072);
pub const SND_RESOURCE = @as(i32, 262148);
pub const SND_PURGE = @as(u32, 64);
pub const SND_APPLICATION = @as(u32, 128);
pub const SND_SENTRY = @as(i32, 524288);
pub const SND_RING = @as(i32, 1048576);
pub const SND_SYSTEM = @as(i32, 2097152);
pub const SND_ALIAS_START = @as(u32, 0);
pub const ACMDM_DRIVER_NOTIFY = @as(u32, 24577);
pub const ACMDM_DRIVER_DETAILS = @as(u32, 24586);
pub const ACMDM_HARDWARE_WAVE_CAPS_INPUT = @as(u32, 24596);
pub const ACMDM_HARDWARE_WAVE_CAPS_OUTPUT = @as(u32, 24597);
pub const ACMDM_FORMATTAG_DETAILS = @as(u32, 24601);
pub const ACMDM_FORMAT_DETAILS = @as(u32, 24602);
pub const ACMDM_FORMAT_SUGGEST = @as(u32, 24603);
pub const ACMDM_FILTERTAG_DETAILS = @as(u32, 24626);
pub const ACMDM_FILTER_DETAILS = @as(u32, 24627);
pub const ACMDM_STREAM_OPEN = @as(u32, 24652);
pub const ACMDM_STREAM_CLOSE = @as(u32, 24653);
pub const ACMDM_STREAM_SIZE = @as(u32, 24654);
pub const ACMDM_STREAM_CONVERT = @as(u32, 24655);
pub const ACMDM_STREAM_RESET = @as(u32, 24656);
pub const ACMDM_STREAM_PREPARE = @as(u32, 24657);
pub const ACMDM_STREAM_UNPREPARE = @as(u32, 24658);
pub const ACMDM_STREAM_UPDATE = @as(u32, 24659);

//--------------------------------------------------------------------------------
// Section: Types (229)
//--------------------------------------------------------------------------------
pub const LPWAVECALLBACK = fn(
    hdrvr: ?HDRVR,
    uMsg: u32,
    dwUser: usize,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPMIDICALLBACK = fn(
    hdrvr: ?HDRVR,
    uMsg: u32,
    dwUser: usize,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIDI_WAVE_OPEN_TYPE = enum(u32) {
    CALLBACK_TYPEMASK = 458752,
    CALLBACK_NULL = 0,
    CALLBACK_WINDOW = 65536,
    CALLBACK_TASK = 131072,
    CALLBACK_FUNCTION = 196608,
    // CALLBACK_THREAD = 131072, this enum value conflicts with CALLBACK_TASK
    CALLBACK_EVENT = 327680,
    WAVE_FORMAT_QUERY = 1,
    WAVE_ALLOWSYNC = 2,
    WAVE_MAPPED = 4,
    WAVE_FORMAT_DIRECT = 8,
    WAVE_FORMAT_DIRECT_QUERY = 9,
    WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = 16,
    MIDI_IO_STATUS = 32,
    _,
    pub fn initFlags(o: struct {
        CALLBACK_TYPEMASK: u1 = 0,
        CALLBACK_NULL: u1 = 0,
        CALLBACK_WINDOW: u1 = 0,
        CALLBACK_TASK: u1 = 0,
        CALLBACK_FUNCTION: u1 = 0,
        CALLBACK_EVENT: u1 = 0,
        WAVE_FORMAT_QUERY: u1 = 0,
        WAVE_ALLOWSYNC: u1 = 0,
        WAVE_MAPPED: u1 = 0,
        WAVE_FORMAT_DIRECT: u1 = 0,
        WAVE_FORMAT_DIRECT_QUERY: u1 = 0,
        WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE: u1 = 0,
        MIDI_IO_STATUS: u1 = 0,
    }) MIDI_WAVE_OPEN_TYPE {
        return @intToEnum(MIDI_WAVE_OPEN_TYPE,
              (if (o.CALLBACK_TYPEMASK == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.CALLBACK_TYPEMASK) else 0)
            | (if (o.CALLBACK_NULL == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.CALLBACK_NULL) else 0)
            | (if (o.CALLBACK_WINDOW == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.CALLBACK_WINDOW) else 0)
            | (if (o.CALLBACK_TASK == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.CALLBACK_TASK) else 0)
            | (if (o.CALLBACK_FUNCTION == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.CALLBACK_FUNCTION) else 0)
            | (if (o.CALLBACK_EVENT == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.CALLBACK_EVENT) else 0)
            | (if (o.WAVE_FORMAT_QUERY == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_QUERY) else 0)
            | (if (o.WAVE_ALLOWSYNC == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.WAVE_ALLOWSYNC) else 0)
            | (if (o.WAVE_MAPPED == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED) else 0)
            | (if (o.WAVE_FORMAT_DIRECT == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT) else 0)
            | (if (o.WAVE_FORMAT_DIRECT_QUERY == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT_QUERY) else 0)
            | (if (o.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE) else 0)
            | (if (o.MIDI_IO_STATUS == 1) @enumToInt(MIDI_WAVE_OPEN_TYPE.MIDI_IO_STATUS) else 0)
        );
    }
};
pub const CALLBACK_TYPEMASK = MIDI_WAVE_OPEN_TYPE.CALLBACK_TYPEMASK;
pub const CALLBACK_NULL = MIDI_WAVE_OPEN_TYPE.CALLBACK_NULL;
pub const CALLBACK_WINDOW = MIDI_WAVE_OPEN_TYPE.CALLBACK_WINDOW;
pub const CALLBACK_TASK = MIDI_WAVE_OPEN_TYPE.CALLBACK_TASK;
pub const CALLBACK_FUNCTION = MIDI_WAVE_OPEN_TYPE.CALLBACK_FUNCTION;
pub const CALLBACK_THREAD = MIDI_WAVE_OPEN_TYPE.CALLBACK_TASK;
pub const CALLBACK_EVENT = MIDI_WAVE_OPEN_TYPE.CALLBACK_EVENT;
pub const WAVE_FORMAT_QUERY = MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_QUERY;
pub const WAVE_ALLOWSYNC = MIDI_WAVE_OPEN_TYPE.WAVE_ALLOWSYNC;
pub const WAVE_MAPPED = MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED;
pub const WAVE_FORMAT_DIRECT = MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT;
pub const WAVE_FORMAT_DIRECT_QUERY = MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT_QUERY;
pub const WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE;
pub const MIDI_IO_STATUS = MIDI_WAVE_OPEN_TYPE.MIDI_IO_STATUS;

pub const MIXERLINE_COMPONENTTYPE = enum(u32) {
    DST_DIGITAL = 1,
    DST_HEADPHONES = 5,
    DST_LINE = 2,
    DST_MONITOR = 3,
    DST_SPEAKERS = 4,
    DST_TELEPHONE = 6,
    DST_UNDEFINED = 0,
    DST_VOICEIN = 8,
    DST_WAVEIN = 7,
    SRC_ANALOG = 4106,
    SRC_AUXILIARY = 4105,
    SRC_COMPACTDISC = 4101,
    SRC_DIGITAL = 4097,
    SRC_LINE = 4098,
    SRC_MICROPHONE = 4099,
    SRC_PCSPEAKER = 4103,
    SRC_SYNTHESIZER = 4100,
    SRC_TELEPHONE = 4102,
    SRC_UNDEFINED = 4096,
    SRC_WAVEOUT = 4104,
};
pub const MIXERLINE_COMPONENTTYPE_DST_DIGITAL = MIXERLINE_COMPONENTTYPE.DST_DIGITAL;
pub const MIXERLINE_COMPONENTTYPE_DST_HEADPHONES = MIXERLINE_COMPONENTTYPE.DST_HEADPHONES;
pub const MIXERLINE_COMPONENTTYPE_DST_LINE = MIXERLINE_COMPONENTTYPE.DST_LINE;
pub const MIXERLINE_COMPONENTTYPE_DST_MONITOR = MIXERLINE_COMPONENTTYPE.DST_MONITOR;
pub const MIXERLINE_COMPONENTTYPE_DST_SPEAKERS = MIXERLINE_COMPONENTTYPE.DST_SPEAKERS;
pub const MIXERLINE_COMPONENTTYPE_DST_TELEPHONE = MIXERLINE_COMPONENTTYPE.DST_TELEPHONE;
pub const MIXERLINE_COMPONENTTYPE_DST_UNDEFINED = MIXERLINE_COMPONENTTYPE.DST_UNDEFINED;
pub const MIXERLINE_COMPONENTTYPE_DST_VOICEIN = MIXERLINE_COMPONENTTYPE.DST_VOICEIN;
pub const MIXERLINE_COMPONENTTYPE_DST_WAVEIN = MIXERLINE_COMPONENTTYPE.DST_WAVEIN;
pub const MIXERLINE_COMPONENTTYPE_SRC_ANALOG = MIXERLINE_COMPONENTTYPE.SRC_ANALOG;
pub const MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY = MIXERLINE_COMPONENTTYPE.SRC_AUXILIARY;
pub const MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC = MIXERLINE_COMPONENTTYPE.SRC_COMPACTDISC;
pub const MIXERLINE_COMPONENTTYPE_SRC_DIGITAL = MIXERLINE_COMPONENTTYPE.SRC_DIGITAL;
pub const MIXERLINE_COMPONENTTYPE_SRC_LINE = MIXERLINE_COMPONENTTYPE.SRC_LINE;
pub const MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE = MIXERLINE_COMPONENTTYPE.SRC_MICROPHONE;
pub const MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER = MIXERLINE_COMPONENTTYPE.SRC_PCSPEAKER;
pub const MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER = MIXERLINE_COMPONENTTYPE.SRC_SYNTHESIZER;
pub const MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE = MIXERLINE_COMPONENTTYPE.SRC_TELEPHONE;
pub const MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED = MIXERLINE_COMPONENTTYPE.SRC_UNDEFINED;
pub const MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT = MIXERLINE_COMPONENTTYPE.SRC_WAVEOUT;

pub const AUDIO_VOLUME_NOTIFICATION_DATA = extern struct {
    guidEventContext: Guid,
    bMuted: BOOL,
    fMasterVolume: f32,
    nChannels: u32,
    afChannelVolumes: [1]f32,
};

pub const HMIDI = *opaque{};

pub const HMIDIIN = *opaque{};

pub const HMIDIOUT = *opaque{};

pub const HMIDISTRM = *opaque{};

pub const HMIXER = *opaque{};

pub const HMIXEROBJ = *opaque{};

pub const HWAVE = *opaque{};

pub const HWAVEOUT = *opaque{};

pub const HWAVEIN = *opaque{};

pub const HACMDRIVERID = *opaque{};

pub const HACMDRIVER = *opaque{};

pub const HACMSTREAM = *opaque{};

pub const HACMOBJ = *opaque{};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMessageFilter_Value = @import("../zig.zig").Guid.initString("00000016-0000-0000-c000-000000000046");
pub const IID_IMessageFilter = &IID_IMessageFilter_Value;
pub const IMessageFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleInComingCall: fn(
            self: *const IMessageFilter,
            dwCallType: u32,
            htaskCaller: ?HTASK,
            dwTickCount: u32,
            lpInterfaceInfo: ?*INTERFACEINFO,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        RetryRejectedCall: fn(
            self: *const IMessageFilter,
            htaskCallee: ?HTASK,
            dwTickCount: u32,
            dwRejectType: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        MessagePending: fn(
            self: *const IMessageFilter,
            htaskCallee: ?HTASK,
            dwTickCount: u32,
            dwPendingType: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageFilter_HandleInComingCall(self: *const T, dwCallType: u32, htaskCaller: ?HTASK, dwTickCount: u32, lpInterfaceInfo: ?*INTERFACEINFO) callconv(.Inline) u32 {
            return @ptrCast(*const IMessageFilter.VTable, self.vtable).HandleInComingCall(@ptrCast(*const IMessageFilter, self), dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageFilter_RetryRejectedCall(self: *const T, htaskCallee: ?HTASK, dwTickCount: u32, dwRejectType: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IMessageFilter.VTable, self.vtable).RetryRejectedCall(@ptrCast(*const IMessageFilter, self), htaskCallee, dwTickCount, dwRejectType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageFilter_MessagePending(self: *const T, htaskCallee: ?HTASK, dwTickCount: u32, dwPendingType: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IMessageFilter.VTable, self.vtable).MessagePending(@ptrCast(*const IMessageFilter, self), htaskCallee, dwTickCount, dwPendingType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WAVEFORMATEXTENSIBLE = packed struct {
    Format: WAVEFORMATEX,
    Samples: packed union {
        wValidBitsPerSample: u16,
        wSamplesPerBlock: u16,
        wReserved: u16,
    },
    dwChannelMask: u32,
    SubFormat: Guid,
};

pub const WAVEFILTER = packed struct {
    cbStruct: u32,
    dwFilterTag: u32,
    fdwFilter: u32,
    dwReserved: [5]u32,
};

pub const VOLUMEWAVEFILTER = packed struct {
    wfltr: WAVEFILTER,
    dwVolume: u32,
};

pub const ECHOWAVEFILTER = packed struct {
    wfltr: WAVEFILTER,
    dwVolume: u32,
    dwDelay: u32,
};

pub const WAVEHDR = packed struct {
    lpData: ?PSTR,
    dwBufferLength: u32,
    dwBytesRecorded: u32,
    dwUser: usize,
    dwFlags: u32,
    dwLoops: u32,
    lpNext: ?*WAVEHDR,
    reserved: usize,
};

pub const WAVEOUTCAPSA = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const WAVEOUTCAPSW = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const WAVEOUTCAPS2A = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEOUTCAPS2W = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEINCAPSA = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
};

pub const WAVEINCAPSW = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
};

pub const WAVEINCAPS2A = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEINCAPS2W = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEFORMAT = packed struct {
    wFormatTag: u16,
    nChannels: u16,
    nSamplesPerSec: u32,
    nAvgBytesPerSec: u32,
    nBlockAlign: u16,
};

pub const PCMWAVEFORMAT = packed struct {
    wf: WAVEFORMAT,
    wBitsPerSample: u16,
};

pub const WAVEFORMATEX = packed struct {
    wFormatTag: u16,
    nChannels: u16,
    nSamplesPerSec: u32,
    nAvgBytesPerSec: u32,
    nBlockAlign: u16,
    wBitsPerSample: u16,
    cbSize: u16,
};

pub const MIDIOUTCAPSA = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
};

pub const MIDIOUTCAPSW = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
};

pub const MIDIOUTCAPS2A = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIOUTCAPS2W = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIINCAPSA = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwSupport: u32,
};

pub const MIDIINCAPSW = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwSupport: u32,
};

pub const MIDIINCAPS2A = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIINCAPS2W = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIHDR = packed struct {
    lpData: ?PSTR,
    dwBufferLength: u32,
    dwBytesRecorded: u32,
    dwUser: usize,
    dwFlags: u32,
    lpNext: ?*MIDIHDR,
    reserved: usize,
    dwOffset: u32,
    dwReserved: [8]usize,
};

pub const MIDIEVENT = packed struct {
    dwDeltaTime: u32,
    dwStreamID: u32,
    dwEvent: u32,
    dwParms: [1]u32,
};

pub const MIDISTRMBUFFVER = packed struct {
    dwVersion: u32,
    dwMid: u32,
    dwOEMVersion: u32,
};

pub const MIDIPROPTIMEDIV = packed struct {
    cbStruct: u32,
    dwTimeDiv: u32,
};

pub const MIDIPROPTEMPO = packed struct {
    cbStruct: u32,
    dwTempo: u32,
};

pub const AUXCAPSA = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const AUXCAPSW = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const AUXCAPS2A = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const AUXCAPS2W = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIXERCAPSA = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    fdwSupport: u32,
    cDestinations: u32,
};

pub const MIXERCAPSW = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    fdwSupport: u32,
    cDestinations: u32,
};

pub const MIXERCAPS2A = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]CHAR,
    fdwSupport: u32,
    cDestinations: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIXERCAPS2W = packed struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    fdwSupport: u32,
    cDestinations: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIXERLINEA = packed struct {
    cbStruct: u32,
    dwDestination: u32,
    dwSource: u32,
    dwLineID: u32,
    fdwLine: u32,
    dwUser: usize,
    dwComponentType: MIXERLINE_COMPONENTTYPE,
    cChannels: u32,
    cConnections: u32,
    cControls: u32,
    szShortName: [16]CHAR,
    szName: [64]CHAR,
    Target: packed struct {
        dwType: u32,
        dwDeviceID: u32,
        wMid: u16,
        wPid: u16,
        vDriverVersion: u32,
        szPname: [32]CHAR,
    },
};

pub const MIXERLINEW = packed struct {
    cbStruct: u32,
    dwDestination: u32,
    dwSource: u32,
    dwLineID: u32,
    fdwLine: u32,
    dwUser: usize,
    dwComponentType: MIXERLINE_COMPONENTTYPE,
    cChannels: u32,
    cConnections: u32,
    cControls: u32,
    szShortName: [16]u16,
    szName: [64]u16,
    Target: packed struct {
        dwType: u32,
        dwDeviceID: u32,
        wMid: u16,
        wPid: u16,
        vDriverVersion: u32,
        szPname: [32]u16,
    },
};

pub const MIXERCONTROLA = packed struct {
    cbStruct: u32,
    dwControlID: u32,
    dwControlType: u32,
    fdwControl: u32,
    cMultipleItems: u32,
    szShortName: [16]CHAR,
    szName: [64]CHAR,
    Bounds: packed union {
        Anonymous1: packed struct {
            lMinimum: i32,
            lMaximum: i32,
        },
        Anonymous2: packed struct {
            dwMinimum: u32,
            dwMaximum: u32,
        },
        dwReserved: [6]u32,
    },
    Metrics: packed union {
        cSteps: u32,
        cbCustomData: u32,
        dwReserved: [6]u32,
    },
};

pub const MIXERCONTROLW = packed struct {
    cbStruct: u32,
    dwControlID: u32,
    dwControlType: u32,
    fdwControl: u32,
    cMultipleItems: u32,
    szShortName: [16]u16,
    szName: [64]u16,
    Bounds: packed union {
        Anonymous1: packed struct {
            lMinimum: i32,
            lMaximum: i32,
        },
        Anonymous2: packed struct {
            dwMinimum: u32,
            dwMaximum: u32,
        },
        dwReserved: [6]u32,
    },
    Metrics: packed union {
        cSteps: u32,
        cbCustomData: u32,
        dwReserved: [6]u32,
    },
};

pub const MIXERLINECONTROLSA = packed struct {
    cbStruct: u32,
    dwLineID: u32,
    Anonymous: packed union {
        dwControlID: u32,
        dwControlType: u32,
    },
    cControls: u32,
    cbmxctrl: u32,
    pamxctrl: ?*MIXERCONTROLA,
};

pub const MIXERLINECONTROLSW = packed struct {
    cbStruct: u32,
    dwLineID: u32,
    Anonymous: packed union {
        dwControlID: u32,
        dwControlType: u32,
    },
    cControls: u32,
    cbmxctrl: u32,
    pamxctrl: ?*MIXERCONTROLW,
};

pub const MIXERCONTROLDETAILS = packed struct {
    cbStruct: u32,
    dwControlID: u32,
    cChannels: u32,
    Anonymous: packed union {
        hwndOwner: ?HWND,
        cMultipleItems: u32,
    },
    cbDetails: u32,
    paDetails: ?*anyopaque,
};

pub const MIXERCONTROLDETAILS_LISTTEXTA = packed struct {
    dwParam1: u32,
    dwParam2: u32,
    szName: [64]CHAR,
};

pub const MIXERCONTROLDETAILS_LISTTEXTW = packed struct {
    dwParam1: u32,
    dwParam2: u32,
    szName: [64]u16,
};

pub const MIXERCONTROLDETAILS_BOOLEAN = packed struct {
    fValue: i32,
};

pub const MIXERCONTROLDETAILS_SIGNED = packed struct {
    lValue: i32,
};

pub const MIXERCONTROLDETAILS_UNSIGNED = packed struct {
    dwValue: u32,
};

pub const AUDCLNT_SHAREMODE = enum(i32) {
    SHARED = 0,
    EXCLUSIVE = 1,
};
pub const AUDCLNT_SHAREMODE_SHARED = AUDCLNT_SHAREMODE.SHARED;
pub const AUDCLNT_SHAREMODE_EXCLUSIVE = AUDCLNT_SHAREMODE.EXCLUSIVE;

pub const AUDIO_STREAM_CATEGORY = enum(i32) {
    Other = 0,
    ForegroundOnlyMedia = 1,
    Communications = 3,
    Alerts = 4,
    SoundEffects = 5,
    GameEffects = 6,
    GameMedia = 7,
    GameChat = 8,
    Speech = 9,
    Movie = 10,
    Media = 11,
    FarFieldSpeech = 12,
    UniformSpeech = 13,
    VoiceTyping = 14,
};
pub const AudioCategory_Other = AUDIO_STREAM_CATEGORY.Other;
pub const AudioCategory_ForegroundOnlyMedia = AUDIO_STREAM_CATEGORY.ForegroundOnlyMedia;
pub const AudioCategory_Communications = AUDIO_STREAM_CATEGORY.Communications;
pub const AudioCategory_Alerts = AUDIO_STREAM_CATEGORY.Alerts;
pub const AudioCategory_SoundEffects = AUDIO_STREAM_CATEGORY.SoundEffects;
pub const AudioCategory_GameEffects = AUDIO_STREAM_CATEGORY.GameEffects;
pub const AudioCategory_GameMedia = AUDIO_STREAM_CATEGORY.GameMedia;
pub const AudioCategory_GameChat = AUDIO_STREAM_CATEGORY.GameChat;
pub const AudioCategory_Speech = AUDIO_STREAM_CATEGORY.Speech;
pub const AudioCategory_Movie = AUDIO_STREAM_CATEGORY.Movie;
pub const AudioCategory_Media = AUDIO_STREAM_CATEGORY.Media;
pub const AudioCategory_FarFieldSpeech = AUDIO_STREAM_CATEGORY.FarFieldSpeech;
pub const AudioCategory_UniformSpeech = AUDIO_STREAM_CATEGORY.UniformSpeech;
pub const AudioCategory_VoiceTyping = AUDIO_STREAM_CATEGORY.VoiceTyping;

pub const AudioSessionState = enum(i32) {
    Inactive = 0,
    Active = 1,
    Expired = 2,
};
pub const AudioSessionStateInactive = AudioSessionState.Inactive;
pub const AudioSessionStateActive = AudioSessionState.Active;
pub const AudioSessionStateExpired = AudioSessionState.Expired;

pub const _AUDCLNT_BUFFERFLAGS = enum(i32) {
    DATA_DISCONTINUITY = 1,
    SILENT = 2,
    TIMESTAMP_ERROR = 4,
};
pub const AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY = _AUDCLNT_BUFFERFLAGS.DATA_DISCONTINUITY;
pub const AUDCLNT_BUFFERFLAGS_SILENT = _AUDCLNT_BUFFERFLAGS.SILENT;
pub const AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR = _AUDCLNT_BUFFERFLAGS.TIMESTAMP_ERROR;

pub const AUDCLNT_STREAMOPTIONS = enum(u32) {
    NONE = 0,
    RAW = 1,
    MATCH_FORMAT = 2,
    AMBISONICS = 4,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        RAW: u1 = 0,
        MATCH_FORMAT: u1 = 0,
        AMBISONICS: u1 = 0,
    }) AUDCLNT_STREAMOPTIONS {
        return @intToEnum(AUDCLNT_STREAMOPTIONS,
              (if (o.NONE == 1) @enumToInt(AUDCLNT_STREAMOPTIONS.NONE) else 0)
            | (if (o.RAW == 1) @enumToInt(AUDCLNT_STREAMOPTIONS.RAW) else 0)
            | (if (o.MATCH_FORMAT == 1) @enumToInt(AUDCLNT_STREAMOPTIONS.MATCH_FORMAT) else 0)
            | (if (o.AMBISONICS == 1) @enumToInt(AUDCLNT_STREAMOPTIONS.AMBISONICS) else 0)
        );
    }
};
pub const AUDCLNT_STREAMOPTIONS_NONE = AUDCLNT_STREAMOPTIONS.NONE;
pub const AUDCLNT_STREAMOPTIONS_RAW = AUDCLNT_STREAMOPTIONS.RAW;
pub const AUDCLNT_STREAMOPTIONS_MATCH_FORMAT = AUDCLNT_STREAMOPTIONS.MATCH_FORMAT;
pub const AUDCLNT_STREAMOPTIONS_AMBISONICS = AUDCLNT_STREAMOPTIONS.AMBISONICS;

pub const AudioClientProperties = extern struct {
    cbSize: u32,
    bIsOffload: BOOL,
    eCategory: AUDIO_STREAM_CATEGORY,
    Options: AUDCLNT_STREAMOPTIONS,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioClient_Value = @import("../zig.zig").Guid.initString("1cb9ad4c-dbfa-4c32-b178-c2f568a703b2");
pub const IID_IAudioClient = &IID_IAudioClient_Value;
pub const IAudioClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IAudioClient,
            ShareMode: AUDCLNT_SHAREMODE,
            StreamFlags: u32,
            hnsBufferDuration: i64,
            hnsPeriodicity: i64,
            pFormat: ?*const WAVEFORMATEX,
            AudioSessionGuid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferSize: fn(
            self: *const IAudioClient,
            pNumBufferFrames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamLatency: fn(
            self: *const IAudioClient,
            phnsLatency: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPadding: fn(
            self: *const IAudioClient,
            pNumPaddingFrames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsFormatSupported: fn(
            self: *const IAudioClient,
            ShareMode: AUDCLNT_SHAREMODE,
            pFormat: ?*const WAVEFORMATEX,
            ppClosestMatch: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMixFormat: fn(
            self: *const IAudioClient,
            ppDeviceFormat: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevicePeriod: fn(
            self: *const IAudioClient,
            phnsDefaultDevicePeriod: ?*i64,
            phnsMinimumDevicePeriod: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: fn(
            self: *const IAudioClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IAudioClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IAudioClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventHandle: fn(
            self: *const IAudioClient,
            eventHandle: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetService: fn(
            self: *const IAudioClient,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_Initialize(self: *const T, ShareMode: AUDCLNT_SHAREMODE, StreamFlags: u32, hnsBufferDuration: i64, hnsPeriodicity: i64, pFormat: ?*const WAVEFORMATEX, AudioSessionGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).Initialize(@ptrCast(*const IAudioClient, self), ShareMode, StreamFlags, hnsBufferDuration, hnsPeriodicity, pFormat, AudioSessionGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_GetBufferSize(self: *const T, pNumBufferFrames: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).GetBufferSize(@ptrCast(*const IAudioClient, self), pNumBufferFrames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_GetStreamLatency(self: *const T, phnsLatency: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).GetStreamLatency(@ptrCast(*const IAudioClient, self), phnsLatency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_GetCurrentPadding(self: *const T, pNumPaddingFrames: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).GetCurrentPadding(@ptrCast(*const IAudioClient, self), pNumPaddingFrames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_IsFormatSupported(self: *const T, ShareMode: AUDCLNT_SHAREMODE, pFormat: ?*const WAVEFORMATEX, ppClosestMatch: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).IsFormatSupported(@ptrCast(*const IAudioClient, self), ShareMode, pFormat, ppClosestMatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_GetMixFormat(self: *const T, ppDeviceFormat: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).GetMixFormat(@ptrCast(*const IAudioClient, self), ppDeviceFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_GetDevicePeriod(self: *const T, phnsDefaultDevicePeriod: ?*i64, phnsMinimumDevicePeriod: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).GetDevicePeriod(@ptrCast(*const IAudioClient, self), phnsDefaultDevicePeriod, phnsMinimumDevicePeriod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_Start(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).Start(@ptrCast(*const IAudioClient, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).Stop(@ptrCast(*const IAudioClient, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).Reset(@ptrCast(*const IAudioClient, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_SetEventHandle(self: *const T, eventHandle: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).SetEventHandle(@ptrCast(*const IAudioClient, self), eventHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient_GetService(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient.VTable, self.vtable).GetService(@ptrCast(*const IAudioClient, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAudioClient2_Value = @import("../zig.zig").Guid.initString("726778cd-f60a-4eda-82de-e47610cd78aa");
pub const IID_IAudioClient2 = &IID_IAudioClient2_Value;
pub const IAudioClient2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioClient.VTable,
        IsOffloadCapable: fn(
            self: *const IAudioClient2,
            Category: AUDIO_STREAM_CATEGORY,
            pbOffloadCapable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClientProperties: fn(
            self: *const IAudioClient2,
            pProperties: ?*const AudioClientProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferSizeLimits: fn(
            self: *const IAudioClient2,
            pFormat: ?*const WAVEFORMATEX,
            bEventDriven: BOOL,
            phnsMinBufferDuration: ?*i64,
            phnsMaxBufferDuration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAudioClient.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient2_IsOffloadCapable(self: *const T, Category: AUDIO_STREAM_CATEGORY, pbOffloadCapable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient2.VTable, self.vtable).IsOffloadCapable(@ptrCast(*const IAudioClient2, self), Category, pbOffloadCapable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient2_SetClientProperties(self: *const T, pProperties: ?*const AudioClientProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient2.VTable, self.vtable).SetClientProperties(@ptrCast(*const IAudioClient2, self), pProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient2_GetBufferSizeLimits(self: *const T, pFormat: ?*const WAVEFORMATEX, bEventDriven: BOOL, phnsMinBufferDuration: ?*i64, phnsMaxBufferDuration: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient2.VTable, self.vtable).GetBufferSizeLimits(@ptrCast(*const IAudioClient2, self), pFormat, bEventDriven, phnsMinBufferDuration, phnsMaxBufferDuration);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AudioClient3ActivationParams = extern struct {
    tracingContextId: Guid,
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAudioClient3_Value = @import("../zig.zig").Guid.initString("7ed4ee07-8e67-4cd4-8c1a-2b7a5987ad42");
pub const IID_IAudioClient3 = &IID_IAudioClient3_Value;
pub const IAudioClient3 = extern struct {
    pub const VTable = extern struct {
        base: IAudioClient2.VTable,
        GetSharedModeEnginePeriod: fn(
            self: *const IAudioClient3,
            pFormat: ?*const WAVEFORMATEX,
            pDefaultPeriodInFrames: ?*u32,
            pFundamentalPeriodInFrames: ?*u32,
            pMinPeriodInFrames: ?*u32,
            pMaxPeriodInFrames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSharedModeEnginePeriod: fn(
            self: *const IAudioClient3,
            ppFormat: ?*?*WAVEFORMATEX,
            pCurrentPeriodInFrames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeSharedAudioStream: fn(
            self: *const IAudioClient3,
            StreamFlags: u32,
            PeriodInFrames: u32,
            pFormat: ?*const WAVEFORMATEX,
            AudioSessionGuid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAudioClient2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient3_GetSharedModeEnginePeriod(self: *const T, pFormat: ?*const WAVEFORMATEX, pDefaultPeriodInFrames: ?*u32, pFundamentalPeriodInFrames: ?*u32, pMinPeriodInFrames: ?*u32, pMaxPeriodInFrames: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient3.VTable, self.vtable).GetSharedModeEnginePeriod(@ptrCast(*const IAudioClient3, self), pFormat, pDefaultPeriodInFrames, pFundamentalPeriodInFrames, pMinPeriodInFrames, pMaxPeriodInFrames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient3_GetCurrentSharedModeEnginePeriod(self: *const T, ppFormat: ?*?*WAVEFORMATEX, pCurrentPeriodInFrames: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient3.VTable, self.vtable).GetCurrentSharedModeEnginePeriod(@ptrCast(*const IAudioClient3, self), ppFormat, pCurrentPeriodInFrames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClient3_InitializeSharedAudioStream(self: *const T, StreamFlags: u32, PeriodInFrames: u32, pFormat: ?*const WAVEFORMATEX, AudioSessionGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClient3.VTable, self.vtable).InitializeSharedAudioStream(@ptrCast(*const IAudioClient3, self), StreamFlags, PeriodInFrames, pFormat, AudioSessionGuid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioRenderClient_Value = @import("../zig.zig").Guid.initString("f294acfc-3146-4483-a7bf-addca7c260e2");
pub const IID_IAudioRenderClient = &IID_IAudioRenderClient_Value;
pub const IAudioRenderClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: fn(
            self: *const IAudioRenderClient,
            NumFramesRequested: u32,
            ppData: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBuffer: fn(
            self: *const IAudioRenderClient,
            NumFramesWritten: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioRenderClient_GetBuffer(self: *const T, NumFramesRequested: u32, ppData: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioRenderClient.VTable, self.vtable).GetBuffer(@ptrCast(*const IAudioRenderClient, self), NumFramesRequested, ppData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioRenderClient_ReleaseBuffer(self: *const T, NumFramesWritten: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioRenderClient.VTable, self.vtable).ReleaseBuffer(@ptrCast(*const IAudioRenderClient, self), NumFramesWritten, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioCaptureClient_Value = @import("../zig.zig").Guid.initString("c8adbd64-e71e-48a0-a4de-185c395cd317");
pub const IID_IAudioCaptureClient = &IID_IAudioCaptureClient_Value;
pub const IAudioCaptureClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: fn(
            self: *const IAudioCaptureClient,
            ppData: ?*?*u8,
            pNumFramesToRead: ?*u32,
            pdwFlags: ?*u32,
            pu64DevicePosition: ?*u64,
            pu64QPCPosition: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBuffer: fn(
            self: *const IAudioCaptureClient,
            NumFramesRead: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextPacketSize: fn(
            self: *const IAudioCaptureClient,
            pNumFramesInNextPacket: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioCaptureClient_GetBuffer(self: *const T, ppData: ?*?*u8, pNumFramesToRead: ?*u32, pdwFlags: ?*u32, pu64DevicePosition: ?*u64, pu64QPCPosition: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioCaptureClient.VTable, self.vtable).GetBuffer(@ptrCast(*const IAudioCaptureClient, self), ppData, pNumFramesToRead, pdwFlags, pu64DevicePosition, pu64QPCPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioCaptureClient_ReleaseBuffer(self: *const T, NumFramesRead: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioCaptureClient.VTable, self.vtable).ReleaseBuffer(@ptrCast(*const IAudioCaptureClient, self), NumFramesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioCaptureClient_GetNextPacketSize(self: *const T, pNumFramesInNextPacket: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioCaptureClient.VTable, self.vtable).GetNextPacketSize(@ptrCast(*const IAudioCaptureClient, self), pNumFramesInNextPacket);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioClock_Value = @import("../zig.zig").Guid.initString("cd63314f-3fba-4a1b-812c-ef96358728e7");
pub const IID_IAudioClock = &IID_IAudioClock_Value;
pub const IAudioClock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrequency: fn(
            self: *const IAudioClock,
            pu64Frequency: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const IAudioClock,
            pu64Position: ?*u64,
            pu64QPCPosition: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharacteristics: fn(
            self: *const IAudioClock,
            pdwCharacteristics: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClock_GetFrequency(self: *const T, pu64Frequency: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClock.VTable, self.vtable).GetFrequency(@ptrCast(*const IAudioClock, self), pu64Frequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClock_GetPosition(self: *const T, pu64Position: ?*u64, pu64QPCPosition: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClock.VTable, self.vtable).GetPosition(@ptrCast(*const IAudioClock, self), pu64Position, pu64QPCPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClock_GetCharacteristics(self: *const T, pdwCharacteristics: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClock.VTable, self.vtable).GetCharacteristics(@ptrCast(*const IAudioClock, self), pdwCharacteristics);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioClock2_Value = @import("../zig.zig").Guid.initString("6f49ff73-6727-49ac-a008-d98cf5e70048");
pub const IID_IAudioClock2 = &IID_IAudioClock2_Value;
pub const IAudioClock2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDevicePosition: fn(
            self: *const IAudioClock2,
            DevicePosition: ?*u64,
            QPCPosition: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClock2_GetDevicePosition(self: *const T, DevicePosition: ?*u64, QPCPosition: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClock2.VTable, self.vtable).GetDevicePosition(@ptrCast(*const IAudioClock2, self), DevicePosition, QPCPosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioClockAdjustment_Value = @import("../zig.zig").Guid.initString("f6e4c0a0-46d9-4fb8-be21-57a3ef2b626c");
pub const IID_IAudioClockAdjustment = &IID_IAudioClockAdjustment_Value;
pub const IAudioClockAdjustment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSampleRate: fn(
            self: *const IAudioClockAdjustment,
            flSampleRate: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClockAdjustment_SetSampleRate(self: *const T, flSampleRate: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClockAdjustment.VTable, self.vtable).SetSampleRate(@ptrCast(*const IAudioClockAdjustment, self), flSampleRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISimpleAudioVolume_Value = @import("../zig.zig").Guid.initString("87ce5498-68d6-44e5-9215-6da47ef883d8");
pub const IID_ISimpleAudioVolume = &IID_ISimpleAudioVolume_Value;
pub const ISimpleAudioVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMasterVolume: fn(
            self: *const ISimpleAudioVolume,
            fLevel: f32,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMasterVolume: fn(
            self: *const ISimpleAudioVolume,
            pfLevel: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMute: fn(
            self: *const ISimpleAudioVolume,
            bMute: BOOL,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: fn(
            self: *const ISimpleAudioVolume,
            pbMute: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleAudioVolume_SetMasterVolume(self: *const T, fLevel: f32, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleAudioVolume.VTable, self.vtable).SetMasterVolume(@ptrCast(*const ISimpleAudioVolume, self), fLevel, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleAudioVolume_GetMasterVolume(self: *const T, pfLevel: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleAudioVolume.VTable, self.vtable).GetMasterVolume(@ptrCast(*const ISimpleAudioVolume, self), pfLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleAudioVolume_SetMute(self: *const T, bMute: BOOL, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleAudioVolume.VTable, self.vtable).SetMute(@ptrCast(*const ISimpleAudioVolume, self), bMute, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleAudioVolume_GetMute(self: *const T, pbMute: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleAudioVolume.VTable, self.vtable).GetMute(@ptrCast(*const ISimpleAudioVolume, self), pbMute);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AUDIO_DUCKING_OPTIONS = enum(u32) {
    EFAULT = 0,
    O_NOT_DUCK_OTHER_STREAMS = 1,
    _,
    pub fn initFlags(o: struct {
        EFAULT: u1 = 0,
        O_NOT_DUCK_OTHER_STREAMS: u1 = 0,
    }) AUDIO_DUCKING_OPTIONS {
        return @intToEnum(AUDIO_DUCKING_OPTIONS,
              (if (o.EFAULT == 1) @enumToInt(AUDIO_DUCKING_OPTIONS.EFAULT) else 0)
            | (if (o.O_NOT_DUCK_OTHER_STREAMS == 1) @enumToInt(AUDIO_DUCKING_OPTIONS.O_NOT_DUCK_OTHER_STREAMS) else 0)
        );
    }
};
pub const AUDIO_DUCKING_OPTIONS_DEFAULT = AUDIO_DUCKING_OPTIONS.EFAULT;
pub const AUDIO_DUCKING_OPTIONS_DO_NOT_DUCK_OTHER_STREAMS = AUDIO_DUCKING_OPTIONS.O_NOT_DUCK_OTHER_STREAMS;

const IID_IAudioClientDuckingControl_Value = @import("../zig.zig").Guid.initString("c789d381-a28c-4168-b28f-d3a837924dc3");
pub const IID_IAudioClientDuckingControl = &IID_IAudioClientDuckingControl_Value;
pub const IAudioClientDuckingControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDuckingOptionsForCurrentStream: fn(
            self: *const IAudioClientDuckingControl,
            options: AUDIO_DUCKING_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioClientDuckingControl_SetDuckingOptionsForCurrentStream(self: *const T, options: AUDIO_DUCKING_OPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioClientDuckingControl.VTable, self.vtable).SetDuckingOptionsForCurrentStream(@ptrCast(*const IAudioClientDuckingControl, self), options);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AUDIO_EFFECT_STATE = enum(i32) {
    FF = 0,
    N = 1,
};
pub const AUDIO_EFFECT_STATE_OFF = AUDIO_EFFECT_STATE.FF;
pub const AUDIO_EFFECT_STATE_ON = AUDIO_EFFECT_STATE.N;

pub const AUDIO_EFFECT = extern struct {
    id: Guid,
    canSetState: BOOL,
    state: AUDIO_EFFECT_STATE,
};

const IID_IAudioEffectsChangedNotificationClient_Value = @import("../zig.zig").Guid.initString("a5ded44f-3c5d-4b2b-bd1e-5dc1ee20bbf6");
pub const IID_IAudioEffectsChangedNotificationClient = &IID_IAudioEffectsChangedNotificationClient_Value;
pub const IAudioEffectsChangedNotificationClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAudioEffectsChanged: fn(
            self: *const IAudioEffectsChangedNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEffectsChangedNotificationClient_OnAudioEffectsChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEffectsChangedNotificationClient.VTable, self.vtable).OnAudioEffectsChanged(@ptrCast(*const IAudioEffectsChangedNotificationClient, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioEffectsManager_Value = @import("../zig.zig").Guid.initString("4460b3ae-4b44-4527-8676-7548a8acd260");
pub const IID_IAudioEffectsManager = &IID_IAudioEffectsManager_Value;
pub const IAudioEffectsManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterAudioEffectsChangedNotificationCallback: fn(
            self: *const IAudioEffectsManager,
            client: ?*IAudioEffectsChangedNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterAudioEffectsChangedNotificationCallback: fn(
            self: *const IAudioEffectsManager,
            client: ?*IAudioEffectsChangedNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioEffects: fn(
            self: *const IAudioEffectsManager,
            effects: ?*?*AUDIO_EFFECT,
            numEffects: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAudioEffectState: fn(
            self: *const IAudioEffectsManager,
            effectId: Guid,
            state: AUDIO_EFFECT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEffectsManager_RegisterAudioEffectsChangedNotificationCallback(self: *const T, client: ?*IAudioEffectsChangedNotificationClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEffectsManager.VTable, self.vtable).RegisterAudioEffectsChangedNotificationCallback(@ptrCast(*const IAudioEffectsManager, self), client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEffectsManager_UnregisterAudioEffectsChangedNotificationCallback(self: *const T, client: ?*IAudioEffectsChangedNotificationClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEffectsManager.VTable, self.vtable).UnregisterAudioEffectsChangedNotificationCallback(@ptrCast(*const IAudioEffectsManager, self), client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEffectsManager_GetAudioEffects(self: *const T, effects: ?*?*AUDIO_EFFECT, numEffects: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEffectsManager.VTable, self.vtable).GetAudioEffects(@ptrCast(*const IAudioEffectsManager, self), effects, numEffects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioEffectsManager_SetAudioEffectState(self: *const T, effectId: Guid, state: AUDIO_EFFECT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioEffectsManager.VTable, self.vtable).SetAudioEffectState(@ptrCast(*const IAudioEffectsManager, self), effectId, state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioStreamVolume_Value = @import("../zig.zig").Guid.initString("93014887-242d-4068-8a15-cf5e93b90fe3");
pub const IID_IAudioStreamVolume = &IID_IAudioStreamVolume_Value;
pub const IAudioStreamVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: fn(
            self: *const IAudioStreamVolume,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolume: fn(
            self: *const IAudioStreamVolume,
            dwIndex: u32,
            fLevel: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolume: fn(
            self: *const IAudioStreamVolume,
            dwIndex: u32,
            pfLevel: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllVolumes: fn(
            self: *const IAudioStreamVolume,
            dwCount: u32,
            pfVolumes: [*]const f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllVolumes: fn(
            self: *const IAudioStreamVolume,
            dwCount: u32,
            pfVolumes: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStreamVolume_GetChannelCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioStreamVolume.VTable, self.vtable).GetChannelCount(@ptrCast(*const IAudioStreamVolume, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStreamVolume_SetChannelVolume(self: *const T, dwIndex: u32, fLevel: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioStreamVolume.VTable, self.vtable).SetChannelVolume(@ptrCast(*const IAudioStreamVolume, self), dwIndex, fLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStreamVolume_GetChannelVolume(self: *const T, dwIndex: u32, pfLevel: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioStreamVolume.VTable, self.vtable).GetChannelVolume(@ptrCast(*const IAudioStreamVolume, self), dwIndex, pfLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStreamVolume_SetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]const f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioStreamVolume.VTable, self.vtable).SetAllVolumes(@ptrCast(*const IAudioStreamVolume, self), dwCount, pfVolumes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStreamVolume_GetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioStreamVolume.VTable, self.vtable).GetAllVolumes(@ptrCast(*const IAudioStreamVolume, self), dwCount, pfVolumes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMBISONICS_TYPE = enum(i32) {
    D = 0,
};
pub const AMBISONICS_TYPE_FULL3D = AMBISONICS_TYPE.D;

pub const AMBISONICS_CHANNEL_ORDERING = enum(i32) {
    N = 0,
};
pub const AMBISONICS_CHANNEL_ORDERING_ACN = AMBISONICS_CHANNEL_ORDERING.N;

pub const AMBISONICS_NORMALIZATION = enum(i32) {
    SN3D = 0,
    N3D = 1,
};
pub const AMBISONICS_NORMALIZATION_SN3D = AMBISONICS_NORMALIZATION.SN3D;
pub const AMBISONICS_NORMALIZATION_N3D = AMBISONICS_NORMALIZATION.N3D;

pub const AMBISONICS_PARAMS = extern struct {
    u32Size: u32,
    u32Version: u32,
    u32Type: AMBISONICS_TYPE,
    u32ChannelOrdering: AMBISONICS_CHANNEL_ORDERING,
    u32Normalization: AMBISONICS_NORMALIZATION,
    u32Order: u32,
    u32NumChannels: u32,
    pu32ChannelMap: ?*u32,
};

const IID_IAudioAmbisonicsControl_Value = @import("../zig.zig").Guid.initString("28724c91-df35-4856-9f76-d6a26413f3df");
pub const IID_IAudioAmbisonicsControl = &IID_IAudioAmbisonicsControl_Value;
pub const IAudioAmbisonicsControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetData: fn(
            self: *const IAudioAmbisonicsControl,
            pAmbisonicsParams: [*]const AMBISONICS_PARAMS,
            cbAmbisonicsParams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeadTracking: fn(
            self: *const IAudioAmbisonicsControl,
            bEnableHeadTracking: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeadTracking: fn(
            self: *const IAudioAmbisonicsControl,
            pbEnableHeadTracking: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRotation: fn(
            self: *const IAudioAmbisonicsControl,
            X: f32,
            Y: f32,
            Z: f32,
            W: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioAmbisonicsControl_SetData(self: *const T, pAmbisonicsParams: [*]const AMBISONICS_PARAMS, cbAmbisonicsParams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioAmbisonicsControl.VTable, self.vtable).SetData(@ptrCast(*const IAudioAmbisonicsControl, self), pAmbisonicsParams, cbAmbisonicsParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioAmbisonicsControl_SetHeadTracking(self: *const T, bEnableHeadTracking: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioAmbisonicsControl.VTable, self.vtable).SetHeadTracking(@ptrCast(*const IAudioAmbisonicsControl, self), bEnableHeadTracking);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioAmbisonicsControl_GetHeadTracking(self: *const T, pbEnableHeadTracking: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioAmbisonicsControl.VTable, self.vtable).GetHeadTracking(@ptrCast(*const IAudioAmbisonicsControl, self), pbEnableHeadTracking);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioAmbisonicsControl_SetRotation(self: *const T, X: f32, Y: f32, Z: f32, W: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioAmbisonicsControl.VTable, self.vtable).SetRotation(@ptrCast(*const IAudioAmbisonicsControl, self), X, Y, Z, W);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IChannelAudioVolume_Value = @import("../zig.zig").Guid.initString("1c158861-b533-4b30-b1cf-e853e51c59b8");
pub const IID_IChannelAudioVolume = &IID_IChannelAudioVolume_Value;
pub const IChannelAudioVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: fn(
            self: *const IChannelAudioVolume,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolume: fn(
            self: *const IChannelAudioVolume,
            dwIndex: u32,
            fLevel: f32,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolume: fn(
            self: *const IChannelAudioVolume,
            dwIndex: u32,
            pfLevel: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllVolumes: fn(
            self: *const IChannelAudioVolume,
            dwCount: u32,
            pfVolumes: [*]const f32,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllVolumes: fn(
            self: *const IChannelAudioVolume,
            dwCount: u32,
            pfVolumes: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelAudioVolume_GetChannelCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChannelAudioVolume.VTable, self.vtable).GetChannelCount(@ptrCast(*const IChannelAudioVolume, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelAudioVolume_SetChannelVolume(self: *const T, dwIndex: u32, fLevel: f32, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChannelAudioVolume.VTable, self.vtable).SetChannelVolume(@ptrCast(*const IChannelAudioVolume, self), dwIndex, fLevel, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelAudioVolume_GetChannelVolume(self: *const T, dwIndex: u32, pfLevel: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChannelAudioVolume.VTable, self.vtable).GetChannelVolume(@ptrCast(*const IChannelAudioVolume, self), dwIndex, pfLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelAudioVolume_SetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]const f32, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChannelAudioVolume.VTable, self.vtable).SetAllVolumes(@ptrCast(*const IChannelAudioVolume, self), dwCount, pfVolumes, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelAudioVolume_GetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChannelAudioVolume.VTable, self.vtable).GetAllVolumes(@ptrCast(*const IChannelAudioVolume, self), dwCount, pfVolumes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AudioObjectType = enum(u32) {
    None = 0,
    Dynamic = 1,
    FrontLeft = 2,
    FrontRight = 4,
    FrontCenter = 8,
    LowFrequency = 16,
    SideLeft = 32,
    SideRight = 64,
    BackLeft = 128,
    BackRight = 256,
    TopFrontLeft = 512,
    TopFrontRight = 1024,
    TopBackLeft = 2048,
    TopBackRight = 4096,
    BottomFrontLeft = 8192,
    BottomFrontRight = 16384,
    BottomBackLeft = 32768,
    BottomBackRight = 65536,
    BackCenter = 131072,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        Dynamic: u1 = 0,
        FrontLeft: u1 = 0,
        FrontRight: u1 = 0,
        FrontCenter: u1 = 0,
        LowFrequency: u1 = 0,
        SideLeft: u1 = 0,
        SideRight: u1 = 0,
        BackLeft: u1 = 0,
        BackRight: u1 = 0,
        TopFrontLeft: u1 = 0,
        TopFrontRight: u1 = 0,
        TopBackLeft: u1 = 0,
        TopBackRight: u1 = 0,
        BottomFrontLeft: u1 = 0,
        BottomFrontRight: u1 = 0,
        BottomBackLeft: u1 = 0,
        BottomBackRight: u1 = 0,
        BackCenter: u1 = 0,
    }) AudioObjectType {
        return @intToEnum(AudioObjectType,
              (if (o.None == 1) @enumToInt(AudioObjectType.None) else 0)
            | (if (o.Dynamic == 1) @enumToInt(AudioObjectType.Dynamic) else 0)
            | (if (o.FrontLeft == 1) @enumToInt(AudioObjectType.FrontLeft) else 0)
            | (if (o.FrontRight == 1) @enumToInt(AudioObjectType.FrontRight) else 0)
            | (if (o.FrontCenter == 1) @enumToInt(AudioObjectType.FrontCenter) else 0)
            | (if (o.LowFrequency == 1) @enumToInt(AudioObjectType.LowFrequency) else 0)
            | (if (o.SideLeft == 1) @enumToInt(AudioObjectType.SideLeft) else 0)
            | (if (o.SideRight == 1) @enumToInt(AudioObjectType.SideRight) else 0)
            | (if (o.BackLeft == 1) @enumToInt(AudioObjectType.BackLeft) else 0)
            | (if (o.BackRight == 1) @enumToInt(AudioObjectType.BackRight) else 0)
            | (if (o.TopFrontLeft == 1) @enumToInt(AudioObjectType.TopFrontLeft) else 0)
            | (if (o.TopFrontRight == 1) @enumToInt(AudioObjectType.TopFrontRight) else 0)
            | (if (o.TopBackLeft == 1) @enumToInt(AudioObjectType.TopBackLeft) else 0)
            | (if (o.TopBackRight == 1) @enumToInt(AudioObjectType.TopBackRight) else 0)
            | (if (o.BottomFrontLeft == 1) @enumToInt(AudioObjectType.BottomFrontLeft) else 0)
            | (if (o.BottomFrontRight == 1) @enumToInt(AudioObjectType.BottomFrontRight) else 0)
            | (if (o.BottomBackLeft == 1) @enumToInt(AudioObjectType.BottomBackLeft) else 0)
            | (if (o.BottomBackRight == 1) @enumToInt(AudioObjectType.BottomBackRight) else 0)
            | (if (o.BackCenter == 1) @enumToInt(AudioObjectType.BackCenter) else 0)
        );
    }
};
pub const AudioObjectType_None = AudioObjectType.None;
pub const AudioObjectType_Dynamic = AudioObjectType.Dynamic;
pub const AudioObjectType_FrontLeft = AudioObjectType.FrontLeft;
pub const AudioObjectType_FrontRight = AudioObjectType.FrontRight;
pub const AudioObjectType_FrontCenter = AudioObjectType.FrontCenter;
pub const AudioObjectType_LowFrequency = AudioObjectType.LowFrequency;
pub const AudioObjectType_SideLeft = AudioObjectType.SideLeft;
pub const AudioObjectType_SideRight = AudioObjectType.SideRight;
pub const AudioObjectType_BackLeft = AudioObjectType.BackLeft;
pub const AudioObjectType_BackRight = AudioObjectType.BackRight;
pub const AudioObjectType_TopFrontLeft = AudioObjectType.TopFrontLeft;
pub const AudioObjectType_TopFrontRight = AudioObjectType.TopFrontRight;
pub const AudioObjectType_TopBackLeft = AudioObjectType.TopBackLeft;
pub const AudioObjectType_TopBackRight = AudioObjectType.TopBackRight;
pub const AudioObjectType_BottomFrontLeft = AudioObjectType.BottomFrontLeft;
pub const AudioObjectType_BottomFrontRight = AudioObjectType.BottomFrontRight;
pub const AudioObjectType_BottomBackLeft = AudioObjectType.BottomBackLeft;
pub const AudioObjectType_BottomBackRight = AudioObjectType.BottomBackRight;
pub const AudioObjectType_BackCenter = AudioObjectType.BackCenter;

pub const SPATIAL_AUDIO_STREAM_OPTIONS = enum(u32) {
    NONE = 0,
    OFFLOAD = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        OFFLOAD: u1 = 0,
    }) SPATIAL_AUDIO_STREAM_OPTIONS {
        return @intToEnum(SPATIAL_AUDIO_STREAM_OPTIONS,
              (if (o.NONE == 1) @enumToInt(SPATIAL_AUDIO_STREAM_OPTIONS.NONE) else 0)
            | (if (o.OFFLOAD == 1) @enumToInt(SPATIAL_AUDIO_STREAM_OPTIONS.OFFLOAD) else 0)
        );
    }
};
pub const SPATIAL_AUDIO_STREAM_OPTIONS_NONE = SPATIAL_AUDIO_STREAM_OPTIONS.NONE;
pub const SPATIAL_AUDIO_STREAM_OPTIONS_OFFLOAD = SPATIAL_AUDIO_STREAM_OPTIONS.OFFLOAD;

pub const SpatialAudioObjectRenderStreamActivationParams = packed struct {
    ObjectFormat: ?*const WAVEFORMATEX,
    StaticObjectTypeMask: AudioObjectType,
    MinDynamicObjectCount: u32,
    MaxDynamicObjectCount: u32,
    Category: AUDIO_STREAM_CATEGORY,
    EventHandle: ?HANDLE,
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify,
};

pub const SpatialAudioObjectRenderStreamActivationParams2 = packed struct {
    ObjectFormat: ?*const WAVEFORMATEX,
    StaticObjectTypeMask: AudioObjectType,
    MinDynamicObjectCount: u32,
    MaxDynamicObjectCount: u32,
    Category: AUDIO_STREAM_CATEGORY,
    EventHandle: ?HANDLE,
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify,
    Options: SPATIAL_AUDIO_STREAM_OPTIONS,
};

const IID_IAudioFormatEnumerator_Value = @import("../zig.zig").Guid.initString("dcdaa858-895a-4a22-a5eb-67bda506096d");
pub const IID_IAudioFormatEnumerator = &IID_IAudioFormatEnumerator_Value;
pub const IAudioFormatEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IAudioFormatEnumerator,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormat: fn(
            self: *const IAudioFormatEnumerator,
            index: u32,
            format: ?*?*WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioFormatEnumerator_GetCount(self: *const T, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioFormatEnumerator.VTable, self.vtable).GetCount(@ptrCast(*const IAudioFormatEnumerator, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioFormatEnumerator_GetFormat(self: *const T, index: u32, format: ?*?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioFormatEnumerator.VTable, self.vtable).GetFormat(@ptrCast(*const IAudioFormatEnumerator, self), index, format);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectBase_Value = @import("../zig.zig").Guid.initString("cce0b8f2-8d4d-4efb-a8cf-3d6ecf1c30e0");
pub const IID_ISpatialAudioObjectBase = &IID_ISpatialAudioObjectBase_Value;
pub const ISpatialAudioObjectBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: fn(
            self: *const ISpatialAudioObjectBase,
            buffer: ?*?*u8,
            bufferLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEndOfStream: fn(
            self: *const ISpatialAudioObjectBase,
            frameCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsActive: fn(
            self: *const ISpatialAudioObjectBase,
            isActive: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioObjectType: fn(
            self: *const ISpatialAudioObjectBase,
            audioObjectType: ?*AudioObjectType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectBase_GetBuffer(self: *const T, buffer: ?*?*u8, bufferLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectBase.VTable, self.vtable).GetBuffer(@ptrCast(*const ISpatialAudioObjectBase, self), buffer, bufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectBase_SetEndOfStream(self: *const T, frameCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectBase.VTable, self.vtable).SetEndOfStream(@ptrCast(*const ISpatialAudioObjectBase, self), frameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectBase_IsActive(self: *const T, isActive: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectBase.VTable, self.vtable).IsActive(@ptrCast(*const ISpatialAudioObjectBase, self), isActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectBase_GetAudioObjectType(self: *const T, audioObjectType: ?*AudioObjectType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectBase.VTable, self.vtable).GetAudioObjectType(@ptrCast(*const ISpatialAudioObjectBase, self), audioObjectType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObject_Value = @import("../zig.zig").Guid.initString("dde28967-521b-46e5-8f00-bd6f2bc8ab1d");
pub const IID_ISpatialAudioObject = &IID_ISpatialAudioObject_Value;
pub const ISpatialAudioObject = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        SetPosition: fn(
            self: *const ISpatialAudioObject,
            x: f32,
            y: f32,
            z: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVolume: fn(
            self: *const ISpatialAudioObject,
            volume: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObject_SetPosition(self: *const T, x: f32, y: f32, z: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObject.VTable, self.vtable).SetPosition(@ptrCast(*const ISpatialAudioObject, self), x, y, z);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObject_SetVolume(self: *const T, volume: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObject.VTable, self.vtable).SetVolume(@ptrCast(*const ISpatialAudioObject, self), volume);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamBase_Value = @import("../zig.zig").Guid.initString("feaaf403-c1d8-450d-aa05-e0ccee7502a8");
pub const IID_ISpatialAudioObjectRenderStreamBase = &IID_ISpatialAudioObjectRenderStreamBase_Value;
pub const ISpatialAudioObjectRenderStreamBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableDynamicObjectCount: fn(
            self: *const ISpatialAudioObjectRenderStreamBase,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetService: fn(
            self: *const ISpatialAudioObjectRenderStreamBase,
            riid: ?*const Guid,
            service: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: fn(
            self: *const ISpatialAudioObjectRenderStreamBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const ISpatialAudioObjectRenderStreamBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ISpatialAudioObjectRenderStreamBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdatingAudioObjects: fn(
            self: *const ISpatialAudioObjectRenderStreamBase,
            availableDynamicObjectCount: ?*u32,
            frameCountPerBuffer: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUpdatingAudioObjects: fn(
            self: *const ISpatialAudioObjectRenderStreamBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamBase_GetAvailableDynamicObjectCount(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamBase.VTable, self.vtable).GetAvailableDynamicObjectCount(@ptrCast(*const ISpatialAudioObjectRenderStreamBase, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamBase_GetService(self: *const T, riid: ?*const Guid, service: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamBase.VTable, self.vtable).GetService(@ptrCast(*const ISpatialAudioObjectRenderStreamBase, self), riid, service);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamBase_Start(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamBase.VTable, self.vtable).Start(@ptrCast(*const ISpatialAudioObjectRenderStreamBase, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamBase_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamBase.VTable, self.vtable).Stop(@ptrCast(*const ISpatialAudioObjectRenderStreamBase, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamBase_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamBase.VTable, self.vtable).Reset(@ptrCast(*const ISpatialAudioObjectRenderStreamBase, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamBase_BeginUpdatingAudioObjects(self: *const T, availableDynamicObjectCount: ?*u32, frameCountPerBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamBase.VTable, self.vtable).BeginUpdatingAudioObjects(@ptrCast(*const ISpatialAudioObjectRenderStreamBase, self), availableDynamicObjectCount, frameCountPerBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamBase_EndUpdatingAudioObjects(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamBase.VTable, self.vtable).EndUpdatingAudioObjects(@ptrCast(*const ISpatialAudioObjectRenderStreamBase, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStream_Value = @import("../zig.zig").Guid.initString("bab5f473-b423-477b-85f5-b5a332a04153");
pub const IID_ISpatialAudioObjectRenderStream = &IID_ISpatialAudioObjectRenderStream_Value;
pub const ISpatialAudioObjectRenderStream = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectRenderStreamBase.VTable,
        ActivateSpatialAudioObject: fn(
            self: *const ISpatialAudioObjectRenderStream,
            type: AudioObjectType,
            audioObject: ?*?*ISpatialAudioObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpatialAudioObjectRenderStreamBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStream_ActivateSpatialAudioObject(self: *const T, type_: AudioObjectType, audioObject: ?*?*ISpatialAudioObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStream.VTable, self.vtable).ActivateSpatialAudioObject(@ptrCast(*const ISpatialAudioObjectRenderStream, self), type_, audioObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamNotify_Value = @import("../zig.zig").Guid.initString("dddf83e6-68d7-4c70-883f-a1836afb4a50");
pub const IID_ISpatialAudioObjectRenderStreamNotify = &IID_ISpatialAudioObjectRenderStreamNotify_Value;
pub const ISpatialAudioObjectRenderStreamNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAvailableDynamicObjectCountChange: fn(
            self: *const ISpatialAudioObjectRenderStreamNotify,
            sender: ?*ISpatialAudioObjectRenderStreamBase,
            hnsComplianceDeadlineTime: i64,
            availableDynamicObjectCountChange: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamNotify_OnAvailableDynamicObjectCountChange(self: *const T, sender: ?*ISpatialAudioObjectRenderStreamBase, hnsComplianceDeadlineTime: i64, availableDynamicObjectCountChange: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamNotify.VTable, self.vtable).OnAvailableDynamicObjectCountChange(@ptrCast(*const ISpatialAudioObjectRenderStreamNotify, self), sender, hnsComplianceDeadlineTime, availableDynamicObjectCountChange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioClient_Value = @import("../zig.zig").Guid.initString("bbf8e066-aaaa-49be-9a4d-fd2a858ea27f");
pub const IID_ISpatialAudioClient = &IID_ISpatialAudioClient_Value;
pub const ISpatialAudioClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStaticObjectPosition: fn(
            self: *const ISpatialAudioClient,
            type: AudioObjectType,
            x: ?*f32,
            y: ?*f32,
            z: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNativeStaticObjectTypeMask: fn(
            self: *const ISpatialAudioClient,
            mask: ?*AudioObjectType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxDynamicObjectCount: fn(
            self: *const ISpatialAudioClient,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedAudioObjectFormatEnumerator: fn(
            self: *const ISpatialAudioClient,
            enumerator: ?*?*IAudioFormatEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxFrameCount: fn(
            self: *const ISpatialAudioClient,
            objectFormat: ?*const WAVEFORMATEX,
            frameCountPerBuffer: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAudioObjectFormatSupported: fn(
            self: *const ISpatialAudioClient,
            objectFormat: ?*const WAVEFORMATEX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSpatialAudioStreamAvailable: fn(
            self: *const ISpatialAudioClient,
            streamUuid: ?*const Guid,
            auxiliaryInfo: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioStream: fn(
            self: *const ISpatialAudioClient,
            activationParams: ?*const PROPVARIANT,
            riid: ?*const Guid,
            stream: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient_GetStaticObjectPosition(self: *const T, type_: AudioObjectType, x: ?*f32, y: ?*f32, z: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient.VTable, self.vtable).GetStaticObjectPosition(@ptrCast(*const ISpatialAudioClient, self), type_, x, y, z);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient_GetNativeStaticObjectTypeMask(self: *const T, mask: ?*AudioObjectType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient.VTable, self.vtable).GetNativeStaticObjectTypeMask(@ptrCast(*const ISpatialAudioClient, self), mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient_GetMaxDynamicObjectCount(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient.VTable, self.vtable).GetMaxDynamicObjectCount(@ptrCast(*const ISpatialAudioClient, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient_GetSupportedAudioObjectFormatEnumerator(self: *const T, enumerator: ?*?*IAudioFormatEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient.VTable, self.vtable).GetSupportedAudioObjectFormatEnumerator(@ptrCast(*const ISpatialAudioClient, self), enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient_GetMaxFrameCount(self: *const T, objectFormat: ?*const WAVEFORMATEX, frameCountPerBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient.VTable, self.vtable).GetMaxFrameCount(@ptrCast(*const ISpatialAudioClient, self), objectFormat, frameCountPerBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient_IsAudioObjectFormatSupported(self: *const T, objectFormat: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient.VTable, self.vtable).IsAudioObjectFormatSupported(@ptrCast(*const ISpatialAudioClient, self), objectFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient_IsSpatialAudioStreamAvailable(self: *const T, streamUuid: ?*const Guid, auxiliaryInfo: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient.VTable, self.vtable).IsSpatialAudioStreamAvailable(@ptrCast(*const ISpatialAudioClient, self), streamUuid, auxiliaryInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient_ActivateSpatialAudioStream(self: *const T, activationParams: ?*const PROPVARIANT, riid: ?*const Guid, stream: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient.VTable, self.vtable).ActivateSpatialAudioStream(@ptrCast(*const ISpatialAudioClient, self), activationParams, riid, stream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpatialAudioClient2_Value = @import("../zig.zig").Guid.initString("caabe452-a66a-4bee-a93e-e320463f6a53");
pub const IID_ISpatialAudioClient2 = &IID_ISpatialAudioClient2_Value;
pub const ISpatialAudioClient2 = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioClient.VTable,
        IsOffloadCapable: fn(
            self: *const ISpatialAudioClient2,
            category: AUDIO_STREAM_CATEGORY,
            isOffloadCapable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxFrameCountForCategory: fn(
            self: *const ISpatialAudioClient2,
            category: AUDIO_STREAM_CATEGORY,
            offloadEnabled: BOOL,
            objectFormat: ?*const WAVEFORMATEX,
            frameCountPerBuffer: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpatialAudioClient.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient2_IsOffloadCapable(self: *const T, category: AUDIO_STREAM_CATEGORY, isOffloadCapable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient2.VTable, self.vtable).IsOffloadCapable(@ptrCast(*const ISpatialAudioClient2, self), category, isOffloadCapable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioClient2_GetMaxFrameCountForCategory(self: *const T, category: AUDIO_STREAM_CATEGORY, offloadEnabled: BOOL, objectFormat: ?*const WAVEFORMATEX, frameCountPerBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioClient2.VTable, self.vtable).GetMaxFrameCountForCategory(@ptrCast(*const ISpatialAudioClient2, self), category, offloadEnabled, objectFormat, frameCountPerBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SpatialAudioClientActivationParams = extern struct {
    tracingContextId: Guid,
    appId: Guid,
    majorVersion: i32,
    minorVersion1: i32,
    minorVersion2: i32,
    minorVersion3: i32,
};

pub const SpatialAudioHrtfDirectivityType = enum(i32) {
    OmniDirectional = 0,
    Cardioid = 1,
    Cone = 2,
};
pub const SpatialAudioHrtfDirectivity_OmniDirectional = SpatialAudioHrtfDirectivityType.OmniDirectional;
pub const SpatialAudioHrtfDirectivity_Cardioid = SpatialAudioHrtfDirectivityType.Cardioid;
pub const SpatialAudioHrtfDirectivity_Cone = SpatialAudioHrtfDirectivityType.Cone;

pub const SpatialAudioHrtfEnvironmentType = enum(i32) {
    Small = 0,
    Medium = 1,
    Large = 2,
    Outdoors = 3,
    Average = 4,
};
pub const SpatialAudioHrtfEnvironment_Small = SpatialAudioHrtfEnvironmentType.Small;
pub const SpatialAudioHrtfEnvironment_Medium = SpatialAudioHrtfEnvironmentType.Medium;
pub const SpatialAudioHrtfEnvironment_Large = SpatialAudioHrtfEnvironmentType.Large;
pub const SpatialAudioHrtfEnvironment_Outdoors = SpatialAudioHrtfEnvironmentType.Outdoors;
pub const SpatialAudioHrtfEnvironment_Average = SpatialAudioHrtfEnvironmentType.Average;

pub const SpatialAudioHrtfDistanceDecayType = enum(i32) {
    NaturalDecay = 0,
    CustomDecay = 1,
};
pub const SpatialAudioHrtfDistanceDecay_NaturalDecay = SpatialAudioHrtfDistanceDecayType.NaturalDecay;
pub const SpatialAudioHrtfDistanceDecay_CustomDecay = SpatialAudioHrtfDistanceDecayType.CustomDecay;

pub const SpatialAudioHrtfDirectivity = packed struct {
    Type: SpatialAudioHrtfDirectivityType,
    Scaling: f32,
};

pub const SpatialAudioHrtfDirectivityCardioid = packed struct {
    directivity: SpatialAudioHrtfDirectivity,
    Order: f32,
};

pub const SpatialAudioHrtfDirectivityCone = packed struct {
    directivity: SpatialAudioHrtfDirectivity,
    InnerAngle: f32,
    OuterAngle: f32,
};

pub const SpatialAudioHrtfDirectivityUnion = extern union {
    Cone: SpatialAudioHrtfDirectivityCone,
    Cardiod: SpatialAudioHrtfDirectivityCardioid,
    Omni: SpatialAudioHrtfDirectivity,
};

pub const SpatialAudioHrtfDistanceDecay = packed struct {
    Type: SpatialAudioHrtfDistanceDecayType,
    MaxGain: f32,
    MinGain: f32,
    UnityGainDistance: f32,
    CutoffDistance: f32,
};

pub const SpatialAudioHrtfActivationParams = packed struct {
    ObjectFormat: ?*const WAVEFORMATEX,
    StaticObjectTypeMask: AudioObjectType,
    MinDynamicObjectCount: u32,
    MaxDynamicObjectCount: u32,
    Category: AUDIO_STREAM_CATEGORY,
    EventHandle: ?HANDLE,
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify,
    DistanceDecay: ?*SpatialAudioHrtfDistanceDecay,
    Directivity: ?*SpatialAudioHrtfDirectivityUnion,
    Environment: ?*SpatialAudioHrtfEnvironmentType,
    Orientation: ?*f32,
};

pub const SpatialAudioHrtfActivationParams2 = packed struct {
    ObjectFormat: ?*const WAVEFORMATEX,
    StaticObjectTypeMask: AudioObjectType,
    MinDynamicObjectCount: u32,
    MaxDynamicObjectCount: u32,
    Category: AUDIO_STREAM_CATEGORY,
    EventHandle: ?HANDLE,
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify,
    DistanceDecay: ?*SpatialAudioHrtfDistanceDecay,
    Directivity: ?*SpatialAudioHrtfDirectivityUnion,
    Environment: ?*SpatialAudioHrtfEnvironmentType,
    Orientation: ?*f32,
    Options: SPATIAL_AUDIO_STREAM_OPTIONS,
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectForHrtf_Value = @import("../zig.zig").Guid.initString("d7436ade-1978-4e14-aba0-555bd8eb83b4");
pub const IID_ISpatialAudioObjectForHrtf = &IID_ISpatialAudioObjectForHrtf_Value;
pub const ISpatialAudioObjectForHrtf = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        SetPosition: fn(
            self: *const ISpatialAudioObjectForHrtf,
            x: f32,
            y: f32,
            z: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGain: fn(
            self: *const ISpatialAudioObjectForHrtf,
            gain: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOrientation: fn(
            self: *const ISpatialAudioObjectForHrtf,
            orientation: ?*const ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnvironment: fn(
            self: *const ISpatialAudioObjectForHrtf,
            environment: SpatialAudioHrtfEnvironmentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDistanceDecay: fn(
            self: *const ISpatialAudioObjectForHrtf,
            distanceDecay: ?*SpatialAudioHrtfDistanceDecay,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectivity: fn(
            self: *const ISpatialAudioObjectForHrtf,
            directivity: ?*SpatialAudioHrtfDirectivityUnion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectForHrtf_SetPosition(self: *const T, x: f32, y: f32, z: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectForHrtf.VTable, self.vtable).SetPosition(@ptrCast(*const ISpatialAudioObjectForHrtf, self), x, y, z);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectForHrtf_SetGain(self: *const T, gain: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectForHrtf.VTable, self.vtable).SetGain(@ptrCast(*const ISpatialAudioObjectForHrtf, self), gain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectForHrtf_SetOrientation(self: *const T, orientation: ?*const ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectForHrtf.VTable, self.vtable).SetOrientation(@ptrCast(*const ISpatialAudioObjectForHrtf, self), orientation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectForHrtf_SetEnvironment(self: *const T, environment: SpatialAudioHrtfEnvironmentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectForHrtf.VTable, self.vtable).SetEnvironment(@ptrCast(*const ISpatialAudioObjectForHrtf, self), environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectForHrtf_SetDistanceDecay(self: *const T, distanceDecay: ?*SpatialAudioHrtfDistanceDecay) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectForHrtf.VTable, self.vtable).SetDistanceDecay(@ptrCast(*const ISpatialAudioObjectForHrtf, self), distanceDecay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectForHrtf_SetDirectivity(self: *const T, directivity: ?*SpatialAudioHrtfDirectivityUnion) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectForHrtf.VTable, self.vtable).SetDirectivity(@ptrCast(*const ISpatialAudioObjectForHrtf, self), directivity);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamForHrtf_Value = @import("../zig.zig").Guid.initString("e08deef9-5363-406e-9fdc-080ee247bbe0");
pub const IID_ISpatialAudioObjectRenderStreamForHrtf = &IID_ISpatialAudioObjectRenderStreamForHrtf_Value;
pub const ISpatialAudioObjectRenderStreamForHrtf = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectRenderStreamBase.VTable,
        ActivateSpatialAudioObjectForHrtf: fn(
            self: *const ISpatialAudioObjectRenderStreamForHrtf,
            type: AudioObjectType,
            audioObject: ?*?*ISpatialAudioObjectForHrtf,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpatialAudioObjectRenderStreamBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamForHrtf_ActivateSpatialAudioObjectForHrtf(self: *const T, type_: AudioObjectType, audioObject: ?*?*ISpatialAudioObjectForHrtf) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamForHrtf.VTable, self.vtable).ActivateSpatialAudioObjectForHrtf(@ptrCast(*const ISpatialAudioObjectRenderStreamForHrtf, self), type_, audioObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MMDeviceEnumerator_Value = @import("../zig.zig").Guid.initString("bcde0395-e52f-467c-8e3d-c4579291692e");
pub const CLSID_MMDeviceEnumerator = &CLSID_MMDeviceEnumerator_Value;

pub const DIRECTX_AUDIO_ACTIVATION_PARAMS = extern struct {
    cbDirectXAudioActivationParams: u32,
    guidAudioSession: Guid,
    dwAudioStreamFlags: u32,
};

pub const EDataFlow = enum(i32) {
    eRender = 0,
    eCapture = 1,
    eAll = 2,
    EDataFlow_enum_count = 3,
};
pub const eRender = EDataFlow.eRender;
pub const eCapture = EDataFlow.eCapture;
pub const eAll = EDataFlow.eAll;
pub const EDataFlow_enum_count = EDataFlow.EDataFlow_enum_count;

pub const ERole = enum(i32) {
    eConsole = 0,
    eMultimedia = 1,
    eCommunications = 2,
    ERole_enum_count = 3,
};
pub const eConsole = ERole.eConsole;
pub const eMultimedia = ERole.eMultimedia;
pub const eCommunications = ERole.eCommunications;
pub const ERole_enum_count = ERole.ERole_enum_count;

pub const EndpointFormFactor = enum(i32) {
    RemoteNetworkDevice = 0,
    Speakers = 1,
    LineLevel = 2,
    Headphones = 3,
    Microphone = 4,
    Headset = 5,
    Handset = 6,
    UnknownDigitalPassthrough = 7,
    SPDIF = 8,
    DigitalAudioDisplayDevice = 9,
    UnknownFormFactor = 10,
    EndpointFormFactor_enum_count = 11,
};
pub const RemoteNetworkDevice = EndpointFormFactor.RemoteNetworkDevice;
pub const Speakers = EndpointFormFactor.Speakers;
pub const LineLevel = EndpointFormFactor.LineLevel;
pub const Headphones = EndpointFormFactor.Headphones;
pub const Microphone = EndpointFormFactor.Microphone;
pub const Headset = EndpointFormFactor.Headset;
pub const Handset = EndpointFormFactor.Handset;
pub const UnknownDigitalPassthrough = EndpointFormFactor.UnknownDigitalPassthrough;
pub const SPDIF = EndpointFormFactor.SPDIF;
pub const DigitalAudioDisplayDevice = EndpointFormFactor.DigitalAudioDisplayDevice;
pub const UnknownFormFactor = EndpointFormFactor.UnknownFormFactor;
pub const EndpointFormFactor_enum_count = EndpointFormFactor.EndpointFormFactor_enum_count;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMNotificationClient_Value = @import("../zig.zig").Guid.initString("7991eec9-7e89-4d85-8390-6c703cec60c0");
pub const IID_IMMNotificationClient = &IID_IMMNotificationClient_Value;
pub const IMMNotificationClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDeviceStateChanged: fn(
            self: *const IMMNotificationClient,
            pwstrDeviceId: ?[*:0]const u16,
            dwNewState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDeviceAdded: fn(
            self: *const IMMNotificationClient,
            pwstrDeviceId: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDeviceRemoved: fn(
            self: *const IMMNotificationClient,
            pwstrDeviceId: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDefaultDeviceChanged: fn(
            self: *const IMMNotificationClient,
            flow: EDataFlow,
            role: ERole,
            pwstrDefaultDeviceId: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPropertyValueChanged: fn(
            self: *const IMMNotificationClient,
            pwstrDeviceId: ?[*:0]const u16,
            key: PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMNotificationClient_OnDeviceStateChanged(self: *const T, pwstrDeviceId: ?[*:0]const u16, dwNewState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMNotificationClient.VTable, self.vtable).OnDeviceStateChanged(@ptrCast(*const IMMNotificationClient, self), pwstrDeviceId, dwNewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMNotificationClient_OnDeviceAdded(self: *const T, pwstrDeviceId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMNotificationClient.VTable, self.vtable).OnDeviceAdded(@ptrCast(*const IMMNotificationClient, self), pwstrDeviceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMNotificationClient_OnDeviceRemoved(self: *const T, pwstrDeviceId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMNotificationClient.VTable, self.vtable).OnDeviceRemoved(@ptrCast(*const IMMNotificationClient, self), pwstrDeviceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMNotificationClient_OnDefaultDeviceChanged(self: *const T, flow: EDataFlow, role: ERole, pwstrDefaultDeviceId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMNotificationClient.VTable, self.vtable).OnDefaultDeviceChanged(@ptrCast(*const IMMNotificationClient, self), flow, role, pwstrDefaultDeviceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMNotificationClient_OnPropertyValueChanged(self: *const T, pwstrDeviceId: ?[*:0]const u16, key: PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMNotificationClient.VTable, self.vtable).OnPropertyValueChanged(@ptrCast(*const IMMNotificationClient, self), pwstrDeviceId, key);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMDevice_Value = @import("../zig.zig").Guid.initString("d666063f-1587-4e43-81f1-b948e807363f");
pub const IID_IMMDevice = &IID_IMMDevice_Value;
pub const IMMDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: fn(
            self: *const IMMDevice,
            iid: ?*const Guid,
            dwClsCtx: u32,
            pActivationParams: ?*PROPVARIANT,
            ppInterface: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenPropertyStore: fn(
            self: *const IMMDevice,
            stgmAccess: u32,
            ppProperties: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetId: fn(
            self: *const IMMDevice,
            ppstrId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IMMDevice,
            pdwState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDevice_Activate(self: *const T, iid: ?*const Guid, dwClsCtx: u32, pActivationParams: ?*PROPVARIANT, ppInterface: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDevice.VTable, self.vtable).Activate(@ptrCast(*const IMMDevice, self), iid, dwClsCtx, pActivationParams, ppInterface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDevice_OpenPropertyStore(self: *const T, stgmAccess: u32, ppProperties: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDevice.VTable, self.vtable).OpenPropertyStore(@ptrCast(*const IMMDevice, self), stgmAccess, ppProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDevice_GetId(self: *const T, ppstrId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDevice.VTable, self.vtable).GetId(@ptrCast(*const IMMDevice, self), ppstrId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDevice_GetState(self: *const T, pdwState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDevice.VTable, self.vtable).GetState(@ptrCast(*const IMMDevice, self), pdwState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMDeviceCollection_Value = @import("../zig.zig").Guid.initString("0bd7a1be-7a1a-44db-8397-cc5392387b5e");
pub const IID_IMMDeviceCollection = &IID_IMMDeviceCollection_Value;
pub const IMMDeviceCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IMMDeviceCollection,
            pcDevices: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IMMDeviceCollection,
            nDevice: u32,
            ppDevice: ?*?*IMMDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDeviceCollection_GetCount(self: *const T, pcDevices: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDeviceCollection.VTable, self.vtable).GetCount(@ptrCast(*const IMMDeviceCollection, self), pcDevices);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDeviceCollection_Item(self: *const T, nDevice: u32, ppDevice: ?*?*IMMDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDeviceCollection.VTable, self.vtable).Item(@ptrCast(*const IMMDeviceCollection, self), nDevice, ppDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMEndpoint_Value = @import("../zig.zig").Guid.initString("1be09788-6894-4089-8586-9a2a6c265ac5");
pub const IID_IMMEndpoint = &IID_IMMEndpoint_Value;
pub const IMMEndpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataFlow: fn(
            self: *const IMMEndpoint,
            pDataFlow: ?*EDataFlow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMEndpoint_GetDataFlow(self: *const T, pDataFlow: ?*EDataFlow) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMEndpoint.VTable, self.vtable).GetDataFlow(@ptrCast(*const IMMEndpoint, self), pDataFlow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMDeviceEnumerator_Value = @import("../zig.zig").Guid.initString("a95664d2-9614-4f35-a746-de8db63617e6");
pub const IID_IMMDeviceEnumerator = &IID_IMMDeviceEnumerator_Value;
pub const IMMDeviceEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumAudioEndpoints: fn(
            self: *const IMMDeviceEnumerator,
            dataFlow: EDataFlow,
            dwStateMask: u32,
            ppDevices: ?*?*IMMDeviceCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultAudioEndpoint: fn(
            self: *const IMMDeviceEnumerator,
            dataFlow: EDataFlow,
            role: ERole,
            ppEndpoint: ?*?*IMMDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevice: fn(
            self: *const IMMDeviceEnumerator,
            pwstrId: ?[*:0]const u16,
            ppDevice: ?*?*IMMDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterEndpointNotificationCallback: fn(
            self: *const IMMDeviceEnumerator,
            pClient: ?*IMMNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterEndpointNotificationCallback: fn(
            self: *const IMMDeviceEnumerator,
            pClient: ?*IMMNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDeviceEnumerator_EnumAudioEndpoints(self: *const T, dataFlow: EDataFlow, dwStateMask: u32, ppDevices: ?*?*IMMDeviceCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDeviceEnumerator.VTable, self.vtable).EnumAudioEndpoints(@ptrCast(*const IMMDeviceEnumerator, self), dataFlow, dwStateMask, ppDevices);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDeviceEnumerator_GetDefaultAudioEndpoint(self: *const T, dataFlow: EDataFlow, role: ERole, ppEndpoint: ?*?*IMMDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDeviceEnumerator.VTable, self.vtable).GetDefaultAudioEndpoint(@ptrCast(*const IMMDeviceEnumerator, self), dataFlow, role, ppEndpoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDeviceEnumerator_GetDevice(self: *const T, pwstrId: ?[*:0]const u16, ppDevice: ?*?*IMMDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDeviceEnumerator.VTable, self.vtable).GetDevice(@ptrCast(*const IMMDeviceEnumerator, self), pwstrId, ppDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDeviceEnumerator_RegisterEndpointNotificationCallback(self: *const T, pClient: ?*IMMNotificationClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDeviceEnumerator.VTable, self.vtable).RegisterEndpointNotificationCallback(@ptrCast(*const IMMDeviceEnumerator, self), pClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(self: *const T, pClient: ?*IMMNotificationClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDeviceEnumerator.VTable, self.vtable).UnregisterEndpointNotificationCallback(@ptrCast(*const IMMDeviceEnumerator, self), pClient);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMMDeviceActivator_Value = @import("../zig.zig").Guid.initString("3b0d0ea4-d0a9-4b0e-935b-09516746fac0");
pub const IID_IMMDeviceActivator = &IID_IMMDeviceActivator_Value;
pub const IMMDeviceActivator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: fn(
            self: *const IMMDeviceActivator,
            iid: ?*const Guid,
            pDevice: ?*IMMDevice,
            pActivationParams: ?*PROPVARIANT,
            ppInterface: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMDeviceActivator_Activate(self: *const T, iid: ?*const Guid, pDevice: ?*IMMDevice, pActivationParams: ?*PROPVARIANT, ppInterface: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMDeviceActivator.VTable, self.vtable).Activate(@ptrCast(*const IMMDeviceActivator, self), iid, pDevice, pActivationParams, ppInterface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IActivateAudioInterfaceCompletionHandler_Value = @import("../zig.zig").Guid.initString("41d949ab-9862-444a-80f6-c261334da5eb");
pub const IID_IActivateAudioInterfaceCompletionHandler = &IID_IActivateAudioInterfaceCompletionHandler_Value;
pub const IActivateAudioInterfaceCompletionHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateCompleted: fn(
            self: *const IActivateAudioInterfaceCompletionHandler,
            activateOperation: ?*IActivateAudioInterfaceAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActivateAudioInterfaceCompletionHandler_ActivateCompleted(self: *const T, activateOperation: ?*IActivateAudioInterfaceAsyncOperation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActivateAudioInterfaceCompletionHandler.VTable, self.vtable).ActivateCompleted(@ptrCast(*const IActivateAudioInterfaceCompletionHandler, self), activateOperation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IActivateAudioInterfaceAsyncOperation_Value = @import("../zig.zig").Guid.initString("72a22d78-cde4-431d-b8cc-843a71199b6d");
pub const IID_IActivateAudioInterfaceAsyncOperation = &IID_IActivateAudioInterfaceAsyncOperation_Value;
pub const IActivateAudioInterfaceAsyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActivateResult: fn(
            self: *const IActivateAudioInterfaceAsyncOperation,
            activateResult: ?*HRESULT,
            activatedInterface: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActivateAudioInterfaceAsyncOperation_GetActivateResult(self: *const T, activateResult: ?*HRESULT, activatedInterface: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActivateAudioInterfaceAsyncOperation.VTable, self.vtable).GetActivateResult(@ptrCast(*const IActivateAudioInterfaceAsyncOperation, self), activateResult, activatedInterface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AudioExtensionParams = extern struct {
    AddPageParam: LPARAM,
    pEndpoint: ?*IMMDevice,
    pPnpInterface: ?*IMMDevice,
    pPnpDevnode: ?*IMMDevice,
};

pub const __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002 = enum(i32) {
    DEFAULT = 0,
    USER = 1,
    VOLATILE = 2,
    ENUM_COUNT = 3,
};
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_DEFAULT = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.DEFAULT;
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_USER = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.USER;
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_VOLATILE = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.VOLATILE;
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_ENUM_COUNT = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.ENUM_COUNT;

const IID_IAudioSystemEffectsPropertyChangeNotificationClient_Value = @import("../zig.zig").Guid.initString("20049d40-56d5-400e-a2ef-385599feed49");
pub const IID_IAudioSystemEffectsPropertyChangeNotificationClient = &IID_IAudioSystemEffectsPropertyChangeNotificationClient_Value;
pub const IAudioSystemEffectsPropertyChangeNotificationClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPropertyChanged: fn(
            self: *const IAudioSystemEffectsPropertyChangeNotificationClient,
            type: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002,
            key: PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsPropertyChangeNotificationClient_OnPropertyChanged(self: *const T, type_: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002, key: PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsPropertyChangeNotificationClient.VTable, self.vtable).OnPropertyChanged(@ptrCast(*const IAudioSystemEffectsPropertyChangeNotificationClient, self), type_, key);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSystemEffectsPropertyStore_Value = @import("../zig.zig").Guid.initString("302ae7f9-d7e0-43e4-971b-1f8293613d2a");
pub const IID_IAudioSystemEffectsPropertyStore = &IID_IAudioSystemEffectsPropertyStore_Value;
pub const IAudioSystemEffectsPropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenDefaultPropertyStore: fn(
            self: *const IAudioSystemEffectsPropertyStore,
            stgmAccess: u32,
            propStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenUserPropertyStore: fn(
            self: *const IAudioSystemEffectsPropertyStore,
            stgmAccess: u32,
            propStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenVolatilePropertyStore: fn(
            self: *const IAudioSystemEffectsPropertyStore,
            stgmAccess: u32,
            propStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetUserPropertyStore: fn(
            self: *const IAudioSystemEffectsPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetVolatilePropertyStore: fn(
            self: *const IAudioSystemEffectsPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterPropertyChangeNotification: fn(
            self: *const IAudioSystemEffectsPropertyStore,
            callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterPropertyChangeNotification: fn(
            self: *const IAudioSystemEffectsPropertyStore,
            callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsPropertyStore_OpenDefaultPropertyStore(self: *const T, stgmAccess: u32, propStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsPropertyStore.VTable, self.vtable).OpenDefaultPropertyStore(@ptrCast(*const IAudioSystemEffectsPropertyStore, self), stgmAccess, propStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsPropertyStore_OpenUserPropertyStore(self: *const T, stgmAccess: u32, propStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsPropertyStore.VTable, self.vtable).OpenUserPropertyStore(@ptrCast(*const IAudioSystemEffectsPropertyStore, self), stgmAccess, propStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsPropertyStore_OpenVolatilePropertyStore(self: *const T, stgmAccess: u32, propStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsPropertyStore.VTable, self.vtable).OpenVolatilePropertyStore(@ptrCast(*const IAudioSystemEffectsPropertyStore, self), stgmAccess, propStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsPropertyStore_ResetUserPropertyStore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsPropertyStore.VTable, self.vtable).ResetUserPropertyStore(@ptrCast(*const IAudioSystemEffectsPropertyStore, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsPropertyStore_ResetVolatilePropertyStore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsPropertyStore.VTable, self.vtable).ResetVolatilePropertyStore(@ptrCast(*const IAudioSystemEffectsPropertyStore, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsPropertyStore_RegisterPropertyChangeNotification(self: *const T, callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsPropertyStore.VTable, self.vtable).RegisterPropertyChangeNotification(@ptrCast(*const IAudioSystemEffectsPropertyStore, self), callback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSystemEffectsPropertyStore_UnregisterPropertyChangeNotification(self: *const T, callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSystemEffectsPropertyStore.VTable, self.vtable).UnregisterPropertyChangeNotification(@ptrCast(*const IAudioSystemEffectsPropertyStore, self), callback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DeviceTopology_Value = @import("../zig.zig").Guid.initString("1df639d0-5ec1-47aa-9379-828dc1aa8c59");
pub const CLSID_DeviceTopology = &CLSID_DeviceTopology_Value;

pub const DataFlow = enum(i32) {
    In = 0,
    Out = 1,
};
pub const In = DataFlow.In;
pub const Out = DataFlow.Out;

pub const PartType = enum(i32) {
    Connector = 0,
    Subunit = 1,
};
pub const Connector = PartType.Connector;
pub const Subunit = PartType.Subunit;

pub const ConnectorType = enum(i32) {
    Unknown_Connector = 0,
    Physical_Internal = 1,
    Physical_External = 2,
    Software_IO = 3,
    Software_Fixed = 4,
    Network = 5,
};
// NOTE: not creating aliases because this enum is 'Scoped'

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPerChannelDbLevel_Value = @import("../zig.zig").Guid.initString("c2f8e001-f205-4bc9-99bc-c13b1e048ccb");
pub const IID_IPerChannelDbLevel = &IID_IPerChannelDbLevel_Value;
pub const IPerChannelDbLevel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: fn(
            self: *const IPerChannelDbLevel,
            pcChannels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLevelRange: fn(
            self: *const IPerChannelDbLevel,
            nChannel: u32,
            pfMinLevelDB: ?*f32,
            pfMaxLevelDB: ?*f32,
            pfStepping: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLevel: fn(
            self: *const IPerChannelDbLevel,
            nChannel: u32,
            pfLevelDB: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLevel: fn(
            self: *const IPerChannelDbLevel,
            nChannel: u32,
            fLevelDB: f32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLevelUniform: fn(
            self: *const IPerChannelDbLevel,
            fLevelDB: f32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLevelAllChannels: fn(
            self: *const IPerChannelDbLevel,
            aLevelsDB: [*]f32,
            cChannels: u32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerChannelDbLevel_GetChannelCount(self: *const T, pcChannels: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerChannelDbLevel.VTable, self.vtable).GetChannelCount(@ptrCast(*const IPerChannelDbLevel, self), pcChannels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerChannelDbLevel_GetLevelRange(self: *const T, nChannel: u32, pfMinLevelDB: ?*f32, pfMaxLevelDB: ?*f32, pfStepping: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerChannelDbLevel.VTable, self.vtable).GetLevelRange(@ptrCast(*const IPerChannelDbLevel, self), nChannel, pfMinLevelDB, pfMaxLevelDB, pfStepping);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerChannelDbLevel_GetLevel(self: *const T, nChannel: u32, pfLevelDB: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerChannelDbLevel.VTable, self.vtable).GetLevel(@ptrCast(*const IPerChannelDbLevel, self), nChannel, pfLevelDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerChannelDbLevel_SetLevel(self: *const T, nChannel: u32, fLevelDB: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerChannelDbLevel.VTable, self.vtable).SetLevel(@ptrCast(*const IPerChannelDbLevel, self), nChannel, fLevelDB, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerChannelDbLevel_SetLevelUniform(self: *const T, fLevelDB: f32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerChannelDbLevel.VTable, self.vtable).SetLevelUniform(@ptrCast(*const IPerChannelDbLevel, self), fLevelDB, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerChannelDbLevel_SetLevelAllChannels(self: *const T, aLevelsDB: [*]f32, cChannels: u32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerChannelDbLevel.VTable, self.vtable).SetLevelAllChannels(@ptrCast(*const IPerChannelDbLevel, self), aLevelsDB, cChannels, pguidEventContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioVolumeLevel_Value = @import("../zig.zig").Guid.initString("7fb7b48f-531d-44a2-bcb3-5ad5a134b3dc");
pub const IID_IAudioVolumeLevel = &IID_IAudioVolumeLevel_Value;
pub const IAudioVolumeLevel = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioChannelConfig_Value = @import("../zig.zig").Guid.initString("bb11c46f-ec28-493c-b88a-5db88062ce98");
pub const IID_IAudioChannelConfig = &IID_IAudioChannelConfig_Value;
pub const IAudioChannelConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetChannelConfig: fn(
            self: *const IAudioChannelConfig,
            dwConfig: u32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelConfig: fn(
            self: *const IAudioChannelConfig,
            pdwConfig: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioChannelConfig_SetChannelConfig(self: *const T, dwConfig: u32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioChannelConfig.VTable, self.vtable).SetChannelConfig(@ptrCast(*const IAudioChannelConfig, self), dwConfig, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioChannelConfig_GetChannelConfig(self: *const T, pdwConfig: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioChannelConfig.VTable, self.vtable).GetChannelConfig(@ptrCast(*const IAudioChannelConfig, self), pdwConfig);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioLoudness_Value = @import("../zig.zig").Guid.initString("7d8b1437-dd53-4350-9c1b-1ee2890bd938");
pub const IID_IAudioLoudness = &IID_IAudioLoudness_Value;
pub const IAudioLoudness = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEnabled: fn(
            self: *const IAudioLoudness,
            pbEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnabled: fn(
            self: *const IAudioLoudness,
            bEnable: BOOL,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioLoudness_GetEnabled(self: *const T, pbEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioLoudness.VTable, self.vtable).GetEnabled(@ptrCast(*const IAudioLoudness, self), pbEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioLoudness_SetEnabled(self: *const T, bEnable: BOOL, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioLoudness.VTable, self.vtable).SetEnabled(@ptrCast(*const IAudioLoudness, self), bEnable, pguidEventContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioInputSelector_Value = @import("../zig.zig").Guid.initString("4f03dc02-5e6e-4653-8f72-a030c123d598");
pub const IID_IAudioInputSelector = &IID_IAudioInputSelector_Value;
pub const IAudioInputSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: fn(
            self: *const IAudioInputSelector,
            pnIdSelected: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: fn(
            self: *const IAudioInputSelector,
            nIdSelect: u32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioInputSelector_GetSelection(self: *const T, pnIdSelected: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioInputSelector.VTable, self.vtable).GetSelection(@ptrCast(*const IAudioInputSelector, self), pnIdSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioInputSelector_SetSelection(self: *const T, nIdSelect: u32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioInputSelector.VTable, self.vtable).SetSelection(@ptrCast(*const IAudioInputSelector, self), nIdSelect, pguidEventContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioOutputSelector_Value = @import("../zig.zig").Guid.initString("bb515f69-94a7-429e-8b9c-271b3f11a3ab");
pub const IID_IAudioOutputSelector = &IID_IAudioOutputSelector_Value;
pub const IAudioOutputSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: fn(
            self: *const IAudioOutputSelector,
            pnIdSelected: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelection: fn(
            self: *const IAudioOutputSelector,
            nIdSelect: u32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioOutputSelector_GetSelection(self: *const T, pnIdSelected: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioOutputSelector.VTable, self.vtable).GetSelection(@ptrCast(*const IAudioOutputSelector, self), pnIdSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioOutputSelector_SetSelection(self: *const T, nIdSelect: u32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioOutputSelector.VTable, self.vtable).SetSelection(@ptrCast(*const IAudioOutputSelector, self), nIdSelect, pguidEventContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioMute_Value = @import("../zig.zig").Guid.initString("df45aeea-b74a-4b6b-afad-2366b6aa012e");
pub const IID_IAudioMute = &IID_IAudioMute_Value;
pub const IAudioMute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMute: fn(
            self: *const IAudioMute,
            bMuted: BOOL,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: fn(
            self: *const IAudioMute,
            pbMuted: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMute_SetMute(self: *const T, bMuted: BOOL, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMute.VTable, self.vtable).SetMute(@ptrCast(*const IAudioMute, self), bMuted, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMute_GetMute(self: *const T, pbMuted: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioMute.VTable, self.vtable).GetMute(@ptrCast(*const IAudioMute, self), pbMuted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioBass_Value = @import("../zig.zig").Guid.initString("a2b1a1d9-4db3-425d-a2b2-bd335cb3e2e5");
pub const IID_IAudioBass = &IID_IAudioBass_Value;
pub const IAudioBass = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioMidrange_Value = @import("../zig.zig").Guid.initString("5e54b6d7-b44b-40d9-9a9e-e691d9ce6edf");
pub const IID_IAudioMidrange = &IID_IAudioMidrange_Value;
pub const IAudioMidrange = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioTreble_Value = @import("../zig.zig").Guid.initString("0a717812-694e-4907-b74b-bafa5cfdca7b");
pub const IID_IAudioTreble = &IID_IAudioTreble_Value;
pub const IAudioTreble = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioAutoGainControl_Value = @import("../zig.zig").Guid.initString("85401fd4-6de4-4b9d-9869-2d6753a82f3c");
pub const IID_IAudioAutoGainControl = &IID_IAudioAutoGainControl_Value;
pub const IAudioAutoGainControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEnabled: fn(
            self: *const IAudioAutoGainControl,
            pbEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnabled: fn(
            self: *const IAudioAutoGainControl,
            bEnable: BOOL,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioAutoGainControl_GetEnabled(self: *const T, pbEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioAutoGainControl.VTable, self.vtable).GetEnabled(@ptrCast(*const IAudioAutoGainControl, self), pbEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioAutoGainControl_SetEnabled(self: *const T, bEnable: BOOL, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioAutoGainControl.VTable, self.vtable).SetEnabled(@ptrCast(*const IAudioAutoGainControl, self), bEnable, pguidEventContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioPeakMeter_Value = @import("../zig.zig").Guid.initString("dd79923c-0599-45e0-b8b6-c8df7db6e796");
pub const IID_IAudioPeakMeter = &IID_IAudioPeakMeter_Value;
pub const IAudioPeakMeter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: fn(
            self: *const IAudioPeakMeter,
            pcChannels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLevel: fn(
            self: *const IAudioPeakMeter,
            nChannel: u32,
            pfLevel: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioPeakMeter_GetChannelCount(self: *const T, pcChannels: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioPeakMeter.VTable, self.vtable).GetChannelCount(@ptrCast(*const IAudioPeakMeter, self), pcChannels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioPeakMeter_GetLevel(self: *const T, nChannel: u32, pfLevel: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioPeakMeter.VTable, self.vtable).GetLevel(@ptrCast(*const IAudioPeakMeter, self), nChannel, pfLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeviceSpecificProperty_Value = @import("../zig.zig").Guid.initString("3b22bcbf-2586-4af0-8583-205d391b807c");
pub const IID_IDeviceSpecificProperty = &IID_IDeviceSpecificProperty_Value;
pub const IDeviceSpecificProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: fn(
            self: *const IDeviceSpecificProperty,
            pVType: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IDeviceSpecificProperty,
            pvValue: ?*anyopaque,
            pcbValue: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const IDeviceSpecificProperty,
            pvValue: ?*anyopaque,
            cbValue: u32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get4BRange: fn(
            self: *const IDeviceSpecificProperty,
            plMin: ?*i32,
            plMax: ?*i32,
            plStepping: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceSpecificProperty_GetType(self: *const T, pVType: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceSpecificProperty.VTable, self.vtable).GetType(@ptrCast(*const IDeviceSpecificProperty, self), pVType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceSpecificProperty_GetValue(self: *const T, pvValue: ?*anyopaque, pcbValue: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceSpecificProperty.VTable, self.vtable).GetValue(@ptrCast(*const IDeviceSpecificProperty, self), pvValue, pcbValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceSpecificProperty_SetValue(self: *const T, pvValue: ?*anyopaque, cbValue: u32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceSpecificProperty.VTable, self.vtable).SetValue(@ptrCast(*const IDeviceSpecificProperty, self), pvValue, cbValue, pguidEventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceSpecificProperty_Get4BRange(self: *const T, plMin: ?*i32, plMax: ?*i32, plStepping: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceSpecificProperty.VTable, self.vtable).Get4BRange(@ptrCast(*const IDeviceSpecificProperty, self), plMin, plMax, plStepping);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPartsList_Value = @import("../zig.zig").Guid.initString("6daa848c-5eb0-45cc-aea5-998a2cda1ffb");
pub const IID_IPartsList = &IID_IPartsList_Value;
pub const IPartsList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IPartsList,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPart: fn(
            self: *const IPartsList,
            nIndex: u32,
            ppPart: ?*?*IPart,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPartsList_GetCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPartsList.VTable, self.vtable).GetCount(@ptrCast(*const IPartsList, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPartsList_GetPart(self: *const T, nIndex: u32, ppPart: ?*?*IPart) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPartsList.VTable, self.vtable).GetPart(@ptrCast(*const IPartsList, self), nIndex, ppPart);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPart_Value = @import("../zig.zig").Guid.initString("ae2de0e4-5bca-4f2d-aa46-5d13f8fdb3a9");
pub const IID_IPart = &IID_IPart_Value;
pub const IPart = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IPart,
            ppwstrName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalId: fn(
            self: *const IPart,
            pnId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGlobalId: fn(
            self: *const IPart,
            ppwstrGlobalId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPartType: fn(
            self: *const IPart,
            pPartType: ?*PartType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubType: fn(
            self: *const IPart,
            pSubType: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlInterfaceCount: fn(
            self: *const IPart,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlInterface: fn(
            self: *const IPart,
            nIndex: u32,
            ppInterfaceDesc: ?*?*IControlInterface,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPartsIncoming: fn(
            self: *const IPart,
            ppParts: ?*?*IPartsList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPartsOutgoing: fn(
            self: *const IPart,
            ppParts: ?*?*IPartsList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTopologyObject: fn(
            self: *const IPart,
            ppTopology: ?*?*IDeviceTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: fn(
            self: *const IPart,
            dwClsContext: u32,
            refiid: ?*const Guid,
            ppvObject: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterControlChangeCallback: fn(
            self: *const IPart,
            riid: ?*const Guid,
            pNotify: ?*IControlChangeNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterControlChangeCallback: fn(
            self: *const IPart,
            pNotify: ?*IControlChangeNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_GetName(self: *const T, ppwstrName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).GetName(@ptrCast(*const IPart, self), ppwstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_GetLocalId(self: *const T, pnId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).GetLocalId(@ptrCast(*const IPart, self), pnId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_GetGlobalId(self: *const T, ppwstrGlobalId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).GetGlobalId(@ptrCast(*const IPart, self), ppwstrGlobalId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_GetPartType(self: *const T, pPartType: ?*PartType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).GetPartType(@ptrCast(*const IPart, self), pPartType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_GetSubType(self: *const T, pSubType: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).GetSubType(@ptrCast(*const IPart, self), pSubType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_GetControlInterfaceCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).GetControlInterfaceCount(@ptrCast(*const IPart, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_GetControlInterface(self: *const T, nIndex: u32, ppInterfaceDesc: ?*?*IControlInterface) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).GetControlInterface(@ptrCast(*const IPart, self), nIndex, ppInterfaceDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_EnumPartsIncoming(self: *const T, ppParts: ?*?*IPartsList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).EnumPartsIncoming(@ptrCast(*const IPart, self), ppParts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_EnumPartsOutgoing(self: *const T, ppParts: ?*?*IPartsList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).EnumPartsOutgoing(@ptrCast(*const IPart, self), ppParts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_GetTopologyObject(self: *const T, ppTopology: ?*?*IDeviceTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).GetTopologyObject(@ptrCast(*const IPart, self), ppTopology);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_Activate(self: *const T, dwClsContext: u32, refiid: ?*const Guid, ppvObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).Activate(@ptrCast(*const IPart, self), dwClsContext, refiid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_RegisterControlChangeCallback(self: *const T, riid: ?*const Guid, pNotify: ?*IControlChangeNotify) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).RegisterControlChangeCallback(@ptrCast(*const IPart, self), riid, pNotify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPart_UnregisterControlChangeCallback(self: *const T, pNotify: ?*IControlChangeNotify) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPart.VTable, self.vtable).UnregisterControlChangeCallback(@ptrCast(*const IPart, self), pNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConnector_Value = @import("../zig.zig").Guid.initString("9c2c4058-23f5-41de-877a-df3af236a09e");
pub const IID_IConnector = &IID_IConnector_Value;
pub const IConnector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: fn(
            self: *const IConnector,
            pType: ?*ConnectorType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataFlow: fn(
            self: *const IConnector,
            pFlow: ?*DataFlow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectTo: fn(
            self: *const IConnector,
            pConnectTo: ?*IConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConnected: fn(
            self: *const IConnector,
            pbConnected: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectedTo: fn(
            self: *const IConnector,
            ppConTo: ?*?*IConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectorIdConnectedTo: fn(
            self: *const IConnector,
            ppwstrConnectorId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceIdConnectedTo: fn(
            self: *const IConnector,
            ppwstrDeviceId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnector_GetType(self: *const T, pType: ?*ConnectorType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnector.VTable, self.vtable).GetType(@ptrCast(*const IConnector, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnector_GetDataFlow(self: *const T, pFlow: ?*DataFlow) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnector.VTable, self.vtable).GetDataFlow(@ptrCast(*const IConnector, self), pFlow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnector_ConnectTo(self: *const T, pConnectTo: ?*IConnector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnector.VTable, self.vtable).ConnectTo(@ptrCast(*const IConnector, self), pConnectTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnector_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnector.VTable, self.vtable).Disconnect(@ptrCast(*const IConnector, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnector_IsConnected(self: *const T, pbConnected: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnector.VTable, self.vtable).IsConnected(@ptrCast(*const IConnector, self), pbConnected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnector_GetConnectedTo(self: *const T, ppConTo: ?*?*IConnector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnector.VTable, self.vtable).GetConnectedTo(@ptrCast(*const IConnector, self), ppConTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnector_GetConnectorIdConnectedTo(self: *const T, ppwstrConnectorId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnector.VTable, self.vtable).GetConnectorIdConnectedTo(@ptrCast(*const IConnector, self), ppwstrConnectorId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnector_GetDeviceIdConnectedTo(self: *const T, ppwstrDeviceId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnector.VTable, self.vtable).GetDeviceIdConnectedTo(@ptrCast(*const IConnector, self), ppwstrDeviceId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISubunit_Value = @import("../zig.zig").Guid.initString("82149a85-dba6-4487-86bb-ea8f7fefcc71");
pub const IID_ISubunit = &IID_ISubunit_Value;
pub const ISubunit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IControlInterface_Value = @import("../zig.zig").Guid.initString("45d37c3f-5140-444a-ae24-400789f3cbf3");
pub const IID_IControlInterface = &IID_IControlInterface_Value;
pub const IControlInterface = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IControlInterface,
            ppwstrName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIID: fn(
            self: *const IControlInterface,
            pIID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IControlInterface_GetName(self: *const T, ppwstrName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IControlInterface.VTable, self.vtable).GetName(@ptrCast(*const IControlInterface, self), ppwstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IControlInterface_GetIID(self: *const T, pIID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IControlInterface.VTable, self.vtable).GetIID(@ptrCast(*const IControlInterface, self), pIID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IControlChangeNotify_Value = @import("../zig.zig").Guid.initString("a09513ed-c709-4d21-bd7b-5f34c47f3947");
pub const IID_IControlChangeNotify = &IID_IControlChangeNotify_Value;
pub const IControlChangeNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: fn(
            self: *const IControlChangeNotify,
            dwSenderProcessId: u32,
            pguidEventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IControlChangeNotify_OnNotify(self: *const T, dwSenderProcessId: u32, pguidEventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IControlChangeNotify.VTable, self.vtable).OnNotify(@ptrCast(*const IControlChangeNotify, self), dwSenderProcessId, pguidEventContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeviceTopology_Value = @import("../zig.zig").Guid.initString("2a07407e-6497-4a18-9787-32f79bd0d98f");
pub const IID_IDeviceTopology = &IID_IDeviceTopology_Value;
pub const IDeviceTopology = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectorCount: fn(
            self: *const IDeviceTopology,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnector: fn(
            self: *const IDeviceTopology,
            nIndex: u32,
            ppConnector: ?*?*IConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubunitCount: fn(
            self: *const IDeviceTopology,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubunit: fn(
            self: *const IDeviceTopology,
            nIndex: u32,
            ppSubunit: ?*?*ISubunit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPartById: fn(
            self: *const IDeviceTopology,
            nId: u32,
            ppPart: ?*?*IPart,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceId: fn(
            self: *const IDeviceTopology,
            ppwstrDeviceId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignalPath: fn(
            self: *const IDeviceTopology,
            pIPartFrom: ?*IPart,
            pIPartTo: ?*IPart,
            bRejectMixedPaths: BOOL,
            ppParts: ?*?*IPartsList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceTopology_GetConnectorCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceTopology.VTable, self.vtable).GetConnectorCount(@ptrCast(*const IDeviceTopology, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceTopology_GetConnector(self: *const T, nIndex: u32, ppConnector: ?*?*IConnector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceTopology.VTable, self.vtable).GetConnector(@ptrCast(*const IDeviceTopology, self), nIndex, ppConnector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceTopology_GetSubunitCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceTopology.VTable, self.vtable).GetSubunitCount(@ptrCast(*const IDeviceTopology, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceTopology_GetSubunit(self: *const T, nIndex: u32, ppSubunit: ?*?*ISubunit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceTopology.VTable, self.vtable).GetSubunit(@ptrCast(*const IDeviceTopology, self), nIndex, ppSubunit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceTopology_GetPartById(self: *const T, nId: u32, ppPart: ?*?*IPart) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceTopology.VTable, self.vtable).GetPartById(@ptrCast(*const IDeviceTopology, self), nId, ppPart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceTopology_GetDeviceId(self: *const T, ppwstrDeviceId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceTopology.VTable, self.vtable).GetDeviceId(@ptrCast(*const IDeviceTopology, self), ppwstrDeviceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeviceTopology_GetSignalPath(self: *const T, pIPartFrom: ?*IPart, pIPartTo: ?*IPart, bRejectMixedPaths: BOOL, ppParts: ?*?*IPartsList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeviceTopology.VTable, self.vtable).GetSignalPath(@ptrCast(*const IDeviceTopology, self), pIPartFrom, pIPartTo, bRejectMixedPaths, ppParts);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AudioSessionDisconnectReason = enum(i32) {
    DeviceRemoval = 0,
    ServerShutdown = 1,
    FormatChanged = 2,
    SessionLogoff = 3,
    SessionDisconnected = 4,
    ExclusiveModeOverride = 5,
};
pub const DisconnectReasonDeviceRemoval = AudioSessionDisconnectReason.DeviceRemoval;
pub const DisconnectReasonServerShutdown = AudioSessionDisconnectReason.ServerShutdown;
pub const DisconnectReasonFormatChanged = AudioSessionDisconnectReason.FormatChanged;
pub const DisconnectReasonSessionLogoff = AudioSessionDisconnectReason.SessionLogoff;
pub const DisconnectReasonSessionDisconnected = AudioSessionDisconnectReason.SessionDisconnected;
pub const DisconnectReasonExclusiveModeOverride = AudioSessionDisconnectReason.ExclusiveModeOverride;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioSessionEvents_Value = @import("../zig.zig").Guid.initString("24918acc-64b3-37c1-8ca9-74a66e9957a8");
pub const IID_IAudioSessionEvents = &IID_IAudioSessionEvents_Value;
pub const IAudioSessionEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDisplayNameChanged: fn(
            self: *const IAudioSessionEvents,
            NewDisplayName: ?[*:0]const u16,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnIconPathChanged: fn(
            self: *const IAudioSessionEvents,
            NewIconPath: ?[*:0]const u16,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSimpleVolumeChanged: fn(
            self: *const IAudioSessionEvents,
            NewVolume: f32,
            NewMute: BOOL,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnChannelVolumeChanged: fn(
            self: *const IAudioSessionEvents,
            ChannelCount: u32,
            NewChannelVolumeArray: [*]f32,
            ChangedChannel: u32,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnGroupingParamChanged: fn(
            self: *const IAudioSessionEvents,
            NewGroupingParam: ?*const Guid,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStateChanged: fn(
            self: *const IAudioSessionEvents,
            NewState: AudioSessionState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSessionDisconnected: fn(
            self: *const IAudioSessionEvents,
            DisconnectReason: AudioSessionDisconnectReason,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionEvents_OnDisplayNameChanged(self: *const T, NewDisplayName: ?[*:0]const u16, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionEvents.VTable, self.vtable).OnDisplayNameChanged(@ptrCast(*const IAudioSessionEvents, self), NewDisplayName, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionEvents_OnIconPathChanged(self: *const T, NewIconPath: ?[*:0]const u16, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionEvents.VTable, self.vtable).OnIconPathChanged(@ptrCast(*const IAudioSessionEvents, self), NewIconPath, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionEvents_OnSimpleVolumeChanged(self: *const T, NewVolume: f32, NewMute: BOOL, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionEvents.VTable, self.vtable).OnSimpleVolumeChanged(@ptrCast(*const IAudioSessionEvents, self), NewVolume, NewMute, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionEvents_OnChannelVolumeChanged(self: *const T, ChannelCount: u32, NewChannelVolumeArray: [*]f32, ChangedChannel: u32, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionEvents.VTable, self.vtable).OnChannelVolumeChanged(@ptrCast(*const IAudioSessionEvents, self), ChannelCount, NewChannelVolumeArray, ChangedChannel, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionEvents_OnGroupingParamChanged(self: *const T, NewGroupingParam: ?*const Guid, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionEvents.VTable, self.vtable).OnGroupingParamChanged(@ptrCast(*const IAudioSessionEvents, self), NewGroupingParam, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionEvents_OnStateChanged(self: *const T, NewState: AudioSessionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionEvents.VTable, self.vtable).OnStateChanged(@ptrCast(*const IAudioSessionEvents, self), NewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionEvents_OnSessionDisconnected(self: *const T, DisconnectReason: AudioSessionDisconnectReason) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionEvents.VTable, self.vtable).OnSessionDisconnected(@ptrCast(*const IAudioSessionEvents, self), DisconnectReason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioSessionControl_Value = @import("../zig.zig").Guid.initString("f4b1a599-7266-4319-a8ca-e70acb11e8cd");
pub const IID_IAudioSessionControl = &IID_IAudioSessionControl_Value;
pub const IAudioSessionControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetState: fn(
            self: *const IAudioSessionControl,
            pRetVal: ?*AudioSessionState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const IAudioSessionControl,
            pRetVal: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplayName: fn(
            self: *const IAudioSessionControl,
            Value: ?[*:0]const u16,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconPath: fn(
            self: *const IAudioSessionControl,
            pRetVal: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconPath: fn(
            self: *const IAudioSessionControl,
            Value: ?[*:0]const u16,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroupingParam: fn(
            self: *const IAudioSessionControl,
            pRetVal: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGroupingParam: fn(
            self: *const IAudioSessionControl,
            Override: ?*const Guid,
            EventContext: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterAudioSessionNotification: fn(
            self: *const IAudioSessionControl,
            NewNotifications: ?*IAudioSessionEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterAudioSessionNotification: fn(
            self: *const IAudioSessionControl,
            NewNotifications: ?*IAudioSessionEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl_GetState(self: *const T, pRetVal: ?*AudioSessionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl.VTable, self.vtable).GetState(@ptrCast(*const IAudioSessionControl, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl_GetDisplayName(self: *const T, pRetVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl.VTable, self.vtable).GetDisplayName(@ptrCast(*const IAudioSessionControl, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl_SetDisplayName(self: *const T, Value: ?[*:0]const u16, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl.VTable, self.vtable).SetDisplayName(@ptrCast(*const IAudioSessionControl, self), Value, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl_GetIconPath(self: *const T, pRetVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl.VTable, self.vtable).GetIconPath(@ptrCast(*const IAudioSessionControl, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl_SetIconPath(self: *const T, Value: ?[*:0]const u16, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl.VTable, self.vtable).SetIconPath(@ptrCast(*const IAudioSessionControl, self), Value, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl_GetGroupingParam(self: *const T, pRetVal: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl.VTable, self.vtable).GetGroupingParam(@ptrCast(*const IAudioSessionControl, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl_SetGroupingParam(self: *const T, Override: ?*const Guid, EventContext: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl.VTable, self.vtable).SetGroupingParam(@ptrCast(*const IAudioSessionControl, self), Override, EventContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl_RegisterAudioSessionNotification(self: *const T, NewNotifications: ?*IAudioSessionEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl.VTable, self.vtable).RegisterAudioSessionNotification(@ptrCast(*const IAudioSessionControl, self), NewNotifications);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl_UnregisterAudioSessionNotification(self: *const T, NewNotifications: ?*IAudioSessionEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl.VTable, self.vtable).UnregisterAudioSessionNotification(@ptrCast(*const IAudioSessionControl, self), NewNotifications);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionControl2_Value = @import("../zig.zig").Guid.initString("bfb7ff88-7239-4fc9-8fa2-07c950be9c6d");
pub const IID_IAudioSessionControl2 = &IID_IAudioSessionControl2_Value;
pub const IAudioSessionControl2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSessionControl.VTable,
        GetSessionIdentifier: fn(
            self: *const IAudioSessionControl2,
            pRetVal: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSessionInstanceIdentifier: fn(
            self: *const IAudioSessionControl2,
            pRetVal: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessId: fn(
            self: *const IAudioSessionControl2,
            pRetVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSystemSoundsSession: fn(
            self: *const IAudioSessionControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuckingPreference: fn(
            self: *const IAudioSessionControl2,
            optOut: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAudioSessionControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl2_GetSessionIdentifier(self: *const T, pRetVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl2.VTable, self.vtable).GetSessionIdentifier(@ptrCast(*const IAudioSessionControl2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl2_GetSessionInstanceIdentifier(self: *const T, pRetVal: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl2.VTable, self.vtable).GetSessionInstanceIdentifier(@ptrCast(*const IAudioSessionControl2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl2_GetProcessId(self: *const T, pRetVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl2.VTable, self.vtable).GetProcessId(@ptrCast(*const IAudioSessionControl2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl2_IsSystemSoundsSession(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl2.VTable, self.vtable).IsSystemSoundsSession(@ptrCast(*const IAudioSessionControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionControl2_SetDuckingPreference(self: *const T, optOut: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionControl2.VTable, self.vtable).SetDuckingPreference(@ptrCast(*const IAudioSessionControl2, self), optOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioSessionManager_Value = @import("../zig.zig").Guid.initString("bfa971f1-4d5e-40bb-935e-967039bfbee4");
pub const IID_IAudioSessionManager = &IID_IAudioSessionManager_Value;
pub const IAudioSessionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAudioSessionControl: fn(
            self: *const IAudioSessionManager,
            AudioSessionGuid: ?*const Guid,
            StreamFlags: u32,
            SessionControl: ?*?*IAudioSessionControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSimpleAudioVolume: fn(
            self: *const IAudioSessionManager,
            AudioSessionGuid: ?*const Guid,
            StreamFlags: u32,
            AudioVolume: ?*?*ISimpleAudioVolume,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionManager_GetAudioSessionControl(self: *const T, AudioSessionGuid: ?*const Guid, StreamFlags: u32, SessionControl: ?*?*IAudioSessionControl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionManager.VTable, self.vtable).GetAudioSessionControl(@ptrCast(*const IAudioSessionManager, self), AudioSessionGuid, StreamFlags, SessionControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionManager_GetSimpleAudioVolume(self: *const T, AudioSessionGuid: ?*const Guid, StreamFlags: u32, AudioVolume: ?*?*ISimpleAudioVolume) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionManager.VTable, self.vtable).GetSimpleAudioVolume(@ptrCast(*const IAudioSessionManager, self), AudioSessionGuid, StreamFlags, AudioVolume);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioVolumeDuckNotification_Value = @import("../zig.zig").Guid.initString("c3b284d4-6d39-4359-b3cf-b56ddb3bb39c");
pub const IID_IAudioVolumeDuckNotification = &IID_IAudioVolumeDuckNotification_Value;
pub const IAudioVolumeDuckNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnVolumeDuckNotification: fn(
            self: *const IAudioVolumeDuckNotification,
            sessionID: ?[*:0]const u16,
            countCommunicationSessions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnVolumeUnduckNotification: fn(
            self: *const IAudioVolumeDuckNotification,
            sessionID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioVolumeDuckNotification_OnVolumeDuckNotification(self: *const T, sessionID: ?[*:0]const u16, countCommunicationSessions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioVolumeDuckNotification.VTable, self.vtable).OnVolumeDuckNotification(@ptrCast(*const IAudioVolumeDuckNotification, self), sessionID, countCommunicationSessions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioVolumeDuckNotification_OnVolumeUnduckNotification(self: *const T, sessionID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioVolumeDuckNotification.VTable, self.vtable).OnVolumeUnduckNotification(@ptrCast(*const IAudioVolumeDuckNotification, self), sessionID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionNotification_Value = @import("../zig.zig").Guid.initString("641dd20b-4d41-49cc-aba3-174b9477bb08");
pub const IID_IAudioSessionNotification = &IID_IAudioSessionNotification_Value;
pub const IAudioSessionNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSessionCreated: fn(
            self: *const IAudioSessionNotification,
            NewSession: ?*IAudioSessionControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionNotification_OnSessionCreated(self: *const T, NewSession: ?*IAudioSessionControl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionNotification.VTable, self.vtable).OnSessionCreated(@ptrCast(*const IAudioSessionNotification, self), NewSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionEnumerator_Value = @import("../zig.zig").Guid.initString("e2f5bb11-0570-40ca-acdd-3aa01277dee8");
pub const IID_IAudioSessionEnumerator = &IID_IAudioSessionEnumerator_Value;
pub const IAudioSessionEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IAudioSessionEnumerator,
            SessionCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSession: fn(
            self: *const IAudioSessionEnumerator,
            SessionCount: i32,
            Session: ?*?*IAudioSessionControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionEnumerator_GetCount(self: *const T, SessionCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionEnumerator.VTable, self.vtable).GetCount(@ptrCast(*const IAudioSessionEnumerator, self), SessionCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionEnumerator_GetSession(self: *const T, SessionCount: i32, Session: ?*?*IAudioSessionControl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionEnumerator.VTable, self.vtable).GetSession(@ptrCast(*const IAudioSessionEnumerator, self), SessionCount, Session);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionManager2_Value = @import("../zig.zig").Guid.initString("77aa99a0-1bd6-484f-8bc7-2c654c9a9b6f");
pub const IID_IAudioSessionManager2 = &IID_IAudioSessionManager2_Value;
pub const IAudioSessionManager2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSessionManager.VTable,
        GetSessionEnumerator: fn(
            self: *const IAudioSessionManager2,
            SessionEnum: ?*?*IAudioSessionEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterSessionNotification: fn(
            self: *const IAudioSessionManager2,
            SessionNotification: ?*IAudioSessionNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterSessionNotification: fn(
            self: *const IAudioSessionManager2,
            SessionNotification: ?*IAudioSessionNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterDuckNotification: fn(
            self: *const IAudioSessionManager2,
            sessionID: ?[*:0]const u16,
            duckNotification: ?*IAudioVolumeDuckNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterDuckNotification: fn(
            self: *const IAudioSessionManager2,
            duckNotification: ?*IAudioVolumeDuckNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAudioSessionManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionManager2_GetSessionEnumerator(self: *const T, SessionEnum: ?*?*IAudioSessionEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionManager2.VTable, self.vtable).GetSessionEnumerator(@ptrCast(*const IAudioSessionManager2, self), SessionEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionManager2_RegisterSessionNotification(self: *const T, SessionNotification: ?*IAudioSessionNotification) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionManager2.VTable, self.vtable).RegisterSessionNotification(@ptrCast(*const IAudioSessionManager2, self), SessionNotification);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionManager2_UnregisterSessionNotification(self: *const T, SessionNotification: ?*IAudioSessionNotification) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionManager2.VTable, self.vtable).UnregisterSessionNotification(@ptrCast(*const IAudioSessionManager2, self), SessionNotification);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionManager2_RegisterDuckNotification(self: *const T, sessionID: ?[*:0]const u16, duckNotification: ?*IAudioVolumeDuckNotification) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionManager2.VTable, self.vtable).RegisterDuckNotification(@ptrCast(*const IAudioSessionManager2, self), sessionID, duckNotification);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionManager2_UnregisterDuckNotification(self: *const T, duckNotification: ?*IAudioVolumeDuckNotification) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSessionManager2.VTable, self.vtable).UnregisterDuckNotification(@ptrCast(*const IAudioSessionManager2, self), duckNotification);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SpatialAudioMetadataWriterOverflowMode = enum(i32) {
    Fail = 0,
    MergeWithNew = 1,
    MergeWithLast = 2,
};
pub const SpatialAudioMetadataWriterOverflow_Fail = SpatialAudioMetadataWriterOverflowMode.Fail;
pub const SpatialAudioMetadataWriterOverflow_MergeWithNew = SpatialAudioMetadataWriterOverflowMode.MergeWithNew;
pub const SpatialAudioMetadataWriterOverflow_MergeWithLast = SpatialAudioMetadataWriterOverflowMode.MergeWithLast;

pub const SpatialAudioMetadataCopyMode = enum(i32) {
    Overwrite = 0,
    Append = 1,
    AppendMergeWithLast = 2,
    AppendMergeWithFirst = 3,
};
pub const SpatialAudioMetadataCopy_Overwrite = SpatialAudioMetadataCopyMode.Overwrite;
pub const SpatialAudioMetadataCopy_Append = SpatialAudioMetadataCopyMode.Append;
pub const SpatialAudioMetadataCopy_AppendMergeWithLast = SpatialAudioMetadataCopyMode.AppendMergeWithLast;
pub const SpatialAudioMetadataCopy_AppendMergeWithFirst = SpatialAudioMetadataCopyMode.AppendMergeWithFirst;

pub const SpatialAudioMetadataItemsInfo = packed struct {
    FrameCount: u16,
    ItemCount: u16,
    MaxItemCount: u16,
    MaxValueBufferLength: u32,
};

pub const SpatialAudioObjectRenderStreamForMetadataActivationParams = packed struct {
    ObjectFormat: ?*const WAVEFORMATEX,
    StaticObjectTypeMask: AudioObjectType,
    MinDynamicObjectCount: u32,
    MaxDynamicObjectCount: u32,
    Category: AUDIO_STREAM_CATEGORY,
    EventHandle: ?HANDLE,
    MetadataFormatId: Guid,
    MaxMetadataItemCount: u16,
    MetadataActivationParams: ?*const PROPVARIANT,
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify,
};

pub const SpatialAudioObjectRenderStreamForMetadataActivationParams2 = packed struct {
    ObjectFormat: ?*const WAVEFORMATEX,
    StaticObjectTypeMask: AudioObjectType,
    MinDynamicObjectCount: u32,
    MaxDynamicObjectCount: u32,
    Category: AUDIO_STREAM_CATEGORY,
    EventHandle: ?HANDLE,
    MetadataFormatId: Guid,
    MaxMetadataItemCount: u32,
    MetadataActivationParams: ?*const PROPVARIANT,
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify,
    Options: SPATIAL_AUDIO_STREAM_OPTIONS,
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataItems_Value = @import("../zig.zig").Guid.initString("bcd7c78f-3098-4f22-b547-a2f25a381269");
pub const IID_ISpatialAudioMetadataItems = &IID_ISpatialAudioMetadataItems_Value;
pub const ISpatialAudioMetadataItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameCount: fn(
            self: *const ISpatialAudioMetadataItems,
            frameCount: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemCount: fn(
            self: *const ISpatialAudioMetadataItems,
            itemCount: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxItemCount: fn(
            self: *const ISpatialAudioMetadataItems,
            maxItemCount: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxValueBufferLength: fn(
            self: *const ISpatialAudioMetadataItems,
            maxValueBufferLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfo: fn(
            self: *const ISpatialAudioMetadataItems,
            info: ?*SpatialAudioMetadataItemsInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataItems_GetFrameCount(self: *const T, frameCount: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataItems.VTable, self.vtable).GetFrameCount(@ptrCast(*const ISpatialAudioMetadataItems, self), frameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataItems_GetItemCount(self: *const T, itemCount: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataItems.VTable, self.vtable).GetItemCount(@ptrCast(*const ISpatialAudioMetadataItems, self), itemCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataItems_GetMaxItemCount(self: *const T, maxItemCount: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataItems.VTable, self.vtable).GetMaxItemCount(@ptrCast(*const ISpatialAudioMetadataItems, self), maxItemCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataItems_GetMaxValueBufferLength(self: *const T, maxValueBufferLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataItems.VTable, self.vtable).GetMaxValueBufferLength(@ptrCast(*const ISpatialAudioMetadataItems, self), maxValueBufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataItems_GetInfo(self: *const T, info: ?*SpatialAudioMetadataItemsInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataItems.VTable, self.vtable).GetInfo(@ptrCast(*const ISpatialAudioMetadataItems, self), info);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataWriter_Value = @import("../zig.zig").Guid.initString("1b17ca01-2955-444d-a430-537dc589a844");
pub const IID_ISpatialAudioMetadataWriter = &IID_ISpatialAudioMetadataWriter_Value;
pub const ISpatialAudioMetadataWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const ISpatialAudioMetadataWriter,
            metadataItems: ?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNextItem: fn(
            self: *const ISpatialAudioMetadataWriter,
            frameOffset: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNextItemCommand: fn(
            self: *const ISpatialAudioMetadataWriter,
            commandID: u8,
            // TODO: what to do with BytesParamIndex 2?
            valueBuffer: ?*const anyopaque,
            valueBufferLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const ISpatialAudioMetadataWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataWriter_Open(self: *const T, metadataItems: ?*ISpatialAudioMetadataItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataWriter.VTable, self.vtable).Open(@ptrCast(*const ISpatialAudioMetadataWriter, self), metadataItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataWriter_WriteNextItem(self: *const T, frameOffset: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataWriter.VTable, self.vtable).WriteNextItem(@ptrCast(*const ISpatialAudioMetadataWriter, self), frameOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataWriter_WriteNextItemCommand(self: *const T, commandID: u8, valueBuffer: ?*const anyopaque, valueBufferLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataWriter.VTable, self.vtable).WriteNextItemCommand(@ptrCast(*const ISpatialAudioMetadataWriter, self), commandID, valueBuffer, valueBufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataWriter_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataWriter.VTable, self.vtable).Close(@ptrCast(*const ISpatialAudioMetadataWriter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataReader_Value = @import("../zig.zig").Guid.initString("b78e86a2-31d9-4c32-94d2-7df40fc7ebec");
pub const IID_ISpatialAudioMetadataReader = &IID_ISpatialAudioMetadataReader_Value;
pub const ISpatialAudioMetadataReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const ISpatialAudioMetadataReader,
            metadataItems: ?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadNextItem: fn(
            self: *const ISpatialAudioMetadataReader,
            commandCount: ?*u8,
            frameOffset: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadNextItemCommand: fn(
            self: *const ISpatialAudioMetadataReader,
            commandID: ?*u8,
            // TODO: what to do with BytesParamIndex 2?
            valueBuffer: ?*anyopaque,
            maxValueBufferLength: u32,
            valueBufferLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const ISpatialAudioMetadataReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataReader_Open(self: *const T, metadataItems: ?*ISpatialAudioMetadataItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataReader.VTable, self.vtable).Open(@ptrCast(*const ISpatialAudioMetadataReader, self), metadataItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataReader_ReadNextItem(self: *const T, commandCount: ?*u8, frameOffset: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataReader.VTable, self.vtable).ReadNextItem(@ptrCast(*const ISpatialAudioMetadataReader, self), commandCount, frameOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataReader_ReadNextItemCommand(self: *const T, commandID: ?*u8, valueBuffer: ?*anyopaque, maxValueBufferLength: u32, valueBufferLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataReader.VTable, self.vtable).ReadNextItemCommand(@ptrCast(*const ISpatialAudioMetadataReader, self), commandID, valueBuffer, maxValueBufferLength, valueBufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataReader_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataReader.VTable, self.vtable).Close(@ptrCast(*const ISpatialAudioMetadataReader, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataCopier_Value = @import("../zig.zig").Guid.initString("d224b233-e251-4fd0-9ca2-d5ecf9a68404");
pub const IID_ISpatialAudioMetadataCopier = &IID_ISpatialAudioMetadataCopier_Value;
pub const ISpatialAudioMetadataCopier = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const ISpatialAudioMetadataCopier,
            metadataItems: ?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyMetadataForFrames: fn(
            self: *const ISpatialAudioMetadataCopier,
            copyFrameCount: u16,
            copyMode: SpatialAudioMetadataCopyMode,
            dstMetadataItems: ?*ISpatialAudioMetadataItems,
            itemsCopied: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const ISpatialAudioMetadataCopier,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataCopier_Open(self: *const T, metadataItems: ?*ISpatialAudioMetadataItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataCopier.VTable, self.vtable).Open(@ptrCast(*const ISpatialAudioMetadataCopier, self), metadataItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataCopier_CopyMetadataForFrames(self: *const T, copyFrameCount: u16, copyMode: SpatialAudioMetadataCopyMode, dstMetadataItems: ?*ISpatialAudioMetadataItems, itemsCopied: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataCopier.VTable, self.vtable).CopyMetadataForFrames(@ptrCast(*const ISpatialAudioMetadataCopier, self), copyFrameCount, copyMode, dstMetadataItems, itemsCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataCopier_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataCopier.VTable, self.vtable).Close(@ptrCast(*const ISpatialAudioMetadataCopier, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataItemsBuffer_Value = @import("../zig.zig").Guid.initString("42640a16-e1bd-42d9-9ff6-031ab71a2dba");
pub const IID_ISpatialAudioMetadataItemsBuffer = &IID_ISpatialAudioMetadataItemsBuffer_Value;
pub const ISpatialAudioMetadataItemsBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachToBuffer: fn(
            self: *const ISpatialAudioMetadataItemsBuffer,
            // TODO: what to do with BytesParamIndex 1?
            buffer: ?*u8,
            bufferLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachToPopulatedBuffer: fn(
            self: *const ISpatialAudioMetadataItemsBuffer,
            // TODO: what to do with BytesParamIndex 1?
            buffer: ?*u8,
            bufferLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachBuffer: fn(
            self: *const ISpatialAudioMetadataItemsBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataItemsBuffer_AttachToBuffer(self: *const T, buffer: ?*u8, bufferLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataItemsBuffer.VTable, self.vtable).AttachToBuffer(@ptrCast(*const ISpatialAudioMetadataItemsBuffer, self), buffer, bufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataItemsBuffer_AttachToPopulatedBuffer(self: *const T, buffer: ?*u8, bufferLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataItemsBuffer.VTable, self.vtable).AttachToPopulatedBuffer(@ptrCast(*const ISpatialAudioMetadataItemsBuffer, self), buffer, bufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataItemsBuffer_DetachBuffer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataItemsBuffer.VTable, self.vtable).DetachBuffer(@ptrCast(*const ISpatialAudioMetadataItemsBuffer, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataClient_Value = @import("../zig.zig").Guid.initString("777d4a3b-f6ff-4a26-85dc-68d7cdeda1d4");
pub const IID_ISpatialAudioMetadataClient = &IID_ISpatialAudioMetadataClient_Value;
pub const ISpatialAudioMetadataClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateSpatialAudioMetadataItems: fn(
            self: *const ISpatialAudioMetadataClient,
            maxItemCount: u16,
            frameCount: u16,
            metadataItemsBuffer: ?*?*ISpatialAudioMetadataItemsBuffer,
            metadataItems: ?*?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpatialAudioMetadataItemsBufferLength: fn(
            self: *const ISpatialAudioMetadataClient,
            maxItemCount: u16,
            bufferLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioMetadataWriter: fn(
            self: *const ISpatialAudioMetadataClient,
            overflowMode: SpatialAudioMetadataWriterOverflowMode,
            metadataWriter: ?*?*ISpatialAudioMetadataWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioMetadataCopier: fn(
            self: *const ISpatialAudioMetadataClient,
            metadataCopier: ?*?*ISpatialAudioMetadataCopier,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioMetadataReader: fn(
            self: *const ISpatialAudioMetadataClient,
            metadataReader: ?*?*ISpatialAudioMetadataReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataClient_ActivateSpatialAudioMetadataItems(self: *const T, maxItemCount: u16, frameCount: u16, metadataItemsBuffer: ?*?*ISpatialAudioMetadataItemsBuffer, metadataItems: ?*?*ISpatialAudioMetadataItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataClient.VTable, self.vtable).ActivateSpatialAudioMetadataItems(@ptrCast(*const ISpatialAudioMetadataClient, self), maxItemCount, frameCount, metadataItemsBuffer, metadataItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataClient_GetSpatialAudioMetadataItemsBufferLength(self: *const T, maxItemCount: u16, bufferLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataClient.VTable, self.vtable).GetSpatialAudioMetadataItemsBufferLength(@ptrCast(*const ISpatialAudioMetadataClient, self), maxItemCount, bufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataClient_ActivateSpatialAudioMetadataWriter(self: *const T, overflowMode: SpatialAudioMetadataWriterOverflowMode, metadataWriter: ?*?*ISpatialAudioMetadataWriter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataClient.VTable, self.vtable).ActivateSpatialAudioMetadataWriter(@ptrCast(*const ISpatialAudioMetadataClient, self), overflowMode, metadataWriter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataClient_ActivateSpatialAudioMetadataCopier(self: *const T, metadataCopier: ?*?*ISpatialAudioMetadataCopier) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataClient.VTable, self.vtable).ActivateSpatialAudioMetadataCopier(@ptrCast(*const ISpatialAudioMetadataClient, self), metadataCopier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioMetadataClient_ActivateSpatialAudioMetadataReader(self: *const T, metadataReader: ?*?*ISpatialAudioMetadataReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioMetadataClient.VTable, self.vtable).ActivateSpatialAudioMetadataReader(@ptrCast(*const ISpatialAudioMetadataClient, self), metadataReader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectForMetadataCommands_Value = @import("../zig.zig").Guid.initString("0df2c94b-f5f9-472d-af6b-c46e0ac9cd05");
pub const IID_ISpatialAudioObjectForMetadataCommands = &IID_ISpatialAudioObjectForMetadataCommands_Value;
pub const ISpatialAudioObjectForMetadataCommands = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        WriteNextMetadataCommand: fn(
            self: *const ISpatialAudioObjectForMetadataCommands,
            commandID: u8,
            // TODO: what to do with BytesParamIndex 2?
            valueBuffer: ?*anyopaque,
            valueBufferLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectForMetadataCommands_WriteNextMetadataCommand(self: *const T, commandID: u8, valueBuffer: ?*anyopaque, valueBufferLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectForMetadataCommands.VTable, self.vtable).WriteNextMetadataCommand(@ptrCast(*const ISpatialAudioObjectForMetadataCommands, self), commandID, valueBuffer, valueBufferLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectForMetadataItems_Value = @import("../zig.zig").Guid.initString("ddea49ff-3bc0-4377-8aad-9fbcfd808566");
pub const IID_ISpatialAudioObjectForMetadataItems = &IID_ISpatialAudioObjectForMetadataItems_Value;
pub const ISpatialAudioObjectForMetadataItems = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        GetSpatialAudioMetadataItems: fn(
            self: *const ISpatialAudioObjectForMetadataItems,
            metadataItems: ?*?*ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectForMetadataItems_GetSpatialAudioMetadataItems(self: *const T, metadataItems: ?*?*ISpatialAudioMetadataItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectForMetadataItems.VTable, self.vtable).GetSpatialAudioMetadataItems(@ptrCast(*const ISpatialAudioObjectForMetadataItems, self), metadataItems);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamForMetadata_Value = @import("../zig.zig").Guid.initString("bbc9c907-48d5-4a2e-a0c7-f7f0d67c1fb1");
pub const IID_ISpatialAudioObjectRenderStreamForMetadata = &IID_ISpatialAudioObjectRenderStreamForMetadata_Value;
pub const ISpatialAudioObjectRenderStreamForMetadata = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectRenderStreamBase.VTable,
        ActivateSpatialAudioObjectForMetadataCommands: fn(
            self: *const ISpatialAudioObjectRenderStreamForMetadata,
            type: AudioObjectType,
            audioObject: ?*?*ISpatialAudioObjectForMetadataCommands,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateSpatialAudioObjectForMetadataItems: fn(
            self: *const ISpatialAudioObjectRenderStreamForMetadata,
            type: AudioObjectType,
            audioObject: ?*?*ISpatialAudioObjectForMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISpatialAudioObjectRenderStreamBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamForMetadata_ActivateSpatialAudioObjectForMetadataCommands(self: *const T, type_: AudioObjectType, audioObject: ?*?*ISpatialAudioObjectForMetadataCommands) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamForMetadata.VTable, self.vtable).ActivateSpatialAudioObjectForMetadataCommands(@ptrCast(*const ISpatialAudioObjectRenderStreamForMetadata, self), type_, audioObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpatialAudioObjectRenderStreamForMetadata_ActivateSpatialAudioObjectForMetadataItems(self: *const T, type_: AudioObjectType, audioObject: ?*?*ISpatialAudioObjectForMetadataItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpatialAudioObjectRenderStreamForMetadata.VTable, self.vtable).ActivateSpatialAudioObjectForMetadataItems(@ptrCast(*const ISpatialAudioObjectRenderStreamForMetadata, self), type_, audioObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROCESS_LOOPBACK_MODE = enum(i32) {
    INCLUDE_TARGET_PROCESS_TREE = 0,
    EXCLUDE_TARGET_PROCESS_TREE = 1,
};
pub const PROCESS_LOOPBACK_MODE_INCLUDE_TARGET_PROCESS_TREE = PROCESS_LOOPBACK_MODE.INCLUDE_TARGET_PROCESS_TREE;
pub const PROCESS_LOOPBACK_MODE_EXCLUDE_TARGET_PROCESS_TREE = PROCESS_LOOPBACK_MODE.EXCLUDE_TARGET_PROCESS_TREE;

pub const AUDIOCLIENT_PROCESS_LOOPBACK_PARAMS = extern struct {
    TargetProcessId: u32,
    ProcessLoopbackMode: PROCESS_LOOPBACK_MODE,
};

pub const AUDIOCLIENT_ACTIVATION_TYPE = enum(i32) {
    DEFAULT = 0,
    PROCESS_LOOPBACK = 1,
};
pub const AUDIOCLIENT_ACTIVATION_TYPE_DEFAULT = AUDIOCLIENT_ACTIVATION_TYPE.DEFAULT;
pub const AUDIOCLIENT_ACTIVATION_TYPE_PROCESS_LOOPBACK = AUDIOCLIENT_ACTIVATION_TYPE.PROCESS_LOOPBACK;

pub const AUDIOCLIENT_ACTIVATION_PARAMS = extern struct {
    ActivationType: AUDIOCLIENT_ACTIVATION_TYPE,
    Anonymous: extern union {
        ProcessLoopbackParams: AUDIOCLIENT_PROCESS_LOOPBACK_PARAMS,
    },
};

pub const PAudioStateMonitorCallback = fn(
    audioStateMonitor: ?*IAudioStateMonitor,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const AudioStateMonitorSoundLevel = enum(i32) {
    Muted = 0,
    Low = 1,
    Full = 2,
};
pub const Muted = AudioStateMonitorSoundLevel.Muted;
pub const Low = AudioStateMonitorSoundLevel.Low;
pub const Full = AudioStateMonitorSoundLevel.Full;

const IID_IAudioStateMonitor_Value = @import("../zig.zig").Guid.initString("63bd8738-e30d-4c77-bf5c-834e87c657e2");
pub const IID_IAudioStateMonitor = &IID_IAudioStateMonitor_Value;
pub const IAudioStateMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCallback: fn(
            self: *const IAudioStateMonitor,
            callback: ?PAudioStateMonitorCallback,
            context: ?*anyopaque,
            registration: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterCallback: fn(
            self: *const IAudioStateMonitor,
            registration: i64,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetSoundLevel: fn(
            self: *const IAudioStateMonitor,
        ) callconv(@import("std").os.windows.WINAPI) AudioStateMonitorSoundLevel,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStateMonitor_RegisterCallback(self: *const T, callback: ?PAudioStateMonitorCallback, context: ?*anyopaque, registration: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioStateMonitor.VTable, self.vtable).RegisterCallback(@ptrCast(*const IAudioStateMonitor, self), callback, context, registration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStateMonitor_UnregisterCallback(self: *const T, registration: i64) callconv(.Inline) void {
            return @ptrCast(*const IAudioStateMonitor.VTable, self.vtable).UnregisterCallback(@ptrCast(*const IAudioStateMonitor, self), registration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStateMonitor_GetSoundLevel(self: *const T) callconv(.Inline) AudioStateMonitorSoundLevel {
            return @ptrCast(*const IAudioStateMonitor.VTable, self.vtable).GetSoundLevel(@ptrCast(*const IAudioStateMonitor, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ACMDRIVERENUMCB = fn(
    hadid: ?HACMDRIVERID,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPACMDRIVERPROC = fn(
    param0: usize,
    param1: ?HACMDRIVERID,
    param2: u32,
    param3: LPARAM,
    param4: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const ACMDRIVERDETAILSA = packed struct {
    cbStruct: u32,
    fccType: u32,
    fccComp: u32,
    wMid: u16,
    wPid: u16,
    vdwACM: u32,
    vdwDriver: u32,
    fdwSupport: u32,
    cFormatTags: u32,
    cFilterTags: u32,
    hicon: ?HICON,
    szShortName: [32]CHAR,
    szLongName: [128]CHAR,
    szCopyright: [80]CHAR,
    szLicensing: [128]CHAR,
    szFeatures: [512]CHAR,
};

pub const ACMDRIVERDETAILSW = packed struct {
    cbStruct: u32,
    fccType: u32,
    fccComp: u32,
    wMid: u16,
    wPid: u16,
    vdwACM: u32,
    vdwDriver: u32,
    fdwSupport: u32,
    cFormatTags: u32,
    cFilterTags: u32,
    hicon: ?HICON,
    szShortName: [32]u16,
    szLongName: [128]u16,
    szCopyright: [80]u16,
    szLicensing: [128]u16,
    szFeatures: [512]u16,
};

pub const ACMFORMATTAGDETAILSA = packed struct {
    cbStruct: u32,
    dwFormatTagIndex: u32,
    dwFormatTag: u32,
    cbFormatSize: u32,
    fdwSupport: u32,
    cStandardFormats: u32,
    szFormatTag: [48]CHAR,
};

pub const ACMFORMATTAGDETAILSW = packed struct {
    cbStruct: u32,
    dwFormatTagIndex: u32,
    dwFormatTag: u32,
    cbFormatSize: u32,
    fdwSupport: u32,
    cStandardFormats: u32,
    szFormatTag: [48]u16,
};

pub const ACMFORMATTAGENUMCBA = fn(
    hadid: ?HACMDRIVERID,
    paftd: ?*ACMFORMATTAGDETAILSA,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATTAGENUMCBW = fn(
    hadid: ?HACMDRIVERID,
    paftd: ?*ACMFORMATTAGDETAILSW,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATDETAILSA = packed struct {
    cbStruct: u32,
    dwFormatIndex: u32,
    dwFormatTag: u32,
    fdwSupport: u32,
    pwfx: ?*WAVEFORMATEX,
    cbwfx: u32,
    szFormat: [128]CHAR,
};

pub const tACMFORMATDETAILSW = packed struct {
    cbStruct: u32,
    dwFormatIndex: u32,
    dwFormatTag: u32,
    fdwSupport: u32,
    pwfx: ?*WAVEFORMATEX,
    cbwfx: u32,
    szFormat: [128]u16,
};

pub const ACMFORMATENUMCBA = fn(
    hadid: ?HACMDRIVERID,
    pafd: ?*ACMFORMATDETAILSA,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATENUMCBW = fn(
    hadid: ?HACMDRIVERID,
    pafd: ?*tACMFORMATDETAILSW,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATCHOOSEHOOKPROCA = fn(
    hwnd: ?HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFORMATCHOOSEHOOKPROCW = fn(
    hwnd: ?HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFORMATCHOOSEA = packed struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: ?HWND,
    pwfx: ?*WAVEFORMATEX,
    cbwfx: u32,
    pszTitle: ?[*:0]const u8,
    szFormatTag: [48]CHAR,
    szFormat: [128]CHAR,
    pszName: ?PSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfxEnum: ?*WAVEFORMATEX,
    hInstance: ?HINSTANCE,
    pszTemplateName: ?[*:0]const u8,
    lCustData: LPARAM,
    pfnHook: ?ACMFORMATCHOOSEHOOKPROCA,
};

pub const ACMFORMATCHOOSEW = packed struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: ?HWND,
    pwfx: ?*WAVEFORMATEX,
    cbwfx: u32,
    pszTitle: ?[*:0]const u16,
    szFormatTag: [48]u16,
    szFormat: [128]u16,
    pszName: ?PWSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfxEnum: ?*WAVEFORMATEX,
    hInstance: ?HINSTANCE,
    pszTemplateName: ?[*:0]const u16,
    lCustData: LPARAM,
    pfnHook: ?ACMFORMATCHOOSEHOOKPROCW,
};

pub const ACMFILTERTAGDETAILSA = packed struct {
    cbStruct: u32,
    dwFilterTagIndex: u32,
    dwFilterTag: u32,
    cbFilterSize: u32,
    fdwSupport: u32,
    cStandardFilters: u32,
    szFilterTag: [48]CHAR,
};

pub const ACMFILTERTAGDETAILSW = packed struct {
    cbStruct: u32,
    dwFilterTagIndex: u32,
    dwFilterTag: u32,
    cbFilterSize: u32,
    fdwSupport: u32,
    cStandardFilters: u32,
    szFilterTag: [48]u16,
};

pub const ACMFILTERTAGENUMCBA = fn(
    hadid: ?HACMDRIVERID,
    paftd: ?*ACMFILTERTAGDETAILSA,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERTAGENUMCBW = fn(
    hadid: ?HACMDRIVERID,
    paftd: ?*ACMFILTERTAGDETAILSW,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERDETAILSA = packed struct {
    cbStruct: u32,
    dwFilterIndex: u32,
    dwFilterTag: u32,
    fdwSupport: u32,
    pwfltr: ?*WAVEFILTER,
    cbwfltr: u32,
    szFilter: [128]CHAR,
};

pub const ACMFILTERDETAILSW = packed struct {
    cbStruct: u32,
    dwFilterIndex: u32,
    dwFilterTag: u32,
    fdwSupport: u32,
    pwfltr: ?*WAVEFILTER,
    cbwfltr: u32,
    szFilter: [128]u16,
};

pub const ACMFILTERENUMCBA = fn(
    hadid: ?HACMDRIVERID,
    pafd: ?*ACMFILTERDETAILSA,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERENUMCBW = fn(
    hadid: ?HACMDRIVERID,
    pafd: ?*ACMFILTERDETAILSW,
    dwInstance: usize,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERCHOOSEHOOKPROCA = fn(
    hwnd: ?HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFILTERCHOOSEHOOKPROCW = fn(
    hwnd: ?HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFILTERCHOOSEA = packed struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: ?HWND,
    pwfltr: ?*WAVEFILTER,
    cbwfltr: u32,
    pszTitle: ?[*:0]const u8,
    szFilterTag: [48]CHAR,
    szFilter: [128]CHAR,
    pszName: ?PSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfltrEnum: ?*WAVEFILTER,
    hInstance: ?HINSTANCE,
    pszTemplateName: ?[*:0]const u8,
    lCustData: LPARAM,
    pfnHook: ?ACMFILTERCHOOSEHOOKPROCA,
};

pub const ACMFILTERCHOOSEW = packed struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: ?HWND,
    pwfltr: ?*WAVEFILTER,
    cbwfltr: u32,
    pszTitle: ?[*:0]const u16,
    szFilterTag: [48]u16,
    szFilter: [128]u16,
    pszName: ?PWSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfltrEnum: ?*WAVEFILTER,
    hInstance: ?HINSTANCE,
    pszTemplateName: ?[*:0]const u16,
    lCustData: LPARAM,
    pfnHook: ?ACMFILTERCHOOSEHOOKPROCW,
};


pub const tACMDRVOPENDESCA = packed struct {
    cbStruct: u32,
    fccType: u32,
    fccComp: u32,
    dwVersion: u32,
    dwFlags: u32,
    dwError: u32,
    pszSectionName: ?[*:0]const u8,
    pszAliasName: ?[*:0]const u8,
    dnDevNode: u32,
};

pub const tACMDRVOPENDESCW = packed struct {
    cbStruct: u32,
    fccType: u32,
    fccComp: u32,
    dwVersion: u32,
    dwFlags: u32,
    dwError: u32,
    pszSectionName: ?[*:0]const u16,
    pszAliasName: ?[*:0]const u16,
    dnDevNode: u32,
};

pub const ACMDRVSTREAMINSTANCE = packed struct {
    cbStruct: u32,
    pwfxSrc: ?*WAVEFORMATEX,
    pwfxDst: ?*WAVEFORMATEX,
    pwfltr: ?*WAVEFILTER,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
    fdwDriver: u32,
    dwDriver: usize,
    has: ?HACMSTREAM,
};

pub const ACMDRVSTREAMHEADER = packed struct {
    cbStruct: u32,
    fdwStatus: u32,
    dwUser: usize,
    pbSrc: ?*u8,
    cbSrcLength: u32,
    cbSrcLengthUsed: u32,
    dwSrcUser: usize,
    pbDst: ?*u8,
    cbDstLength: u32,
    cbDstLengthUsed: u32,
    dwDstUser: usize,
    fdwConvert: u32,
    padshNext: ?*ACMDRVSTREAMHEADER,
    fdwDriver: u32,
    dwDriver: usize,
    fdwPrepared: u32,
    dwPrepared: usize,
    pbPreparedSrc: ?*u8,
    cbPreparedSrcLength: u32,
    pbPreparedDst: ?*u8,
    cbPreparedDstLength: u32,
};

pub const ACMDRVSTREAMSIZE = packed struct {
    cbStruct: u32,
    fdwSize: u32,
    cbSrcLength: u32,
    cbDstLength: u32,
};

pub const ACMDRVFORMATSUGGEST = packed struct {
    cbStruct: u32,
    fdwSuggest: u32,
    pwfxSrc: ?*WAVEFORMATEX,
    cbwfxSrc: u32,
    pwfxDst: ?*WAVEFORMATEX,
    cbwfxDst: u32,
};


pub const ACMSTREAMHEADER = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => packed struct {
        cbStruct: u32,
        fdwStatus: u32,
        dwUser: usize,
        pbSrc: ?*u8,
        cbSrcLength: u32,
        cbSrcLengthUsed: u32,
        dwSrcUser: usize,
        pbDst: ?*u8,
        cbDstLength: u32,
        cbDstLengthUsed: u32,
        dwDstUser: usize,
        dwReservedDriver: [15]u32,
    },
    .X86 => packed struct {
        cbStruct: u32,
        fdwStatus: u32,
        dwUser: usize,
        pbSrc: ?*u8,
        cbSrcLength: u32,
        cbSrcLengthUsed: u32,
        dwSrcUser: usize,
        pbDst: ?*u8,
        cbDstLength: u32,
        cbDstLengthUsed: u32,
        dwDstUser: usize,
        dwReservedDriver: [10]u32,
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (158)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterMessageFilter(
    lpMessageFilter: ?*IMessageFilter,
    lplpMessageFilter: ?*?*IMessageFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINMM" fn sndPlaySoundA(
    pszSound: ?[*:0]const u8,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn sndPlaySoundW(
    pszSound: ?[*:0]const u16,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn PlaySoundA(
    pszSound: ?[*:0]const u8,
    hmod: ?HINSTANCE,
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn PlaySoundW(
    pszSound: ?[*:0]const u16,
    hmod: ?HINSTANCE,
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetDevCapsA(
    uDeviceID: usize,
    pwoc: ?*WAVEOUTCAPSA,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetDevCapsW(
    uDeviceID: usize,
    pwoc: ?*WAVEOUTCAPSW,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetVolume(
    hwo: ?HWAVEOUT,
    pdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutSetVolume(
    hwo: ?HWAVEOUT,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutOpen(
    phwo: ?*?HWAVEOUT,
    uDeviceID: u32,
    pwfx: ?*WAVEFORMATEX,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutClose(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutPrepareHeader(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutUnprepareHeader(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutWrite(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutPause(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutRestart(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutReset(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutBreakLoop(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetPosition(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetPitch(
    hwo: ?HWAVEOUT,
    pdwPitch: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutSetPitch(
    hwo: ?HWAVEOUT,
    dwPitch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetPlaybackRate(
    hwo: ?HWAVEOUT,
    pdwRate: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutSetPlaybackRate(
    hwo: ?HWAVEOUT,
    dwRate: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutGetID(
    hwo: ?HWAVEOUT,
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveOutMessage(
    hwo: ?HWAVEOUT,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pwic: ?*WAVEINCAPSA,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pwic: ?*WAVEINCAPSW,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInOpen(
    phwi: ?*?HWAVEIN,
    uDeviceID: u32,
    pwfx: ?*WAVEFORMATEX,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInClose(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInPrepareHeader(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInUnprepareHeader(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInAddBuffer(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInStart(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInStop(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInReset(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInGetPosition(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInGetID(
    hwi: ?HWAVEIN,
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn waveInMessage(
    hwi: ?HWAVEIN,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamOpen(
    phms: ?*?HMIDISTRM,
    puDeviceID: [*]u32,
    cMidi: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamClose(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamProperty(
    hms: ?HMIDISTRM,
    lppropdata: ?*u8,
    dwProperty: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamPosition(
    hms: ?HMIDISTRM,
    // TODO: what to do with BytesParamIndex 2?
    lpmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamOut(
    hms: ?HMIDISTRM,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamPause(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamRestart(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiStreamStop(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiConnect(
    hmi: ?HMIDI,
    hmo: ?HMIDIOUT,
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiDisconnect(
    hmi: ?HMIDI,
    hmo: ?HMIDIOUT,
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmoc: ?*MIDIOUTCAPSA,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmoc: ?*MIDIOUTCAPSW,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetVolume(
    hmo: ?HMIDIOUT,
    pdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutSetVolume(
    hmo: ?HMIDIOUT,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutOpen(
    phmo: ?*?HMIDIOUT,
    uDeviceID: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutClose(
    hmo: ?HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutPrepareHeader(
    hmo: ?HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutUnprepareHeader(
    hmo: ?HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutShortMsg(
    hmo: ?HMIDIOUT,
    dwMsg: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutLongMsg(
    hmo: ?HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutReset(
    hmo: ?HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutCachePatches(
    hmo: ?HMIDIOUT,
    uBank: u32,
    pwpa: *[128]u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutCacheDrumPatches(
    hmo: ?HMIDIOUT,
    uPatch: u32,
    pwkya: *[128]u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutGetID(
    hmo: ?HMIDIOUT,
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiOutMessage(
    hmo: ?HMIDIOUT,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmic: ?*MIDIINCAPSA,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmic: ?*MIDIINCAPSW,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInOpen(
    phmi: ?*?HMIDIIN,
    uDeviceID: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInClose(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInPrepareHeader(
    hmi: ?HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInUnprepareHeader(
    hmi: ?HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInAddBuffer(
    hmi: ?HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInStart(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInStop(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInReset(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInGetID(
    hmi: ?HMIDIIN,
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn midiInMessage(
    hmi: ?HMIDIIN,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pac: ?*AUXCAPSA,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pac: ?*AUXCAPSW,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxSetVolume(
    uDeviceID: u32,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxGetVolume(
    uDeviceID: u32,
    pdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn auxOutMessage(
    uDeviceID: u32,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetDevCapsA(
    uMxId: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmxcaps: ?*MIXERCAPSA,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetDevCapsW(
    uMxId: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmxcaps: ?*MIXERCAPSW,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerOpen(
    phmx: ?*isize,
    uMxId: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerClose(
    hmx: ?HMIXER,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerMessage(
    hmx: ?HMIXER,
    uMsg: u32,
    dwParam1: usize,
    dwParam2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetLineInfoA(
    hmxobj: ?HMIXEROBJ,
    pmxl: ?*MIXERLINEA,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetLineInfoW(
    hmxobj: ?HMIXEROBJ,
    pmxl: ?*MIXERLINEW,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetID(
    hmxobj: ?HMIXEROBJ,
    puMxId: ?*u32,
    fdwId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetLineControlsA(
    hmxobj: ?HMIXEROBJ,
    pmxlc: ?*MIXERLINECONTROLSA,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetLineControlsW(
    hmxobj: ?HMIXEROBJ,
    pmxlc: ?*MIXERLINECONTROLSW,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetControlDetailsA(
    hmxobj: ?HMIXEROBJ,
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerGetControlDetailsW(
    hmxobj: ?HMIXEROBJ,
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "WINMM" fn mixerSetControlDetails(
    hmxobj: ?HMIXEROBJ,
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "MMDevAPI" fn ActivateAudioInterfaceAsync(
    deviceInterfacePath: ?[*:0]const u16,
    riid: ?*const Guid,
    activationParams: ?*PROPVARIANT,
    completionHandler: ?*IActivateAudioInterfaceCompletionHandler,
    activationOperation: ?*?*IActivateAudioInterfaceAsyncOperation,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Windows.Media.MediaControl" fn CreateRenderAudioStateMonitor(
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Windows.Media.MediaControl" fn CreateRenderAudioStateMonitorForCategory(
    category: AUDIO_STREAM_CATEGORY,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Windows.Media.MediaControl" fn CreateRenderAudioStateMonitorForCategoryAndDeviceRole(
    category: AUDIO_STREAM_CATEGORY,
    role: ERole,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Windows.Media.MediaControl" fn CreateRenderAudioStateMonitorForCategoryAndDeviceId(
    category: AUDIO_STREAM_CATEGORY,
    deviceId: ?[*:0]const u16,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Windows.Media.MediaControl" fn CreateCaptureAudioStateMonitor(
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Windows.Media.MediaControl" fn CreateCaptureAudioStateMonitorForCategory(
    category: AUDIO_STREAM_CATEGORY,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Windows.Media.MediaControl" fn CreateCaptureAudioStateMonitorForCategoryAndDeviceRole(
    category: AUDIO_STREAM_CATEGORY,
    role: ERole,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Windows.Media.MediaControl" fn CreateCaptureAudioStateMonitorForCategoryAndDeviceId(
    category: AUDIO_STREAM_CATEGORY,
    deviceId: ?[*:0]const u16,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmGetVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmMetrics(
    hao: ?HACMOBJ,
    uMetric: u32,
    pMetric: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverEnum(
    fnCallback: ?ACMDRIVERENUMCB,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverID(
    hao: ?HACMOBJ,
    phadid: ?*isize,
    fdwDriverID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverAddA(
    phadid: ?*isize,
    hinstModule: ?HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverAddW(
    phadid: ?*isize,
    hinstModule: ?HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverRemove(
    hadid: ?HACMDRIVERID,
    fdwRemove: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverOpen(
    phad: ?*isize,
    hadid: ?HACMDRIVERID,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverClose(
    had: ?HACMDRIVER,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverMessage(
    had: ?HACMDRIVER,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverPriority(
    hadid: ?HACMDRIVERID,
    dwPriority: u32,
    fdwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverDetailsA(
    hadid: ?HACMDRIVERID,
    padd: ?*ACMDRIVERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmDriverDetailsW(
    hadid: ?HACMDRIVERID,
    padd: ?*ACMDRIVERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatTagDetailsA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatTagDetailsW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatTagEnumA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSA,
    fnCallback: ?ACMFORMATTAGENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatTagEnumW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSW,
    fnCallback: ?ACMFORMATTAGENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatDetailsA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFORMATDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatDetailsW(
    had: ?HACMDRIVER,
    pafd: ?*tACMFORMATDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatEnumA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFORMATDETAILSA,
    fnCallback: ?ACMFORMATENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatEnumW(
    had: ?HACMDRIVER,
    pafd: ?*tACMFORMATDETAILSW,
    fnCallback: ?ACMFORMATENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatSuggest(
    had: ?HACMDRIVER,
    pwfxSrc: ?*WAVEFORMATEX,
    pwfxDst: ?*WAVEFORMATEX,
    cbwfxDst: u32,
    fdwSuggest: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatChooseA(
    pafmtc: ?*ACMFORMATCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFormatChooseW(
    pafmtc: ?*ACMFORMATCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterTagDetailsA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterTagDetailsW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterTagEnumA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSA,
    fnCallback: ?ACMFILTERTAGENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterTagEnumW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSW,
    fnCallback: ?ACMFILTERTAGENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterDetailsA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterDetailsW(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterEnumA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSA,
    fnCallback: ?ACMFILTERENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterEnumW(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSW,
    fnCallback: ?ACMFILTERENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterChooseA(
    pafltrc: ?*ACMFILTERCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmFilterChooseW(
    pafltrc: ?*ACMFILTERCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamOpen(
    phas: ?*isize,
    had: ?HACMDRIVER,
    pwfxSrc: ?*WAVEFORMATEX,
    pwfxDst: ?*WAVEFORMATEX,
    pwfltr: ?*WAVEFILTER,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamClose(
    has: ?HACMSTREAM,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamSize(
    has: ?HACMSTREAM,
    cbInput: u32,
    pdwOutputBytes: ?*u32,
    fdwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamReset(
    has: ?HACMSTREAM,
    fdwReset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamMessage(
    has: ?HACMSTREAM,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamConvert(
    has: ?HACMSTREAM,
    pash: ?*ACMSTREAMHEADER,
    fdwConvert: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamPrepareHeader(
    has: ?HACMSTREAM,
    pash: ?*ACMSTREAMHEADER,
    fdwPrepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "MSACM32" fn acmStreamUnprepareHeader(
    has: ?HACMSTREAM,
    pash: ?*ACMSTREAMHEADER,
    fdwUnprepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (56)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WAVEOUTCAPS = thismodule.WAVEOUTCAPSA;
        pub const WAVEOUTCAPS2 = thismodule.WAVEOUTCAPS2A;
        pub const WAVEINCAPS = thismodule.WAVEINCAPSA;
        pub const WAVEINCAPS2 = thismodule.WAVEINCAPS2A;
        pub const MIDIOUTCAPS = thismodule.MIDIOUTCAPSA;
        pub const MIDIOUTCAPS2 = thismodule.MIDIOUTCAPS2A;
        pub const MIDIINCAPS = thismodule.MIDIINCAPSA;
        pub const MIDIINCAPS2 = thismodule.MIDIINCAPS2A;
        pub const AUXCAPS = thismodule.AUXCAPSA;
        pub const AUXCAPS2 = thismodule.AUXCAPS2A;
        pub const MIXERCAPS = thismodule.MIXERCAPSA;
        pub const MIXERCAPS2 = thismodule.MIXERCAPS2A;
        pub const MIXERLINE = thismodule.MIXERLINEA;
        pub const MIXERCONTROL = thismodule.MIXERCONTROLA;
        pub const MIXERLINECONTROLS = thismodule.MIXERLINECONTROLSA;
        pub const MIXERCONTROLDETAILS_LISTTEXT = thismodule.MIXERCONTROLDETAILS_LISTTEXTA;
        pub const ACMDRIVERDETAILS = thismodule.ACMDRIVERDETAILSA;
        pub const ACMFORMATTAGDETAILS = thismodule.ACMFORMATTAGDETAILSA;
        pub const ACMFORMATTAGENUMCB = thismodule.ACMFORMATTAGENUMCBA;
        pub const ACMFORMATENUMCB = thismodule.ACMFORMATENUMCBA;
        pub const ACMFORMATCHOOSEHOOKPROC = thismodule.ACMFORMATCHOOSEHOOKPROCA;
        pub const ACMFORMATCHOOSE = thismodule.ACMFORMATCHOOSEA;
        pub const ACMFILTERTAGDETAILS = thismodule.ACMFILTERTAGDETAILSA;
        pub const ACMFILTERTAGENUMCB = thismodule.ACMFILTERTAGENUMCBA;
        pub const ACMFILTERDETAILS = thismodule.ACMFILTERDETAILSA;
        pub const ACMFILTERENUMCB = thismodule.ACMFILTERENUMCBA;
        pub const ACMFILTERCHOOSEHOOKPROC = thismodule.ACMFILTERCHOOSEHOOKPROCA;
        pub const ACMFILTERCHOOSE = thismodule.ACMFILTERCHOOSEA;
        pub const tACMDRVOPENDESC = thismodule.tACMDRVOPENDESCA;
        pub const sndPlaySound = thismodule.sndPlaySoundA;
        pub const PlaySound = thismodule.PlaySoundA;
        pub const waveOutGetDevCaps = thismodule.waveOutGetDevCapsA;
        pub const waveOutGetErrorText = thismodule.waveOutGetErrorTextA;
        pub const waveInGetDevCaps = thismodule.waveInGetDevCapsA;
        pub const waveInGetErrorText = thismodule.waveInGetErrorTextA;
        pub const midiOutGetDevCaps = thismodule.midiOutGetDevCapsA;
        pub const midiOutGetErrorText = thismodule.midiOutGetErrorTextA;
        pub const midiInGetDevCaps = thismodule.midiInGetDevCapsA;
        pub const midiInGetErrorText = thismodule.midiInGetErrorTextA;
        pub const auxGetDevCaps = thismodule.auxGetDevCapsA;
        pub const mixerGetDevCaps = thismodule.mixerGetDevCapsA;
        pub const mixerGetLineInfo = thismodule.mixerGetLineInfoA;
        pub const mixerGetLineControls = thismodule.mixerGetLineControlsA;
        pub const mixerGetControlDetails = thismodule.mixerGetControlDetailsA;
        pub const acmDriverAdd = thismodule.acmDriverAddA;
        pub const acmDriverDetails = thismodule.acmDriverDetailsA;
        pub const acmFormatTagDetails = thismodule.acmFormatTagDetailsA;
        pub const acmFormatTagEnum = thismodule.acmFormatTagEnumA;
        pub const acmFormatDetails = thismodule.acmFormatDetailsA;
        pub const acmFormatEnum = thismodule.acmFormatEnumA;
        pub const acmFormatChoose = thismodule.acmFormatChooseA;
        pub const acmFilterTagDetails = thismodule.acmFilterTagDetailsA;
        pub const acmFilterTagEnum = thismodule.acmFilterTagEnumA;
        pub const acmFilterDetails = thismodule.acmFilterDetailsA;
        pub const acmFilterEnum = thismodule.acmFilterEnumA;
        pub const acmFilterChoose = thismodule.acmFilterChooseA;
    },
    .wide => struct {
        pub const WAVEOUTCAPS = thismodule.WAVEOUTCAPSW;
        pub const WAVEOUTCAPS2 = thismodule.WAVEOUTCAPS2W;
        pub const WAVEINCAPS = thismodule.WAVEINCAPSW;
        pub const WAVEINCAPS2 = thismodule.WAVEINCAPS2W;
        pub const MIDIOUTCAPS = thismodule.MIDIOUTCAPSW;
        pub const MIDIOUTCAPS2 = thismodule.MIDIOUTCAPS2W;
        pub const MIDIINCAPS = thismodule.MIDIINCAPSW;
        pub const MIDIINCAPS2 = thismodule.MIDIINCAPS2W;
        pub const AUXCAPS = thismodule.AUXCAPSW;
        pub const AUXCAPS2 = thismodule.AUXCAPS2W;
        pub const MIXERCAPS = thismodule.MIXERCAPSW;
        pub const MIXERCAPS2 = thismodule.MIXERCAPS2W;
        pub const MIXERLINE = thismodule.MIXERLINEW;
        pub const MIXERCONTROL = thismodule.MIXERCONTROLW;
        pub const MIXERLINECONTROLS = thismodule.MIXERLINECONTROLSW;
        pub const MIXERCONTROLDETAILS_LISTTEXT = thismodule.MIXERCONTROLDETAILS_LISTTEXTW;
        pub const ACMDRIVERDETAILS = thismodule.ACMDRIVERDETAILSW;
        pub const ACMFORMATTAGDETAILS = thismodule.ACMFORMATTAGDETAILSW;
        pub const ACMFORMATTAGENUMCB = thismodule.ACMFORMATTAGENUMCBW;
        pub const ACMFORMATENUMCB = thismodule.ACMFORMATENUMCBW;
        pub const ACMFORMATCHOOSEHOOKPROC = thismodule.ACMFORMATCHOOSEHOOKPROCW;
        pub const ACMFORMATCHOOSE = thismodule.ACMFORMATCHOOSEW;
        pub const ACMFILTERTAGDETAILS = thismodule.ACMFILTERTAGDETAILSW;
        pub const ACMFILTERTAGENUMCB = thismodule.ACMFILTERTAGENUMCBW;
        pub const ACMFILTERDETAILS = thismodule.ACMFILTERDETAILSW;
        pub const ACMFILTERENUMCB = thismodule.ACMFILTERENUMCBW;
        pub const ACMFILTERCHOOSEHOOKPROC = thismodule.ACMFILTERCHOOSEHOOKPROCW;
        pub const ACMFILTERCHOOSE = thismodule.ACMFILTERCHOOSEW;
        pub const tACMDRVOPENDESC = thismodule.tACMDRVOPENDESCW;
        pub const sndPlaySound = thismodule.sndPlaySoundW;
        pub const PlaySound = thismodule.PlaySoundW;
        pub const waveOutGetDevCaps = thismodule.waveOutGetDevCapsW;
        pub const waveOutGetErrorText = thismodule.waveOutGetErrorTextW;
        pub const waveInGetDevCaps = thismodule.waveInGetDevCapsW;
        pub const waveInGetErrorText = thismodule.waveInGetErrorTextW;
        pub const midiOutGetDevCaps = thismodule.midiOutGetDevCapsW;
        pub const midiOutGetErrorText = thismodule.midiOutGetErrorTextW;
        pub const midiInGetDevCaps = thismodule.midiInGetDevCapsW;
        pub const midiInGetErrorText = thismodule.midiInGetErrorTextW;
        pub const auxGetDevCaps = thismodule.auxGetDevCapsW;
        pub const mixerGetDevCaps = thismodule.mixerGetDevCapsW;
        pub const mixerGetLineInfo = thismodule.mixerGetLineInfoW;
        pub const mixerGetLineControls = thismodule.mixerGetLineControlsW;
        pub const mixerGetControlDetails = thismodule.mixerGetControlDetailsW;
        pub const acmDriverAdd = thismodule.acmDriverAddW;
        pub const acmDriverDetails = thismodule.acmDriverDetailsW;
        pub const acmFormatTagDetails = thismodule.acmFormatTagDetailsW;
        pub const acmFormatTagEnum = thismodule.acmFormatTagEnumW;
        pub const acmFormatDetails = thismodule.acmFormatDetailsW;
        pub const acmFormatEnum = thismodule.acmFormatEnumW;
        pub const acmFormatChoose = thismodule.acmFormatChooseW;
        pub const acmFilterTagDetails = thismodule.acmFilterTagDetailsW;
        pub const acmFilterTagEnum = thismodule.acmFilterTagEnumW;
        pub const acmFilterDetails = thismodule.acmFilterDetailsW;
        pub const acmFilterEnum = thismodule.acmFilterEnumW;
        pub const acmFilterChoose = thismodule.acmFilterChooseW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const WAVEOUTCAPS = *opaque{};
        pub const WAVEOUTCAPS2 = *opaque{};
        pub const WAVEINCAPS = *opaque{};
        pub const WAVEINCAPS2 = *opaque{};
        pub const MIDIOUTCAPS = *opaque{};
        pub const MIDIOUTCAPS2 = *opaque{};
        pub const MIDIINCAPS = *opaque{};
        pub const MIDIINCAPS2 = *opaque{};
        pub const AUXCAPS = *opaque{};
        pub const AUXCAPS2 = *opaque{};
        pub const MIXERCAPS = *opaque{};
        pub const MIXERCAPS2 = *opaque{};
        pub const MIXERLINE = *opaque{};
        pub const MIXERCONTROL = *opaque{};
        pub const MIXERLINECONTROLS = *opaque{};
        pub const MIXERCONTROLDETAILS_LISTTEXT = *opaque{};
        pub const ACMDRIVERDETAILS = *opaque{};
        pub const ACMFORMATTAGDETAILS = *opaque{};
        pub const ACMFORMATTAGENUMCB = *opaque{};
        pub const ACMFORMATENUMCB = *opaque{};
        pub const ACMFORMATCHOOSEHOOKPROC = *opaque{};
        pub const ACMFORMATCHOOSE = *opaque{};
        pub const ACMFILTERTAGDETAILS = *opaque{};
        pub const ACMFILTERTAGENUMCB = *opaque{};
        pub const ACMFILTERDETAILS = *opaque{};
        pub const ACMFILTERENUMCB = *opaque{};
        pub const ACMFILTERCHOOSEHOOKPROC = *opaque{};
        pub const ACMFILTERCHOOSE = *opaque{};
        pub const tACMDRVOPENDESC = *opaque{};
        pub const sndPlaySound = *opaque{};
        pub const PlaySound = *opaque{};
        pub const waveOutGetDevCaps = *opaque{};
        pub const waveOutGetErrorText = *opaque{};
        pub const waveInGetDevCaps = *opaque{};
        pub const waveInGetErrorText = *opaque{};
        pub const midiOutGetDevCaps = *opaque{};
        pub const midiOutGetErrorText = *opaque{};
        pub const midiInGetDevCaps = *opaque{};
        pub const midiInGetErrorText = *opaque{};
        pub const auxGetDevCaps = *opaque{};
        pub const mixerGetDevCaps = *opaque{};
        pub const mixerGetLineInfo = *opaque{};
        pub const mixerGetLineControls = *opaque{};
        pub const mixerGetControlDetails = *opaque{};
        pub const acmDriverAdd = *opaque{};
        pub const acmDriverDetails = *opaque{};
        pub const acmFormatTagDetails = *opaque{};
        pub const acmFormatTagEnum = *opaque{};
        pub const acmFormatDetails = *opaque{};
        pub const acmFormatEnum = *opaque{};
        pub const acmFormatChoose = *opaque{};
        pub const acmFilterTagDetails = *opaque{};
        pub const acmFilterTagEnum = *opaque{};
        pub const acmFilterDetails = *opaque{};
        pub const acmFilterEnum = *opaque{};
        pub const acmFilterChoose = *opaque{};
    } else struct {
        pub const WAVEOUTCAPS = @compileError("'WAVEOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEOUTCAPS2 = @compileError("'WAVEOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS = @compileError("'WAVEINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS2 = @compileError("'WAVEINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS = @compileError("'MIDIOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS2 = @compileError("'MIDIOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS = @compileError("'MIDIINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS2 = @compileError("'MIDIINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS = @compileError("'AUXCAPS' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS2 = @compileError("'AUXCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS = @compileError("'MIXERCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS2 = @compileError("'MIXERCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINE = @compileError("'MIXERLINE' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROL = @compileError("'MIXERCONTROL' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINECONTROLS = @compileError("'MIXERLINECONTROLS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROLDETAILS_LISTTEXT = @compileError("'MIXERCONTROLDETAILS_LISTTEXT' requires that UNICODE be set to true or false in the root module");
        pub const ACMDRIVERDETAILS = @compileError("'ACMDRIVERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGDETAILS = @compileError("'ACMFORMATTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGENUMCB = @compileError("'ACMFORMATTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATENUMCB = @compileError("'ACMFORMATENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSEHOOKPROC = @compileError("'ACMFORMATCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSE = @compileError("'ACMFORMATCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGDETAILS = @compileError("'ACMFILTERTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGENUMCB = @compileError("'ACMFILTERTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERDETAILS = @compileError("'ACMFILTERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERENUMCB = @compileError("'ACMFILTERENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSEHOOKPROC = @compileError("'ACMFILTERCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSE = @compileError("'ACMFILTERCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const tACMDRVOPENDESC = @compileError("'tACMDRVOPENDESC' requires that UNICODE be set to true or false in the root module");
        pub const sndPlaySound = @compileError("'sndPlaySound' requires that UNICODE be set to true or false in the root module");
        pub const PlaySound = @compileError("'PlaySound' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetDevCaps = @compileError("'waveOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetErrorText = @compileError("'waveOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetDevCaps = @compileError("'waveInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetErrorText = @compileError("'waveInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetDevCaps = @compileError("'midiOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetErrorText = @compileError("'midiOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetDevCaps = @compileError("'midiInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetErrorText = @compileError("'midiInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const auxGetDevCaps = @compileError("'auxGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetDevCaps = @compileError("'mixerGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineInfo = @compileError("'mixerGetLineInfo' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineControls = @compileError("'mixerGetLineControls' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetControlDetails = @compileError("'mixerGetControlDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverAdd = @compileError("'acmDriverAdd' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverDetails = @compileError("'acmDriverDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagDetails = @compileError("'acmFormatTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagEnum = @compileError("'acmFormatTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatDetails = @compileError("'acmFormatDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatEnum = @compileError("'acmFormatEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatChoose = @compileError("'acmFormatChoose' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagDetails = @compileError("'acmFilterTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagEnum = @compileError("'acmFilterTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterDetails = @compileError("'acmFilterDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterEnum = @compileError("'acmFilterEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterChoose = @compileError("'acmFilterChoose' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (21)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const CHAR = @import("../foundation.zig").CHAR;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDRVR = @import("../media/multimedia.zig").HDRVR;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HTASK = @import("../media.zig").HTASK;
const HWND = @import("../foundation.zig").HWND;
const INTERFACEINFO = @import("../system/com.zig").INTERFACEINFO;
const IPropertyStore = @import("../ui/shell/properties_system.zig").IPropertyStore;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const MMTIME = @import("../media.zig").MMTIME;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPWAVECALLBACK")) { _ = LPWAVECALLBACK; }
    if (@hasDecl(@This(), "LPMIDICALLBACK")) { _ = LPMIDICALLBACK; }
    if (@hasDecl(@This(), "PAudioStateMonitorCallback")) { _ = PAudioStateMonitorCallback; }
    if (@hasDecl(@This(), "ACMDRIVERENUMCB")) { _ = ACMDRIVERENUMCB; }
    if (@hasDecl(@This(), "LPACMDRIVERPROC")) { _ = LPACMDRIVERPROC; }
    if (@hasDecl(@This(), "ACMFORMATTAGENUMCBA")) { _ = ACMFORMATTAGENUMCBA; }
    if (@hasDecl(@This(), "ACMFORMATTAGENUMCBW")) { _ = ACMFORMATTAGENUMCBW; }
    if (@hasDecl(@This(), "ACMFORMATENUMCBA")) { _ = ACMFORMATENUMCBA; }
    if (@hasDecl(@This(), "ACMFORMATENUMCBW")) { _ = ACMFORMATENUMCBW; }
    if (@hasDecl(@This(), "ACMFORMATCHOOSEHOOKPROCA")) { _ = ACMFORMATCHOOSEHOOKPROCA; }
    if (@hasDecl(@This(), "ACMFORMATCHOOSEHOOKPROCW")) { _ = ACMFORMATCHOOSEHOOKPROCW; }
    if (@hasDecl(@This(), "ACMFILTERTAGENUMCBA")) { _ = ACMFILTERTAGENUMCBA; }
    if (@hasDecl(@This(), "ACMFILTERTAGENUMCBW")) { _ = ACMFILTERTAGENUMCBW; }
    if (@hasDecl(@This(), "ACMFILTERENUMCBA")) { _ = ACMFILTERENUMCBA; }
    if (@hasDecl(@This(), "ACMFILTERENUMCBW")) { _ = ACMFILTERENUMCBW; }
    if (@hasDecl(@This(), "ACMFILTERCHOOSEHOOKPROCA")) { _ = ACMFILTERCHOOSEHOOKPROCA; }
    if (@hasDecl(@This(), "ACMFILTERCHOOSEHOOKPROCW")) { _ = ACMFILTERCHOOSEHOOKPROCW; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (5)
//--------------------------------------------------------------------------------
pub const apo = @import("audio/apo.zig");
pub const direct_music = @import("audio/direct_music.zig");
pub const direct_sound = @import("audio/direct_sound.zig");
pub const endpoints = @import("audio/endpoints.zig");
pub const xaudio2 = @import("audio/xaudio2.zig");
