//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (151)
//--------------------------------------------------------------------------------
pub const FSRM_DISPID_FEATURE_MASK = @as(u32, 251658240);
pub const FSRM_DISPID_INTERFACE_A_MASK = @as(u32, 15728640);
pub const FSRM_DISPID_INTERFACE_B_MASK = @as(u32, 983040);
pub const FSRM_DISPID_INTERFACE_C_MASK = @as(u32, 61440);
pub const FSRM_DISPID_INTERFACE_D_MASK = @as(u32, 3840);
pub const FSRM_DISPID_IS_PROPERTY = @as(u32, 128);
pub const FSRM_DISPID_METHOD_NUM_MASK = @as(u32, 127);
pub const FSRM_DISPID_FEATURE_GENERAL = @as(u32, 16777216);
pub const FSRM_DISPID_FEATURE_QUOTA = @as(u32, 33554432);
pub const FSRM_DISPID_FEATURE_FILESCREEN = @as(u32, 50331648);
pub const FSRM_DISPID_FEATURE_REPORTS = @as(u32, 67108864);
pub const FSRM_DISPID_FEATURE_CLASSIFICATION = @as(u32, 83886080);
pub const FSRM_DISPID_FEATURE_PIPELINE = @as(u32, 100663296);
pub const FsrmMaxNumberThresholds = @as(u32, 16);
pub const FsrmMinThresholdValue = @as(u32, 1);
pub const FsrmMaxThresholdValue = @as(u32, 250);
pub const FsrmMinQuotaLimit = @as(u32, 1024);
pub const FsrmMaxExcludeFolders = @as(u32, 32);
pub const FsrmMaxNumberPropertyDefinitions = @as(u32, 100);
pub const MessageSizeLimit = @as(u32, 4096);
pub const FsrmDaysNotSpecified = @as(i32, -1);
pub const FSRM_S_PARTIAL_BATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, 283396));
pub const FSRM_S_PARTIAL_CLASSIFICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, 283397));
pub const FSRM_S_CLASSIFICATION_SCAN_FAILURES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 283398));
pub const FSRM_E_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200255));
pub const FSRM_E_INVALID_SCHEDULER_ARGUMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200254));
pub const FSRM_E_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200253));
pub const FSRM_E_PATH_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200252));
pub const FSRM_E_INVALID_USER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200251));
pub const FSRM_E_INVALID_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200250));
pub const FSRM_E_INVALID_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200249));
pub const FSRM_E_INVALID_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200248));
pub const FSRM_E_FAIL_BATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200247));
pub const FSRM_E_INVALID_TEXT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200246));
pub const FSRM_E_INVALID_IMPORT_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200245));
pub const FSRM_E_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200243));
pub const FSRM_E_REQD_PARAM_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200242));
pub const FSRM_E_INVALID_COMBINATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200241));
pub const FSRM_E_DUPLICATE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200240));
pub const FSRM_E_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200239));
pub const FSRM_E_DRIVER_NOT_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200237));
pub const FSRM_E_INSUFFICIENT_DISK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200236));
pub const FSRM_E_VOLUME_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200235));
pub const FSRM_E_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200234));
pub const FSRM_E_INSECURE_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200233));
pub const FSRM_E_INVALID_SMTP_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200232));
pub const FSRM_E_AUTO_QUOTA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 283419));
pub const FSRM_E_EMAIL_NOT_SENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200228));
pub const FSRM_E_INVALID_EMAIL_ADDRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200226));
pub const FSRM_E_FILE_SYSTEM_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200225));
pub const FSRM_E_LONG_CMDLINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200224));
pub const FSRM_E_INVALID_FILEGROUP_DEFINITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200223));
pub const FSRM_E_INVALID_DATASCREEN_DEFINITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200220));
pub const FSRM_E_INVALID_REPORT_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200216));
pub const FSRM_E_INVALID_REPORT_DESC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200215));
pub const FSRM_E_INVALID_FILENAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200214));
pub const FSRM_E_SHADOW_COPY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200212));
pub const FSRM_E_XML_CORRUPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200211));
pub const FSRM_E_CLUSTER_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200210));
pub const FSRM_E_STORE_NOT_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200209));
pub const FSRM_E_NOT_CLUSTER_VOLUME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200208));
pub const FSRM_E_DIFFERENT_CLUSTER_GROUP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200207));
pub const FSRM_E_REPORT_TYPE_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200206));
pub const FSRM_E_REPORT_JOB_ALREADY_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200205));
pub const FSRM_E_REPORT_GENERATION_ERR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200204));
pub const FSRM_E_REPORT_TASK_TRIGGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200203));
pub const FSRM_E_LOADING_DISABLED_MODULE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200202));
pub const FSRM_E_CANNOT_AGGREGATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200201));
pub const FSRM_E_MESSAGE_LIMIT_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200200));
pub const FSRM_E_OBJECT_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200199));
pub const FSRM_E_CANNOT_RENAME_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200198));
pub const FSRM_E_CANNOT_CHANGE_PROPERTY_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200197));
pub const FSRM_E_MAX_PROPERTY_DEFINITIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200196));
pub const FSRM_E_CLASSIFICATION_ALREADY_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200195));
pub const FSRM_E_CLASSIFICATION_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200194));
pub const FSRM_E_FILE_MANAGEMENT_JOB_ALREADY_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200193));
pub const FSRM_E_FILE_MANAGEMENT_JOB_EXPIRATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200192));
pub const FSRM_E_FILE_MANAGEMENT_JOB_CUSTOM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200191));
pub const FSRM_E_FILE_MANAGEMENT_JOB_NOTIFICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200190));
pub const FSRM_E_FILE_OPEN_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200189));
pub const FSRM_E_UNSECURE_LINK_TO_HOSTED_MODULE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200188));
pub const FSRM_E_CACHE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200187));
pub const FSRM_E_CACHE_MODULE_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200186));
pub const FSRM_E_FILE_MANAGEMENT_EXPIRATION_DIR_IN_SCOPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200185));
pub const FSRM_E_FILE_MANAGEMENT_JOB_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200184));
pub const FSRM_E_PROPERTY_DELETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200183));
pub const FSRM_E_LAST_ACCESS_UPDATE_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200176));
pub const FSRM_E_NO_PROPERTY_VALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200175));
pub const FSRM_E_INPROC_MODULE_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200174));
pub const FSRM_E_ENUM_PROPERTIES_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200173));
pub const FSRM_E_SET_PROPERTY_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200172));
pub const FSRM_E_CANNOT_STORE_PROPERTIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200171));
pub const FSRM_E_CANNOT_ALLOW_REPARSE_POINT_TAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200170));
pub const FSRM_E_PARTIAL_CLASSIFICATION_PROPERTY_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200169));
pub const FSRM_E_TEXTREADER_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200168));
pub const FSRM_E_TEXTREADER_IFILTER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200167));
pub const FSRM_E_PERSIST_PROPERTIES_FAILED_ENCRYPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200166));
pub const FSRM_E_TEXTREADER_IFILTER_CLSID_MALFORMED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200160));
pub const FSRM_E_TEXTREADER_STREAM_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200159));
pub const FSRM_E_TEXTREADER_FILENAME_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200158));
pub const FSRM_E_INCOMPATIBLE_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200157));
pub const FSRM_E_FILE_ENCRYPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200156));
pub const FSRM_E_PERSIST_PROPERTIES_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200155));
pub const FSRM_E_VOLUME_OFFLINE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200154));
pub const FSRM_E_FILE_MANAGEMENT_ACTION_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200153));
pub const FSRM_E_FILE_MANAGEMENT_ACTION_GET_EXITCODE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200152));
pub const FSRM_E_MODULE_INVALID_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200151));
pub const FSRM_E_MODULE_INITIALIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200150));
pub const FSRM_E_MODULE_SESSION_INITIALIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200149));
pub const FSRM_E_CLASSIFICATION_SCAN_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200148));
pub const FSRM_E_FILE_MANAGEMENT_JOB_NOT_LEGACY_ACCESSIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200147));
pub const FSRM_E_FILE_MANAGEMENT_JOB_MAX_FILE_CONDITIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200146));
pub const FSRM_E_CANNOT_USE_DEPRECATED_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200145));
pub const FSRM_E_SYNC_TASK_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200144));
pub const FSRM_E_CANNOT_USE_DELETED_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200143));
pub const FSRM_E_INVALID_AD_CLAIM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200142));
pub const FSRM_E_CLASSIFICATION_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200141));
pub const FSRM_E_INVALID_FOLDER_PROPERTY_STORE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200140));
pub const FSRM_E_REBUILDING_FODLER_TYPE_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200139));
pub const FSRM_E_PROPERTY_MUST_APPLY_TO_FILES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200138));
pub const FSRM_E_CLASSIFICATION_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200137));
pub const FSRM_E_CLASSIFICATION_PARTIAL_BATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200136));
pub const FSRM_E_CANNOT_DELETE_SYSTEM_PROPERTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200135));
pub const FSRM_E_FILE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200134));
pub const FSRM_E_ERROR_NOT_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200133));
pub const FSRM_E_CANNOT_CREATE_TEMP_COPY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200132));
pub const FSRM_E_NO_EMAIL_ADDRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200131));
pub const FSRM_E_ADR_MAX_EMAILS_SENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200130));
pub const FSRM_E_PATH_NOT_IN_NAMESPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200129));
pub const FSRM_E_RMS_TEMPLATE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200128));
pub const FSRM_E_SECURE_PROPERTIES_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200127));
pub const FSRM_E_RMS_NO_PROTECTORS_INSTALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200126));
pub const FSRM_E_RMS_NO_PROTECTOR_INSTALLED_FOR_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200125));
pub const FSRM_E_PROPERTY_MUST_APPLY_TO_FOLDERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200124));
pub const FSRM_E_PROPERTY_MUST_BE_SECURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200123));
pub const FSRM_E_PROPERTY_MUST_BE_GLOBAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200122));
pub const FSRM_E_WMI_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200121));
pub const FSRM_E_FILE_MANAGEMENT_JOB_RMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200120));
pub const FSRM_E_SYNC_TASK_HAD_ERRORS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200119));
pub const FSRM_E_ADR_SRV_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200112));
pub const FSRM_E_ADR_PATH_IS_LOCAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200111));
pub const FSRM_E_ADR_NOT_DOMAIN_JOINED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200110));
pub const FSRM_E_CANNOT_REMOVE_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200109));
pub const FSRM_E_FILE_MANAGEMENT_JOB_INVALID_CONTINUOUS_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200108));
pub const FSRM_E_LEGACY_SCHEDULE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200107));
pub const FSRM_E_CSC_PATH_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200106));
pub const FSRM_E_EXPIRATION_PATH_NOT_WRITEABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200105));
pub const FSRM_E_EXPIRATION_PATH_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200104));
pub const FSRM_E_EXPIRATION_VOLUME_NOT_NTFS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200103));
pub const FSRM_E_FILE_MANAGEMENT_JOB_DEPRECATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200102));
pub const FSRM_E_MODULE_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147200101));

//--------------------------------------------------------------------------------
// Section: Types (117)
//--------------------------------------------------------------------------------
pub const FsrmQuotaFlags = enum(i32) {
    Enforce = 256,
    Disable = 512,
    StatusIncomplete = 65536,
    StatusRebuilding = 131072,
};
pub const FsrmQuotaFlags_Enforce = FsrmQuotaFlags.Enforce;
pub const FsrmQuotaFlags_Disable = FsrmQuotaFlags.Disable;
pub const FsrmQuotaFlags_StatusIncomplete = FsrmQuotaFlags.StatusIncomplete;
pub const FsrmQuotaFlags_StatusRebuilding = FsrmQuotaFlags.StatusRebuilding;

pub const FsrmFileScreenFlags = enum(i32) {
    e = 1,
};
pub const FsrmFileScreenFlags_Enforce = FsrmFileScreenFlags.e;

pub const FsrmCollectionState = enum(i32) {
    Fetching = 1,
    Committing = 2,
    Complete = 3,
    Cancelled = 4,
};
pub const FsrmCollectionState_Fetching = FsrmCollectionState.Fetching;
pub const FsrmCollectionState_Committing = FsrmCollectionState.Committing;
pub const FsrmCollectionState_Complete = FsrmCollectionState.Complete;
pub const FsrmCollectionState_Cancelled = FsrmCollectionState.Cancelled;

pub const FsrmEnumOptions = enum(i32) {
    None = 0,
    Asynchronous = 1,
    CheckRecycleBin = 2,
    IncludeClusterNodes = 4,
    IncludeDeprecatedObjects = 8,
};
pub const FsrmEnumOptions_None = FsrmEnumOptions.None;
pub const FsrmEnumOptions_Asynchronous = FsrmEnumOptions.Asynchronous;
pub const FsrmEnumOptions_CheckRecycleBin = FsrmEnumOptions.CheckRecycleBin;
pub const FsrmEnumOptions_IncludeClusterNodes = FsrmEnumOptions.IncludeClusterNodes;
pub const FsrmEnumOptions_IncludeDeprecatedObjects = FsrmEnumOptions.IncludeDeprecatedObjects;

pub const FsrmCommitOptions = enum(i32) {
    None = 0,
    Asynchronous = 1,
};
pub const FsrmCommitOptions_None = FsrmCommitOptions.None;
pub const FsrmCommitOptions_Asynchronous = FsrmCommitOptions.Asynchronous;

pub const FsrmTemplateApplyOptions = enum(i32) {
    Matching = 1,
    All = 2,
};
pub const FsrmTemplateApplyOptions_ApplyToDerivedMatching = FsrmTemplateApplyOptions.Matching;
pub const FsrmTemplateApplyOptions_ApplyToDerivedAll = FsrmTemplateApplyOptions.All;

pub const FsrmActionType = enum(i32) {
    Unknown = 0,
    EventLog = 1,
    Email = 2,
    Command = 3,
    Report = 4,
};
pub const FsrmActionType_Unknown = FsrmActionType.Unknown;
pub const FsrmActionType_EventLog = FsrmActionType.EventLog;
pub const FsrmActionType_Email = FsrmActionType.Email;
pub const FsrmActionType_Command = FsrmActionType.Command;
pub const FsrmActionType_Report = FsrmActionType.Report;

pub const FsrmEventType = enum(i32) {
    Unknown = 0,
    Information = 1,
    Warning = 2,
    Error = 3,
};
pub const FsrmEventType_Unknown = FsrmEventType.Unknown;
pub const FsrmEventType_Information = FsrmEventType.Information;
pub const FsrmEventType_Warning = FsrmEventType.Warning;
pub const FsrmEventType_Error = FsrmEventType.Error;

pub const FsrmAccountType = enum(i32) {
    Unknown = 0,
    NetworkService = 1,
    LocalService = 2,
    LocalSystem = 3,
    InProc = 4,
    External = 5,
    Automatic = 500,
};
pub const FsrmAccountType_Unknown = FsrmAccountType.Unknown;
pub const FsrmAccountType_NetworkService = FsrmAccountType.NetworkService;
pub const FsrmAccountType_LocalService = FsrmAccountType.LocalService;
pub const FsrmAccountType_LocalSystem = FsrmAccountType.LocalSystem;
pub const FsrmAccountType_InProc = FsrmAccountType.InProc;
pub const FsrmAccountType_External = FsrmAccountType.External;
pub const FsrmAccountType_Automatic = FsrmAccountType.Automatic;

pub const FsrmReportType = enum(i32) {
    Unknown = 0,
    LargeFiles = 1,
    FilesByType = 2,
    LeastRecentlyAccessed = 3,
    MostRecentlyAccessed = 4,
    QuotaUsage = 5,
    FilesByOwner = 6,
    ExportReport = 7,
    DuplicateFiles = 8,
    FileScreenAudit = 9,
    FilesByProperty = 10,
    AutomaticClassification = 11,
    Expiration = 12,
    FoldersByProperty = 13,
};
pub const FsrmReportType_Unknown = FsrmReportType.Unknown;
pub const FsrmReportType_LargeFiles = FsrmReportType.LargeFiles;
pub const FsrmReportType_FilesByType = FsrmReportType.FilesByType;
pub const FsrmReportType_LeastRecentlyAccessed = FsrmReportType.LeastRecentlyAccessed;
pub const FsrmReportType_MostRecentlyAccessed = FsrmReportType.MostRecentlyAccessed;
pub const FsrmReportType_QuotaUsage = FsrmReportType.QuotaUsage;
pub const FsrmReportType_FilesByOwner = FsrmReportType.FilesByOwner;
pub const FsrmReportType_ExportReport = FsrmReportType.ExportReport;
pub const FsrmReportType_DuplicateFiles = FsrmReportType.DuplicateFiles;
pub const FsrmReportType_FileScreenAudit = FsrmReportType.FileScreenAudit;
pub const FsrmReportType_FilesByProperty = FsrmReportType.FilesByProperty;
pub const FsrmReportType_AutomaticClassification = FsrmReportType.AutomaticClassification;
pub const FsrmReportType_Expiration = FsrmReportType.Expiration;
pub const FsrmReportType_FoldersByProperty = FsrmReportType.FoldersByProperty;

pub const FsrmReportFormat = enum(i32) {
    Unknown = 0,
    DHtml = 1,
    Html = 2,
    Txt = 3,
    Csv = 4,
    Xml = 5,
};
pub const FsrmReportFormat_Unknown = FsrmReportFormat.Unknown;
pub const FsrmReportFormat_DHtml = FsrmReportFormat.DHtml;
pub const FsrmReportFormat_Html = FsrmReportFormat.Html;
pub const FsrmReportFormat_Txt = FsrmReportFormat.Txt;
pub const FsrmReportFormat_Csv = FsrmReportFormat.Csv;
pub const FsrmReportFormat_Xml = FsrmReportFormat.Xml;

pub const FsrmReportRunningStatus = enum(i32) {
    Unknown = 0,
    NotRunning = 1,
    Queued = 2,
    Running = 3,
};
pub const FsrmReportRunningStatus_Unknown = FsrmReportRunningStatus.Unknown;
pub const FsrmReportRunningStatus_NotRunning = FsrmReportRunningStatus.NotRunning;
pub const FsrmReportRunningStatus_Queued = FsrmReportRunningStatus.Queued;
pub const FsrmReportRunningStatus_Running = FsrmReportRunningStatus.Running;

pub const FsrmReportGenerationContext = enum(i32) {
    Undefined = 1,
    ScheduledReport = 2,
    InteractiveReport = 3,
    IncidentReport = 4,
};
pub const FsrmReportGenerationContext_Undefined = FsrmReportGenerationContext.Undefined;
pub const FsrmReportGenerationContext_ScheduledReport = FsrmReportGenerationContext.ScheduledReport;
pub const FsrmReportGenerationContext_InteractiveReport = FsrmReportGenerationContext.InteractiveReport;
pub const FsrmReportGenerationContext_IncidentReport = FsrmReportGenerationContext.IncidentReport;

pub const FsrmReportFilter = enum(i32) {
    MinSize = 1,
    MinAgeDays = 2,
    MaxAgeDays = 3,
    MinQuotaUsage = 4,
    FileGroups = 5,
    Owners = 6,
    NamePattern = 7,
    Property = 8,
};
pub const FsrmReportFilter_MinSize = FsrmReportFilter.MinSize;
pub const FsrmReportFilter_MinAgeDays = FsrmReportFilter.MinAgeDays;
pub const FsrmReportFilter_MaxAgeDays = FsrmReportFilter.MaxAgeDays;
pub const FsrmReportFilter_MinQuotaUsage = FsrmReportFilter.MinQuotaUsage;
pub const FsrmReportFilter_FileGroups = FsrmReportFilter.FileGroups;
pub const FsrmReportFilter_Owners = FsrmReportFilter.Owners;
pub const FsrmReportFilter_NamePattern = FsrmReportFilter.NamePattern;
pub const FsrmReportFilter_Property = FsrmReportFilter.Property;

pub const FsrmReportLimit = enum(i32) {
    Files = 1,
    FileGroups = 2,
    Owners = 3,
    FilesPerFileGroup = 4,
    FilesPerOwner = 5,
    FilesPerDuplGroup = 6,
    DuplicateGroups = 7,
    Quotas = 8,
    FileScreenEvents = 9,
    PropertyValues = 10,
    FilesPerPropertyValue = 11,
    Folders = 12,
};
pub const FsrmReportLimit_MaxFiles = FsrmReportLimit.Files;
pub const FsrmReportLimit_MaxFileGroups = FsrmReportLimit.FileGroups;
pub const FsrmReportLimit_MaxOwners = FsrmReportLimit.Owners;
pub const FsrmReportLimit_MaxFilesPerFileGroup = FsrmReportLimit.FilesPerFileGroup;
pub const FsrmReportLimit_MaxFilesPerOwner = FsrmReportLimit.FilesPerOwner;
pub const FsrmReportLimit_MaxFilesPerDuplGroup = FsrmReportLimit.FilesPerDuplGroup;
pub const FsrmReportLimit_MaxDuplicateGroups = FsrmReportLimit.DuplicateGroups;
pub const FsrmReportLimit_MaxQuotas = FsrmReportLimit.Quotas;
pub const FsrmReportLimit_MaxFileScreenEvents = FsrmReportLimit.FileScreenEvents;
pub const FsrmReportLimit_MaxPropertyValues = FsrmReportLimit.PropertyValues;
pub const FsrmReportLimit_MaxFilesPerPropertyValue = FsrmReportLimit.FilesPerPropertyValue;
pub const FsrmReportLimit_MaxFolders = FsrmReportLimit.Folders;

pub const FsrmPropertyDefinitionType = enum(i32) {
    Unknown = 0,
    OrderedList = 1,
    MultiChoiceList = 2,
    SingleChoiceList = 3,
    String = 4,
    MultiString = 5,
    Int = 6,
    Bool = 7,
    Date = 8,
};
pub const FsrmPropertyDefinitionType_Unknown = FsrmPropertyDefinitionType.Unknown;
pub const FsrmPropertyDefinitionType_OrderedList = FsrmPropertyDefinitionType.OrderedList;
pub const FsrmPropertyDefinitionType_MultiChoiceList = FsrmPropertyDefinitionType.MultiChoiceList;
pub const FsrmPropertyDefinitionType_SingleChoiceList = FsrmPropertyDefinitionType.SingleChoiceList;
pub const FsrmPropertyDefinitionType_String = FsrmPropertyDefinitionType.String;
pub const FsrmPropertyDefinitionType_MultiString = FsrmPropertyDefinitionType.MultiString;
pub const FsrmPropertyDefinitionType_Int = FsrmPropertyDefinitionType.Int;
pub const FsrmPropertyDefinitionType_Bool = FsrmPropertyDefinitionType.Bool;
pub const FsrmPropertyDefinitionType_Date = FsrmPropertyDefinitionType.Date;

pub const FsrmPropertyDefinitionFlags = enum(i32) {
    Global = 1,
    Deprecated = 2,
    Secure = 4,
};
pub const FsrmPropertyDefinitionFlags_Global = FsrmPropertyDefinitionFlags.Global;
pub const FsrmPropertyDefinitionFlags_Deprecated = FsrmPropertyDefinitionFlags.Deprecated;
pub const FsrmPropertyDefinitionFlags_Secure = FsrmPropertyDefinitionFlags.Secure;

pub const FsrmPropertyDefinitionAppliesTo = enum(i32) {
    iles = 1,
    olders = 2,
};
pub const FsrmPropertyDefinitionAppliesTo_Files = FsrmPropertyDefinitionAppliesTo.iles;
pub const FsrmPropertyDefinitionAppliesTo_Folders = FsrmPropertyDefinitionAppliesTo.olders;

pub const FsrmRuleType = enum(i32) {
    Unknown = 0,
    Classification = 1,
    Generic = 2,
};
pub const FsrmRuleType_Unknown = FsrmRuleType.Unknown;
pub const FsrmRuleType_Classification = FsrmRuleType.Classification;
pub const FsrmRuleType_Generic = FsrmRuleType.Generic;

pub const FsrmRuleFlags = enum(i32) {
    Disabled = 256,
    ClearAutomaticallyClassifiedProperty = 1024,
    ClearManuallyClassifiedProperty = 2048,
    Invalid = 4096,
};
pub const FsrmRuleFlags_Disabled = FsrmRuleFlags.Disabled;
pub const FsrmRuleFlags_ClearAutomaticallyClassifiedProperty = FsrmRuleFlags.ClearAutomaticallyClassifiedProperty;
pub const FsrmRuleFlags_ClearManuallyClassifiedProperty = FsrmRuleFlags.ClearManuallyClassifiedProperty;
pub const FsrmRuleFlags_Invalid = FsrmRuleFlags.Invalid;

pub const FsrmClassificationLoggingFlags = enum(i32) {
    None = 0,
    ClassificationsInLogFile = 1,
    ErrorsInLogFile = 2,
    ClassificationsInSystemLog = 4,
    ErrorsInSystemLog = 8,
};
pub const FsrmClassificationLoggingFlags_None = FsrmClassificationLoggingFlags.None;
pub const FsrmClassificationLoggingFlags_ClassificationsInLogFile = FsrmClassificationLoggingFlags.ClassificationsInLogFile;
pub const FsrmClassificationLoggingFlags_ErrorsInLogFile = FsrmClassificationLoggingFlags.ErrorsInLogFile;
pub const FsrmClassificationLoggingFlags_ClassificationsInSystemLog = FsrmClassificationLoggingFlags.ClassificationsInSystemLog;
pub const FsrmClassificationLoggingFlags_ErrorsInSystemLog = FsrmClassificationLoggingFlags.ErrorsInSystemLog;

pub const FsrmExecutionOption = enum(i32) {
    Unknown = 0,
    EvaluateUnset = 1,
    ReEvaluate_ConsiderExistingValue = 2,
    ReEvaluate_IgnoreExistingValue = 3,
};
pub const FsrmExecutionOption_Unknown = FsrmExecutionOption.Unknown;
pub const FsrmExecutionOption_EvaluateUnset = FsrmExecutionOption.EvaluateUnset;
pub const FsrmExecutionOption_ReEvaluate_ConsiderExistingValue = FsrmExecutionOption.ReEvaluate_ConsiderExistingValue;
pub const FsrmExecutionOption_ReEvaluate_IgnoreExistingValue = FsrmExecutionOption.ReEvaluate_IgnoreExistingValue;

pub const FsrmStorageModuleCaps = enum(i32) {
    Unknown = 0,
    CanGet = 1,
    CanSet = 2,
    CanHandleDirectories = 4,
    CanHandleFiles = 8,
};
pub const FsrmStorageModuleCaps_Unknown = FsrmStorageModuleCaps.Unknown;
pub const FsrmStorageModuleCaps_CanGet = FsrmStorageModuleCaps.CanGet;
pub const FsrmStorageModuleCaps_CanSet = FsrmStorageModuleCaps.CanSet;
pub const FsrmStorageModuleCaps_CanHandleDirectories = FsrmStorageModuleCaps.CanHandleDirectories;
pub const FsrmStorageModuleCaps_CanHandleFiles = FsrmStorageModuleCaps.CanHandleFiles;

pub const FsrmStorageModuleType = enum(i32) {
    Unknown = 0,
    Cache = 1,
    InFile = 2,
    Database = 3,
    System = 100,
};
pub const FsrmStorageModuleType_Unknown = FsrmStorageModuleType.Unknown;
pub const FsrmStorageModuleType_Cache = FsrmStorageModuleType.Cache;
pub const FsrmStorageModuleType_InFile = FsrmStorageModuleType.InFile;
pub const FsrmStorageModuleType_Database = FsrmStorageModuleType.Database;
pub const FsrmStorageModuleType_System = FsrmStorageModuleType.System;

pub const FsrmPropertyBagFlags = enum(i32) {
    UpdatedByClassifier = 1,
    FailedLoadingProperties = 2,
    FailedSavingProperties = 4,
    FailedClassifyingProperties = 8,
};
pub const FsrmPropertyBagFlags_UpdatedByClassifier = FsrmPropertyBagFlags.UpdatedByClassifier;
pub const FsrmPropertyBagFlags_FailedLoadingProperties = FsrmPropertyBagFlags.FailedLoadingProperties;
pub const FsrmPropertyBagFlags_FailedSavingProperties = FsrmPropertyBagFlags.FailedSavingProperties;
pub const FsrmPropertyBagFlags_FailedClassifyingProperties = FsrmPropertyBagFlags.FailedClassifyingProperties;

pub const FsrmPropertyBagField = enum(i32) {
    AccessVolume = 0,
    VolumeGuidName = 1,
};
pub const FsrmPropertyBagField_AccessVolume = FsrmPropertyBagField.AccessVolume;
pub const FsrmPropertyBagField_VolumeGuidName = FsrmPropertyBagField.VolumeGuidName;

pub const FsrmPropertyFlags = enum(i32) {
    None = 0,
    Orphaned = 1,
    RetrievedFromCache = 2,
    RetrievedFromStorage = 4,
    SetByClassifier = 8,
    Deleted = 16,
    Reclassified = 32,
    AggregationFailed = 64,
    Existing = 128,
    FailedLoadingProperties = 256,
    FailedClassifyingProperties = 512,
    FailedSavingProperties = 1024,
    Secure = 2048,
    PolicyDerived = 4096,
    Inherited = 8192,
    Manual = 16384,
    ExplicitValueDeleted = 32768,
    PropertyDeletedFromClear = 65536,
    PropertySourceMask = 14,
    PersistentMask = 20480,
};
pub const FsrmPropertyFlags_None = FsrmPropertyFlags.None;
pub const FsrmPropertyFlags_Orphaned = FsrmPropertyFlags.Orphaned;
pub const FsrmPropertyFlags_RetrievedFromCache = FsrmPropertyFlags.RetrievedFromCache;
pub const FsrmPropertyFlags_RetrievedFromStorage = FsrmPropertyFlags.RetrievedFromStorage;
pub const FsrmPropertyFlags_SetByClassifier = FsrmPropertyFlags.SetByClassifier;
pub const FsrmPropertyFlags_Deleted = FsrmPropertyFlags.Deleted;
pub const FsrmPropertyFlags_Reclassified = FsrmPropertyFlags.Reclassified;
pub const FsrmPropertyFlags_AggregationFailed = FsrmPropertyFlags.AggregationFailed;
pub const FsrmPropertyFlags_Existing = FsrmPropertyFlags.Existing;
pub const FsrmPropertyFlags_FailedLoadingProperties = FsrmPropertyFlags.FailedLoadingProperties;
pub const FsrmPropertyFlags_FailedClassifyingProperties = FsrmPropertyFlags.FailedClassifyingProperties;
pub const FsrmPropertyFlags_FailedSavingProperties = FsrmPropertyFlags.FailedSavingProperties;
pub const FsrmPropertyFlags_Secure = FsrmPropertyFlags.Secure;
pub const FsrmPropertyFlags_PolicyDerived = FsrmPropertyFlags.PolicyDerived;
pub const FsrmPropertyFlags_Inherited = FsrmPropertyFlags.Inherited;
pub const FsrmPropertyFlags_Manual = FsrmPropertyFlags.Manual;
pub const FsrmPropertyFlags_ExplicitValueDeleted = FsrmPropertyFlags.ExplicitValueDeleted;
pub const FsrmPropertyFlags_PropertyDeletedFromClear = FsrmPropertyFlags.PropertyDeletedFromClear;
pub const FsrmPropertyFlags_PropertySourceMask = FsrmPropertyFlags.PropertySourceMask;
pub const FsrmPropertyFlags_PersistentMask = FsrmPropertyFlags.PersistentMask;

pub const FsrmPipelineModuleType = enum(i32) {
    Unknown = 0,
    Storage = 1,
    Classifier = 2,
};
pub const FsrmPipelineModuleType_Unknown = FsrmPipelineModuleType.Unknown;
pub const FsrmPipelineModuleType_Storage = FsrmPipelineModuleType.Storage;
pub const FsrmPipelineModuleType_Classifier = FsrmPipelineModuleType.Classifier;

pub const FsrmGetFilePropertyOptions = enum(i32) {
    None = 0,
    NoRuleEvaluation = 1,
    Persistent = 2,
    FailOnPersistErrors = 4,
    SkipOrphaned = 8,
};
pub const FsrmGetFilePropertyOptions_None = FsrmGetFilePropertyOptions.None;
pub const FsrmGetFilePropertyOptions_NoRuleEvaluation = FsrmGetFilePropertyOptions.NoRuleEvaluation;
pub const FsrmGetFilePropertyOptions_Persistent = FsrmGetFilePropertyOptions.Persistent;
pub const FsrmGetFilePropertyOptions_FailOnPersistErrors = FsrmGetFilePropertyOptions.FailOnPersistErrors;
pub const FsrmGetFilePropertyOptions_SkipOrphaned = FsrmGetFilePropertyOptions.SkipOrphaned;

pub const FsrmFileManagementType = enum(i32) {
    Unknown = 0,
    Expiration = 1,
    Custom = 2,
    Rms = 3,
};
pub const FsrmFileManagementType_Unknown = FsrmFileManagementType.Unknown;
pub const FsrmFileManagementType_Expiration = FsrmFileManagementType.Expiration;
pub const FsrmFileManagementType_Custom = FsrmFileManagementType.Custom;
pub const FsrmFileManagementType_Rms = FsrmFileManagementType.Rms;

pub const FsrmFileManagementLoggingFlags = enum(i32) {
    None = 0,
    Error = 1,
    Information = 2,
    Audit = 4,
};
pub const FsrmFileManagementLoggingFlags_None = FsrmFileManagementLoggingFlags.None;
pub const FsrmFileManagementLoggingFlags_Error = FsrmFileManagementLoggingFlags.Error;
pub const FsrmFileManagementLoggingFlags_Information = FsrmFileManagementLoggingFlags.Information;
pub const FsrmFileManagementLoggingFlags_Audit = FsrmFileManagementLoggingFlags.Audit;

pub const FsrmPropertyConditionType = enum(i32) {
    Unknown = 0,
    Equal = 1,
    NotEqual = 2,
    GreaterThan = 3,
    LessThan = 4,
    Contain = 5,
    Exist = 6,
    NotExist = 7,
    StartWith = 8,
    EndWith = 9,
    ContainedIn = 10,
    PrefixOf = 11,
    SuffixOf = 12,
    MatchesPattern = 13,
};
pub const FsrmPropertyConditionType_Unknown = FsrmPropertyConditionType.Unknown;
pub const FsrmPropertyConditionType_Equal = FsrmPropertyConditionType.Equal;
pub const FsrmPropertyConditionType_NotEqual = FsrmPropertyConditionType.NotEqual;
pub const FsrmPropertyConditionType_GreaterThan = FsrmPropertyConditionType.GreaterThan;
pub const FsrmPropertyConditionType_LessThan = FsrmPropertyConditionType.LessThan;
pub const FsrmPropertyConditionType_Contain = FsrmPropertyConditionType.Contain;
pub const FsrmPropertyConditionType_Exist = FsrmPropertyConditionType.Exist;
pub const FsrmPropertyConditionType_NotExist = FsrmPropertyConditionType.NotExist;
pub const FsrmPropertyConditionType_StartWith = FsrmPropertyConditionType.StartWith;
pub const FsrmPropertyConditionType_EndWith = FsrmPropertyConditionType.EndWith;
pub const FsrmPropertyConditionType_ContainedIn = FsrmPropertyConditionType.ContainedIn;
pub const FsrmPropertyConditionType_PrefixOf = FsrmPropertyConditionType.PrefixOf;
pub const FsrmPropertyConditionType_SuffixOf = FsrmPropertyConditionType.SuffixOf;
pub const FsrmPropertyConditionType_MatchesPattern = FsrmPropertyConditionType.MatchesPattern;

pub const FsrmFileStreamingMode = enum(i32) {
    Unknown = 0,
    Read = 1,
    Write = 2,
};
pub const FsrmFileStreamingMode_Unknown = FsrmFileStreamingMode.Unknown;
pub const FsrmFileStreamingMode_Read = FsrmFileStreamingMode.Read;
pub const FsrmFileStreamingMode_Write = FsrmFileStreamingMode.Write;

pub const FsrmFileStreamingInterfaceType = enum(i32) {
    Unknown = 0,
    ILockBytes = 1,
    IStream = 2,
};
pub const FsrmFileStreamingInterfaceType_Unknown = FsrmFileStreamingInterfaceType.Unknown;
pub const FsrmFileStreamingInterfaceType_ILockBytes = FsrmFileStreamingInterfaceType.ILockBytes;
pub const FsrmFileStreamingInterfaceType_IStream = FsrmFileStreamingInterfaceType.IStream;

pub const FsrmFileConditionType = enum(i32) {
    Unknown = 0,
    Property = 1,
};
pub const FsrmFileConditionType_Unknown = FsrmFileConditionType.Unknown;
pub const FsrmFileConditionType_Property = FsrmFileConditionType.Property;

pub const FsrmFileSystemPropertyId = enum(i32) {
    Undefined = 0,
    FileName = 1,
    DateCreated = 2,
    DateLastAccessed = 3,
    DateLastModified = 4,
    DateNow = 5,
};
pub const FsrmFileSystemPropertyId_Undefined = FsrmFileSystemPropertyId.Undefined;
pub const FsrmFileSystemPropertyId_FileName = FsrmFileSystemPropertyId.FileName;
pub const FsrmFileSystemPropertyId_DateCreated = FsrmFileSystemPropertyId.DateCreated;
pub const FsrmFileSystemPropertyId_DateLastAccessed = FsrmFileSystemPropertyId.DateLastAccessed;
pub const FsrmFileSystemPropertyId_DateLastModified = FsrmFileSystemPropertyId.DateLastModified;
pub const FsrmFileSystemPropertyId_DateNow = FsrmFileSystemPropertyId.DateNow;

pub const FsrmPropertyValueType = enum(i32) {
    Undefined = 0,
    Literal = 1,
    DateOffset = 2,
};
pub const FsrmPropertyValueType_Undefined = FsrmPropertyValueType.Undefined;
pub const FsrmPropertyValueType_Literal = FsrmPropertyValueType.Literal;
pub const FsrmPropertyValueType_DateOffset = FsrmPropertyValueType.DateOffset;

pub const AdrClientDisplayFlags = enum(i32) {
    AllowEmailRequests = 1,
    ShowDeviceTroubleshooting = 2,
};
pub const AdrClientDisplayFlags_AllowEmailRequests = AdrClientDisplayFlags.AllowEmailRequests;
pub const AdrClientDisplayFlags_ShowDeviceTroubleshooting = AdrClientDisplayFlags.ShowDeviceTroubleshooting;

pub const AdrEmailFlags = enum(i32) {
    PutDataOwnerOnToLine = 1,
    PutAdminOnToLine = 2,
    IncludeDeviceClaims = 4,
    IncludeUserInfo = 8,
    GenerateEventLog = 16,
};
pub const AdrEmailFlags_PutDataOwnerOnToLine = AdrEmailFlags.PutDataOwnerOnToLine;
pub const AdrEmailFlags_PutAdminOnToLine = AdrEmailFlags.PutAdminOnToLine;
pub const AdrEmailFlags_IncludeDeviceClaims = AdrEmailFlags.IncludeDeviceClaims;
pub const AdrEmailFlags_IncludeUserInfo = AdrEmailFlags.IncludeUserInfo;
pub const AdrEmailFlags_GenerateEventLog = AdrEmailFlags.GenerateEventLog;

pub const AdrClientErrorType = enum(i32) {
    Unknown = 0,
    AccessDenied = 1,
    FileNotFound = 2,
};
pub const AdrClientErrorType_Unknown = AdrClientErrorType.Unknown;
pub const AdrClientErrorType_AccessDenied = AdrClientErrorType.AccessDenied;
pub const AdrClientErrorType_FileNotFound = AdrClientErrorType.FileNotFound;

pub const AdrClientFlags = enum(i32) {
    None = 0,
    FailForLocalPaths = 1,
    FailIfNotSupportedByServer = 2,
    FailIfNotDomainJoined = 4,
};
pub const AdrClientFlags_None = AdrClientFlags.None;
pub const AdrClientFlags_FailForLocalPaths = AdrClientFlags.FailForLocalPaths;
pub const AdrClientFlags_FailIfNotSupportedByServer = AdrClientFlags.FailIfNotSupportedByServer;
pub const AdrClientFlags_FailIfNotDomainJoined = AdrClientFlags.FailIfNotDomainJoined;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmObject_Value = @import("../zig.zig").Guid.initString("22bcef93-4a3f-4183-89f9-2f8b8a628aee");
pub const IID_IFsrmObject = &IID_IFsrmObject_Value;
pub const IFsrmObject = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: fn(
            self: *const IFsrmObject,
            id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IFsrmObject,
            description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IFsrmObject,
            description: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IFsrmObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IFsrmObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmObject_get_Id(self: *const T, id: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmObject.VTable, self.vtable).get_Id(@ptrCast(*const IFsrmObject, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmObject_get_Description(self: *const T, description: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmObject.VTable, self.vtable).get_Description(@ptrCast(*const IFsrmObject, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmObject_put_Description(self: *const T, description: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmObject.VTable, self.vtable).put_Description(@ptrCast(*const IFsrmObject, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmObject_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmObject.VTable, self.vtable).Delete(@ptrCast(*const IFsrmObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmObject_Commit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmObject.VTable, self.vtable).Commit(@ptrCast(*const IFsrmObject, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmCollection_Value = @import("../zig.zig").Guid.initString("f76fbf3b-8ddd-4b42-b05a-cb1c3ff1fee8");
pub const IID_IFsrmCollection = &IID_IFsrmCollection_Value;
pub const IFsrmCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IFsrmCollection,
            unknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IFsrmCollection,
            index: i32,
            item: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IFsrmCollection,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: fn(
            self: *const IFsrmCollection,
            state: ?*FsrmCollectionState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForCompletion: fn(
            self: *const IFsrmCollection,
            waitSeconds: i32,
            completed: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetById: fn(
            self: *const IFsrmCollection,
            id: Guid,
            entry: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmCollection_get__NewEnum(self: *const T, unknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IFsrmCollection, self), unknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmCollection_get_Item(self: *const T, index: i32, item: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmCollection.VTable, self.vtable).get_Item(@ptrCast(*const IFsrmCollection, self), index, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmCollection_get_Count(self: *const T, count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmCollection.VTable, self.vtable).get_Count(@ptrCast(*const IFsrmCollection, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmCollection_get_State(self: *const T, state: ?*FsrmCollectionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmCollection.VTable, self.vtable).get_State(@ptrCast(*const IFsrmCollection, self), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmCollection_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmCollection.VTable, self.vtable).Cancel(@ptrCast(*const IFsrmCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmCollection_WaitForCompletion(self: *const T, waitSeconds: i32, completed: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmCollection.VTable, self.vtable).WaitForCompletion(@ptrCast(*const IFsrmCollection, self), waitSeconds, completed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmCollection_GetById(self: *const T, id: Guid, entry: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmCollection.VTable, self.vtable).GetById(@ptrCast(*const IFsrmCollection, self), id, entry);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmMutableCollection_Value = @import("../zig.zig").Guid.initString("1bb617b8-3886-49dc-af82-a6c90fa35dda");
pub const IID_IFsrmMutableCollection = &IID_IFsrmMutableCollection_Value;
pub const IFsrmMutableCollection = extern struct {
    pub const VTable = extern struct {
        base: IFsrmCollection.VTable,
        Add: fn(
            self: *const IFsrmMutableCollection,
            item: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IFsrmMutableCollection,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveById: fn(
            self: *const IFsrmMutableCollection,
            id: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IFsrmMutableCollection,
            collection: ?*?*IFsrmMutableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmCollection.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmMutableCollection_Add(self: *const T, item: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmMutableCollection.VTable, self.vtable).Add(@ptrCast(*const IFsrmMutableCollection, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmMutableCollection_Remove(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmMutableCollection.VTable, self.vtable).Remove(@ptrCast(*const IFsrmMutableCollection, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmMutableCollection_RemoveById(self: *const T, id: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmMutableCollection.VTable, self.vtable).RemoveById(@ptrCast(*const IFsrmMutableCollection, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmMutableCollection_Clone(self: *const T, collection: ?*?*IFsrmMutableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmMutableCollection.VTable, self.vtable).Clone(@ptrCast(*const IFsrmMutableCollection, self), collection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmCommittableCollection_Value = @import("../zig.zig").Guid.initString("96deb3b5-8b91-4a2a-9d93-80a35d8aa847");
pub const IID_IFsrmCommittableCollection = &IID_IFsrmCommittableCollection_Value;
pub const IFsrmCommittableCollection = extern struct {
    pub const VTable = extern struct {
        base: IFsrmMutableCollection.VTable,
        Commit: fn(
            self: *const IFsrmCommittableCollection,
            options: FsrmCommitOptions,
            results: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmMutableCollection.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmCommittableCollection_Commit(self: *const T, options: FsrmCommitOptions, results: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmCommittableCollection.VTable, self.vtable).Commit(@ptrCast(*const IFsrmCommittableCollection, self), options, results);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmAction_Value = @import("../zig.zig").Guid.initString("6cd6408a-ae60-463b-9ef1-e117534d69dc");
pub const IID_IFsrmAction = &IID_IFsrmAction_Value;
pub const IFsrmAction = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: fn(
            self: *const IFsrmAction,
            id: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActionType: fn(
            self: *const IFsrmAction,
            actionType: ?*FsrmActionType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunLimitInterval: fn(
            self: *const IFsrmAction,
            minutes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RunLimitInterval: fn(
            self: *const IFsrmAction,
            minutes: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IFsrmAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmAction_get_Id(self: *const T, id: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmAction.VTable, self.vtable).get_Id(@ptrCast(*const IFsrmAction, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmAction_get_ActionType(self: *const T, actionType: ?*FsrmActionType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmAction.VTable, self.vtable).get_ActionType(@ptrCast(*const IFsrmAction, self), actionType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmAction_get_RunLimitInterval(self: *const T, minutes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmAction.VTable, self.vtable).get_RunLimitInterval(@ptrCast(*const IFsrmAction, self), minutes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmAction_put_RunLimitInterval(self: *const T, minutes: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmAction.VTable, self.vtable).put_RunLimitInterval(@ptrCast(*const IFsrmAction, self), minutes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmAction_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmAction.VTable, self.vtable).Delete(@ptrCast(*const IFsrmAction, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmActionEmail_Value = @import("../zig.zig").Guid.initString("d646567d-26ae-4caa-9f84-4e0aad207fca");
pub const IID_IFsrmActionEmail = &IID_IFsrmActionEmail_Value;
pub const IFsrmActionEmail = extern struct {
    pub const VTable = extern struct {
        base: IFsrmAction.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailFrom: fn(
            self: *const IFsrmActionEmail,
            mailFrom: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailFrom: fn(
            self: *const IFsrmActionEmail,
            mailFrom: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailReplyTo: fn(
            self: *const IFsrmActionEmail,
            mailReplyTo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailReplyTo: fn(
            self: *const IFsrmActionEmail,
            mailReplyTo: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailTo: fn(
            self: *const IFsrmActionEmail,
            mailTo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailTo: fn(
            self: *const IFsrmActionEmail,
            mailTo: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailCc: fn(
            self: *const IFsrmActionEmail,
            mailCc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailCc: fn(
            self: *const IFsrmActionEmail,
            mailCc: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailBcc: fn(
            self: *const IFsrmActionEmail,
            mailBcc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailBcc: fn(
            self: *const IFsrmActionEmail,
            mailBcc: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailSubject: fn(
            self: *const IFsrmActionEmail,
            mailSubject: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailSubject: fn(
            self: *const IFsrmActionEmail,
            mailSubject: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MessageText: fn(
            self: *const IFsrmActionEmail,
            messageText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MessageText: fn(
            self: *const IFsrmActionEmail,
            messageText: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmAction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_get_MailFrom(self: *const T, mailFrom: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).get_MailFrom(@ptrCast(*const IFsrmActionEmail, self), mailFrom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_put_MailFrom(self: *const T, mailFrom: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).put_MailFrom(@ptrCast(*const IFsrmActionEmail, self), mailFrom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_get_MailReplyTo(self: *const T, mailReplyTo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).get_MailReplyTo(@ptrCast(*const IFsrmActionEmail, self), mailReplyTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_put_MailReplyTo(self: *const T, mailReplyTo: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).put_MailReplyTo(@ptrCast(*const IFsrmActionEmail, self), mailReplyTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_get_MailTo(self: *const T, mailTo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).get_MailTo(@ptrCast(*const IFsrmActionEmail, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_put_MailTo(self: *const T, mailTo: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).put_MailTo(@ptrCast(*const IFsrmActionEmail, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_get_MailCc(self: *const T, mailCc: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).get_MailCc(@ptrCast(*const IFsrmActionEmail, self), mailCc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_put_MailCc(self: *const T, mailCc: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).put_MailCc(@ptrCast(*const IFsrmActionEmail, self), mailCc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_get_MailBcc(self: *const T, mailBcc: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).get_MailBcc(@ptrCast(*const IFsrmActionEmail, self), mailBcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_put_MailBcc(self: *const T, mailBcc: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).put_MailBcc(@ptrCast(*const IFsrmActionEmail, self), mailBcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_get_MailSubject(self: *const T, mailSubject: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).get_MailSubject(@ptrCast(*const IFsrmActionEmail, self), mailSubject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_put_MailSubject(self: *const T, mailSubject: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).put_MailSubject(@ptrCast(*const IFsrmActionEmail, self), mailSubject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_get_MessageText(self: *const T, messageText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).get_MessageText(@ptrCast(*const IFsrmActionEmail, self), messageText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail_put_MessageText(self: *const T, messageText: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail.VTable, self.vtable).put_MessageText(@ptrCast(*const IFsrmActionEmail, self), messageText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmActionEmail2_Value = @import("../zig.zig").Guid.initString("8276702f-2532-4839-89bf-4872609a2ea4");
pub const IID_IFsrmActionEmail2 = &IID_IFsrmActionEmail2_Value;
pub const IFsrmActionEmail2 = extern struct {
    pub const VTable = extern struct {
        base: IFsrmActionEmail.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttachmentFileListSize: fn(
            self: *const IFsrmActionEmail2,
            attachmentFileListSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AttachmentFileListSize: fn(
            self: *const IFsrmActionEmail2,
            attachmentFileListSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmActionEmail.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail2_get_AttachmentFileListSize(self: *const T, attachmentFileListSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail2.VTable, self.vtable).get_AttachmentFileListSize(@ptrCast(*const IFsrmActionEmail2, self), attachmentFileListSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEmail2_put_AttachmentFileListSize(self: *const T, attachmentFileListSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEmail2.VTable, self.vtable).put_AttachmentFileListSize(@ptrCast(*const IFsrmActionEmail2, self), attachmentFileListSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmActionReport_Value = @import("../zig.zig").Guid.initString("2dbe63c4-b340-48a0-a5b0-158e07fc567e");
pub const IID_IFsrmActionReport = &IID_IFsrmActionReport_Value;
pub const IFsrmActionReport = extern struct {
    pub const VTable = extern struct {
        base: IFsrmAction.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReportTypes: fn(
            self: *const IFsrmActionReport,
            reportTypes: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReportTypes: fn(
            self: *const IFsrmActionReport,
            reportTypes: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailTo: fn(
            self: *const IFsrmActionReport,
            mailTo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailTo: fn(
            self: *const IFsrmActionReport,
            mailTo: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmAction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionReport_get_ReportTypes(self: *const T, reportTypes: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionReport.VTable, self.vtable).get_ReportTypes(@ptrCast(*const IFsrmActionReport, self), reportTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionReport_put_ReportTypes(self: *const T, reportTypes: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionReport.VTable, self.vtable).put_ReportTypes(@ptrCast(*const IFsrmActionReport, self), reportTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionReport_get_MailTo(self: *const T, mailTo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionReport.VTable, self.vtable).get_MailTo(@ptrCast(*const IFsrmActionReport, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionReport_put_MailTo(self: *const T, mailTo: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionReport.VTable, self.vtable).put_MailTo(@ptrCast(*const IFsrmActionReport, self), mailTo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmActionEventLog_Value = @import("../zig.zig").Guid.initString("4c8f96c3-5d94-4f37-a4f4-f56ab463546f");
pub const IID_IFsrmActionEventLog = &IID_IFsrmActionEventLog_Value;
pub const IFsrmActionEventLog = extern struct {
    pub const VTable = extern struct {
        base: IFsrmAction.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EventType: fn(
            self: *const IFsrmActionEventLog,
            eventType: ?*FsrmEventType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EventType: fn(
            self: *const IFsrmActionEventLog,
            eventType: FsrmEventType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MessageText: fn(
            self: *const IFsrmActionEventLog,
            messageText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MessageText: fn(
            self: *const IFsrmActionEventLog,
            messageText: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmAction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEventLog_get_EventType(self: *const T, eventType: ?*FsrmEventType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEventLog.VTable, self.vtable).get_EventType(@ptrCast(*const IFsrmActionEventLog, self), eventType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEventLog_put_EventType(self: *const T, eventType: FsrmEventType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEventLog.VTable, self.vtable).put_EventType(@ptrCast(*const IFsrmActionEventLog, self), eventType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEventLog_get_MessageText(self: *const T, messageText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEventLog.VTable, self.vtable).get_MessageText(@ptrCast(*const IFsrmActionEventLog, self), messageText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionEventLog_put_MessageText(self: *const T, messageText: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionEventLog.VTable, self.vtable).put_MessageText(@ptrCast(*const IFsrmActionEventLog, self), messageText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmActionCommand_Value = @import("../zig.zig").Guid.initString("12937789-e247-4917-9c20-f3ee9c7ee783");
pub const IID_IFsrmActionCommand = &IID_IFsrmActionCommand_Value;
pub const IFsrmActionCommand = extern struct {
    pub const VTable = extern struct {
        base: IFsrmAction.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExecutablePath: fn(
            self: *const IFsrmActionCommand,
            executablePath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExecutablePath: fn(
            self: *const IFsrmActionCommand,
            executablePath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Arguments: fn(
            self: *const IFsrmActionCommand,
            arguments: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Arguments: fn(
            self: *const IFsrmActionCommand,
            arguments: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Account: fn(
            self: *const IFsrmActionCommand,
            account: ?*FsrmAccountType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Account: fn(
            self: *const IFsrmActionCommand,
            account: FsrmAccountType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WorkingDirectory: fn(
            self: *const IFsrmActionCommand,
            workingDirectory: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WorkingDirectory: fn(
            self: *const IFsrmActionCommand,
            workingDirectory: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MonitorCommand: fn(
            self: *const IFsrmActionCommand,
            monitorCommand: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MonitorCommand: fn(
            self: *const IFsrmActionCommand,
            monitorCommand: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KillTimeOut: fn(
            self: *const IFsrmActionCommand,
            minutes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KillTimeOut: fn(
            self: *const IFsrmActionCommand,
            minutes: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogResult: fn(
            self: *const IFsrmActionCommand,
            logResults: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LogResult: fn(
            self: *const IFsrmActionCommand,
            logResults: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmAction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_get_ExecutablePath(self: *const T, executablePath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).get_ExecutablePath(@ptrCast(*const IFsrmActionCommand, self), executablePath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_put_ExecutablePath(self: *const T, executablePath: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).put_ExecutablePath(@ptrCast(*const IFsrmActionCommand, self), executablePath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_get_Arguments(self: *const T, arguments: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).get_Arguments(@ptrCast(*const IFsrmActionCommand, self), arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_put_Arguments(self: *const T, arguments: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).put_Arguments(@ptrCast(*const IFsrmActionCommand, self), arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_get_Account(self: *const T, account: ?*FsrmAccountType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).get_Account(@ptrCast(*const IFsrmActionCommand, self), account);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_put_Account(self: *const T, account: FsrmAccountType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).put_Account(@ptrCast(*const IFsrmActionCommand, self), account);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_get_WorkingDirectory(self: *const T, workingDirectory: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).get_WorkingDirectory(@ptrCast(*const IFsrmActionCommand, self), workingDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_put_WorkingDirectory(self: *const T, workingDirectory: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).put_WorkingDirectory(@ptrCast(*const IFsrmActionCommand, self), workingDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_get_MonitorCommand(self: *const T, monitorCommand: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).get_MonitorCommand(@ptrCast(*const IFsrmActionCommand, self), monitorCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_put_MonitorCommand(self: *const T, monitorCommand: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).put_MonitorCommand(@ptrCast(*const IFsrmActionCommand, self), monitorCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_get_KillTimeOut(self: *const T, minutes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).get_KillTimeOut(@ptrCast(*const IFsrmActionCommand, self), minutes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_put_KillTimeOut(self: *const T, minutes: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).put_KillTimeOut(@ptrCast(*const IFsrmActionCommand, self), minutes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_get_LogResult(self: *const T, logResults: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).get_LogResult(@ptrCast(*const IFsrmActionCommand, self), logResults);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmActionCommand_put_LogResult(self: *const T, logResults: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmActionCommand.VTable, self.vtable).put_LogResult(@ptrCast(*const IFsrmActionCommand, self), logResults);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmSetting_Value = @import("../zig.zig").Guid.initString("f411d4fd-14be-4260-8c40-03b7c95e608a");
pub const IID_IFsrmSetting = &IID_IFsrmSetting_Value;
pub const IFsrmSetting = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SmtpServer: fn(
            self: *const IFsrmSetting,
            smtpServer: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SmtpServer: fn(
            self: *const IFsrmSetting,
            smtpServer: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailFrom: fn(
            self: *const IFsrmSetting,
            mailFrom: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailFrom: fn(
            self: *const IFsrmSetting,
            mailFrom: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AdminEmail: fn(
            self: *const IFsrmSetting,
            adminEmail: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AdminEmail: fn(
            self: *const IFsrmSetting,
            adminEmail: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisableCommandLine: fn(
            self: *const IFsrmSetting,
            disableCommandLine: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisableCommandLine: fn(
            self: *const IFsrmSetting,
            disableCommandLine: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableScreeningAudit: fn(
            self: *const IFsrmSetting,
            enableScreeningAudit: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableScreeningAudit: fn(
            self: *const IFsrmSetting,
            enableScreeningAudit: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EmailTest: fn(
            self: *const IFsrmSetting,
            mailTo: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActionRunLimitInterval: fn(
            self: *const IFsrmSetting,
            actionType: FsrmActionType,
            delayTimeMinutes: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActionRunLimitInterval: fn(
            self: *const IFsrmSetting,
            actionType: FsrmActionType,
            delayTimeMinutes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_get_SmtpServer(self: *const T, smtpServer: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).get_SmtpServer(@ptrCast(*const IFsrmSetting, self), smtpServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_put_SmtpServer(self: *const T, smtpServer: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).put_SmtpServer(@ptrCast(*const IFsrmSetting, self), smtpServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_get_MailFrom(self: *const T, mailFrom: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).get_MailFrom(@ptrCast(*const IFsrmSetting, self), mailFrom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_put_MailFrom(self: *const T, mailFrom: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).put_MailFrom(@ptrCast(*const IFsrmSetting, self), mailFrom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_get_AdminEmail(self: *const T, adminEmail: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).get_AdminEmail(@ptrCast(*const IFsrmSetting, self), adminEmail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_put_AdminEmail(self: *const T, adminEmail: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).put_AdminEmail(@ptrCast(*const IFsrmSetting, self), adminEmail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_get_DisableCommandLine(self: *const T, disableCommandLine: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).get_DisableCommandLine(@ptrCast(*const IFsrmSetting, self), disableCommandLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_put_DisableCommandLine(self: *const T, disableCommandLine: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).put_DisableCommandLine(@ptrCast(*const IFsrmSetting, self), disableCommandLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_get_EnableScreeningAudit(self: *const T, enableScreeningAudit: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).get_EnableScreeningAudit(@ptrCast(*const IFsrmSetting, self), enableScreeningAudit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_put_EnableScreeningAudit(self: *const T, enableScreeningAudit: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).put_EnableScreeningAudit(@ptrCast(*const IFsrmSetting, self), enableScreeningAudit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_EmailTest(self: *const T, mailTo: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).EmailTest(@ptrCast(*const IFsrmSetting, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_SetActionRunLimitInterval(self: *const T, actionType: FsrmActionType, delayTimeMinutes: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).SetActionRunLimitInterval(@ptrCast(*const IFsrmSetting, self), actionType, delayTimeMinutes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmSetting_GetActionRunLimitInterval(self: *const T, actionType: FsrmActionType, delayTimeMinutes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmSetting.VTable, self.vtable).GetActionRunLimitInterval(@ptrCast(*const IFsrmSetting, self), actionType, delayTimeMinutes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmPathMapper_Value = @import("../zig.zig").Guid.initString("6f4dbfff-6920-4821-a6c3-b7e94c1fd60c");
pub const IID_IFsrmPathMapper = &IID_IFsrmPathMapper_Value;
pub const IFsrmPathMapper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetSharePathsForLocalPath: fn(
            self: *const IFsrmPathMapper,
            localPath: ?BSTR,
            sharePaths: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPathMapper_GetSharePathsForLocalPath(self: *const T, localPath: ?BSTR, sharePaths: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPathMapper.VTable, self.vtable).GetSharePathsForLocalPath(@ptrCast(*const IFsrmPathMapper, self), localPath, sharePaths);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmExportImport_Value = @import("../zig.zig").Guid.initString("efcb0ab1-16c4-4a79-812c-725614c3306b");
pub const IID_IFsrmExportImport = &IID_IFsrmExportImport_Value;
pub const IFsrmExportImport = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ExportFileGroups: fn(
            self: *const IFsrmExportImport,
            filePath: ?BSTR,
            fileGroupNamesSafeArray: ?*VARIANT,
            remoteHost: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportFileGroups: fn(
            self: *const IFsrmExportImport,
            filePath: ?BSTR,
            fileGroupNamesSafeArray: ?*VARIANT,
            remoteHost: ?BSTR,
            fileGroups: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExportFileScreenTemplates: fn(
            self: *const IFsrmExportImport,
            filePath: ?BSTR,
            templateNamesSafeArray: ?*VARIANT,
            remoteHost: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportFileScreenTemplates: fn(
            self: *const IFsrmExportImport,
            filePath: ?BSTR,
            templateNamesSafeArray: ?*VARIANT,
            remoteHost: ?BSTR,
            templates: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExportQuotaTemplates: fn(
            self: *const IFsrmExportImport,
            filePath: ?BSTR,
            templateNamesSafeArray: ?*VARIANT,
            remoteHost: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportQuotaTemplates: fn(
            self: *const IFsrmExportImport,
            filePath: ?BSTR,
            templateNamesSafeArray: ?*VARIANT,
            remoteHost: ?BSTR,
            templates: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmExportImport_ExportFileGroups(self: *const T, filePath: ?BSTR, fileGroupNamesSafeArray: ?*VARIANT, remoteHost: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmExportImport.VTable, self.vtable).ExportFileGroups(@ptrCast(*const IFsrmExportImport, self), filePath, fileGroupNamesSafeArray, remoteHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmExportImport_ImportFileGroups(self: *const T, filePath: ?BSTR, fileGroupNamesSafeArray: ?*VARIANT, remoteHost: ?BSTR, fileGroups: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmExportImport.VTable, self.vtable).ImportFileGroups(@ptrCast(*const IFsrmExportImport, self), filePath, fileGroupNamesSafeArray, remoteHost, fileGroups);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmExportImport_ExportFileScreenTemplates(self: *const T, filePath: ?BSTR, templateNamesSafeArray: ?*VARIANT, remoteHost: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmExportImport.VTable, self.vtable).ExportFileScreenTemplates(@ptrCast(*const IFsrmExportImport, self), filePath, templateNamesSafeArray, remoteHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmExportImport_ImportFileScreenTemplates(self: *const T, filePath: ?BSTR, templateNamesSafeArray: ?*VARIANT, remoteHost: ?BSTR, templates: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmExportImport.VTable, self.vtable).ImportFileScreenTemplates(@ptrCast(*const IFsrmExportImport, self), filePath, templateNamesSafeArray, remoteHost, templates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmExportImport_ExportQuotaTemplates(self: *const T, filePath: ?BSTR, templateNamesSafeArray: ?*VARIANT, remoteHost: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmExportImport.VTable, self.vtable).ExportQuotaTemplates(@ptrCast(*const IFsrmExportImport, self), filePath, templateNamesSafeArray, remoteHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmExportImport_ImportQuotaTemplates(self: *const T, filePath: ?BSTR, templateNamesSafeArray: ?*VARIANT, remoteHost: ?BSTR, templates: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmExportImport.VTable, self.vtable).ImportQuotaTemplates(@ptrCast(*const IFsrmExportImport, self), filePath, templateNamesSafeArray, remoteHost, templates);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmDerivedObjectsResult_Value = @import("../zig.zig").Guid.initString("39322a2d-38ee-4d0d-8095-421a80849a82");
pub const IID_IFsrmDerivedObjectsResult = &IID_IFsrmDerivedObjectsResult_Value;
pub const IFsrmDerivedObjectsResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DerivedObjects: fn(
            self: *const IFsrmDerivedObjectsResult,
            derivedObjects: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Results: fn(
            self: *const IFsrmDerivedObjectsResult,
            results: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmDerivedObjectsResult_get_DerivedObjects(self: *const T, derivedObjects: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmDerivedObjectsResult.VTable, self.vtable).get_DerivedObjects(@ptrCast(*const IFsrmDerivedObjectsResult, self), derivedObjects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmDerivedObjectsResult_get_Results(self: *const T, results: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmDerivedObjectsResult.VTable, self.vtable).get_Results(@ptrCast(*const IFsrmDerivedObjectsResult, self), results);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IFsrmAccessDeniedRemediationClient_Value = @import("../zig.zig").Guid.initString("40002314-590b-45a5-8e1b-8c05da527e52");
pub const IID_IFsrmAccessDeniedRemediationClient = &IID_IFsrmAccessDeniedRemediationClient_Value;
pub const IFsrmAccessDeniedRemediationClient = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Show: fn(
            self: *const IFsrmAccessDeniedRemediationClient,
            parentWnd: usize,
            accessPath: ?BSTR,
            errorType: AdrClientErrorType,
            flags: i32,
            windowTitle: ?BSTR,
            windowMessage: ?BSTR,
            result: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmAccessDeniedRemediationClient_Show(self: *const T, parentWnd: usize, accessPath: ?BSTR, errorType: AdrClientErrorType, flags: i32, windowTitle: ?BSTR, windowMessage: ?BSTR, result: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmAccessDeniedRemediationClient.VTable, self.vtable).Show(@ptrCast(*const IFsrmAccessDeniedRemediationClient, self), parentWnd, accessPath, errorType, flags, windowTitle, windowMessage, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_FsrmSetting_Value = @import("../zig.zig").Guid.initString("f556d708-6d4d-4594-9c61-7dbb0dae2a46");
pub const CLSID_FsrmSetting = &CLSID_FsrmSetting_Value;

const CLSID_FsrmPathMapper_Value = @import("../zig.zig").Guid.initString("f3be42bd-8ac2-409e-bbd8-faf9b6b41feb");
pub const CLSID_FsrmPathMapper = &CLSID_FsrmPathMapper_Value;

const CLSID_FsrmExportImport_Value = @import("../zig.zig").Guid.initString("1482dc37-fae9-4787-9025-8ce4e024ab56");
pub const CLSID_FsrmExportImport = &CLSID_FsrmExportImport_Value;

const CLSID_FsrmQuotaManager_Value = @import("../zig.zig").Guid.initString("90dcab7f-347c-4bfc-b543-540326305fbe");
pub const CLSID_FsrmQuotaManager = &CLSID_FsrmQuotaManager_Value;

const CLSID_FsrmQuotaTemplateManager_Value = @import("../zig.zig").Guid.initString("97d3d443-251c-4337-81e7-b32e8f4ee65e");
pub const CLSID_FsrmQuotaTemplateManager = &CLSID_FsrmQuotaTemplateManager_Value;

const CLSID_FsrmFileGroupManager_Value = @import("../zig.zig").Guid.initString("8f1363f6-656f-4496-9226-13aecbd7718f");
pub const CLSID_FsrmFileGroupManager = &CLSID_FsrmFileGroupManager_Value;

const CLSID_FsrmFileScreenManager_Value = @import("../zig.zig").Guid.initString("95941183-db53-4c5f-b37b-7d0921cf9dc7");
pub const CLSID_FsrmFileScreenManager = &CLSID_FsrmFileScreenManager_Value;

const CLSID_FsrmFileScreenTemplateManager_Value = @import("../zig.zig").Guid.initString("243111df-e474-46aa-a054-eaa33edc292a");
pub const CLSID_FsrmFileScreenTemplateManager = &CLSID_FsrmFileScreenTemplateManager_Value;

const CLSID_FsrmReportManager_Value = @import("../zig.zig").Guid.initString("0058ef37-aa66-4c48-bd5b-2fce432ab0c8");
pub const CLSID_FsrmReportManager = &CLSID_FsrmReportManager_Value;

const CLSID_FsrmReportScheduler_Value = @import("../zig.zig").Guid.initString("ea25f1b8-1b8d-4290-8ee8-e17c12c2fe20");
pub const CLSID_FsrmReportScheduler = &CLSID_FsrmReportScheduler_Value;

const CLSID_FsrmFileManagementJobManager_Value = @import("../zig.zig").Guid.initString("eb18f9b2-4c3a-4321-b203-205120cff614");
pub const CLSID_FsrmFileManagementJobManager = &CLSID_FsrmFileManagementJobManager_Value;

const CLSID_FsrmClassificationManager_Value = @import("../zig.zig").Guid.initString("b15c0e47-c391-45b9-95c8-eb596c853f3a");
pub const CLSID_FsrmClassificationManager = &CLSID_FsrmClassificationManager_Value;

const CLSID_FsrmPipelineModuleConnector_Value = @import("../zig.zig").Guid.initString("c7643375-1eb5-44de-a062-623547d933bc");
pub const CLSID_FsrmPipelineModuleConnector = &CLSID_FsrmPipelineModuleConnector_Value;

const CLSID_AdSyncTask_Value = @import("../zig.zig").Guid.initString("2ae64751-b728-4d6b-97a0-b2da2e7d2a3b");
pub const CLSID_AdSyncTask = &CLSID_AdSyncTask_Value;

const CLSID_FsrmAccessDeniedRemediationClient_Value = @import("../zig.zig").Guid.initString("100b4fc8-74c1-470f-b1b7-dd7b6bae79bd");
pub const CLSID_FsrmAccessDeniedRemediationClient = &CLSID_FsrmAccessDeniedRemediationClient_Value;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmQuotaBase_Value = @import("../zig.zig").Guid.initString("1568a795-3924-4118-b74b-68d8f0fa5daf");
pub const IID_IFsrmQuotaBase = &IID_IFsrmQuotaBase_Value;
pub const IFsrmQuotaBase = extern struct {
    pub const VTable = extern struct {
        base: IFsrmObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuotaLimit: fn(
            self: *const IFsrmQuotaBase,
            quotaLimit: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuotaLimit: fn(
            self: *const IFsrmQuotaBase,
            quotaLimit: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuotaFlags: fn(
            self: *const IFsrmQuotaBase,
            quotaFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_QuotaFlags: fn(
            self: *const IFsrmQuotaBase,
            quotaFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Thresholds: fn(
            self: *const IFsrmQuotaBase,
            thresholds: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddThreshold: fn(
            self: *const IFsrmQuotaBase,
            threshold: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteThreshold: fn(
            self: *const IFsrmQuotaBase,
            threshold: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyThreshold: fn(
            self: *const IFsrmQuotaBase,
            threshold: i32,
            newThreshold: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateThresholdAction: fn(
            self: *const IFsrmQuotaBase,
            threshold: i32,
            actionType: FsrmActionType,
            action: ?*?*IFsrmAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumThresholdActions: fn(
            self: *const IFsrmQuotaBase,
            threshold: i32,
            actions: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_get_QuotaLimit(self: *const T, quotaLimit: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).get_QuotaLimit(@ptrCast(*const IFsrmQuotaBase, self), quotaLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_put_QuotaLimit(self: *const T, quotaLimit: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).put_QuotaLimit(@ptrCast(*const IFsrmQuotaBase, self), quotaLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_get_QuotaFlags(self: *const T, quotaFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).get_QuotaFlags(@ptrCast(*const IFsrmQuotaBase, self), quotaFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_put_QuotaFlags(self: *const T, quotaFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).put_QuotaFlags(@ptrCast(*const IFsrmQuotaBase, self), quotaFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_get_Thresholds(self: *const T, thresholds: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).get_Thresholds(@ptrCast(*const IFsrmQuotaBase, self), thresholds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_AddThreshold(self: *const T, threshold: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).AddThreshold(@ptrCast(*const IFsrmQuotaBase, self), threshold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_DeleteThreshold(self: *const T, threshold: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).DeleteThreshold(@ptrCast(*const IFsrmQuotaBase, self), threshold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_ModifyThreshold(self: *const T, threshold: i32, newThreshold: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).ModifyThreshold(@ptrCast(*const IFsrmQuotaBase, self), threshold, newThreshold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_CreateThresholdAction(self: *const T, threshold: i32, actionType: FsrmActionType, action: ?*?*IFsrmAction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).CreateThresholdAction(@ptrCast(*const IFsrmQuotaBase, self), threshold, actionType, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaBase_EnumThresholdActions(self: *const T, threshold: i32, actions: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaBase.VTable, self.vtable).EnumThresholdActions(@ptrCast(*const IFsrmQuotaBase, self), threshold, actions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmQuotaObject_Value = @import("../zig.zig").Guid.initString("42dc3511-61d5-48ae-b6dc-59fc00c0a8d6");
pub const IID_IFsrmQuotaObject = &IID_IFsrmQuotaObject_Value;
pub const IFsrmQuotaObject = extern struct {
    pub const VTable = extern struct {
        base: IFsrmQuotaBase.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IFsrmQuotaObject,
            path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserSid: fn(
            self: *const IFsrmQuotaObject,
            userSid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAccount: fn(
            self: *const IFsrmQuotaObject,
            userAccount: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceTemplateName: fn(
            self: *const IFsrmQuotaObject,
            quotaTemplateName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MatchesSourceTemplate: fn(
            self: *const IFsrmQuotaObject,
            matches: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyTemplate: fn(
            self: *const IFsrmQuotaObject,
            quotaTemplateName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmQuotaBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaObject_get_Path(self: *const T, path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaObject.VTable, self.vtable).get_Path(@ptrCast(*const IFsrmQuotaObject, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaObject_get_UserSid(self: *const T, userSid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaObject.VTable, self.vtable).get_UserSid(@ptrCast(*const IFsrmQuotaObject, self), userSid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaObject_get_UserAccount(self: *const T, userAccount: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaObject.VTable, self.vtable).get_UserAccount(@ptrCast(*const IFsrmQuotaObject, self), userAccount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaObject_get_SourceTemplateName(self: *const T, quotaTemplateName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaObject.VTable, self.vtable).get_SourceTemplateName(@ptrCast(*const IFsrmQuotaObject, self), quotaTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaObject_get_MatchesSourceTemplate(self: *const T, matches: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaObject.VTable, self.vtable).get_MatchesSourceTemplate(@ptrCast(*const IFsrmQuotaObject, self), matches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaObject_ApplyTemplate(self: *const T, quotaTemplateName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaObject.VTable, self.vtable).ApplyTemplate(@ptrCast(*const IFsrmQuotaObject, self), quotaTemplateName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmQuota_Value = @import("../zig.zig").Guid.initString("377f739d-9647-4b8e-97d2-5ffce6d759cd");
pub const IID_IFsrmQuota = &IID_IFsrmQuota_Value;
pub const IFsrmQuota = extern struct {
    pub const VTable = extern struct {
        base: IFsrmQuotaObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuotaUsed: fn(
            self: *const IFsrmQuota,
            used: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuotaPeakUsage: fn(
            self: *const IFsrmQuota,
            peakUsage: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QuotaPeakUsageTime: fn(
            self: *const IFsrmQuota,
            peakUsageDateTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetPeakUsage: fn(
            self: *const IFsrmQuota,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RefreshUsageProperties: fn(
            self: *const IFsrmQuota,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmQuotaObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuota_get_QuotaUsed(self: *const T, used: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuota.VTable, self.vtable).get_QuotaUsed(@ptrCast(*const IFsrmQuota, self), used);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuota_get_QuotaPeakUsage(self: *const T, peakUsage: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuota.VTable, self.vtable).get_QuotaPeakUsage(@ptrCast(*const IFsrmQuota, self), peakUsage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuota_get_QuotaPeakUsageTime(self: *const T, peakUsageDateTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuota.VTable, self.vtable).get_QuotaPeakUsageTime(@ptrCast(*const IFsrmQuota, self), peakUsageDateTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuota_ResetPeakUsage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuota.VTable, self.vtable).ResetPeakUsage(@ptrCast(*const IFsrmQuota, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuota_RefreshUsageProperties(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuota.VTable, self.vtable).RefreshUsageProperties(@ptrCast(*const IFsrmQuota, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmAutoApplyQuota_Value = @import("../zig.zig").Guid.initString("f82e5729-6aba-4740-bfc7-c7f58f75fb7b");
pub const IID_IFsrmAutoApplyQuota = &IID_IFsrmAutoApplyQuota_Value;
pub const IFsrmAutoApplyQuota = extern struct {
    pub const VTable = extern struct {
        base: IFsrmQuotaObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExcludeFolders: fn(
            self: *const IFsrmAutoApplyQuota,
            folders: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExcludeFolders: fn(
            self: *const IFsrmAutoApplyQuota,
            folders: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitAndUpdateDerived: fn(
            self: *const IFsrmAutoApplyQuota,
            commitOptions: FsrmCommitOptions,
            applyOptions: FsrmTemplateApplyOptions,
            derivedObjectsResult: ?*?*IFsrmDerivedObjectsResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmQuotaObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmAutoApplyQuota_get_ExcludeFolders(self: *const T, folders: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmAutoApplyQuota.VTable, self.vtable).get_ExcludeFolders(@ptrCast(*const IFsrmAutoApplyQuota, self), folders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmAutoApplyQuota_put_ExcludeFolders(self: *const T, folders: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmAutoApplyQuota.VTable, self.vtable).put_ExcludeFolders(@ptrCast(*const IFsrmAutoApplyQuota, self), folders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmAutoApplyQuota_CommitAndUpdateDerived(self: *const T, commitOptions: FsrmCommitOptions, applyOptions: FsrmTemplateApplyOptions, derivedObjectsResult: ?*?*IFsrmDerivedObjectsResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmAutoApplyQuota.VTable, self.vtable).CommitAndUpdateDerived(@ptrCast(*const IFsrmAutoApplyQuota, self), commitOptions, applyOptions, derivedObjectsResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmQuotaManager_Value = @import("../zig.zig").Guid.initString("8bb68c7d-19d8-4ffb-809e-be4fc1734014");
pub const IID_IFsrmQuotaManager = &IID_IFsrmQuotaManager_Value;
pub const IFsrmQuotaManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActionVariables: fn(
            self: *const IFsrmQuotaManager,
            variables: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActionVariableDescriptions: fn(
            self: *const IFsrmQuotaManager,
            descriptions: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateQuota: fn(
            self: *const IFsrmQuotaManager,
            path: ?BSTR,
            quota: ?*?*IFsrmQuota,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAutoApplyQuota: fn(
            self: *const IFsrmQuotaManager,
            quotaTemplateName: ?BSTR,
            path: ?BSTR,
            quota: ?*?*IFsrmAutoApplyQuota,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuota: fn(
            self: *const IFsrmQuotaManager,
            path: ?BSTR,
            quota: ?*?*IFsrmQuota,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutoApplyQuota: fn(
            self: *const IFsrmQuotaManager,
            path: ?BSTR,
            quota: ?*?*IFsrmAutoApplyQuota,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestrictiveQuota: fn(
            self: *const IFsrmQuotaManager,
            path: ?BSTR,
            quota: ?*?*IFsrmQuota,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumQuotas: fn(
            self: *const IFsrmQuotaManager,
            path: ?BSTR,
            options: FsrmEnumOptions,
            quotas: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAutoApplyQuotas: fn(
            self: *const IFsrmQuotaManager,
            path: ?BSTR,
            options: FsrmEnumOptions,
            quotas: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumEffectiveQuotas: fn(
            self: *const IFsrmQuotaManager,
            path: ?BSTR,
            options: FsrmEnumOptions,
            quotas: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Scan: fn(
            self: *const IFsrmQuotaManager,
            strPath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateQuotaCollection: fn(
            self: *const IFsrmQuotaManager,
            collection: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_get_ActionVariables(self: *const T, variables: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).get_ActionVariables(@ptrCast(*const IFsrmQuotaManager, self), variables);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_get_ActionVariableDescriptions(self: *const T, descriptions: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).get_ActionVariableDescriptions(@ptrCast(*const IFsrmQuotaManager, self), descriptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_CreateQuota(self: *const T, path: ?BSTR, quota: ?*?*IFsrmQuota) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).CreateQuota(@ptrCast(*const IFsrmQuotaManager, self), path, quota);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_CreateAutoApplyQuota(self: *const T, quotaTemplateName: ?BSTR, path: ?BSTR, quota: ?*?*IFsrmAutoApplyQuota) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).CreateAutoApplyQuota(@ptrCast(*const IFsrmQuotaManager, self), quotaTemplateName, path, quota);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_GetQuota(self: *const T, path: ?BSTR, quota: ?*?*IFsrmQuota) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).GetQuota(@ptrCast(*const IFsrmQuotaManager, self), path, quota);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_GetAutoApplyQuota(self: *const T, path: ?BSTR, quota: ?*?*IFsrmAutoApplyQuota) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).GetAutoApplyQuota(@ptrCast(*const IFsrmQuotaManager, self), path, quota);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_GetRestrictiveQuota(self: *const T, path: ?BSTR, quota: ?*?*IFsrmQuota) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).GetRestrictiveQuota(@ptrCast(*const IFsrmQuotaManager, self), path, quota);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_EnumQuotas(self: *const T, path: ?BSTR, options: FsrmEnumOptions, quotas: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).EnumQuotas(@ptrCast(*const IFsrmQuotaManager, self), path, options, quotas);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_EnumAutoApplyQuotas(self: *const T, path: ?BSTR, options: FsrmEnumOptions, quotas: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).EnumAutoApplyQuotas(@ptrCast(*const IFsrmQuotaManager, self), path, options, quotas);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_EnumEffectiveQuotas(self: *const T, path: ?BSTR, options: FsrmEnumOptions, quotas: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).EnumEffectiveQuotas(@ptrCast(*const IFsrmQuotaManager, self), path, options, quotas);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_Scan(self: *const T, strPath: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).Scan(@ptrCast(*const IFsrmQuotaManager, self), strPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManager_CreateQuotaCollection(self: *const T, collection: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManager.VTable, self.vtable).CreateQuotaCollection(@ptrCast(*const IFsrmQuotaManager, self), collection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmQuotaManagerEx_Value = @import("../zig.zig").Guid.initString("4846cb01-d430-494f-abb4-b1054999fb09");
pub const IID_IFsrmQuotaManagerEx = &IID_IFsrmQuotaManagerEx_Value;
pub const IFsrmQuotaManagerEx = extern struct {
    pub const VTable = extern struct {
        base: IFsrmQuotaManager.VTable,
        IsAffectedByQuota: fn(
            self: *const IFsrmQuotaManagerEx,
            path: ?BSTR,
            options: FsrmEnumOptions,
            affected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmQuotaManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaManagerEx_IsAffectedByQuota(self: *const T, path: ?BSTR, options: FsrmEnumOptions, affected: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaManagerEx.VTable, self.vtable).IsAffectedByQuota(@ptrCast(*const IFsrmQuotaManagerEx, self), path, options, affected);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmQuotaTemplate_Value = @import("../zig.zig").Guid.initString("a2efab31-295e-46bb-b976-e86d58b52e8b");
pub const IID_IFsrmQuotaTemplate = &IID_IFsrmQuotaTemplate_Value;
pub const IFsrmQuotaTemplate = extern struct {
    pub const VTable = extern struct {
        base: IFsrmQuotaBase.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmQuotaTemplate,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFsrmQuotaTemplate,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTemplate: fn(
            self: *const IFsrmQuotaTemplate,
            quotaTemplateName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitAndUpdateDerived: fn(
            self: *const IFsrmQuotaTemplate,
            commitOptions: FsrmCommitOptions,
            applyOptions: FsrmTemplateApplyOptions,
            derivedObjectsResult: ?*?*IFsrmDerivedObjectsResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmQuotaBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplate_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplate.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmQuotaTemplate, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplate_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplate.VTable, self.vtable).put_Name(@ptrCast(*const IFsrmQuotaTemplate, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplate_CopyTemplate(self: *const T, quotaTemplateName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplate.VTable, self.vtable).CopyTemplate(@ptrCast(*const IFsrmQuotaTemplate, self), quotaTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplate_CommitAndUpdateDerived(self: *const T, commitOptions: FsrmCommitOptions, applyOptions: FsrmTemplateApplyOptions, derivedObjectsResult: ?*?*IFsrmDerivedObjectsResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplate.VTable, self.vtable).CommitAndUpdateDerived(@ptrCast(*const IFsrmQuotaTemplate, self), commitOptions, applyOptions, derivedObjectsResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmQuotaTemplateImported_Value = @import("../zig.zig").Guid.initString("9a2bf113-a329-44cc-809a-5c00fce8da40");
pub const IID_IFsrmQuotaTemplateImported = &IID_IFsrmQuotaTemplateImported_Value;
pub const IFsrmQuotaTemplateImported = extern struct {
    pub const VTable = extern struct {
        base: IFsrmQuotaTemplate.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OverwriteOnCommit: fn(
            self: *const IFsrmQuotaTemplateImported,
            overwrite: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OverwriteOnCommit: fn(
            self: *const IFsrmQuotaTemplateImported,
            overwrite: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmQuotaTemplate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplateImported_get_OverwriteOnCommit(self: *const T, overwrite: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplateImported.VTable, self.vtable).get_OverwriteOnCommit(@ptrCast(*const IFsrmQuotaTemplateImported, self), overwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplateImported_put_OverwriteOnCommit(self: *const T, overwrite: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplateImported.VTable, self.vtable).put_OverwriteOnCommit(@ptrCast(*const IFsrmQuotaTemplateImported, self), overwrite);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmQuotaTemplateManager_Value = @import("../zig.zig").Guid.initString("4173ac41-172d-4d52-963c-fdc7e415f717");
pub const IID_IFsrmQuotaTemplateManager = &IID_IFsrmQuotaTemplateManager_Value;
pub const IFsrmQuotaTemplateManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateTemplate: fn(
            self: *const IFsrmQuotaTemplateManager,
            quotaTemplate: ?*?*IFsrmQuotaTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTemplate: fn(
            self: *const IFsrmQuotaTemplateManager,
            name: ?BSTR,
            quotaTemplate: ?*?*IFsrmQuotaTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumTemplates: fn(
            self: *const IFsrmQuotaTemplateManager,
            options: FsrmEnumOptions,
            quotaTemplates: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExportTemplates: fn(
            self: *const IFsrmQuotaTemplateManager,
            quotaTemplateNamesArray: ?*VARIANT,
            serializedQuotaTemplates: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportTemplates: fn(
            self: *const IFsrmQuotaTemplateManager,
            serializedQuotaTemplates: ?BSTR,
            quotaTemplateNamesArray: ?*VARIANT,
            quotaTemplates: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplateManager_CreateTemplate(self: *const T, quotaTemplate: ?*?*IFsrmQuotaTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplateManager.VTable, self.vtable).CreateTemplate(@ptrCast(*const IFsrmQuotaTemplateManager, self), quotaTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplateManager_GetTemplate(self: *const T, name: ?BSTR, quotaTemplate: ?*?*IFsrmQuotaTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplateManager.VTable, self.vtable).GetTemplate(@ptrCast(*const IFsrmQuotaTemplateManager, self), name, quotaTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplateManager_EnumTemplates(self: *const T, options: FsrmEnumOptions, quotaTemplates: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplateManager.VTable, self.vtable).EnumTemplates(@ptrCast(*const IFsrmQuotaTemplateManager, self), options, quotaTemplates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplateManager_ExportTemplates(self: *const T, quotaTemplateNamesArray: ?*VARIANT, serializedQuotaTemplates: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplateManager.VTable, self.vtable).ExportTemplates(@ptrCast(*const IFsrmQuotaTemplateManager, self), quotaTemplateNamesArray, serializedQuotaTemplates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmQuotaTemplateManager_ImportTemplates(self: *const T, serializedQuotaTemplates: ?BSTR, quotaTemplateNamesArray: ?*VARIANT, quotaTemplates: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmQuotaTemplateManager.VTable, self.vtable).ImportTemplates(@ptrCast(*const IFsrmQuotaTemplateManager, self), serializedQuotaTemplates, quotaTemplateNamesArray, quotaTemplates);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileGroup_Value = @import("../zig.zig").Guid.initString("8dd04909-0e34-4d55-afaa-89e1f1a1bbb9");
pub const IID_IFsrmFileGroup = &IID_IFsrmFileGroup_Value;
pub const IFsrmFileGroup = extern struct {
    pub const VTable = extern struct {
        base: IFsrmObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmFileGroup,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFsrmFileGroup,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Members: fn(
            self: *const IFsrmFileGroup,
            members: ?*?*IFsrmMutableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Members: fn(
            self: *const IFsrmFileGroup,
            members: ?*IFsrmMutableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NonMembers: fn(
            self: *const IFsrmFileGroup,
            nonMembers: ?*?*IFsrmMutableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NonMembers: fn(
            self: *const IFsrmFileGroup,
            nonMembers: ?*IFsrmMutableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroup_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroup.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmFileGroup, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroup_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroup.VTable, self.vtable).put_Name(@ptrCast(*const IFsrmFileGroup, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroup_get_Members(self: *const T, members: ?*?*IFsrmMutableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroup.VTable, self.vtable).get_Members(@ptrCast(*const IFsrmFileGroup, self), members);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroup_put_Members(self: *const T, members: ?*IFsrmMutableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroup.VTable, self.vtable).put_Members(@ptrCast(*const IFsrmFileGroup, self), members);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroup_get_NonMembers(self: *const T, nonMembers: ?*?*IFsrmMutableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroup.VTable, self.vtable).get_NonMembers(@ptrCast(*const IFsrmFileGroup, self), nonMembers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroup_put_NonMembers(self: *const T, nonMembers: ?*IFsrmMutableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroup.VTable, self.vtable).put_NonMembers(@ptrCast(*const IFsrmFileGroup, self), nonMembers);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileGroupImported_Value = @import("../zig.zig").Guid.initString("ad55f10b-5f11-4be7-94ef-d9ee2e470ded");
pub const IID_IFsrmFileGroupImported = &IID_IFsrmFileGroupImported_Value;
pub const IFsrmFileGroupImported = extern struct {
    pub const VTable = extern struct {
        base: IFsrmFileGroup.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OverwriteOnCommit: fn(
            self: *const IFsrmFileGroupImported,
            overwrite: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OverwriteOnCommit: fn(
            self: *const IFsrmFileGroupImported,
            overwrite: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmFileGroup.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroupImported_get_OverwriteOnCommit(self: *const T, overwrite: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroupImported.VTable, self.vtable).get_OverwriteOnCommit(@ptrCast(*const IFsrmFileGroupImported, self), overwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroupImported_put_OverwriteOnCommit(self: *const T, overwrite: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroupImported.VTable, self.vtable).put_OverwriteOnCommit(@ptrCast(*const IFsrmFileGroupImported, self), overwrite);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileGroupManager_Value = @import("../zig.zig").Guid.initString("426677d5-018c-485c-8a51-20b86d00bdc4");
pub const IID_IFsrmFileGroupManager = &IID_IFsrmFileGroupManager_Value;
pub const IFsrmFileGroupManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateFileGroup: fn(
            self: *const IFsrmFileGroupManager,
            fileGroup: ?*?*IFsrmFileGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileGroup: fn(
            self: *const IFsrmFileGroupManager,
            name: ?BSTR,
            fileGroup: ?*?*IFsrmFileGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFileGroups: fn(
            self: *const IFsrmFileGroupManager,
            options: FsrmEnumOptions,
            fileGroups: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExportFileGroups: fn(
            self: *const IFsrmFileGroupManager,
            fileGroupNamesArray: ?*VARIANT,
            serializedFileGroups: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportFileGroups: fn(
            self: *const IFsrmFileGroupManager,
            serializedFileGroups: ?BSTR,
            fileGroupNamesArray: ?*VARIANT,
            fileGroups: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroupManager_CreateFileGroup(self: *const T, fileGroup: ?*?*IFsrmFileGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroupManager.VTable, self.vtable).CreateFileGroup(@ptrCast(*const IFsrmFileGroupManager, self), fileGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroupManager_GetFileGroup(self: *const T, name: ?BSTR, fileGroup: ?*?*IFsrmFileGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroupManager.VTable, self.vtable).GetFileGroup(@ptrCast(*const IFsrmFileGroupManager, self), name, fileGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroupManager_EnumFileGroups(self: *const T, options: FsrmEnumOptions, fileGroups: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroupManager.VTable, self.vtable).EnumFileGroups(@ptrCast(*const IFsrmFileGroupManager, self), options, fileGroups);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroupManager_ExportFileGroups(self: *const T, fileGroupNamesArray: ?*VARIANT, serializedFileGroups: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroupManager.VTable, self.vtable).ExportFileGroups(@ptrCast(*const IFsrmFileGroupManager, self), fileGroupNamesArray, serializedFileGroups);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileGroupManager_ImportFileGroups(self: *const T, serializedFileGroups: ?BSTR, fileGroupNamesArray: ?*VARIANT, fileGroups: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileGroupManager.VTable, self.vtable).ImportFileGroups(@ptrCast(*const IFsrmFileGroupManager, self), serializedFileGroups, fileGroupNamesArray, fileGroups);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileScreenBase_Value = @import("../zig.zig").Guid.initString("f3637e80-5b22-4a2b-a637-bbb642b41cfc");
pub const IID_IFsrmFileScreenBase = &IID_IFsrmFileScreenBase_Value;
pub const IFsrmFileScreenBase = extern struct {
    pub const VTable = extern struct {
        base: IFsrmObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockedFileGroups: fn(
            self: *const IFsrmFileScreenBase,
            blockList: ?*?*IFsrmMutableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockedFileGroups: fn(
            self: *const IFsrmFileScreenBase,
            blockList: ?*IFsrmMutableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileScreenFlags: fn(
            self: *const IFsrmFileScreenBase,
            fileScreenFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileScreenFlags: fn(
            self: *const IFsrmFileScreenBase,
            fileScreenFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAction: fn(
            self: *const IFsrmFileScreenBase,
            actionType: FsrmActionType,
            action: ?*?*IFsrmAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumActions: fn(
            self: *const IFsrmFileScreenBase,
            actions: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenBase_get_BlockedFileGroups(self: *const T, blockList: ?*?*IFsrmMutableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenBase.VTable, self.vtable).get_BlockedFileGroups(@ptrCast(*const IFsrmFileScreenBase, self), blockList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenBase_put_BlockedFileGroups(self: *const T, blockList: ?*IFsrmMutableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenBase.VTable, self.vtable).put_BlockedFileGroups(@ptrCast(*const IFsrmFileScreenBase, self), blockList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenBase_get_FileScreenFlags(self: *const T, fileScreenFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenBase.VTable, self.vtable).get_FileScreenFlags(@ptrCast(*const IFsrmFileScreenBase, self), fileScreenFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenBase_put_FileScreenFlags(self: *const T, fileScreenFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenBase.VTable, self.vtable).put_FileScreenFlags(@ptrCast(*const IFsrmFileScreenBase, self), fileScreenFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenBase_CreateAction(self: *const T, actionType: FsrmActionType, action: ?*?*IFsrmAction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenBase.VTable, self.vtable).CreateAction(@ptrCast(*const IFsrmFileScreenBase, self), actionType, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenBase_EnumActions(self: *const T, actions: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenBase.VTable, self.vtable).EnumActions(@ptrCast(*const IFsrmFileScreenBase, self), actions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileScreen_Value = @import("../zig.zig").Guid.initString("5f6325d3-ce88-4733-84c1-2d6aefc5ea07");
pub const IID_IFsrmFileScreen = &IID_IFsrmFileScreen_Value;
pub const IFsrmFileScreen = extern struct {
    pub const VTable = extern struct {
        base: IFsrmFileScreenBase.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IFsrmFileScreen,
            path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceTemplateName: fn(
            self: *const IFsrmFileScreen,
            fileScreenTemplateName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MatchesSourceTemplate: fn(
            self: *const IFsrmFileScreen,
            matches: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserSid: fn(
            self: *const IFsrmFileScreen,
            userSid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAccount: fn(
            self: *const IFsrmFileScreen,
            userAccount: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyTemplate: fn(
            self: *const IFsrmFileScreen,
            fileScreenTemplateName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmFileScreenBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreen_get_Path(self: *const T, path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreen.VTable, self.vtable).get_Path(@ptrCast(*const IFsrmFileScreen, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreen_get_SourceTemplateName(self: *const T, fileScreenTemplateName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreen.VTable, self.vtable).get_SourceTemplateName(@ptrCast(*const IFsrmFileScreen, self), fileScreenTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreen_get_MatchesSourceTemplate(self: *const T, matches: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreen.VTable, self.vtable).get_MatchesSourceTemplate(@ptrCast(*const IFsrmFileScreen, self), matches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreen_get_UserSid(self: *const T, userSid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreen.VTable, self.vtable).get_UserSid(@ptrCast(*const IFsrmFileScreen, self), userSid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreen_get_UserAccount(self: *const T, userAccount: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreen.VTable, self.vtable).get_UserAccount(@ptrCast(*const IFsrmFileScreen, self), userAccount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreen_ApplyTemplate(self: *const T, fileScreenTemplateName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreen.VTable, self.vtable).ApplyTemplate(@ptrCast(*const IFsrmFileScreen, self), fileScreenTemplateName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileScreenException_Value = @import("../zig.zig").Guid.initString("bee7ce02-df77-4515-9389-78f01c5afc1a");
pub const IID_IFsrmFileScreenException = &IID_IFsrmFileScreenException_Value;
pub const IFsrmFileScreenException = extern struct {
    pub const VTable = extern struct {
        base: IFsrmObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IFsrmFileScreenException,
            path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowedFileGroups: fn(
            self: *const IFsrmFileScreenException,
            allowList: ?*?*IFsrmMutableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowedFileGroups: fn(
            self: *const IFsrmFileScreenException,
            allowList: ?*IFsrmMutableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenException_get_Path(self: *const T, path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenException.VTable, self.vtable).get_Path(@ptrCast(*const IFsrmFileScreenException, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenException_get_AllowedFileGroups(self: *const T, allowList: ?*?*IFsrmMutableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenException.VTable, self.vtable).get_AllowedFileGroups(@ptrCast(*const IFsrmFileScreenException, self), allowList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenException_put_AllowedFileGroups(self: *const T, allowList: ?*IFsrmMutableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenException.VTable, self.vtable).put_AllowedFileGroups(@ptrCast(*const IFsrmFileScreenException, self), allowList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileScreenManager_Value = @import("../zig.zig").Guid.initString("ff4fa04e-5a94-4bda-a3a0-d5b4d3c52eba");
pub const IID_IFsrmFileScreenManager = &IID_IFsrmFileScreenManager_Value;
pub const IFsrmFileScreenManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActionVariables: fn(
            self: *const IFsrmFileScreenManager,
            variables: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActionVariableDescriptions: fn(
            self: *const IFsrmFileScreenManager,
            descriptions: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFileScreen: fn(
            self: *const IFsrmFileScreenManager,
            path: ?BSTR,
            fileScreen: ?*?*IFsrmFileScreen,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileScreen: fn(
            self: *const IFsrmFileScreenManager,
            path: ?BSTR,
            fileScreen: ?*?*IFsrmFileScreen,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFileScreens: fn(
            self: *const IFsrmFileScreenManager,
            path: ?BSTR,
            options: FsrmEnumOptions,
            fileScreens: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFileScreenException: fn(
            self: *const IFsrmFileScreenManager,
            path: ?BSTR,
            fileScreenException: ?*?*IFsrmFileScreenException,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileScreenException: fn(
            self: *const IFsrmFileScreenManager,
            path: ?BSTR,
            fileScreenException: ?*?*IFsrmFileScreenException,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFileScreenExceptions: fn(
            self: *const IFsrmFileScreenManager,
            path: ?BSTR,
            options: FsrmEnumOptions,
            fileScreenExceptions: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFileScreenCollection: fn(
            self: *const IFsrmFileScreenManager,
            collection: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenManager_get_ActionVariables(self: *const T, variables: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenManager.VTable, self.vtable).get_ActionVariables(@ptrCast(*const IFsrmFileScreenManager, self), variables);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenManager_get_ActionVariableDescriptions(self: *const T, descriptions: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenManager.VTable, self.vtable).get_ActionVariableDescriptions(@ptrCast(*const IFsrmFileScreenManager, self), descriptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenManager_CreateFileScreen(self: *const T, path: ?BSTR, fileScreen: ?*?*IFsrmFileScreen) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenManager.VTable, self.vtable).CreateFileScreen(@ptrCast(*const IFsrmFileScreenManager, self), path, fileScreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenManager_GetFileScreen(self: *const T, path: ?BSTR, fileScreen: ?*?*IFsrmFileScreen) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenManager.VTable, self.vtable).GetFileScreen(@ptrCast(*const IFsrmFileScreenManager, self), path, fileScreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenManager_EnumFileScreens(self: *const T, path: ?BSTR, options: FsrmEnumOptions, fileScreens: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenManager.VTable, self.vtable).EnumFileScreens(@ptrCast(*const IFsrmFileScreenManager, self), path, options, fileScreens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenManager_CreateFileScreenException(self: *const T, path: ?BSTR, fileScreenException: ?*?*IFsrmFileScreenException) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenManager.VTable, self.vtable).CreateFileScreenException(@ptrCast(*const IFsrmFileScreenManager, self), path, fileScreenException);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenManager_GetFileScreenException(self: *const T, path: ?BSTR, fileScreenException: ?*?*IFsrmFileScreenException) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenManager.VTable, self.vtable).GetFileScreenException(@ptrCast(*const IFsrmFileScreenManager, self), path, fileScreenException);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenManager_EnumFileScreenExceptions(self: *const T, path: ?BSTR, options: FsrmEnumOptions, fileScreenExceptions: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenManager.VTable, self.vtable).EnumFileScreenExceptions(@ptrCast(*const IFsrmFileScreenManager, self), path, options, fileScreenExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenManager_CreateFileScreenCollection(self: *const T, collection: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenManager.VTable, self.vtable).CreateFileScreenCollection(@ptrCast(*const IFsrmFileScreenManager, self), collection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileScreenTemplate_Value = @import("../zig.zig").Guid.initString("205bebf8-dd93-452a-95a6-32b566b35828");
pub const IID_IFsrmFileScreenTemplate = &IID_IFsrmFileScreenTemplate_Value;
pub const IFsrmFileScreenTemplate = extern struct {
    pub const VTable = extern struct {
        base: IFsrmFileScreenBase.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmFileScreenTemplate,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFsrmFileScreenTemplate,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTemplate: fn(
            self: *const IFsrmFileScreenTemplate,
            fileScreenTemplateName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitAndUpdateDerived: fn(
            self: *const IFsrmFileScreenTemplate,
            commitOptions: FsrmCommitOptions,
            applyOptions: FsrmTemplateApplyOptions,
            derivedObjectsResult: ?*?*IFsrmDerivedObjectsResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmFileScreenBase.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplate_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplate.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmFileScreenTemplate, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplate_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplate.VTable, self.vtable).put_Name(@ptrCast(*const IFsrmFileScreenTemplate, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplate_CopyTemplate(self: *const T, fileScreenTemplateName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplate.VTable, self.vtable).CopyTemplate(@ptrCast(*const IFsrmFileScreenTemplate, self), fileScreenTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplate_CommitAndUpdateDerived(self: *const T, commitOptions: FsrmCommitOptions, applyOptions: FsrmTemplateApplyOptions, derivedObjectsResult: ?*?*IFsrmDerivedObjectsResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplate.VTable, self.vtable).CommitAndUpdateDerived(@ptrCast(*const IFsrmFileScreenTemplate, self), commitOptions, applyOptions, derivedObjectsResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileScreenTemplateImported_Value = @import("../zig.zig").Guid.initString("e1010359-3e5d-4ecd-9fe4-ef48622fdf30");
pub const IID_IFsrmFileScreenTemplateImported = &IID_IFsrmFileScreenTemplateImported_Value;
pub const IFsrmFileScreenTemplateImported = extern struct {
    pub const VTable = extern struct {
        base: IFsrmFileScreenTemplate.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OverwriteOnCommit: fn(
            self: *const IFsrmFileScreenTemplateImported,
            overwrite: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OverwriteOnCommit: fn(
            self: *const IFsrmFileScreenTemplateImported,
            overwrite: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmFileScreenTemplate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplateImported_get_OverwriteOnCommit(self: *const T, overwrite: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplateImported.VTable, self.vtable).get_OverwriteOnCommit(@ptrCast(*const IFsrmFileScreenTemplateImported, self), overwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplateImported_put_OverwriteOnCommit(self: *const T, overwrite: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplateImported.VTable, self.vtable).put_OverwriteOnCommit(@ptrCast(*const IFsrmFileScreenTemplateImported, self), overwrite);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileScreenTemplateManager_Value = @import("../zig.zig").Guid.initString("cfe36cba-1949-4e74-a14f-f1d580ceaf13");
pub const IID_IFsrmFileScreenTemplateManager = &IID_IFsrmFileScreenTemplateManager_Value;
pub const IFsrmFileScreenTemplateManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateTemplate: fn(
            self: *const IFsrmFileScreenTemplateManager,
            fileScreenTemplate: ?*?*IFsrmFileScreenTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTemplate: fn(
            self: *const IFsrmFileScreenTemplateManager,
            name: ?BSTR,
            fileScreenTemplate: ?*?*IFsrmFileScreenTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumTemplates: fn(
            self: *const IFsrmFileScreenTemplateManager,
            options: FsrmEnumOptions,
            fileScreenTemplates: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExportTemplates: fn(
            self: *const IFsrmFileScreenTemplateManager,
            fileScreenTemplateNamesArray: ?*VARIANT,
            serializedFileScreenTemplates: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportTemplates: fn(
            self: *const IFsrmFileScreenTemplateManager,
            serializedFileScreenTemplates: ?BSTR,
            fileScreenTemplateNamesArray: ?*VARIANT,
            fileScreenTemplates: ?*?*IFsrmCommittableCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplateManager_CreateTemplate(self: *const T, fileScreenTemplate: ?*?*IFsrmFileScreenTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplateManager.VTable, self.vtable).CreateTemplate(@ptrCast(*const IFsrmFileScreenTemplateManager, self), fileScreenTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplateManager_GetTemplate(self: *const T, name: ?BSTR, fileScreenTemplate: ?*?*IFsrmFileScreenTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplateManager.VTable, self.vtable).GetTemplate(@ptrCast(*const IFsrmFileScreenTemplateManager, self), name, fileScreenTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplateManager_EnumTemplates(self: *const T, options: FsrmEnumOptions, fileScreenTemplates: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplateManager.VTable, self.vtable).EnumTemplates(@ptrCast(*const IFsrmFileScreenTemplateManager, self), options, fileScreenTemplates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplateManager_ExportTemplates(self: *const T, fileScreenTemplateNamesArray: ?*VARIANT, serializedFileScreenTemplates: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplateManager.VTable, self.vtable).ExportTemplates(@ptrCast(*const IFsrmFileScreenTemplateManager, self), fileScreenTemplateNamesArray, serializedFileScreenTemplates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileScreenTemplateManager_ImportTemplates(self: *const T, serializedFileScreenTemplates: ?BSTR, fileScreenTemplateNamesArray: ?*VARIANT, fileScreenTemplates: ?*?*IFsrmCommittableCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileScreenTemplateManager.VTable, self.vtable).ImportTemplates(@ptrCast(*const IFsrmFileScreenTemplateManager, self), serializedFileScreenTemplates, fileScreenTemplateNamesArray, fileScreenTemplates);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmReportManager_Value = @import("../zig.zig").Guid.initString("27b899fe-6ffa-4481-a184-d3daade8a02b");
pub const IID_IFsrmReportManager = &IID_IFsrmReportManager_Value;
pub const IFsrmReportManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        EnumReportJobs: fn(
            self: *const IFsrmReportManager,
            options: FsrmEnumOptions,
            reportJobs: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateReportJob: fn(
            self: *const IFsrmReportManager,
            reportJob: ?*?*IFsrmReportJob,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReportJob: fn(
            self: *const IFsrmReportManager,
            taskName: ?BSTR,
            reportJob: ?*?*IFsrmReportJob,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputDirectory: fn(
            self: *const IFsrmReportManager,
            context: FsrmReportGenerationContext,
            path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputDirectory: fn(
            self: *const IFsrmReportManager,
            context: FsrmReportGenerationContext,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsFilterValidForReportType: fn(
            self: *const IFsrmReportManager,
            reportType: FsrmReportType,
            filter: FsrmReportFilter,
            valid: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultFilter: fn(
            self: *const IFsrmReportManager,
            reportType: FsrmReportType,
            filter: FsrmReportFilter,
            filterValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultFilter: fn(
            self: *const IFsrmReportManager,
            reportType: FsrmReportType,
            filter: FsrmReportFilter,
            filterValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReportSizeLimit: fn(
            self: *const IFsrmReportManager,
            limit: FsrmReportLimit,
            limitValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReportSizeLimit: fn(
            self: *const IFsrmReportManager,
            limit: FsrmReportLimit,
            limitValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_EnumReportJobs(self: *const T, options: FsrmEnumOptions, reportJobs: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).EnumReportJobs(@ptrCast(*const IFsrmReportManager, self), options, reportJobs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_CreateReportJob(self: *const T, reportJob: ?*?*IFsrmReportJob) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).CreateReportJob(@ptrCast(*const IFsrmReportManager, self), reportJob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_GetReportJob(self: *const T, taskName: ?BSTR, reportJob: ?*?*IFsrmReportJob) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).GetReportJob(@ptrCast(*const IFsrmReportManager, self), taskName, reportJob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_GetOutputDirectory(self: *const T, context: FsrmReportGenerationContext, path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).GetOutputDirectory(@ptrCast(*const IFsrmReportManager, self), context, path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_SetOutputDirectory(self: *const T, context: FsrmReportGenerationContext, path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).SetOutputDirectory(@ptrCast(*const IFsrmReportManager, self), context, path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_IsFilterValidForReportType(self: *const T, reportType: FsrmReportType, filter: FsrmReportFilter, valid: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).IsFilterValidForReportType(@ptrCast(*const IFsrmReportManager, self), reportType, filter, valid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_GetDefaultFilter(self: *const T, reportType: FsrmReportType, filter: FsrmReportFilter, filterValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).GetDefaultFilter(@ptrCast(*const IFsrmReportManager, self), reportType, filter, filterValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_SetDefaultFilter(self: *const T, reportType: FsrmReportType, filter: FsrmReportFilter, filterValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).SetDefaultFilter(@ptrCast(*const IFsrmReportManager, self), reportType, filter, filterValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_GetReportSizeLimit(self: *const T, limit: FsrmReportLimit, limitValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).GetReportSizeLimit(@ptrCast(*const IFsrmReportManager, self), limit, limitValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportManager_SetReportSizeLimit(self: *const T, limit: FsrmReportLimit, limitValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportManager.VTable, self.vtable).SetReportSizeLimit(@ptrCast(*const IFsrmReportManager, self), limit, limitValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmReportJob_Value = @import("../zig.zig").Guid.initString("38e87280-715c-4c7d-a280-ea1651a19fef");
pub const IID_IFsrmReportJob = &IID_IFsrmReportJob_Value;
pub const IFsrmReportJob = extern struct {
    pub const VTable = extern struct {
        base: IFsrmObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Task: fn(
            self: *const IFsrmReportJob,
            taskName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Task: fn(
            self: *const IFsrmReportJob,
            taskName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NamespaceRoots: fn(
            self: *const IFsrmReportJob,
            namespaceRoots: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NamespaceRoots: fn(
            self: *const IFsrmReportJob,
            namespaceRoots: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Formats: fn(
            self: *const IFsrmReportJob,
            formats: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Formats: fn(
            self: *const IFsrmReportJob,
            formats: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailTo: fn(
            self: *const IFsrmReportJob,
            mailTo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailTo: fn(
            self: *const IFsrmReportJob,
            mailTo: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunningStatus: fn(
            self: *const IFsrmReportJob,
            runningStatus: ?*FsrmReportRunningStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastRun: fn(
            self: *const IFsrmReportJob,
            lastRun: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastError: fn(
            self: *const IFsrmReportJob,
            lastError: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastGeneratedInDirectory: fn(
            self: *const IFsrmReportJob,
            path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumReports: fn(
            self: *const IFsrmReportJob,
            reports: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateReport: fn(
            self: *const IFsrmReportJob,
            reportType: FsrmReportType,
            report: ?*?*IFsrmReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IFsrmReportJob,
            context: FsrmReportGenerationContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForCompletion: fn(
            self: *const IFsrmReportJob,
            waitSeconds: i32,
            completed: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IFsrmReportJob,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_get_Task(self: *const T, taskName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).get_Task(@ptrCast(*const IFsrmReportJob, self), taskName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_put_Task(self: *const T, taskName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).put_Task(@ptrCast(*const IFsrmReportJob, self), taskName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_get_NamespaceRoots(self: *const T, namespaceRoots: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).get_NamespaceRoots(@ptrCast(*const IFsrmReportJob, self), namespaceRoots);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_put_NamespaceRoots(self: *const T, namespaceRoots: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).put_NamespaceRoots(@ptrCast(*const IFsrmReportJob, self), namespaceRoots);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_get_Formats(self: *const T, formats: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).get_Formats(@ptrCast(*const IFsrmReportJob, self), formats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_put_Formats(self: *const T, formats: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).put_Formats(@ptrCast(*const IFsrmReportJob, self), formats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_get_MailTo(self: *const T, mailTo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).get_MailTo(@ptrCast(*const IFsrmReportJob, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_put_MailTo(self: *const T, mailTo: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).put_MailTo(@ptrCast(*const IFsrmReportJob, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_get_RunningStatus(self: *const T, runningStatus: ?*FsrmReportRunningStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).get_RunningStatus(@ptrCast(*const IFsrmReportJob, self), runningStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_get_LastRun(self: *const T, lastRun: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).get_LastRun(@ptrCast(*const IFsrmReportJob, self), lastRun);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_get_LastError(self: *const T, lastError: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).get_LastError(@ptrCast(*const IFsrmReportJob, self), lastError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_get_LastGeneratedInDirectory(self: *const T, path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).get_LastGeneratedInDirectory(@ptrCast(*const IFsrmReportJob, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_EnumReports(self: *const T, reports: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).EnumReports(@ptrCast(*const IFsrmReportJob, self), reports);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_CreateReport(self: *const T, reportType: FsrmReportType, report: ?*?*IFsrmReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).CreateReport(@ptrCast(*const IFsrmReportJob, self), reportType, report);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_Run(self: *const T, context: FsrmReportGenerationContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).Run(@ptrCast(*const IFsrmReportJob, self), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_WaitForCompletion(self: *const T, waitSeconds: i32, completed: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).WaitForCompletion(@ptrCast(*const IFsrmReportJob, self), waitSeconds, completed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportJob_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportJob.VTable, self.vtable).Cancel(@ptrCast(*const IFsrmReportJob, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmReport_Value = @import("../zig.zig").Guid.initString("d8cc81d9-46b8-4fa4-bfa5-4aa9dec9b638");
pub const IID_IFsrmReport = &IID_IFsrmReport_Value;
pub const IFsrmReport = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IFsrmReport,
            reportType: ?*FsrmReportType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmReport,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFsrmReport,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IFsrmReport,
            description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IFsrmReport,
            description: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastGeneratedFileNamePrefix: fn(
            self: *const IFsrmReport,
            prefix: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilter: fn(
            self: *const IFsrmReport,
            filter: FsrmReportFilter,
            filterValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilter: fn(
            self: *const IFsrmReport,
            filter: FsrmReportFilter,
            filterValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IFsrmReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReport_get_Type(self: *const T, reportType: ?*FsrmReportType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReport.VTable, self.vtable).get_Type(@ptrCast(*const IFsrmReport, self), reportType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReport_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReport.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmReport, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReport_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReport.VTable, self.vtable).put_Name(@ptrCast(*const IFsrmReport, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReport_get_Description(self: *const T, description: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReport.VTable, self.vtable).get_Description(@ptrCast(*const IFsrmReport, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReport_put_Description(self: *const T, description: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReport.VTable, self.vtable).put_Description(@ptrCast(*const IFsrmReport, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReport_get_LastGeneratedFileNamePrefix(self: *const T, prefix: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReport.VTable, self.vtable).get_LastGeneratedFileNamePrefix(@ptrCast(*const IFsrmReport, self), prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReport_GetFilter(self: *const T, filter: FsrmReportFilter, filterValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReport.VTable, self.vtable).GetFilter(@ptrCast(*const IFsrmReport, self), filter, filterValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReport_SetFilter(self: *const T, filter: FsrmReportFilter, filterValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReport.VTable, self.vtable).SetFilter(@ptrCast(*const IFsrmReport, self), filter, filterValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReport_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReport.VTable, self.vtable).Delete(@ptrCast(*const IFsrmReport, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmReportScheduler_Value = @import("../zig.zig").Guid.initString("6879caf9-6617-4484-8719-71c3d8645f94");
pub const IID_IFsrmReportScheduler = &IID_IFsrmReportScheduler_Value;
pub const IFsrmReportScheduler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        VerifyNamespaces: fn(
            self: *const IFsrmReportScheduler,
            namespacesSafeArray: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateScheduleTask: fn(
            self: *const IFsrmReportScheduler,
            taskName: ?BSTR,
            namespacesSafeArray: ?*VARIANT,
            serializedTask: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyScheduleTask: fn(
            self: *const IFsrmReportScheduler,
            taskName: ?BSTR,
            namespacesSafeArray: ?*VARIANT,
            serializedTask: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteScheduleTask: fn(
            self: *const IFsrmReportScheduler,
            taskName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportScheduler_VerifyNamespaces(self: *const T, namespacesSafeArray: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportScheduler.VTable, self.vtable).VerifyNamespaces(@ptrCast(*const IFsrmReportScheduler, self), namespacesSafeArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportScheduler_CreateScheduleTask(self: *const T, taskName: ?BSTR, namespacesSafeArray: ?*VARIANT, serializedTask: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportScheduler.VTable, self.vtable).CreateScheduleTask(@ptrCast(*const IFsrmReportScheduler, self), taskName, namespacesSafeArray, serializedTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportScheduler_ModifyScheduleTask(self: *const T, taskName: ?BSTR, namespacesSafeArray: ?*VARIANT, serializedTask: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportScheduler.VTable, self.vtable).ModifyScheduleTask(@ptrCast(*const IFsrmReportScheduler, self), taskName, namespacesSafeArray, serializedTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmReportScheduler_DeleteScheduleTask(self: *const T, taskName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmReportScheduler.VTable, self.vtable).DeleteScheduleTask(@ptrCast(*const IFsrmReportScheduler, self), taskName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileManagementJobManager_Value = @import("../zig.zig").Guid.initString("ee321ecb-d95e-48e9-907c-c7685a013235");
pub const IID_IFsrmFileManagementJobManager = &IID_IFsrmFileManagementJobManager_Value;
pub const IFsrmFileManagementJobManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActionVariables: fn(
            self: *const IFsrmFileManagementJobManager,
            variables: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActionVariableDescriptions: fn(
            self: *const IFsrmFileManagementJobManager,
            descriptions: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFileManagementJobs: fn(
            self: *const IFsrmFileManagementJobManager,
            options: FsrmEnumOptions,
            fileManagementJobs: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFileManagementJob: fn(
            self: *const IFsrmFileManagementJobManager,
            fileManagementJob: ?*?*IFsrmFileManagementJob,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileManagementJob: fn(
            self: *const IFsrmFileManagementJobManager,
            name: ?BSTR,
            fileManagementJob: ?*?*IFsrmFileManagementJob,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJobManager_get_ActionVariables(self: *const T, variables: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJobManager.VTable, self.vtable).get_ActionVariables(@ptrCast(*const IFsrmFileManagementJobManager, self), variables);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJobManager_get_ActionVariableDescriptions(self: *const T, descriptions: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJobManager.VTable, self.vtable).get_ActionVariableDescriptions(@ptrCast(*const IFsrmFileManagementJobManager, self), descriptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJobManager_EnumFileManagementJobs(self: *const T, options: FsrmEnumOptions, fileManagementJobs: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJobManager.VTable, self.vtable).EnumFileManagementJobs(@ptrCast(*const IFsrmFileManagementJobManager, self), options, fileManagementJobs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJobManager_CreateFileManagementJob(self: *const T, fileManagementJob: ?*?*IFsrmFileManagementJob) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJobManager.VTable, self.vtable).CreateFileManagementJob(@ptrCast(*const IFsrmFileManagementJobManager, self), fileManagementJob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJobManager_GetFileManagementJob(self: *const T, name: ?BSTR, fileManagementJob: ?*?*IFsrmFileManagementJob) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJobManager.VTable, self.vtable).GetFileManagementJob(@ptrCast(*const IFsrmFileManagementJobManager, self), name, fileManagementJob);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmFileManagementJob_Value = @import("../zig.zig").Guid.initString("0770687e-9f36-4d6f-8778-599d188461c9");
pub const IID_IFsrmFileManagementJob = &IID_IFsrmFileManagementJob_Value;
pub const IFsrmFileManagementJob = extern struct {
    pub const VTable = extern struct {
        base: IFsrmObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmFileManagementJob,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFsrmFileManagementJob,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NamespaceRoots: fn(
            self: *const IFsrmFileManagementJob,
            namespaceRoots: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NamespaceRoots: fn(
            self: *const IFsrmFileManagementJob,
            namespaceRoots: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const IFsrmFileManagementJob,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const IFsrmFileManagementJob,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OperationType: fn(
            self: *const IFsrmFileManagementJob,
            operationType: ?*FsrmFileManagementType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OperationType: fn(
            self: *const IFsrmFileManagementJob,
            operationType: FsrmFileManagementType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpirationDirectory: fn(
            self: *const IFsrmFileManagementJob,
            expirationDirectory: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExpirationDirectory: fn(
            self: *const IFsrmFileManagementJob,
            expirationDirectory: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CustomAction: fn(
            self: *const IFsrmFileManagementJob,
            action: ?*?*IFsrmActionCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Notifications: fn(
            self: *const IFsrmFileManagementJob,
            notifications: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Logging: fn(
            self: *const IFsrmFileManagementJob,
            loggingFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Logging: fn(
            self: *const IFsrmFileManagementJob,
            loggingFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReportEnabled: fn(
            self: *const IFsrmFileManagementJob,
            reportEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReportEnabled: fn(
            self: *const IFsrmFileManagementJob,
            reportEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Formats: fn(
            self: *const IFsrmFileManagementJob,
            formats: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Formats: fn(
            self: *const IFsrmFileManagementJob,
            formats: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MailTo: fn(
            self: *const IFsrmFileManagementJob,
            mailTo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MailTo: fn(
            self: *const IFsrmFileManagementJob,
            mailTo: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DaysSinceFileCreated: fn(
            self: *const IFsrmFileManagementJob,
            daysSinceCreation: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DaysSinceFileCreated: fn(
            self: *const IFsrmFileManagementJob,
            daysSinceCreation: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DaysSinceFileLastAccessed: fn(
            self: *const IFsrmFileManagementJob,
            daysSinceAccess: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DaysSinceFileLastAccessed: fn(
            self: *const IFsrmFileManagementJob,
            daysSinceAccess: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DaysSinceFileLastModified: fn(
            self: *const IFsrmFileManagementJob,
            daysSinceModify: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DaysSinceFileLastModified: fn(
            self: *const IFsrmFileManagementJob,
            daysSinceModify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyConditions: fn(
            self: *const IFsrmFileManagementJob,
            propertyConditions: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FromDate: fn(
            self: *const IFsrmFileManagementJob,
            fromDate: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FromDate: fn(
            self: *const IFsrmFileManagementJob,
            fromDate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Task: fn(
            self: *const IFsrmFileManagementJob,
            taskName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Task: fn(
            self: *const IFsrmFileManagementJob,
            taskName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parameters: fn(
            self: *const IFsrmFileManagementJob,
            parameters: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Parameters: fn(
            self: *const IFsrmFileManagementJob,
            parameters: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunningStatus: fn(
            self: *const IFsrmFileManagementJob,
            runningStatus: ?*FsrmReportRunningStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastError: fn(
            self: *const IFsrmFileManagementJob,
            lastError: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastReportPathWithoutExtension: fn(
            self: *const IFsrmFileManagementJob,
            path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastRun: fn(
            self: *const IFsrmFileManagementJob,
            lastRun: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileNamePattern: fn(
            self: *const IFsrmFileManagementJob,
            fileNamePattern: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileNamePattern: fn(
            self: *const IFsrmFileManagementJob,
            fileNamePattern: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IFsrmFileManagementJob,
            context: FsrmReportGenerationContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForCompletion: fn(
            self: *const IFsrmFileManagementJob,
            waitSeconds: i32,
            completed: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IFsrmFileManagementJob,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddNotification: fn(
            self: *const IFsrmFileManagementJob,
            days: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteNotification: fn(
            self: *const IFsrmFileManagementJob,
            days: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyNotification: fn(
            self: *const IFsrmFileManagementJob,
            days: i32,
            newDays: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateNotificationAction: fn(
            self: *const IFsrmFileManagementJob,
            days: i32,
            actionType: FsrmActionType,
            action: ?*?*IFsrmAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumNotificationActions: fn(
            self: *const IFsrmFileManagementJob,
            days: i32,
            actions: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePropertyCondition: fn(
            self: *const IFsrmFileManagementJob,
            name: ?BSTR,
            propertyCondition: ?*?*IFsrmPropertyCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCustomAction: fn(
            self: *const IFsrmFileManagementJob,
            customAction: ?*?*IFsrmActionCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmFileManagementJob, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_Name(@ptrCast(*const IFsrmFileManagementJob, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_NamespaceRoots(self: *const T, namespaceRoots: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_NamespaceRoots(@ptrCast(*const IFsrmFileManagementJob, self), namespaceRoots);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_NamespaceRoots(self: *const T, namespaceRoots: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_NamespaceRoots(@ptrCast(*const IFsrmFileManagementJob, self), namespaceRoots);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_Enabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_Enabled(@ptrCast(*const IFsrmFileManagementJob, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_Enabled(@ptrCast(*const IFsrmFileManagementJob, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_OperationType(self: *const T, operationType: ?*FsrmFileManagementType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_OperationType(@ptrCast(*const IFsrmFileManagementJob, self), operationType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_OperationType(self: *const T, operationType: FsrmFileManagementType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_OperationType(@ptrCast(*const IFsrmFileManagementJob, self), operationType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_ExpirationDirectory(self: *const T, expirationDirectory: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_ExpirationDirectory(@ptrCast(*const IFsrmFileManagementJob, self), expirationDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_ExpirationDirectory(self: *const T, expirationDirectory: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_ExpirationDirectory(@ptrCast(*const IFsrmFileManagementJob, self), expirationDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_CustomAction(self: *const T, action: ?*?*IFsrmActionCommand) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_CustomAction(@ptrCast(*const IFsrmFileManagementJob, self), action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_Notifications(self: *const T, notifications: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_Notifications(@ptrCast(*const IFsrmFileManagementJob, self), notifications);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_Logging(self: *const T, loggingFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_Logging(@ptrCast(*const IFsrmFileManagementJob, self), loggingFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_Logging(self: *const T, loggingFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_Logging(@ptrCast(*const IFsrmFileManagementJob, self), loggingFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_ReportEnabled(self: *const T, reportEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_ReportEnabled(@ptrCast(*const IFsrmFileManagementJob, self), reportEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_ReportEnabled(self: *const T, reportEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_ReportEnabled(@ptrCast(*const IFsrmFileManagementJob, self), reportEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_Formats(self: *const T, formats: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_Formats(@ptrCast(*const IFsrmFileManagementJob, self), formats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_Formats(self: *const T, formats: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_Formats(@ptrCast(*const IFsrmFileManagementJob, self), formats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_MailTo(self: *const T, mailTo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_MailTo(@ptrCast(*const IFsrmFileManagementJob, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_MailTo(self: *const T, mailTo: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_MailTo(@ptrCast(*const IFsrmFileManagementJob, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_DaysSinceFileCreated(self: *const T, daysSinceCreation: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_DaysSinceFileCreated(@ptrCast(*const IFsrmFileManagementJob, self), daysSinceCreation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_DaysSinceFileCreated(self: *const T, daysSinceCreation: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_DaysSinceFileCreated(@ptrCast(*const IFsrmFileManagementJob, self), daysSinceCreation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_DaysSinceFileLastAccessed(self: *const T, daysSinceAccess: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_DaysSinceFileLastAccessed(@ptrCast(*const IFsrmFileManagementJob, self), daysSinceAccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_DaysSinceFileLastAccessed(self: *const T, daysSinceAccess: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_DaysSinceFileLastAccessed(@ptrCast(*const IFsrmFileManagementJob, self), daysSinceAccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_DaysSinceFileLastModified(self: *const T, daysSinceModify: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_DaysSinceFileLastModified(@ptrCast(*const IFsrmFileManagementJob, self), daysSinceModify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_DaysSinceFileLastModified(self: *const T, daysSinceModify: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_DaysSinceFileLastModified(@ptrCast(*const IFsrmFileManagementJob, self), daysSinceModify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_PropertyConditions(self: *const T, propertyConditions: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_PropertyConditions(@ptrCast(*const IFsrmFileManagementJob, self), propertyConditions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_FromDate(self: *const T, fromDate: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_FromDate(@ptrCast(*const IFsrmFileManagementJob, self), fromDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_FromDate(self: *const T, fromDate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_FromDate(@ptrCast(*const IFsrmFileManagementJob, self), fromDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_Task(self: *const T, taskName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_Task(@ptrCast(*const IFsrmFileManagementJob, self), taskName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_Task(self: *const T, taskName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_Task(@ptrCast(*const IFsrmFileManagementJob, self), taskName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_Parameters(self: *const T, parameters: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_Parameters(@ptrCast(*const IFsrmFileManagementJob, self), parameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_Parameters(self: *const T, parameters: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_Parameters(@ptrCast(*const IFsrmFileManagementJob, self), parameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_RunningStatus(self: *const T, runningStatus: ?*FsrmReportRunningStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_RunningStatus(@ptrCast(*const IFsrmFileManagementJob, self), runningStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_LastError(self: *const T, lastError: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_LastError(@ptrCast(*const IFsrmFileManagementJob, self), lastError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_LastReportPathWithoutExtension(self: *const T, path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_LastReportPathWithoutExtension(@ptrCast(*const IFsrmFileManagementJob, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_LastRun(self: *const T, lastRun: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_LastRun(@ptrCast(*const IFsrmFileManagementJob, self), lastRun);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_get_FileNamePattern(self: *const T, fileNamePattern: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).get_FileNamePattern(@ptrCast(*const IFsrmFileManagementJob, self), fileNamePattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_put_FileNamePattern(self: *const T, fileNamePattern: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).put_FileNamePattern(@ptrCast(*const IFsrmFileManagementJob, self), fileNamePattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_Run(self: *const T, context: FsrmReportGenerationContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).Run(@ptrCast(*const IFsrmFileManagementJob, self), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_WaitForCompletion(self: *const T, waitSeconds: i32, completed: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).WaitForCompletion(@ptrCast(*const IFsrmFileManagementJob, self), waitSeconds, completed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).Cancel(@ptrCast(*const IFsrmFileManagementJob, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_AddNotification(self: *const T, days: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).AddNotification(@ptrCast(*const IFsrmFileManagementJob, self), days);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_DeleteNotification(self: *const T, days: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).DeleteNotification(@ptrCast(*const IFsrmFileManagementJob, self), days);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_ModifyNotification(self: *const T, days: i32, newDays: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).ModifyNotification(@ptrCast(*const IFsrmFileManagementJob, self), days, newDays);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_CreateNotificationAction(self: *const T, days: i32, actionType: FsrmActionType, action: ?*?*IFsrmAction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).CreateNotificationAction(@ptrCast(*const IFsrmFileManagementJob, self), days, actionType, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_EnumNotificationActions(self: *const T, days: i32, actions: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).EnumNotificationActions(@ptrCast(*const IFsrmFileManagementJob, self), days, actions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_CreatePropertyCondition(self: *const T, name: ?BSTR, propertyCondition: ?*?*IFsrmPropertyCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).CreatePropertyCondition(@ptrCast(*const IFsrmFileManagementJob, self), name, propertyCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileManagementJob_CreateCustomAction(self: *const T, customAction: ?*?*IFsrmActionCommand) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileManagementJob.VTable, self.vtable).CreateCustomAction(@ptrCast(*const IFsrmFileManagementJob, self), customAction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmPropertyCondition_Value = @import("../zig.zig").Guid.initString("326af66f-2ac0-4f68-bf8c-4759f054fa29");
pub const IID_IFsrmPropertyCondition = &IID_IFsrmPropertyCondition_Value;
pub const IFsrmPropertyCondition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmPropertyCondition,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFsrmPropertyCondition,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IFsrmPropertyCondition,
            type: ?*FsrmPropertyConditionType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Type: fn(
            self: *const IFsrmPropertyCondition,
            type: FsrmPropertyConditionType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IFsrmPropertyCondition,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: fn(
            self: *const IFsrmPropertyCondition,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IFsrmPropertyCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyCondition_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyCondition.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmPropertyCondition, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyCondition_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyCondition.VTable, self.vtable).put_Name(@ptrCast(*const IFsrmPropertyCondition, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyCondition_get_Type(self: *const T, type_: ?*FsrmPropertyConditionType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyCondition.VTable, self.vtable).get_Type(@ptrCast(*const IFsrmPropertyCondition, self), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyCondition_put_Type(self: *const T, type_: FsrmPropertyConditionType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyCondition.VTable, self.vtable).put_Type(@ptrCast(*const IFsrmPropertyCondition, self), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyCondition_get_Value(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyCondition.VTable, self.vtable).get_Value(@ptrCast(*const IFsrmPropertyCondition, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyCondition_put_Value(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyCondition.VTable, self.vtable).put_Value(@ptrCast(*const IFsrmPropertyCondition, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyCondition_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyCondition.VTable, self.vtable).Delete(@ptrCast(*const IFsrmPropertyCondition, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFsrmFileCondition_Value = @import("../zig.zig").Guid.initString("70684ffc-691a-4a1a-b922-97752e138cc1");
pub const IID_IFsrmFileCondition = &IID_IFsrmFileCondition_Value;
pub const IFsrmFileCondition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IFsrmFileCondition,
            pVal: ?*FsrmFileConditionType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IFsrmFileCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileCondition_get_Type(self: *const T, pVal: ?*FsrmFileConditionType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileCondition.VTable, self.vtable).get_Type(@ptrCast(*const IFsrmFileCondition, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileCondition_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileCondition.VTable, self.vtable).Delete(@ptrCast(*const IFsrmFileCondition, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IFsrmFileConditionProperty_Value = @import("../zig.zig").Guid.initString("81926775-b981-4479-988f-da171d627360");
pub const IID_IFsrmFileConditionProperty = &IID_IFsrmFileConditionProperty_Value;
pub const IFsrmFileConditionProperty = extern struct {
    pub const VTable = extern struct {
        base: IFsrmFileCondition.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyName: fn(
            self: *const IFsrmFileConditionProperty,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PropertyName: fn(
            self: *const IFsrmFileConditionProperty,
            newVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyId: fn(
            self: *const IFsrmFileConditionProperty,
            pVal: ?*FsrmFileSystemPropertyId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PropertyId: fn(
            self: *const IFsrmFileConditionProperty,
            newVal: FsrmFileSystemPropertyId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Operator: fn(
            self: *const IFsrmFileConditionProperty,
            pVal: ?*FsrmPropertyConditionType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Operator: fn(
            self: *const IFsrmFileConditionProperty,
            newVal: FsrmPropertyConditionType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ValueType: fn(
            self: *const IFsrmFileConditionProperty,
            pVal: ?*FsrmPropertyValueType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ValueType: fn(
            self: *const IFsrmFileConditionProperty,
            newVal: FsrmPropertyValueType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IFsrmFileConditionProperty,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: fn(
            self: *const IFsrmFileConditionProperty,
            newVal: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmFileCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_get_PropertyName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).get_PropertyName(@ptrCast(*const IFsrmFileConditionProperty, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_put_PropertyName(self: *const T, newVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).put_PropertyName(@ptrCast(*const IFsrmFileConditionProperty, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_get_PropertyId(self: *const T, pVal: ?*FsrmFileSystemPropertyId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).get_PropertyId(@ptrCast(*const IFsrmFileConditionProperty, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_put_PropertyId(self: *const T, newVal: FsrmFileSystemPropertyId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).put_PropertyId(@ptrCast(*const IFsrmFileConditionProperty, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_get_Operator(self: *const T, pVal: ?*FsrmPropertyConditionType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).get_Operator(@ptrCast(*const IFsrmFileConditionProperty, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_put_Operator(self: *const T, newVal: FsrmPropertyConditionType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).put_Operator(@ptrCast(*const IFsrmFileConditionProperty, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_get_ValueType(self: *const T, pVal: ?*FsrmPropertyValueType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).get_ValueType(@ptrCast(*const IFsrmFileConditionProperty, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_put_ValueType(self: *const T, newVal: FsrmPropertyValueType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).put_ValueType(@ptrCast(*const IFsrmFileConditionProperty, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_get_Value(self: *const T, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).get_Value(@ptrCast(*const IFsrmFileConditionProperty, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmFileConditionProperty_put_Value(self: *const T, newVal: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmFileConditionProperty.VTable, self.vtable).put_Value(@ptrCast(*const IFsrmFileConditionProperty, self), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmPropertyDefinition_Value = @import("../zig.zig").Guid.initString("ede0150f-e9a3-419c-877c-01fe5d24c5d3");
pub const IID_IFsrmPropertyDefinition = &IID_IFsrmPropertyDefinition_Value;
pub const IFsrmPropertyDefinition = extern struct {
    pub const VTable = extern struct {
        base: IFsrmObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmPropertyDefinition,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFsrmPropertyDefinition,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IFsrmPropertyDefinition,
            type: ?*FsrmPropertyDefinitionType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Type: fn(
            self: *const IFsrmPropertyDefinition,
            type: FsrmPropertyDefinitionType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PossibleValues: fn(
            self: *const IFsrmPropertyDefinition,
            possibleValues: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PossibleValues: fn(
            self: *const IFsrmPropertyDefinition,
            possibleValues: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ValueDescriptions: fn(
            self: *const IFsrmPropertyDefinition,
            valueDescriptions: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ValueDescriptions: fn(
            self: *const IFsrmPropertyDefinition,
            valueDescriptions: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parameters: fn(
            self: *const IFsrmPropertyDefinition,
            parameters: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Parameters: fn(
            self: *const IFsrmPropertyDefinition,
            parameters: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmPropertyDefinition, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).put_Name(@ptrCast(*const IFsrmPropertyDefinition, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_get_Type(self: *const T, type_: ?*FsrmPropertyDefinitionType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).get_Type(@ptrCast(*const IFsrmPropertyDefinition, self), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_put_Type(self: *const T, type_: FsrmPropertyDefinitionType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).put_Type(@ptrCast(*const IFsrmPropertyDefinition, self), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_get_PossibleValues(self: *const T, possibleValues: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).get_PossibleValues(@ptrCast(*const IFsrmPropertyDefinition, self), possibleValues);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_put_PossibleValues(self: *const T, possibleValues: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).put_PossibleValues(@ptrCast(*const IFsrmPropertyDefinition, self), possibleValues);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_get_ValueDescriptions(self: *const T, valueDescriptions: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).get_ValueDescriptions(@ptrCast(*const IFsrmPropertyDefinition, self), valueDescriptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_put_ValueDescriptions(self: *const T, valueDescriptions: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).put_ValueDescriptions(@ptrCast(*const IFsrmPropertyDefinition, self), valueDescriptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_get_Parameters(self: *const T, parameters: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).get_Parameters(@ptrCast(*const IFsrmPropertyDefinition, self), parameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition_put_Parameters(self: *const T, parameters: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition.VTable, self.vtable).put_Parameters(@ptrCast(*const IFsrmPropertyDefinition, self), parameters);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IFsrmPropertyDefinition2_Value = @import("../zig.zig").Guid.initString("47782152-d16c-4229-b4e1-0ddfe308b9f6");
pub const IID_IFsrmPropertyDefinition2 = &IID_IFsrmPropertyDefinition2_Value;
pub const IFsrmPropertyDefinition2 = extern struct {
    pub const VTable = extern struct {
        base: IFsrmPropertyDefinition.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyDefinitionFlags: fn(
            self: *const IFsrmPropertyDefinition2,
            propertyDefinitionFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: fn(
            self: *const IFsrmPropertyDefinition2,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplayName: fn(
            self: *const IFsrmPropertyDefinition2,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppliesTo: fn(
            self: *const IFsrmPropertyDefinition2,
            appliesTo: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ValueDefinitions: fn(
            self: *const IFsrmPropertyDefinition2,
            valueDefinitions: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmPropertyDefinition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition2_get_PropertyDefinitionFlags(self: *const T, propertyDefinitionFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition2.VTable, self.vtable).get_PropertyDefinitionFlags(@ptrCast(*const IFsrmPropertyDefinition2, self), propertyDefinitionFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition2_get_DisplayName(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition2.VTable, self.vtable).get_DisplayName(@ptrCast(*const IFsrmPropertyDefinition2, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition2_put_DisplayName(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition2.VTable, self.vtable).put_DisplayName(@ptrCast(*const IFsrmPropertyDefinition2, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition2_get_AppliesTo(self: *const T, appliesTo: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition2.VTable, self.vtable).get_AppliesTo(@ptrCast(*const IFsrmPropertyDefinition2, self), appliesTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinition2_get_ValueDefinitions(self: *const T, valueDefinitions: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinition2.VTable, self.vtable).get_ValueDefinitions(@ptrCast(*const IFsrmPropertyDefinition2, self), valueDefinitions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IFsrmPropertyDefinitionValue_Value = @import("../zig.zig").Guid.initString("e946d148-bd67-4178-8e22-1c44925ed710");
pub const IID_IFsrmPropertyDefinitionValue = &IID_IFsrmPropertyDefinitionValue_Value;
pub const IFsrmPropertyDefinitionValue = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmPropertyDefinitionValue,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: fn(
            self: *const IFsrmPropertyDefinitionValue,
            displayName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IFsrmPropertyDefinitionValue,
            description: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UniqueID: fn(
            self: *const IFsrmPropertyDefinitionValue,
            uniqueID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinitionValue_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinitionValue.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmPropertyDefinitionValue, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinitionValue_get_DisplayName(self: *const T, displayName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinitionValue.VTable, self.vtable).get_DisplayName(@ptrCast(*const IFsrmPropertyDefinitionValue, self), displayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinitionValue_get_Description(self: *const T, description: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinitionValue.VTable, self.vtable).get_Description(@ptrCast(*const IFsrmPropertyDefinitionValue, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyDefinitionValue_get_UniqueID(self: *const T, uniqueID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyDefinitionValue.VTable, self.vtable).get_UniqueID(@ptrCast(*const IFsrmPropertyDefinitionValue, self), uniqueID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmProperty_Value = @import("../zig.zig").Guid.initString("4a73fee4-4102-4fcc-9ffb-38614f9ee768");
pub const IID_IFsrmProperty = &IID_IFsrmProperty_Value;
pub const IFsrmProperty = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmProperty,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IFsrmProperty,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Sources: fn(
            self: *const IFsrmProperty,
            sources: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyFlags: fn(
            self: *const IFsrmProperty,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmProperty_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmProperty.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmProperty, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmProperty_get_Value(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmProperty.VTable, self.vtable).get_Value(@ptrCast(*const IFsrmProperty, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmProperty_get_Sources(self: *const T, sources: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmProperty.VTable, self.vtable).get_Sources(@ptrCast(*const IFsrmProperty, self), sources);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmProperty_get_PropertyFlags(self: *const T, flags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmProperty.VTable, self.vtable).get_PropertyFlags(@ptrCast(*const IFsrmProperty, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmRule_Value = @import("../zig.zig").Guid.initString("cb0df960-16f5-4495-9079-3f9360d831df");
pub const IID_IFsrmRule = &IID_IFsrmRule_Value;
pub const IFsrmRule = extern struct {
    pub const VTable = extern struct {
        base: IFsrmObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmRule,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFsrmRule,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RuleType: fn(
            self: *const IFsrmRule,
            ruleType: ?*FsrmRuleType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleDefinitionName: fn(
            self: *const IFsrmRule,
            moduleDefinitionName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ModuleDefinitionName: fn(
            self: *const IFsrmRule,
            moduleDefinitionName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NamespaceRoots: fn(
            self: *const IFsrmRule,
            namespaceRoots: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NamespaceRoots: fn(
            self: *const IFsrmRule,
            namespaceRoots: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RuleFlags: fn(
            self: *const IFsrmRule,
            ruleFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RuleFlags: fn(
            self: *const IFsrmRule,
            ruleFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parameters: fn(
            self: *const IFsrmRule,
            parameters: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Parameters: fn(
            self: *const IFsrmRule,
            parameters: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastModified: fn(
            self: *const IFsrmRule,
            lastModified: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmRule, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).put_Name(@ptrCast(*const IFsrmRule, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_get_RuleType(self: *const T, ruleType: ?*FsrmRuleType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).get_RuleType(@ptrCast(*const IFsrmRule, self), ruleType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_get_ModuleDefinitionName(self: *const T, moduleDefinitionName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).get_ModuleDefinitionName(@ptrCast(*const IFsrmRule, self), moduleDefinitionName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_put_ModuleDefinitionName(self: *const T, moduleDefinitionName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).put_ModuleDefinitionName(@ptrCast(*const IFsrmRule, self), moduleDefinitionName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_get_NamespaceRoots(self: *const T, namespaceRoots: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).get_NamespaceRoots(@ptrCast(*const IFsrmRule, self), namespaceRoots);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_put_NamespaceRoots(self: *const T, namespaceRoots: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).put_NamespaceRoots(@ptrCast(*const IFsrmRule, self), namespaceRoots);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_get_RuleFlags(self: *const T, ruleFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).get_RuleFlags(@ptrCast(*const IFsrmRule, self), ruleFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_put_RuleFlags(self: *const T, ruleFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).put_RuleFlags(@ptrCast(*const IFsrmRule, self), ruleFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_get_Parameters(self: *const T, parameters: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).get_Parameters(@ptrCast(*const IFsrmRule, self), parameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_put_Parameters(self: *const T, parameters: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).put_Parameters(@ptrCast(*const IFsrmRule, self), parameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmRule_get_LastModified(self: *const T, lastModified: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmRule.VTable, self.vtable).get_LastModified(@ptrCast(*const IFsrmRule, self), lastModified);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmClassificationRule_Value = @import("../zig.zig").Guid.initString("afc052c2-5315-45ab-841b-c6db0e120148");
pub const IID_IFsrmClassificationRule = &IID_IFsrmClassificationRule_Value;
pub const IFsrmClassificationRule = extern struct {
    pub const VTable = extern struct {
        base: IFsrmRule.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExecutionOption: fn(
            self: *const IFsrmClassificationRule,
            executionOption: ?*FsrmExecutionOption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExecutionOption: fn(
            self: *const IFsrmClassificationRule,
            executionOption: FsrmExecutionOption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyAffected: fn(
            self: *const IFsrmClassificationRule,
            property: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PropertyAffected: fn(
            self: *const IFsrmClassificationRule,
            property: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const IFsrmClassificationRule,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: fn(
            self: *const IFsrmClassificationRule,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmRule.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationRule_get_ExecutionOption(self: *const T, executionOption: ?*FsrmExecutionOption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationRule.VTable, self.vtable).get_ExecutionOption(@ptrCast(*const IFsrmClassificationRule, self), executionOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationRule_put_ExecutionOption(self: *const T, executionOption: FsrmExecutionOption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationRule.VTable, self.vtable).put_ExecutionOption(@ptrCast(*const IFsrmClassificationRule, self), executionOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationRule_get_PropertyAffected(self: *const T, property: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationRule.VTable, self.vtable).get_PropertyAffected(@ptrCast(*const IFsrmClassificationRule, self), property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationRule_put_PropertyAffected(self: *const T, property: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationRule.VTable, self.vtable).put_PropertyAffected(@ptrCast(*const IFsrmClassificationRule, self), property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationRule_get_Value(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationRule.VTable, self.vtable).get_Value(@ptrCast(*const IFsrmClassificationRule, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationRule_put_Value(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationRule.VTable, self.vtable).put_Value(@ptrCast(*const IFsrmClassificationRule, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmPipelineModuleDefinition_Value = @import("../zig.zig").Guid.initString("515c1277-2c81-440e-8fcf-367921ed4f59");
pub const IID_IFsrmPipelineModuleDefinition = &IID_IFsrmPipelineModuleDefinition_Value;
pub const IFsrmPipelineModuleDefinition = extern struct {
    pub const VTable = extern struct {
        base: IFsrmObject.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleClsid: fn(
            self: *const IFsrmPipelineModuleDefinition,
            moduleClsid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ModuleClsid: fn(
            self: *const IFsrmPipelineModuleDefinition,
            moduleClsid: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmPipelineModuleDefinition,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const IFsrmPipelineModuleDefinition,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Company: fn(
            self: *const IFsrmPipelineModuleDefinition,
            company: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Company: fn(
            self: *const IFsrmPipelineModuleDefinition,
            company: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const IFsrmPipelineModuleDefinition,
            version: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Version: fn(
            self: *const IFsrmPipelineModuleDefinition,
            version: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleType: fn(
            self: *const IFsrmPipelineModuleDefinition,
            moduleType: ?*FsrmPipelineModuleType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const IFsrmPipelineModuleDefinition,
            enabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const IFsrmPipelineModuleDefinition,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NeedsFileContent: fn(
            self: *const IFsrmPipelineModuleDefinition,
            needsFileContent: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NeedsFileContent: fn(
            self: *const IFsrmPipelineModuleDefinition,
            needsFileContent: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Account: fn(
            self: *const IFsrmPipelineModuleDefinition,
            retrievalAccount: ?*FsrmAccountType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Account: fn(
            self: *const IFsrmPipelineModuleDefinition,
            retrievalAccount: FsrmAccountType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedExtensions: fn(
            self: *const IFsrmPipelineModuleDefinition,
            supportedExtensions: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SupportedExtensions: fn(
            self: *const IFsrmPipelineModuleDefinition,
            supportedExtensions: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parameters: fn(
            self: *const IFsrmPipelineModuleDefinition,
            parameters: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Parameters: fn(
            self: *const IFsrmPipelineModuleDefinition,
            parameters: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_ModuleClsid(self: *const T, moduleClsid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_ModuleClsid(@ptrCast(*const IFsrmPipelineModuleDefinition, self), moduleClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_put_ModuleClsid(self: *const T, moduleClsid: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).put_ModuleClsid(@ptrCast(*const IFsrmPipelineModuleDefinition, self), moduleClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmPipelineModuleDefinition, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).put_Name(@ptrCast(*const IFsrmPipelineModuleDefinition, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_Company(self: *const T, company: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_Company(@ptrCast(*const IFsrmPipelineModuleDefinition, self), company);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_put_Company(self: *const T, company: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).put_Company(@ptrCast(*const IFsrmPipelineModuleDefinition, self), company);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_Version(self: *const T, version: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_Version(@ptrCast(*const IFsrmPipelineModuleDefinition, self), version);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_put_Version(self: *const T, version: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).put_Version(@ptrCast(*const IFsrmPipelineModuleDefinition, self), version);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_ModuleType(self: *const T, moduleType: ?*FsrmPipelineModuleType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_ModuleType(@ptrCast(*const IFsrmPipelineModuleDefinition, self), moduleType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_Enabled(self: *const T, enabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_Enabled(@ptrCast(*const IFsrmPipelineModuleDefinition, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).put_Enabled(@ptrCast(*const IFsrmPipelineModuleDefinition, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_NeedsFileContent(self: *const T, needsFileContent: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_NeedsFileContent(@ptrCast(*const IFsrmPipelineModuleDefinition, self), needsFileContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_put_NeedsFileContent(self: *const T, needsFileContent: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).put_NeedsFileContent(@ptrCast(*const IFsrmPipelineModuleDefinition, self), needsFileContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_Account(self: *const T, retrievalAccount: ?*FsrmAccountType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_Account(@ptrCast(*const IFsrmPipelineModuleDefinition, self), retrievalAccount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_put_Account(self: *const T, retrievalAccount: FsrmAccountType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).put_Account(@ptrCast(*const IFsrmPipelineModuleDefinition, self), retrievalAccount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_SupportedExtensions(self: *const T, supportedExtensions: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_SupportedExtensions(@ptrCast(*const IFsrmPipelineModuleDefinition, self), supportedExtensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_put_SupportedExtensions(self: *const T, supportedExtensions: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).put_SupportedExtensions(@ptrCast(*const IFsrmPipelineModuleDefinition, self), supportedExtensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_get_Parameters(self: *const T, parameters: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).get_Parameters(@ptrCast(*const IFsrmPipelineModuleDefinition, self), parameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleDefinition_put_Parameters(self: *const T, parameters: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleDefinition.VTable, self.vtable).put_Parameters(@ptrCast(*const IFsrmPipelineModuleDefinition, self), parameters);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmClassifierModuleDefinition_Value = @import("../zig.zig").Guid.initString("bb36ea26-6318-4b8c-8592-f72dd602e7a5");
pub const IID_IFsrmClassifierModuleDefinition = &IID_IFsrmClassifierModuleDefinition_Value;
pub const IFsrmClassifierModuleDefinition = extern struct {
    pub const VTable = extern struct {
        base: IFsrmPipelineModuleDefinition.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertiesAffected: fn(
            self: *const IFsrmClassifierModuleDefinition,
            propertiesAffected: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PropertiesAffected: fn(
            self: *const IFsrmClassifierModuleDefinition,
            propertiesAffected: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertiesUsed: fn(
            self: *const IFsrmClassifierModuleDefinition,
            propertiesUsed: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PropertiesUsed: fn(
            self: *const IFsrmClassifierModuleDefinition,
            propertiesUsed: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NeedsExplicitValue: fn(
            self: *const IFsrmClassifierModuleDefinition,
            needsExplicitValue: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NeedsExplicitValue: fn(
            self: *const IFsrmClassifierModuleDefinition,
            needsExplicitValue: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmPipelineModuleDefinition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleDefinition_get_PropertiesAffected(self: *const T, propertiesAffected: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleDefinition.VTable, self.vtable).get_PropertiesAffected(@ptrCast(*const IFsrmClassifierModuleDefinition, self), propertiesAffected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleDefinition_put_PropertiesAffected(self: *const T, propertiesAffected: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleDefinition.VTable, self.vtable).put_PropertiesAffected(@ptrCast(*const IFsrmClassifierModuleDefinition, self), propertiesAffected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleDefinition_get_PropertiesUsed(self: *const T, propertiesUsed: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleDefinition.VTable, self.vtable).get_PropertiesUsed(@ptrCast(*const IFsrmClassifierModuleDefinition, self), propertiesUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleDefinition_put_PropertiesUsed(self: *const T, propertiesUsed: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleDefinition.VTable, self.vtable).put_PropertiesUsed(@ptrCast(*const IFsrmClassifierModuleDefinition, self), propertiesUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleDefinition_get_NeedsExplicitValue(self: *const T, needsExplicitValue: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleDefinition.VTable, self.vtable).get_NeedsExplicitValue(@ptrCast(*const IFsrmClassifierModuleDefinition, self), needsExplicitValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleDefinition_put_NeedsExplicitValue(self: *const T, needsExplicitValue: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleDefinition.VTable, self.vtable).put_NeedsExplicitValue(@ptrCast(*const IFsrmClassifierModuleDefinition, self), needsExplicitValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmStorageModuleDefinition_Value = @import("../zig.zig").Guid.initString("15a81350-497d-4aba-80e9-d4dbcc5521fe");
pub const IID_IFsrmStorageModuleDefinition = &IID_IFsrmStorageModuleDefinition_Value;
pub const IFsrmStorageModuleDefinition = extern struct {
    pub const VTable = extern struct {
        base: IFsrmPipelineModuleDefinition.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Capabilities: fn(
            self: *const IFsrmStorageModuleDefinition,
            capabilities: ?*FsrmStorageModuleCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Capabilities: fn(
            self: *const IFsrmStorageModuleDefinition,
            capabilities: FsrmStorageModuleCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StorageType: fn(
            self: *const IFsrmStorageModuleDefinition,
            storageType: ?*FsrmStorageModuleType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StorageType: fn(
            self: *const IFsrmStorageModuleDefinition,
            storageType: FsrmStorageModuleType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UpdatesFileContent: fn(
            self: *const IFsrmStorageModuleDefinition,
            updatesFileContent: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UpdatesFileContent: fn(
            self: *const IFsrmStorageModuleDefinition,
            updatesFileContent: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmPipelineModuleDefinition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmStorageModuleDefinition_get_Capabilities(self: *const T, capabilities: ?*FsrmStorageModuleCaps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmStorageModuleDefinition.VTable, self.vtable).get_Capabilities(@ptrCast(*const IFsrmStorageModuleDefinition, self), capabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmStorageModuleDefinition_put_Capabilities(self: *const T, capabilities: FsrmStorageModuleCaps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmStorageModuleDefinition.VTable, self.vtable).put_Capabilities(@ptrCast(*const IFsrmStorageModuleDefinition, self), capabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmStorageModuleDefinition_get_StorageType(self: *const T, storageType: ?*FsrmStorageModuleType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmStorageModuleDefinition.VTable, self.vtable).get_StorageType(@ptrCast(*const IFsrmStorageModuleDefinition, self), storageType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmStorageModuleDefinition_put_StorageType(self: *const T, storageType: FsrmStorageModuleType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmStorageModuleDefinition.VTable, self.vtable).put_StorageType(@ptrCast(*const IFsrmStorageModuleDefinition, self), storageType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmStorageModuleDefinition_get_UpdatesFileContent(self: *const T, updatesFileContent: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmStorageModuleDefinition.VTable, self.vtable).get_UpdatesFileContent(@ptrCast(*const IFsrmStorageModuleDefinition, self), updatesFileContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmStorageModuleDefinition_put_UpdatesFileContent(self: *const T, updatesFileContent: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmStorageModuleDefinition.VTable, self.vtable).put_UpdatesFileContent(@ptrCast(*const IFsrmStorageModuleDefinition, self), updatesFileContent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFsrmClassificationManager_Value = @import("../zig.zig").Guid.initString("d2dc89da-ee91-48a0-85d8-cc72a56f7d04");
pub const IID_IFsrmClassificationManager = &IID_IFsrmClassificationManager_Value;
pub const IFsrmClassificationManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassificationReportFormats: fn(
            self: *const IFsrmClassificationManager,
            formats: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClassificationReportFormats: fn(
            self: *const IFsrmClassificationManager,
            formats: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Logging: fn(
            self: *const IFsrmClassificationManager,
            logging: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Logging: fn(
            self: *const IFsrmClassificationManager,
            logging: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassificationReportMailTo: fn(
            self: *const IFsrmClassificationManager,
            mailTo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClassificationReportMailTo: fn(
            self: *const IFsrmClassificationManager,
            mailTo: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassificationReportEnabled: fn(
            self: *const IFsrmClassificationManager,
            reportEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClassificationReportEnabled: fn(
            self: *const IFsrmClassificationManager,
            reportEnabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassificationLastReportPathWithoutExtension: fn(
            self: *const IFsrmClassificationManager,
            lastReportPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassificationLastError: fn(
            self: *const IFsrmClassificationManager,
            lastError: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassificationRunningStatus: fn(
            self: *const IFsrmClassificationManager,
            runningStatus: ?*FsrmReportRunningStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPropertyDefinitions: fn(
            self: *const IFsrmClassificationManager,
            options: FsrmEnumOptions,
            propertyDefinitions: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePropertyDefinition: fn(
            self: *const IFsrmClassificationManager,
            propertyDefinition: ?*?*IFsrmPropertyDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyDefinition: fn(
            self: *const IFsrmClassificationManager,
            propertyName: ?BSTR,
            propertyDefinition: ?*?*IFsrmPropertyDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRules: fn(
            self: *const IFsrmClassificationManager,
            ruleType: FsrmRuleType,
            options: FsrmEnumOptions,
            Rules: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRule: fn(
            self: *const IFsrmClassificationManager,
            ruleType: FsrmRuleType,
            Rule: ?*?*IFsrmRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRule: fn(
            self: *const IFsrmClassificationManager,
            ruleName: ?BSTR,
            ruleType: FsrmRuleType,
            Rule: ?*?*IFsrmRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumModuleDefinitions: fn(
            self: *const IFsrmClassificationManager,
            moduleType: FsrmPipelineModuleType,
            options: FsrmEnumOptions,
            moduleDefinitions: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateModuleDefinition: fn(
            self: *const IFsrmClassificationManager,
            moduleType: FsrmPipelineModuleType,
            moduleDefinition: ?*?*IFsrmPipelineModuleDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleDefinition: fn(
            self: *const IFsrmClassificationManager,
            moduleName: ?BSTR,
            moduleType: FsrmPipelineModuleType,
            moduleDefinition: ?*?*IFsrmPipelineModuleDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunClassification: fn(
            self: *const IFsrmClassificationManager,
            context: FsrmReportGenerationContext,
            reserved: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForClassificationCompletion: fn(
            self: *const IFsrmClassificationManager,
            waitSeconds: i32,
            completed: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelClassification: fn(
            self: *const IFsrmClassificationManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFileProperties: fn(
            self: *const IFsrmClassificationManager,
            filePath: ?BSTR,
            options: FsrmGetFilePropertyOptions,
            fileProperties: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileProperty: fn(
            self: *const IFsrmClassificationManager,
            filePath: ?BSTR,
            propertyName: ?BSTR,
            options: FsrmGetFilePropertyOptions,
            property: ?*?*IFsrmProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFileProperty: fn(
            self: *const IFsrmClassificationManager,
            filePath: ?BSTR,
            propertyName: ?BSTR,
            propertyValue: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearFileProperty: fn(
            self: *const IFsrmClassificationManager,
            filePath: ?BSTR,
            property: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_get_ClassificationReportFormats(self: *const T, formats: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).get_ClassificationReportFormats(@ptrCast(*const IFsrmClassificationManager, self), formats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_put_ClassificationReportFormats(self: *const T, formats: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).put_ClassificationReportFormats(@ptrCast(*const IFsrmClassificationManager, self), formats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_get_Logging(self: *const T, logging: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).get_Logging(@ptrCast(*const IFsrmClassificationManager, self), logging);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_put_Logging(self: *const T, logging: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).put_Logging(@ptrCast(*const IFsrmClassificationManager, self), logging);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_get_ClassificationReportMailTo(self: *const T, mailTo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).get_ClassificationReportMailTo(@ptrCast(*const IFsrmClassificationManager, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_put_ClassificationReportMailTo(self: *const T, mailTo: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).put_ClassificationReportMailTo(@ptrCast(*const IFsrmClassificationManager, self), mailTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_get_ClassificationReportEnabled(self: *const T, reportEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).get_ClassificationReportEnabled(@ptrCast(*const IFsrmClassificationManager, self), reportEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_put_ClassificationReportEnabled(self: *const T, reportEnabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).put_ClassificationReportEnabled(@ptrCast(*const IFsrmClassificationManager, self), reportEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_get_ClassificationLastReportPathWithoutExtension(self: *const T, lastReportPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).get_ClassificationLastReportPathWithoutExtension(@ptrCast(*const IFsrmClassificationManager, self), lastReportPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_get_ClassificationLastError(self: *const T, lastError: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).get_ClassificationLastError(@ptrCast(*const IFsrmClassificationManager, self), lastError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_get_ClassificationRunningStatus(self: *const T, runningStatus: ?*FsrmReportRunningStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).get_ClassificationRunningStatus(@ptrCast(*const IFsrmClassificationManager, self), runningStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_EnumPropertyDefinitions(self: *const T, options: FsrmEnumOptions, propertyDefinitions: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).EnumPropertyDefinitions(@ptrCast(*const IFsrmClassificationManager, self), options, propertyDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_CreatePropertyDefinition(self: *const T, propertyDefinition: ?*?*IFsrmPropertyDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).CreatePropertyDefinition(@ptrCast(*const IFsrmClassificationManager, self), propertyDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_GetPropertyDefinition(self: *const T, propertyName: ?BSTR, propertyDefinition: ?*?*IFsrmPropertyDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).GetPropertyDefinition(@ptrCast(*const IFsrmClassificationManager, self), propertyName, propertyDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_EnumRules(self: *const T, ruleType: FsrmRuleType, options: FsrmEnumOptions, Rules: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).EnumRules(@ptrCast(*const IFsrmClassificationManager, self), ruleType, options, Rules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_CreateRule(self: *const T, ruleType: FsrmRuleType, Rule: ?*?*IFsrmRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).CreateRule(@ptrCast(*const IFsrmClassificationManager, self), ruleType, Rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_GetRule(self: *const T, ruleName: ?BSTR, ruleType: FsrmRuleType, Rule: ?*?*IFsrmRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).GetRule(@ptrCast(*const IFsrmClassificationManager, self), ruleName, ruleType, Rule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_EnumModuleDefinitions(self: *const T, moduleType: FsrmPipelineModuleType, options: FsrmEnumOptions, moduleDefinitions: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).EnumModuleDefinitions(@ptrCast(*const IFsrmClassificationManager, self), moduleType, options, moduleDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_CreateModuleDefinition(self: *const T, moduleType: FsrmPipelineModuleType, moduleDefinition: ?*?*IFsrmPipelineModuleDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).CreateModuleDefinition(@ptrCast(*const IFsrmClassificationManager, self), moduleType, moduleDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_GetModuleDefinition(self: *const T, moduleName: ?BSTR, moduleType: FsrmPipelineModuleType, moduleDefinition: ?*?*IFsrmPipelineModuleDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).GetModuleDefinition(@ptrCast(*const IFsrmClassificationManager, self), moduleName, moduleType, moduleDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_RunClassification(self: *const T, context: FsrmReportGenerationContext, reserved: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).RunClassification(@ptrCast(*const IFsrmClassificationManager, self), context, reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_WaitForClassificationCompletion(self: *const T, waitSeconds: i32, completed: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).WaitForClassificationCompletion(@ptrCast(*const IFsrmClassificationManager, self), waitSeconds, completed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_CancelClassification(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).CancelClassification(@ptrCast(*const IFsrmClassificationManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_EnumFileProperties(self: *const T, filePath: ?BSTR, options: FsrmGetFilePropertyOptions, fileProperties: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).EnumFileProperties(@ptrCast(*const IFsrmClassificationManager, self), filePath, options, fileProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_GetFileProperty(self: *const T, filePath: ?BSTR, propertyName: ?BSTR, options: FsrmGetFilePropertyOptions, property: ?*?*IFsrmProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).GetFileProperty(@ptrCast(*const IFsrmClassificationManager, self), filePath, propertyName, options, property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_SetFileProperty(self: *const T, filePath: ?BSTR, propertyName: ?BSTR, propertyValue: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).SetFileProperty(@ptrCast(*const IFsrmClassificationManager, self), filePath, propertyName, propertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager_ClearFileProperty(self: *const T, filePath: ?BSTR, property: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager.VTable, self.vtable).ClearFileProperty(@ptrCast(*const IFsrmClassificationManager, self), filePath, property);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFsrmClassificationManager2_Value = @import("../zig.zig").Guid.initString("0004c1c9-127e-4765-ba07-6a3147bca112");
pub const IID_IFsrmClassificationManager2 = &IID_IFsrmClassificationManager2_Value;
pub const IFsrmClassificationManager2 = extern struct {
    pub const VTable = extern struct {
        base: IFsrmClassificationManager.VTable,
        ClassifyFiles: fn(
            self: *const IFsrmClassificationManager2,
            filePaths: ?*SAFEARRAY,
            propertyNames: ?*SAFEARRAY,
            propertyValues: ?*SAFEARRAY,
            options: FsrmGetFilePropertyOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmClassificationManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassificationManager2_ClassifyFiles(self: *const T, filePaths: ?*SAFEARRAY, propertyNames: ?*SAFEARRAY, propertyValues: ?*SAFEARRAY, options: FsrmGetFilePropertyOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassificationManager2.VTable, self.vtable).ClassifyFiles(@ptrCast(*const IFsrmClassificationManager2, self), filePaths, propertyNames, propertyValues, options);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmPropertyBag_Value = @import("../zig.zig").Guid.initString("774589d1-d300-4f7a-9a24-f7b766800250");
pub const IID_IFsrmPropertyBag = &IID_IFsrmPropertyBag_Value;
pub const IFsrmPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsrmPropertyBag,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RelativePath: fn(
            self: *const IFsrmPropertyBag,
            path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeName: fn(
            self: *const IFsrmPropertyBag,
            volumeName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RelativeNamespaceRoot: fn(
            self: *const IFsrmPropertyBag,
            relativeNamespaceRoot: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeIndex: fn(
            self: *const IFsrmPropertyBag,
            volumeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileId: fn(
            self: *const IFsrmPropertyBag,
            fileId: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentDirectoryId: fn(
            self: *const IFsrmPropertyBag,
            parentDirectoryId: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Size: fn(
            self: *const IFsrmPropertyBag,
            size: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SizeAllocated: fn(
            self: *const IFsrmPropertyBag,
            sizeAllocated: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreationTime: fn(
            self: *const IFsrmPropertyBag,
            creationTime: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastAccessTime: fn(
            self: *const IFsrmPropertyBag,
            lastAccessTime: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastModificationTime: fn(
            self: *const IFsrmPropertyBag,
            lastModificationTime: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Attributes: fn(
            self: *const IFsrmPropertyBag,
            attributes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OwnerSid: fn(
            self: *const IFsrmPropertyBag,
            ownerSid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilePropertyNames: fn(
            self: *const IFsrmPropertyBag,
            filePropertyNames: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Messages: fn(
            self: *const IFsrmPropertyBag,
            messages: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyBagFlags: fn(
            self: *const IFsrmPropertyBag,
            flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileProperty: fn(
            self: *const IFsrmPropertyBag,
            name: ?BSTR,
            fileProperty: ?*?*IFsrmProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFileProperty: fn(
            self: *const IFsrmPropertyBag,
            name: ?BSTR,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMessage: fn(
            self: *const IFsrmPropertyBag,
            message: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileStreamInterface: fn(
            self: *const IFsrmPropertyBag,
            accessMode: FsrmFileStreamingMode,
            interfaceType: FsrmFileStreamingInterfaceType,
            pStreamInterface: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_Name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_Name(@ptrCast(*const IFsrmPropertyBag, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_RelativePath(self: *const T, path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_RelativePath(@ptrCast(*const IFsrmPropertyBag, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_VolumeName(self: *const T, volumeName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_VolumeName(@ptrCast(*const IFsrmPropertyBag, self), volumeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_RelativeNamespaceRoot(self: *const T, relativeNamespaceRoot: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_RelativeNamespaceRoot(@ptrCast(*const IFsrmPropertyBag, self), relativeNamespaceRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_VolumeIndex(self: *const T, volumeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_VolumeIndex(@ptrCast(*const IFsrmPropertyBag, self), volumeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_FileId(self: *const T, fileId: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_FileId(@ptrCast(*const IFsrmPropertyBag, self), fileId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_ParentDirectoryId(self: *const T, parentDirectoryId: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_ParentDirectoryId(@ptrCast(*const IFsrmPropertyBag, self), parentDirectoryId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_Size(self: *const T, size: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_Size(@ptrCast(*const IFsrmPropertyBag, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_SizeAllocated(self: *const T, sizeAllocated: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_SizeAllocated(@ptrCast(*const IFsrmPropertyBag, self), sizeAllocated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_CreationTime(self: *const T, creationTime: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_CreationTime(@ptrCast(*const IFsrmPropertyBag, self), creationTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_LastAccessTime(self: *const T, lastAccessTime: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_LastAccessTime(@ptrCast(*const IFsrmPropertyBag, self), lastAccessTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_LastModificationTime(self: *const T, lastModificationTime: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_LastModificationTime(@ptrCast(*const IFsrmPropertyBag, self), lastModificationTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_Attributes(self: *const T, attributes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_Attributes(@ptrCast(*const IFsrmPropertyBag, self), attributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_OwnerSid(self: *const T, ownerSid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_OwnerSid(@ptrCast(*const IFsrmPropertyBag, self), ownerSid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_FilePropertyNames(self: *const T, filePropertyNames: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_FilePropertyNames(@ptrCast(*const IFsrmPropertyBag, self), filePropertyNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_Messages(self: *const T, messages: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_Messages(@ptrCast(*const IFsrmPropertyBag, self), messages);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_get_PropertyBagFlags(self: *const T, flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).get_PropertyBagFlags(@ptrCast(*const IFsrmPropertyBag, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_GetFileProperty(self: *const T, name: ?BSTR, fileProperty: ?*?*IFsrmProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).GetFileProperty(@ptrCast(*const IFsrmPropertyBag, self), name, fileProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_SetFileProperty(self: *const T, name: ?BSTR, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).SetFileProperty(@ptrCast(*const IFsrmPropertyBag, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_AddMessage(self: *const T, message: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).AddMessage(@ptrCast(*const IFsrmPropertyBag, self), message);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag_GetFileStreamInterface(self: *const T, accessMode: FsrmFileStreamingMode, interfaceType: FsrmFileStreamingInterfaceType, pStreamInterface: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag.VTable, self.vtable).GetFileStreamInterface(@ptrCast(*const IFsrmPropertyBag, self), accessMode, interfaceType, pStreamInterface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2012'
const IID_IFsrmPropertyBag2_Value = @import("../zig.zig").Guid.initString("0e46bdbd-2402-4fed-9c30-9266e6eb2cc9");
pub const IID_IFsrmPropertyBag2 = &IID_IFsrmPropertyBag2_Value;
pub const IFsrmPropertyBag2 = extern struct {
    pub const VTable = extern struct {
        base: IFsrmPropertyBag.VTable,
        GetFieldValue: fn(
            self: *const IFsrmPropertyBag2,
            field: FsrmPropertyBagField,
            value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUntrustedInFileProperties: fn(
            self: *const IFsrmPropertyBag2,
            props: ?*?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmPropertyBag.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag2_GetFieldValue(self: *const T, field: FsrmPropertyBagField, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag2.VTable, self.vtable).GetFieldValue(@ptrCast(*const IFsrmPropertyBag2, self), field, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPropertyBag2_GetUntrustedInFileProperties(self: *const T, props: ?*?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPropertyBag2.VTable, self.vtable).GetUntrustedInFileProperties(@ptrCast(*const IFsrmPropertyBag2, self), props);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmPipelineModuleImplementation_Value = @import("../zig.zig").Guid.initString("b7907906-2b02-4cb5-84a9-fdf54613d6cd");
pub const IID_IFsrmPipelineModuleImplementation = &IID_IFsrmPipelineModuleImplementation_Value;
pub const IFsrmPipelineModuleImplementation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OnLoad: fn(
            self: *const IFsrmPipelineModuleImplementation,
            moduleDefinition: ?*IFsrmPipelineModuleDefinition,
            moduleConnector: ?*?*IFsrmPipelineModuleConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUnload: fn(
            self: *const IFsrmPipelineModuleImplementation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleImplementation_OnLoad(self: *const T, moduleDefinition: ?*IFsrmPipelineModuleDefinition, moduleConnector: ?*?*IFsrmPipelineModuleConnector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleImplementation.VTable, self.vtable).OnLoad(@ptrCast(*const IFsrmPipelineModuleImplementation, self), moduleDefinition, moduleConnector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleImplementation_OnUnload(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleImplementation.VTable, self.vtable).OnUnload(@ptrCast(*const IFsrmPipelineModuleImplementation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmClassifierModuleImplementation_Value = @import("../zig.zig").Guid.initString("4c968fc6-6edb-4051-9c18-73b7291ae106");
pub const IID_IFsrmClassifierModuleImplementation = &IID_IFsrmClassifierModuleImplementation_Value;
pub const IFsrmClassifierModuleImplementation = extern struct {
    pub const VTable = extern struct {
        base: IFsrmPipelineModuleImplementation.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastModified: fn(
            self: *const IFsrmClassifierModuleImplementation,
            lastModified: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UseRulesAndDefinitions: fn(
            self: *const IFsrmClassifierModuleImplementation,
            rules: ?*IFsrmCollection,
            propertyDefinitions: ?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBeginFile: fn(
            self: *const IFsrmClassifierModuleImplementation,
            propertyBag: ?*IFsrmPropertyBag,
            arrayRuleIds: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoesPropertyValueApply: fn(
            self: *const IFsrmClassifierModuleImplementation,
            property: ?BSTR,
            value: ?BSTR,
            applyValue: ?*i16,
            idRule: Guid,
            idPropDef: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyValueToApply: fn(
            self: *const IFsrmClassifierModuleImplementation,
            property: ?BSTR,
            value: ?*?BSTR,
            idRule: Guid,
            idPropDef: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndFile: fn(
            self: *const IFsrmClassifierModuleImplementation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmPipelineModuleImplementation.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleImplementation_get_LastModified(self: *const T, lastModified: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleImplementation.VTable, self.vtable).get_LastModified(@ptrCast(*const IFsrmClassifierModuleImplementation, self), lastModified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleImplementation_UseRulesAndDefinitions(self: *const T, rules: ?*IFsrmCollection, propertyDefinitions: ?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleImplementation.VTable, self.vtable).UseRulesAndDefinitions(@ptrCast(*const IFsrmClassifierModuleImplementation, self), rules, propertyDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleImplementation_OnBeginFile(self: *const T, propertyBag: ?*IFsrmPropertyBag, arrayRuleIds: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleImplementation.VTable, self.vtable).OnBeginFile(@ptrCast(*const IFsrmClassifierModuleImplementation, self), propertyBag, arrayRuleIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleImplementation_DoesPropertyValueApply(self: *const T, property: ?BSTR, value: ?BSTR, applyValue: ?*i16, idRule: Guid, idPropDef: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleImplementation.VTable, self.vtable).DoesPropertyValueApply(@ptrCast(*const IFsrmClassifierModuleImplementation, self), property, value, applyValue, idRule, idPropDef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleImplementation_GetPropertyValueToApply(self: *const T, property: ?BSTR, value: ?*?BSTR, idRule: Guid, idPropDef: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleImplementation.VTable, self.vtable).GetPropertyValueToApply(@ptrCast(*const IFsrmClassifierModuleImplementation, self), property, value, idRule, idPropDef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmClassifierModuleImplementation_OnEndFile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmClassifierModuleImplementation.VTable, self.vtable).OnEndFile(@ptrCast(*const IFsrmClassifierModuleImplementation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmStorageModuleImplementation_Value = @import("../zig.zig").Guid.initString("0af4a0da-895a-4e50-8712-a96724bcec64");
pub const IID_IFsrmStorageModuleImplementation = &IID_IFsrmStorageModuleImplementation_Value;
pub const IFsrmStorageModuleImplementation = extern struct {
    pub const VTable = extern struct {
        base: IFsrmPipelineModuleImplementation.VTable,
        UseDefinitions: fn(
            self: *const IFsrmStorageModuleImplementation,
            propertyDefinitions: ?*IFsrmCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadProperties: fn(
            self: *const IFsrmStorageModuleImplementation,
            propertyBag: ?*IFsrmPropertyBag,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveProperties: fn(
            self: *const IFsrmStorageModuleImplementation,
            propertyBag: ?*IFsrmPropertyBag,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsrmPipelineModuleImplementation.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmStorageModuleImplementation_UseDefinitions(self: *const T, propertyDefinitions: ?*IFsrmCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmStorageModuleImplementation.VTable, self.vtable).UseDefinitions(@ptrCast(*const IFsrmStorageModuleImplementation, self), propertyDefinitions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmStorageModuleImplementation_LoadProperties(self: *const T, propertyBag: ?*IFsrmPropertyBag) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmStorageModuleImplementation.VTable, self.vtable).LoadProperties(@ptrCast(*const IFsrmStorageModuleImplementation, self), propertyBag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmStorageModuleImplementation_SaveProperties(self: *const T, propertyBag: ?*IFsrmPropertyBag) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmStorageModuleImplementation.VTable, self.vtable).SaveProperties(@ptrCast(*const IFsrmStorageModuleImplementation, self), propertyBag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IFsrmPipelineModuleConnector_Value = @import("../zig.zig").Guid.initString("c16014f3-9aa1-46b3-b0a7-ab146eb205f2");
pub const IID_IFsrmPipelineModuleConnector = &IID_IFsrmPipelineModuleConnector_Value;
pub const IFsrmPipelineModuleConnector = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleImplementation: fn(
            self: *const IFsrmPipelineModuleConnector,
            pipelineModuleImplementation: ?*?*IFsrmPipelineModuleImplementation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleName: fn(
            self: *const IFsrmPipelineModuleConnector,
            userName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HostingUserAccount: fn(
            self: *const IFsrmPipelineModuleConnector,
            userAccount: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HostingProcessPid: fn(
            self: *const IFsrmPipelineModuleConnector,
            pid: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Bind: fn(
            self: *const IFsrmPipelineModuleConnector,
            moduleDefinition: ?*IFsrmPipelineModuleDefinition,
            moduleImplementation: ?*IFsrmPipelineModuleImplementation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleConnector_get_ModuleImplementation(self: *const T, pipelineModuleImplementation: ?*?*IFsrmPipelineModuleImplementation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleConnector.VTable, self.vtable).get_ModuleImplementation(@ptrCast(*const IFsrmPipelineModuleConnector, self), pipelineModuleImplementation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleConnector_get_ModuleName(self: *const T, userName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleConnector.VTable, self.vtable).get_ModuleName(@ptrCast(*const IFsrmPipelineModuleConnector, self), userName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleConnector_get_HostingUserAccount(self: *const T, userAccount: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleConnector.VTable, self.vtable).get_HostingUserAccount(@ptrCast(*const IFsrmPipelineModuleConnector, self), userAccount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleConnector_get_HostingProcessPid(self: *const T, pid: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleConnector.VTable, self.vtable).get_HostingProcessPid(@ptrCast(*const IFsrmPipelineModuleConnector, self), pid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsrmPipelineModuleConnector_Bind(self: *const T, moduleDefinition: ?*IFsrmPipelineModuleDefinition, moduleImplementation: ?*IFsrmPipelineModuleImplementation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsrmPipelineModuleConnector.VTable, self.vtable).Bind(@ptrCast(*const IFsrmPipelineModuleConnector, self), moduleDefinition, moduleImplementation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_DIFsrmClassificationEvents_Value = @import("../zig.zig").Guid.initString("26942db0-dabf-41d8-bbdd-b129a9f70424");
pub const IID_DIFsrmClassificationEvents = &IID_DIFsrmClassificationEvents_Value;
pub const DIFsrmClassificationEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BSTR = @import("../foundation.zig").BSTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
