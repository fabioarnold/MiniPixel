//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (102)
//--------------------------------------------------------------------------------
pub const OPC_E_NONCONFORMING_URI = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175231));
pub const OPC_E_RELATIVE_URI_REQUIRED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175230));
pub const OPC_E_RELATIONSHIP_URI_REQUIRED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175229));
pub const OPC_E_PART_CANNOT_BE_DIRECTORY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175228));
pub const OPC_E_UNEXPECTED_CONTENT_TYPE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175227));
pub const OPC_E_INVALID_CONTENT_TYPE_XML = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175226));
pub const OPC_E_MISSING_CONTENT_TYPES = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175225));
pub const OPC_E_NONCONFORMING_CONTENT_TYPES_XML = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175224));
pub const OPC_E_NONCONFORMING_RELS_XML = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175223));
pub const OPC_E_INVALID_RELS_XML = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175222));
pub const OPC_E_DUPLICATE_PART = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175221));
pub const OPC_E_INVALID_OVERRIDE_PART_NAME = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175220));
pub const OPC_E_DUPLICATE_OVERRIDE_PART = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175219));
pub const OPC_E_INVALID_DEFAULT_EXTENSION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175218));
pub const OPC_E_DUPLICATE_DEFAULT_EXTENSION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175217));
pub const OPC_E_INVALID_RELATIONSHIP_ID = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175216));
pub const OPC_E_INVALID_RELATIONSHIP_TYPE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175215));
pub const OPC_E_INVALID_RELATIONSHIP_TARGET = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175214));
pub const OPC_E_DUPLICATE_RELATIONSHIP = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175213));
pub const OPC_E_CONFLICTING_SETTINGS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175212));
pub const OPC_E_DUPLICATE_PIECE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175211));
pub const OPC_E_INVALID_PIECE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175210));
pub const OPC_E_MISSING_PIECE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175209));
pub const OPC_E_NO_SUCH_PART = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175208));
pub const OPC_E_DS_SIGNATURE_CORRUPT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175207));
pub const OPC_E_DS_DIGEST_VALUE_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175206));
pub const OPC_E_DS_DUPLICATE_SIGNATURE_ORIGIN_RELATIONSHIP = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175205));
pub const OPC_E_DS_INVALID_SIGNATURE_ORIGIN_RELATIONSHIP = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175204));
pub const OPC_E_DS_INVALID_CERTIFICATE_RELATIONSHIP = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175203));
pub const OPC_E_DS_EXTERNAL_SIGNATURE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175202));
pub const OPC_E_DS_MISSING_SIGNATURE_ORIGIN_PART = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175201));
pub const OPC_E_DS_MISSING_SIGNATURE_PART = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175200));
pub const OPC_E_DS_INVALID_RELATIONSHIP_TRANSFORM_XML = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175199));
pub const OPC_E_DS_INVALID_CANONICALIZATION_METHOD = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175198));
pub const OPC_E_DS_INVALID_RELATIONSHIPS_SIGNING_OPTION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175197));
pub const OPC_E_DS_INVALID_OPC_SIGNATURE_TIME_FORMAT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175196));
pub const OPC_E_DS_PACKAGE_REFERENCE_URI_RESERVED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175195));
pub const OPC_E_DS_MISSING_SIGNATURE_PROPERTIES_ELEMENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175194));
pub const OPC_E_DS_MISSING_SIGNATURE_PROPERTY_ELEMENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175193));
pub const OPC_E_DS_DUPLICATE_SIGNATURE_PROPERTY_ELEMENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175192));
pub const OPC_E_DS_MISSING_SIGNATURE_TIME_PROPERTY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175191));
pub const OPC_E_DS_INVALID_SIGNATURE_XML = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175190));
pub const OPC_E_DS_INVALID_SIGNATURE_COUNT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175189));
pub const OPC_E_DS_MISSING_SIGNATURE_ALGORITHM = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175188));
pub const OPC_E_DS_DUPLICATE_PACKAGE_OBJECT_REFERENCES = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175187));
pub const OPC_E_DS_MISSING_PACKAGE_OBJECT_REFERENCE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175186));
pub const OPC_E_DS_EXTERNAL_SIGNATURE_REFERENCE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175185));
pub const OPC_E_DS_REFERENCE_MISSING_CONTENT_TYPE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175184));
pub const OPC_E_DS_MULTIPLE_RELATIONSHIP_TRANSFORMS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175183));
pub const OPC_E_DS_MISSING_CANONICALIZATION_TRANSFORM = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175182));
pub const OPC_E_MC_UNEXPECTED_ELEMENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175181));
pub const OPC_E_MC_UNEXPECTED_REQUIRES_ATTR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175180));
pub const OPC_E_MC_MISSING_REQUIRES_ATTR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175179));
pub const OPC_E_MC_UNEXPECTED_ATTR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175178));
pub const OPC_E_MC_INVALID_PREFIX_LIST = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175177));
pub const OPC_E_MC_INVALID_QNAME_LIST = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175176));
pub const OPC_E_MC_NESTED_ALTERNATE_CONTENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175175));
pub const OPC_E_MC_UNEXPECTED_CHOICE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175174));
pub const OPC_E_MC_MISSING_CHOICE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175173));
pub const OPC_E_MC_INVALID_ENUM_TYPE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175172));
pub const OPC_E_MC_UNKNOWN_NAMESPACE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175170));
pub const OPC_E_MC_UNKNOWN_PREFIX = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175169));
pub const OPC_E_MC_INVALID_ATTRIBUTES_ON_IGNORABLE_ELEMENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175168));
pub const OPC_E_MC_INVALID_XMLNS_ATTRIBUTE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175167));
pub const OPC_E_INVALID_XML_ENCODING = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175166));
pub const OPC_E_DS_SIGNATURE_REFERENCE_MISSING_URI = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175165));
pub const OPC_E_INVALID_CONTENT_TYPE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175164));
pub const OPC_E_DS_SIGNATURE_PROPERTY_MISSING_TARGET = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175163));
pub const OPC_E_DS_SIGNATURE_METHOD_NOT_SET = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175162));
pub const OPC_E_DS_DEFAULT_DIGEST_METHOD_NOT_SET = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175161));
pub const OPC_E_NO_SUCH_RELATIONSHIP = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175160));
pub const OPC_E_MC_MULTIPLE_FALLBACK_ELEMENTS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175159));
pub const OPC_E_MC_INCONSISTENT_PROCESS_CONTENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175158));
pub const OPC_E_MC_INCONSISTENT_PRESERVE_ATTRIBUTES = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175157));
pub const OPC_E_MC_INCONSISTENT_PRESERVE_ELEMENTS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175156));
pub const OPC_E_INVALID_RELATIONSHIP_TARGET_MODE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175155));
pub const OPC_E_COULD_NOT_RECOVER = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175154));
pub const OPC_E_UNSUPPORTED_PACKAGE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175153));
pub const OPC_E_ENUM_COLLECTION_CHANGED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175152));
pub const OPC_E_ENUM_CANNOT_MOVE_NEXT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175151));
pub const OPC_E_ENUM_CANNOT_MOVE_PREVIOUS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175150));
pub const OPC_E_ENUM_INVALID_POSITION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175149));
pub const OPC_E_DS_SIGNATURE_ORIGIN_EXISTS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175148));
pub const OPC_E_DS_UNSIGNED_PACKAGE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175147));
pub const OPC_E_DS_MISSING_CERTIFICATE_PART = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175146));
pub const OPC_E_NO_SUCH_SETTINGS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142175145));
pub const OPC_E_ZIP_INCORRECT_DATA_SIZE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171135));
pub const OPC_E_ZIP_CORRUPTED_ARCHIVE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171134));
pub const OPC_E_ZIP_COMPRESSION_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171133));
pub const OPC_E_ZIP_DECOMPRESSION_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171132));
pub const OPC_E_ZIP_INCONSISTENT_FILEITEM = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171131));
pub const OPC_E_ZIP_INCONSISTENT_DIRECTORY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171130));
pub const OPC_E_ZIP_MISSING_DATA_DESCRIPTOR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171129));
pub const OPC_E_ZIP_UNSUPPORTEDARCHIVE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171128));
pub const OPC_E_ZIP_CENTRAL_DIRECTORY_TOO_LARGE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171127));
pub const OPC_E_ZIP_NAME_TOO_LARGE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171126));
pub const OPC_E_ZIP_DUPLICATE_NAME = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171125));
pub const OPC_E_ZIP_COMMENT_TOO_LARGE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171124));
pub const OPC_E_ZIP_EXTRA_FIELDS_TOO_LARGE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171123));
pub const OPC_E_ZIP_FILE_HEADER_TOO_LARGE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171122));
pub const OPC_E_ZIP_MISSING_END_OF_CENTRAL_DIRECTORY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171121));
pub const OPC_E_ZIP_REQUIRES_64_BIT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2142171120));

//--------------------------------------------------------------------------------
// Section: Types (43)
//--------------------------------------------------------------------------------
const CLSID_OpcFactory_Value = @import("../../zig.zig").Guid.initString("6b2d6ba0-9f3e-4f27-920b-313cc426a39e");
pub const CLSID_OpcFactory = &CLSID_OpcFactory_Value;

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcUri_Value = @import("../../zig.zig").Guid.initString("bc9c1b9b-d62c-49eb-aef0-3b4e0b28ebed");
pub const IID_IOpcUri = &IID_IOpcUri_Value;
pub const IOpcUri = extern struct {
    pub const VTable = extern struct {
        base: IUri.VTable,
        GetRelationshipsPartUri: fn(
            self: *const IOpcUri,
            relationshipPartUri: ?*?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelativeUri: fn(
            self: *const IOpcUri,
            targetPartUri: ?*IOpcPartUri,
            relativeUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CombinePartUri: fn(
            self: *const IOpcUri,
            relativeUri: ?*IUri,
            combinedUri: ?*?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUri.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcUri_GetRelationshipsPartUri(self: *const T, relationshipPartUri: ?*?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcUri.VTable, self.vtable).GetRelationshipsPartUri(@ptrCast(*const IOpcUri, self), relationshipPartUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcUri_GetRelativeUri(self: *const T, targetPartUri: ?*IOpcPartUri, relativeUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcUri.VTable, self.vtable).GetRelativeUri(@ptrCast(*const IOpcUri, self), targetPartUri, relativeUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcUri_CombinePartUri(self: *const T, relativeUri: ?*IUri, combinedUri: ?*?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcUri.VTable, self.vtable).CombinePartUri(@ptrCast(*const IOpcUri, self), relativeUri, combinedUri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcPartUri_Value = @import("../../zig.zig").Guid.initString("7d3babe7-88b2-46ba-85cb-4203cb016c87");
pub const IID_IOpcPartUri = &IID_IOpcPartUri_Value;
pub const IOpcPartUri = extern struct {
    pub const VTable = extern struct {
        base: IOpcUri.VTable,
        ComparePartUri: fn(
            self: *const IOpcPartUri,
            partUri: ?*IOpcPartUri,
            comparisonResult: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceUri: fn(
            self: *const IOpcPartUri,
            sourceUri: ?*?*IOpcUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRelationshipsPartUri: fn(
            self: *const IOpcPartUri,
            isRelationshipUri: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOpcUri.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartUri_ComparePartUri(self: *const T, partUri: ?*IOpcPartUri, comparisonResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartUri.VTable, self.vtable).ComparePartUri(@ptrCast(*const IOpcPartUri, self), partUri, comparisonResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartUri_GetSourceUri(self: *const T, sourceUri: ?*?*IOpcUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartUri.VTable, self.vtable).GetSourceUri(@ptrCast(*const IOpcPartUri, self), sourceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartUri_IsRelationshipsPartUri(self: *const T, isRelationshipUri: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartUri.VTable, self.vtable).IsRelationshipsPartUri(@ptrCast(*const IOpcPartUri, self), isRelationshipUri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OPC_URI_TARGET_MODE = enum(i32) {
    INTERNAL = 0,
    EXTERNAL = 1,
};
pub const OPC_URI_TARGET_MODE_INTERNAL = OPC_URI_TARGET_MODE.INTERNAL;
pub const OPC_URI_TARGET_MODE_EXTERNAL = OPC_URI_TARGET_MODE.EXTERNAL;

pub const OPC_COMPRESSION_OPTIONS = enum(i32) {
    NONE = -1,
    NORMAL = 0,
    MAXIMUM = 1,
    FAST = 2,
    SUPERFAST = 3,
};
pub const OPC_COMPRESSION_NONE = OPC_COMPRESSION_OPTIONS.NONE;
pub const OPC_COMPRESSION_NORMAL = OPC_COMPRESSION_OPTIONS.NORMAL;
pub const OPC_COMPRESSION_MAXIMUM = OPC_COMPRESSION_OPTIONS.MAXIMUM;
pub const OPC_COMPRESSION_FAST = OPC_COMPRESSION_OPTIONS.FAST;
pub const OPC_COMPRESSION_SUPERFAST = OPC_COMPRESSION_OPTIONS.SUPERFAST;

pub const OPC_STREAM_IO_MODE = enum(i32) {
    READ = 1,
    WRITE = 2,
};
pub const OPC_STREAM_IO_READ = OPC_STREAM_IO_MODE.READ;
pub const OPC_STREAM_IO_WRITE = OPC_STREAM_IO_MODE.WRITE;

pub const OPC_READ_FLAGS = enum(u32) {
    READ_DEFAULT = 0,
    VALIDATE_ON_LOAD = 1,
    CACHE_ON_ACCESS = 2,
    _,
    pub fn initFlags(o: struct {
        READ_DEFAULT: u1 = 0,
        VALIDATE_ON_LOAD: u1 = 0,
        CACHE_ON_ACCESS: u1 = 0,
    }) OPC_READ_FLAGS {
        return @intToEnum(OPC_READ_FLAGS,
              (if (o.READ_DEFAULT == 1) @enumToInt(OPC_READ_FLAGS.READ_DEFAULT) else 0)
            | (if (o.VALIDATE_ON_LOAD == 1) @enumToInt(OPC_READ_FLAGS.VALIDATE_ON_LOAD) else 0)
            | (if (o.CACHE_ON_ACCESS == 1) @enumToInt(OPC_READ_FLAGS.CACHE_ON_ACCESS) else 0)
        );
    }
};
pub const OPC_READ_DEFAULT = OPC_READ_FLAGS.READ_DEFAULT;
pub const OPC_VALIDATE_ON_LOAD = OPC_READ_FLAGS.VALIDATE_ON_LOAD;
pub const OPC_CACHE_ON_ACCESS = OPC_READ_FLAGS.CACHE_ON_ACCESS;

pub const OPC_WRITE_FLAGS = enum(u32) {
    DEFAULT = 0,
    FORCE_ZIP32 = 1,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        FORCE_ZIP32: u1 = 0,
    }) OPC_WRITE_FLAGS {
        return @intToEnum(OPC_WRITE_FLAGS,
              (if (o.DEFAULT == 1) @enumToInt(OPC_WRITE_FLAGS.DEFAULT) else 0)
            | (if (o.FORCE_ZIP32 == 1) @enumToInt(OPC_WRITE_FLAGS.FORCE_ZIP32) else 0)
        );
    }
};
pub const OPC_WRITE_DEFAULT = OPC_WRITE_FLAGS.DEFAULT;
pub const OPC_WRITE_FORCE_ZIP32 = OPC_WRITE_FLAGS.FORCE_ZIP32;

pub const OPC_SIGNATURE_VALIDATION_RESULT = enum(i32) {
    VALID = 0,
    INVALID = -1,
};
pub const OPC_SIGNATURE_VALID = OPC_SIGNATURE_VALIDATION_RESULT.VALID;
pub const OPC_SIGNATURE_INVALID = OPC_SIGNATURE_VALIDATION_RESULT.INVALID;

pub const OPC_CANONICALIZATION_METHOD = enum(i32) {
    NONE = 0,
    C14N = 1,
    C14N_WITH_COMMENTS = 2,
};
pub const OPC_CANONICALIZATION_NONE = OPC_CANONICALIZATION_METHOD.NONE;
pub const OPC_CANONICALIZATION_C14N = OPC_CANONICALIZATION_METHOD.C14N;
pub const OPC_CANONICALIZATION_C14N_WITH_COMMENTS = OPC_CANONICALIZATION_METHOD.C14N_WITH_COMMENTS;

pub const OPC_RELATIONSHIP_SELECTOR = enum(i32) {
    ID = 0,
    TYPE = 1,
};
pub const OPC_RELATIONSHIP_SELECT_BY_ID = OPC_RELATIONSHIP_SELECTOR.ID;
pub const OPC_RELATIONSHIP_SELECT_BY_TYPE = OPC_RELATIONSHIP_SELECTOR.TYPE;

pub const OPC_RELATIONSHIPS_SIGNING_OPTION = enum(i32) {
    USING_SELECTORS = 0,
    PART = 1,
};
pub const OPC_RELATIONSHIP_SIGN_USING_SELECTORS = OPC_RELATIONSHIPS_SIGNING_OPTION.USING_SELECTORS;
pub const OPC_RELATIONSHIP_SIGN_PART = OPC_RELATIONSHIPS_SIGNING_OPTION.PART;

pub const OPC_CERTIFICATE_EMBEDDING_OPTION = enum(i32) {
    IN_CERTIFICATE_PART = 0,
    IN_SIGNATURE_PART = 1,
    NOT_EMBEDDED = 2,
};
pub const OPC_CERTIFICATE_IN_CERTIFICATE_PART = OPC_CERTIFICATE_EMBEDDING_OPTION.IN_CERTIFICATE_PART;
pub const OPC_CERTIFICATE_IN_SIGNATURE_PART = OPC_CERTIFICATE_EMBEDDING_OPTION.IN_SIGNATURE_PART;
pub const OPC_CERTIFICATE_NOT_EMBEDDED = OPC_CERTIFICATE_EMBEDDING_OPTION.NOT_EMBEDDED;

pub const OPC_SIGNATURE_TIME_FORMAT = enum(i32) {
    MILLISECONDS = 0,
    SECONDS = 1,
    MINUTES = 2,
    DAYS = 3,
    MONTHS = 4,
    YEARS = 5,
};
pub const OPC_SIGNATURE_TIME_FORMAT_MILLISECONDS = OPC_SIGNATURE_TIME_FORMAT.MILLISECONDS;
pub const OPC_SIGNATURE_TIME_FORMAT_SECONDS = OPC_SIGNATURE_TIME_FORMAT.SECONDS;
pub const OPC_SIGNATURE_TIME_FORMAT_MINUTES = OPC_SIGNATURE_TIME_FORMAT.MINUTES;
pub const OPC_SIGNATURE_TIME_FORMAT_DAYS = OPC_SIGNATURE_TIME_FORMAT.DAYS;
pub const OPC_SIGNATURE_TIME_FORMAT_MONTHS = OPC_SIGNATURE_TIME_FORMAT.MONTHS;
pub const OPC_SIGNATURE_TIME_FORMAT_YEARS = OPC_SIGNATURE_TIME_FORMAT.YEARS;

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcPackage_Value = @import("../../zig.zig").Guid.initString("42195949-3b79-4fc8-89c6-fc7fb979ee70");
pub const IID_IOpcPackage = &IID_IOpcPackage_Value;
pub const IOpcPackage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPartSet: fn(
            self: *const IOpcPackage,
            partSet: ?*?*IOpcPartSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelationshipSet: fn(
            self: *const IOpcPackage,
            relationshipSet: ?*?*IOpcRelationshipSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPackage_GetPartSet(self: *const T, partSet: ?*?*IOpcPartSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPackage.VTable, self.vtable).GetPartSet(@ptrCast(*const IOpcPackage, self), partSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPackage_GetRelationshipSet(self: *const T, relationshipSet: ?*?*IOpcRelationshipSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPackage.VTable, self.vtable).GetRelationshipSet(@ptrCast(*const IOpcPackage, self), relationshipSet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcPart_Value = @import("../../zig.zig").Guid.initString("42195949-3b79-4fc8-89c6-fc7fb979ee71");
pub const IID_IOpcPart = &IID_IOpcPart_Value;
pub const IOpcPart = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRelationshipSet: fn(
            self: *const IOpcPart,
            relationshipSet: ?*?*IOpcRelationshipSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContentStream: fn(
            self: *const IOpcPart,
            stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IOpcPart,
            name: ?*?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContentType: fn(
            self: *const IOpcPart,
            contentType: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompressionOptions: fn(
            self: *const IOpcPart,
            compressionOptions: ?*OPC_COMPRESSION_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPart_GetRelationshipSet(self: *const T, relationshipSet: ?*?*IOpcRelationshipSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPart.VTable, self.vtable).GetRelationshipSet(@ptrCast(*const IOpcPart, self), relationshipSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPart_GetContentStream(self: *const T, stream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPart.VTable, self.vtable).GetContentStream(@ptrCast(*const IOpcPart, self), stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPart_GetName(self: *const T, name: ?*?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPart.VTable, self.vtable).GetName(@ptrCast(*const IOpcPart, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPart_GetContentType(self: *const T, contentType: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPart.VTable, self.vtable).GetContentType(@ptrCast(*const IOpcPart, self), contentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPart_GetCompressionOptions(self: *const T, compressionOptions: ?*OPC_COMPRESSION_OPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPart.VTable, self.vtable).GetCompressionOptions(@ptrCast(*const IOpcPart, self), compressionOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcRelationship_Value = @import("../../zig.zig").Guid.initString("42195949-3b79-4fc8-89c6-fc7fb979ee72");
pub const IID_IOpcRelationship = &IID_IOpcRelationship_Value;
pub const IOpcRelationship = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IOpcRelationship,
            relationshipIdentifier: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelationshipType: fn(
            self: *const IOpcRelationship,
            relationshipType: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceUri: fn(
            self: *const IOpcRelationship,
            sourceUri: ?*?*IOpcUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetUri: fn(
            self: *const IOpcRelationship,
            targetUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetMode: fn(
            self: *const IOpcRelationship,
            targetMode: ?*OPC_URI_TARGET_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationship_GetId(self: *const T, relationshipIdentifier: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationship.VTable, self.vtable).GetId(@ptrCast(*const IOpcRelationship, self), relationshipIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationship_GetRelationshipType(self: *const T, relationshipType: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationship.VTable, self.vtable).GetRelationshipType(@ptrCast(*const IOpcRelationship, self), relationshipType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationship_GetSourceUri(self: *const T, sourceUri: ?*?*IOpcUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationship.VTable, self.vtable).GetSourceUri(@ptrCast(*const IOpcRelationship, self), sourceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationship_GetTargetUri(self: *const T, targetUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationship.VTable, self.vtable).GetTargetUri(@ptrCast(*const IOpcRelationship, self), targetUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationship_GetTargetMode(self: *const T, targetMode: ?*OPC_URI_TARGET_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationship.VTable, self.vtable).GetTargetMode(@ptrCast(*const IOpcRelationship, self), targetMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcPartSet_Value = @import("../../zig.zig").Guid.initString("42195949-3b79-4fc8-89c6-fc7fb979ee73");
pub const IID_IOpcPartSet = &IID_IOpcPartSet_Value;
pub const IOpcPartSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPart: fn(
            self: *const IOpcPartSet,
            name: ?*IOpcPartUri,
            part: ?*?*IOpcPart,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePart: fn(
            self: *const IOpcPartSet,
            name: ?*IOpcPartUri,
            contentType: ?[*:0]const u16,
            compressionOptions: OPC_COMPRESSION_OPTIONS,
            part: ?*?*IOpcPart,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeletePart: fn(
            self: *const IOpcPartSet,
            name: ?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PartExists: fn(
            self: *const IOpcPartSet,
            name: ?*IOpcPartUri,
            partExists: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumerator: fn(
            self: *const IOpcPartSet,
            partEnumerator: ?*?*IOpcPartEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartSet_GetPart(self: *const T, name: ?*IOpcPartUri, part: ?*?*IOpcPart) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartSet.VTable, self.vtable).GetPart(@ptrCast(*const IOpcPartSet, self), name, part);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartSet_CreatePart(self: *const T, name: ?*IOpcPartUri, contentType: ?[*:0]const u16, compressionOptions: OPC_COMPRESSION_OPTIONS, part: ?*?*IOpcPart) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartSet.VTable, self.vtable).CreatePart(@ptrCast(*const IOpcPartSet, self), name, contentType, compressionOptions, part);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartSet_DeletePart(self: *const T, name: ?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartSet.VTable, self.vtable).DeletePart(@ptrCast(*const IOpcPartSet, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartSet_PartExists(self: *const T, name: ?*IOpcPartUri, partExists: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartSet.VTable, self.vtable).PartExists(@ptrCast(*const IOpcPartSet, self), name, partExists);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartSet_GetEnumerator(self: *const T, partEnumerator: ?*?*IOpcPartEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartSet.VTable, self.vtable).GetEnumerator(@ptrCast(*const IOpcPartSet, self), partEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcRelationshipSet_Value = @import("../../zig.zig").Guid.initString("42195949-3b79-4fc8-89c6-fc7fb979ee74");
pub const IID_IOpcRelationshipSet = &IID_IOpcRelationshipSet_Value;
pub const IOpcRelationshipSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRelationship: fn(
            self: *const IOpcRelationshipSet,
            relationshipIdentifier: ?[*:0]const u16,
            relationship: ?*?*IOpcRelationship,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRelationship: fn(
            self: *const IOpcRelationshipSet,
            relationshipIdentifier: ?[*:0]const u16,
            relationshipType: ?[*:0]const u16,
            targetUri: ?*IUri,
            targetMode: OPC_URI_TARGET_MODE,
            relationship: ?*?*IOpcRelationship,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRelationship: fn(
            self: *const IOpcRelationshipSet,
            relationshipIdentifier: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RelationshipExists: fn(
            self: *const IOpcRelationshipSet,
            relationshipIdentifier: ?[*:0]const u16,
            relationshipExists: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumerator: fn(
            self: *const IOpcRelationshipSet,
            relationshipEnumerator: ?*?*IOpcRelationshipEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumeratorForType: fn(
            self: *const IOpcRelationshipSet,
            relationshipType: ?[*:0]const u16,
            relationshipEnumerator: ?*?*IOpcRelationshipEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelationshipsContentStream: fn(
            self: *const IOpcRelationshipSet,
            contents: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSet_GetRelationship(self: *const T, relationshipIdentifier: ?[*:0]const u16, relationship: ?*?*IOpcRelationship) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSet.VTable, self.vtable).GetRelationship(@ptrCast(*const IOpcRelationshipSet, self), relationshipIdentifier, relationship);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSet_CreateRelationship(self: *const T, relationshipIdentifier: ?[*:0]const u16, relationshipType: ?[*:0]const u16, targetUri: ?*IUri, targetMode: OPC_URI_TARGET_MODE, relationship: ?*?*IOpcRelationship) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSet.VTable, self.vtable).CreateRelationship(@ptrCast(*const IOpcRelationshipSet, self), relationshipIdentifier, relationshipType, targetUri, targetMode, relationship);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSet_DeleteRelationship(self: *const T, relationshipIdentifier: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSet.VTable, self.vtable).DeleteRelationship(@ptrCast(*const IOpcRelationshipSet, self), relationshipIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSet_RelationshipExists(self: *const T, relationshipIdentifier: ?[*:0]const u16, relationshipExists: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSet.VTable, self.vtable).RelationshipExists(@ptrCast(*const IOpcRelationshipSet, self), relationshipIdentifier, relationshipExists);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSet_GetEnumerator(self: *const T, relationshipEnumerator: ?*?*IOpcRelationshipEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSet.VTable, self.vtable).GetEnumerator(@ptrCast(*const IOpcRelationshipSet, self), relationshipEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSet_GetEnumeratorForType(self: *const T, relationshipType: ?[*:0]const u16, relationshipEnumerator: ?*?*IOpcRelationshipEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSet.VTable, self.vtable).GetEnumeratorForType(@ptrCast(*const IOpcRelationshipSet, self), relationshipType, relationshipEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSet_GetRelationshipsContentStream(self: *const T, contents: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSet.VTable, self.vtable).GetRelationshipsContentStream(@ptrCast(*const IOpcRelationshipSet, self), contents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcPartEnumerator_Value = @import("../../zig.zig").Guid.initString("42195949-3b79-4fc8-89c6-fc7fb979ee75");
pub const IID_IOpcPartEnumerator = &IID_IOpcPartEnumerator_Value;
pub const IOpcPartEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveNext: fn(
            self: *const IOpcPartEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePrevious: fn(
            self: *const IOpcPartEnumerator,
            hasPrevious: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrent: fn(
            self: *const IOpcPartEnumerator,
            part: ?*?*IOpcPart,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOpcPartEnumerator,
            copy: ?*?*IOpcPartEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IOpcPartEnumerator, self), hasNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartEnumerator_MovePrevious(self: *const T, hasPrevious: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartEnumerator.VTable, self.vtable).MovePrevious(@ptrCast(*const IOpcPartEnumerator, self), hasPrevious);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartEnumerator_GetCurrent(self: *const T, part: ?*?*IOpcPart) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IOpcPartEnumerator, self), part);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcPartEnumerator_Clone(self: *const T, copy: ?*?*IOpcPartEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcPartEnumerator.VTable, self.vtable).Clone(@ptrCast(*const IOpcPartEnumerator, self), copy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcRelationshipEnumerator_Value = @import("../../zig.zig").Guid.initString("42195949-3b79-4fc8-89c6-fc7fb979ee76");
pub const IID_IOpcRelationshipEnumerator = &IID_IOpcRelationshipEnumerator_Value;
pub const IOpcRelationshipEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveNext: fn(
            self: *const IOpcRelationshipEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePrevious: fn(
            self: *const IOpcRelationshipEnumerator,
            hasPrevious: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrent: fn(
            self: *const IOpcRelationshipEnumerator,
            relationship: ?*?*IOpcRelationship,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOpcRelationshipEnumerator,
            copy: ?*?*IOpcRelationshipEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IOpcRelationshipEnumerator, self), hasNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipEnumerator_MovePrevious(self: *const T, hasPrevious: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipEnumerator.VTable, self.vtable).MovePrevious(@ptrCast(*const IOpcRelationshipEnumerator, self), hasPrevious);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipEnumerator_GetCurrent(self: *const T, relationship: ?*?*IOpcRelationship) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IOpcRelationshipEnumerator, self), relationship);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipEnumerator_Clone(self: *const T, copy: ?*?*IOpcRelationshipEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipEnumerator.VTable, self.vtable).Clone(@ptrCast(*const IOpcRelationshipEnumerator, self), copy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignaturePartReference_Value = @import("../../zig.zig").Guid.initString("e24231ca-59f4-484e-b64b-36eeda36072c");
pub const IID_IOpcSignaturePartReference = &IID_IOpcSignaturePartReference_Value;
pub const IOpcSignaturePartReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPartName: fn(
            self: *const IOpcSignaturePartReference,
            partName: ?*?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContentType: fn(
            self: *const IOpcSignaturePartReference,
            contentType: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDigestMethod: fn(
            self: *const IOpcSignaturePartReference,
            digestMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDigestValue: fn(
            self: *const IOpcSignaturePartReference,
            digestValue: ?[*]?*u8,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransformMethod: fn(
            self: *const IOpcSignaturePartReference,
            transformMethod: ?*OPC_CANONICALIZATION_METHOD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReference_GetPartName(self: *const T, partName: ?*?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReference.VTable, self.vtable).GetPartName(@ptrCast(*const IOpcSignaturePartReference, self), partName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReference_GetContentType(self: *const T, contentType: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReference.VTable, self.vtable).GetContentType(@ptrCast(*const IOpcSignaturePartReference, self), contentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReference_GetDigestMethod(self: *const T, digestMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReference.VTable, self.vtable).GetDigestMethod(@ptrCast(*const IOpcSignaturePartReference, self), digestMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReference_GetDigestValue(self: *const T, digestValue: ?[*]?*u8, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReference.VTable, self.vtable).GetDigestValue(@ptrCast(*const IOpcSignaturePartReference, self), digestValue, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReference_GetTransformMethod(self: *const T, transformMethod: ?*OPC_CANONICALIZATION_METHOD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReference.VTable, self.vtable).GetTransformMethod(@ptrCast(*const IOpcSignaturePartReference, self), transformMethod);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignatureRelationshipReference_Value = @import("../../zig.zig").Guid.initString("57babac6-9d4a-4e50-8b86-e5d4051eae7c");
pub const IID_IOpcSignatureRelationshipReference = &IID_IOpcSignatureRelationshipReference_Value;
pub const IOpcSignatureRelationshipReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceUri: fn(
            self: *const IOpcSignatureRelationshipReference,
            sourceUri: ?*?*IOpcUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDigestMethod: fn(
            self: *const IOpcSignatureRelationshipReference,
            digestMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDigestValue: fn(
            self: *const IOpcSignatureRelationshipReference,
            digestValue: ?[*]?*u8,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransformMethod: fn(
            self: *const IOpcSignatureRelationshipReference,
            transformMethod: ?*OPC_CANONICALIZATION_METHOD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelationshipSigningOption: fn(
            self: *const IOpcSignatureRelationshipReference,
            relationshipSigningOption: ?*OPC_RELATIONSHIPS_SIGNING_OPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelationshipSelectorEnumerator: fn(
            self: *const IOpcSignatureRelationshipReference,
            selectorEnumerator: ?*?*IOpcRelationshipSelectorEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReference_GetSourceUri(self: *const T, sourceUri: ?*?*IOpcUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReference.VTable, self.vtable).GetSourceUri(@ptrCast(*const IOpcSignatureRelationshipReference, self), sourceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReference_GetDigestMethod(self: *const T, digestMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReference.VTable, self.vtable).GetDigestMethod(@ptrCast(*const IOpcSignatureRelationshipReference, self), digestMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReference_GetDigestValue(self: *const T, digestValue: ?[*]?*u8, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReference.VTable, self.vtable).GetDigestValue(@ptrCast(*const IOpcSignatureRelationshipReference, self), digestValue, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReference_GetTransformMethod(self: *const T, transformMethod: ?*OPC_CANONICALIZATION_METHOD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReference.VTable, self.vtable).GetTransformMethod(@ptrCast(*const IOpcSignatureRelationshipReference, self), transformMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReference_GetRelationshipSigningOption(self: *const T, relationshipSigningOption: ?*OPC_RELATIONSHIPS_SIGNING_OPTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReference.VTable, self.vtable).GetRelationshipSigningOption(@ptrCast(*const IOpcSignatureRelationshipReference, self), relationshipSigningOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReference_GetRelationshipSelectorEnumerator(self: *const T, selectorEnumerator: ?*?*IOpcRelationshipSelectorEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReference.VTable, self.vtable).GetRelationshipSelectorEnumerator(@ptrCast(*const IOpcSignatureRelationshipReference, self), selectorEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcRelationshipSelector_Value = @import("../../zig.zig").Guid.initString("f8f26c7f-b28f-4899-84c8-5d5639ede75f");
pub const IID_IOpcRelationshipSelector = &IID_IOpcRelationshipSelector_Value;
pub const IOpcRelationshipSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelectorType: fn(
            self: *const IOpcRelationshipSelector,
            selector: ?*OPC_RELATIONSHIP_SELECTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectionCriterion: fn(
            self: *const IOpcRelationshipSelector,
            selectionCriterion: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSelector_GetSelectorType(self: *const T, selector: ?*OPC_RELATIONSHIP_SELECTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSelector.VTable, self.vtable).GetSelectorType(@ptrCast(*const IOpcRelationshipSelector, self), selector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSelector_GetSelectionCriterion(self: *const T, selectionCriterion: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSelector.VTable, self.vtable).GetSelectionCriterion(@ptrCast(*const IOpcRelationshipSelector, self), selectionCriterion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignatureReference_Value = @import("../../zig.zig").Guid.initString("1b47005e-3011-4edc-be6f-0f65e5ab0342");
pub const IID_IOpcSignatureReference = &IID_IOpcSignatureReference_Value;
pub const IOpcSignatureReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IOpcSignatureReference,
            referenceId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUri: fn(
            self: *const IOpcSignatureReference,
            referenceUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const IOpcSignatureReference,
            type: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransformMethod: fn(
            self: *const IOpcSignatureReference,
            transformMethod: ?*OPC_CANONICALIZATION_METHOD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDigestMethod: fn(
            self: *const IOpcSignatureReference,
            digestMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDigestValue: fn(
            self: *const IOpcSignatureReference,
            digestValue: ?[*]?*u8,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReference_GetId(self: *const T, referenceId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReference.VTable, self.vtable).GetId(@ptrCast(*const IOpcSignatureReference, self), referenceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReference_GetUri(self: *const T, referenceUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReference.VTable, self.vtable).GetUri(@ptrCast(*const IOpcSignatureReference, self), referenceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReference_GetType(self: *const T, type_: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReference.VTable, self.vtable).GetType(@ptrCast(*const IOpcSignatureReference, self), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReference_GetTransformMethod(self: *const T, transformMethod: ?*OPC_CANONICALIZATION_METHOD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReference.VTable, self.vtable).GetTransformMethod(@ptrCast(*const IOpcSignatureReference, self), transformMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReference_GetDigestMethod(self: *const T, digestMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReference.VTable, self.vtable).GetDigestMethod(@ptrCast(*const IOpcSignatureReference, self), digestMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReference_GetDigestValue(self: *const T, digestValue: ?[*]?*u8, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReference.VTable, self.vtable).GetDigestValue(@ptrCast(*const IOpcSignatureReference, self), digestValue, count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignatureCustomObject_Value = @import("../../zig.zig").Guid.initString("5d77a19e-62c1-44e7-becd-45da5ae51a56");
pub const IID_IOpcSignatureCustomObject = &IID_IOpcSignatureCustomObject_Value;
pub const IOpcSignatureCustomObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetXml: fn(
            self: *const IOpcSignatureCustomObject,
            xmlMarkup: ?[*]?*u8,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureCustomObject_GetXml(self: *const T, xmlMarkup: ?[*]?*u8, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureCustomObject.VTable, self.vtable).GetXml(@ptrCast(*const IOpcSignatureCustomObject, self), xmlMarkup, count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcDigitalSignature_Value = @import("../../zig.zig").Guid.initString("52ab21dd-1cd0-4949-bc80-0c1232d00cb4");
pub const IID_IOpcDigitalSignature = &IID_IOpcDigitalSignature_Value;
pub const IOpcDigitalSignature = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNamespaces: fn(
            self: *const IOpcDigitalSignature,
            prefixes: ?[*]?*?PWSTR,
            namespaces: ?[*]?*?PWSTR,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignatureId: fn(
            self: *const IOpcDigitalSignature,
            signatureId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignaturePartName: fn(
            self: *const IOpcDigitalSignature,
            signaturePartName: ?*?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignatureMethod: fn(
            self: *const IOpcDigitalSignature,
            signatureMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCanonicalizationMethod: fn(
            self: *const IOpcDigitalSignature,
            canonicalizationMethod: ?*OPC_CANONICALIZATION_METHOD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignatureValue: fn(
            self: *const IOpcDigitalSignature,
            signatureValue: ?[*]?*u8,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignaturePartReferenceEnumerator: fn(
            self: *const IOpcDigitalSignature,
            partReferenceEnumerator: ?*?*IOpcSignaturePartReferenceEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignatureRelationshipReferenceEnumerator: fn(
            self: *const IOpcDigitalSignature,
            relationshipReferenceEnumerator: ?*?*IOpcSignatureRelationshipReferenceEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSigningTime: fn(
            self: *const IOpcDigitalSignature,
            signingTime: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeFormat: fn(
            self: *const IOpcDigitalSignature,
            timeFormat: ?*OPC_SIGNATURE_TIME_FORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageObjectReference: fn(
            self: *const IOpcDigitalSignature,
            packageObjectReference: ?*?*IOpcSignatureReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateEnumerator: fn(
            self: *const IOpcDigitalSignature,
            certificateEnumerator: ?*?*IOpcCertificateEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustomReferenceEnumerator: fn(
            self: *const IOpcDigitalSignature,
            customReferenceEnumerator: ?*?*IOpcSignatureReferenceEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustomObjectEnumerator: fn(
            self: *const IOpcDigitalSignature,
            customObjectEnumerator: ?*?*IOpcSignatureCustomObjectEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignatureXml: fn(
            self: *const IOpcDigitalSignature,
            signatureXml: ?*?*u8,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetNamespaces(self: *const T, prefixes: ?[*]?*?PWSTR, namespaces: ?[*]?*?PWSTR, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetNamespaces(@ptrCast(*const IOpcDigitalSignature, self), prefixes, namespaces, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetSignatureId(self: *const T, signatureId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetSignatureId(@ptrCast(*const IOpcDigitalSignature, self), signatureId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetSignaturePartName(self: *const T, signaturePartName: ?*?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetSignaturePartName(@ptrCast(*const IOpcDigitalSignature, self), signaturePartName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetSignatureMethod(self: *const T, signatureMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetSignatureMethod(@ptrCast(*const IOpcDigitalSignature, self), signatureMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetCanonicalizationMethod(self: *const T, canonicalizationMethod: ?*OPC_CANONICALIZATION_METHOD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetCanonicalizationMethod(@ptrCast(*const IOpcDigitalSignature, self), canonicalizationMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetSignatureValue(self: *const T, signatureValue: ?[*]?*u8, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetSignatureValue(@ptrCast(*const IOpcDigitalSignature, self), signatureValue, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetSignaturePartReferenceEnumerator(self: *const T, partReferenceEnumerator: ?*?*IOpcSignaturePartReferenceEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetSignaturePartReferenceEnumerator(@ptrCast(*const IOpcDigitalSignature, self), partReferenceEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetSignatureRelationshipReferenceEnumerator(self: *const T, relationshipReferenceEnumerator: ?*?*IOpcSignatureRelationshipReferenceEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetSignatureRelationshipReferenceEnumerator(@ptrCast(*const IOpcDigitalSignature, self), relationshipReferenceEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetSigningTime(self: *const T, signingTime: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetSigningTime(@ptrCast(*const IOpcDigitalSignature, self), signingTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetTimeFormat(self: *const T, timeFormat: ?*OPC_SIGNATURE_TIME_FORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetTimeFormat(@ptrCast(*const IOpcDigitalSignature, self), timeFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetPackageObjectReference(self: *const T, packageObjectReference: ?*?*IOpcSignatureReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetPackageObjectReference(@ptrCast(*const IOpcDigitalSignature, self), packageObjectReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetCertificateEnumerator(self: *const T, certificateEnumerator: ?*?*IOpcCertificateEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetCertificateEnumerator(@ptrCast(*const IOpcDigitalSignature, self), certificateEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetCustomReferenceEnumerator(self: *const T, customReferenceEnumerator: ?*?*IOpcSignatureReferenceEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetCustomReferenceEnumerator(@ptrCast(*const IOpcDigitalSignature, self), customReferenceEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetCustomObjectEnumerator(self: *const T, customObjectEnumerator: ?*?*IOpcSignatureCustomObjectEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetCustomObjectEnumerator(@ptrCast(*const IOpcDigitalSignature, self), customObjectEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignature_GetSignatureXml(self: *const T, signatureXml: ?*?*u8, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignature.VTable, self.vtable).GetSignatureXml(@ptrCast(*const IOpcDigitalSignature, self), signatureXml, count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSigningOptions_Value = @import("../../zig.zig").Guid.initString("50d2d6a5-7aeb-46c0-b241-43ab0e9b407e");
pub const IID_IOpcSigningOptions = &IID_IOpcSigningOptions_Value;
pub const IOpcSigningOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSignatureId: fn(
            self: *const IOpcSigningOptions,
            signatureId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSignatureId: fn(
            self: *const IOpcSigningOptions,
            signatureId: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignatureMethod: fn(
            self: *const IOpcSigningOptions,
            signatureMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSignatureMethod: fn(
            self: *const IOpcSigningOptions,
            signatureMethod: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultDigestMethod: fn(
            self: *const IOpcSigningOptions,
            digestMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultDigestMethod: fn(
            self: *const IOpcSigningOptions,
            digestMethod: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateEmbeddingOption: fn(
            self: *const IOpcSigningOptions,
            embeddingOption: ?*OPC_CERTIFICATE_EMBEDDING_OPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCertificateEmbeddingOption: fn(
            self: *const IOpcSigningOptions,
            embeddingOption: OPC_CERTIFICATE_EMBEDDING_OPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeFormat: fn(
            self: *const IOpcSigningOptions,
            timeFormat: ?*OPC_SIGNATURE_TIME_FORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimeFormat: fn(
            self: *const IOpcSigningOptions,
            timeFormat: OPC_SIGNATURE_TIME_FORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignaturePartReferenceSet: fn(
            self: *const IOpcSigningOptions,
            partReferenceSet: ?*?*IOpcSignaturePartReferenceSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignatureRelationshipReferenceSet: fn(
            self: *const IOpcSigningOptions,
            relationshipReferenceSet: ?*?*IOpcSignatureRelationshipReferenceSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustomObjectSet: fn(
            self: *const IOpcSigningOptions,
            customObjectSet: ?*?*IOpcSignatureCustomObjectSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustomReferenceSet: fn(
            self: *const IOpcSigningOptions,
            customReferenceSet: ?*?*IOpcSignatureReferenceSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificateSet: fn(
            self: *const IOpcSigningOptions,
            certificateSet: ?*?*IOpcCertificateSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignaturePartName: fn(
            self: *const IOpcSigningOptions,
            signaturePartName: ?*?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSignaturePartName: fn(
            self: *const IOpcSigningOptions,
            signaturePartName: ?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetSignatureId(self: *const T, signatureId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetSignatureId(@ptrCast(*const IOpcSigningOptions, self), signatureId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_SetSignatureId(self: *const T, signatureId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).SetSignatureId(@ptrCast(*const IOpcSigningOptions, self), signatureId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetSignatureMethod(self: *const T, signatureMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetSignatureMethod(@ptrCast(*const IOpcSigningOptions, self), signatureMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_SetSignatureMethod(self: *const T, signatureMethod: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).SetSignatureMethod(@ptrCast(*const IOpcSigningOptions, self), signatureMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetDefaultDigestMethod(self: *const T, digestMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetDefaultDigestMethod(@ptrCast(*const IOpcSigningOptions, self), digestMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_SetDefaultDigestMethod(self: *const T, digestMethod: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).SetDefaultDigestMethod(@ptrCast(*const IOpcSigningOptions, self), digestMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetCertificateEmbeddingOption(self: *const T, embeddingOption: ?*OPC_CERTIFICATE_EMBEDDING_OPTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetCertificateEmbeddingOption(@ptrCast(*const IOpcSigningOptions, self), embeddingOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_SetCertificateEmbeddingOption(self: *const T, embeddingOption: OPC_CERTIFICATE_EMBEDDING_OPTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).SetCertificateEmbeddingOption(@ptrCast(*const IOpcSigningOptions, self), embeddingOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetTimeFormat(self: *const T, timeFormat: ?*OPC_SIGNATURE_TIME_FORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetTimeFormat(@ptrCast(*const IOpcSigningOptions, self), timeFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_SetTimeFormat(self: *const T, timeFormat: OPC_SIGNATURE_TIME_FORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).SetTimeFormat(@ptrCast(*const IOpcSigningOptions, self), timeFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetSignaturePartReferenceSet(self: *const T, partReferenceSet: ?*?*IOpcSignaturePartReferenceSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetSignaturePartReferenceSet(@ptrCast(*const IOpcSigningOptions, self), partReferenceSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetSignatureRelationshipReferenceSet(self: *const T, relationshipReferenceSet: ?*?*IOpcSignatureRelationshipReferenceSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetSignatureRelationshipReferenceSet(@ptrCast(*const IOpcSigningOptions, self), relationshipReferenceSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetCustomObjectSet(self: *const T, customObjectSet: ?*?*IOpcSignatureCustomObjectSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetCustomObjectSet(@ptrCast(*const IOpcSigningOptions, self), customObjectSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetCustomReferenceSet(self: *const T, customReferenceSet: ?*?*IOpcSignatureReferenceSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetCustomReferenceSet(@ptrCast(*const IOpcSigningOptions, self), customReferenceSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetCertificateSet(self: *const T, certificateSet: ?*?*IOpcCertificateSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetCertificateSet(@ptrCast(*const IOpcSigningOptions, self), certificateSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_GetSignaturePartName(self: *const T, signaturePartName: ?*?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).GetSignaturePartName(@ptrCast(*const IOpcSigningOptions, self), signaturePartName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSigningOptions_SetSignaturePartName(self: *const T, signaturePartName: ?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSigningOptions.VTable, self.vtable).SetSignaturePartName(@ptrCast(*const IOpcSigningOptions, self), signaturePartName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcDigitalSignatureManager_Value = @import("../../zig.zig").Guid.initString("d5e62a0b-696d-462f-94df-72e33cef2659");
pub const IID_IOpcDigitalSignatureManager = &IID_IOpcDigitalSignatureManager_Value;
pub const IOpcDigitalSignatureManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSignatureOriginPartName: fn(
            self: *const IOpcDigitalSignatureManager,
            signatureOriginPartName: ?*?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSignatureOriginPartName: fn(
            self: *const IOpcDigitalSignatureManager,
            signatureOriginPartName: ?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSignatureEnumerator: fn(
            self: *const IOpcDigitalSignatureManager,
            signatureEnumerator: ?*?*IOpcDigitalSignatureEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSignature: fn(
            self: *const IOpcDigitalSignatureManager,
            signaturePartName: ?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSigningOptions: fn(
            self: *const IOpcDigitalSignatureManager,
            signingOptions: ?*?*IOpcSigningOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: fn(
            self: *const IOpcDigitalSignatureManager,
            signature: ?*IOpcDigitalSignature,
            certificate: ?*const CERT_CONTEXT,
            validationResult: ?*OPC_SIGNATURE_VALIDATION_RESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Sign: fn(
            self: *const IOpcDigitalSignatureManager,
            certificate: ?*const CERT_CONTEXT,
            signingOptions: ?*IOpcSigningOptions,
            digitalSignature: ?*?*IOpcDigitalSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceSignatureXml: fn(
            self: *const IOpcDigitalSignatureManager,
            signaturePartName: ?*IOpcPartUri,
            newSignatureXml: ?*const u8,
            count: u32,
            digitalSignature: ?*?*IOpcDigitalSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureManager_GetSignatureOriginPartName(self: *const T, signatureOriginPartName: ?*?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureManager.VTable, self.vtable).GetSignatureOriginPartName(@ptrCast(*const IOpcDigitalSignatureManager, self), signatureOriginPartName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureManager_SetSignatureOriginPartName(self: *const T, signatureOriginPartName: ?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureManager.VTable, self.vtable).SetSignatureOriginPartName(@ptrCast(*const IOpcDigitalSignatureManager, self), signatureOriginPartName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureManager_GetSignatureEnumerator(self: *const T, signatureEnumerator: ?*?*IOpcDigitalSignatureEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureManager.VTable, self.vtable).GetSignatureEnumerator(@ptrCast(*const IOpcDigitalSignatureManager, self), signatureEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureManager_RemoveSignature(self: *const T, signaturePartName: ?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureManager.VTable, self.vtable).RemoveSignature(@ptrCast(*const IOpcDigitalSignatureManager, self), signaturePartName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureManager_CreateSigningOptions(self: *const T, signingOptions: ?*?*IOpcSigningOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureManager.VTable, self.vtable).CreateSigningOptions(@ptrCast(*const IOpcDigitalSignatureManager, self), signingOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureManager_Validate(self: *const T, signature: ?*IOpcDigitalSignature, certificate: ?*const CERT_CONTEXT, validationResult: ?*OPC_SIGNATURE_VALIDATION_RESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureManager.VTable, self.vtable).Validate(@ptrCast(*const IOpcDigitalSignatureManager, self), signature, certificate, validationResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureManager_Sign(self: *const T, certificate: ?*const CERT_CONTEXT, signingOptions: ?*IOpcSigningOptions, digitalSignature: ?*?*IOpcDigitalSignature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureManager.VTable, self.vtable).Sign(@ptrCast(*const IOpcDigitalSignatureManager, self), certificate, signingOptions, digitalSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureManager_ReplaceSignatureXml(self: *const T, signaturePartName: ?*IOpcPartUri, newSignatureXml: ?*const u8, count: u32, digitalSignature: ?*?*IOpcDigitalSignature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureManager.VTable, self.vtable).ReplaceSignatureXml(@ptrCast(*const IOpcDigitalSignatureManager, self), signaturePartName, newSignatureXml, count, digitalSignature);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignaturePartReferenceEnumerator_Value = @import("../../zig.zig").Guid.initString("80eb1561-8c77-49cf-8266-459b356ee99a");
pub const IID_IOpcSignaturePartReferenceEnumerator = &IID_IOpcSignaturePartReferenceEnumerator_Value;
pub const IOpcSignaturePartReferenceEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveNext: fn(
            self: *const IOpcSignaturePartReferenceEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePrevious: fn(
            self: *const IOpcSignaturePartReferenceEnumerator,
            hasPrevious: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrent: fn(
            self: *const IOpcSignaturePartReferenceEnumerator,
            partReference: ?*?*IOpcSignaturePartReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOpcSignaturePartReferenceEnumerator,
            copy: ?*?*IOpcSignaturePartReferenceEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReferenceEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReferenceEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IOpcSignaturePartReferenceEnumerator, self), hasNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReferenceEnumerator_MovePrevious(self: *const T, hasPrevious: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReferenceEnumerator.VTable, self.vtable).MovePrevious(@ptrCast(*const IOpcSignaturePartReferenceEnumerator, self), hasPrevious);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReferenceEnumerator_GetCurrent(self: *const T, partReference: ?*?*IOpcSignaturePartReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReferenceEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IOpcSignaturePartReferenceEnumerator, self), partReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReferenceEnumerator_Clone(self: *const T, copy: ?*?*IOpcSignaturePartReferenceEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReferenceEnumerator.VTable, self.vtable).Clone(@ptrCast(*const IOpcSignaturePartReferenceEnumerator, self), copy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignatureRelationshipReferenceEnumerator_Value = @import("../../zig.zig").Guid.initString("773ba3e4-f021-48e4-aa04-9816db5d3495");
pub const IID_IOpcSignatureRelationshipReferenceEnumerator = &IID_IOpcSignatureRelationshipReferenceEnumerator_Value;
pub const IOpcSignatureRelationshipReferenceEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveNext: fn(
            self: *const IOpcSignatureRelationshipReferenceEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePrevious: fn(
            self: *const IOpcSignatureRelationshipReferenceEnumerator,
            hasPrevious: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrent: fn(
            self: *const IOpcSignatureRelationshipReferenceEnumerator,
            relationshipReference: ?*?*IOpcSignatureRelationshipReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOpcSignatureRelationshipReferenceEnumerator,
            copy: ?*?*IOpcSignatureRelationshipReferenceEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReferenceEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReferenceEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IOpcSignatureRelationshipReferenceEnumerator, self), hasNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReferenceEnumerator_MovePrevious(self: *const T, hasPrevious: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReferenceEnumerator.VTable, self.vtable).MovePrevious(@ptrCast(*const IOpcSignatureRelationshipReferenceEnumerator, self), hasPrevious);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReferenceEnumerator_GetCurrent(self: *const T, relationshipReference: ?*?*IOpcSignatureRelationshipReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReferenceEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IOpcSignatureRelationshipReferenceEnumerator, self), relationshipReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReferenceEnumerator_Clone(self: *const T, copy: ?*?*IOpcSignatureRelationshipReferenceEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReferenceEnumerator.VTable, self.vtable).Clone(@ptrCast(*const IOpcSignatureRelationshipReferenceEnumerator, self), copy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcRelationshipSelectorEnumerator_Value = @import("../../zig.zig").Guid.initString("5e50a181-a91b-48ac-88d2-bca3d8f8c0b1");
pub const IID_IOpcRelationshipSelectorEnumerator = &IID_IOpcRelationshipSelectorEnumerator_Value;
pub const IOpcRelationshipSelectorEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveNext: fn(
            self: *const IOpcRelationshipSelectorEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePrevious: fn(
            self: *const IOpcRelationshipSelectorEnumerator,
            hasPrevious: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrent: fn(
            self: *const IOpcRelationshipSelectorEnumerator,
            relationshipSelector: ?*?*IOpcRelationshipSelector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOpcRelationshipSelectorEnumerator,
            copy: ?*?*IOpcRelationshipSelectorEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSelectorEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSelectorEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IOpcRelationshipSelectorEnumerator, self), hasNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSelectorEnumerator_MovePrevious(self: *const T, hasPrevious: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSelectorEnumerator.VTable, self.vtable).MovePrevious(@ptrCast(*const IOpcRelationshipSelectorEnumerator, self), hasPrevious);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSelectorEnumerator_GetCurrent(self: *const T, relationshipSelector: ?*?*IOpcRelationshipSelector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSelectorEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IOpcRelationshipSelectorEnumerator, self), relationshipSelector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSelectorEnumerator_Clone(self: *const T, copy: ?*?*IOpcRelationshipSelectorEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSelectorEnumerator.VTable, self.vtable).Clone(@ptrCast(*const IOpcRelationshipSelectorEnumerator, self), copy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignatureReferenceEnumerator_Value = @import("../../zig.zig").Guid.initString("cfa59a45-28b1-4868-969e-fa8097fdc12a");
pub const IID_IOpcSignatureReferenceEnumerator = &IID_IOpcSignatureReferenceEnumerator_Value;
pub const IOpcSignatureReferenceEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveNext: fn(
            self: *const IOpcSignatureReferenceEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePrevious: fn(
            self: *const IOpcSignatureReferenceEnumerator,
            hasPrevious: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrent: fn(
            self: *const IOpcSignatureReferenceEnumerator,
            reference: ?*?*IOpcSignatureReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOpcSignatureReferenceEnumerator,
            copy: ?*?*IOpcSignatureReferenceEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReferenceEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReferenceEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IOpcSignatureReferenceEnumerator, self), hasNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReferenceEnumerator_MovePrevious(self: *const T, hasPrevious: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReferenceEnumerator.VTable, self.vtable).MovePrevious(@ptrCast(*const IOpcSignatureReferenceEnumerator, self), hasPrevious);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReferenceEnumerator_GetCurrent(self: *const T, reference: ?*?*IOpcSignatureReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReferenceEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IOpcSignatureReferenceEnumerator, self), reference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReferenceEnumerator_Clone(self: *const T, copy: ?*?*IOpcSignatureReferenceEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReferenceEnumerator.VTable, self.vtable).Clone(@ptrCast(*const IOpcSignatureReferenceEnumerator, self), copy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignatureCustomObjectEnumerator_Value = @import("../../zig.zig").Guid.initString("5ee4fe1d-e1b0-4683-8079-7ea0fcf80b4c");
pub const IID_IOpcSignatureCustomObjectEnumerator = &IID_IOpcSignatureCustomObjectEnumerator_Value;
pub const IOpcSignatureCustomObjectEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveNext: fn(
            self: *const IOpcSignatureCustomObjectEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePrevious: fn(
            self: *const IOpcSignatureCustomObjectEnumerator,
            hasPrevious: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrent: fn(
            self: *const IOpcSignatureCustomObjectEnumerator,
            customObject: ?*?*IOpcSignatureCustomObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOpcSignatureCustomObjectEnumerator,
            copy: ?*?*IOpcSignatureCustomObjectEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureCustomObjectEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureCustomObjectEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IOpcSignatureCustomObjectEnumerator, self), hasNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureCustomObjectEnumerator_MovePrevious(self: *const T, hasPrevious: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureCustomObjectEnumerator.VTable, self.vtable).MovePrevious(@ptrCast(*const IOpcSignatureCustomObjectEnumerator, self), hasPrevious);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureCustomObjectEnumerator_GetCurrent(self: *const T, customObject: ?*?*IOpcSignatureCustomObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureCustomObjectEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IOpcSignatureCustomObjectEnumerator, self), customObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureCustomObjectEnumerator_Clone(self: *const T, copy: ?*?*IOpcSignatureCustomObjectEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureCustomObjectEnumerator.VTable, self.vtable).Clone(@ptrCast(*const IOpcSignatureCustomObjectEnumerator, self), copy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcCertificateEnumerator_Value = @import("../../zig.zig").Guid.initString("85131937-8f24-421f-b439-59ab24d140b8");
pub const IID_IOpcCertificateEnumerator = &IID_IOpcCertificateEnumerator_Value;
pub const IOpcCertificateEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveNext: fn(
            self: *const IOpcCertificateEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePrevious: fn(
            self: *const IOpcCertificateEnumerator,
            hasPrevious: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrent: fn(
            self: *const IOpcCertificateEnumerator,
            certificate: ?*const ?*CERT_CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOpcCertificateEnumerator,
            copy: ?*?*IOpcCertificateEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcCertificateEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcCertificateEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IOpcCertificateEnumerator, self), hasNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcCertificateEnumerator_MovePrevious(self: *const T, hasPrevious: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcCertificateEnumerator.VTable, self.vtable).MovePrevious(@ptrCast(*const IOpcCertificateEnumerator, self), hasPrevious);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcCertificateEnumerator_GetCurrent(self: *const T, certificate: ?*const ?*CERT_CONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcCertificateEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IOpcCertificateEnumerator, self), certificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcCertificateEnumerator_Clone(self: *const T, copy: ?*?*IOpcCertificateEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcCertificateEnumerator.VTable, self.vtable).Clone(@ptrCast(*const IOpcCertificateEnumerator, self), copy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcDigitalSignatureEnumerator_Value = @import("../../zig.zig").Guid.initString("967b6882-0ba3-4358-b9e7-b64c75063c5e");
pub const IID_IOpcDigitalSignatureEnumerator = &IID_IOpcDigitalSignatureEnumerator_Value;
pub const IOpcDigitalSignatureEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveNext: fn(
            self: *const IOpcDigitalSignatureEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePrevious: fn(
            self: *const IOpcDigitalSignatureEnumerator,
            hasPrevious: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrent: fn(
            self: *const IOpcDigitalSignatureEnumerator,
            digitalSignature: ?*?*IOpcDigitalSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IOpcDigitalSignatureEnumerator,
            copy: ?*?*IOpcDigitalSignatureEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IOpcDigitalSignatureEnumerator, self), hasNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureEnumerator_MovePrevious(self: *const T, hasPrevious: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureEnumerator.VTable, self.vtable).MovePrevious(@ptrCast(*const IOpcDigitalSignatureEnumerator, self), hasPrevious);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureEnumerator_GetCurrent(self: *const T, digitalSignature: ?*?*IOpcDigitalSignature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IOpcDigitalSignatureEnumerator, self), digitalSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcDigitalSignatureEnumerator_Clone(self: *const T, copy: ?*?*IOpcDigitalSignatureEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcDigitalSignatureEnumerator.VTable, self.vtable).Clone(@ptrCast(*const IOpcDigitalSignatureEnumerator, self), copy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignaturePartReferenceSet_Value = @import("../../zig.zig").Guid.initString("6c9fe28c-ecd9-4b22-9d36-7fdde670fec0");
pub const IID_IOpcSignaturePartReferenceSet = &IID_IOpcSignaturePartReferenceSet_Value;
pub const IOpcSignaturePartReferenceSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IOpcSignaturePartReferenceSet,
            partUri: ?*IOpcPartUri,
            digestMethod: ?[*:0]const u16,
            transformMethod: OPC_CANONICALIZATION_METHOD,
            partReference: ?*?*IOpcSignaturePartReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IOpcSignaturePartReferenceSet,
            partReference: ?*IOpcSignaturePartReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumerator: fn(
            self: *const IOpcSignaturePartReferenceSet,
            partReferenceEnumerator: ?*?*IOpcSignaturePartReferenceEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReferenceSet_Create(self: *const T, partUri: ?*IOpcPartUri, digestMethod: ?[*:0]const u16, transformMethod: OPC_CANONICALIZATION_METHOD, partReference: ?*?*IOpcSignaturePartReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReferenceSet.VTable, self.vtable).Create(@ptrCast(*const IOpcSignaturePartReferenceSet, self), partUri, digestMethod, transformMethod, partReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReferenceSet_Delete(self: *const T, partReference: ?*IOpcSignaturePartReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReferenceSet.VTable, self.vtable).Delete(@ptrCast(*const IOpcSignaturePartReferenceSet, self), partReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignaturePartReferenceSet_GetEnumerator(self: *const T, partReferenceEnumerator: ?*?*IOpcSignaturePartReferenceEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignaturePartReferenceSet.VTable, self.vtable).GetEnumerator(@ptrCast(*const IOpcSignaturePartReferenceSet, self), partReferenceEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignatureRelationshipReferenceSet_Value = @import("../../zig.zig").Guid.initString("9f863ca5-3631-404c-828d-807e0715069b");
pub const IID_IOpcSignatureRelationshipReferenceSet = &IID_IOpcSignatureRelationshipReferenceSet_Value;
pub const IOpcSignatureRelationshipReferenceSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IOpcSignatureRelationshipReferenceSet,
            sourceUri: ?*IOpcUri,
            digestMethod: ?[*:0]const u16,
            relationshipSigningOption: OPC_RELATIONSHIPS_SIGNING_OPTION,
            selectorSet: ?*IOpcRelationshipSelectorSet,
            transformMethod: OPC_CANONICALIZATION_METHOD,
            relationshipReference: ?*?*IOpcSignatureRelationshipReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRelationshipSelectorSet: fn(
            self: *const IOpcSignatureRelationshipReferenceSet,
            selectorSet: ?*?*IOpcRelationshipSelectorSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IOpcSignatureRelationshipReferenceSet,
            relationshipReference: ?*IOpcSignatureRelationshipReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumerator: fn(
            self: *const IOpcSignatureRelationshipReferenceSet,
            relationshipReferenceEnumerator: ?*?*IOpcSignatureRelationshipReferenceEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReferenceSet_Create(self: *const T, sourceUri: ?*IOpcUri, digestMethod: ?[*:0]const u16, relationshipSigningOption: OPC_RELATIONSHIPS_SIGNING_OPTION, selectorSet: ?*IOpcRelationshipSelectorSet, transformMethod: OPC_CANONICALIZATION_METHOD, relationshipReference: ?*?*IOpcSignatureRelationshipReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReferenceSet.VTable, self.vtable).Create(@ptrCast(*const IOpcSignatureRelationshipReferenceSet, self), sourceUri, digestMethod, relationshipSigningOption, selectorSet, transformMethod, relationshipReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReferenceSet_CreateRelationshipSelectorSet(self: *const T, selectorSet: ?*?*IOpcRelationshipSelectorSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReferenceSet.VTable, self.vtable).CreateRelationshipSelectorSet(@ptrCast(*const IOpcSignatureRelationshipReferenceSet, self), selectorSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReferenceSet_Delete(self: *const T, relationshipReference: ?*IOpcSignatureRelationshipReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReferenceSet.VTable, self.vtable).Delete(@ptrCast(*const IOpcSignatureRelationshipReferenceSet, self), relationshipReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureRelationshipReferenceSet_GetEnumerator(self: *const T, relationshipReferenceEnumerator: ?*?*IOpcSignatureRelationshipReferenceEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureRelationshipReferenceSet.VTable, self.vtable).GetEnumerator(@ptrCast(*const IOpcSignatureRelationshipReferenceSet, self), relationshipReferenceEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcRelationshipSelectorSet_Value = @import("../../zig.zig").Guid.initString("6e34c269-a4d3-47c0-b5c4-87ff2b3b6136");
pub const IID_IOpcRelationshipSelectorSet = &IID_IOpcRelationshipSelectorSet_Value;
pub const IOpcRelationshipSelectorSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IOpcRelationshipSelectorSet,
            selector: OPC_RELATIONSHIP_SELECTOR,
            selectionCriterion: ?[*:0]const u16,
            relationshipSelector: ?*?*IOpcRelationshipSelector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IOpcRelationshipSelectorSet,
            relationshipSelector: ?*IOpcRelationshipSelector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumerator: fn(
            self: *const IOpcRelationshipSelectorSet,
            relationshipSelectorEnumerator: ?*?*IOpcRelationshipSelectorEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSelectorSet_Create(self: *const T, selector: OPC_RELATIONSHIP_SELECTOR, selectionCriterion: ?[*:0]const u16, relationshipSelector: ?*?*IOpcRelationshipSelector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSelectorSet.VTable, self.vtable).Create(@ptrCast(*const IOpcRelationshipSelectorSet, self), selector, selectionCriterion, relationshipSelector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSelectorSet_Delete(self: *const T, relationshipSelector: ?*IOpcRelationshipSelector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSelectorSet.VTable, self.vtable).Delete(@ptrCast(*const IOpcRelationshipSelectorSet, self), relationshipSelector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcRelationshipSelectorSet_GetEnumerator(self: *const T, relationshipSelectorEnumerator: ?*?*IOpcRelationshipSelectorEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcRelationshipSelectorSet.VTable, self.vtable).GetEnumerator(@ptrCast(*const IOpcRelationshipSelectorSet, self), relationshipSelectorEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignatureReferenceSet_Value = @import("../../zig.zig").Guid.initString("f3b02d31-ab12-42dd-9e2f-2b16761c3c1e");
pub const IID_IOpcSignatureReferenceSet = &IID_IOpcSignatureReferenceSet_Value;
pub const IOpcSignatureReferenceSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IOpcSignatureReferenceSet,
            referenceUri: ?*IUri,
            referenceId: ?[*:0]const u16,
            type: ?[*:0]const u16,
            digestMethod: ?[*:0]const u16,
            transformMethod: OPC_CANONICALIZATION_METHOD,
            reference: ?*?*IOpcSignatureReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IOpcSignatureReferenceSet,
            reference: ?*IOpcSignatureReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumerator: fn(
            self: *const IOpcSignatureReferenceSet,
            referenceEnumerator: ?*?*IOpcSignatureReferenceEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReferenceSet_Create(self: *const T, referenceUri: ?*IUri, referenceId: ?[*:0]const u16, type_: ?[*:0]const u16, digestMethod: ?[*:0]const u16, transformMethod: OPC_CANONICALIZATION_METHOD, reference: ?*?*IOpcSignatureReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReferenceSet.VTable, self.vtable).Create(@ptrCast(*const IOpcSignatureReferenceSet, self), referenceUri, referenceId, type_, digestMethod, transformMethod, reference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReferenceSet_Delete(self: *const T, reference: ?*IOpcSignatureReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReferenceSet.VTable, self.vtable).Delete(@ptrCast(*const IOpcSignatureReferenceSet, self), reference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureReferenceSet_GetEnumerator(self: *const T, referenceEnumerator: ?*?*IOpcSignatureReferenceEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureReferenceSet.VTable, self.vtable).GetEnumerator(@ptrCast(*const IOpcSignatureReferenceSet, self), referenceEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcSignatureCustomObjectSet_Value = @import("../../zig.zig").Guid.initString("8f792ac5-7947-4e11-bc3d-2659ff046ae1");
pub const IID_IOpcSignatureCustomObjectSet = &IID_IOpcSignatureCustomObjectSet_Value;
pub const IOpcSignatureCustomObjectSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IOpcSignatureCustomObjectSet,
            xmlMarkup: [*:0]const u8,
            count: u32,
            customObject: ?*?*IOpcSignatureCustomObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IOpcSignatureCustomObjectSet,
            customObject: ?*IOpcSignatureCustomObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumerator: fn(
            self: *const IOpcSignatureCustomObjectSet,
            customObjectEnumerator: ?*?*IOpcSignatureCustomObjectEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureCustomObjectSet_Create(self: *const T, xmlMarkup: [*:0]const u8, count: u32, customObject: ?*?*IOpcSignatureCustomObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureCustomObjectSet.VTable, self.vtable).Create(@ptrCast(*const IOpcSignatureCustomObjectSet, self), xmlMarkup, count, customObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureCustomObjectSet_Delete(self: *const T, customObject: ?*IOpcSignatureCustomObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureCustomObjectSet.VTable, self.vtable).Delete(@ptrCast(*const IOpcSignatureCustomObjectSet, self), customObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcSignatureCustomObjectSet_GetEnumerator(self: *const T, customObjectEnumerator: ?*?*IOpcSignatureCustomObjectEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcSignatureCustomObjectSet.VTable, self.vtable).GetEnumerator(@ptrCast(*const IOpcSignatureCustomObjectSet, self), customObjectEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcCertificateSet_Value = @import("../../zig.zig").Guid.initString("56ea4325-8e2d-4167-b1a4-e486d24c8fa7");
pub const IID_IOpcCertificateSet = &IID_IOpcCertificateSet_Value;
pub const IOpcCertificateSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: fn(
            self: *const IOpcCertificateSet,
            certificate: ?*const CERT_CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IOpcCertificateSet,
            certificate: ?*const CERT_CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumerator: fn(
            self: *const IOpcCertificateSet,
            certificateEnumerator: ?*?*IOpcCertificateEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcCertificateSet_Add(self: *const T, certificate: ?*const CERT_CONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcCertificateSet.VTable, self.vtable).Add(@ptrCast(*const IOpcCertificateSet, self), certificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcCertificateSet_Remove(self: *const T, certificate: ?*const CERT_CONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcCertificateSet.VTable, self.vtable).Remove(@ptrCast(*const IOpcCertificateSet, self), certificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcCertificateSet_GetEnumerator(self: *const T, certificateEnumerator: ?*?*IOpcCertificateEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcCertificateSet.VTable, self.vtable).GetEnumerator(@ptrCast(*const IOpcCertificateSet, self), certificateEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpcFactory_Value = @import("../../zig.zig").Guid.initString("6d0b4446-cd73-4ab3-94f4-8ccdf6116154");
pub const IID_IOpcFactory = &IID_IOpcFactory_Value;
pub const IOpcFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePackageRootUri: fn(
            self: *const IOpcFactory,
            rootUri: ?*?*IOpcUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePartUri: fn(
            self: *const IOpcFactory,
            pwzUri: ?[*:0]const u16,
            partUri: ?*?*IOpcPartUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStreamOnFile: fn(
            self: *const IOpcFactory,
            filename: ?[*:0]const u16,
            ioMode: OPC_STREAM_IO_MODE,
            securityAttributes: ?*SECURITY_ATTRIBUTES,
            dwFlagsAndAttributes: u32,
            stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePackage: fn(
            self: *const IOpcFactory,
            package: ?*?*IOpcPackage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPackageFromStream: fn(
            self: *const IOpcFactory,
            stream: ?*IStream,
            flags: OPC_READ_FLAGS,
            package: ?*?*IOpcPackage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePackageToStream: fn(
            self: *const IOpcFactory,
            package: ?*IOpcPackage,
            flags: OPC_WRITE_FLAGS,
            stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDigitalSignatureManager: fn(
            self: *const IOpcFactory,
            package: ?*IOpcPackage,
            signatureManager: ?*?*IOpcDigitalSignatureManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcFactory_CreatePackageRootUri(self: *const T, rootUri: ?*?*IOpcUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcFactory.VTable, self.vtable).CreatePackageRootUri(@ptrCast(*const IOpcFactory, self), rootUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcFactory_CreatePartUri(self: *const T, pwzUri: ?[*:0]const u16, partUri: ?*?*IOpcPartUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcFactory.VTable, self.vtable).CreatePartUri(@ptrCast(*const IOpcFactory, self), pwzUri, partUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcFactory_CreateStreamOnFile(self: *const T, filename: ?[*:0]const u16, ioMode: OPC_STREAM_IO_MODE, securityAttributes: ?*SECURITY_ATTRIBUTES, dwFlagsAndAttributes: u32, stream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcFactory.VTable, self.vtable).CreateStreamOnFile(@ptrCast(*const IOpcFactory, self), filename, ioMode, securityAttributes, dwFlagsAndAttributes, stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcFactory_CreatePackage(self: *const T, package: ?*?*IOpcPackage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcFactory.VTable, self.vtable).CreatePackage(@ptrCast(*const IOpcFactory, self), package);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcFactory_ReadPackageFromStream(self: *const T, stream: ?*IStream, flags: OPC_READ_FLAGS, package: ?*?*IOpcPackage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcFactory.VTable, self.vtable).ReadPackageFromStream(@ptrCast(*const IOpcFactory, self), stream, flags, package);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcFactory_WritePackageToStream(self: *const T, package: ?*IOpcPackage, flags: OPC_WRITE_FLAGS, stream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcFactory.VTable, self.vtable).WritePackageToStream(@ptrCast(*const IOpcFactory, self), package, flags, stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpcFactory_CreateDigitalSignatureManager(self: *const T, package: ?*IOpcPackage, signatureManager: ?*?*IOpcDigitalSignatureManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpcFactory.VTable, self.vtable).CreateDigitalSignatureManager(@ptrCast(*const IOpcFactory, self), package, signatureManager);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const BOOL = @import("../../foundation.zig").BOOL;
const CERT_CONTEXT = @import("../../security/cryptography.zig").CERT_CONTEXT;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IStream = @import("../../system/com.zig").IStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const IUri = @import("../../system/com.zig").IUri;
const PWSTR = @import("../../foundation.zig").PWSTR;
const SECURITY_ATTRIBUTES = @import("../../security.zig").SECURITY_ATTRIBUTES;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
