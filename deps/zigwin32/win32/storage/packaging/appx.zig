//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (22)
//--------------------------------------------------------------------------------
pub const PACKAGE_PROPERTY_FRAMEWORK = @as(u32, 1);
pub const PACKAGE_PROPERTY_RESOURCE = @as(u32, 2);
pub const PACKAGE_PROPERTY_BUNDLE = @as(u32, 4);
pub const PACKAGE_PROPERTY_OPTIONAL = @as(u32, 8);
pub const PACKAGE_FILTER_HEAD = @as(u32, 16);
pub const PACKAGE_FILTER_DIRECT = @as(u32, 32);
pub const PACKAGE_FILTER_RESOURCE = @as(u32, 64);
pub const PACKAGE_FILTER_BUNDLE = @as(u32, 128);
pub const PACKAGE_INFORMATION_BASIC = @as(u32, 0);
pub const PACKAGE_INFORMATION_FULL = @as(u32, 256);
pub const PACKAGE_PROPERTY_DEVELOPMENT_MODE = @as(u32, 65536);
pub const PACKAGE_FILTER_OPTIONAL = @as(u32, 131072);
pub const PACKAGE_PROPERTY_IS_IN_RELATED_SET = @as(u32, 262144);
pub const PACKAGE_FILTER_IS_IN_RELATED_SET = @as(u32, 262144);
pub const PACKAGE_PROPERTY_STATIC = @as(u32, 524288);
pub const PACKAGE_FILTER_STATIC = @as(u32, 524288);
pub const PACKAGE_PROPERTY_DYNAMIC = @as(u32, 1048576);
pub const PACKAGE_FILTER_DYNAMIC = @as(u32, 1048576);
pub const PACKAGE_PROPERTY_HOSTRUNTIME = @as(u32, 2097152);
pub const PACKAGE_FILTER_HOSTRUNTIME = @as(u32, 2097152);
pub const PACKAGE_FILTER_ALL_LOADED = @as(u32, 0);
pub const PACKAGE_DEPENDENCY_RANK_DEFAULT = @as(u32, 0);

//--------------------------------------------------------------------------------
// Section: Types (125)
//--------------------------------------------------------------------------------
const CLSID_AppxFactory_Value = @import("../../zig.zig").Guid.initString("5842a140-ff9f-4166-8f5c-62f5b7b0c781");
pub const CLSID_AppxFactory = &CLSID_AppxFactory_Value;

const CLSID_AppxBundleFactory_Value = @import("../../zig.zig").Guid.initString("378e0446-5384-43b7-8877-e7dbdd883446");
pub const CLSID_AppxBundleFactory = &CLSID_AppxBundleFactory_Value;

const CLSID_AppxPackagingDiagnosticEventSinkManager_Value = @import("../../zig.zig").Guid.initString("50ca0a46-1588-4161-8ed2-ef9e469ced5d");
pub const CLSID_AppxPackagingDiagnosticEventSinkManager = &CLSID_AppxPackagingDiagnosticEventSinkManager_Value;

const CLSID_AppxEncryptionFactory_Value = @import("../../zig.zig").Guid.initString("dc664fdd-d868-46ee-8780-8d196cb739f7");
pub const CLSID_AppxEncryptionFactory = &CLSID_AppxEncryptionFactory_Value;

const CLSID_AppxPackageEditor_Value = @import("../../zig.zig").Guid.initString("f004f2ca-aebc-4b0d-bf58-e516d5bcc0ab");
pub const CLSID_AppxPackageEditor = &CLSID_AppxPackageEditor_Value;

pub const APPX_PACKAGE_SETTINGS = extern struct {
    forceZip32: BOOL,
    hashMethod: ?*IUri,
};

pub const APPX_COMPRESSION_OPTION = enum(i32) {
    NONE = 0,
    NORMAL = 1,
    MAXIMUM = 2,
    FAST = 3,
    SUPERFAST = 4,
};
pub const APPX_COMPRESSION_OPTION_NONE = APPX_COMPRESSION_OPTION.NONE;
pub const APPX_COMPRESSION_OPTION_NORMAL = APPX_COMPRESSION_OPTION.NORMAL;
pub const APPX_COMPRESSION_OPTION_MAXIMUM = APPX_COMPRESSION_OPTION.MAXIMUM;
pub const APPX_COMPRESSION_OPTION_FAST = APPX_COMPRESSION_OPTION.FAST;
pub const APPX_COMPRESSION_OPTION_SUPERFAST = APPX_COMPRESSION_OPTION.SUPERFAST;

pub const APPX_PACKAGE_WRITER_PAYLOAD_STREAM = extern struct {
    inputStream: ?*IStream,
    fileName: ?[*:0]const u16,
    contentType: ?[*:0]const u16,
    compressionOption: APPX_COMPRESSION_OPTION,
};

pub const APPX_FOOTPRINT_FILE_TYPE = enum(i32) {
    MANIFEST = 0,
    BLOCKMAP = 1,
    SIGNATURE = 2,
    CODEINTEGRITY = 3,
    CONTENTGROUPMAP = 4,
};
pub const APPX_FOOTPRINT_FILE_TYPE_MANIFEST = APPX_FOOTPRINT_FILE_TYPE.MANIFEST;
pub const APPX_FOOTPRINT_FILE_TYPE_BLOCKMAP = APPX_FOOTPRINT_FILE_TYPE.BLOCKMAP;
pub const APPX_FOOTPRINT_FILE_TYPE_SIGNATURE = APPX_FOOTPRINT_FILE_TYPE.SIGNATURE;
pub const APPX_FOOTPRINT_FILE_TYPE_CODEINTEGRITY = APPX_FOOTPRINT_FILE_TYPE.CODEINTEGRITY;
pub const APPX_FOOTPRINT_FILE_TYPE_CONTENTGROUPMAP = APPX_FOOTPRINT_FILE_TYPE.CONTENTGROUPMAP;

pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE = enum(i32) {
    FIRST = 0,
    // MANIFEST = 0, this enum value conflicts with FIRST
    BLOCKMAP = 1,
    SIGNATURE = 2,
    // LAST = 2, this enum value conflicts with SIGNATURE
};
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_FIRST = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.FIRST;
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_MANIFEST = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.FIRST;
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_BLOCKMAP = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.BLOCKMAP;
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_SIGNATURE = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.SIGNATURE;
pub const APPX_BUNDLE_FOOTPRINT_FILE_TYPE_LAST = APPX_BUNDLE_FOOTPRINT_FILE_TYPE.SIGNATURE;

pub const APPX_CAPABILITIES = enum(u32) {
    INTERNET_CLIENT = 1,
    INTERNET_CLIENT_SERVER = 2,
    PRIVATE_NETWORK_CLIENT_SERVER = 4,
    DOCUMENTS_LIBRARY = 8,
    PICTURES_LIBRARY = 16,
    VIDEOS_LIBRARY = 32,
    MUSIC_LIBRARY = 64,
    ENTERPRISE_AUTHENTICATION = 128,
    SHARED_USER_CERTIFICATES = 256,
    REMOVABLE_STORAGE = 512,
    APPOINTMENTS = 1024,
    CONTACTS = 2048,
    _,
    pub fn initFlags(o: struct {
        INTERNET_CLIENT: u1 = 0,
        INTERNET_CLIENT_SERVER: u1 = 0,
        PRIVATE_NETWORK_CLIENT_SERVER: u1 = 0,
        DOCUMENTS_LIBRARY: u1 = 0,
        PICTURES_LIBRARY: u1 = 0,
        VIDEOS_LIBRARY: u1 = 0,
        MUSIC_LIBRARY: u1 = 0,
        ENTERPRISE_AUTHENTICATION: u1 = 0,
        SHARED_USER_CERTIFICATES: u1 = 0,
        REMOVABLE_STORAGE: u1 = 0,
        APPOINTMENTS: u1 = 0,
        CONTACTS: u1 = 0,
    }) APPX_CAPABILITIES {
        return @intToEnum(APPX_CAPABILITIES,
              (if (o.INTERNET_CLIENT == 1) @enumToInt(APPX_CAPABILITIES.INTERNET_CLIENT) else 0)
            | (if (o.INTERNET_CLIENT_SERVER == 1) @enumToInt(APPX_CAPABILITIES.INTERNET_CLIENT_SERVER) else 0)
            | (if (o.PRIVATE_NETWORK_CLIENT_SERVER == 1) @enumToInt(APPX_CAPABILITIES.PRIVATE_NETWORK_CLIENT_SERVER) else 0)
            | (if (o.DOCUMENTS_LIBRARY == 1) @enumToInt(APPX_CAPABILITIES.DOCUMENTS_LIBRARY) else 0)
            | (if (o.PICTURES_LIBRARY == 1) @enumToInt(APPX_CAPABILITIES.PICTURES_LIBRARY) else 0)
            | (if (o.VIDEOS_LIBRARY == 1) @enumToInt(APPX_CAPABILITIES.VIDEOS_LIBRARY) else 0)
            | (if (o.MUSIC_LIBRARY == 1) @enumToInt(APPX_CAPABILITIES.MUSIC_LIBRARY) else 0)
            | (if (o.ENTERPRISE_AUTHENTICATION == 1) @enumToInt(APPX_CAPABILITIES.ENTERPRISE_AUTHENTICATION) else 0)
            | (if (o.SHARED_USER_CERTIFICATES == 1) @enumToInt(APPX_CAPABILITIES.SHARED_USER_CERTIFICATES) else 0)
            | (if (o.REMOVABLE_STORAGE == 1) @enumToInt(APPX_CAPABILITIES.REMOVABLE_STORAGE) else 0)
            | (if (o.APPOINTMENTS == 1) @enumToInt(APPX_CAPABILITIES.APPOINTMENTS) else 0)
            | (if (o.CONTACTS == 1) @enumToInt(APPX_CAPABILITIES.CONTACTS) else 0)
        );
    }
};
pub const APPX_CAPABILITY_INTERNET_CLIENT = APPX_CAPABILITIES.INTERNET_CLIENT;
pub const APPX_CAPABILITY_INTERNET_CLIENT_SERVER = APPX_CAPABILITIES.INTERNET_CLIENT_SERVER;
pub const APPX_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER = APPX_CAPABILITIES.PRIVATE_NETWORK_CLIENT_SERVER;
pub const APPX_CAPABILITY_DOCUMENTS_LIBRARY = APPX_CAPABILITIES.DOCUMENTS_LIBRARY;
pub const APPX_CAPABILITY_PICTURES_LIBRARY = APPX_CAPABILITIES.PICTURES_LIBRARY;
pub const APPX_CAPABILITY_VIDEOS_LIBRARY = APPX_CAPABILITIES.VIDEOS_LIBRARY;
pub const APPX_CAPABILITY_MUSIC_LIBRARY = APPX_CAPABILITIES.MUSIC_LIBRARY;
pub const APPX_CAPABILITY_ENTERPRISE_AUTHENTICATION = APPX_CAPABILITIES.ENTERPRISE_AUTHENTICATION;
pub const APPX_CAPABILITY_SHARED_USER_CERTIFICATES = APPX_CAPABILITIES.SHARED_USER_CERTIFICATES;
pub const APPX_CAPABILITY_REMOVABLE_STORAGE = APPX_CAPABILITIES.REMOVABLE_STORAGE;
pub const APPX_CAPABILITY_APPOINTMENTS = APPX_CAPABILITIES.APPOINTMENTS;
pub const APPX_CAPABILITY_CONTACTS = APPX_CAPABILITIES.CONTACTS;

pub const APPX_PACKAGE_ARCHITECTURE = enum(i32) {
    X86 = 0,
    ARM = 5,
    X64 = 9,
    NEUTRAL = 11,
    ARM64 = 12,
};
pub const APPX_PACKAGE_ARCHITECTURE_X86 = APPX_PACKAGE_ARCHITECTURE.X86;
pub const APPX_PACKAGE_ARCHITECTURE_ARM = APPX_PACKAGE_ARCHITECTURE.ARM;
pub const APPX_PACKAGE_ARCHITECTURE_X64 = APPX_PACKAGE_ARCHITECTURE.X64;
pub const APPX_PACKAGE_ARCHITECTURE_NEUTRAL = APPX_PACKAGE_ARCHITECTURE.NEUTRAL;
pub const APPX_PACKAGE_ARCHITECTURE_ARM64 = APPX_PACKAGE_ARCHITECTURE.ARM64;

pub const APPX_PACKAGE_ARCHITECTURE2 = enum(i32) {
    X86 = 0,
    ARM = 5,
    X64 = 9,
    NEUTRAL = 11,
    ARM64 = 12,
    X86_ON_ARM64 = 14,
    UNKNOWN = 65535,
};
pub const APPX_PACKAGE_ARCHITECTURE2_X86 = APPX_PACKAGE_ARCHITECTURE2.X86;
pub const APPX_PACKAGE_ARCHITECTURE2_ARM = APPX_PACKAGE_ARCHITECTURE2.ARM;
pub const APPX_PACKAGE_ARCHITECTURE2_X64 = APPX_PACKAGE_ARCHITECTURE2.X64;
pub const APPX_PACKAGE_ARCHITECTURE2_NEUTRAL = APPX_PACKAGE_ARCHITECTURE2.NEUTRAL;
pub const APPX_PACKAGE_ARCHITECTURE2_ARM64 = APPX_PACKAGE_ARCHITECTURE2.ARM64;
pub const APPX_PACKAGE_ARCHITECTURE2_X86_ON_ARM64 = APPX_PACKAGE_ARCHITECTURE2.X86_ON_ARM64;
pub const APPX_PACKAGE_ARCHITECTURE2_UNKNOWN = APPX_PACKAGE_ARCHITECTURE2.UNKNOWN;

pub const APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE = enum(i32) {
    APPLICATION = 0,
    RESOURCE = 1,
};
pub const APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE_APPLICATION = APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE.APPLICATION;
pub const APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE_RESOURCE = APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE.RESOURCE;

pub const DX_FEATURE_LEVEL = enum(i32) {
    UNSPECIFIED = 0,
    @"9" = 1,
    @"10" = 2,
    @"11" = 3,
};
pub const DX_FEATURE_LEVEL_UNSPECIFIED = DX_FEATURE_LEVEL.UNSPECIFIED;
pub const DX_FEATURE_LEVEL_9 = DX_FEATURE_LEVEL.@"9";
pub const DX_FEATURE_LEVEL_10 = DX_FEATURE_LEVEL.@"10";
pub const DX_FEATURE_LEVEL_11 = DX_FEATURE_LEVEL.@"11";

pub const APPX_CAPABILITY_CLASS_TYPE = enum(i32) {
    DEFAULT = 0,
    GENERAL = 1,
    RESTRICTED = 2,
    WINDOWS = 4,
    ALL = 7,
    CUSTOM = 8,
};
pub const APPX_CAPABILITY_CLASS_DEFAULT = APPX_CAPABILITY_CLASS_TYPE.DEFAULT;
pub const APPX_CAPABILITY_CLASS_GENERAL = APPX_CAPABILITY_CLASS_TYPE.GENERAL;
pub const APPX_CAPABILITY_CLASS_RESTRICTED = APPX_CAPABILITY_CLASS_TYPE.RESTRICTED;
pub const APPX_CAPABILITY_CLASS_WINDOWS = APPX_CAPABILITY_CLASS_TYPE.WINDOWS;
pub const APPX_CAPABILITY_CLASS_ALL = APPX_CAPABILITY_CLASS_TYPE.ALL;
pub const APPX_CAPABILITY_CLASS_CUSTOM = APPX_CAPABILITY_CLASS_TYPE.CUSTOM;

pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE = enum(i32) {
    START = 0,
    CHANGE = 1,
    DETAILS = 2,
    END = 3,
};
pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE_START = APPX_PACKAGING_CONTEXT_CHANGE_TYPE.START;
pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE_CHANGE = APPX_PACKAGING_CONTEXT_CHANGE_TYPE.CHANGE;
pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE_DETAILS = APPX_PACKAGING_CONTEXT_CHANGE_TYPE.DETAILS;
pub const APPX_PACKAGING_CONTEXT_CHANGE_TYPE_END = APPX_PACKAGING_CONTEXT_CHANGE_TYPE.END;

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxFactory_Value = @import("../../zig.zig").Guid.initString("beb94909-e451-438b-b5a7-d79e767b75d8");
pub const IID_IAppxFactory = &IID_IAppxFactory_Value;
pub const IAppxFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePackageWriter: fn(
            self: *const IAppxFactory,
            outputStream: ?*IStream,
            settings: ?*APPX_PACKAGE_SETTINGS,
            packageWriter: ?*?*IAppxPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePackageReader: fn(
            self: *const IAppxFactory,
            inputStream: ?*IStream,
            packageReader: ?*?*IAppxPackageReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateManifestReader: fn(
            self: *const IAppxFactory,
            inputStream: ?*IStream,
            manifestReader: ?*?*IAppxManifestReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBlockMapReader: fn(
            self: *const IAppxFactory,
            inputStream: ?*IStream,
            blockMapReader: ?*?*IAppxBlockMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateValidatedBlockMapReader: fn(
            self: *const IAppxFactory,
            blockMapStream: ?*IStream,
            signatureFileName: ?[*:0]const u16,
            blockMapReader: ?*?*IAppxBlockMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFactory_CreatePackageWriter(self: *const T, outputStream: ?*IStream, settings: ?*APPX_PACKAGE_SETTINGS, packageWriter: ?*?*IAppxPackageWriter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFactory.VTable, self.vtable).CreatePackageWriter(@ptrCast(*const IAppxFactory, self), outputStream, settings, packageWriter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFactory_CreatePackageReader(self: *const T, inputStream: ?*IStream, packageReader: ?*?*IAppxPackageReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFactory.VTable, self.vtable).CreatePackageReader(@ptrCast(*const IAppxFactory, self), inputStream, packageReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFactory_CreateManifestReader(self: *const T, inputStream: ?*IStream, manifestReader: ?*?*IAppxManifestReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFactory.VTable, self.vtable).CreateManifestReader(@ptrCast(*const IAppxFactory, self), inputStream, manifestReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFactory_CreateBlockMapReader(self: *const T, inputStream: ?*IStream, blockMapReader: ?*?*IAppxBlockMapReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFactory.VTable, self.vtable).CreateBlockMapReader(@ptrCast(*const IAppxFactory, self), inputStream, blockMapReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFactory_CreateValidatedBlockMapReader(self: *const T, blockMapStream: ?*IStream, signatureFileName: ?[*:0]const u16, blockMapReader: ?*?*IAppxBlockMapReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFactory.VTable, self.vtable).CreateValidatedBlockMapReader(@ptrCast(*const IAppxFactory, self), blockMapStream, signatureFileName, blockMapReader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxFactory2_Value = @import("../../zig.zig").Guid.initString("f1346df2-c282-4e22-b918-743a929a8d55");
pub const IID_IAppxFactory2 = &IID_IAppxFactory2_Value;
pub const IAppxFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContentGroupMapReader: fn(
            self: *const IAppxFactory2,
            inputStream: ?*IStream,
            contentGroupMapReader: ?*?*IAppxContentGroupMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSourceContentGroupMapReader: fn(
            self: *const IAppxFactory2,
            inputStream: ?*IStream,
            reader: ?*?*IAppxSourceContentGroupMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateContentGroupMapWriter: fn(
            self: *const IAppxFactory2,
            stream: ?*IStream,
            contentGroupMapWriter: ?*?*IAppxContentGroupMapWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFactory2_CreateContentGroupMapReader(self: *const T, inputStream: ?*IStream, contentGroupMapReader: ?*?*IAppxContentGroupMapReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFactory2.VTable, self.vtable).CreateContentGroupMapReader(@ptrCast(*const IAppxFactory2, self), inputStream, contentGroupMapReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFactory2_CreateSourceContentGroupMapReader(self: *const T, inputStream: ?*IStream, reader: ?*?*IAppxSourceContentGroupMapReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFactory2.VTable, self.vtable).CreateSourceContentGroupMapReader(@ptrCast(*const IAppxFactory2, self), inputStream, reader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFactory2_CreateContentGroupMapWriter(self: *const T, stream: ?*IStream, contentGroupMapWriter: ?*?*IAppxContentGroupMapWriter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFactory2.VTable, self.vtable).CreateContentGroupMapWriter(@ptrCast(*const IAppxFactory2, self), stream, contentGroupMapWriter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxPackageReader_Value = @import("../../zig.zig").Guid.initString("b5c49650-99bc-481c-9a34-3d53a4106708");
pub const IID_IAppxPackageReader = &IID_IAppxPackageReader_Value;
pub const IAppxPackageReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBlockMap: fn(
            self: *const IAppxPackageReader,
            blockMapReader: ?*?*IAppxBlockMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFootprintFile: fn(
            self: *const IAppxPackageReader,
            type: APPX_FOOTPRINT_FILE_TYPE,
            file: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadFile: fn(
            self: *const IAppxPackageReader,
            fileName: ?[*:0]const u16,
            file: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadFiles: fn(
            self: *const IAppxPackageReader,
            filesEnumerator: ?*?*IAppxFilesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManifest: fn(
            self: *const IAppxPackageReader,
            manifestReader: ?*?*IAppxManifestReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageReader_GetBlockMap(self: *const T, blockMapReader: ?*?*IAppxBlockMapReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageReader.VTable, self.vtable).GetBlockMap(@ptrCast(*const IAppxPackageReader, self), blockMapReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageReader_GetFootprintFile(self: *const T, type_: APPX_FOOTPRINT_FILE_TYPE, file: ?*?*IAppxFile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageReader.VTable, self.vtable).GetFootprintFile(@ptrCast(*const IAppxPackageReader, self), type_, file);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageReader_GetPayloadFile(self: *const T, fileName: ?[*:0]const u16, file: ?*?*IAppxFile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageReader.VTable, self.vtable).GetPayloadFile(@ptrCast(*const IAppxPackageReader, self), fileName, file);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageReader_GetPayloadFiles(self: *const T, filesEnumerator: ?*?*IAppxFilesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageReader.VTable, self.vtable).GetPayloadFiles(@ptrCast(*const IAppxPackageReader, self), filesEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageReader_GetManifest(self: *const T, manifestReader: ?*?*IAppxManifestReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageReader.VTable, self.vtable).GetManifest(@ptrCast(*const IAppxPackageReader, self), manifestReader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxPackageWriter_Value = @import("../../zig.zig").Guid.initString("9099e33b-246f-41e4-881a-008eb613f858");
pub const IID_IAppxPackageWriter = &IID_IAppxPackageWriter_Value;
pub const IAppxPackageWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadFile: fn(
            self: *const IAppxPackageWriter,
            fileName: ?[*:0]const u16,
            contentType: ?[*:0]const u16,
            compressionOption: APPX_COMPRESSION_OPTION,
            inputStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IAppxPackageWriter,
            manifest: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageWriter_AddPayloadFile(self: *const T, fileName: ?[*:0]const u16, contentType: ?[*:0]const u16, compressionOption: APPX_COMPRESSION_OPTION, inputStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageWriter.VTable, self.vtable).AddPayloadFile(@ptrCast(*const IAppxPackageWriter, self), fileName, contentType, compressionOption, inputStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageWriter_Close(self: *const T, manifest: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageWriter.VTable, self.vtable).Close(@ptrCast(*const IAppxPackageWriter, self), manifest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxPackageWriter2_Value = @import("../../zig.zig").Guid.initString("2cf5c4fd-e54c-4ea5-ba4e-f8c4b105a8c8");
pub const IID_IAppxPackageWriter2 = &IID_IAppxPackageWriter2_Value;
pub const IAppxPackageWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Close: fn(
            self: *const IAppxPackageWriter2,
            manifest: ?*IStream,
            contentGroupMap: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageWriter2_Close(self: *const T, manifest: ?*IStream, contentGroupMap: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageWriter2.VTable, self.vtable).Close(@ptrCast(*const IAppxPackageWriter2, self), manifest, contentGroupMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxPackageWriter3_Value = @import("../../zig.zig").Guid.initString("a83aacd3-41c0-4501-b8a3-74164f50b2fd");
pub const IID_IAppxPackageWriter3 = &IID_IAppxPackageWriter3_Value;
pub const IAppxPackageWriter3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadFiles: fn(
            self: *const IAppxPackageWriter3,
            fileCount: u32,
            payloadFiles: [*]APPX_PACKAGE_WRITER_PAYLOAD_STREAM,
            memoryLimit: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageWriter3_AddPayloadFiles(self: *const T, fileCount: u32, payloadFiles: [*]APPX_PACKAGE_WRITER_PAYLOAD_STREAM, memoryLimit: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageWriter3.VTable, self.vtable).AddPayloadFiles(@ptrCast(*const IAppxPackageWriter3, self), fileCount, payloadFiles, memoryLimit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxFile_Value = @import("../../zig.zig").Guid.initString("91df827b-94fd-468f-827b-57f41b2f6f2e");
pub const IID_IAppxFile = &IID_IAppxFile_Value;
pub const IAppxFile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCompressionOption: fn(
            self: *const IAppxFile,
            compressionOption: ?*APPX_COMPRESSION_OPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContentType: fn(
            self: *const IAppxFile,
            contentType: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IAppxFile,
            fileName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IAppxFile,
            size: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: fn(
            self: *const IAppxFile,
            stream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFile_GetCompressionOption(self: *const T, compressionOption: ?*APPX_COMPRESSION_OPTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFile.VTable, self.vtable).GetCompressionOption(@ptrCast(*const IAppxFile, self), compressionOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFile_GetContentType(self: *const T, contentType: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFile.VTable, self.vtable).GetContentType(@ptrCast(*const IAppxFile, self), contentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFile_GetName(self: *const T, fileName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFile.VTable, self.vtable).GetName(@ptrCast(*const IAppxFile, self), fileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFile_GetSize(self: *const T, size: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFile.VTable, self.vtable).GetSize(@ptrCast(*const IAppxFile, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFile_GetStream(self: *const T, stream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFile.VTable, self.vtable).GetStream(@ptrCast(*const IAppxFile, self), stream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxFilesEnumerator_Value = @import("../../zig.zig").Guid.initString("f007eeaf-9831-411c-9847-917cdc62d1fe");
pub const IID_IAppxFilesEnumerator = &IID_IAppxFilesEnumerator_Value;
pub const IAppxFilesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxFilesEnumerator,
            file: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxFilesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxFilesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFilesEnumerator_GetCurrent(self: *const T, file: ?*?*IAppxFile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFilesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxFilesEnumerator, self), file);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFilesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFilesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxFilesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxFilesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxFilesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxFilesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapReader_Value = @import("../../zig.zig").Guid.initString("5efec991-bca3-42d1-9ec2-e92d609ec22a");
pub const IID_IAppxBlockMapReader = &IID_IAppxBlockMapReader_Value;
pub const IAppxBlockMapReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFile: fn(
            self: *const IAppxBlockMapReader,
            filename: ?[*:0]const u16,
            file: ?*?*IAppxBlockMapFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFiles: fn(
            self: *const IAppxBlockMapReader,
            enumerator: ?*?*IAppxBlockMapFilesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashMethod: fn(
            self: *const IAppxBlockMapReader,
            hashMethod: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: fn(
            self: *const IAppxBlockMapReader,
            blockMapStream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapReader_GetFile(self: *const T, filename: ?[*:0]const u16, file: ?*?*IAppxBlockMapFile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapReader.VTable, self.vtable).GetFile(@ptrCast(*const IAppxBlockMapReader, self), filename, file);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapReader_GetFiles(self: *const T, enumerator: ?*?*IAppxBlockMapFilesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapReader.VTable, self.vtable).GetFiles(@ptrCast(*const IAppxBlockMapReader, self), enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapReader_GetHashMethod(self: *const T, hashMethod: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapReader.VTable, self.vtable).GetHashMethod(@ptrCast(*const IAppxBlockMapReader, self), hashMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapReader_GetStream(self: *const T, blockMapStream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapReader.VTable, self.vtable).GetStream(@ptrCast(*const IAppxBlockMapReader, self), blockMapStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapFile_Value = @import("../../zig.zig").Guid.initString("277672ac-4f63-42c1-8abc-beae3600eb59");
pub const IID_IAppxBlockMapFile = &IID_IAppxBlockMapFile_Value;
pub const IAppxBlockMapFile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBlocks: fn(
            self: *const IAppxBlockMapFile,
            blocks: ?*?*IAppxBlockMapBlocksEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalFileHeaderSize: fn(
            self: *const IAppxBlockMapFile,
            lfhSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IAppxBlockMapFile,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUncompressedSize: fn(
            self: *const IAppxBlockMapFile,
            size: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateFileHash: fn(
            self: *const IAppxBlockMapFile,
            fileStream: ?*IStream,
            isValid: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapFile_GetBlocks(self: *const T, blocks: ?*?*IAppxBlockMapBlocksEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapFile.VTable, self.vtable).GetBlocks(@ptrCast(*const IAppxBlockMapFile, self), blocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapFile_GetLocalFileHeaderSize(self: *const T, lfhSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapFile.VTable, self.vtable).GetLocalFileHeaderSize(@ptrCast(*const IAppxBlockMapFile, self), lfhSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapFile_GetName(self: *const T, name: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapFile.VTable, self.vtable).GetName(@ptrCast(*const IAppxBlockMapFile, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapFile_GetUncompressedSize(self: *const T, size: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapFile.VTable, self.vtable).GetUncompressedSize(@ptrCast(*const IAppxBlockMapFile, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapFile_ValidateFileHash(self: *const T, fileStream: ?*IStream, isValid: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapFile.VTable, self.vtable).ValidateFileHash(@ptrCast(*const IAppxBlockMapFile, self), fileStream, isValid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapFilesEnumerator_Value = @import("../../zig.zig").Guid.initString("02b856a2-4262-4070-bacb-1a8cbbc42305");
pub const IID_IAppxBlockMapFilesEnumerator = &IID_IAppxBlockMapFilesEnumerator_Value;
pub const IAppxBlockMapFilesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxBlockMapFilesEnumerator,
            file: ?*?*IAppxBlockMapFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxBlockMapFilesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxBlockMapFilesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapFilesEnumerator_GetCurrent(self: *const T, file: ?*?*IAppxBlockMapFile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapFilesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxBlockMapFilesEnumerator, self), file);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapFilesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapFilesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxBlockMapFilesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapFilesEnumerator_MoveNext(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapFilesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxBlockMapFilesEnumerator, self), hasCurrent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapBlock_Value = @import("../../zig.zig").Guid.initString("75cf3930-3244-4fe0-a8c8-e0bcb270b889");
pub const IID_IAppxBlockMapBlock = &IID_IAppxBlockMapBlock_Value;
pub const IAppxBlockMapBlock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHash: fn(
            self: *const IAppxBlockMapBlock,
            bufferSize: ?*u32,
            buffer: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompressedSize: fn(
            self: *const IAppxBlockMapBlock,
            size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapBlock_GetHash(self: *const T, bufferSize: ?*u32, buffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapBlock.VTable, self.vtable).GetHash(@ptrCast(*const IAppxBlockMapBlock, self), bufferSize, buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapBlock_GetCompressedSize(self: *const T, size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapBlock.VTable, self.vtable).GetCompressedSize(@ptrCast(*const IAppxBlockMapBlock, self), size);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxBlockMapBlocksEnumerator_Value = @import("../../zig.zig").Guid.initString("6b429b5b-36ef-479e-b9eb-0c1482b49e16");
pub const IID_IAppxBlockMapBlocksEnumerator = &IID_IAppxBlockMapBlocksEnumerator_Value;
pub const IAppxBlockMapBlocksEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxBlockMapBlocksEnumerator,
            block: ?*?*IAppxBlockMapBlock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxBlockMapBlocksEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxBlockMapBlocksEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapBlocksEnumerator_GetCurrent(self: *const T, block: ?*?*IAppxBlockMapBlock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapBlocksEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxBlockMapBlocksEnumerator, self), block);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapBlocksEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapBlocksEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxBlockMapBlocksEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBlockMapBlocksEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBlockMapBlocksEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxBlockMapBlocksEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestReader_Value = @import("../../zig.zig").Guid.initString("4e1bd148-55a0-4480-a3d1-15544710637c");
pub const IID_IAppxManifestReader = &IID_IAppxManifestReader_Value;
pub const IAppxManifestReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageId: fn(
            self: *const IAppxManifestReader,
            packageId: ?*?*IAppxManifestPackageId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const IAppxManifestReader,
            packageProperties: ?*?*IAppxManifestProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageDependencies: fn(
            self: *const IAppxManifestReader,
            dependencies: ?*?*IAppxManifestPackageDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCapabilities: fn(
            self: *const IAppxManifestReader,
            capabilities: ?*APPX_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResources: fn(
            self: *const IAppxManifestReader,
            resources: ?*?*IAppxManifestResourcesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceCapabilities: fn(
            self: *const IAppxManifestReader,
            deviceCapabilities: ?*?*IAppxManifestDeviceCapabilitiesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrerequisite: fn(
            self: *const IAppxManifestReader,
            name: ?[*:0]const u16,
            value: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplications: fn(
            self: *const IAppxManifestReader,
            applications: ?*?*IAppxManifestApplicationsEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: fn(
            self: *const IAppxManifestReader,
            manifestStream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader_GetPackageId(self: *const T, packageId: ?*?*IAppxManifestPackageId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader.VTable, self.vtable).GetPackageId(@ptrCast(*const IAppxManifestReader, self), packageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader_GetProperties(self: *const T, packageProperties: ?*?*IAppxManifestProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader.VTable, self.vtable).GetProperties(@ptrCast(*const IAppxManifestReader, self), packageProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader_GetPackageDependencies(self: *const T, dependencies: ?*?*IAppxManifestPackageDependenciesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader.VTable, self.vtable).GetPackageDependencies(@ptrCast(*const IAppxManifestReader, self), dependencies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader_GetCapabilities(self: *const T, capabilities: ?*APPX_CAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader.VTable, self.vtable).GetCapabilities(@ptrCast(*const IAppxManifestReader, self), capabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader_GetResources(self: *const T, resources: ?*?*IAppxManifestResourcesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader.VTable, self.vtable).GetResources(@ptrCast(*const IAppxManifestReader, self), resources);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader_GetDeviceCapabilities(self: *const T, deviceCapabilities: ?*?*IAppxManifestDeviceCapabilitiesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader.VTable, self.vtable).GetDeviceCapabilities(@ptrCast(*const IAppxManifestReader, self), deviceCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader_GetPrerequisite(self: *const T, name: ?[*:0]const u16, value: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader.VTable, self.vtable).GetPrerequisite(@ptrCast(*const IAppxManifestReader, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader_GetApplications(self: *const T, applications: ?*?*IAppxManifestApplicationsEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader.VTable, self.vtable).GetApplications(@ptrCast(*const IAppxManifestReader, self), applications);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader_GetStream(self: *const T, manifestStream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader.VTable, self.vtable).GetStream(@ptrCast(*const IAppxManifestReader, self), manifestStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxManifestReader2_Value = @import("../../zig.zig").Guid.initString("d06f67bc-b31d-4eba-a8af-638e73e77b4d");
pub const IID_IAppxManifestReader2 = &IID_IAppxManifestReader2_Value;
pub const IAppxManifestReader2 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestReader.VTable,
        GetQualifiedResources: fn(
            self: *const IAppxManifestReader2,
            resources: ?*?*IAppxManifestQualifiedResourcesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAppxManifestReader.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader2_GetQualifiedResources(self: *const T, resources: ?*?*IAppxManifestQualifiedResourcesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader2.VTable, self.vtable).GetQualifiedResources(@ptrCast(*const IAppxManifestReader2, self), resources);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestReader3_Value = @import("../../zig.zig").Guid.initString("c43825ab-69b7-400a-9709-cc37f5a72d24");
pub const IID_IAppxManifestReader3 = &IID_IAppxManifestReader3_Value;
pub const IAppxManifestReader3 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestReader2.VTable,
        GetCapabilitiesByCapabilityClass: fn(
            self: *const IAppxManifestReader3,
            capabilityClass: APPX_CAPABILITY_CLASS_TYPE,
            capabilities: ?*?*IAppxManifestCapabilitiesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetDeviceFamilies: fn(
            self: *const IAppxManifestReader3,
            targetDeviceFamilies: ?*?*IAppxManifestTargetDeviceFamiliesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAppxManifestReader2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader3_GetCapabilitiesByCapabilityClass(self: *const T, capabilityClass: APPX_CAPABILITY_CLASS_TYPE, capabilities: ?*?*IAppxManifestCapabilitiesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader3.VTable, self.vtable).GetCapabilitiesByCapabilityClass(@ptrCast(*const IAppxManifestReader3, self), capabilityClass, capabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader3_GetTargetDeviceFamilies(self: *const T, targetDeviceFamilies: ?*?*IAppxManifestTargetDeviceFamiliesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader3.VTable, self.vtable).GetTargetDeviceFamilies(@ptrCast(*const IAppxManifestReader3, self), targetDeviceFamilies);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestReader4_Value = @import("../../zig.zig").Guid.initString("4579bb7c-741d-4161-b5a1-47bd3b78ad9b");
pub const IID_IAppxManifestReader4 = &IID_IAppxManifestReader4_Value;
pub const IAppxManifestReader4 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestReader3.VTable,
        GetOptionalPackageInfo: fn(
            self: *const IAppxManifestReader4,
            optionalPackageInfo: ?*?*IAppxManifestOptionalPackageInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAppxManifestReader3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader4_GetOptionalPackageInfo(self: *const T, optionalPackageInfo: ?*?*IAppxManifestOptionalPackageInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader4.VTable, self.vtable).GetOptionalPackageInfo(@ptrCast(*const IAppxManifestReader4, self), optionalPackageInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestReader5_Value = @import("../../zig.zig").Guid.initString("8d7ae132-a690-4c00-b75a-6aae1feaac80");
pub const IID_IAppxManifestReader5 = &IID_IAppxManifestReader5_Value;
pub const IAppxManifestReader5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMainPackageDependencies: fn(
            self: *const IAppxManifestReader5,
            mainPackageDependencies: ?*?*IAppxManifestMainPackageDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader5_GetMainPackageDependencies(self: *const T, mainPackageDependencies: ?*?*IAppxManifestMainPackageDependenciesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader5.VTable, self.vtable).GetMainPackageDependencies(@ptrCast(*const IAppxManifestReader5, self), mainPackageDependencies);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestReader6_Value = @import("../../zig.zig").Guid.initString("34deaca4-d3c0-4e3e-b312-e42625e3807e");
pub const IID_IAppxManifestReader6 = &IID_IAppxManifestReader6_Value;
pub const IAppxManifestReader6 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsNonQualifiedResourcePackage: fn(
            self: *const IAppxManifestReader6,
            isNonQualifiedResourcePackage: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader6_GetIsNonQualifiedResourcePackage(self: *const T, isNonQualifiedResourcePackage: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader6.VTable, self.vtable).GetIsNonQualifiedResourcePackage(@ptrCast(*const IAppxManifestReader6, self), isNonQualifiedResourcePackage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestReader7_Value = @import("../../zig.zig").Guid.initString("8efe6f27-0ce0-4988-b32d-738eb63db3b7");
pub const IID_IAppxManifestReader7 = &IID_IAppxManifestReader7_Value;
pub const IAppxManifestReader7 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDriverDependencies: fn(
            self: *const IAppxManifestReader7,
            driverDependencies: ?*?*IAppxManifestDriverDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOSPackageDependencies: fn(
            self: *const IAppxManifestReader7,
            osPackageDependencies: ?*?*IAppxManifestOSPackageDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHostRuntimeDependencies: fn(
            self: *const IAppxManifestReader7,
            hostRuntimeDependencies: ?*?*IAppxManifestHostRuntimeDependenciesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader7_GetDriverDependencies(self: *const T, driverDependencies: ?*?*IAppxManifestDriverDependenciesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader7.VTable, self.vtable).GetDriverDependencies(@ptrCast(*const IAppxManifestReader7, self), driverDependencies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader7_GetOSPackageDependencies(self: *const T, osPackageDependencies: ?*?*IAppxManifestOSPackageDependenciesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader7.VTable, self.vtable).GetOSPackageDependencies(@ptrCast(*const IAppxManifestReader7, self), osPackageDependencies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestReader7_GetHostRuntimeDependencies(self: *const T, hostRuntimeDependencies: ?*?*IAppxManifestHostRuntimeDependenciesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestReader7.VTable, self.vtable).GetHostRuntimeDependencies(@ptrCast(*const IAppxManifestReader7, self), hostRuntimeDependencies);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestDriverDependenciesEnumerator_Value = @import("../../zig.zig").Guid.initString("fe039db2-467f-4755-8404-8f5eb6865b33");
pub const IID_IAppxManifestDriverDependenciesEnumerator = &IID_IAppxManifestDriverDependenciesEnumerator_Value;
pub const IAppxManifestDriverDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestDriverDependenciesEnumerator,
            driverDependency: ?*?*IAppxManifestDriverDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestDriverDependenciesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestDriverDependenciesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverDependenciesEnumerator_GetCurrent(self: *const T, driverDependency: ?*?*IAppxManifestDriverDependency) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverDependenciesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestDriverDependenciesEnumerator, self), driverDependency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverDependenciesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverDependenciesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestDriverDependenciesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverDependenciesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverDependenciesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestDriverDependenciesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestDriverDependency_Value = @import("../../zig.zig").Guid.initString("1210cb94-5a92-4602-be24-79f318af4af9");
pub const IID_IAppxManifestDriverDependency = &IID_IAppxManifestDriverDependency_Value;
pub const IAppxManifestDriverDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDriverConstraints: fn(
            self: *const IAppxManifestDriverDependency,
            driverConstraints: ?*?*IAppxManifestDriverConstraintsEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverDependency_GetDriverConstraints(self: *const T, driverConstraints: ?*?*IAppxManifestDriverConstraintsEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverDependency.VTable, self.vtable).GetDriverConstraints(@ptrCast(*const IAppxManifestDriverDependency, self), driverConstraints);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestDriverConstraintsEnumerator_Value = @import("../../zig.zig").Guid.initString("d402b2d1-f600-49e0-95e6-975d8da13d89");
pub const IID_IAppxManifestDriverConstraintsEnumerator = &IID_IAppxManifestDriverConstraintsEnumerator_Value;
pub const IAppxManifestDriverConstraintsEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestDriverConstraintsEnumerator,
            driverConstraint: ?*?*IAppxManifestDriverConstraint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestDriverConstraintsEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestDriverConstraintsEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverConstraintsEnumerator_GetCurrent(self: *const T, driverConstraint: ?*?*IAppxManifestDriverConstraint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverConstraintsEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestDriverConstraintsEnumerator, self), driverConstraint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverConstraintsEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverConstraintsEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestDriverConstraintsEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverConstraintsEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverConstraintsEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestDriverConstraintsEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestDriverConstraint_Value = @import("../../zig.zig").Guid.initString("c031bee4-bbcc-48ea-a237-c34045c80a07");
pub const IID_IAppxManifestDriverConstraint = &IID_IAppxManifestDriverConstraint_Value;
pub const IAppxManifestDriverConstraint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IAppxManifestDriverConstraint,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinVersion: fn(
            self: *const IAppxManifestDriverConstraint,
            minVersion: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinDate: fn(
            self: *const IAppxManifestDriverConstraint,
            minDate: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverConstraint_GetName(self: *const T, name: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverConstraint.VTable, self.vtable).GetName(@ptrCast(*const IAppxManifestDriverConstraint, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverConstraint_GetMinVersion(self: *const T, minVersion: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverConstraint.VTable, self.vtable).GetMinVersion(@ptrCast(*const IAppxManifestDriverConstraint, self), minVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDriverConstraint_GetMinDate(self: *const T, minDate: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDriverConstraint.VTable, self.vtable).GetMinDate(@ptrCast(*const IAppxManifestDriverConstraint, self), minDate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestOSPackageDependenciesEnumerator_Value = @import("../../zig.zig").Guid.initString("b84e2fc3-f8ec-4bc1-8ae2-156346f5ffea");
pub const IID_IAppxManifestOSPackageDependenciesEnumerator = &IID_IAppxManifestOSPackageDependenciesEnumerator_Value;
pub const IAppxManifestOSPackageDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestOSPackageDependenciesEnumerator,
            osPackageDependency: ?*?*IAppxManifestOSPackageDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestOSPackageDependenciesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestOSPackageDependenciesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestOSPackageDependenciesEnumerator_GetCurrent(self: *const T, osPackageDependency: ?*?*IAppxManifestOSPackageDependency) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestOSPackageDependenciesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestOSPackageDependenciesEnumerator, self), osPackageDependency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestOSPackageDependenciesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestOSPackageDependenciesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestOSPackageDependenciesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestOSPackageDependenciesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestOSPackageDependenciesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestOSPackageDependenciesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestOSPackageDependency_Value = @import("../../zig.zig").Guid.initString("154995ee-54a6-4f14-ac97-d8cf0519644b");
pub const IID_IAppxManifestOSPackageDependency = &IID_IAppxManifestOSPackageDependency_Value;
pub const IAppxManifestOSPackageDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IAppxManifestOSPackageDependency,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const IAppxManifestOSPackageDependency,
            version: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestOSPackageDependency_GetName(self: *const T, name: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestOSPackageDependency.VTable, self.vtable).GetName(@ptrCast(*const IAppxManifestOSPackageDependency, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestOSPackageDependency_GetVersion(self: *const T, version: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestOSPackageDependency.VTable, self.vtable).GetVersion(@ptrCast(*const IAppxManifestOSPackageDependency, self), version);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestHostRuntimeDependenciesEnumerator_Value = @import("../../zig.zig").Guid.initString("6427a646-7f49-433e-b1a6-0da309f6885a");
pub const IID_IAppxManifestHostRuntimeDependenciesEnumerator = &IID_IAppxManifestHostRuntimeDependenciesEnumerator_Value;
pub const IAppxManifestHostRuntimeDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestHostRuntimeDependenciesEnumerator,
            hostRuntimeDependency: ?*?*IAppxManifestHostRuntimeDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestHostRuntimeDependenciesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestHostRuntimeDependenciesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestHostRuntimeDependenciesEnumerator_GetCurrent(self: *const T, hostRuntimeDependency: ?*?*IAppxManifestHostRuntimeDependency) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestHostRuntimeDependenciesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestHostRuntimeDependenciesEnumerator, self), hostRuntimeDependency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestHostRuntimeDependenciesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestHostRuntimeDependenciesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestHostRuntimeDependenciesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestHostRuntimeDependenciesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestHostRuntimeDependenciesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestHostRuntimeDependenciesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestHostRuntimeDependency_Value = @import("../../zig.zig").Guid.initString("3455d234-8414-410d-95c7-7b35255b8391");
pub const IID_IAppxManifestHostRuntimeDependency = &IID_IAppxManifestHostRuntimeDependency_Value;
pub const IAppxManifestHostRuntimeDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IAppxManifestHostRuntimeDependency,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPublisher: fn(
            self: *const IAppxManifestHostRuntimeDependency,
            publisher: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinVersion: fn(
            self: *const IAppxManifestHostRuntimeDependency,
            minVersion: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestHostRuntimeDependency_GetName(self: *const T, name: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestHostRuntimeDependency.VTable, self.vtable).GetName(@ptrCast(*const IAppxManifestHostRuntimeDependency, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestHostRuntimeDependency_GetPublisher(self: *const T, publisher: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestHostRuntimeDependency.VTable, self.vtable).GetPublisher(@ptrCast(*const IAppxManifestHostRuntimeDependency, self), publisher);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestHostRuntimeDependency_GetMinVersion(self: *const T, minVersion: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestHostRuntimeDependency.VTable, self.vtable).GetMinVersion(@ptrCast(*const IAppxManifestHostRuntimeDependency, self), minVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestHostRuntimeDependency2_Value = @import("../../zig.zig").Guid.initString("c26f23a8-ee10-4ad6-b898-2b4d7aebfe6a");
pub const IID_IAppxManifestHostRuntimeDependency2 = &IID_IAppxManifestHostRuntimeDependency2_Value;
pub const IAppxManifestHostRuntimeDependency2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageFamilyName: fn(
            self: *const IAppxManifestHostRuntimeDependency2,
            packageFamilyName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestHostRuntimeDependency2_GetPackageFamilyName(self: *const T, packageFamilyName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestHostRuntimeDependency2.VTable, self.vtable).GetPackageFamilyName(@ptrCast(*const IAppxManifestHostRuntimeDependency2, self), packageFamilyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestOptionalPackageInfo_Value = @import("../../zig.zig").Guid.initString("2634847d-5b5d-4fe5-a243-002ff95edc7e");
pub const IID_IAppxManifestOptionalPackageInfo = &IID_IAppxManifestOptionalPackageInfo_Value;
pub const IAppxManifestOptionalPackageInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsOptionalPackage: fn(
            self: *const IAppxManifestOptionalPackageInfo,
            isOptionalPackage: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainPackageName: fn(
            self: *const IAppxManifestOptionalPackageInfo,
            mainPackageName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestOptionalPackageInfo_GetIsOptionalPackage(self: *const T, isOptionalPackage: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestOptionalPackageInfo.VTable, self.vtable).GetIsOptionalPackage(@ptrCast(*const IAppxManifestOptionalPackageInfo, self), isOptionalPackage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestOptionalPackageInfo_GetMainPackageName(self: *const T, mainPackageName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestOptionalPackageInfo.VTable, self.vtable).GetMainPackageName(@ptrCast(*const IAppxManifestOptionalPackageInfo, self), mainPackageName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestMainPackageDependenciesEnumerator_Value = @import("../../zig.zig").Guid.initString("a99c4f00-51d2-4f0f-ba46-7ed5255ebdff");
pub const IID_IAppxManifestMainPackageDependenciesEnumerator = &IID_IAppxManifestMainPackageDependenciesEnumerator_Value;
pub const IAppxManifestMainPackageDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestMainPackageDependenciesEnumerator,
            mainPackageDependency: ?*?*IAppxManifestMainPackageDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestMainPackageDependenciesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestMainPackageDependenciesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestMainPackageDependenciesEnumerator_GetCurrent(self: *const T, mainPackageDependency: ?*?*IAppxManifestMainPackageDependency) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestMainPackageDependenciesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestMainPackageDependenciesEnumerator, self), mainPackageDependency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestMainPackageDependenciesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestMainPackageDependenciesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestMainPackageDependenciesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestMainPackageDependenciesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestMainPackageDependenciesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestMainPackageDependenciesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestMainPackageDependency_Value = @import("../../zig.zig").Guid.initString("05d0611c-bc29-46d5-97e2-84b9c79bd8ae");
pub const IID_IAppxManifestMainPackageDependency = &IID_IAppxManifestMainPackageDependency_Value;
pub const IAppxManifestMainPackageDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IAppxManifestMainPackageDependency,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPublisher: fn(
            self: *const IAppxManifestMainPackageDependency,
            publisher: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageFamilyName: fn(
            self: *const IAppxManifestMainPackageDependency,
            packageFamilyName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestMainPackageDependency_GetName(self: *const T, name: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestMainPackageDependency.VTable, self.vtable).GetName(@ptrCast(*const IAppxManifestMainPackageDependency, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestMainPackageDependency_GetPublisher(self: *const T, publisher: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestMainPackageDependency.VTable, self.vtable).GetPublisher(@ptrCast(*const IAppxManifestMainPackageDependency, self), publisher);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestMainPackageDependency_GetPackageFamilyName(self: *const T, packageFamilyName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestMainPackageDependency.VTable, self.vtable).GetPackageFamilyName(@ptrCast(*const IAppxManifestMainPackageDependency, self), packageFamilyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestPackageId_Value = @import("../../zig.zig").Guid.initString("283ce2d7-7153-4a91-9649-7a0f7240945f");
pub const IID_IAppxManifestPackageId = &IID_IAppxManifestPackageId_Value;
pub const IAppxManifestPackageId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IAppxManifestPackageId,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetArchitecture: fn(
            self: *const IAppxManifestPackageId,
            architecture: ?*APPX_PACKAGE_ARCHITECTURE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPublisher: fn(
            self: *const IAppxManifestPackageId,
            publisher: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const IAppxManifestPackageId,
            packageVersion: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResourceId: fn(
            self: *const IAppxManifestPackageId,
            resourceId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComparePublisher: fn(
            self: *const IAppxManifestPackageId,
            other: ?[*:0]const u16,
            isSame: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageFullName: fn(
            self: *const IAppxManifestPackageId,
            packageFullName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageFamilyName: fn(
            self: *const IAppxManifestPackageId,
            packageFamilyName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageId_GetName(self: *const T, name: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageId.VTable, self.vtable).GetName(@ptrCast(*const IAppxManifestPackageId, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageId_GetArchitecture(self: *const T, architecture: ?*APPX_PACKAGE_ARCHITECTURE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageId.VTable, self.vtable).GetArchitecture(@ptrCast(*const IAppxManifestPackageId, self), architecture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageId_GetPublisher(self: *const T, publisher: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageId.VTable, self.vtable).GetPublisher(@ptrCast(*const IAppxManifestPackageId, self), publisher);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageId_GetVersion(self: *const T, packageVersion: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageId.VTable, self.vtable).GetVersion(@ptrCast(*const IAppxManifestPackageId, self), packageVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageId_GetResourceId(self: *const T, resourceId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageId.VTable, self.vtable).GetResourceId(@ptrCast(*const IAppxManifestPackageId, self), resourceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageId_ComparePublisher(self: *const T, other: ?[*:0]const u16, isSame: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageId.VTable, self.vtable).ComparePublisher(@ptrCast(*const IAppxManifestPackageId, self), other, isSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageId_GetPackageFullName(self: *const T, packageFullName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageId.VTable, self.vtable).GetPackageFullName(@ptrCast(*const IAppxManifestPackageId, self), packageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageId_GetPackageFamilyName(self: *const T, packageFamilyName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageId.VTable, self.vtable).GetPackageFamilyName(@ptrCast(*const IAppxManifestPackageId, self), packageFamilyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestPackageId2_Value = @import("../../zig.zig").Guid.initString("2256999d-d617-42f1-880e-0ba4542319d5");
pub const IID_IAppxManifestPackageId2 = &IID_IAppxManifestPackageId2_Value;
pub const IAppxManifestPackageId2 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestPackageId.VTable,
        GetArchitecture2: fn(
            self: *const IAppxManifestPackageId2,
            architecture: ?*APPX_PACKAGE_ARCHITECTURE2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAppxManifestPackageId.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageId2_GetArchitecture2(self: *const T, architecture: ?*APPX_PACKAGE_ARCHITECTURE2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageId2.VTable, self.vtable).GetArchitecture2(@ptrCast(*const IAppxManifestPackageId2, self), architecture);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestProperties_Value = @import("../../zig.zig").Guid.initString("03faf64d-f26f-4b2c-aaf7-8fe7789b8bca");
pub const IID_IAppxManifestProperties = &IID_IAppxManifestProperties_Value;
pub const IAppxManifestProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBoolValue: fn(
            self: *const IAppxManifestProperties,
            name: ?[*:0]const u16,
            value: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringValue: fn(
            self: *const IAppxManifestProperties,
            name: ?[*:0]const u16,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestProperties_GetBoolValue(self: *const T, name: ?[*:0]const u16, value: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestProperties.VTable, self.vtable).GetBoolValue(@ptrCast(*const IAppxManifestProperties, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestProperties_GetStringValue(self: *const T, name: ?[*:0]const u16, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestProperties.VTable, self.vtable).GetStringValue(@ptrCast(*const IAppxManifestProperties, self), name, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestTargetDeviceFamiliesEnumerator_Value = @import("../../zig.zig").Guid.initString("36537f36-27a4-4788-88c0-733819575017");
pub const IID_IAppxManifestTargetDeviceFamiliesEnumerator = &IID_IAppxManifestTargetDeviceFamiliesEnumerator_Value;
pub const IAppxManifestTargetDeviceFamiliesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestTargetDeviceFamiliesEnumerator,
            targetDeviceFamily: ?*?*IAppxManifestTargetDeviceFamily,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestTargetDeviceFamiliesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestTargetDeviceFamiliesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestTargetDeviceFamiliesEnumerator_GetCurrent(self: *const T, targetDeviceFamily: ?*?*IAppxManifestTargetDeviceFamily) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestTargetDeviceFamiliesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestTargetDeviceFamiliesEnumerator, self), targetDeviceFamily);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestTargetDeviceFamiliesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestTargetDeviceFamiliesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestTargetDeviceFamiliesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestTargetDeviceFamiliesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestTargetDeviceFamiliesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestTargetDeviceFamiliesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxManifestTargetDeviceFamily_Value = @import("../../zig.zig").Guid.initString("9091b09b-c8d5-4f31-8687-a338259faefb");
pub const IID_IAppxManifestTargetDeviceFamily = &IID_IAppxManifestTargetDeviceFamily_Value;
pub const IAppxManifestTargetDeviceFamily = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IAppxManifestTargetDeviceFamily,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinVersion: fn(
            self: *const IAppxManifestTargetDeviceFamily,
            minVersion: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxVersionTested: fn(
            self: *const IAppxManifestTargetDeviceFamily,
            maxVersionTested: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestTargetDeviceFamily_GetName(self: *const T, name: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestTargetDeviceFamily.VTable, self.vtable).GetName(@ptrCast(*const IAppxManifestTargetDeviceFamily, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestTargetDeviceFamily_GetMinVersion(self: *const T, minVersion: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestTargetDeviceFamily.VTable, self.vtable).GetMinVersion(@ptrCast(*const IAppxManifestTargetDeviceFamily, self), minVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestTargetDeviceFamily_GetMaxVersionTested(self: *const T, maxVersionTested: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestTargetDeviceFamily.VTable, self.vtable).GetMaxVersionTested(@ptrCast(*const IAppxManifestTargetDeviceFamily, self), maxVersionTested);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestPackageDependenciesEnumerator_Value = @import("../../zig.zig").Guid.initString("b43bbcf9-65a6-42dd-bac0-8c6741e7f5a4");
pub const IID_IAppxManifestPackageDependenciesEnumerator = &IID_IAppxManifestPackageDependenciesEnumerator_Value;
pub const IAppxManifestPackageDependenciesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestPackageDependenciesEnumerator,
            dependency: ?*?*IAppxManifestPackageDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestPackageDependenciesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestPackageDependenciesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageDependenciesEnumerator_GetCurrent(self: *const T, dependency: ?*?*IAppxManifestPackageDependency) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageDependenciesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestPackageDependenciesEnumerator, self), dependency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageDependenciesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageDependenciesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestPackageDependenciesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageDependenciesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageDependenciesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestPackageDependenciesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestPackageDependency_Value = @import("../../zig.zig").Guid.initString("e4946b59-733e-43f0-a724-3bde4c1285a0");
pub const IID_IAppxManifestPackageDependency = &IID_IAppxManifestPackageDependency_Value;
pub const IAppxManifestPackageDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IAppxManifestPackageDependency,
            name: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPublisher: fn(
            self: *const IAppxManifestPackageDependency,
            publisher: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinVersion: fn(
            self: *const IAppxManifestPackageDependency,
            minVersion: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageDependency_GetName(self: *const T, name: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageDependency.VTable, self.vtable).GetName(@ptrCast(*const IAppxManifestPackageDependency, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageDependency_GetPublisher(self: *const T, publisher: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageDependency.VTable, self.vtable).GetPublisher(@ptrCast(*const IAppxManifestPackageDependency, self), publisher);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageDependency_GetMinVersion(self: *const T, minVersion: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageDependency.VTable, self.vtable).GetMinVersion(@ptrCast(*const IAppxManifestPackageDependency, self), minVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestPackageDependency2_Value = @import("../../zig.zig").Guid.initString("dda0b713-f3ff-49d3-898a-2786780c5d98");
pub const IID_IAppxManifestPackageDependency2 = &IID_IAppxManifestPackageDependency2_Value;
pub const IAppxManifestPackageDependency2 = extern struct {
    pub const VTable = extern struct {
        base: IAppxManifestPackageDependency.VTable,
        GetMaxMajorVersionTested: fn(
            self: *const IAppxManifestPackageDependency2,
            maxMajorVersionTested: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAppxManifestPackageDependency.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageDependency2_GetMaxMajorVersionTested(self: *const T, maxMajorVersionTested: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageDependency2.VTable, self.vtable).GetMaxMajorVersionTested(@ptrCast(*const IAppxManifestPackageDependency2, self), maxMajorVersionTested);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestPackageDependency3_Value = @import("../../zig.zig").Guid.initString("1ac56374-6198-4d6b-92e4-749d5ab8a895");
pub const IID_IAppxManifestPackageDependency3 = &IID_IAppxManifestPackageDependency3_Value;
pub const IAppxManifestPackageDependency3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsOptional: fn(
            self: *const IAppxManifestPackageDependency3,
            isOptional: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestPackageDependency3_GetIsOptional(self: *const T, isOptional: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestPackageDependency3.VTable, self.vtable).GetIsOptional(@ptrCast(*const IAppxManifestPackageDependency3, self), isOptional);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestResourcesEnumerator_Value = @import("../../zig.zig").Guid.initString("de4dfbbd-881a-48bb-858c-d6f2baeae6ed");
pub const IID_IAppxManifestResourcesEnumerator = &IID_IAppxManifestResourcesEnumerator_Value;
pub const IAppxManifestResourcesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestResourcesEnumerator,
            resource: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestResourcesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestResourcesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestResourcesEnumerator_GetCurrent(self: *const T, resource: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestResourcesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestResourcesEnumerator, self), resource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestResourcesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestResourcesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestResourcesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestResourcesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestResourcesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestResourcesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestDeviceCapabilitiesEnumerator_Value = @import("../../zig.zig").Guid.initString("30204541-427b-4a1c-bacf-655bf463a540");
pub const IID_IAppxManifestDeviceCapabilitiesEnumerator = &IID_IAppxManifestDeviceCapabilitiesEnumerator_Value;
pub const IAppxManifestDeviceCapabilitiesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestDeviceCapabilitiesEnumerator,
            deviceCapability: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestDeviceCapabilitiesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestDeviceCapabilitiesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDeviceCapabilitiesEnumerator_GetCurrent(self: *const T, deviceCapability: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDeviceCapabilitiesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestDeviceCapabilitiesEnumerator, self), deviceCapability);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDeviceCapabilitiesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDeviceCapabilitiesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestDeviceCapabilitiesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestDeviceCapabilitiesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestDeviceCapabilitiesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestDeviceCapabilitiesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestCapabilitiesEnumerator_Value = @import("../../zig.zig").Guid.initString("11d22258-f470-42c1-b291-8361c5437e41");
pub const IID_IAppxManifestCapabilitiesEnumerator = &IID_IAppxManifestCapabilitiesEnumerator_Value;
pub const IAppxManifestCapabilitiesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestCapabilitiesEnumerator,
            capability: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestCapabilitiesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestCapabilitiesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestCapabilitiesEnumerator_GetCurrent(self: *const T, capability: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestCapabilitiesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestCapabilitiesEnumerator, self), capability);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestCapabilitiesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestCapabilitiesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestCapabilitiesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestCapabilitiesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestCapabilitiesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestCapabilitiesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestApplicationsEnumerator_Value = @import("../../zig.zig").Guid.initString("9eb8a55a-f04b-4d0d-808d-686185d4847a");
pub const IID_IAppxManifestApplicationsEnumerator = &IID_IAppxManifestApplicationsEnumerator_Value;
pub const IAppxManifestApplicationsEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestApplicationsEnumerator,
            application: ?*?*IAppxManifestApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestApplicationsEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestApplicationsEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestApplicationsEnumerator_GetCurrent(self: *const T, application: ?*?*IAppxManifestApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestApplicationsEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestApplicationsEnumerator, self), application);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestApplicationsEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestApplicationsEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestApplicationsEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestApplicationsEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestApplicationsEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestApplicationsEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppxManifestApplication_Value = @import("../../zig.zig").Guid.initString("5da89bf4-3773-46be-b650-7e744863b7e8");
pub const IID_IAppxManifestApplication = &IID_IAppxManifestApplication_Value;
pub const IAppxManifestApplication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringValue: fn(
            self: *const IAppxManifestApplication,
            name: ?[*:0]const u16,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppUserModelId: fn(
            self: *const IAppxManifestApplication,
            appUserModelId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestApplication_GetStringValue(self: *const T, name: ?[*:0]const u16, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestApplication.VTable, self.vtable).GetStringValue(@ptrCast(*const IAppxManifestApplication, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestApplication_GetAppUserModelId(self: *const T, appUserModelId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestApplication.VTable, self.vtable).GetAppUserModelId(@ptrCast(*const IAppxManifestApplication, self), appUserModelId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestQualifiedResourcesEnumerator_Value = @import("../../zig.zig").Guid.initString("8ef6adfe-3762-4a8f-9373-2fc5d444c8d2");
pub const IID_IAppxManifestQualifiedResourcesEnumerator = &IID_IAppxManifestQualifiedResourcesEnumerator_Value;
pub const IAppxManifestQualifiedResourcesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxManifestQualifiedResourcesEnumerator,
            resource: ?*?*IAppxManifestQualifiedResource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxManifestQualifiedResourcesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxManifestQualifiedResourcesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestQualifiedResourcesEnumerator_GetCurrent(self: *const T, resource: ?*?*IAppxManifestQualifiedResource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestQualifiedResourcesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxManifestQualifiedResourcesEnumerator, self), resource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestQualifiedResourcesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestQualifiedResourcesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxManifestQualifiedResourcesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestQualifiedResourcesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestQualifiedResourcesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxManifestQualifiedResourcesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxManifestQualifiedResource_Value = @import("../../zig.zig").Guid.initString("3b53a497-3c5c-48d1-9ea3-bb7eac8cd7d4");
pub const IID_IAppxManifestQualifiedResource = &IID_IAppxManifestQualifiedResource_Value;
pub const IAppxManifestQualifiedResource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLanguage: fn(
            self: *const IAppxManifestQualifiedResource,
            language: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScale: fn(
            self: *const IAppxManifestQualifiedResource,
            scale: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDXFeatureLevel: fn(
            self: *const IAppxManifestQualifiedResource,
            dxFeatureLevel: ?*DX_FEATURE_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestQualifiedResource_GetLanguage(self: *const T, language: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestQualifiedResource.VTable, self.vtable).GetLanguage(@ptrCast(*const IAppxManifestQualifiedResource, self), language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestQualifiedResource_GetScale(self: *const T, scale: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestQualifiedResource.VTable, self.vtable).GetScale(@ptrCast(*const IAppxManifestQualifiedResource, self), scale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxManifestQualifiedResource_GetDXFeatureLevel(self: *const T, dxFeatureLevel: ?*DX_FEATURE_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxManifestQualifiedResource.VTable, self.vtable).GetDXFeatureLevel(@ptrCast(*const IAppxManifestQualifiedResource, self), dxFeatureLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleFactory_Value = @import("../../zig.zig").Guid.initString("bba65864-965f-4a5f-855f-f074bdbf3a7b");
pub const IID_IAppxBundleFactory = &IID_IAppxBundleFactory_Value;
pub const IAppxBundleFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateBundleWriter: fn(
            self: *const IAppxBundleFactory,
            outputStream: ?*IStream,
            bundleVersion: u64,
            bundleWriter: ?*?*IAppxBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBundleReader: fn(
            self: *const IAppxBundleFactory,
            inputStream: ?*IStream,
            bundleReader: ?*?*IAppxBundleReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBundleManifestReader: fn(
            self: *const IAppxBundleFactory,
            inputStream: ?*IStream,
            manifestReader: ?*?*IAppxBundleManifestReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleFactory_CreateBundleWriter(self: *const T, outputStream: ?*IStream, bundleVersion: u64, bundleWriter: ?*?*IAppxBundleWriter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleFactory.VTable, self.vtable).CreateBundleWriter(@ptrCast(*const IAppxBundleFactory, self), outputStream, bundleVersion, bundleWriter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleFactory_CreateBundleReader(self: *const T, inputStream: ?*IStream, bundleReader: ?*?*IAppxBundleReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleFactory.VTable, self.vtable).CreateBundleReader(@ptrCast(*const IAppxBundleFactory, self), inputStream, bundleReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleFactory_CreateBundleManifestReader(self: *const T, inputStream: ?*IStream, manifestReader: ?*?*IAppxBundleManifestReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleFactory.VTable, self.vtable).CreateBundleManifestReader(@ptrCast(*const IAppxBundleFactory, self), inputStream, manifestReader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleWriter_Value = @import("../../zig.zig").Guid.initString("ec446fe8-bfec-4c64-ab4f-49f038f0c6d2");
pub const IID_IAppxBundleWriter = &IID_IAppxBundleWriter_Value;
pub const IAppxBundleWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadPackage: fn(
            self: *const IAppxBundleWriter,
            fileName: ?[*:0]const u16,
            packageStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IAppxBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleWriter_AddPayloadPackage(self: *const T, fileName: ?[*:0]const u16, packageStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleWriter.VTable, self.vtable).AddPayloadPackage(@ptrCast(*const IAppxBundleWriter, self), fileName, packageStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleWriter_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleWriter.VTable, self.vtable).Close(@ptrCast(*const IAppxBundleWriter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleWriter2_Value = @import("../../zig.zig").Guid.initString("6d8fe971-01cc-49a0-b685-233851279962");
pub const IID_IAppxBundleWriter2 = &IID_IAppxBundleWriter2_Value;
pub const IAppxBundleWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddExternalPackageReference: fn(
            self: *const IAppxBundleWriter2,
            fileName: ?[*:0]const u16,
            inputStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleWriter2_AddExternalPackageReference(self: *const T, fileName: ?[*:0]const u16, inputStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleWriter2.VTable, self.vtable).AddExternalPackageReference(@ptrCast(*const IAppxBundleWriter2, self), fileName, inputStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleWriter3_Value = @import("../../zig.zig").Guid.initString("ad711152-f969-4193-82d5-9ddf2786d21a");
pub const IID_IAppxBundleWriter3 = &IID_IAppxBundleWriter3_Value;
pub const IAppxBundleWriter3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPackageReference: fn(
            self: *const IAppxBundleWriter3,
            fileName: ?[*:0]const u16,
            inputStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IAppxBundleWriter3,
            hashMethodString: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleWriter3_AddPackageReference(self: *const T, fileName: ?[*:0]const u16, inputStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleWriter3.VTable, self.vtable).AddPackageReference(@ptrCast(*const IAppxBundleWriter3, self), fileName, inputStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleWriter3_Close(self: *const T, hashMethodString: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleWriter3.VTable, self.vtable).Close(@ptrCast(*const IAppxBundleWriter3, self), hashMethodString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleWriter4_Value = @import("../../zig.zig").Guid.initString("9cd9d523-5009-4c01-9882-dc029fbd47a3");
pub const IID_IAppxBundleWriter4 = &IID_IAppxBundleWriter4_Value;
pub const IAppxBundleWriter4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadPackage: fn(
            self: *const IAppxBundleWriter4,
            fileName: ?[*:0]const u16,
            packageStream: ?*IStream,
            isDefaultApplicablePackage: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPackageReference: fn(
            self: *const IAppxBundleWriter4,
            fileName: ?[*:0]const u16,
            inputStream: ?*IStream,
            isDefaultApplicablePackage: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExternalPackageReference: fn(
            self: *const IAppxBundleWriter4,
            fileName: ?[*:0]const u16,
            inputStream: ?*IStream,
            isDefaultApplicablePackage: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleWriter4_AddPayloadPackage(self: *const T, fileName: ?[*:0]const u16, packageStream: ?*IStream, isDefaultApplicablePackage: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleWriter4.VTable, self.vtable).AddPayloadPackage(@ptrCast(*const IAppxBundleWriter4, self), fileName, packageStream, isDefaultApplicablePackage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleWriter4_AddPackageReference(self: *const T, fileName: ?[*:0]const u16, inputStream: ?*IStream, isDefaultApplicablePackage: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleWriter4.VTable, self.vtable).AddPackageReference(@ptrCast(*const IAppxBundleWriter4, self), fileName, inputStream, isDefaultApplicablePackage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleWriter4_AddExternalPackageReference(self: *const T, fileName: ?[*:0]const u16, inputStream: ?*IStream, isDefaultApplicablePackage: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleWriter4.VTable, self.vtable).AddExternalPackageReference(@ptrCast(*const IAppxBundleWriter4, self), fileName, inputStream, isDefaultApplicablePackage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleReader_Value = @import("../../zig.zig").Guid.initString("dd75b8c0-ba76-43b0-ae0f-68656a1dc5c8");
pub const IID_IAppxBundleReader = &IID_IAppxBundleReader_Value;
pub const IAppxBundleReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFootprintFile: fn(
            self: *const IAppxBundleReader,
            fileType: APPX_BUNDLE_FOOTPRINT_FILE_TYPE,
            footprintFile: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBlockMap: fn(
            self: *const IAppxBundleReader,
            blockMapReader: ?*?*IAppxBlockMapReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManifest: fn(
            self: *const IAppxBundleReader,
            manifestReader: ?*?*IAppxBundleManifestReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadPackages: fn(
            self: *const IAppxBundleReader,
            payloadPackages: ?*?*IAppxFilesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadPackage: fn(
            self: *const IAppxBundleReader,
            fileName: ?[*:0]const u16,
            payloadPackage: ?*?*IAppxFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleReader_GetFootprintFile(self: *const T, fileType: APPX_BUNDLE_FOOTPRINT_FILE_TYPE, footprintFile: ?*?*IAppxFile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleReader.VTable, self.vtable).GetFootprintFile(@ptrCast(*const IAppxBundleReader, self), fileType, footprintFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleReader_GetBlockMap(self: *const T, blockMapReader: ?*?*IAppxBlockMapReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleReader.VTable, self.vtable).GetBlockMap(@ptrCast(*const IAppxBundleReader, self), blockMapReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleReader_GetManifest(self: *const T, manifestReader: ?*?*IAppxBundleManifestReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleReader.VTable, self.vtable).GetManifest(@ptrCast(*const IAppxBundleReader, self), manifestReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleReader_GetPayloadPackages(self: *const T, payloadPackages: ?*?*IAppxFilesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleReader.VTable, self.vtable).GetPayloadPackages(@ptrCast(*const IAppxBundleReader, self), payloadPackages);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleReader_GetPayloadPackage(self: *const T, fileName: ?[*:0]const u16, payloadPackage: ?*?*IAppxFile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleReader.VTable, self.vtable).GetPayloadPackage(@ptrCast(*const IAppxBundleReader, self), fileName, payloadPackage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleManifestReader_Value = @import("../../zig.zig").Guid.initString("cf0ebbc1-cc99-4106-91eb-e67462e04fb0");
pub const IID_IAppxBundleManifestReader = &IID_IAppxBundleManifestReader_Value;
pub const IAppxBundleManifestReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageId: fn(
            self: *const IAppxBundleManifestReader,
            packageId: ?*?*IAppxManifestPackageId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageInfoItems: fn(
            self: *const IAppxBundleManifestReader,
            packageInfoItems: ?*?*IAppxBundleManifestPackageInfoEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: fn(
            self: *const IAppxBundleManifestReader,
            manifestStream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestReader_GetPackageId(self: *const T, packageId: ?*?*IAppxManifestPackageId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestReader.VTable, self.vtable).GetPackageId(@ptrCast(*const IAppxBundleManifestReader, self), packageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestReader_GetPackageInfoItems(self: *const T, packageInfoItems: ?*?*IAppxBundleManifestPackageInfoEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestReader.VTable, self.vtable).GetPackageInfoItems(@ptrCast(*const IAppxBundleManifestReader, self), packageInfoItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestReader_GetStream(self: *const T, manifestStream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestReader.VTable, self.vtable).GetStream(@ptrCast(*const IAppxBundleManifestReader, self), manifestStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleManifestReader2_Value = @import("../../zig.zig").Guid.initString("5517df70-033f-4af2-8213-87d766805c02");
pub const IID_IAppxBundleManifestReader2 = &IID_IAppxBundleManifestReader2_Value;
pub const IAppxBundleManifestReader2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOptionalBundles: fn(
            self: *const IAppxBundleManifestReader2,
            optionalBundles: ?*?*IAppxBundleManifestOptionalBundleInfoEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestReader2_GetOptionalBundles(self: *const T, optionalBundles: ?*?*IAppxBundleManifestOptionalBundleInfoEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestReader2.VTable, self.vtable).GetOptionalBundles(@ptrCast(*const IAppxBundleManifestReader2, self), optionalBundles);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleManifestPackageInfoEnumerator_Value = @import("../../zig.zig").Guid.initString("f9b856ee-49a6-4e19-b2b0-6a2406d63a32");
pub const IID_IAppxBundleManifestPackageInfoEnumerator = &IID_IAppxBundleManifestPackageInfoEnumerator_Value;
pub const IAppxBundleManifestPackageInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxBundleManifestPackageInfoEnumerator,
            packageInfo: ?*?*IAppxBundleManifestPackageInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxBundleManifestPackageInfoEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxBundleManifestPackageInfoEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfoEnumerator_GetCurrent(self: *const T, packageInfo: ?*?*IAppxBundleManifestPackageInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfoEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxBundleManifestPackageInfoEnumerator, self), packageInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfoEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfoEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxBundleManifestPackageInfoEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfoEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfoEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxBundleManifestPackageInfoEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IAppxBundleManifestPackageInfo_Value = @import("../../zig.zig").Guid.initString("54cd06c1-268f-40bb-8ed2-757a9ebaec8d");
pub const IID_IAppxBundleManifestPackageInfo = &IID_IAppxBundleManifestPackageInfo_Value;
pub const IAppxBundleManifestPackageInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageType: fn(
            self: *const IAppxBundleManifestPackageInfo,
            packageType: ?*APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageId: fn(
            self: *const IAppxBundleManifestPackageInfo,
            packageId: ?*?*IAppxManifestPackageId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: fn(
            self: *const IAppxBundleManifestPackageInfo,
            fileName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffset: fn(
            self: *const IAppxBundleManifestPackageInfo,
            offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IAppxBundleManifestPackageInfo,
            size: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResources: fn(
            self: *const IAppxBundleManifestPackageInfo,
            resources: ?*?*IAppxManifestQualifiedResourcesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo_GetPackageType(self: *const T, packageType: ?*APPX_BUNDLE_PAYLOAD_PACKAGE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo.VTable, self.vtable).GetPackageType(@ptrCast(*const IAppxBundleManifestPackageInfo, self), packageType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo_GetPackageId(self: *const T, packageId: ?*?*IAppxManifestPackageId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo.VTable, self.vtable).GetPackageId(@ptrCast(*const IAppxBundleManifestPackageInfo, self), packageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo_GetFileName(self: *const T, fileName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo.VTable, self.vtable).GetFileName(@ptrCast(*const IAppxBundleManifestPackageInfo, self), fileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo_GetOffset(self: *const T, offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo.VTable, self.vtable).GetOffset(@ptrCast(*const IAppxBundleManifestPackageInfo, self), offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo_GetSize(self: *const T, size: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo.VTable, self.vtable).GetSize(@ptrCast(*const IAppxBundleManifestPackageInfo, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo_GetResources(self: *const T, resources: ?*?*IAppxManifestQualifiedResourcesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo.VTable, self.vtable).GetResources(@ptrCast(*const IAppxBundleManifestPackageInfo, self), resources);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleManifestPackageInfo2_Value = @import("../../zig.zig").Guid.initString("44c2acbc-b2cf-4ccb-bbdb-9c6da8c3bc9e");
pub const IID_IAppxBundleManifestPackageInfo2 = &IID_IAppxBundleManifestPackageInfo2_Value;
pub const IAppxBundleManifestPackageInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsPackageReference: fn(
            self: *const IAppxBundleManifestPackageInfo2,
            isPackageReference: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIsNonQualifiedResourcePackage: fn(
            self: *const IAppxBundleManifestPackageInfo2,
            isNonQualifiedResourcePackage: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIsDefaultApplicablePackage: fn(
            self: *const IAppxBundleManifestPackageInfo2,
            isDefaultApplicablePackage: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo2_GetIsPackageReference(self: *const T, isPackageReference: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo2.VTable, self.vtable).GetIsPackageReference(@ptrCast(*const IAppxBundleManifestPackageInfo2, self), isPackageReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo2_GetIsNonQualifiedResourcePackage(self: *const T, isNonQualifiedResourcePackage: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo2.VTable, self.vtable).GetIsNonQualifiedResourcePackage(@ptrCast(*const IAppxBundleManifestPackageInfo2, self), isNonQualifiedResourcePackage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo2_GetIsDefaultApplicablePackage(self: *const T, isDefaultApplicablePackage: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo2.VTable, self.vtable).GetIsDefaultApplicablePackage(@ptrCast(*const IAppxBundleManifestPackageInfo2, self), isDefaultApplicablePackage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxBundleManifestPackageInfo3_Value = @import("../../zig.zig").Guid.initString("6ba74b98-bb74-4296-80d0-5f4256a99675");
pub const IID_IAppxBundleManifestPackageInfo3 = &IID_IAppxBundleManifestPackageInfo3_Value;
pub const IAppxBundleManifestPackageInfo3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTargetDeviceFamilies: fn(
            self: *const IAppxBundleManifestPackageInfo3,
            targetDeviceFamilies: ?*?*IAppxManifestTargetDeviceFamiliesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo3_GetTargetDeviceFamilies(self: *const T, targetDeviceFamilies: ?*?*IAppxManifestTargetDeviceFamiliesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo3.VTable, self.vtable).GetTargetDeviceFamilies(@ptrCast(*const IAppxBundleManifestPackageInfo3, self), targetDeviceFamilies);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxBundleManifestPackageInfo4_Value = @import("../../zig.zig").Guid.initString("5da6f13d-a8a7-4532-857c-1393d659371d");
pub const IID_IAppxBundleManifestPackageInfo4 = &IID_IAppxBundleManifestPackageInfo4_Value;
pub const IAppxBundleManifestPackageInfo4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIsStub: fn(
            self: *const IAppxBundleManifestPackageInfo4,
            isStub: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestPackageInfo4_GetIsStub(self: *const T, isStub: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestPackageInfo4.VTable, self.vtable).GetIsStub(@ptrCast(*const IAppxBundleManifestPackageInfo4, self), isStub);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleManifestOptionalBundleInfoEnumerator_Value = @import("../../zig.zig").Guid.initString("9a178793-f97e-46ac-aaca-dd5ba4c177c8");
pub const IID_IAppxBundleManifestOptionalBundleInfoEnumerator = &IID_IAppxBundleManifestOptionalBundleInfoEnumerator_Value;
pub const IAppxBundleManifestOptionalBundleInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxBundleManifestOptionalBundleInfoEnumerator,
            optionalBundle: ?*?*IAppxBundleManifestOptionalBundleInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxBundleManifestOptionalBundleInfoEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxBundleManifestOptionalBundleInfoEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestOptionalBundleInfoEnumerator_GetCurrent(self: *const T, optionalBundle: ?*?*IAppxBundleManifestOptionalBundleInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestOptionalBundleInfoEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxBundleManifestOptionalBundleInfoEnumerator, self), optionalBundle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestOptionalBundleInfoEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestOptionalBundleInfoEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxBundleManifestOptionalBundleInfoEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestOptionalBundleInfoEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestOptionalBundleInfoEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxBundleManifestOptionalBundleInfoEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxBundleManifestOptionalBundleInfo_Value = @import("../../zig.zig").Guid.initString("515bf2e8-bcb0-4d69-8c48-e383147b6e12");
pub const IID_IAppxBundleManifestOptionalBundleInfo = &IID_IAppxBundleManifestOptionalBundleInfo_Value;
pub const IAppxBundleManifestOptionalBundleInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPackageId: fn(
            self: *const IAppxBundleManifestOptionalBundleInfo,
            packageId: ?*?*IAppxManifestPackageId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: fn(
            self: *const IAppxBundleManifestOptionalBundleInfo,
            fileName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageInfoItems: fn(
            self: *const IAppxBundleManifestOptionalBundleInfo,
            packageInfoItems: ?*?*IAppxBundleManifestPackageInfoEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestOptionalBundleInfo_GetPackageId(self: *const T, packageId: ?*?*IAppxManifestPackageId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestOptionalBundleInfo.VTable, self.vtable).GetPackageId(@ptrCast(*const IAppxBundleManifestOptionalBundleInfo, self), packageId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestOptionalBundleInfo_GetFileName(self: *const T, fileName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestOptionalBundleInfo.VTable, self.vtable).GetFileName(@ptrCast(*const IAppxBundleManifestOptionalBundleInfo, self), fileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxBundleManifestOptionalBundleInfo_GetPackageInfoItems(self: *const T, packageInfoItems: ?*?*IAppxBundleManifestPackageInfoEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxBundleManifestOptionalBundleInfo.VTable, self.vtable).GetPackageInfoItems(@ptrCast(*const IAppxBundleManifestOptionalBundleInfo, self), packageInfoItems);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroupFilesEnumerator_Value = @import("../../zig.zig").Guid.initString("1a09a2fd-7440-44eb-8c84-848205a6a1cc");
pub const IID_IAppxContentGroupFilesEnumerator = &IID_IAppxContentGroupFilesEnumerator_Value;
pub const IAppxContentGroupFilesEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxContentGroupFilesEnumerator,
            file: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxContentGroupFilesEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxContentGroupFilesEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupFilesEnumerator_GetCurrent(self: *const T, file: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupFilesEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxContentGroupFilesEnumerator, self), file);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupFilesEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupFilesEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxContentGroupFilesEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupFilesEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupFilesEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxContentGroupFilesEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroup_Value = @import("../../zig.zig").Guid.initString("328f6468-c04f-4e3c-b6fa-6b8d27f3003a");
pub const IID_IAppxContentGroup = &IID_IAppxContentGroup_Value;
pub const IAppxContentGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IAppxContentGroup,
            groupName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFiles: fn(
            self: *const IAppxContentGroup,
            enumerator: ?*?*IAppxContentGroupFilesEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroup_GetName(self: *const T, groupName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroup.VTable, self.vtable).GetName(@ptrCast(*const IAppxContentGroup, self), groupName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroup_GetFiles(self: *const T, enumerator: ?*?*IAppxContentGroupFilesEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroup.VTable, self.vtable).GetFiles(@ptrCast(*const IAppxContentGroup, self), enumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroupsEnumerator_Value = @import("../../zig.zig").Guid.initString("3264e477-16d1-4d63-823e-7d2984696634");
pub const IID_IAppxContentGroupsEnumerator = &IID_IAppxContentGroupsEnumerator_Value;
pub const IAppxContentGroupsEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrent: fn(
            self: *const IAppxContentGroupsEnumerator,
            stream: ?*?*IAppxContentGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHasCurrent: fn(
            self: *const IAppxContentGroupsEnumerator,
            hasCurrent: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveNext: fn(
            self: *const IAppxContentGroupsEnumerator,
            hasNext: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupsEnumerator_GetCurrent(self: *const T, stream: ?*?*IAppxContentGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupsEnumerator.VTable, self.vtable).GetCurrent(@ptrCast(*const IAppxContentGroupsEnumerator, self), stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupsEnumerator_GetHasCurrent(self: *const T, hasCurrent: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupsEnumerator.VTable, self.vtable).GetHasCurrent(@ptrCast(*const IAppxContentGroupsEnumerator, self), hasCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupsEnumerator_MoveNext(self: *const T, hasNext: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupsEnumerator.VTable, self.vtable).MoveNext(@ptrCast(*const IAppxContentGroupsEnumerator, self), hasNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroupMapReader_Value = @import("../../zig.zig").Guid.initString("418726d8-dd99-4f5d-9886-157add20de01");
pub const IID_IAppxContentGroupMapReader = &IID_IAppxContentGroupMapReader_Value;
pub const IAppxContentGroupMapReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRequiredGroup: fn(
            self: *const IAppxContentGroupMapReader,
            requiredGroup: ?*?*IAppxContentGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutomaticGroups: fn(
            self: *const IAppxContentGroupMapReader,
            automaticGroupsEnumerator: ?*?*IAppxContentGroupsEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupMapReader_GetRequiredGroup(self: *const T, requiredGroup: ?*?*IAppxContentGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupMapReader.VTable, self.vtable).GetRequiredGroup(@ptrCast(*const IAppxContentGroupMapReader, self), requiredGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupMapReader_GetAutomaticGroups(self: *const T, automaticGroupsEnumerator: ?*?*IAppxContentGroupsEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupMapReader.VTable, self.vtable).GetAutomaticGroups(@ptrCast(*const IAppxContentGroupMapReader, self), automaticGroupsEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxSourceContentGroupMapReader_Value = @import("../../zig.zig").Guid.initString("f329791d-540b-4a9f-bc75-3282b7d73193");
pub const IID_IAppxSourceContentGroupMapReader = &IID_IAppxSourceContentGroupMapReader_Value;
pub const IAppxSourceContentGroupMapReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRequiredGroup: fn(
            self: *const IAppxSourceContentGroupMapReader,
            requiredGroup: ?*?*IAppxContentGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutomaticGroups: fn(
            self: *const IAppxSourceContentGroupMapReader,
            automaticGroupsEnumerator: ?*?*IAppxContentGroupsEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxSourceContentGroupMapReader_GetRequiredGroup(self: *const T, requiredGroup: ?*?*IAppxContentGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxSourceContentGroupMapReader.VTable, self.vtable).GetRequiredGroup(@ptrCast(*const IAppxSourceContentGroupMapReader, self), requiredGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxSourceContentGroupMapReader_GetAutomaticGroups(self: *const T, automaticGroupsEnumerator: ?*?*IAppxContentGroupsEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxSourceContentGroupMapReader.VTable, self.vtable).GetAutomaticGroups(@ptrCast(*const IAppxSourceContentGroupMapReader, self), automaticGroupsEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxContentGroupMapWriter_Value = @import("../../zig.zig").Guid.initString("d07ab776-a9de-4798-8c14-3db31e687c78");
pub const IID_IAppxContentGroupMapWriter = &IID_IAppxContentGroupMapWriter_Value;
pub const IAppxContentGroupMapWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddAutomaticGroup: fn(
            self: *const IAppxContentGroupMapWriter,
            groupName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAutomaticFile: fn(
            self: *const IAppxContentGroupMapWriter,
            fileName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IAppxContentGroupMapWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupMapWriter_AddAutomaticGroup(self: *const T, groupName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupMapWriter.VTable, self.vtable).AddAutomaticGroup(@ptrCast(*const IAppxContentGroupMapWriter, self), groupName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupMapWriter_AddAutomaticFile(self: *const T, fileName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupMapWriter.VTable, self.vtable).AddAutomaticFile(@ptrCast(*const IAppxContentGroupMapWriter, self), fileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxContentGroupMapWriter_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxContentGroupMapWriter.VTable, self.vtable).Close(@ptrCast(*const IAppxContentGroupMapWriter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxPackagingDiagnosticEventSink_Value = @import("../../zig.zig").Guid.initString("17239d47-6adb-45d2-80f6-f9cbc3bf059d");
pub const IID_IAppxPackagingDiagnosticEventSink = &IID_IAppxPackagingDiagnosticEventSink_Value;
pub const IAppxPackagingDiagnosticEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportContextChange: fn(
            self: *const IAppxPackagingDiagnosticEventSink,
            changeType: APPX_PACKAGING_CONTEXT_CHANGE_TYPE,
            contextId: i32,
            contextName: ?[*:0]const u8,
            contextMessage: ?[*:0]const u16,
            detailsMessage: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportError: fn(
            self: *const IAppxPackagingDiagnosticEventSink,
            errorMessage: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackagingDiagnosticEventSink_ReportContextChange(self: *const T, changeType: APPX_PACKAGING_CONTEXT_CHANGE_TYPE, contextId: i32, contextName: ?[*:0]const u8, contextMessage: ?[*:0]const u16, detailsMessage: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackagingDiagnosticEventSink.VTable, self.vtable).ReportContextChange(@ptrCast(*const IAppxPackagingDiagnosticEventSink, self), changeType, contextId, contextName, contextMessage, detailsMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackagingDiagnosticEventSink_ReportError(self: *const T, errorMessage: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackagingDiagnosticEventSink.VTable, self.vtable).ReportError(@ptrCast(*const IAppxPackagingDiagnosticEventSink, self), errorMessage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppxPackagingDiagnosticEventSinkManager_Value = @import("../../zig.zig").Guid.initString("369648fa-a7eb-4909-a15d-6954a078f18a");
pub const IID_IAppxPackagingDiagnosticEventSinkManager = &IID_IAppxPackagingDiagnosticEventSinkManager_Value;
pub const IAppxPackagingDiagnosticEventSinkManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSinkForProcess: fn(
            self: *const IAppxPackagingDiagnosticEventSinkManager,
            sink: ?*IAppxPackagingDiagnosticEventSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackagingDiagnosticEventSinkManager_SetSinkForProcess(self: *const T, sink: ?*IAppxPackagingDiagnosticEventSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackagingDiagnosticEventSinkManager.VTable, self.vtable).SetSinkForProcess(@ptrCast(*const IAppxPackagingDiagnosticEventSinkManager, self), sink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APPX_ENCRYPTED_PACKAGE_SETTINGS = extern struct {
    keyLength: u32,
    encryptionAlgorithm: ?[*:0]const u16,
    useDiffusion: BOOL,
    blockMapHashAlgorithm: ?*IUri,
};

pub const APPX_ENCRYPTED_PACKAGE_OPTIONS = enum(u32) {
    NONE = 0,
    DIFFUSION = 1,
    PAGE_HASHING = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        DIFFUSION: u1 = 0,
        PAGE_HASHING: u1 = 0,
    }) APPX_ENCRYPTED_PACKAGE_OPTIONS {
        return @intToEnum(APPX_ENCRYPTED_PACKAGE_OPTIONS,
              (if (o.NONE == 1) @enumToInt(APPX_ENCRYPTED_PACKAGE_OPTIONS.NONE) else 0)
            | (if (o.DIFFUSION == 1) @enumToInt(APPX_ENCRYPTED_PACKAGE_OPTIONS.DIFFUSION) else 0)
            | (if (o.PAGE_HASHING == 1) @enumToInt(APPX_ENCRYPTED_PACKAGE_OPTIONS.PAGE_HASHING) else 0)
        );
    }
};
pub const APPX_ENCRYPTED_PACKAGE_OPTION_NONE = APPX_ENCRYPTED_PACKAGE_OPTIONS.NONE;
pub const APPX_ENCRYPTED_PACKAGE_OPTION_DIFFUSION = APPX_ENCRYPTED_PACKAGE_OPTIONS.DIFFUSION;
pub const APPX_ENCRYPTED_PACKAGE_OPTION_PAGE_HASHING = APPX_ENCRYPTED_PACKAGE_OPTIONS.PAGE_HASHING;

pub const APPX_ENCRYPTED_PACKAGE_SETTINGS2 = extern struct {
    keyLength: u32,
    encryptionAlgorithm: ?[*:0]const u16,
    blockMapHashAlgorithm: ?*IUri,
    options: u32,
};

pub const APPX_KEY_INFO = extern struct {
    keyLength: u32,
    keyIdLength: u32,
    key: ?*u8,
    keyId: ?*u8,
};

pub const APPX_ENCRYPTED_EXEMPTIONS = extern struct {
    count: u32,
    plainTextFiles: ?*?PWSTR,
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IAppxEncryptionFactory_Value = @import("../../zig.zig").Guid.initString("80e8e04d-8c88-44ae-a011-7cadf6fb2e72");
pub const IID_IAppxEncryptionFactory = &IID_IAppxEncryptionFactory_Value;
pub const IAppxEncryptionFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncryptPackage: fn(
            self: *const IAppxEncryptionFactory,
            inputStream: ?*IStream,
            outputStream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecryptPackage: fn(
            self: *const IAppxEncryptionFactory,
            inputStream: ?*IStream,
            outputStream: ?*IStream,
            keyInfo: ?*const APPX_KEY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedPackageWriter: fn(
            self: *const IAppxEncryptionFactory,
            outputStream: ?*IStream,
            manifestStream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            packageWriter: ?*?*IAppxEncryptedPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedPackageReader: fn(
            self: *const IAppxEncryptionFactory,
            inputStream: ?*IStream,
            keyInfo: ?*const APPX_KEY_INFO,
            packageReader: ?*?*IAppxPackageReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncryptBundle: fn(
            self: *const IAppxEncryptionFactory,
            inputStream: ?*IStream,
            outputStream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecryptBundle: fn(
            self: *const IAppxEncryptionFactory,
            inputStream: ?*IStream,
            outputStream: ?*IStream,
            keyInfo: ?*const APPX_KEY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedBundleWriter: fn(
            self: *const IAppxEncryptionFactory,
            outputStream: ?*IStream,
            bundleVersion: u64,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            bundleWriter: ?*?*IAppxEncryptedBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedBundleReader: fn(
            self: *const IAppxEncryptionFactory,
            inputStream: ?*IStream,
            keyInfo: ?*const APPX_KEY_INFO,
            bundleReader: ?*?*IAppxBundleReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory_EncryptPackage(self: *const T, inputStream: ?*IStream, outputStream: ?*IStream, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory.VTable, self.vtable).EncryptPackage(@ptrCast(*const IAppxEncryptionFactory, self), inputStream, outputStream, settings, keyInfo, exemptedFiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory_DecryptPackage(self: *const T, inputStream: ?*IStream, outputStream: ?*IStream, keyInfo: ?*const APPX_KEY_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory.VTable, self.vtable).DecryptPackage(@ptrCast(*const IAppxEncryptionFactory, self), inputStream, outputStream, keyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory_CreateEncryptedPackageWriter(self: *const T, outputStream: ?*IStream, manifestStream: ?*IStream, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS, packageWriter: ?*?*IAppxEncryptedPackageWriter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory.VTable, self.vtable).CreateEncryptedPackageWriter(@ptrCast(*const IAppxEncryptionFactory, self), outputStream, manifestStream, settings, keyInfo, exemptedFiles, packageWriter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory_CreateEncryptedPackageReader(self: *const T, inputStream: ?*IStream, keyInfo: ?*const APPX_KEY_INFO, packageReader: ?*?*IAppxPackageReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory.VTable, self.vtable).CreateEncryptedPackageReader(@ptrCast(*const IAppxEncryptionFactory, self), inputStream, keyInfo, packageReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory_EncryptBundle(self: *const T, inputStream: ?*IStream, outputStream: ?*IStream, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory.VTable, self.vtable).EncryptBundle(@ptrCast(*const IAppxEncryptionFactory, self), inputStream, outputStream, settings, keyInfo, exemptedFiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory_DecryptBundle(self: *const T, inputStream: ?*IStream, outputStream: ?*IStream, keyInfo: ?*const APPX_KEY_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory.VTable, self.vtable).DecryptBundle(@ptrCast(*const IAppxEncryptionFactory, self), inputStream, outputStream, keyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory_CreateEncryptedBundleWriter(self: *const T, outputStream: ?*IStream, bundleVersion: u64, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS, bundleWriter: ?*?*IAppxEncryptedBundleWriter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory.VTable, self.vtable).CreateEncryptedBundleWriter(@ptrCast(*const IAppxEncryptionFactory, self), outputStream, bundleVersion, settings, keyInfo, exemptedFiles, bundleWriter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory_CreateEncryptedBundleReader(self: *const T, inputStream: ?*IStream, keyInfo: ?*const APPX_KEY_INFO, bundleReader: ?*?*IAppxBundleReader) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory.VTable, self.vtable).CreateEncryptedBundleReader(@ptrCast(*const IAppxEncryptionFactory, self), inputStream, keyInfo, bundleReader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptionFactory2_Value = @import("../../zig.zig").Guid.initString("c1b11eee-c4ba-4ab2-a55d-d015fe8ff64f");
pub const IID_IAppxEncryptionFactory2 = &IID_IAppxEncryptionFactory2_Value;
pub const IAppxEncryptionFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateEncryptedPackageWriter: fn(
            self: *const IAppxEncryptionFactory2,
            outputStream: ?*IStream,
            manifestStream: ?*IStream,
            contentGroupMapStream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            packageWriter: ?*?*IAppxEncryptedPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory2_CreateEncryptedPackageWriter(self: *const T, outputStream: ?*IStream, manifestStream: ?*IStream, contentGroupMapStream: ?*IStream, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS, packageWriter: ?*?*IAppxEncryptedPackageWriter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory2.VTable, self.vtable).CreateEncryptedPackageWriter(@ptrCast(*const IAppxEncryptionFactory2, self), outputStream, manifestStream, contentGroupMapStream, settings, keyInfo, exemptedFiles, packageWriter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptionFactory3_Value = @import("../../zig.zig").Guid.initString("09edca37-cd64-47d6-b7e8-1cb11d4f7e05");
pub const IID_IAppxEncryptionFactory3 = &IID_IAppxEncryptionFactory3_Value;
pub const IAppxEncryptionFactory3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncryptPackage: fn(
            self: *const IAppxEncryptionFactory3,
            inputStream: ?*IStream,
            outputStream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedPackageWriter: fn(
            self: *const IAppxEncryptionFactory3,
            outputStream: ?*IStream,
            manifestStream: ?*IStream,
            contentGroupMapStream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            packageWriter: ?*?*IAppxEncryptedPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncryptBundle: fn(
            self: *const IAppxEncryptionFactory3,
            inputStream: ?*IStream,
            outputStream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEncryptedBundleWriter: fn(
            self: *const IAppxEncryptionFactory3,
            outputStream: ?*IStream,
            bundleVersion: u64,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            bundleWriter: ?*?*IAppxEncryptedBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory3_EncryptPackage(self: *const T, inputStream: ?*IStream, outputStream: ?*IStream, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory3.VTable, self.vtable).EncryptPackage(@ptrCast(*const IAppxEncryptionFactory3, self), inputStream, outputStream, settings, keyInfo, exemptedFiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory3_CreateEncryptedPackageWriter(self: *const T, outputStream: ?*IStream, manifestStream: ?*IStream, contentGroupMapStream: ?*IStream, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS, packageWriter: ?*?*IAppxEncryptedPackageWriter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory3.VTable, self.vtable).CreateEncryptedPackageWriter(@ptrCast(*const IAppxEncryptionFactory3, self), outputStream, manifestStream, contentGroupMapStream, settings, keyInfo, exemptedFiles, packageWriter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory3_EncryptBundle(self: *const T, inputStream: ?*IStream, outputStream: ?*IStream, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory3.VTable, self.vtable).EncryptBundle(@ptrCast(*const IAppxEncryptionFactory3, self), inputStream, outputStream, settings, keyInfo, exemptedFiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory3_CreateEncryptedBundleWriter(self: *const T, outputStream: ?*IStream, bundleVersion: u64, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS, bundleWriter: ?*?*IAppxEncryptedBundleWriter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory3.VTable, self.vtable).CreateEncryptedBundleWriter(@ptrCast(*const IAppxEncryptionFactory3, self), outputStream, bundleVersion, settings, keyInfo, exemptedFiles, bundleWriter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptionFactory4_Value = @import("../../zig.zig").Guid.initString("a879611f-12fd-41fe-85d5-06ae779bbaf5");
pub const IID_IAppxEncryptionFactory4 = &IID_IAppxEncryptionFactory4_Value;
pub const IAppxEncryptionFactory4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncryptPackage: fn(
            self: *const IAppxEncryptionFactory4,
            inputStream: ?*IStream,
            outputStream: ?*IStream,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            keyInfo: ?*const APPX_KEY_INFO,
            exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS,
            memoryLimit: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptionFactory4_EncryptPackage(self: *const T, inputStream: ?*IStream, outputStream: ?*IStream, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, keyInfo: ?*const APPX_KEY_INFO, exemptedFiles: ?*const APPX_ENCRYPTED_EXEMPTIONS, memoryLimit: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptionFactory4.VTable, self.vtable).EncryptPackage(@ptrCast(*const IAppxEncryptionFactory4, self), inputStream, outputStream, settings, keyInfo, exemptedFiles, memoryLimit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IAppxEncryptedPackageWriter_Value = @import("../../zig.zig").Guid.initString("f43d0b0b-1379-40e2-9b29-682ea2bf42af");
pub const IID_IAppxEncryptedPackageWriter = &IID_IAppxEncryptedPackageWriter_Value;
pub const IAppxEncryptedPackageWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadFileEncrypted: fn(
            self: *const IAppxEncryptedPackageWriter,
            fileName: ?[*:0]const u16,
            compressionOption: APPX_COMPRESSION_OPTION,
            inputStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IAppxEncryptedPackageWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptedPackageWriter_AddPayloadFileEncrypted(self: *const T, fileName: ?[*:0]const u16, compressionOption: APPX_COMPRESSION_OPTION, inputStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptedPackageWriter.VTable, self.vtable).AddPayloadFileEncrypted(@ptrCast(*const IAppxEncryptedPackageWriter, self), fileName, compressionOption, inputStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptedPackageWriter_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptedPackageWriter.VTable, self.vtable).Close(@ptrCast(*const IAppxEncryptedPackageWriter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IAppxEncryptedPackageWriter2_Value = @import("../../zig.zig").Guid.initString("3e475447-3a25-40b5-8ad2-f953ae50c92d");
pub const IID_IAppxEncryptedPackageWriter2 = &IID_IAppxEncryptedPackageWriter2_Value;
pub const IAppxEncryptedPackageWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadFilesEncrypted: fn(
            self: *const IAppxEncryptedPackageWriter2,
            fileCount: u32,
            payloadFiles: [*]APPX_PACKAGE_WRITER_PAYLOAD_STREAM,
            memoryLimit: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptedPackageWriter2_AddPayloadFilesEncrypted(self: *const T, fileCount: u32, payloadFiles: [*]APPX_PACKAGE_WRITER_PAYLOAD_STREAM, memoryLimit: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptedPackageWriter2.VTable, self.vtable).AddPayloadFilesEncrypted(@ptrCast(*const IAppxEncryptedPackageWriter2, self), fileCount, payloadFiles, memoryLimit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IAppxEncryptedBundleWriter_Value = @import("../../zig.zig").Guid.initString("80b0902f-7bf0-4117-b8c6-4279ef81ee77");
pub const IID_IAppxEncryptedBundleWriter = &IID_IAppxEncryptedBundleWriter_Value;
pub const IAppxEncryptedBundleWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadPackageEncrypted: fn(
            self: *const IAppxEncryptedBundleWriter,
            fileName: ?[*:0]const u16,
            packageStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IAppxEncryptedBundleWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptedBundleWriter_AddPayloadPackageEncrypted(self: *const T, fileName: ?[*:0]const u16, packageStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptedBundleWriter.VTable, self.vtable).AddPayloadPackageEncrypted(@ptrCast(*const IAppxEncryptedBundleWriter, self), fileName, packageStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptedBundleWriter_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptedBundleWriter.VTable, self.vtable).Close(@ptrCast(*const IAppxEncryptedBundleWriter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptedBundleWriter2_Value = @import("../../zig.zig").Guid.initString("e644be82-f0fa-42b8-a956-8d1cb48ee379");
pub const IID_IAppxEncryptedBundleWriter2 = &IID_IAppxEncryptedBundleWriter2_Value;
pub const IAppxEncryptedBundleWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddExternalPackageReference: fn(
            self: *const IAppxEncryptedBundleWriter2,
            fileName: ?[*:0]const u16,
            inputStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptedBundleWriter2_AddExternalPackageReference(self: *const T, fileName: ?[*:0]const u16, inputStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptedBundleWriter2.VTable, self.vtable).AddExternalPackageReference(@ptrCast(*const IAppxEncryptedBundleWriter2, self), fileName, inputStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION = enum(i32) {
    A = 0,
};
pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION_APPEND_DELTA = APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION.A;

pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS = enum(u32) {
    NONE = 0,
    SKIP_VALIDATION = 1,
    LOCALIZED = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        SKIP_VALIDATION: u1 = 0,
        LOCALIZED: u1 = 0,
    }) APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS {
        return @intToEnum(APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS,
              (if (o.NONE == 1) @enumToInt(APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.NONE) else 0)
            | (if (o.SKIP_VALIDATION == 1) @enumToInt(APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.SKIP_VALIDATION) else 0)
            | (if (o.LOCALIZED == 1) @enumToInt(APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.LOCALIZED) else 0)
        );
    }
};
pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTION_NONE = APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.NONE;
pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTION_SKIP_VALIDATION = APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.SKIP_VALIDATION;
pub const APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTION_LOCALIZED = APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS.LOCALIZED;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxEncryptedBundleWriter3_Value = @import("../../zig.zig").Guid.initString("0d34deb3-5cae-4dd3-977c-504932a51d31");
pub const IID_IAppxEncryptedBundleWriter3 = &IID_IAppxEncryptedBundleWriter3_Value;
pub const IAppxEncryptedBundleWriter3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPayloadPackageEncrypted: fn(
            self: *const IAppxEncryptedBundleWriter3,
            fileName: ?[*:0]const u16,
            packageStream: ?*IStream,
            isDefaultApplicablePackage: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExternalPackageReference: fn(
            self: *const IAppxEncryptedBundleWriter3,
            fileName: ?[*:0]const u16,
            inputStream: ?*IStream,
            isDefaultApplicablePackage: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptedBundleWriter3_AddPayloadPackageEncrypted(self: *const T, fileName: ?[*:0]const u16, packageStream: ?*IStream, isDefaultApplicablePackage: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptedBundleWriter3.VTable, self.vtable).AddPayloadPackageEncrypted(@ptrCast(*const IAppxEncryptedBundleWriter3, self), fileName, packageStream, isDefaultApplicablePackage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxEncryptedBundleWriter3_AddExternalPackageReference(self: *const T, fileName: ?[*:0]const u16, inputStream: ?*IStream, isDefaultApplicablePackage: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxEncryptedBundleWriter3.VTable, self.vtable).AddExternalPackageReference(@ptrCast(*const IAppxEncryptedBundleWriter3, self), fileName, inputStream, isDefaultApplicablePackage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAppxPackageEditor_Value = @import("../../zig.zig").Guid.initString("e2adb6dc-5e71-4416-86b6-86e5f5291a6b");
pub const IID_IAppxPackageEditor = &IID_IAppxPackageEditor_Value;
pub const IAppxPackageEditor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetWorkingDirectory: fn(
            self: *const IAppxPackageEditor,
            workingDirectory: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDeltaPackage: fn(
            self: *const IAppxPackageEditor,
            updatedPackageStream: ?*IStream,
            baselinePackageStream: ?*IStream,
            deltaPackageStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDeltaPackageUsingBaselineBlockMap: fn(
            self: *const IAppxPackageEditor,
            updatedPackageStream: ?*IStream,
            baselineBlockMapStream: ?*IStream,
            baselinePackageFullName: ?[*:0]const u16,
            deltaPackageStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdatePackage: fn(
            self: *const IAppxPackageEditor,
            baselinePackageStream: ?*IStream,
            deltaPackageStream: ?*IStream,
            updateOption: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateEncryptedPackage: fn(
            self: *const IAppxPackageEditor,
            baselineEncryptedPackageStream: ?*IStream,
            deltaPackageStream: ?*IStream,
            updateOption: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION,
            settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2,
            keyInfo: ?*const APPX_KEY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdatePackageManifest: fn(
            self: *const IAppxPackageEditor,
            packageStream: ?*IStream,
            updatedManifestStream: ?*IStream,
            isPackageEncrypted: BOOL,
            options: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageEditor_SetWorkingDirectory(self: *const T, workingDirectory: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageEditor.VTable, self.vtable).SetWorkingDirectory(@ptrCast(*const IAppxPackageEditor, self), workingDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageEditor_CreateDeltaPackage(self: *const T, updatedPackageStream: ?*IStream, baselinePackageStream: ?*IStream, deltaPackageStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageEditor.VTable, self.vtable).CreateDeltaPackage(@ptrCast(*const IAppxPackageEditor, self), updatedPackageStream, baselinePackageStream, deltaPackageStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageEditor_CreateDeltaPackageUsingBaselineBlockMap(self: *const T, updatedPackageStream: ?*IStream, baselineBlockMapStream: ?*IStream, baselinePackageFullName: ?[*:0]const u16, deltaPackageStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageEditor.VTable, self.vtable).CreateDeltaPackageUsingBaselineBlockMap(@ptrCast(*const IAppxPackageEditor, self), updatedPackageStream, baselineBlockMapStream, baselinePackageFullName, deltaPackageStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageEditor_UpdatePackage(self: *const T, baselinePackageStream: ?*IStream, deltaPackageStream: ?*IStream, updateOption: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageEditor.VTable, self.vtable).UpdatePackage(@ptrCast(*const IAppxPackageEditor, self), baselinePackageStream, deltaPackageStream, updateOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageEditor_UpdateEncryptedPackage(self: *const T, baselineEncryptedPackageStream: ?*IStream, deltaPackageStream: ?*IStream, updateOption: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_OPTION, settings: ?*const APPX_ENCRYPTED_PACKAGE_SETTINGS2, keyInfo: ?*const APPX_KEY_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageEditor.VTable, self.vtable).UpdateEncryptedPackage(@ptrCast(*const IAppxPackageEditor, self), baselineEncryptedPackageStream, deltaPackageStream, updateOption, settings, keyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppxPackageEditor_UpdatePackageManifest(self: *const T, packageStream: ?*IStream, updatedManifestStream: ?*IStream, isPackageEncrypted: BOOL, options: APPX_PACKAGE_EDITOR_UPDATE_PACKAGE_MANIFEST_OPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppxPackageEditor.VTable, self.vtable).UpdatePackageManifest(@ptrCast(*const IAppxPackageEditor, self), packageStream, updatedManifestStream, isPackageEncrypted, options);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PACKAGE_VERSION = extern struct {
    Anonymous: extern union {
        // WARNING: unable to add field alignment because it's not implemented for unions
        Version: u64,
        Anonymous: extern struct {
            Revision: u16,
            Build: u16,
            Minor: u16,
            Major: u16,
        },
    },
};

pub const PACKAGE_ID = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    reserved: u32,
    processorArchitecture: u32,
    version: PACKAGE_VERSION,
    name: ?PWSTR,
    publisher: ?PWSTR,
    resourceId: ?PWSTR,
    publisherId: ?PWSTR,
};

pub const PackagePathType = enum(i32) {
    Install = 0,
    Mutable = 1,
    Effective = 2,
    MachineExternal = 3,
    UserExternal = 4,
    EffectiveExternal = 5,
};
pub const PackagePathType_Install = PackagePathType.Install;
pub const PackagePathType_Mutable = PackagePathType.Mutable;
pub const PackagePathType_Effective = PackagePathType.Effective;
pub const PackagePathType_MachineExternal = PackagePathType.MachineExternal;
pub const PackagePathType_UserExternal = PackagePathType.UserExternal;
pub const PackagePathType_EffectiveExternal = PackagePathType.EffectiveExternal;

pub const PackageOrigin = enum(i32) {
    Unknown = 0,
    Unsigned = 1,
    Inbox = 2,
    Store = 3,
    DeveloperUnsigned = 4,
    DeveloperSigned = 5,
    LineOfBusiness = 6,
};
pub const PackageOrigin_Unknown = PackageOrigin.Unknown;
pub const PackageOrigin_Unsigned = PackageOrigin.Unsigned;
pub const PackageOrigin_Inbox = PackageOrigin.Inbox;
pub const PackageOrigin_Store = PackageOrigin.Store;
pub const PackageOrigin_DeveloperUnsigned = PackageOrigin.DeveloperUnsigned;
pub const PackageOrigin_DeveloperSigned = PackageOrigin.DeveloperSigned;
pub const PackageOrigin_LineOfBusiness = PackageOrigin.LineOfBusiness;

pub const _PACKAGE_INFO_REFERENCE = extern struct {
    reserved: ?*anyopaque,
};

pub const PACKAGE_INFO = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    reserved: u32,
    flags: u32,
    path: ?PWSTR,
    packageFullName: ?PWSTR,
    packageFamilyName: ?PWSTR,
    packageId: PACKAGE_ID,
};

pub const CreatePackageDependencyOptions = enum(i32) {
    None = 0,
    DoNotVerifyDependencyResolution = 1,
    ScopeIsSystem = 2,
};
pub const CreatePackageDependencyOptions_None = CreatePackageDependencyOptions.None;
pub const CreatePackageDependencyOptions_DoNotVerifyDependencyResolution = CreatePackageDependencyOptions.DoNotVerifyDependencyResolution;
pub const CreatePackageDependencyOptions_ScopeIsSystem = CreatePackageDependencyOptions.ScopeIsSystem;

pub const PackageDependencyLifetimeKind = enum(i32) {
    Process = 0,
    FilePath = 1,
    RegistryKey = 2,
};
pub const PackageDependencyLifetimeKind_Process = PackageDependencyLifetimeKind.Process;
pub const PackageDependencyLifetimeKind_FilePath = PackageDependencyLifetimeKind.FilePath;
pub const PackageDependencyLifetimeKind_RegistryKey = PackageDependencyLifetimeKind.RegistryKey;

pub const AddPackageDependencyOptions = enum(i32) {
    None = 0,
    PrependIfRankCollision = 1,
};
pub const AddPackageDependencyOptions_None = AddPackageDependencyOptions.None;
pub const AddPackageDependencyOptions_PrependIfRankCollision = AddPackageDependencyOptions.PrependIfRankCollision;

pub const PackageDependencyProcessorArchitectures = enum(i32) {
    None = 0,
    Neutral = 1,
    X86 = 2,
    X64 = 4,
    Arm = 8,
    Arm64 = 16,
    X86A64 = 32,
};
pub const PackageDependencyProcessorArchitectures_None = PackageDependencyProcessorArchitectures.None;
pub const PackageDependencyProcessorArchitectures_Neutral = PackageDependencyProcessorArchitectures.Neutral;
pub const PackageDependencyProcessorArchitectures_X86 = PackageDependencyProcessorArchitectures.X86;
pub const PackageDependencyProcessorArchitectures_X64 = PackageDependencyProcessorArchitectures.X64;
pub const PackageDependencyProcessorArchitectures_Arm = PackageDependencyProcessorArchitectures.Arm;
pub const PackageDependencyProcessorArchitectures_Arm64 = PackageDependencyProcessorArchitectures.Arm64;
pub const PackageDependencyProcessorArchitectures_X86A64 = PackageDependencyProcessorArchitectures.X86A64;

pub const PACKAGEDEPENDENCY_CONTEXT__ = extern struct {
    unused: i32,
};

pub const AppPolicyLifecycleManagement = enum(i32) {
    Unmanaged = 0,
    Managed = 1,
};
pub const AppPolicyLifecycleManagement_Unmanaged = AppPolicyLifecycleManagement.Unmanaged;
pub const AppPolicyLifecycleManagement_Managed = AppPolicyLifecycleManagement.Managed;

pub const AppPolicyWindowingModel = enum(i32) {
    None = 0,
    Universal = 1,
    ClassicDesktop = 2,
    ClassicPhone = 3,
};
pub const AppPolicyWindowingModel_None = AppPolicyWindowingModel.None;
pub const AppPolicyWindowingModel_Universal = AppPolicyWindowingModel.Universal;
pub const AppPolicyWindowingModel_ClassicDesktop = AppPolicyWindowingModel.ClassicDesktop;
pub const AppPolicyWindowingModel_ClassicPhone = AppPolicyWindowingModel.ClassicPhone;

pub const AppPolicyMediaFoundationCodecLoading = enum(i32) {
    All = 0,
    InboxOnly = 1,
};
pub const AppPolicyMediaFoundationCodecLoading_All = AppPolicyMediaFoundationCodecLoading.All;
pub const AppPolicyMediaFoundationCodecLoading_InboxOnly = AppPolicyMediaFoundationCodecLoading.InboxOnly;

pub const AppPolicyClrCompat = enum(i32) {
    Other = 0,
    ClassicDesktop = 1,
    Universal = 2,
    PackagedDesktop = 3,
};
pub const AppPolicyClrCompat_Other = AppPolicyClrCompat.Other;
pub const AppPolicyClrCompat_ClassicDesktop = AppPolicyClrCompat.ClassicDesktop;
pub const AppPolicyClrCompat_Universal = AppPolicyClrCompat.Universal;
pub const AppPolicyClrCompat_PackagedDesktop = AppPolicyClrCompat.PackagedDesktop;

pub const AppPolicyThreadInitializationType = enum(i32) {
    None = 0,
    InitializeWinRT = 1,
};
pub const AppPolicyThreadInitializationType_None = AppPolicyThreadInitializationType.None;
pub const AppPolicyThreadInitializationType_InitializeWinRT = AppPolicyThreadInitializationType.InitializeWinRT;

pub const AppPolicyShowDeveloperDiagnostic = enum(i32) {
    None = 0,
    ShowUI = 1,
};
pub const AppPolicyShowDeveloperDiagnostic_None = AppPolicyShowDeveloperDiagnostic.None;
pub const AppPolicyShowDeveloperDiagnostic_ShowUI = AppPolicyShowDeveloperDiagnostic.ShowUI;

pub const AppPolicyProcessTerminationMethod = enum(i32) {
    ExitProcess = 0,
    TerminateProcess = 1,
};
pub const AppPolicyProcessTerminationMethod_ExitProcess = AppPolicyProcessTerminationMethod.ExitProcess;
pub const AppPolicyProcessTerminationMethod_TerminateProcess = AppPolicyProcessTerminationMethod.TerminateProcess;

pub const AppPolicyCreateFileAccess = enum(i32) {
    Full = 0,
    Limited = 1,
};
pub const AppPolicyCreateFileAccess_Full = AppPolicyCreateFileAccess.Full;
pub const AppPolicyCreateFileAccess_Limited = AppPolicyCreateFileAccess.Limited;

pub const PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__ = extern struct {
    unused: i32,
};


//--------------------------------------------------------------------------------
// Section: Functions (63)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetCurrentPackageId(
    bufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetCurrentPackageFullName(
    packageFullNameLength: ?*u32,
    packageFullName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetCurrentPackageFamilyName(
    packageFamilyNameLength: ?*u32,
    packageFamilyName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetCurrentPackagePath(
    pathLength: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetPackageId(
    hProcess: ?HANDLE,
    bufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetPackageFullName(
    hProcess: ?HANDLE,
    packageFullNameLength: ?*u32,
    packageFullName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn GetPackageFullNameFromToken(
    token: ?HANDLE,
    packageFullNameLength: ?*u32,
    packageFullName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetPackageFamilyName(
    hProcess: ?HANDLE,
    packageFamilyNameLength: ?*u32,
    packageFamilyName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn GetPackageFamilyNameFromToken(
    token: ?HANDLE,
    packageFamilyNameLength: ?*u32,
    packageFamilyName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetPackagePath(
    packageId: ?*const PACKAGE_ID,
    reserved: u32,
    pathLength: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "KERNEL32" fn GetPackagePathByFullName(
    packageFullName: ?[*:0]const u16,
    pathLength: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "KERNEL32" fn GetStagedPackagePathByFullName(
    packageFullName: ?[*:0]const u16,
    pathLength: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetPackagePathByFullName2(
    packageFullName: ?[*:0]const u16,
    packagePathType: PackagePathType,
    pathLength: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetStagedPackagePathByFullName2(
    packageFullName: ?[*:0]const u16,
    packagePathType: PackagePathType,
    pathLength: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetCurrentPackageInfo2(
    flags: u32,
    packagePathType: PackagePathType,
    bufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetCurrentPackagePath2(
    packagePathType: PackagePathType,
    pathLength: ?*u32,
    path: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn GetCurrentApplicationUserModelId(
    applicationUserModelIdLength: ?*u32,
    applicationUserModelId: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn GetApplicationUserModelId(
    hProcess: ?HANDLE,
    applicationUserModelIdLength: ?*u32,
    applicationUserModelId: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn GetApplicationUserModelIdFromToken(
    token: ?HANDLE,
    applicationUserModelIdLength: ?*u32,
    applicationUserModelId: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyPackageFullName(
    packageFullName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyPackageFamilyName(
    packageFamilyName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyPackageId(
    packageId: ?*const PACKAGE_ID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyApplicationUserModelId(
    applicationUserModelId: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn VerifyPackageRelativeApplicationId(
    packageRelativeApplicationId: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn PackageIdFromFullName(
    packageFullName: ?[*:0]const u16,
    flags: u32,
    bufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn PackageFullNameFromId(
    packageId: ?*const PACKAGE_ID,
    packageFullNameLength: ?*u32,
    packageFullName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn PackageFamilyNameFromId(
    packageId: ?*const PACKAGE_ID,
    packageFamilyNameLength: ?*u32,
    packageFamilyName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn PackageFamilyNameFromFullName(
    packageFullName: ?[*:0]const u16,
    packageFamilyNameLength: ?*u32,
    packageFamilyName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn PackageNameAndPublisherIdFromFamilyName(
    packageFamilyName: ?[*:0]const u16,
    packageNameLength: ?*u32,
    packageName: ?[*:0]u16,
    packagePublisherIdLength: ?*u32,
    packagePublisherId: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "KERNEL32" fn FormatApplicationUserModelId(
    packageFamilyName: ?[*:0]const u16,
    packageRelativeApplicationId: ?[*:0]const u16,
    applicationUserModelIdLength: ?*u32,
    applicationUserModelId: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "KERNEL32" fn ParseApplicationUserModelId(
    applicationUserModelId: ?[*:0]const u16,
    packageFamilyNameLength: ?*u32,
    packageFamilyName: ?[*:0]u16,
    packageRelativeApplicationIdLength: ?*u32,
    packageRelativeApplicationId: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetPackagesByPackageFamily(
    packageFamilyName: ?[*:0]const u16,
    count: ?*u32,
    packageFullNames: ?[*]?PWSTR,
    bufferLength: ?*u32,
    buffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "KERNEL32" fn FindPackagesByPackageFamily(
    packageFamilyName: ?[*:0]const u16,
    packageFilters: u32,
    count: ?*u32,
    packageFullNames: ?[*]?PWSTR,
    bufferLength: ?*u32,
    buffer: ?[*:0]u16,
    packageProperties: ?[*]u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn GetStagedPackageOrigin(
    packageFullName: ?[*:0]const u16,
    origin: ?*PackageOrigin,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetCurrentPackageInfo(
    flags: u32,
    bufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn OpenPackageInfoByFullName(
    packageFullName: ?[*:0]const u16,
    reserved: u32,
    packageInfoReference: ?*?*_PACKAGE_INFO_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-appmodel-runtime-l1-1-1" fn OpenPackageInfoByFullNameForUser(
    userSid: ?PSID,
    packageFullName: ?[*:0]const u16,
    reserved: u32,
    packageInfoReference: ?*?*_PACKAGE_INFO_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn ClosePackageInfo(
    packageInfoReference: ?*_PACKAGE_INFO_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetPackageInfo(
    packageInfoReference: ?*_PACKAGE_INFO_REFERENCE,
    flags: u32,
    bufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "KERNEL32" fn GetPackageApplicationIds(
    packageInfoReference: ?*_PACKAGE_INFO_REFERENCE,
    bufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-appmodel-runtime-l1-1-3" fn GetPackageInfo2(
    packageInfoReference: ?*_PACKAGE_INFO_REFERENCE,
    flags: u32,
    packagePathType: PackagePathType,
    bufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    buffer: ?*u8,
    count: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn CheckIsMSIXPackage(
    packageFullName: ?[*:0]const u16,
    isMSIXPackage: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn TryCreatePackageDependency(
    user: ?PSID,
    packageFamilyName: ?[*:0]const u16,
    minVersion: PACKAGE_VERSION,
    packageDependencyProcessorArchitectures: PackageDependencyProcessorArchitectures,
    lifetimeKind: PackageDependencyLifetimeKind,
    lifetimeArtifact: ?[*:0]const u16,
    options: CreatePackageDependencyOptions,
    packageDependencyId: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn DeletePackageDependency(
    packageDependencyId: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn AddPackageDependency(
    packageDependencyId: ?[*:0]const u16,
    rank: i32,
    options: AddPackageDependencyOptions,
    packageDependencyContext: ?*?*PACKAGEDEPENDENCY_CONTEXT__,
    packageFullName: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn RemovePackageDependency(
    packageDependencyContext: ?*PACKAGEDEPENDENCY_CONTEXT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn GetResolvedPackageFullNameForPackageDependency(
    packageDependencyId: ?[*:0]const u16,
    packageFullName: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn GetIdForPackageDependencyContext(
    packageDependencyContext: ?*PACKAGEDEPENDENCY_CONTEXT__,
    packageDependencyId: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn AppPolicyGetLifecycleManagement(
    processToken: ?HANDLE,
    policy: ?*AppPolicyLifecycleManagement,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn AppPolicyGetWindowingModel(
    processToken: ?HANDLE,
    policy: ?*AppPolicyWindowingModel,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn AppPolicyGetMediaFoundationCodecLoading(
    processToken: ?HANDLE,
    policy: ?*AppPolicyMediaFoundationCodecLoading,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn AppPolicyGetClrCompat(
    processToken: ?HANDLE,
    policy: ?*AppPolicyClrCompat,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn AppPolicyGetThreadInitializationType(
    processToken: ?HANDLE,
    policy: ?*AppPolicyThreadInitializationType,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn AppPolicyGetShowDeveloperDiagnostic(
    processToken: ?HANDLE,
    policy: ?*AppPolicyShowDeveloperDiagnostic,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn AppPolicyGetProcessTerminationMethod(
    processToken: ?HANDLE,
    policy: ?*AppPolicyProcessTerminationMethod,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn AppPolicyGetCreateFileAccess(
    processToken: ?HANDLE,
    policy: ?*AppPolicyCreateFileAccess,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn CreatePackageVirtualizationContext(
    packageFamilyName: ?[*:0]const u16,
    context: ?*?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn ActivatePackageVirtualizationContext(
    context: ?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
    cookie: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn ReleasePackageVirtualizationContext(
    context: ?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn DeactivatePackageVirtualizationContext(
    cookie: usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn DuplicatePackageVirtualizationContext(
    sourceContext: ?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
    destContext: ?*?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn GetCurrentPackageVirtualizationContext(
) callconv(@import("std").os.windows.WINAPI) ?*PACKAGE_VIRTUALIZATION_CONTEXT_HANDLE__;

pub extern "KERNEL32" fn GetProcessesInVirtualizationContext(
    packageFamilyName: ?[*:0]const u16,
    count: ?*u32,
    processes: ?*?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const BOOL = @import("../../foundation.zig").BOOL;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IStream = @import("../../system/com.zig").IStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const IUri = @import("../../system/com.zig").IUri;
const PSID = @import("../../foundation.zig").PSID;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
