//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (284)
//--------------------------------------------------------------------------------
pub const IMAPI_SECTOR_SIZE = @as(u32, 2048);
pub const IMAPI2_DEFAULT_COMMAND_TIMEOUT = @as(u32, 10);
pub const DISPID_DDISCMASTER2EVENTS_DEVICEADDED = @as(u32, 256);
pub const DISPID_DDISCMASTER2EVENTS_DEVICEREMOVED = @as(u32, 257);
pub const DISPID_IDISCRECORDER2_EJECTMEDIA = @as(u32, 256);
pub const DISPID_IDISCRECORDER2_CLOSETRAY = @as(u32, 257);
pub const DISPID_IDISCRECORDER2_ACQUIREEXCLUSIVEACCESS = @as(u32, 258);
pub const DISPID_IDISCRECORDER2_RELEASEEXCLUSIVEACCESS = @as(u32, 259);
pub const DISPID_IDISCRECORDER2_DISABLEMCN = @as(u32, 260);
pub const DISPID_IDISCRECORDER2_ENABLEMCN = @as(u32, 261);
pub const DISPID_IDISCRECORDER2_INITIALIZEDISCRECORDER = @as(u32, 262);
pub const DISPID_IDISCRECORDER2_ACTIVEDISCRECORDER = @as(u32, 0);
pub const DISPID_IDISCRECORDER2_VENDORID = @as(u32, 513);
pub const DISPID_IDISCRECORDER2_PRODUCTID = @as(u32, 514);
pub const DISPID_IDISCRECORDER2_PRODUCTREVISION = @as(u32, 515);
pub const DISPID_IDISCRECORDER2_VOLUMENAME = @as(u32, 516);
pub const DISPID_IDISCRECORDER2_VOLUMEPATHNAMES = @as(u32, 517);
pub const DISPID_IDISCRECORDER2_DEVICECANLOADMEDIA = @as(u32, 518);
pub const DISPID_IDISCRECORDER2_LEGACYDEVICENUMBER = @as(u32, 519);
pub const DISPID_IDISCRECORDER2_SUPPORTEDFEATUREPAGES = @as(u32, 520);
pub const DISPID_IDISCRECORDER2_CURRENTFEATUREPAGES = @as(u32, 521);
pub const DISPID_IDISCRECORDER2_SUPPORTEDPROFILES = @as(u32, 522);
pub const DISPID_IDISCRECORDER2_CURRENTPROFILES = @as(u32, 523);
pub const DISPID_IDISCRECORDER2_SUPPORTEDMODEPAGES = @as(u32, 524);
pub const DISPID_IDISCRECORDER2_EXCLUSIVEACCESSOWNER = @as(u32, 525);
pub const DISPID_IWRITEENGINE2_WRITESECTION = @as(u32, 512);
pub const DISPID_IWRITEENGINE2_CANCELWRITE = @as(u32, 513);
pub const DISPID_IWRITEENGINE2_DISCRECORDER = @as(u32, 256);
pub const DISPID_IWRITEENGINE2_USESTREAMINGWRITE12 = @as(u32, 257);
pub const DISPID_IWRITEENGINE2_STARTINGSECTORSPERSECOND = @as(u32, 258);
pub const DISPID_IWRITEENGINE2_ENDINGSECTORSPERSECOND = @as(u32, 259);
pub const DISPID_IWRITEENGINE2_BYTESPERSECTOR = @as(u32, 260);
pub const DISPID_IWRITEENGINE2_WRITEINPROGRESS = @as(u32, 261);
pub const DISPID_IWRITEENGINE2EVENTARGS_STARTLBA = @as(u32, 256);
pub const DISPID_IWRITEENGINE2EVENTARGS_SECTORCOUNT = @as(u32, 257);
pub const DISPID_IWRITEENGINE2EVENTARGS_LASTREADLBA = @as(u32, 258);
pub const DISPID_IWRITEENGINE2EVENTARGS_LASTWRITTENLBA = @as(u32, 259);
pub const DISPID_IWRITEENGINE2EVENTARGS_TOTALDEVICEBUFFER = @as(u32, 260);
pub const DISPID_IWRITEENGINE2EVENTARGS_USEDDEVICEBUFFER = @as(u32, 261);
pub const DISPID_IWRITEENGINE2EVENTARGS_TOTALSYSTEMBUFFER = @as(u32, 262);
pub const DISPID_IWRITEENGINE2EVENTARGS_USEDSYSTEMBUFFER = @as(u32, 263);
pub const DISPID_IWRITEENGINE2EVENTARGS_FREESYSTEMBUFFER = @as(u32, 264);
pub const DISPID_DWRITEENGINE2EVENTS_UPDATE = @as(u32, 256);
pub const DISPID_IDISCFORMAT2_RECORDERSUPPORTED = @as(u32, 2048);
pub const DISPID_IDISCFORMAT2_MEDIASUPPORTED = @as(u32, 2049);
pub const DISPID_IDISCFORMAT2_MEDIAPHYSICALLYBLANK = @as(u32, 1792);
pub const DISPID_IDISCFORMAT2_MEDIAHEURISTICALLYBLANK = @as(u32, 1793);
pub const DISPID_IDISCFORMAT2_SUPPORTEDMEDIATYPES = @as(u32, 1794);
pub const DISPID_IDISCFORMAT2ERASE_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2ERASE_FULLERASE = @as(u32, 257);
pub const DISPID_IDISCFORMAT2ERASE_MEDIATYPE = @as(u32, 258);
pub const DISPID_IDISCFORMAT2ERASE_CLIENTNAME = @as(u32, 259);
pub const DISPID_IDISCFORMAT2ERASE_ERASEMEDIA = @as(u32, 513);
pub const DISPID_IDISCFORMAT2ERASEEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2DATA_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2DATA_BUFFERUNDERRUNFREEDISABLED = @as(u32, 257);
pub const DISPID_IDISCFORMAT2DATA_POSTGAPALREADYINIMAGE = @as(u32, 260);
pub const DISPID_IDISCFORMAT2DATA_CURRENTMEDIASTATUS = @as(u32, 262);
pub const DISPID_IDISCFORMAT2DATA_WRITEPROTECTSTATUS = @as(u32, 263);
pub const DISPID_IDISCFORMAT2DATA_TOTALSECTORS = @as(u32, 264);
pub const DISPID_IDISCFORMAT2DATA_FREESECTORS = @as(u32, 265);
pub const DISPID_IDISCFORMAT2DATA_NEXTWRITABLEADDRESS = @as(u32, 266);
pub const DISPID_IDISCFORMAT2DATA_STARTSECTOROFPREVIOUSSESSION = @as(u32, 267);
pub const DISPID_IDISCFORMAT2DATA_LASTSECTOROFPREVIOUSSESSION = @as(u32, 268);
pub const DISPID_IDISCFORMAT2DATA_FORCEMEDIATOBECLOSED = @as(u32, 269);
pub const DISPID_IDISCFORMAT2DATA_DISABLEDVDCOMPATIBILITYMODE = @as(u32, 270);
pub const DISPID_IDISCFORMAT2DATA_CURRENTMEDIATYPE = @as(u32, 271);
pub const DISPID_IDISCFORMAT2DATA_CLIENTNAME = @as(u32, 272);
pub const DISPID_IDISCFORMAT2DATA_REQUESTEDWRITESPEED = @as(u32, 273);
pub const DISPID_IDISCFORMAT2DATA_REQUESTEDROTATIONTYPEISPURECAV = @as(u32, 274);
pub const DISPID_IDISCFORMAT2DATA_CURRENTWRITESPEED = @as(u32, 275);
pub const DISPID_IDISCFORMAT2DATA_CURRENTROTATIONTYPEISPURECAV = @as(u32, 276);
pub const DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDS = @as(u32, 277);
pub const DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDDESCRIPTORS = @as(u32, 278);
pub const DISPID_IDISCFORMAT2DATA_FORCEOVERWRITE = @as(u32, 279);
pub const DISPID_IDISCFORMAT2DATA_MUTLISESSIONINTERFACES = @as(u32, 280);
pub const DISPID_IDISCFORMAT2DATA_WRITE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2DATA_CANCELWRITE = @as(u32, 513);
pub const DISPID_IDISCFORMAT2DATA_SETWRITESPEED = @as(u32, 514);
pub const DISPID_DDISCFORMAT2DATAEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_ELAPSEDTIME = @as(u32, 768);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDREMAININGTIME = @as(u32, 769);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDTOTALTIME = @as(u32, 770);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_CURRENTACTION = @as(u32, 771);
pub const DISPID_IDISCFORMAT2TAO_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2TAO_BUFFERUNDERRUNFREEDISABLED = @as(u32, 258);
pub const DISPID_IDISCFORMAT2TAO_NUMBEROFEXISTINGTRACKS = @as(u32, 259);
pub const DISPID_IDISCFORMAT2TAO_TOTALSECTORSONMEDIA = @as(u32, 260);
pub const DISPID_IDISCFORMAT2TAO_FREESECTORSONMEDIA = @as(u32, 261);
pub const DISPID_IDISCFORMAT2TAO_USEDSECTORSONMEDIA = @as(u32, 262);
pub const DISPID_IDISCFORMAT2TAO_DONOTFINALIZEMEDIA = @as(u32, 263);
pub const DISPID_IDISCFORMAT2TAO_EXPECTEDTABLEOFCONTENTS = @as(u32, 266);
pub const DISPID_IDISCFORMAT2TAO_CURRENTMEDIATYPE = @as(u32, 267);
pub const DISPID_IDISCFORMAT2TAO_CLIENTNAME = @as(u32, 270);
pub const DISPID_IDISCFORMAT2TAO_REQUESTEDWRITESPEED = @as(u32, 271);
pub const DISPID_IDISCFORMAT2TAO_REQUESTEDROTATIONTYPEISPURECAV = @as(u32, 272);
pub const DISPID_IDISCFORMAT2TAO_CURRENTWRITESPEED = @as(u32, 273);
pub const DISPID_IDISCFORMAT2TAO_CURRENTROTATIONTYPEISPURECAV = @as(u32, 274);
pub const DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDS = @as(u32, 275);
pub const DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDDESCRIPTORS = @as(u32, 276);
pub const DISPID_IDISCFORMAT2TAO_PREPAREMEDIA = @as(u32, 512);
pub const DISPID_IDISCFORMAT2TAO_ADDAUDIOTRACK = @as(u32, 513);
pub const DISPID_IDISCFORMAT2TAO_CANCELADDTRACK = @as(u32, 514);
pub const DISPID_IDISCFORMAT2TAO_FINISHMEDIA = @as(u32, 515);
pub const DISPID_IDISCFORMAT2TAO_SETWRITESPEED = @as(u32, 516);
pub const DISPID_DDISCFORMAT2TAOEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTTRACKNUMBER = @as(u32, 768);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTACTION = @as(u32, 769);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_ELAPSEDTIME = @as(u32, 770);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDREMAININGTIME = @as(u32, 771);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDTOTALTIME = @as(u32, 772);
pub const DISPID_IDISCFORMAT2RAWCD_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2RAWCD_BUFFERUNDERRUNFREEDISABLED = @as(u32, 258);
pub const DISPID_IDISCFORMAT2RAWCD_STARTOFNEXTSESSION = @as(u32, 259);
pub const DISPID_IDISCFORMAT2RAWCD_LASTPOSSIBLESTARTOFLEADOUT = @as(u32, 260);
pub const DISPID_IDISCFORMAT2RAWCD_CURRENTMEDIATYPE = @as(u32, 261);
pub const DISPID_IDISCFORMAT2RAWCD_SUPPORTEDDATASECTORTYPES = @as(u32, 264);
pub const DISPID_IDISCFORMAT2RAWCD_REQUESTEDDATASECTORTYPE = @as(u32, 265);
pub const DISPID_IDISCFORMAT2RAWCD_CLIENTNAME = @as(u32, 266);
pub const DISPID_IDISCFORMAT2RAWCD_REQUESTEDWRITESPEED = @as(u32, 267);
pub const DISPID_IDISCFORMAT2RAWCD_REQUESTEDROTATIONTYPEISPURECAV = @as(u32, 268);
pub const DISPID_IDISCFORMAT2RAWCD_CURRENTWRITESPEED = @as(u32, 269);
pub const DISPID_IDISCFORMAT2RAWCD_CURRENTROTATIONTYPEISPURECAV = @as(u32, 270);
pub const DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDS = @as(u32, 271);
pub const DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDDESCRIPTORS = @as(u32, 272);
pub const DISPID_IDISCFORMAT2RAWCD_PREPAREMEDIA = @as(u32, 512);
pub const DISPID_IDISCFORMAT2RAWCD_WRITEMEDIA = @as(u32, 513);
pub const DISPID_IDISCFORMAT2RAWCD_WRITEMEDIAWITHVALIDATION = @as(u32, 514);
pub const DISPID_IDISCFORMAT2RAWCD_CANCELWRITE = @as(u32, 515);
pub const DISPID_IDISCFORMAT2RAWCD_RELEASEMEDIA = @as(u32, 516);
pub const DISPID_IDISCFORMAT2RAWCD_SETWRITESPEED = @as(u32, 517);
pub const DISPID_DDISCFORMAT2RAWCDEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTTRACKNUMBER = @as(u32, 768);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTACTION = @as(u32, 769);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_ELAPSEDTIME = @as(u32, 768);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDREMAININGTIME = @as(u32, 769);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDTOTALTIME = @as(u32, 770);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_CD = @as(u32, 75);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_DVD = @as(u32, 680);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_BD = @as(u32, 2195);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_HD_DVD = @as(u32, 4568);
pub const DISPID_IMULTISESSION_SUPPORTEDONCURRENTMEDIA = @as(u32, 256);
pub const DISPID_IMULTISESSION_INUSE = @as(u32, 257);
pub const DISPID_IMULTISESSION_IMPORTRECORDER = @as(u32, 258);
pub const DISPID_IMULTISESSION_FIRSTDATASESSION = @as(u32, 512);
pub const DISPID_IMULTISESSION_STARTSECTOROFPREVIOUSSESSION = @as(u32, 513);
pub const DISPID_IMULTISESSION_LASTSECTOROFPREVIOUSSESSION = @as(u32, 514);
pub const DISPID_IMULTISESSION_NEXTWRITABLEADDRESS = @as(u32, 515);
pub const DISPID_IMULTISESSION_FREESECTORS = @as(u32, 516);
pub const DISPID_IMULTISESSION_WRITEUNITSIZE = @as(u32, 517);
pub const DISPID_IMULTISESSION_LASTWRITTENADDRESS = @as(u32, 518);
pub const DISPID_IMULTISESSION_SECTORSONMEDIA = @as(u32, 519);
pub const DISPID_IRAWCDIMAGECREATOR_CREATERESULTIMAGE = @as(u32, 512);
pub const DISPID_IRAWCDIMAGECREATOR_ADDTRACK = @as(u32, 513);
pub const DISPID_IRAWCDIMAGECREATOR_ADDSPECIALPREGAP = @as(u32, 514);
pub const DISPID_IRAWCDIMAGECREATOR_ADDSUBCODERWGENERATOR = @as(u32, 515);
pub const DISPID_IRAWCDIMAGECREATOR_RESULTINGIMAGETYPE = @as(u32, 256);
pub const DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUT = @as(u32, 257);
pub const DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUTLIMIT = @as(u32, 258);
pub const DISPID_IRAWCDIMAGECREATOR_DISABLEGAPLESSAUDIO = @as(u32, 259);
pub const DISPID_IRAWCDIMAGECREATOR_MEDIACATALOGNUMBER = @as(u32, 260);
pub const DISPID_IRAWCDIMAGECREATOR_STARTINGTRACKNUMBER = @as(u32, 261);
pub const DISPID_IRAWCDIMAGECREATOR_TRACKINFO = @as(u32, 262);
pub const DISPID_IRAWCDIMAGECREATOR_NUMBEROFEXISTINGTRACKS = @as(u32, 263);
pub const DISPID_IRAWCDIMAGECREATOR_USEDSECTORSONDISC = @as(u32, 264);
pub const DISPID_IRAWCDIMAGECREATOR_EXPECTEDTABLEOFCONTENTS = @as(u32, 265);
pub const DISPID_IRAWCDTRACKINFO_STARTINGLBA = @as(u32, 256);
pub const DISPID_IRAWCDTRACKINFO_SECTORCOUNT = @as(u32, 257);
pub const DISPID_IRAWCDTRACKINFO_TRACKNUMBER = @as(u32, 258);
pub const DISPID_IRAWCDTRACKINFO_SECTORTYPE = @as(u32, 259);
pub const DISPID_IRAWCDTRACKINFO_ISRC = @as(u32, 260);
pub const DISPID_IRAWCDTRACKINFO_DIGITALAUDIOCOPYSETTING = @as(u32, 261);
pub const DISPID_IRAWCDTRACKINFO_AUDIOHASPREEMPHASIS = @as(u32, 262);
pub const DISPID_IBLOCKRANGE_STARTLBA = @as(u32, 256);
pub const DISPID_IBLOCKRANGE_ENDLBA = @as(u32, 257);
pub const DISPID_IBLOCKRANGELIST_BLOCKRANGES = @as(u32, 256);
pub const IMAPILib2_MajorVersion = @as(u32, 1);
pub const IMAPILib2_MinorVersion = @as(u32, 0);
pub const IMAPI2FS_BOOT_ENTRY_COUNT_MAX = @as(u32, 32);
pub const DISPID_DFILESYSTEMIMAGEEVENTS_UPDATE = @as(u32, 256);
pub const DISPID_DFILESYSTEMIMAGEIMPORTEVENTS_UPDATEIMPORT = @as(u32, 257);
pub const IMAPI2FS_MajorVersion = @as(u32, 1);
pub const IMAPI2FS_MinorVersion = @as(u32, 0);
pub const MP_MSGCLASS_SYSTEM = @as(u32, 1);
pub const MP_MSGCLASS_REPLICATION = @as(u32, 2);
pub const MP_MSGCLASS_DELIVERY_REPORT = @as(u32, 3);
pub const MP_MSGCLASS_NONDELIVERY_REPORT = @as(u32, 4);
pub const MP_STATUS_SUCCESS = @as(u32, 0);
pub const MP_STATUS_RETRY = @as(u32, 1);
pub const MP_STATUS_ABORT_DELIVERY = @as(u32, 2);
pub const MP_STATUS_BAD_MAIL = @as(u32, 3);
pub const MP_STATUS_SUBMITTED = @as(u32, 4);
pub const MP_STATUS_CATEGORIZED = @as(u32, 5);
pub const MP_STATUS_ABANDON_DELIVERY = @as(u32, 6);
pub const RP_RECIP_FLAGS_RESERVED = @as(u32, 15);
pub const RP_DSN_NOTIFY_SUCCESS = @as(u32, 16777216);
pub const RP_DSN_NOTIFY_FAILURE = @as(u32, 33554432);
pub const RP_DSN_NOTIFY_DELAY = @as(u32, 67108864);
pub const RP_DSN_NOTIFY_NEVER = @as(u32, 134217728);
pub const RP_DSN_NOTIFY_MASK = @as(u32, 251658240);
pub const RP_HANDLED = @as(u32, 16);
pub const RP_GENERAL_FAILURE = @as(u32, 32);
pub const RP_DSN_HANDLED = @as(u32, 64);
pub const RP_DELIVERED = @as(u32, 272);
pub const RP_DSN_SENT_NDR = @as(u32, 1104);
pub const RP_FAILED = @as(u32, 2096);
pub const RP_UNRESOLVED = @as(u32, 4144);
pub const RP_ENPANDED = @as(u32, 8208);
pub const RP_EXPANDED = @as(u32, 8208);
pub const RP_DSN_SENT_DELAYED = @as(u32, 16384);
pub const RP_DSN_SENT_EXPANDED = @as(u32, 32832);
pub const RP_DSN_SENT_RELAYED = @as(u32, 65600);
pub const RP_DSN_SENT_DELIVERED = @as(u32, 131136);
pub const RP_REMOTE_MTA_NO_DSN = @as(u32, 524288);
pub const RP_ERROR_CONTEXT_STORE = @as(u32, 1048576);
pub const RP_ERROR_CONTEXT_CAT = @as(u32, 2097152);
pub const RP_ERROR_CONTEXT_MTA = @as(u32, 4194304);
pub const RP_VOLATILE_FLAGS_MASK = @as(u32, 4026531840);
pub const RP_DSN_NOTIFY_INVALID = @as(u32, 0);
pub const MPV_INBOUND_CUTOFF_EXCEEDED = @as(u32, 1);
pub const MPV_WRITE_CONTENT = @as(u32, 2);
pub const NMP_PROCESS_POST = @as(u32, 1);
pub const NMP_PROCESS_CONTROL = @as(u32, 2);
pub const NMP_PROCESS_MODERATOR = @as(u32, 4);
pub const GUID_SMTP_SOURCE_TYPE = Guid.initString("fb65c4dc-e468-11d1-aa67-00c04fa345f6");
pub const GUID_SMTPSVC_SOURCE = Guid.initString("1b3c0666-e470-11d1-aa67-00c04fa345f6");
pub const CATID_SMTP_ON_INBOUND_COMMAND = Guid.initString("f6628c8d-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_SERVER_RESPONSE = Guid.initString("f6628c8e-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_SESSION_START = Guid.initString("f6628c8f-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_MESSAGE_START = Guid.initString("f6628c90-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_PER_RECIPIENT = Guid.initString("f6628c91-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_BEFORE_DATA = Guid.initString("f6628c92-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_SESSION_END = Guid.initString("f6628c93-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_STORE_DRIVER = Guid.initString("59175850-e533-11d1-aa67-00c04fa345f6");
pub const CATID_SMTP_TRANSPORT_SUBMISSION = Guid.initString("ff3caa23-00b9-11d2-9dfb-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_PRECATEGORIZE = Guid.initString("a3acfb0d-83ff-11d2-9e14-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_CATEGORIZE = Guid.initString("960252a3-0a3a-11d2-9e00-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_POSTCATEGORIZE = Guid.initString("76719654-05a6-11d2-9dfd-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_ROUTER = Guid.initString("283430c9-1850-11d2-9e03-00c04fa322ba");
pub const CATID_SMTP_MSGTRACKLOG = Guid.initString("c6df52aa-7db0-11d2-94f4-00c04f79f1d6");
pub const CATID_SMTP_DNSRESOLVERRECORDSINK = Guid.initString("bd0b4366-8e03-11d2-94f6-00c04f79f1d6");
pub const CATID_SMTP_MAXMSGSIZE = Guid.initString("ebf159de-a67e-11d2-94f7-00c04f79f1d6");
pub const CATID_SMTP_LOG = Guid.initString("93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97");
pub const CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS = Guid.initString("84ff368a-fab3-43d7-bcdf-692c5b46e6b1");
pub const CLSID_SmtpCat = Guid.initString("b23c35b7-9219-11d2-9e17-00c04fa322ba");
pub const CATID_SMTP_DSN = Guid.initString("22b55731-f5f8-4d23-bd8f-87b52371a73a");
pub const IMAPI_S_PROPERTIESIGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const IMAPI_S_BUFFER_TO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const IMAPI_E_NOTOPENED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const IMAPI_E_NOTINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const IMAPI_E_USERABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const IMAPI_E_GENERIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const IMAPI_E_MEDIUM_NOTPRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const IMAPI_E_MEDIUM_INVALIDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const IMAPI_E_DEVICE_NOPROPERTIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const IMAPI_E_DEVICE_NOTACCESSIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const IMAPI_E_DEVICE_NOTPRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const IMAPI_E_DEVICE_INVALIDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const IMAPI_E_INITIALIZE_WRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const IMAPI_E_INITIALIZE_ENDWRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const IMAPI_E_FILESYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const IMAPI_E_FILEACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220968));
pub const IMAPI_E_DISCINFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const IMAPI_E_TRACKNOTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220966));
pub const IMAPI_E_TRACKOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const IMAPI_E_DISCFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220964));
pub const IMAPI_E_BADJOLIETNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220963));
pub const IMAPI_E_INVALIDIMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220962));
pub const IMAPI_E_NOACTIVEFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220961));
pub const IMAPI_E_NOACTIVERECORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220960));
pub const IMAPI_E_WRONGFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220959));
pub const IMAPI_E_ALREADYOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220958));
pub const IMAPI_E_WRONGDISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220957));
pub const IMAPI_E_FILEEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220956));
pub const IMAPI_E_STASHINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220955));
pub const IMAPI_E_DEVICE_STILL_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220954));
pub const IMAPI_E_LOSS_OF_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220953));
pub const IMAPI_E_COMPRESSEDSTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220952));
pub const IMAPI_E_ENCRYPTEDSTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220951));
pub const IMAPI_E_NOTENOUGHDISKFORSTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220950));
pub const IMAPI_E_REMOVABLESTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220949));
pub const IMAPI_E_CANNOT_WRITE_TO_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220948));
pub const IMAPI_E_TRACK_NOT_BIG_ENOUGH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220947));
pub const IMAPI_E_BOOTIMAGE_AND_NONBLANK_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220946));

//--------------------------------------------------------------------------------
// Section: Types (130)
//--------------------------------------------------------------------------------
pub const DISC_RECORDER_STATE_FLAGS = enum(u32) {
    BURNING = 2,
    DOING_NOTHING = 0,
    OPENED = 1,
};
pub const RECORDER_BURNING = DISC_RECORDER_STATE_FLAGS.BURNING;
pub const RECORDER_DOING_NOTHING = DISC_RECORDER_STATE_FLAGS.DOING_NOTHING;
pub const RECORDER_OPENED = DISC_RECORDER_STATE_FLAGS.OPENED;

const CLSID_MsftDiscMaster2_Value = @import("../zig.zig").Guid.initString("2735412e-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscMaster2 = &CLSID_MsftDiscMaster2_Value;

const CLSID_MsftDiscRecorder2_Value = @import("../zig.zig").Guid.initString("2735412d-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscRecorder2 = &CLSID_MsftDiscRecorder2_Value;

const CLSID_MsftWriteEngine2_Value = @import("../zig.zig").Guid.initString("2735412c-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftWriteEngine2 = &CLSID_MsftWriteEngine2_Value;

const CLSID_MsftDiscFormat2Erase_Value = @import("../zig.zig").Guid.initString("2735412b-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2Erase = &CLSID_MsftDiscFormat2Erase_Value;

const CLSID_MsftDiscFormat2Data_Value = @import("../zig.zig").Guid.initString("2735412a-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2Data = &CLSID_MsftDiscFormat2Data_Value;

const CLSID_MsftDiscFormat2TrackAtOnce_Value = @import("../zig.zig").Guid.initString("27354129-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2TrackAtOnce = &CLSID_MsftDiscFormat2TrackAtOnce_Value;

const CLSID_MsftDiscFormat2RawCD_Value = @import("../zig.zig").Guid.initString("27354128-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2RawCD = &CLSID_MsftDiscFormat2RawCD_Value;

const CLSID_MsftStreamZero_Value = @import("../zig.zig").Guid.initString("27354127-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamZero = &CLSID_MsftStreamZero_Value;

const CLSID_MsftStreamPrng001_Value = @import("../zig.zig").Guid.initString("27354126-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamPrng001 = &CLSID_MsftStreamPrng001_Value;

const CLSID_MsftStreamConcatenate_Value = @import("../zig.zig").Guid.initString("27354125-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamConcatenate = &CLSID_MsftStreamConcatenate_Value;

const CLSID_MsftStreamInterleave_Value = @import("../zig.zig").Guid.initString("27354124-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamInterleave = &CLSID_MsftStreamInterleave_Value;

const CLSID_MsftWriteSpeedDescriptor_Value = @import("../zig.zig").Guid.initString("27354123-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftWriteSpeedDescriptor = &CLSID_MsftWriteSpeedDescriptor_Value;

const CLSID_MsftMultisessionSequential_Value = @import("../zig.zig").Guid.initString("27354122-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftMultisessionSequential = &CLSID_MsftMultisessionSequential_Value;

const CLSID_MsftMultisessionRandomWrite_Value = @import("../zig.zig").Guid.initString("b507ca24-2204-11dd-966a-001aa01bbc58");
pub const CLSID_MsftMultisessionRandomWrite = &CLSID_MsftMultisessionRandomWrite_Value;

const CLSID_MsftRawCDImageCreator_Value = @import("../zig.zig").Guid.initString("25983561-9d65-49ce-b335-40630d901227");
pub const CLSID_MsftRawCDImageCreator = &CLSID_MsftRawCDImageCreator_Value;

pub const IMAPI_MEDIA_PHYSICAL_TYPE = enum(i32) {
    UNKNOWN = 0,
    CDROM = 1,
    CDR = 2,
    CDRW = 3,
    DVDROM = 4,
    DVDRAM = 5,
    DVDPLUSR = 6,
    DVDPLUSRW = 7,
    DVDPLUSR_DUALLAYER = 8,
    DVDDASHR = 9,
    DVDDASHRW = 10,
    DVDDASHR_DUALLAYER = 11,
    DISK = 12,
    DVDPLUSRW_DUALLAYER = 13,
    HDDVDROM = 14,
    HDDVDR = 15,
    HDDVDRAM = 16,
    BDROM = 17,
    BDR = 18,
    BDRE = 19,
    // MAX = 19, this enum value conflicts with BDRE
};
pub const IMAPI_MEDIA_TYPE_UNKNOWN = IMAPI_MEDIA_PHYSICAL_TYPE.UNKNOWN;
pub const IMAPI_MEDIA_TYPE_CDROM = IMAPI_MEDIA_PHYSICAL_TYPE.CDROM;
pub const IMAPI_MEDIA_TYPE_CDR = IMAPI_MEDIA_PHYSICAL_TYPE.CDR;
pub const IMAPI_MEDIA_TYPE_CDRW = IMAPI_MEDIA_PHYSICAL_TYPE.CDRW;
pub const IMAPI_MEDIA_TYPE_DVDROM = IMAPI_MEDIA_PHYSICAL_TYPE.DVDROM;
pub const IMAPI_MEDIA_TYPE_DVDRAM = IMAPI_MEDIA_PHYSICAL_TYPE.DVDRAM;
pub const IMAPI_MEDIA_TYPE_DVDPLUSR = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSR;
pub const IMAPI_MEDIA_TYPE_DVDPLUSRW = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSRW;
pub const IMAPI_MEDIA_TYPE_DVDPLUSR_DUALLAYER = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSR_DUALLAYER;
pub const IMAPI_MEDIA_TYPE_DVDDASHR = IMAPI_MEDIA_PHYSICAL_TYPE.DVDDASHR;
pub const IMAPI_MEDIA_TYPE_DVDDASHRW = IMAPI_MEDIA_PHYSICAL_TYPE.DVDDASHRW;
pub const IMAPI_MEDIA_TYPE_DVDDASHR_DUALLAYER = IMAPI_MEDIA_PHYSICAL_TYPE.DVDDASHR_DUALLAYER;
pub const IMAPI_MEDIA_TYPE_DISK = IMAPI_MEDIA_PHYSICAL_TYPE.DISK;
pub const IMAPI_MEDIA_TYPE_DVDPLUSRW_DUALLAYER = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSRW_DUALLAYER;
pub const IMAPI_MEDIA_TYPE_HDDVDROM = IMAPI_MEDIA_PHYSICAL_TYPE.HDDVDROM;
pub const IMAPI_MEDIA_TYPE_HDDVDR = IMAPI_MEDIA_PHYSICAL_TYPE.HDDVDR;
pub const IMAPI_MEDIA_TYPE_HDDVDRAM = IMAPI_MEDIA_PHYSICAL_TYPE.HDDVDRAM;
pub const IMAPI_MEDIA_TYPE_BDROM = IMAPI_MEDIA_PHYSICAL_TYPE.BDROM;
pub const IMAPI_MEDIA_TYPE_BDR = IMAPI_MEDIA_PHYSICAL_TYPE.BDR;
pub const IMAPI_MEDIA_TYPE_BDRE = IMAPI_MEDIA_PHYSICAL_TYPE.BDRE;
pub const IMAPI_MEDIA_TYPE_MAX = IMAPI_MEDIA_PHYSICAL_TYPE.BDRE;

pub const IMAPI_MEDIA_WRITE_PROTECT_STATE = enum(i32) {
    UNTIL_POWERDOWN = 1,
    BY_CARTRIDGE = 2,
    BY_MEDIA_SPECIFIC_REASON = 4,
    BY_SOFTWARE_WRITE_PROTECT = 8,
    BY_DISC_CONTROL_BLOCK = 16,
    READ_ONLY_MEDIA = 16384,
};
pub const IMAPI_WRITEPROTECTED_UNTIL_POWERDOWN = IMAPI_MEDIA_WRITE_PROTECT_STATE.UNTIL_POWERDOWN;
pub const IMAPI_WRITEPROTECTED_BY_CARTRIDGE = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_CARTRIDGE;
pub const IMAPI_WRITEPROTECTED_BY_MEDIA_SPECIFIC_REASON = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_MEDIA_SPECIFIC_REASON;
pub const IMAPI_WRITEPROTECTED_BY_SOFTWARE_WRITE_PROTECT = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_SOFTWARE_WRITE_PROTECT;
pub const IMAPI_WRITEPROTECTED_BY_DISC_CONTROL_BLOCK = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_DISC_CONTROL_BLOCK;
pub const IMAPI_WRITEPROTECTED_READ_ONLY_MEDIA = IMAPI_MEDIA_WRITE_PROTECT_STATE.READ_ONLY_MEDIA;

pub const IMAPI_READ_TRACK_ADDRESS_TYPE = enum(i32) {
    LBA = 0,
    TRACK = 1,
    SESSION = 2,
};
pub const IMAPI_READ_TRACK_ADDRESS_TYPE_LBA = IMAPI_READ_TRACK_ADDRESS_TYPE.LBA;
pub const IMAPI_READ_TRACK_ADDRESS_TYPE_TRACK = IMAPI_READ_TRACK_ADDRESS_TYPE.TRACK;
pub const IMAPI_READ_TRACK_ADDRESS_TYPE_SESSION = IMAPI_READ_TRACK_ADDRESS_TYPE.SESSION;

pub const IMAPI_MODE_PAGE_REQUEST_TYPE = enum(i32) {
    CURRENT_VALUES = 0,
    CHANGEABLE_VALUES = 1,
    DEFAULT_VALUES = 2,
    SAVED_VALUES = 3,
};
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_CURRENT_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.CURRENT_VALUES;
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_CHANGEABLE_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.CHANGEABLE_VALUES;
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_DEFAULT_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.DEFAULT_VALUES;
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_SAVED_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.SAVED_VALUES;

pub const IMAPI_MODE_PAGE_TYPE = enum(i32) {
    READ_WRITE_ERROR_RECOVERY = 1,
    MRW = 3,
    WRITE_PARAMETERS = 5,
    CACHING = 8,
    INFORMATIONAL_EXCEPTIONS = 28,
    TIMEOUT_AND_PROTECT = 29,
    POWER_CONDITION = 26,
    LEGACY_CAPABILITIES = 42,
};
pub const IMAPI_MODE_PAGE_TYPE_READ_WRITE_ERROR_RECOVERY = IMAPI_MODE_PAGE_TYPE.READ_WRITE_ERROR_RECOVERY;
pub const IMAPI_MODE_PAGE_TYPE_MRW = IMAPI_MODE_PAGE_TYPE.MRW;
pub const IMAPI_MODE_PAGE_TYPE_WRITE_PARAMETERS = IMAPI_MODE_PAGE_TYPE.WRITE_PARAMETERS;
pub const IMAPI_MODE_PAGE_TYPE_CACHING = IMAPI_MODE_PAGE_TYPE.CACHING;
pub const IMAPI_MODE_PAGE_TYPE_INFORMATIONAL_EXCEPTIONS = IMAPI_MODE_PAGE_TYPE.INFORMATIONAL_EXCEPTIONS;
pub const IMAPI_MODE_PAGE_TYPE_TIMEOUT_AND_PROTECT = IMAPI_MODE_PAGE_TYPE.TIMEOUT_AND_PROTECT;
pub const IMAPI_MODE_PAGE_TYPE_POWER_CONDITION = IMAPI_MODE_PAGE_TYPE.POWER_CONDITION;
pub const IMAPI_MODE_PAGE_TYPE_LEGACY_CAPABILITIES = IMAPI_MODE_PAGE_TYPE.LEGACY_CAPABILITIES;

pub const IMAPI_FEATURE_PAGE_TYPE = enum(i32) {
    PROFILE_LIST = 0,
    CORE = 1,
    MORPHING = 2,
    REMOVABLE_MEDIUM = 3,
    WRITE_PROTECT = 4,
    RANDOMLY_READABLE = 16,
    CD_MULTIREAD = 29,
    CD_READ = 30,
    DVD_READ = 31,
    RANDOMLY_WRITABLE = 32,
    INCREMENTAL_STREAMING_WRITABLE = 33,
    SECTOR_ERASABLE = 34,
    FORMATTABLE = 35,
    HARDWARE_DEFECT_MANAGEMENT = 36,
    WRITE_ONCE = 37,
    RESTRICTED_OVERWRITE = 38,
    CDRW_CAV_WRITE = 39,
    MRW = 40,
    ENHANCED_DEFECT_REPORTING = 41,
    DVD_PLUS_RW = 42,
    DVD_PLUS_R = 43,
    RIGID_RESTRICTED_OVERWRITE = 44,
    CD_TRACK_AT_ONCE = 45,
    CD_MASTERING = 46,
    DVD_DASH_WRITE = 47,
    DOUBLE_DENSITY_CD_READ = 48,
    DOUBLE_DENSITY_CD_R_WRITE = 49,
    DOUBLE_DENSITY_CD_RW_WRITE = 50,
    LAYER_JUMP_RECORDING = 51,
    CD_RW_MEDIA_WRITE_SUPPORT = 55,
    BD_PSEUDO_OVERWRITE = 56,
    DVD_PLUS_R_DUAL_LAYER = 59,
    BD_READ = 64,
    BD_WRITE = 65,
    HD_DVD_READ = 80,
    HD_DVD_WRITE = 81,
    POWER_MANAGEMENT = 256,
    SMART = 257,
    EMBEDDED_CHANGER = 258,
    CD_ANALOG_PLAY = 259,
    MICROCODE_UPDATE = 260,
    TIMEOUT = 261,
    DVD_CSS = 262,
    REAL_TIME_STREAMING = 263,
    LOGICAL_UNIT_SERIAL_NUMBER = 264,
    MEDIA_SERIAL_NUMBER = 265,
    DISC_CONTROL_BLOCKS = 266,
    DVD_CPRM = 267,
    FIRMWARE_INFORMATION = 268,
    AACS = 269,
    VCPS = 272,
};
pub const IMAPI_FEATURE_PAGE_TYPE_PROFILE_LIST = IMAPI_FEATURE_PAGE_TYPE.PROFILE_LIST;
pub const IMAPI_FEATURE_PAGE_TYPE_CORE = IMAPI_FEATURE_PAGE_TYPE.CORE;
pub const IMAPI_FEATURE_PAGE_TYPE_MORPHING = IMAPI_FEATURE_PAGE_TYPE.MORPHING;
pub const IMAPI_FEATURE_PAGE_TYPE_REMOVABLE_MEDIUM = IMAPI_FEATURE_PAGE_TYPE.REMOVABLE_MEDIUM;
pub const IMAPI_FEATURE_PAGE_TYPE_WRITE_PROTECT = IMAPI_FEATURE_PAGE_TYPE.WRITE_PROTECT;
pub const IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_READABLE = IMAPI_FEATURE_PAGE_TYPE.RANDOMLY_READABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_MULTIREAD = IMAPI_FEATURE_PAGE_TYPE.CD_MULTIREAD;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_READ = IMAPI_FEATURE_PAGE_TYPE.CD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_READ = IMAPI_FEATURE_PAGE_TYPE.DVD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_WRITABLE = IMAPI_FEATURE_PAGE_TYPE.RANDOMLY_WRITABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_INCREMENTAL_STREAMING_WRITABLE = IMAPI_FEATURE_PAGE_TYPE.INCREMENTAL_STREAMING_WRITABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_SECTOR_ERASABLE = IMAPI_FEATURE_PAGE_TYPE.SECTOR_ERASABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_FORMATTABLE = IMAPI_FEATURE_PAGE_TYPE.FORMATTABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_HARDWARE_DEFECT_MANAGEMENT = IMAPI_FEATURE_PAGE_TYPE.HARDWARE_DEFECT_MANAGEMENT;
pub const IMAPI_FEATURE_PAGE_TYPE_WRITE_ONCE = IMAPI_FEATURE_PAGE_TYPE.WRITE_ONCE;
pub const IMAPI_FEATURE_PAGE_TYPE_RESTRICTED_OVERWRITE = IMAPI_FEATURE_PAGE_TYPE.RESTRICTED_OVERWRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_CDRW_CAV_WRITE = IMAPI_FEATURE_PAGE_TYPE.CDRW_CAV_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_MRW = IMAPI_FEATURE_PAGE_TYPE.MRW;
pub const IMAPI_FEATURE_PAGE_TYPE_ENHANCED_DEFECT_REPORTING = IMAPI_FEATURE_PAGE_TYPE.ENHANCED_DEFECT_REPORTING;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_RW = IMAPI_FEATURE_PAGE_TYPE.DVD_PLUS_RW;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R = IMAPI_FEATURE_PAGE_TYPE.DVD_PLUS_R;
pub const IMAPI_FEATURE_PAGE_TYPE_RIGID_RESTRICTED_OVERWRITE = IMAPI_FEATURE_PAGE_TYPE.RIGID_RESTRICTED_OVERWRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_TRACK_AT_ONCE = IMAPI_FEATURE_PAGE_TYPE.CD_TRACK_AT_ONCE;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_MASTERING = IMAPI_FEATURE_PAGE_TYPE.CD_MASTERING;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_DASH_WRITE = IMAPI_FEATURE_PAGE_TYPE.DVD_DASH_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_READ = IMAPI_FEATURE_PAGE_TYPE.DOUBLE_DENSITY_CD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_R_WRITE = IMAPI_FEATURE_PAGE_TYPE.DOUBLE_DENSITY_CD_R_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_RW_WRITE = IMAPI_FEATURE_PAGE_TYPE.DOUBLE_DENSITY_CD_RW_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_LAYER_JUMP_RECORDING = IMAPI_FEATURE_PAGE_TYPE.LAYER_JUMP_RECORDING;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_RW_MEDIA_WRITE_SUPPORT = IMAPI_FEATURE_PAGE_TYPE.CD_RW_MEDIA_WRITE_SUPPORT;
pub const IMAPI_FEATURE_PAGE_TYPE_BD_PSEUDO_OVERWRITE = IMAPI_FEATURE_PAGE_TYPE.BD_PSEUDO_OVERWRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R_DUAL_LAYER = IMAPI_FEATURE_PAGE_TYPE.DVD_PLUS_R_DUAL_LAYER;
pub const IMAPI_FEATURE_PAGE_TYPE_BD_READ = IMAPI_FEATURE_PAGE_TYPE.BD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_BD_WRITE = IMAPI_FEATURE_PAGE_TYPE.BD_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_HD_DVD_READ = IMAPI_FEATURE_PAGE_TYPE.HD_DVD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_HD_DVD_WRITE = IMAPI_FEATURE_PAGE_TYPE.HD_DVD_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_POWER_MANAGEMENT = IMAPI_FEATURE_PAGE_TYPE.POWER_MANAGEMENT;
pub const IMAPI_FEATURE_PAGE_TYPE_SMART = IMAPI_FEATURE_PAGE_TYPE.SMART;
pub const IMAPI_FEATURE_PAGE_TYPE_EMBEDDED_CHANGER = IMAPI_FEATURE_PAGE_TYPE.EMBEDDED_CHANGER;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_ANALOG_PLAY = IMAPI_FEATURE_PAGE_TYPE.CD_ANALOG_PLAY;
pub const IMAPI_FEATURE_PAGE_TYPE_MICROCODE_UPDATE = IMAPI_FEATURE_PAGE_TYPE.MICROCODE_UPDATE;
pub const IMAPI_FEATURE_PAGE_TYPE_TIMEOUT = IMAPI_FEATURE_PAGE_TYPE.TIMEOUT;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_CSS = IMAPI_FEATURE_PAGE_TYPE.DVD_CSS;
pub const IMAPI_FEATURE_PAGE_TYPE_REAL_TIME_STREAMING = IMAPI_FEATURE_PAGE_TYPE.REAL_TIME_STREAMING;
pub const IMAPI_FEATURE_PAGE_TYPE_LOGICAL_UNIT_SERIAL_NUMBER = IMAPI_FEATURE_PAGE_TYPE.LOGICAL_UNIT_SERIAL_NUMBER;
pub const IMAPI_FEATURE_PAGE_TYPE_MEDIA_SERIAL_NUMBER = IMAPI_FEATURE_PAGE_TYPE.MEDIA_SERIAL_NUMBER;
pub const IMAPI_FEATURE_PAGE_TYPE_DISC_CONTROL_BLOCKS = IMAPI_FEATURE_PAGE_TYPE.DISC_CONTROL_BLOCKS;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_CPRM = IMAPI_FEATURE_PAGE_TYPE.DVD_CPRM;
pub const IMAPI_FEATURE_PAGE_TYPE_FIRMWARE_INFORMATION = IMAPI_FEATURE_PAGE_TYPE.FIRMWARE_INFORMATION;
pub const IMAPI_FEATURE_PAGE_TYPE_AACS = IMAPI_FEATURE_PAGE_TYPE.AACS;
pub const IMAPI_FEATURE_PAGE_TYPE_VCPS = IMAPI_FEATURE_PAGE_TYPE.VCPS;

pub const IMAPI_PROFILE_TYPE = enum(i32) {
    INVALID = 0,
    NON_REMOVABLE_DISK = 1,
    REMOVABLE_DISK = 2,
    MO_ERASABLE = 3,
    MO_WRITE_ONCE = 4,
    AS_MO = 5,
    CDROM = 8,
    CD_RECORDABLE = 9,
    CD_REWRITABLE = 10,
    DVDROM = 16,
    DVD_DASH_RECORDABLE = 17,
    DVD_RAM = 18,
    DVD_DASH_REWRITABLE = 19,
    DVD_DASH_RW_SEQUENTIAL = 20,
    DVD_DASH_R_DUAL_SEQUENTIAL = 21,
    DVD_DASH_R_DUAL_LAYER_JUMP = 22,
    DVD_PLUS_RW = 26,
    DVD_PLUS_R = 27,
    DDCDROM = 32,
    DDCD_RECORDABLE = 33,
    DDCD_REWRITABLE = 34,
    DVD_PLUS_RW_DUAL = 42,
    DVD_PLUS_R_DUAL = 43,
    BD_ROM = 64,
    BD_R_SEQUENTIAL = 65,
    BD_R_RANDOM_RECORDING = 66,
    BD_REWRITABLE = 67,
    HD_DVD_ROM = 80,
    HD_DVD_RECORDABLE = 81,
    HD_DVD_RAM = 82,
    NON_STANDARD = 65535,
};
pub const IMAPI_PROFILE_TYPE_INVALID = IMAPI_PROFILE_TYPE.INVALID;
pub const IMAPI_PROFILE_TYPE_NON_REMOVABLE_DISK = IMAPI_PROFILE_TYPE.NON_REMOVABLE_DISK;
pub const IMAPI_PROFILE_TYPE_REMOVABLE_DISK = IMAPI_PROFILE_TYPE.REMOVABLE_DISK;
pub const IMAPI_PROFILE_TYPE_MO_ERASABLE = IMAPI_PROFILE_TYPE.MO_ERASABLE;
pub const IMAPI_PROFILE_TYPE_MO_WRITE_ONCE = IMAPI_PROFILE_TYPE.MO_WRITE_ONCE;
pub const IMAPI_PROFILE_TYPE_AS_MO = IMAPI_PROFILE_TYPE.AS_MO;
pub const IMAPI_PROFILE_TYPE_CDROM = IMAPI_PROFILE_TYPE.CDROM;
pub const IMAPI_PROFILE_TYPE_CD_RECORDABLE = IMAPI_PROFILE_TYPE.CD_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_CD_REWRITABLE = IMAPI_PROFILE_TYPE.CD_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_DVDROM = IMAPI_PROFILE_TYPE.DVDROM;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_RECORDABLE = IMAPI_PROFILE_TYPE.DVD_DASH_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_DVD_RAM = IMAPI_PROFILE_TYPE.DVD_RAM;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_REWRITABLE = IMAPI_PROFILE_TYPE.DVD_DASH_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_RW_SEQUENTIAL = IMAPI_PROFILE_TYPE.DVD_DASH_RW_SEQUENTIAL;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_SEQUENTIAL = IMAPI_PROFILE_TYPE.DVD_DASH_R_DUAL_SEQUENTIAL;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_LAYER_JUMP = IMAPI_PROFILE_TYPE.DVD_DASH_R_DUAL_LAYER_JUMP;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_RW = IMAPI_PROFILE_TYPE.DVD_PLUS_RW;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_R = IMAPI_PROFILE_TYPE.DVD_PLUS_R;
pub const IMAPI_PROFILE_TYPE_DDCDROM = IMAPI_PROFILE_TYPE.DDCDROM;
pub const IMAPI_PROFILE_TYPE_DDCD_RECORDABLE = IMAPI_PROFILE_TYPE.DDCD_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_DDCD_REWRITABLE = IMAPI_PROFILE_TYPE.DDCD_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_RW_DUAL = IMAPI_PROFILE_TYPE.DVD_PLUS_RW_DUAL;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_R_DUAL = IMAPI_PROFILE_TYPE.DVD_PLUS_R_DUAL;
pub const IMAPI_PROFILE_TYPE_BD_ROM = IMAPI_PROFILE_TYPE.BD_ROM;
pub const IMAPI_PROFILE_TYPE_BD_R_SEQUENTIAL = IMAPI_PROFILE_TYPE.BD_R_SEQUENTIAL;
pub const IMAPI_PROFILE_TYPE_BD_R_RANDOM_RECORDING = IMAPI_PROFILE_TYPE.BD_R_RANDOM_RECORDING;
pub const IMAPI_PROFILE_TYPE_BD_REWRITABLE = IMAPI_PROFILE_TYPE.BD_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_HD_DVD_ROM = IMAPI_PROFILE_TYPE.HD_DVD_ROM;
pub const IMAPI_PROFILE_TYPE_HD_DVD_RECORDABLE = IMAPI_PROFILE_TYPE.HD_DVD_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_HD_DVD_RAM = IMAPI_PROFILE_TYPE.HD_DVD_RAM;
pub const IMAPI_PROFILE_TYPE_NON_STANDARD = IMAPI_PROFILE_TYPE.NON_STANDARD;

pub const IMAPI_FORMAT2_DATA_WRITE_ACTION = enum(i32) {
    VALIDATING_MEDIA = 0,
    FORMATTING_MEDIA = 1,
    INITIALIZING_HARDWARE = 2,
    CALIBRATING_POWER = 3,
    WRITING_DATA = 4,
    FINALIZATION = 5,
    COMPLETED = 6,
    VERIFYING = 7,
};
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_VALIDATING_MEDIA = IMAPI_FORMAT2_DATA_WRITE_ACTION.VALIDATING_MEDIA;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_FORMATTING_MEDIA = IMAPI_FORMAT2_DATA_WRITE_ACTION.FORMATTING_MEDIA;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_INITIALIZING_HARDWARE = IMAPI_FORMAT2_DATA_WRITE_ACTION.INITIALIZING_HARDWARE;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_CALIBRATING_POWER = IMAPI_FORMAT2_DATA_WRITE_ACTION.CALIBRATING_POWER;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_WRITING_DATA = IMAPI_FORMAT2_DATA_WRITE_ACTION.WRITING_DATA;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_FINALIZATION = IMAPI_FORMAT2_DATA_WRITE_ACTION.FINALIZATION;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_COMPLETED = IMAPI_FORMAT2_DATA_WRITE_ACTION.COMPLETED;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_VERIFYING = IMAPI_FORMAT2_DATA_WRITE_ACTION.VERIFYING;

pub const IMAPI_FORMAT2_DATA_MEDIA_STATE = enum(i32) {
    UNKNOWN = 0,
    INFORMATIONAL_MASK = 15,
    UNSUPPORTED_MASK = 64512,
    OVERWRITE_ONLY = 1,
    // RANDOMLY_WRITABLE = 1, this enum value conflicts with OVERWRITE_ONLY
    BLANK = 2,
    APPENDABLE = 4,
    FINAL_SESSION = 8,
    DAMAGED = 1024,
    ERASE_REQUIRED = 2048,
    NON_EMPTY_SESSION = 4096,
    WRITE_PROTECTED = 8192,
    FINALIZED = 16384,
    UNSUPPORTED_MEDIA = 32768,
};
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_UNKNOWN = IMAPI_FORMAT2_DATA_MEDIA_STATE.UNKNOWN;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_INFORMATIONAL_MASK = IMAPI_FORMAT2_DATA_MEDIA_STATE.INFORMATIONAL_MASK;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MASK = IMAPI_FORMAT2_DATA_MEDIA_STATE.UNSUPPORTED_MASK;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_OVERWRITE_ONLY = IMAPI_FORMAT2_DATA_MEDIA_STATE.OVERWRITE_ONLY;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_RANDOMLY_WRITABLE = IMAPI_FORMAT2_DATA_MEDIA_STATE.OVERWRITE_ONLY;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_BLANK = IMAPI_FORMAT2_DATA_MEDIA_STATE.BLANK;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_APPENDABLE = IMAPI_FORMAT2_DATA_MEDIA_STATE.APPENDABLE;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_FINAL_SESSION = IMAPI_FORMAT2_DATA_MEDIA_STATE.FINAL_SESSION;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_DAMAGED = IMAPI_FORMAT2_DATA_MEDIA_STATE.DAMAGED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_ERASE_REQUIRED = IMAPI_FORMAT2_DATA_MEDIA_STATE.ERASE_REQUIRED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_NON_EMPTY_SESSION = IMAPI_FORMAT2_DATA_MEDIA_STATE.NON_EMPTY_SESSION;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_WRITE_PROTECTED = IMAPI_FORMAT2_DATA_MEDIA_STATE.WRITE_PROTECTED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_FINALIZED = IMAPI_FORMAT2_DATA_MEDIA_STATE.FINALIZED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MEDIA = IMAPI_FORMAT2_DATA_MEDIA_STATE.UNSUPPORTED_MEDIA;

pub const IMAPI_FORMAT2_TAO_WRITE_ACTION = enum(i32) {
    UNKNOWN = 0,
    PREPARING = 1,
    WRITING = 2,
    FINISHING = 3,
    VERIFYING = 4,
};
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_UNKNOWN = IMAPI_FORMAT2_TAO_WRITE_ACTION.UNKNOWN;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_PREPARING = IMAPI_FORMAT2_TAO_WRITE_ACTION.PREPARING;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_WRITING = IMAPI_FORMAT2_TAO_WRITE_ACTION.WRITING;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_FINISHING = IMAPI_FORMAT2_TAO_WRITE_ACTION.FINISHING;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_VERIFYING = IMAPI_FORMAT2_TAO_WRITE_ACTION.VERIFYING;

pub const IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE = enum(i32) {
    PQ_ONLY = 1,
    IS_COOKED = 2,
    IS_RAW = 3,
};
pub const IMAPI_FORMAT2_RAW_CD_SUBCODE_PQ_ONLY = IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE.PQ_ONLY;
pub const IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_COOKED = IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE.IS_COOKED;
pub const IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_RAW = IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE.IS_RAW;

pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION = enum(i32) {
    UNKNOWN = 0,
    PREPARING = 1,
    WRITING = 2,
    FINISHING = 3,
};
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_UNKNOWN = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.UNKNOWN;
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_PREPARING = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.PREPARING;
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_WRITING = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.WRITING;
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_FINISHING = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.FINISHING;

pub const IMAPI_CD_SECTOR_TYPE = enum(i32) {
    AUDIO = 0,
    MODE_ZERO = 1,
    MODE1 = 2,
    MODE2FORM0 = 3,
    MODE2FORM1 = 4,
    MODE2FORM2 = 5,
    MODE1RAW = 6,
    MODE2FORM0RAW = 7,
    MODE2FORM1RAW = 8,
    MODE2FORM2RAW = 9,
};
pub const IMAPI_CD_SECTOR_AUDIO = IMAPI_CD_SECTOR_TYPE.AUDIO;
pub const IMAPI_CD_SECTOR_MODE_ZERO = IMAPI_CD_SECTOR_TYPE.MODE_ZERO;
pub const IMAPI_CD_SECTOR_MODE1 = IMAPI_CD_SECTOR_TYPE.MODE1;
pub const IMAPI_CD_SECTOR_MODE2FORM0 = IMAPI_CD_SECTOR_TYPE.MODE2FORM0;
pub const IMAPI_CD_SECTOR_MODE2FORM1 = IMAPI_CD_SECTOR_TYPE.MODE2FORM1;
pub const IMAPI_CD_SECTOR_MODE2FORM2 = IMAPI_CD_SECTOR_TYPE.MODE2FORM2;
pub const IMAPI_CD_SECTOR_MODE1RAW = IMAPI_CD_SECTOR_TYPE.MODE1RAW;
pub const IMAPI_CD_SECTOR_MODE2FORM0RAW = IMAPI_CD_SECTOR_TYPE.MODE2FORM0RAW;
pub const IMAPI_CD_SECTOR_MODE2FORM1RAW = IMAPI_CD_SECTOR_TYPE.MODE2FORM1RAW;
pub const IMAPI_CD_SECTOR_MODE2FORM2RAW = IMAPI_CD_SECTOR_TYPE.MODE2FORM2RAW;

pub const IMAPI_CD_TRACK_DIGITAL_COPY_SETTING = enum(i32) {
    PERMITTED = 0,
    PROHIBITED = 1,
    SCMS = 2,
};
pub const IMAPI_CD_TRACK_DIGITAL_COPY_PERMITTED = IMAPI_CD_TRACK_DIGITAL_COPY_SETTING.PERMITTED;
pub const IMAPI_CD_TRACK_DIGITAL_COPY_PROHIBITED = IMAPI_CD_TRACK_DIGITAL_COPY_SETTING.PROHIBITED;
pub const IMAPI_CD_TRACK_DIGITAL_COPY_SCMS = IMAPI_CD_TRACK_DIGITAL_COPY_SETTING.SCMS;

pub const IMAPI_BURN_VERIFICATION_LEVEL = enum(i32) {
    NONE = 0,
    QUICK = 1,
    FULL = 2,
};
pub const IMAPI_BURN_VERIFICATION_NONE = IMAPI_BURN_VERIFICATION_LEVEL.NONE;
pub const IMAPI_BURN_VERIFICATION_QUICK = IMAPI_BURN_VERIFICATION_LEVEL.QUICK;
pub const IMAPI_BURN_VERIFICATION_FULL = IMAPI_BURN_VERIFICATION_LEVEL.FULL;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscMaster2_Value = @import("../zig.zig").Guid.initString("27354130-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscMaster2 = &IID_IDiscMaster2_Value;
pub const IDiscMaster2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IDiscMaster2,
            ppunk: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IDiscMaster2,
            index: i32,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IDiscMaster2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSupportedEnvironment: fn(
            self: *const IDiscMaster2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster2_get__NewEnum(self: *const T, ppunk: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster2.VTable, self.vtable).get__NewEnum(@ptrCast(*const IDiscMaster2, self), ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster2_get_Item(self: *const T, index: i32, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster2.VTable, self.vtable).get_Item(@ptrCast(*const IDiscMaster2, self), index, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster2_get_Count(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster2.VTable, self.vtable).get_Count(@ptrCast(*const IDiscMaster2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster2_get_IsSupportedEnvironment(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster2.VTable, self.vtable).get_IsSupportedEnvironment(@ptrCast(*const IDiscMaster2, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscMaster2Events_Value = @import("../zig.zig").Guid.initString("27354131-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscMaster2Events = &IID_DDiscMaster2Events_Value;
pub const DDiscMaster2Events = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        NotifyDeviceAdded: fn(
            self: *const DDiscMaster2Events,
            object: ?*IDispatch,
            uniqueId: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyDeviceRemoved: fn(
            self: *const DDiscMaster2Events,
            object: ?*IDispatch,
            uniqueId: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscMaster2Events_NotifyDeviceAdded(self: *const T, object: ?*IDispatch, uniqueId: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const DDiscMaster2Events.VTable, self.vtable).NotifyDeviceAdded(@ptrCast(*const DDiscMaster2Events, self), object, uniqueId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscMaster2Events_NotifyDeviceRemoved(self: *const T, object: ?*IDispatch, uniqueId: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const DDiscMaster2Events.VTable, self.vtable).NotifyDeviceRemoved(@ptrCast(*const DDiscMaster2Events, self), object, uniqueId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscRecorder2Ex_Value = @import("../zig.zig").Guid.initString("27354132-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscRecorder2Ex = &IID_IDiscRecorder2Ex_Value;
pub const IDiscRecorder2Ex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SendCommandNoData: fn(
            self: *const IDiscRecorder2Ex,
            Cdb: [*:0]u8,
            CdbSize: u32,
            SenseBuffer: *[18]u8,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendCommandSendDataToDevice: fn(
            self: *const IDiscRecorder2Ex,
            Cdb: [*:0]u8,
            CdbSize: u32,
            SenseBuffer: *[18]u8,
            Timeout: u32,
            Buffer: [*:0]u8,
            BufferSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendCommandGetDataFromDevice: fn(
            self: *const IDiscRecorder2Ex,
            Cdb: [*:0]u8,
            CdbSize: u32,
            SenseBuffer: *[18]u8,
            Timeout: u32,
            Buffer: [*:0]u8,
            BufferSize: u32,
            BufferFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadDvdStructure: fn(
            self: *const IDiscRecorder2Ex,
            format: u32,
            address: u32,
            layer: u32,
            agid: u32,
            data: ?[*]?*u8,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendDvdStructure: fn(
            self: *const IDiscRecorder2Ex,
            format: u32,
            data: [*:0]u8,
            count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdapterDescriptor: fn(
            self: *const IDiscRecorder2Ex,
            data: ?[*]?*u8,
            byteSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceDescriptor: fn(
            self: *const IDiscRecorder2Ex,
            data: ?[*]?*u8,
            byteSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDiscInformation: fn(
            self: *const IDiscRecorder2Ex,
            discInformation: ?[*]?*u8,
            byteSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrackInformation: fn(
            self: *const IDiscRecorder2Ex,
            address: u32,
            addressType: IMAPI_READ_TRACK_ADDRESS_TYPE,
            trackInformation: ?[*]?*u8,
            byteSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFeaturePage: fn(
            self: *const IDiscRecorder2Ex,
            requestedFeature: IMAPI_FEATURE_PAGE_TYPE,
            currentFeatureOnly: BOOLEAN,
            featureData: ?[*]?*u8,
            byteSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModePage: fn(
            self: *const IDiscRecorder2Ex,
            requestedModePage: IMAPI_MODE_PAGE_TYPE,
            requestType: IMAPI_MODE_PAGE_REQUEST_TYPE,
            modePageData: ?[*]?*u8,
            byteSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModePage: fn(
            self: *const IDiscRecorder2Ex,
            requestType: IMAPI_MODE_PAGE_REQUEST_TYPE,
            data: [*:0]u8,
            byteSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedFeaturePages: fn(
            self: *const IDiscRecorder2Ex,
            currentFeatureOnly: BOOLEAN,
            featureData: ?[*]?*IMAPI_FEATURE_PAGE_TYPE,
            byteSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProfiles: fn(
            self: *const IDiscRecorder2Ex,
            currentOnly: BOOLEAN,
            profileTypes: ?[*]?*IMAPI_PROFILE_TYPE,
            validProfiles: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedModePages: fn(
            self: *const IDiscRecorder2Ex,
            requestType: IMAPI_MODE_PAGE_REQUEST_TYPE,
            modePageTypes: ?[*]?*IMAPI_MODE_PAGE_TYPE,
            validPages: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetByteAlignmentMask: fn(
            self: *const IDiscRecorder2Ex,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaximumNonPageAlignedTransferSize: fn(
            self: *const IDiscRecorder2Ex,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaximumPageAlignedTransferSize: fn(
            self: *const IDiscRecorder2Ex,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SendCommandNoData(self: *const T, Cdb: [*:0]u8, CdbSize: u32, SenseBuffer: *[18]u8, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).SendCommandNoData(@ptrCast(*const IDiscRecorder2Ex, self), Cdb, CdbSize, SenseBuffer, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SendCommandSendDataToDevice(self: *const T, Cdb: [*:0]u8, CdbSize: u32, SenseBuffer: *[18]u8, Timeout: u32, Buffer: [*:0]u8, BufferSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).SendCommandSendDataToDevice(@ptrCast(*const IDiscRecorder2Ex, self), Cdb, CdbSize, SenseBuffer, Timeout, Buffer, BufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SendCommandGetDataFromDevice(self: *const T, Cdb: [*:0]u8, CdbSize: u32, SenseBuffer: *[18]u8, Timeout: u32, Buffer: [*:0]u8, BufferSize: u32, BufferFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).SendCommandGetDataFromDevice(@ptrCast(*const IDiscRecorder2Ex, self), Cdb, CdbSize, SenseBuffer, Timeout, Buffer, BufferSize, BufferFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_ReadDvdStructure(self: *const T, format: u32, address: u32, layer: u32, agid: u32, data: ?[*]?*u8, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).ReadDvdStructure(@ptrCast(*const IDiscRecorder2Ex, self), format, address, layer, agid, data, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SendDvdStructure(self: *const T, format: u32, data: [*:0]u8, count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).SendDvdStructure(@ptrCast(*const IDiscRecorder2Ex, self), format, data, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetAdapterDescriptor(self: *const T, data: ?[*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetAdapterDescriptor(@ptrCast(*const IDiscRecorder2Ex, self), data, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetDeviceDescriptor(self: *const T, data: ?[*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetDeviceDescriptor(@ptrCast(*const IDiscRecorder2Ex, self), data, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetDiscInformation(self: *const T, discInformation: ?[*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetDiscInformation(@ptrCast(*const IDiscRecorder2Ex, self), discInformation, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetTrackInformation(self: *const T, address: u32, addressType: IMAPI_READ_TRACK_ADDRESS_TYPE, trackInformation: ?[*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetTrackInformation(@ptrCast(*const IDiscRecorder2Ex, self), address, addressType, trackInformation, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetFeaturePage(self: *const T, requestedFeature: IMAPI_FEATURE_PAGE_TYPE, currentFeatureOnly: BOOLEAN, featureData: ?[*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetFeaturePage(@ptrCast(*const IDiscRecorder2Ex, self), requestedFeature, currentFeatureOnly, featureData, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetModePage(self: *const T, requestedModePage: IMAPI_MODE_PAGE_TYPE, requestType: IMAPI_MODE_PAGE_REQUEST_TYPE, modePageData: ?[*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetModePage(@ptrCast(*const IDiscRecorder2Ex, self), requestedModePage, requestType, modePageData, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SetModePage(self: *const T, requestType: IMAPI_MODE_PAGE_REQUEST_TYPE, data: [*:0]u8, byteSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).SetModePage(@ptrCast(*const IDiscRecorder2Ex, self), requestType, data, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetSupportedFeaturePages(self: *const T, currentFeatureOnly: BOOLEAN, featureData: ?[*]?*IMAPI_FEATURE_PAGE_TYPE, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetSupportedFeaturePages(@ptrCast(*const IDiscRecorder2Ex, self), currentFeatureOnly, featureData, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetSupportedProfiles(self: *const T, currentOnly: BOOLEAN, profileTypes: ?[*]?*IMAPI_PROFILE_TYPE, validProfiles: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetSupportedProfiles(@ptrCast(*const IDiscRecorder2Ex, self), currentOnly, profileTypes, validProfiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetSupportedModePages(self: *const T, requestType: IMAPI_MODE_PAGE_REQUEST_TYPE, modePageTypes: ?[*]?*IMAPI_MODE_PAGE_TYPE, validPages: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetSupportedModePages(@ptrCast(*const IDiscRecorder2Ex, self), requestType, modePageTypes, validPages);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetByteAlignmentMask(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetByteAlignmentMask(@ptrCast(*const IDiscRecorder2Ex, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetMaximumNonPageAlignedTransferSize(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetMaximumNonPageAlignedTransferSize(@ptrCast(*const IDiscRecorder2Ex, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetMaximumPageAlignedTransferSize(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2Ex.VTable, self.vtable).GetMaximumPageAlignedTransferSize(@ptrCast(*const IDiscRecorder2Ex, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscRecorder2_Value = @import("../zig.zig").Guid.initString("27354133-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscRecorder2 = &IID_IDiscRecorder2_Value;
pub const IDiscRecorder2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        EjectMedia: fn(
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseTray: fn(
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AcquireExclusiveAccess: fn(
            self: *const IDiscRecorder2,
            force: i16,
            __MIDL__IDiscRecorder20000: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseExclusiveAccess: fn(
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableMcn: fn(
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableMcn: fn(
            self: *const IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDiscRecorder: fn(
            self: *const IDiscRecorder2,
            recorderUniqueId: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveDiscRecorder: fn(
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VendorId: fn(
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductId: fn(
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductRevision: fn(
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeName: fn(
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumePathNames: fn(
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceCanLoadMedia: fn(
            self: *const IDiscRecorder2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LegacyDeviceNumber: fn(
            self: *const IDiscRecorder2,
            legacyDeviceNumber: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedFeaturePages: fn(
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFeaturePages: fn(
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedProfiles: fn(
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProfiles: fn(
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedModePages: fn(
            self: *const IDiscRecorder2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExclusiveAccessOwner: fn(
            self: *const IDiscRecorder2,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_EjectMedia(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).EjectMedia(@ptrCast(*const IDiscRecorder2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_CloseTray(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).CloseTray(@ptrCast(*const IDiscRecorder2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_AcquireExclusiveAccess(self: *const T, force: i16, __MIDL__IDiscRecorder20000: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).AcquireExclusiveAccess(@ptrCast(*const IDiscRecorder2, self), force, __MIDL__IDiscRecorder20000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_ReleaseExclusiveAccess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).ReleaseExclusiveAccess(@ptrCast(*const IDiscRecorder2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_DisableMcn(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).DisableMcn(@ptrCast(*const IDiscRecorder2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_EnableMcn(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).EnableMcn(@ptrCast(*const IDiscRecorder2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_InitializeDiscRecorder(self: *const T, recorderUniqueId: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).InitializeDiscRecorder(@ptrCast(*const IDiscRecorder2, self), recorderUniqueId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_ActiveDiscRecorder(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_ActiveDiscRecorder(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_VendorId(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_VendorId(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_ProductId(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_ProductId(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_ProductRevision(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_ProductRevision(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_VolumeName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_VolumeName(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_VolumePathNames(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_VolumePathNames(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_DeviceCanLoadMedia(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_DeviceCanLoadMedia(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_LegacyDeviceNumber(self: *const T, legacyDeviceNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_LegacyDeviceNumber(@ptrCast(*const IDiscRecorder2, self), legacyDeviceNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_SupportedFeaturePages(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_SupportedFeaturePages(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_CurrentFeaturePages(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_CurrentFeaturePages(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_SupportedProfiles(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_SupportedProfiles(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_CurrentProfiles(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_CurrentProfiles(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_SupportedModePages(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_SupportedModePages(@ptrCast(*const IDiscRecorder2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_ExclusiveAccessOwner(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder2.VTable, self.vtable).get_ExclusiveAccessOwner(@ptrCast(*const IDiscRecorder2, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWriteEngine2_Value = @import("../zig.zig").Guid.initString("27354135-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IWriteEngine2 = &IID_IWriteEngine2_Value;
pub const IWriteEngine2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        WriteSection: fn(
            self: *const IWriteEngine2,
            data: ?*IStream,
            startingBlockAddress: i32,
            numberOfBlocks: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelWrite: fn(
            self: *const IWriteEngine2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: fn(
            self: *const IWriteEngine2,
            value: ?*IDiscRecorder2Ex,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: fn(
            self: *const IWriteEngine2,
            value: ?*?*IDiscRecorder2Ex,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseStreamingWrite12: fn(
            self: *const IWriteEngine2,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseStreamingWrite12: fn(
            self: *const IWriteEngine2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartingSectorsPerSecond: fn(
            self: *const IWriteEngine2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartingSectorsPerSecond: fn(
            self: *const IWriteEngine2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EndingSectorsPerSecond: fn(
            self: *const IWriteEngine2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EndingSectorsPerSecond: fn(
            self: *const IWriteEngine2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BytesPerSector: fn(
            self: *const IWriteEngine2,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BytesPerSector: fn(
            self: *const IWriteEngine2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteInProgress: fn(
            self: *const IWriteEngine2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_WriteSection(self: *const T, data: ?*IStream, startingBlockAddress: i32, numberOfBlocks: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).WriteSection(@ptrCast(*const IWriteEngine2, self), data, startingBlockAddress, numberOfBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_CancelWrite(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).CancelWrite(@ptrCast(*const IWriteEngine2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_Recorder(self: *const T, value: ?*IDiscRecorder2Ex) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).put_Recorder(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2Ex) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).get_Recorder(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_UseStreamingWrite12(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).put_UseStreamingWrite12(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_UseStreamingWrite12(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).get_UseStreamingWrite12(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_StartingSectorsPerSecond(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).put_StartingSectorsPerSecond(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_StartingSectorsPerSecond(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).get_StartingSectorsPerSecond(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_EndingSectorsPerSecond(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).put_EndingSectorsPerSecond(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_EndingSectorsPerSecond(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).get_EndingSectorsPerSecond(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_BytesPerSector(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).put_BytesPerSector(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_BytesPerSector(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).get_BytesPerSector(@ptrCast(*const IWriteEngine2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_WriteInProgress(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2.VTable, self.vtable).get_WriteInProgress(@ptrCast(*const IWriteEngine2, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWriteEngine2EventArgs_Value = @import("../zig.zig").Guid.initString("27354136-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IWriteEngine2EventArgs = &IID_IWriteEngine2EventArgs_Value;
pub const IWriteEngine2EventArgs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartLba: fn(
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SectorCount: fn(
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastReadLba: fn(
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenLba: fn(
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSystemBuffer: fn(
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsedSystemBuffer: fn(
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSystemBuffer: fn(
            self: *const IWriteEngine2EventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_StartLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2EventArgs.VTable, self.vtable).get_StartLba(@ptrCast(*const IWriteEngine2EventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_SectorCount(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2EventArgs.VTable, self.vtable).get_SectorCount(@ptrCast(*const IWriteEngine2EventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_LastReadLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2EventArgs.VTable, self.vtable).get_LastReadLba(@ptrCast(*const IWriteEngine2EventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_LastWrittenLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2EventArgs.VTable, self.vtable).get_LastWrittenLba(@ptrCast(*const IWriteEngine2EventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_TotalSystemBuffer(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2EventArgs.VTable, self.vtable).get_TotalSystemBuffer(@ptrCast(*const IWriteEngine2EventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_UsedSystemBuffer(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2EventArgs.VTable, self.vtable).get_UsedSystemBuffer(@ptrCast(*const IWriteEngine2EventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_FreeSystemBuffer(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteEngine2EventArgs.VTable, self.vtable).get_FreeSystemBuffer(@ptrCast(*const IWriteEngine2EventArgs, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DWriteEngine2Events_Value = @import("../zig.zig").Guid.initString("27354137-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DWriteEngine2Events = &IID_DWriteEngine2Events_Value;
pub const DWriteEngine2Events = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: fn(
            self: *const DWriteEngine2Events,
            object: ?*IDispatch,
            progress: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DWriteEngine2Events_Update(self: *const T, object: ?*IDispatch, progress: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const DWriteEngine2Events.VTable, self.vtable).Update(@ptrCast(*const DWriteEngine2Events, self), object, progress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2_Value = @import("../zig.zig").Guid.initString("27354152-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2 = &IID_IDiscFormat2_Value;
pub const IDiscFormat2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        IsRecorderSupported: fn(
            self: *const IDiscFormat2,
            recorder: ?*IDiscRecorder2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCurrentMediaSupported: fn(
            self: *const IDiscFormat2,
            recorder: ?*IDiscRecorder2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaPhysicallyBlank: fn(
            self: *const IDiscFormat2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaHeuristicallyBlank: fn(
            self: *const IDiscFormat2,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedMediaTypes: fn(
            self: *const IDiscFormat2,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_IsRecorderSupported(self: *const T, recorder: ?*IDiscRecorder2, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2.VTable, self.vtable).IsRecorderSupported(@ptrCast(*const IDiscFormat2, self), recorder, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_IsCurrentMediaSupported(self: *const T, recorder: ?*IDiscRecorder2, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2.VTable, self.vtable).IsCurrentMediaSupported(@ptrCast(*const IDiscFormat2, self), recorder, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_get_MediaPhysicallyBlank(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2.VTable, self.vtable).get_MediaPhysicallyBlank(@ptrCast(*const IDiscFormat2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_get_MediaHeuristicallyBlank(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2.VTable, self.vtable).get_MediaHeuristicallyBlank(@ptrCast(*const IDiscFormat2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_get_SupportedMediaTypes(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2.VTable, self.vtable).get_SupportedMediaTypes(@ptrCast(*const IDiscFormat2, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2Erase_Value = @import("../zig.zig").Guid.initString("27354156-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2Erase = &IID_IDiscFormat2Erase_Value;
pub const IDiscFormat2Erase = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: fn(
            self: *const IDiscFormat2Erase,
            value: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: fn(
            self: *const IDiscFormat2Erase,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FullErase: fn(
            self: *const IDiscFormat2Erase,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullErase: fn(
            self: *const IDiscFormat2Erase,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: fn(
            self: *const IDiscFormat2Erase,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: fn(
            self: *const IDiscFormat2Erase,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: fn(
            self: *const IDiscFormat2Erase,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EraseMedia: fn(
            self: *const IDiscFormat2Erase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDiscFormat2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_put_Recorder(self: *const T, value: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Erase.VTable, self.vtable).put_Recorder(@ptrCast(*const IDiscFormat2Erase, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Erase.VTable, self.vtable).get_Recorder(@ptrCast(*const IDiscFormat2Erase, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_put_FullErase(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Erase.VTable, self.vtable).put_FullErase(@ptrCast(*const IDiscFormat2Erase, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_get_FullErase(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Erase.VTable, self.vtable).get_FullErase(@ptrCast(*const IDiscFormat2Erase, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_get_CurrentPhysicalMediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Erase.VTable, self.vtable).get_CurrentPhysicalMediaType(@ptrCast(*const IDiscFormat2Erase, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_put_ClientName(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Erase.VTable, self.vtable).put_ClientName(@ptrCast(*const IDiscFormat2Erase, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_get_ClientName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Erase.VTable, self.vtable).get_ClientName(@ptrCast(*const IDiscFormat2Erase, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_EraseMedia(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Erase.VTable, self.vtable).EraseMedia(@ptrCast(*const IDiscFormat2Erase, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2EraseEvents_Value = @import("../zig.zig").Guid.initString("2735413a-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2EraseEvents = &IID_DDiscFormat2EraseEvents_Value;
pub const DDiscFormat2EraseEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: fn(
            self: *const DDiscFormat2EraseEvents,
            object: ?*IDispatch,
            elapsedSeconds: i32,
            estimatedTotalSeconds: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscFormat2EraseEvents_Update(self: *const T, object: ?*IDispatch, elapsedSeconds: i32, estimatedTotalSeconds: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const DDiscFormat2EraseEvents.VTable, self.vtable).Update(@ptrCast(*const DDiscFormat2EraseEvents, self), object, elapsedSeconds, estimatedTotalSeconds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2Data_Value = @import("../zig.zig").Guid.initString("27354153-9f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2Data = &IID_IDiscFormat2Data_Value;
pub const IDiscFormat2Data = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: fn(
            self: *const IDiscFormat2Data,
            value: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: fn(
            self: *const IDiscFormat2Data,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferUnderrunFreeDisabled: fn(
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferUnderrunFreeDisabled: fn(
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PostgapAlreadyInImage: fn(
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PostgapAlreadyInImage: fn(
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentMediaStatus: fn(
            self: *const IDiscFormat2Data,
            value: ?*IMAPI_FORMAT2_DATA_MEDIA_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteProtectStatus: fn(
            self: *const IDiscFormat2Data,
            value: ?*IMAPI_MEDIA_WRITE_PROTECT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSectorsOnMedia: fn(
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSectorsOnMedia: fn(
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextWritableAddress: fn(
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAddressOfPreviousSession: fn(
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenAddressOfPreviousSession: fn(
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ForceMediaToBeClosed: fn(
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForceMediaToBeClosed: fn(
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisableConsumerDvdCompatibilityMode: fn(
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisableConsumerDvdCompatibilityMode: fn(
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: fn(
            self: *const IDiscFormat2Data,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: fn(
            self: *const IDiscFormat2Data,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: fn(
            self: *const IDiscFormat2Data,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedWriteSpeed: fn(
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedRotationTypeIsPureCAV: fn(
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWriteSpeed: fn(
            self: *const IDiscFormat2Data,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRotationTypeIsPureCAV: fn(
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeeds: fn(
            self: *const IDiscFormat2Data,
            supportedSpeeds: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeedDescriptors: fn(
            self: *const IDiscFormat2Data,
            supportedSpeedDescriptors: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ForceOverwrite: fn(
            self: *const IDiscFormat2Data,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForceOverwrite: fn(
            self: *const IDiscFormat2Data,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MultisessionInterfaces: fn(
            self: *const IDiscFormat2Data,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const IDiscFormat2Data,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelWrite: fn(
            self: *const IDiscFormat2Data,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWriteSpeed: fn(
            self: *const IDiscFormat2Data,
            RequestedSectorsPerSecond: i32,
            RotationTypeIsPureCAV: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDiscFormat2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_Recorder(self: *const T, value: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).put_Recorder(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_Recorder(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_BufferUnderrunFreeDisabled(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).put_BufferUnderrunFreeDisabled(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_BufferUnderrunFreeDisabled(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_BufferUnderrunFreeDisabled(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_PostgapAlreadyInImage(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).put_PostgapAlreadyInImage(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_PostgapAlreadyInImage(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_PostgapAlreadyInImage(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_CurrentMediaStatus(self: *const T, value: ?*IMAPI_FORMAT2_DATA_MEDIA_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_CurrentMediaStatus(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_WriteProtectStatus(self: *const T, value: ?*IMAPI_MEDIA_WRITE_PROTECT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_WriteProtectStatus(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_TotalSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_TotalSectorsOnMedia(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_FreeSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_FreeSectorsOnMedia(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_NextWritableAddress(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_NextWritableAddress(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_StartAddressOfPreviousSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_StartAddressOfPreviousSession(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_LastWrittenAddressOfPreviousSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_LastWrittenAddressOfPreviousSession(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_ForceMediaToBeClosed(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).put_ForceMediaToBeClosed(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_ForceMediaToBeClosed(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_ForceMediaToBeClosed(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_DisableConsumerDvdCompatibilityMode(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).put_DisableConsumerDvdCompatibilityMode(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_DisableConsumerDvdCompatibilityMode(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_DisableConsumerDvdCompatibilityMode(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_CurrentPhysicalMediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_CurrentPhysicalMediaType(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_ClientName(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).put_ClientName(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_ClientName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_ClientName(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_RequestedWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_RequestedWriteSpeed(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_RequestedRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_RequestedRotationTypeIsPureCAV(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_CurrentWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_CurrentWriteSpeed(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_CurrentRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_CurrentRotationTypeIsPureCAV(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_SupportedWriteSpeeds(self: *const T, supportedSpeeds: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_SupportedWriteSpeeds(@ptrCast(*const IDiscFormat2Data, self), supportedSpeeds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_SupportedWriteSpeedDescriptors(self: *const T, supportedSpeedDescriptors: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_SupportedWriteSpeedDescriptors(@ptrCast(*const IDiscFormat2Data, self), supportedSpeedDescriptors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_ForceOverwrite(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).put_ForceOverwrite(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_ForceOverwrite(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_ForceOverwrite(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_MultisessionInterfaces(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).get_MultisessionInterfaces(@ptrCast(*const IDiscFormat2Data, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_Write(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).Write(@ptrCast(*const IDiscFormat2Data, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_CancelWrite(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).CancelWrite(@ptrCast(*const IDiscFormat2Data, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_SetWriteSpeed(self: *const T, RequestedSectorsPerSecond: i32, RotationTypeIsPureCAV: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2Data.VTable, self.vtable).SetWriteSpeed(@ptrCast(*const IDiscFormat2Data, self), RequestedSectorsPerSecond, RotationTypeIsPureCAV);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2DataEvents_Value = @import("../zig.zig").Guid.initString("2735413c-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2DataEvents = &IID_DDiscFormat2DataEvents_Value;
pub const DDiscFormat2DataEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: fn(
            self: *const DDiscFormat2DataEvents,
            object: ?*IDispatch,
            progress: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscFormat2DataEvents_Update(self: *const T, object: ?*IDispatch, progress: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const DDiscFormat2DataEvents.VTable, self.vtable).Update(@ptrCast(*const DDiscFormat2DataEvents, self), object, progress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2DataEventArgs_Value = @import("../zig.zig").Guid.initString("2735413d-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2DataEventArgs = &IID_IDiscFormat2DataEventArgs_Value;
pub const IDiscFormat2DataEventArgs = extern struct {
    pub const VTable = extern struct {
        base: IWriteEngine2EventArgs.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElapsedTime: fn(
            self: *const IDiscFormat2DataEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemainingTime: fn(
            self: *const IDiscFormat2DataEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalTime: fn(
            self: *const IDiscFormat2DataEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: fn(
            self: *const IDiscFormat2DataEventArgs,
            value: ?*IMAPI_FORMAT2_DATA_WRITE_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWriteEngine2EventArgs.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2DataEventArgs_get_ElapsedTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2DataEventArgs.VTable, self.vtable).get_ElapsedTime(@ptrCast(*const IDiscFormat2DataEventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2DataEventArgs_get_RemainingTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2DataEventArgs.VTable, self.vtable).get_RemainingTime(@ptrCast(*const IDiscFormat2DataEventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2DataEventArgs_get_TotalTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2DataEventArgs.VTable, self.vtable).get_TotalTime(@ptrCast(*const IDiscFormat2DataEventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2DataEventArgs_get_CurrentAction(self: *const T, value: ?*IMAPI_FORMAT2_DATA_WRITE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2DataEventArgs.VTable, self.vtable).get_CurrentAction(@ptrCast(*const IDiscFormat2DataEventArgs, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2TrackAtOnce_Value = @import("../zig.zig").Guid.initString("27354154-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2TrackAtOnce = &IID_IDiscFormat2TrackAtOnce_Value;
pub const IDiscFormat2TrackAtOnce = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        PrepareMedia: fn(
            self: *const IDiscFormat2TrackAtOnce,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAudioTrack: fn(
            self: *const IDiscFormat2TrackAtOnce,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelAddTrack: fn(
            self: *const IDiscFormat2TrackAtOnce,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMedia: fn(
            self: *const IDiscFormat2TrackAtOnce,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWriteSpeed: fn(
            self: *const IDiscFormat2TrackAtOnce,
            RequestedSectorsPerSecond: i32,
            RotationTypeIsPureCAV: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferUnderrunFreeDisabled: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferUnderrunFreeDisabled: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfExistingTracks: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSectorsOnMedia: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSectorsOnMedia: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsedSectorsOnMedia: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DoNotFinalizeMedia: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DoNotFinalizeMedia: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpectedTableOfContents: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedWriteSpeed: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedRotationTypeIsPureCAV: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWriteSpeed: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRotationTypeIsPureCAV: fn(
            self: *const IDiscFormat2TrackAtOnce,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeeds: fn(
            self: *const IDiscFormat2TrackAtOnce,
            supportedSpeeds: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeedDescriptors: fn(
            self: *const IDiscFormat2TrackAtOnce,
            supportedSpeedDescriptors: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDiscFormat2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_PrepareMedia(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).PrepareMedia(@ptrCast(*const IDiscFormat2TrackAtOnce, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_AddAudioTrack(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).AddAudioTrack(@ptrCast(*const IDiscFormat2TrackAtOnce, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_CancelAddTrack(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).CancelAddTrack(@ptrCast(*const IDiscFormat2TrackAtOnce, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_ReleaseMedia(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).ReleaseMedia(@ptrCast(*const IDiscFormat2TrackAtOnce, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_SetWriteSpeed(self: *const T, RequestedSectorsPerSecond: i32, RotationTypeIsPureCAV: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).SetWriteSpeed(@ptrCast(*const IDiscFormat2TrackAtOnce, self), RequestedSectorsPerSecond, RotationTypeIsPureCAV);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_put_Recorder(self: *const T, value: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).put_Recorder(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_Recorder(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_put_BufferUnderrunFreeDisabled(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).put_BufferUnderrunFreeDisabled(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_BufferUnderrunFreeDisabled(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_BufferUnderrunFreeDisabled(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_NumberOfExistingTracks(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_NumberOfExistingTracks(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_TotalSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_TotalSectorsOnMedia(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_FreeSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_FreeSectorsOnMedia(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_UsedSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_UsedSectorsOnMedia(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_put_DoNotFinalizeMedia(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).put_DoNotFinalizeMedia(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_DoNotFinalizeMedia(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_DoNotFinalizeMedia(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_ExpectedTableOfContents(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_ExpectedTableOfContents(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_CurrentPhysicalMediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_CurrentPhysicalMediaType(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_put_ClientName(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).put_ClientName(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_ClientName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_ClientName(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_RequestedWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_RequestedWriteSpeed(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_RequestedRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_RequestedRotationTypeIsPureCAV(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_CurrentWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_CurrentWriteSpeed(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_CurrentRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_CurrentRotationTypeIsPureCAV(@ptrCast(*const IDiscFormat2TrackAtOnce, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_SupportedWriteSpeeds(self: *const T, supportedSpeeds: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_SupportedWriteSpeeds(@ptrCast(*const IDiscFormat2TrackAtOnce, self), supportedSpeeds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_SupportedWriteSpeedDescriptors(self: *const T, supportedSpeedDescriptors: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnce.VTable, self.vtable).get_SupportedWriteSpeedDescriptors(@ptrCast(*const IDiscFormat2TrackAtOnce, self), supportedSpeedDescriptors);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2TrackAtOnceEvents_Value = @import("../zig.zig").Guid.initString("2735413f-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2TrackAtOnceEvents = &IID_DDiscFormat2TrackAtOnceEvents_Value;
pub const DDiscFormat2TrackAtOnceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: fn(
            self: *const DDiscFormat2TrackAtOnceEvents,
            object: ?*IDispatch,
            progress: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscFormat2TrackAtOnceEvents_Update(self: *const T, object: ?*IDispatch, progress: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const DDiscFormat2TrackAtOnceEvents.VTable, self.vtable).Update(@ptrCast(*const DDiscFormat2TrackAtOnceEvents, self), object, progress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2TrackAtOnceEventArgs_Value = @import("../zig.zig").Guid.initString("27354140-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2TrackAtOnceEventArgs = &IID_IDiscFormat2TrackAtOnceEventArgs_Value;
pub const IDiscFormat2TrackAtOnceEventArgs = extern struct {
    pub const VTable = extern struct {
        base: IWriteEngine2EventArgs.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTrackNumber: fn(
            self: *const IDiscFormat2TrackAtOnceEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: fn(
            self: *const IDiscFormat2TrackAtOnceEventArgs,
            value: ?*IMAPI_FORMAT2_TAO_WRITE_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElapsedTime: fn(
            self: *const IDiscFormat2TrackAtOnceEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemainingTime: fn(
            self: *const IDiscFormat2TrackAtOnceEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWriteEngine2EventArgs.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnceEventArgs_get_CurrentTrackNumber(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnceEventArgs.VTable, self.vtable).get_CurrentTrackNumber(@ptrCast(*const IDiscFormat2TrackAtOnceEventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnceEventArgs_get_CurrentAction(self: *const T, value: ?*IMAPI_FORMAT2_TAO_WRITE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnceEventArgs.VTable, self.vtable).get_CurrentAction(@ptrCast(*const IDiscFormat2TrackAtOnceEventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnceEventArgs_get_ElapsedTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnceEventArgs.VTable, self.vtable).get_ElapsedTime(@ptrCast(*const IDiscFormat2TrackAtOnceEventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnceEventArgs_get_RemainingTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2TrackAtOnceEventArgs.VTable, self.vtable).get_RemainingTime(@ptrCast(*const IDiscFormat2TrackAtOnceEventArgs, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2RawCD_Value = @import("../zig.zig").Guid.initString("27354155-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2RawCD = &IID_IDiscFormat2RawCD_Value;
pub const IDiscFormat2RawCD = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        PrepareMedia: fn(
            self: *const IDiscFormat2RawCD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMedia: fn(
            self: *const IDiscFormat2RawCD,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMedia2: fn(
            self: *const IDiscFormat2RawCD,
            data: ?*IStream,
            streamLeadInSectors: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelWrite: fn(
            self: *const IDiscFormat2RawCD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMedia: fn(
            self: *const IDiscFormat2RawCD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWriteSpeed: fn(
            self: *const IDiscFormat2RawCD,
            RequestedSectorsPerSecond: i32,
            RotationTypeIsPureCAV: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferUnderrunFreeDisabled: fn(
            self: *const IDiscFormat2RawCD,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferUnderrunFreeDisabled: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartOfNextSession: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastPossibleStartOfLeadout: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedSectorTypes: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequestedSectorType: fn(
            self: *const IDiscFormat2RawCD,
            value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedSectorType: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: fn(
            self: *const IDiscFormat2RawCD,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedWriteSpeed: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedRotationTypeIsPureCAV: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWriteSpeed: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRotationTypeIsPureCAV: fn(
            self: *const IDiscFormat2RawCD,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeeds: fn(
            self: *const IDiscFormat2RawCD,
            supportedSpeeds: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeedDescriptors: fn(
            self: *const IDiscFormat2RawCD,
            supportedSpeedDescriptors: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDiscFormat2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_PrepareMedia(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).PrepareMedia(@ptrCast(*const IDiscFormat2RawCD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_WriteMedia(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).WriteMedia(@ptrCast(*const IDiscFormat2RawCD, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_WriteMedia2(self: *const T, data: ?*IStream, streamLeadInSectors: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).WriteMedia2(@ptrCast(*const IDiscFormat2RawCD, self), data, streamLeadInSectors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_CancelWrite(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).CancelWrite(@ptrCast(*const IDiscFormat2RawCD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_ReleaseMedia(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).ReleaseMedia(@ptrCast(*const IDiscFormat2RawCD, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_SetWriteSpeed(self: *const T, RequestedSectorsPerSecond: i32, RotationTypeIsPureCAV: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).SetWriteSpeed(@ptrCast(*const IDiscFormat2RawCD, self), RequestedSectorsPerSecond, RotationTypeIsPureCAV);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_put_Recorder(self: *const T, value: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).put_Recorder(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_Recorder(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_put_BufferUnderrunFreeDisabled(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).put_BufferUnderrunFreeDisabled(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_BufferUnderrunFreeDisabled(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_BufferUnderrunFreeDisabled(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_StartOfNextSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_StartOfNextSession(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_LastPossibleStartOfLeadout(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_LastPossibleStartOfLeadout(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_CurrentPhysicalMediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_CurrentPhysicalMediaType(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_SupportedSectorTypes(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_SupportedSectorTypes(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_put_RequestedSectorType(self: *const T, value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).put_RequestedSectorType(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_RequestedSectorType(self: *const T, value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_RequestedSectorType(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_put_ClientName(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).put_ClientName(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_ClientName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_ClientName(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_RequestedWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_RequestedWriteSpeed(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_RequestedRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_RequestedRotationTypeIsPureCAV(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_CurrentWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_CurrentWriteSpeed(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_CurrentRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_CurrentRotationTypeIsPureCAV(@ptrCast(*const IDiscFormat2RawCD, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_SupportedWriteSpeeds(self: *const T, supportedSpeeds: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_SupportedWriteSpeeds(@ptrCast(*const IDiscFormat2RawCD, self), supportedSpeeds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_SupportedWriteSpeedDescriptors(self: *const T, supportedSpeedDescriptors: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCD.VTable, self.vtable).get_SupportedWriteSpeedDescriptors(@ptrCast(*const IDiscFormat2RawCD, self), supportedSpeedDescriptors);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2RawCDEvents_Value = @import("../zig.zig").Guid.initString("27354142-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2RawCDEvents = &IID_DDiscFormat2RawCDEvents_Value;
pub const DDiscFormat2RawCDEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: fn(
            self: *const DDiscFormat2RawCDEvents,
            object: ?*IDispatch,
            progress: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscFormat2RawCDEvents_Update(self: *const T, object: ?*IDispatch, progress: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const DDiscFormat2RawCDEvents.VTable, self.vtable).Update(@ptrCast(*const DDiscFormat2RawCDEvents, self), object, progress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2RawCDEventArgs_Value = @import("../zig.zig").Guid.initString("27354143-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2RawCDEventArgs = &IID_IDiscFormat2RawCDEventArgs_Value;
pub const IDiscFormat2RawCDEventArgs = extern struct {
    pub const VTable = extern struct {
        base: IWriteEngine2EventArgs.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: fn(
            self: *const IDiscFormat2RawCDEventArgs,
            value: ?*IMAPI_FORMAT2_RAW_CD_WRITE_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElapsedTime: fn(
            self: *const IDiscFormat2RawCDEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemainingTime: fn(
            self: *const IDiscFormat2RawCDEventArgs,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWriteEngine2EventArgs.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCDEventArgs_get_CurrentAction(self: *const T, value: ?*IMAPI_FORMAT2_RAW_CD_WRITE_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCDEventArgs.VTable, self.vtable).get_CurrentAction(@ptrCast(*const IDiscFormat2RawCDEventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCDEventArgs_get_ElapsedTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCDEventArgs.VTable, self.vtable).get_ElapsedTime(@ptrCast(*const IDiscFormat2RawCDEventArgs, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCDEventArgs_get_RemainingTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscFormat2RawCDEventArgs.VTable, self.vtable).get_RemainingTime(@ptrCast(*const IDiscFormat2RawCDEventArgs, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBurnVerification_Value = @import("../zig.zig").Guid.initString("d2ffd834-958b-426d-8470-2a13879c6a91");
pub const IID_IBurnVerification = &IID_IBurnVerification_Value;
pub const IBurnVerification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BurnVerificationLevel: fn(
            self: *const IBurnVerification,
            value: IMAPI_BURN_VERIFICATION_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BurnVerificationLevel: fn(
            self: *const IBurnVerification,
            value: ?*IMAPI_BURN_VERIFICATION_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBurnVerification_put_BurnVerificationLevel(self: *const T, value: IMAPI_BURN_VERIFICATION_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBurnVerification.VTable, self.vtable).put_BurnVerificationLevel(@ptrCast(*const IBurnVerification, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBurnVerification_get_BurnVerificationLevel(self: *const T, value: ?*IMAPI_BURN_VERIFICATION_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBurnVerification.VTable, self.vtable).get_BurnVerificationLevel(@ptrCast(*const IBurnVerification, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWriteSpeedDescriptor_Value = @import("../zig.zig").Guid.initString("27354144-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IWriteSpeedDescriptor = &IID_IWriteSpeedDescriptor_Value;
pub const IWriteSpeedDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: fn(
            self: *const IWriteSpeedDescriptor,
            value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RotationTypeIsPureCAV: fn(
            self: *const IWriteSpeedDescriptor,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteSpeed: fn(
            self: *const IWriteSpeedDescriptor,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteSpeedDescriptor_get_MediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteSpeedDescriptor.VTable, self.vtable).get_MediaType(@ptrCast(*const IWriteSpeedDescriptor, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteSpeedDescriptor_get_RotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteSpeedDescriptor.VTable, self.vtable).get_RotationTypeIsPureCAV(@ptrCast(*const IWriteSpeedDescriptor, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteSpeedDescriptor_get_WriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWriteSpeedDescriptor.VTable, self.vtable).get_WriteSpeed(@ptrCast(*const IWriteSpeedDescriptor, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMultisession_Value = @import("../zig.zig").Guid.initString("27354150-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IMultisession = &IID_IMultisession_Value;
pub const IMultisession = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSupportedOnCurrentMediaState: fn(
            self: *const IMultisession,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InUse: fn(
            self: *const IMultisession,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InUse: fn(
            self: *const IMultisession,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImportRecorder: fn(
            self: *const IMultisession,
            value: ?*?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisession_get_IsSupportedOnCurrentMediaState(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisession.VTable, self.vtable).get_IsSupportedOnCurrentMediaState(@ptrCast(*const IMultisession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisession_put_InUse(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisession.VTable, self.vtable).put_InUse(@ptrCast(*const IMultisession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisession_get_InUse(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisession.VTable, self.vtable).get_InUse(@ptrCast(*const IMultisession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisession_get_ImportRecorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisession.VTable, self.vtable).get_ImportRecorder(@ptrCast(*const IMultisession, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMultisessionSequential_Value = @import("../zig.zig").Guid.initString("27354151-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IMultisessionSequential = &IID_IMultisessionSequential_Value;
pub const IMultisessionSequential = extern struct {
    pub const VTable = extern struct {
        base: IMultisession.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFirstDataSession: fn(
            self: *const IMultisessionSequential,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAddressOfPreviousSession: fn(
            self: *const IMultisessionSequential,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenAddressOfPreviousSession: fn(
            self: *const IMultisessionSequential,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextWritableAddress: fn(
            self: *const IMultisessionSequential,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSectorsOnMedia: fn(
            self: *const IMultisessionSequential,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMultisession.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_IsFirstDataSession(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisessionSequential.VTable, self.vtable).get_IsFirstDataSession(@ptrCast(*const IMultisessionSequential, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_StartAddressOfPreviousSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisessionSequential.VTable, self.vtable).get_StartAddressOfPreviousSession(@ptrCast(*const IMultisessionSequential, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_LastWrittenAddressOfPreviousSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisessionSequential.VTable, self.vtable).get_LastWrittenAddressOfPreviousSession(@ptrCast(*const IMultisessionSequential, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_NextWritableAddress(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisessionSequential.VTable, self.vtable).get_NextWritableAddress(@ptrCast(*const IMultisessionSequential, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_FreeSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisessionSequential.VTable, self.vtable).get_FreeSectorsOnMedia(@ptrCast(*const IMultisessionSequential, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMultisessionSequential2_Value = @import("../zig.zig").Guid.initString("b507ca22-2204-11dd-966a-001aa01bbc58");
pub const IID_IMultisessionSequential2 = &IID_IMultisessionSequential2_Value;
pub const IMultisessionSequential2 = extern struct {
    pub const VTable = extern struct {
        base: IMultisessionSequential.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteUnitSize: fn(
            self: *const IMultisessionSequential2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMultisessionSequential.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential2_get_WriteUnitSize(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisessionSequential2.VTable, self.vtable).get_WriteUnitSize(@ptrCast(*const IMultisessionSequential2, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMultisessionRandomWrite_Value = @import("../zig.zig").Guid.initString("b507ca23-2204-11dd-966a-001aa01bbc58");
pub const IID_IMultisessionRandomWrite = &IID_IMultisessionRandomWrite_Value;
pub const IMultisessionRandomWrite = extern struct {
    pub const VTable = extern struct {
        base: IMultisession.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteUnitSize: fn(
            self: *const IMultisessionRandomWrite,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenAddress: fn(
            self: *const IMultisessionRandomWrite,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSectorsOnMedia: fn(
            self: *const IMultisessionRandomWrite,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMultisession.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionRandomWrite_get_WriteUnitSize(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisessionRandomWrite.VTable, self.vtable).get_WriteUnitSize(@ptrCast(*const IMultisessionRandomWrite, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionRandomWrite_get_LastWrittenAddress(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisessionRandomWrite.VTable, self.vtable).get_LastWrittenAddress(@ptrCast(*const IMultisessionRandomWrite, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionRandomWrite_get_TotalSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultisessionRandomWrite.VTable, self.vtable).get_TotalSectorsOnMedia(@ptrCast(*const IMultisessionRandomWrite, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamPseudoRandomBased_Value = @import("../zig.zig").Guid.initString("27354145-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IStreamPseudoRandomBased = &IID_IStreamPseudoRandomBased_Value;
pub const IStreamPseudoRandomBased = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Seed: fn(
            self: *const IStreamPseudoRandomBased,
            value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Seed: fn(
            self: *const IStreamPseudoRandomBased,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExtendedSeed: fn(
            self: *const IStreamPseudoRandomBased,
            values: [*]u32,
            eCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtendedSeed: fn(
            self: *const IStreamPseudoRandomBased,
            values: [*]?*u32,
            eCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamPseudoRandomBased_put_Seed(self: *const T, value: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamPseudoRandomBased.VTable, self.vtable).put_Seed(@ptrCast(*const IStreamPseudoRandomBased, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamPseudoRandomBased_get_Seed(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamPseudoRandomBased.VTable, self.vtable).get_Seed(@ptrCast(*const IStreamPseudoRandomBased, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamPseudoRandomBased_put_ExtendedSeed(self: *const T, values: [*]u32, eCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamPseudoRandomBased.VTable, self.vtable).put_ExtendedSeed(@ptrCast(*const IStreamPseudoRandomBased, self), values, eCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamPseudoRandomBased_get_ExtendedSeed(self: *const T, values: [*]?*u32, eCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamPseudoRandomBased.VTable, self.vtable).get_ExtendedSeed(@ptrCast(*const IStreamPseudoRandomBased, self), values, eCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamConcatenate_Value = @import("../zig.zig").Guid.initString("27354146-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IStreamConcatenate = &IID_IStreamConcatenate_Value;
pub const IStreamConcatenate = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        Initialize: fn(
            self: *const IStreamConcatenate,
            stream1: ?*IStream,
            stream2: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize2: fn(
            self: *const IStreamConcatenate,
            streams: [*]?*IStream,
            streamCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: fn(
            self: *const IStreamConcatenate,
            stream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append2: fn(
            self: *const IStreamConcatenate,
            streams: [*]?*IStream,
            streamCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamConcatenate_Initialize(self: *const T, stream1: ?*IStream, stream2: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamConcatenate.VTable, self.vtable).Initialize(@ptrCast(*const IStreamConcatenate, self), stream1, stream2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamConcatenate_Initialize2(self: *const T, streams: [*]?*IStream, streamCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamConcatenate.VTable, self.vtable).Initialize2(@ptrCast(*const IStreamConcatenate, self), streams, streamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamConcatenate_Append(self: *const T, stream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamConcatenate.VTable, self.vtable).Append(@ptrCast(*const IStreamConcatenate, self), stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamConcatenate_Append2(self: *const T, streams: [*]?*IStream, streamCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamConcatenate.VTable, self.vtable).Append2(@ptrCast(*const IStreamConcatenate, self), streams, streamCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamInterleave_Value = @import("../zig.zig").Guid.initString("27354147-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IStreamInterleave = &IID_IStreamInterleave_Value;
pub const IStreamInterleave = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        Initialize: fn(
            self: *const IStreamInterleave,
            streams: [*]?*IStream,
            interleaveSizes: [*]u32,
            streamCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamInterleave_Initialize(self: *const T, streams: [*]?*IStream, interleaveSizes: [*]u32, streamCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamInterleave.VTable, self.vtable).Initialize(@ptrCast(*const IStreamInterleave, self), streams, interleaveSizes, streamCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRawCDImageCreator_Value = @import("../zig.zig").Guid.initString("25983550-9d65-49ce-b335-40630d901227");
pub const IID_IRawCDImageCreator = &IID_IRawCDImageCreator_Value;
pub const IRawCDImageCreator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateResultImage: fn(
            self: *const IRawCDImageCreator,
            resultStream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTrack: fn(
            self: *const IRawCDImageCreator,
            dataType: IMAPI_CD_SECTOR_TYPE,
            data: ?*IStream,
            trackIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSpecialPregap: fn(
            self: *const IRawCDImageCreator,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSubcodeRWGenerator: fn(
            self: *const IRawCDImageCreator,
            subcode: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ResultingImageType: fn(
            self: *const IRawCDImageCreator,
            value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultingImageType: fn(
            self: *const IRawCDImageCreator,
            value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartOfLeadout: fn(
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartOfLeadoutLimit: fn(
            self: *const IRawCDImageCreator,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartOfLeadoutLimit: fn(
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisableGaplessAudio: fn(
            self: *const IRawCDImageCreator,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisableGaplessAudio: fn(
            self: *const IRawCDImageCreator,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaCatalogNumber: fn(
            self: *const IRawCDImageCreator,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaCatalogNumber: fn(
            self: *const IRawCDImageCreator,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartingTrackNumber: fn(
            self: *const IRawCDImageCreator,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartingTrackNumber: fn(
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackInfo: fn(
            self: *const IRawCDImageCreator,
            trackIndex: i32,
            value: ?*?*IRawCDImageTrackInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfExistingTracks: fn(
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastUsedUserSectorInImage: fn(
            self: *const IRawCDImageCreator,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpectedTableOfContents: fn(
            self: *const IRawCDImageCreator,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_CreateResultImage(self: *const T, resultStream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).CreateResultImage(@ptrCast(*const IRawCDImageCreator, self), resultStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_AddTrack(self: *const T, dataType: IMAPI_CD_SECTOR_TYPE, data: ?*IStream, trackIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).AddTrack(@ptrCast(*const IRawCDImageCreator, self), dataType, data, trackIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_AddSpecialPregap(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).AddSpecialPregap(@ptrCast(*const IRawCDImageCreator, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_AddSubcodeRWGenerator(self: *const T, subcode: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).AddSubcodeRWGenerator(@ptrCast(*const IRawCDImageCreator, self), subcode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_ResultingImageType(self: *const T, value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).put_ResultingImageType(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_ResultingImageType(self: *const T, value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_ResultingImageType(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_StartOfLeadout(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_StartOfLeadout(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_StartOfLeadoutLimit(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).put_StartOfLeadoutLimit(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_StartOfLeadoutLimit(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_StartOfLeadoutLimit(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_DisableGaplessAudio(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).put_DisableGaplessAudio(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_DisableGaplessAudio(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_DisableGaplessAudio(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_MediaCatalogNumber(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).put_MediaCatalogNumber(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_MediaCatalogNumber(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_MediaCatalogNumber(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_StartingTrackNumber(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).put_StartingTrackNumber(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_StartingTrackNumber(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_StartingTrackNumber(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_TrackInfo(self: *const T, trackIndex: i32, value: ?*?*IRawCDImageTrackInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_TrackInfo(@ptrCast(*const IRawCDImageCreator, self), trackIndex, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_NumberOfExistingTracks(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_NumberOfExistingTracks(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_LastUsedUserSectorInImage(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_LastUsedUserSectorInImage(@ptrCast(*const IRawCDImageCreator, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_ExpectedTableOfContents(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageCreator.VTable, self.vtable).get_ExpectedTableOfContents(@ptrCast(*const IRawCDImageCreator, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRawCDImageTrackInfo_Value = @import("../zig.zig").Guid.initString("25983551-9d65-49ce-b335-40630d901227");
pub const IID_IRawCDImageTrackInfo = &IID_IRawCDImageTrackInfo_Value;
pub const IRawCDImageTrackInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartingLba: fn(
            self: *const IRawCDImageTrackInfo,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SectorCount: fn(
            self: *const IRawCDImageTrackInfo,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackNumber: fn(
            self: *const IRawCDImageTrackInfo,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SectorType: fn(
            self: *const IRawCDImageTrackInfo,
            value: ?*IMAPI_CD_SECTOR_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ISRC: fn(
            self: *const IRawCDImageTrackInfo,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ISRC: fn(
            self: *const IRawCDImageTrackInfo,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DigitalAudioCopySetting: fn(
            self: *const IRawCDImageTrackInfo,
            value: ?*IMAPI_CD_TRACK_DIGITAL_COPY_SETTING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DigitalAudioCopySetting: fn(
            self: *const IRawCDImageTrackInfo,
            value: IMAPI_CD_TRACK_DIGITAL_COPY_SETTING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioHasPreemphasis: fn(
            self: *const IRawCDImageTrackInfo,
            value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioHasPreemphasis: fn(
            self: *const IRawCDImageTrackInfo,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackIndexes: fn(
            self: *const IRawCDImageTrackInfo,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTrackIndex: fn(
            self: *const IRawCDImageTrackInfo,
            lbaOffset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearTrackIndex: fn(
            self: *const IRawCDImageTrackInfo,
            lbaOffset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_StartingLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).get_StartingLba(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_SectorCount(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).get_SectorCount(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_TrackNumber(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).get_TrackNumber(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_SectorType(self: *const T, value: ?*IMAPI_CD_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).get_SectorType(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_ISRC(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).get_ISRC(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_put_ISRC(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).put_ISRC(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_DigitalAudioCopySetting(self: *const T, value: ?*IMAPI_CD_TRACK_DIGITAL_COPY_SETTING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).get_DigitalAudioCopySetting(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_put_DigitalAudioCopySetting(self: *const T, value: IMAPI_CD_TRACK_DIGITAL_COPY_SETTING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).put_DigitalAudioCopySetting(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_AudioHasPreemphasis(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).get_AudioHasPreemphasis(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_put_AudioHasPreemphasis(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).put_AudioHasPreemphasis(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_TrackIndexes(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).get_TrackIndexes(@ptrCast(*const IRawCDImageTrackInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_AddTrackIndex(self: *const T, lbaOffset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).AddTrackIndex(@ptrCast(*const IRawCDImageTrackInfo, self), lbaOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_ClearTrackIndex(self: *const T, lbaOffset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawCDImageTrackInfo.VTable, self.vtable).ClearTrackIndex(@ptrCast(*const IRawCDImageTrackInfo, self), lbaOffset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBlockRange_Value = @import("../zig.zig").Guid.initString("b507ca25-2204-11dd-966a-001aa01bbc58");
pub const IID_IBlockRange = &IID_IBlockRange_Value;
pub const IBlockRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartLba: fn(
            self: *const IBlockRange,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EndLba: fn(
            self: *const IBlockRange,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockRange_get_StartLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockRange.VTable, self.vtable).get_StartLba(@ptrCast(*const IBlockRange, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockRange_get_EndLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockRange.VTable, self.vtable).get_EndLba(@ptrCast(*const IBlockRange, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBlockRangeList_Value = @import("../zig.zig").Guid.initString("b507ca26-2204-11dd-966a-001aa01bbc58");
pub const IID_IBlockRangeList = &IID_IBlockRangeList_Value;
pub const IBlockRangeList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockRanges: fn(
            self: *const IBlockRangeList,
            value: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockRangeList_get_BlockRanges(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockRangeList.VTable, self.vtable).get_BlockRanges(@ptrCast(*const IBlockRangeList, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BootOptions_Value = @import("../zig.zig").Guid.initString("2c941fce-975b-59be-a960-9a2a262853a5");
pub const CLSID_BootOptions = &CLSID_BootOptions_Value;

const CLSID_FsiStream_Value = @import("../zig.zig").Guid.initString("2c941fcd-975b-59be-a960-9a2a262853a5");
pub const CLSID_FsiStream = &CLSID_FsiStream_Value;

const CLSID_FileSystemImageResult_Value = @import("../zig.zig").Guid.initString("2c941fcc-975b-59be-a960-9a2a262853a5");
pub const CLSID_FileSystemImageResult = &CLSID_FileSystemImageResult_Value;

const CLSID_ProgressItem_Value = @import("../zig.zig").Guid.initString("2c941fcb-975b-59be-a960-9a2a262853a5");
pub const CLSID_ProgressItem = &CLSID_ProgressItem_Value;

const CLSID_EnumProgressItems_Value = @import("../zig.zig").Guid.initString("2c941fca-975b-59be-a960-9a2a262853a5");
pub const CLSID_EnumProgressItems = &CLSID_EnumProgressItems_Value;

const CLSID_ProgressItems_Value = @import("../zig.zig").Guid.initString("2c941fc9-975b-59be-a960-9a2a262853a5");
pub const CLSID_ProgressItems = &CLSID_ProgressItems_Value;

const CLSID_FsiDirectoryItem_Value = @import("../zig.zig").Guid.initString("2c941fc8-975b-59be-a960-9a2a262853a5");
pub const CLSID_FsiDirectoryItem = &CLSID_FsiDirectoryItem_Value;

const CLSID_FsiFileItem_Value = @import("../zig.zig").Guid.initString("2c941fc7-975b-59be-a960-9a2a262853a5");
pub const CLSID_FsiFileItem = &CLSID_FsiFileItem_Value;

const CLSID_EnumFsiItems_Value = @import("../zig.zig").Guid.initString("2c941fc6-975b-59be-a960-9a2a262853a5");
pub const CLSID_EnumFsiItems = &CLSID_EnumFsiItems_Value;

const CLSID_FsiNamedStreams_Value = @import("../zig.zig").Guid.initString("c6b6f8ed-6d19-44b4-b539-b159b793a32d");
pub const CLSID_FsiNamedStreams = &CLSID_FsiNamedStreams_Value;

const CLSID_MsftFileSystemImage_Value = @import("../zig.zig").Guid.initString("2c941fc5-975b-59be-a960-9a2a262853a5");
pub const CLSID_MsftFileSystemImage = &CLSID_MsftFileSystemImage_Value;

const CLSID_MsftIsoImageManager_Value = @import("../zig.zig").Guid.initString("ceee3b62-8f56-4056-869b-ef16917e3efc");
pub const CLSID_MsftIsoImageManager = &CLSID_MsftIsoImageManager_Value;

const CLSID_BlockRange_Value = @import("../zig.zig").Guid.initString("b507ca27-2204-11dd-966a-001aa01bbc58");
pub const CLSID_BlockRange = &CLSID_BlockRange_Value;

const CLSID_BlockRangeList_Value = @import("../zig.zig").Guid.initString("b507ca28-2204-11dd-966a-001aa01bbc58");
pub const CLSID_BlockRangeList = &CLSID_BlockRangeList_Value;

pub const FsiItemType = enum(i32) {
    NotFound = 0,
    Directory = 1,
    File = 2,
};
pub const FsiItemNotFound = FsiItemType.NotFound;
pub const FsiItemDirectory = FsiItemType.Directory;
pub const FsiItemFile = FsiItemType.File;

pub const FsiFileSystems = enum(i32) {
    None = 0,
    ISO9660 = 1,
    Joliet = 2,
    UDF = 4,
    Unknown = 1073741824,
};
pub const FsiFileSystemNone = FsiFileSystems.None;
pub const FsiFileSystemISO9660 = FsiFileSystems.ISO9660;
pub const FsiFileSystemJoliet = FsiFileSystems.Joliet;
pub const FsiFileSystemUDF = FsiFileSystems.UDF;
pub const FsiFileSystemUnknown = FsiFileSystems.Unknown;

pub const EmulationType = enum(i32) {
    None = 0,
    @"12MFloppy" = 1,
    @"144MFloppy" = 2,
    @"288MFloppy" = 3,
    HardDisk = 4,
};
pub const EmulationNone = EmulationType.None;
pub const Emulation12MFloppy = EmulationType.@"12MFloppy";
pub const Emulation144MFloppy = EmulationType.@"144MFloppy";
pub const Emulation288MFloppy = EmulationType.@"288MFloppy";
pub const EmulationHardDisk = EmulationType.HardDisk;

pub const PlatformId = enum(i32) {
    X86 = 0,
    PowerPC = 1,
    Mac = 2,
    EFI = 239,
};
pub const PlatformX86 = PlatformId.X86;
pub const PlatformPowerPC = PlatformId.PowerPC;
pub const PlatformMac = PlatformId.Mac;
pub const PlatformEFI = PlatformId.EFI;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBootOptions_Value = @import("../zig.zig").Guid.initString("2c941fd4-975b-59be-a960-9a2a262853a5");
pub const IID_IBootOptions = &IID_IBootOptions_Value;
pub const IBootOptions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BootImage: fn(
            self: *const IBootOptions,
            pVal: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Manufacturer: fn(
            self: *const IBootOptions,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Manufacturer: fn(
            self: *const IBootOptions,
            newVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlatformId: fn(
            self: *const IBootOptions,
            pVal: ?*PlatformId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PlatformId: fn(
            self: *const IBootOptions,
            newVal: PlatformId,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Emulation: fn(
            self: *const IBootOptions,
            pVal: ?*EmulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Emulation: fn(
            self: *const IBootOptions,
            newVal: EmulationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageSize: fn(
            self: *const IBootOptions,
            pVal: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssignBootImage: fn(
            self: *const IBootOptions,
            newVal: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_BootImage(self: *const T, pVal: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootOptions.VTable, self.vtable).get_BootImage(@ptrCast(*const IBootOptions, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_Manufacturer(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootOptions.VTable, self.vtable).get_Manufacturer(@ptrCast(*const IBootOptions, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_put_Manufacturer(self: *const T, newVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootOptions.VTable, self.vtable).put_Manufacturer(@ptrCast(*const IBootOptions, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_PlatformId(self: *const T, pVal: ?*PlatformId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootOptions.VTable, self.vtable).get_PlatformId(@ptrCast(*const IBootOptions, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_put_PlatformId(self: *const T, newVal: PlatformId) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootOptions.VTable, self.vtable).put_PlatformId(@ptrCast(*const IBootOptions, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_Emulation(self: *const T, pVal: ?*EmulationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootOptions.VTable, self.vtable).get_Emulation(@ptrCast(*const IBootOptions, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_put_Emulation(self: *const T, newVal: EmulationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootOptions.VTable, self.vtable).put_Emulation(@ptrCast(*const IBootOptions, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_ImageSize(self: *const T, pVal: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootOptions.VTable, self.vtable).get_ImageSize(@ptrCast(*const IBootOptions, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_AssignBootImage(self: *const T, newVal: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootOptions.VTable, self.vtable).AssignBootImage(@ptrCast(*const IBootOptions, self), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProgressItem_Value = @import("../zig.zig").Guid.initString("2c941fd5-975b-59be-a960-9a2a262853a5");
pub const IID_IProgressItem = &IID_IProgressItem_Value;
pub const IProgressItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IProgressItem,
            desc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstBlock: fn(
            self: *const IProgressItem,
            block: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastBlock: fn(
            self: *const IProgressItem,
            block: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockCount: fn(
            self: *const IProgressItem,
            blocks: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItem_get_Description(self: *const T, desc: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItem.VTable, self.vtable).get_Description(@ptrCast(*const IProgressItem, self), desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItem_get_FirstBlock(self: *const T, block: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItem.VTable, self.vtable).get_FirstBlock(@ptrCast(*const IProgressItem, self), block);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItem_get_LastBlock(self: *const T, block: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItem.VTable, self.vtable).get_LastBlock(@ptrCast(*const IProgressItem, self), block);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItem_get_BlockCount(self: *const T, blocks: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItem.VTable, self.vtable).get_BlockCount(@ptrCast(*const IProgressItem, self), blocks);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumProgressItems_Value = @import("../zig.zig").Guid.initString("2c941fd6-975b-59be-a960-9a2a262853a5");
pub const IID_IEnumProgressItems = &IID_IEnumProgressItems_Value;
pub const IEnumProgressItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumProgressItems,
            celt: u32,
            rgelt: [*]?*IProgressItem,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumProgressItems,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumProgressItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumProgressItems,
            ppEnum: ?*?*IEnumProgressItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumProgressItems_Next(self: *const T, celt: u32, rgelt: [*]?*IProgressItem, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumProgressItems.VTable, self.vtable).Next(@ptrCast(*const IEnumProgressItems, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumProgressItems_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumProgressItems.VTable, self.vtable).Skip(@ptrCast(*const IEnumProgressItems, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumProgressItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumProgressItems.VTable, self.vtable).Reset(@ptrCast(*const IEnumProgressItems, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumProgressItems_Clone(self: *const T, ppEnum: ?*?*IEnumProgressItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumProgressItems.VTable, self.vtable).Clone(@ptrCast(*const IEnumProgressItems, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProgressItems_Value = @import("../zig.zig").Guid.initString("2c941fd7-975b-59be-a960-9a2a262853a5");
pub const IID_IProgressItems = &IID_IProgressItems_Value;
pub const IProgressItems = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IProgressItems,
            NewEnum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IProgressItems,
            Index: i32,
            item: ?*?*IProgressItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IProgressItems,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgressItemFromBlock: fn(
            self: *const IProgressItems,
            block: u32,
            item: ?*?*IProgressItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgressItemFromDescription: fn(
            self: *const IProgressItems,
            description: ?BSTR,
            item: ?*?*IProgressItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumProgressItems: fn(
            self: *const IProgressItems,
            NewEnum: ?*?*IEnumProgressItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItems.VTable, self.vtable).get__NewEnum(@ptrCast(*const IProgressItems, self), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_get_Item(self: *const T, Index: i32, item: ?*?*IProgressItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItems.VTable, self.vtable).get_Item(@ptrCast(*const IProgressItems, self), Index, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItems.VTable, self.vtable).get_Count(@ptrCast(*const IProgressItems, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_ProgressItemFromBlock(self: *const T, block: u32, item: ?*?*IProgressItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItems.VTable, self.vtable).ProgressItemFromBlock(@ptrCast(*const IProgressItems, self), block, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_ProgressItemFromDescription(self: *const T, description: ?BSTR, item: ?*?*IProgressItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItems.VTable, self.vtable).ProgressItemFromDescription(@ptrCast(*const IProgressItems, self), description, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_get_EnumProgressItems(self: *const T, NewEnum: ?*?*IEnumProgressItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressItems.VTable, self.vtable).get_EnumProgressItems(@ptrCast(*const IProgressItems, self), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImageResult_Value = @import("../zig.zig").Guid.initString("2c941fd8-975b-59be-a960-9a2a262853a5");
pub const IID_IFileSystemImageResult = &IID_IFileSystemImageResult_Value;
pub const IFileSystemImageResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageStream: fn(
            self: *const IFileSystemImageResult,
            pVal: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgressItems: fn(
            self: *const IFileSystemImageResult,
            pVal: ?*?*IProgressItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalBlocks: fn(
            self: *const IFileSystemImageResult,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockSize: fn(
            self: *const IFileSystemImageResult,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiscId: fn(
            self: *const IFileSystemImageResult,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_ImageStream(self: *const T, pVal: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImageResult.VTable, self.vtable).get_ImageStream(@ptrCast(*const IFileSystemImageResult, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_ProgressItems(self: *const T, pVal: ?*?*IProgressItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImageResult.VTable, self.vtable).get_ProgressItems(@ptrCast(*const IFileSystemImageResult, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_TotalBlocks(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImageResult.VTable, self.vtable).get_TotalBlocks(@ptrCast(*const IFileSystemImageResult, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_BlockSize(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImageResult.VTable, self.vtable).get_BlockSize(@ptrCast(*const IFileSystemImageResult, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_DiscId(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImageResult.VTable, self.vtable).get_DiscId(@ptrCast(*const IFileSystemImageResult, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IFileSystemImageResult2_Value = @import("../zig.zig").Guid.initString("b507ca29-2204-11dd-966a-001aa01bbc58");
pub const IID_IFileSystemImageResult2 = &IID_IFileSystemImageResult2_Value;
pub const IFileSystemImageResult2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemImageResult.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModifiedBlocks: fn(
            self: *const IFileSystemImageResult2,
            pVal: ?*?*IBlockRangeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileSystemImageResult.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult2_get_ModifiedBlocks(self: *const T, pVal: ?*?*IBlockRangeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImageResult2.VTable, self.vtable).get_ModifiedBlocks(@ptrCast(*const IFileSystemImageResult2, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiItem_Value = @import("../zig.zig").Guid.initString("2c941fd9-975b-59be-a960-9a2a262853a5");
pub const IID_IFsiItem = &IID_IFsiItem_Value;
pub const IFsiItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IFsiItem,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullPath: fn(
            self: *const IFsiItem,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreationTime: fn(
            self: *const IFsiItem,
            pVal: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CreationTime: fn(
            self: *const IFsiItem,
            newVal: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastAccessedTime: fn(
            self: *const IFsiItem,
            pVal: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LastAccessedTime: fn(
            self: *const IFsiItem,
            newVal: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastModifiedTime: fn(
            self: *const IFsiItem,
            pVal: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LastModifiedTime: fn(
            self: *const IFsiItem,
            newVal: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsHidden: fn(
            self: *const IFsiItem,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsHidden: fn(
            self: *const IFsiItem,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FileSystemName: fn(
            self: *const IFsiItem,
            fileSystem: FsiFileSystems,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FileSystemPath: fn(
            self: *const IFsiItem,
            fileSystem: FsiFileSystems,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_Name(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).get_Name(@ptrCast(*const IFsiItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_FullPath(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).get_FullPath(@ptrCast(*const IFsiItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_CreationTime(self: *const T, pVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).get_CreationTime(@ptrCast(*const IFsiItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_put_CreationTime(self: *const T, newVal: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).put_CreationTime(@ptrCast(*const IFsiItem, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_LastAccessedTime(self: *const T, pVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).get_LastAccessedTime(@ptrCast(*const IFsiItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_put_LastAccessedTime(self: *const T, newVal: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).put_LastAccessedTime(@ptrCast(*const IFsiItem, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_LastModifiedTime(self: *const T, pVal: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).get_LastModifiedTime(@ptrCast(*const IFsiItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_put_LastModifiedTime(self: *const T, newVal: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).put_LastModifiedTime(@ptrCast(*const IFsiItem, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_IsHidden(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).get_IsHidden(@ptrCast(*const IFsiItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_put_IsHidden(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).put_IsHidden(@ptrCast(*const IFsiItem, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_FileSystemName(self: *const T, fileSystem: FsiFileSystems, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).FileSystemName(@ptrCast(*const IFsiItem, self), fileSystem, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_FileSystemPath(self: *const T, fileSystem: FsiFileSystems, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiItem.VTable, self.vtable).FileSystemPath(@ptrCast(*const IFsiItem, self), fileSystem, pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumFsiItems_Value = @import("../zig.zig").Guid.initString("2c941fda-975b-59be-a960-9a2a262853a5");
pub const IID_IEnumFsiItems = &IID_IEnumFsiItems_Value;
pub const IEnumFsiItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumFsiItems,
            celt: u32,
            rgelt: [*]?*IFsiItem,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumFsiItems,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumFsiItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumFsiItems,
            ppEnum: ?*?*IEnumFsiItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFsiItems_Next(self: *const T, celt: u32, rgelt: [*]?*IFsiItem, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFsiItems.VTable, self.vtable).Next(@ptrCast(*const IEnumFsiItems, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFsiItems_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFsiItems.VTable, self.vtable).Skip(@ptrCast(*const IEnumFsiItems, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFsiItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFsiItems.VTable, self.vtable).Reset(@ptrCast(*const IEnumFsiItems, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFsiItems_Clone(self: *const T, ppEnum: ?*?*IEnumFsiItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFsiItems.VTable, self.vtable).Clone(@ptrCast(*const IEnumFsiItems, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiFileItem_Value = @import("../zig.zig").Guid.initString("2c941fdb-975b-59be-a960-9a2a262853a5");
pub const IID_IFsiFileItem = &IID_IFsiFileItem_Value;
pub const IFsiFileItem = extern struct {
    pub const VTable = extern struct {
        base: IFsiItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSize: fn(
            self: *const IFsiFileItem,
            pVal: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSize32BitLow: fn(
            self: *const IFsiFileItem,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSize32BitHigh: fn(
            self: *const IFsiFileItem,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: fn(
            self: *const IFsiFileItem,
            pVal: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: fn(
            self: *const IFsiFileItem,
            newVal: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsiItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_get_DataSize(self: *const T, pVal: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem.VTable, self.vtable).get_DataSize(@ptrCast(*const IFsiFileItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_get_DataSize32BitLow(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem.VTable, self.vtable).get_DataSize32BitLow(@ptrCast(*const IFsiFileItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_get_DataSize32BitHigh(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem.VTable, self.vtable).get_DataSize32BitHigh(@ptrCast(*const IFsiFileItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_get_Data(self: *const T, pVal: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem.VTable, self.vtable).get_Data(@ptrCast(*const IFsiFileItem, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_put_Data(self: *const T, newVal: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem.VTable, self.vtable).put_Data(@ptrCast(*const IFsiFileItem, self), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiFileItem2_Value = @import("../zig.zig").Guid.initString("199d0c19-11e1-40eb-8ec2-c8c822a07792");
pub const IID_IFsiFileItem2 = &IID_IFsiFileItem2_Value;
pub const IFsiFileItem2 = extern struct {
    pub const VTable = extern struct {
        base: IFsiFileItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FsiNamedStreams: fn(
            self: *const IFsiFileItem2,
            streams: ?*?*IFsiNamedStreams,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsNamedStream: fn(
            self: *const IFsiFileItem2,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStream: fn(
            self: *const IFsiFileItem2,
            name: ?BSTR,
            streamData: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStream: fn(
            self: *const IFsiFileItem2,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRealTime: fn(
            self: *const IFsiFileItem2,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsRealTime: fn(
            self: *const IFsiFileItem2,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsiFileItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_get_FsiNamedStreams(self: *const T, streams: ?*?*IFsiNamedStreams) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem2.VTable, self.vtable).get_FsiNamedStreams(@ptrCast(*const IFsiFileItem2, self), streams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_get_IsNamedStream(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem2.VTable, self.vtable).get_IsNamedStream(@ptrCast(*const IFsiFileItem2, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_AddStream(self: *const T, name: ?BSTR, streamData: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem2.VTable, self.vtable).AddStream(@ptrCast(*const IFsiFileItem2, self), name, streamData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_RemoveStream(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem2.VTable, self.vtable).RemoveStream(@ptrCast(*const IFsiFileItem2, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_get_IsRealTime(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem2.VTable, self.vtable).get_IsRealTime(@ptrCast(*const IFsiFileItem2, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_put_IsRealTime(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiFileItem2.VTable, self.vtable).put_IsRealTime(@ptrCast(*const IFsiFileItem2, self), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiNamedStreams_Value = @import("../zig.zig").Guid.initString("ed79ba56-5294-4250-8d46-f9aecee23459");
pub const IID_IFsiNamedStreams = &IID_IFsiNamedStreams_Value;
pub const IFsiNamedStreams = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IFsiNamedStreams,
            NewEnum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IFsiNamedStreams,
            index: i32,
            item: ?*?*IFsiFileItem2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IFsiNamedStreams,
            count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumNamedStreams: fn(
            self: *const IFsiNamedStreams,
            NewEnum: ?*?*IEnumFsiItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiNamedStreams_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiNamedStreams.VTable, self.vtable).get__NewEnum(@ptrCast(*const IFsiNamedStreams, self), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiNamedStreams_get_Item(self: *const T, index: i32, item: ?*?*IFsiFileItem2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiNamedStreams.VTable, self.vtable).get_Item(@ptrCast(*const IFsiNamedStreams, self), index, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiNamedStreams_get_Count(self: *const T, count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiNamedStreams.VTable, self.vtable).get_Count(@ptrCast(*const IFsiNamedStreams, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiNamedStreams_get_EnumNamedStreams(self: *const T, NewEnum: ?*?*IEnumFsiItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiNamedStreams.VTable, self.vtable).get_EnumNamedStreams(@ptrCast(*const IFsiNamedStreams, self), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiDirectoryItem_Value = @import("../zig.zig").Guid.initString("2c941fdc-975b-59be-a960-9a2a262853a5");
pub const IID_IFsiDirectoryItem = &IID_IFsiDirectoryItem_Value;
pub const IFsiDirectoryItem = extern struct {
    pub const VTable = extern struct {
        base: IFsiItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IFsiDirectoryItem,
            NewEnum: ?*?*IEnumVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
            item: ?*?*IFsiItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IFsiDirectoryItem,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumFsiItems: fn(
            self: *const IFsiDirectoryItem,
            NewEnum: ?*?*IEnumFsiItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDirectory: fn(
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFile: fn(
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
            fileData: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTree: fn(
            self: *const IFsiDirectoryItem,
            sourceDirectory: ?BSTR,
            includeBaseDirectory: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IFsiDirectoryItem,
            item: ?*IFsiItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTree: fn(
            self: *const IFsiDirectoryItem,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsiItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).get__NewEnum(@ptrCast(*const IFsiDirectoryItem, self), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_get_Item(self: *const T, path: ?BSTR, item: ?*?*IFsiItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).get_Item(@ptrCast(*const IFsiDirectoryItem, self), path, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).get_Count(@ptrCast(*const IFsiDirectoryItem, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_get_EnumFsiItems(self: *const T, NewEnum: ?*?*IEnumFsiItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).get_EnumFsiItems(@ptrCast(*const IFsiDirectoryItem, self), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_AddDirectory(self: *const T, path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).AddDirectory(@ptrCast(*const IFsiDirectoryItem, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_AddFile(self: *const T, path: ?BSTR, fileData: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).AddFile(@ptrCast(*const IFsiDirectoryItem, self), path, fileData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_AddTree(self: *const T, sourceDirectory: ?BSTR, includeBaseDirectory: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).AddTree(@ptrCast(*const IFsiDirectoryItem, self), sourceDirectory, includeBaseDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_Add(self: *const T, item: ?*IFsiItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).Add(@ptrCast(*const IFsiDirectoryItem, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_Remove(self: *const T, path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).Remove(@ptrCast(*const IFsiDirectoryItem, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_RemoveTree(self: *const T, path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem.VTable, self.vtable).RemoveTree(@ptrCast(*const IFsiDirectoryItem, self), path);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiDirectoryItem2_Value = @import("../zig.zig").Guid.initString("f7fb4b9b-6d96-4d7b-9115-201b144811ef");
pub const IID_IFsiDirectoryItem2 = &IID_IFsiDirectoryItem2_Value;
pub const IFsiDirectoryItem2 = extern struct {
    pub const VTable = extern struct {
        base: IFsiDirectoryItem.VTable,
        AddTreeWithNamedStreams: fn(
            self: *const IFsiDirectoryItem2,
            sourceDirectory: ?BSTR,
            includeBaseDirectory: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsiDirectoryItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem2_AddTreeWithNamedStreams(self: *const T, sourceDirectory: ?BSTR, includeBaseDirectory: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFsiDirectoryItem2.VTable, self.vtable).AddTreeWithNamedStreams(@ptrCast(*const IFsiDirectoryItem2, self), sourceDirectory, includeBaseDirectory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImage_Value = @import("../zig.zig").Guid.initString("2c941fe1-975b-59be-a960-9a2a262853a5");
pub const IID_IFileSystemImage = &IID_IFileSystemImage_Value;
pub const IFileSystemImage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Root: fn(
            self: *const IFileSystemImage,
            pVal: ?*?*IFsiDirectoryItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionStartBlock: fn(
            self: *const IFileSystemImage,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SessionStartBlock: fn(
            self: *const IFileSystemImage,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeMediaBlocks: fn(
            self: *const IFileSystemImage,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FreeMediaBlocks: fn(
            self: *const IFileSystemImage,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaxMediaBlocksFromDevice: fn(
            self: *const IFileSystemImage,
            discRecorder: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsedBlocks: fn(
            self: *const IFileSystemImage,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeName: fn(
            self: *const IFileSystemImage,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VolumeName: fn(
            self: *const IFileSystemImage,
            newVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImportedVolumeName: fn(
            self: *const IFileSystemImage,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BootImageOptions: fn(
            self: *const IFileSystemImage,
            pVal: ?*?*IBootOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BootImageOptions: fn(
            self: *const IFileSystemImage,
            newVal: ?*IBootOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileCount: fn(
            self: *const IFileSystemImage,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DirectoryCount: fn(
            self: *const IFileSystemImage,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WorkingDirectory: fn(
            self: *const IFileSystemImage,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WorkingDirectory: fn(
            self: *const IFileSystemImage,
            newVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChangePoint: fn(
            self: *const IFileSystemImage,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StrictFileSystemCompliance: fn(
            self: *const IFileSystemImage,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StrictFileSystemCompliance: fn(
            self: *const IFileSystemImage,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseRestrictedCharacterSet: fn(
            self: *const IFileSystemImage,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseRestrictedCharacterSet: fn(
            self: *const IFileSystemImage,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileSystemsToCreate: fn(
            self: *const IFileSystemImage,
            pVal: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileSystemsToCreate: fn(
            self: *const IFileSystemImage,
            newVal: FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileSystemsSupported: fn(
            self: *const IFileSystemImage,
            pVal: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UDFRevision: fn(
            self: *const IFileSystemImage,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UDFRevision: fn(
            self: *const IFileSystemImage,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UDFRevisionsSupported: fn(
            self: *const IFileSystemImage,
            pVal: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChooseImageDefaults: fn(
            self: *const IFileSystemImage,
            discRecorder: ?*IDiscRecorder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChooseImageDefaultsForMediaType: fn(
            self: *const IFileSystemImage,
            value: IMAPI_MEDIA_PHYSICAL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ISO9660InterchangeLevel: fn(
            self: *const IFileSystemImage,
            newVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ISO9660InterchangeLevel: fn(
            self: *const IFileSystemImage,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ISO9660InterchangeLevelsSupported: fn(
            self: *const IFileSystemImage,
            pVal: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateResultImage: fn(
            self: *const IFileSystemImage,
            resultStream: ?*?*IFileSystemImageResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Exists: fn(
            self: *const IFileSystemImage,
            fullPath: ?BSTR,
            itemType: ?*FsiItemType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CalculateDiscIdentifier: fn(
            self: *const IFileSystemImage,
            discIdentifier: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IdentifyFileSystemsOnDisc: fn(
            self: *const IFileSystemImage,
            discRecorder: ?*IDiscRecorder2,
            fileSystems: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultFileSystemForImport: fn(
            self: *const IFileSystemImage,
            fileSystems: FsiFileSystems,
            importDefault: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportFileSystem: fn(
            self: *const IFileSystemImage,
            importedFileSystem: ?*FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportSpecificFileSystem: fn(
            self: *const IFileSystemImage,
            fileSystemToUse: FsiFileSystems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RollbackToChangePoint: fn(
            self: *const IFileSystemImage,
            changePoint: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockInChangePoint: fn(
            self: *const IFileSystemImage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDirectoryItem: fn(
            self: *const IFileSystemImage,
            name: ?BSTR,
            newItem: ?*?*IFsiDirectoryItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFileItem: fn(
            self: *const IFileSystemImage,
            name: ?BSTR,
            newItem: ?*?*IFsiFileItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeNameUDF: fn(
            self: *const IFileSystemImage,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeNameJoliet: fn(
            self: *const IFileSystemImage,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeNameISO9660: fn(
            self: *const IFileSystemImage,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StageFiles: fn(
            self: *const IFileSystemImage,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StageFiles: fn(
            self: *const IFileSystemImage,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MultisessionInterfaces: fn(
            self: *const IFileSystemImage,
            pVal: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MultisessionInterfaces: fn(
            self: *const IFileSystemImage,
            newVal: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_Root(self: *const T, pVal: ?*?*IFsiDirectoryItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_Root(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_SessionStartBlock(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_SessionStartBlock(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_SessionStartBlock(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_SessionStartBlock(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_FreeMediaBlocks(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_FreeMediaBlocks(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_FreeMediaBlocks(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_FreeMediaBlocks(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_SetMaxMediaBlocksFromDevice(self: *const T, discRecorder: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).SetMaxMediaBlocksFromDevice(@ptrCast(*const IFileSystemImage, self), discRecorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_UsedBlocks(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_UsedBlocks(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_VolumeName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_VolumeName(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_VolumeName(self: *const T, newVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_VolumeName(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_ImportedVolumeName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_ImportedVolumeName(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_BootImageOptions(self: *const T, pVal: ?*?*IBootOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_BootImageOptions(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_BootImageOptions(self: *const T, newVal: ?*IBootOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_BootImageOptions(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_FileCount(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_FileCount(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_DirectoryCount(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_DirectoryCount(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_WorkingDirectory(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_WorkingDirectory(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_WorkingDirectory(self: *const T, newVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_WorkingDirectory(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_ChangePoint(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_ChangePoint(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_StrictFileSystemCompliance(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_StrictFileSystemCompliance(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_StrictFileSystemCompliance(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_StrictFileSystemCompliance(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_UseRestrictedCharacterSet(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_UseRestrictedCharacterSet(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_UseRestrictedCharacterSet(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_UseRestrictedCharacterSet(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_FileSystemsToCreate(self: *const T, pVal: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_FileSystemsToCreate(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_FileSystemsToCreate(self: *const T, newVal: FsiFileSystems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_FileSystemsToCreate(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_FileSystemsSupported(self: *const T, pVal: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_FileSystemsSupported(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_UDFRevision(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_UDFRevision(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_UDFRevision(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_UDFRevision(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_UDFRevisionsSupported(self: *const T, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_UDFRevisionsSupported(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_ChooseImageDefaults(self: *const T, discRecorder: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).ChooseImageDefaults(@ptrCast(*const IFileSystemImage, self), discRecorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_ChooseImageDefaultsForMediaType(self: *const T, value: IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).ChooseImageDefaultsForMediaType(@ptrCast(*const IFileSystemImage, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_ISO9660InterchangeLevel(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_ISO9660InterchangeLevel(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_ISO9660InterchangeLevel(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_ISO9660InterchangeLevel(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_ISO9660InterchangeLevelsSupported(self: *const T, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_ISO9660InterchangeLevelsSupported(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_CreateResultImage(self: *const T, resultStream: ?*?*IFileSystemImageResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).CreateResultImage(@ptrCast(*const IFileSystemImage, self), resultStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_Exists(self: *const T, fullPath: ?BSTR, itemType: ?*FsiItemType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).Exists(@ptrCast(*const IFileSystemImage, self), fullPath, itemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_CalculateDiscIdentifier(self: *const T, discIdentifier: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).CalculateDiscIdentifier(@ptrCast(*const IFileSystemImage, self), discIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_IdentifyFileSystemsOnDisc(self: *const T, discRecorder: ?*IDiscRecorder2, fileSystems: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).IdentifyFileSystemsOnDisc(@ptrCast(*const IFileSystemImage, self), discRecorder, fileSystems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_GetDefaultFileSystemForImport(self: *const T, fileSystems: FsiFileSystems, importDefault: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).GetDefaultFileSystemForImport(@ptrCast(*const IFileSystemImage, self), fileSystems, importDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_ImportFileSystem(self: *const T, importedFileSystem: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).ImportFileSystem(@ptrCast(*const IFileSystemImage, self), importedFileSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_ImportSpecificFileSystem(self: *const T, fileSystemToUse: FsiFileSystems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).ImportSpecificFileSystem(@ptrCast(*const IFileSystemImage, self), fileSystemToUse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_RollbackToChangePoint(self: *const T, changePoint: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).RollbackToChangePoint(@ptrCast(*const IFileSystemImage, self), changePoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_LockInChangePoint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).LockInChangePoint(@ptrCast(*const IFileSystemImage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_CreateDirectoryItem(self: *const T, name: ?BSTR, newItem: ?*?*IFsiDirectoryItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).CreateDirectoryItem(@ptrCast(*const IFileSystemImage, self), name, newItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_CreateFileItem(self: *const T, name: ?BSTR, newItem: ?*?*IFsiFileItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).CreateFileItem(@ptrCast(*const IFileSystemImage, self), name, newItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_VolumeNameUDF(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_VolumeNameUDF(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_VolumeNameJoliet(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_VolumeNameJoliet(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_VolumeNameISO9660(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_VolumeNameISO9660(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_StageFiles(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_StageFiles(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_StageFiles(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_StageFiles(@ptrCast(*const IFileSystemImage, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_MultisessionInterfaces(self: *const T, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).get_MultisessionInterfaces(@ptrCast(*const IFileSystemImage, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_MultisessionInterfaces(self: *const T, newVal: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage.VTable, self.vtable).put_MultisessionInterfaces(@ptrCast(*const IFileSystemImage, self), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImage2_Value = @import("../zig.zig").Guid.initString("d7644b2c-1537-4767-b62f-f1387b02ddfd");
pub const IID_IFileSystemImage2 = &IID_IFileSystemImage2_Value;
pub const IFileSystemImage2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemImage.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BootImageOptionsArray: fn(
            self: *const IFileSystemImage2,
            pVal: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BootImageOptionsArray: fn(
            self: *const IFileSystemImage2,
            newVal: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileSystemImage.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage2_get_BootImageOptionsArray(self: *const T, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage2.VTable, self.vtable).get_BootImageOptionsArray(@ptrCast(*const IFileSystemImage2, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage2_put_BootImageOptionsArray(self: *const T, newVal: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage2.VTable, self.vtable).put_BootImageOptionsArray(@ptrCast(*const IFileSystemImage2, self), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImage3_Value = @import("../zig.zig").Guid.initString("7cff842c-7e97-4807-8304-910dd8f7c051");
pub const IID_IFileSystemImage3 = &IID_IFileSystemImage3_Value;
pub const IFileSystemImage3 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemImage2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreateRedundantUdfMetadataFiles: fn(
            self: *const IFileSystemImage3,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CreateRedundantUdfMetadataFiles: fn(
            self: *const IFileSystemImage3,
            newVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProbeSpecificFileSystem: fn(
            self: *const IFileSystemImage3,
            fileSystemToProbe: FsiFileSystems,
            isAppendable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileSystemImage2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage3_get_CreateRedundantUdfMetadataFiles(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage3.VTable, self.vtable).get_CreateRedundantUdfMetadataFiles(@ptrCast(*const IFileSystemImage3, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage3_put_CreateRedundantUdfMetadataFiles(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage3.VTable, self.vtable).put_CreateRedundantUdfMetadataFiles(@ptrCast(*const IFileSystemImage3, self), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage3_ProbeSpecificFileSystem(self: *const T, fileSystemToProbe: FsiFileSystems, isAppendable: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemImage3.VTable, self.vtable).ProbeSpecificFileSystem(@ptrCast(*const IFileSystemImage3, self), fileSystemToProbe, isAppendable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DFileSystemImageEvents_Value = @import("../zig.zig").Guid.initString("2c941fdf-975b-59be-a960-9a2a262853a5");
pub const IID_DFileSystemImageEvents = &IID_DFileSystemImageEvents_Value;
pub const DFileSystemImageEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: fn(
            self: *const DFileSystemImageEvents,
            object: ?*IDispatch,
            currentFile: ?BSTR,
            copiedSectors: i32,
            totalSectors: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DFileSystemImageEvents_Update(self: *const T, object: ?*IDispatch, currentFile: ?BSTR, copiedSectors: i32, totalSectors: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const DFileSystemImageEvents.VTable, self.vtable).Update(@ptrCast(*const DFileSystemImageEvents, self), object, currentFile, copiedSectors, totalSectors);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DFileSystemImageImportEvents_Value = @import("../zig.zig").Guid.initString("d25c30f9-4087-4366-9e24-e55be286424b");
pub const IID_DFileSystemImageImportEvents = &IID_DFileSystemImageImportEvents_Value;
pub const DFileSystemImageImportEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        UpdateImport: fn(
            self: *const DFileSystemImageImportEvents,
            object: ?*IDispatch,
            fileSystem: FsiFileSystems,
            currentItem: ?BSTR,
            importedDirectoryItems: i32,
            totalDirectoryItems: i32,
            importedFileItems: i32,
            totalFileItems: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DFileSystemImageImportEvents_UpdateImport(self: *const T, object: ?*IDispatch, fileSystem: FsiFileSystems, currentItem: ?BSTR, importedDirectoryItems: i32, totalDirectoryItems: i32, importedFileItems: i32, totalFileItems: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const DFileSystemImageImportEvents.VTable, self.vtable).UpdateImport(@ptrCast(*const DFileSystemImageImportEvents, self), object, fileSystem, currentItem, importedDirectoryItems, totalDirectoryItems, importedFileItems, totalFileItems);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IIsoImageManager_Value = @import("../zig.zig").Guid.initString("6ca38be5-fbbb-4800-95a1-a438865eb0d4");
pub const IID_IIsoImageManager = &IID_IIsoImageManager_Value;
pub const IIsoImageManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IIsoImageManager,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Stream: fn(
            self: *const IIsoImageManager,
            data: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPath: fn(
            self: *const IIsoImageManager,
            Val: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStream: fn(
            self: *const IIsoImageManager,
            data: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: fn(
            self: *const IIsoImageManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_get_Path(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsoImageManager.VTable, self.vtable).get_Path(@ptrCast(*const IIsoImageManager, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_get_Stream(self: *const T, data: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsoImageManager.VTable, self.vtable).get_Stream(@ptrCast(*const IIsoImageManager, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_SetPath(self: *const T, Val: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsoImageManager.VTable, self.vtable).SetPath(@ptrCast(*const IIsoImageManager, self), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_SetStream(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsoImageManager.VTable, self.vtable).SetStream(@ptrCast(*const IIsoImageManager, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_Validate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsoImageManager.VTable, self.vtable).Validate(@ptrCast(*const IIsoImageManager, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSDiscRecorderObj_Value = @import("../zig.zig").Guid.initString("520cca61-51a5-11d3-9144-00104ba11c5e");
pub const CLSID_MSDiscRecorderObj = &CLSID_MSDiscRecorderObj_Value;

const CLSID_MSDiscMasterObj_Value = @import("../zig.zig").Guid.initString("520cca63-51a5-11d3-9144-00104ba11c5e");
pub const CLSID_MSDiscMasterObj = &CLSID_MSDiscMasterObj_Value;

const CLSID_MSEnumDiscRecordersObj_Value = @import("../zig.zig").Guid.initString("8a03567a-63cb-4ba8-baf6-52119816d1ef");
pub const CLSID_MSEnumDiscRecordersObj = &CLSID_MSEnumDiscRecordersObj_Value;

pub const MEDIA_TYPES = enum(i32) {
    CDDA_CDROM = 1,
    CD_ROM_XA = 2,
    CD_I = 3,
    CD_EXTRA = 4,
    CD_OTHER = 5,
    SPECIAL = 6,
};
pub const MEDIA_CDDA_CDROM = MEDIA_TYPES.CDDA_CDROM;
pub const MEDIA_CD_ROM_XA = MEDIA_TYPES.CD_ROM_XA;
pub const MEDIA_CD_I = MEDIA_TYPES.CD_I;
pub const MEDIA_CD_EXTRA = MEDIA_TYPES.CD_EXTRA;
pub const MEDIA_CD_OTHER = MEDIA_TYPES.CD_OTHER;
pub const MEDIA_SPECIAL = MEDIA_TYPES.SPECIAL;

pub const MEDIA_FLAGS = enum(i32) {
    BLANK = 1,
    RW = 2,
    WRITABLE = 4,
    FORMAT_UNUSABLE_BY_IMAPI = 8,
};
pub const MEDIA_BLANK = MEDIA_FLAGS.BLANK;
pub const MEDIA_RW = MEDIA_FLAGS.RW;
pub const MEDIA_WRITABLE = MEDIA_FLAGS.WRITABLE;
pub const MEDIA_FORMAT_UNUSABLE_BY_IMAPI = MEDIA_FLAGS.FORMAT_UNUSABLE_BY_IMAPI;

pub const RECORDER_TYPES = enum(i32) {
    R = 1,
    W = 2,
};
pub const RECORDER_CDR = RECORDER_TYPES.R;
pub const RECORDER_CDRW = RECORDER_TYPES.W;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiscRecorder_Value = @import("../zig.zig").Guid.initString("85ac9776-ca88-4cf2-894e-09598c078a41");
pub const IID_IDiscRecorder = &IID_IDiscRecorder_Value;
pub const IDiscRecorder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IDiscRecorder,
            pbyUniqueID: [*:0]u8,
            nulIDSize: u32,
            nulDriveNumber: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecorderGUID: fn(
            self: *const IDiscRecorder,
            pbyUniqueID: ?[*:0]u8,
            ulBufferSize: u32,
            pulReturnSizeRequired: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecorderType: fn(
            self: *const IDiscRecorder,
            fTypeCode: ?*RECORDER_TYPES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayNames: fn(
            self: *const IDiscRecorder,
            pbstrVendorID: ?*?BSTR,
            pbstrProductID: ?*?BSTR,
            pbstrRevision: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBasePnPID: fn(
            self: *const IDiscRecorder,
            pbstrBasePnPID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: fn(
            self: *const IDiscRecorder,
            pbstrPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecorderProperties: fn(
            self: *const IDiscRecorder,
            ppPropStg: ?*?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRecorderProperties: fn(
            self: *const IDiscRecorder,
            pPropStg: ?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecorderState: fn(
            self: *const IDiscRecorder,
            pulDevStateFlags: ?*DISC_RECORDER_STATE_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenExclusive: fn(
            self: *const IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMediaType: fn(
            self: *const IDiscRecorder,
            fMediaType: ?*MEDIA_TYPES,
            fMediaFlags: ?*MEDIA_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMediaInfo: fn(
            self: *const IDiscRecorder,
            pbSessions: ?*u8,
            pbLastTrack: ?*u8,
            ulStartAddress: ?*u32,
            ulNextWritable: ?*u32,
            ulFreeBlocks: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Eject: fn(
            self: *const IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Erase: fn(
            self: *const IDiscRecorder,
            bFullErase: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_Init(self: *const T, pbyUniqueID: [*:0]u8, nulIDSize: u32, nulDriveNumber: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).Init(@ptrCast(*const IDiscRecorder, self), pbyUniqueID, nulIDSize, nulDriveNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetRecorderGUID(self: *const T, pbyUniqueID: ?[*:0]u8, ulBufferSize: u32, pulReturnSizeRequired: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).GetRecorderGUID(@ptrCast(*const IDiscRecorder, self), pbyUniqueID, ulBufferSize, pulReturnSizeRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetRecorderType(self: *const T, fTypeCode: ?*RECORDER_TYPES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).GetRecorderType(@ptrCast(*const IDiscRecorder, self), fTypeCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetDisplayNames(self: *const T, pbstrVendorID: ?*?BSTR, pbstrProductID: ?*?BSTR, pbstrRevision: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).GetDisplayNames(@ptrCast(*const IDiscRecorder, self), pbstrVendorID, pbstrProductID, pbstrRevision);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetBasePnPID(self: *const T, pbstrBasePnPID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).GetBasePnPID(@ptrCast(*const IDiscRecorder, self), pbstrBasePnPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetPath(self: *const T, pbstrPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).GetPath(@ptrCast(*const IDiscRecorder, self), pbstrPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetRecorderProperties(self: *const T, ppPropStg: ?*?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).GetRecorderProperties(@ptrCast(*const IDiscRecorder, self), ppPropStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_SetRecorderProperties(self: *const T, pPropStg: ?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).SetRecorderProperties(@ptrCast(*const IDiscRecorder, self), pPropStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetRecorderState(self: *const T, pulDevStateFlags: ?*DISC_RECORDER_STATE_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).GetRecorderState(@ptrCast(*const IDiscRecorder, self), pulDevStateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_OpenExclusive(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).OpenExclusive(@ptrCast(*const IDiscRecorder, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_QueryMediaType(self: *const T, fMediaType: ?*MEDIA_TYPES, fMediaFlags: ?*MEDIA_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).QueryMediaType(@ptrCast(*const IDiscRecorder, self), fMediaType, fMediaFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_QueryMediaInfo(self: *const T, pbSessions: ?*u8, pbLastTrack: ?*u8, ulStartAddress: ?*u32, ulNextWritable: ?*u32, ulFreeBlocks: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).QueryMediaInfo(@ptrCast(*const IDiscRecorder, self), pbSessions, pbLastTrack, ulStartAddress, ulNextWritable, ulFreeBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_Eject(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).Eject(@ptrCast(*const IDiscRecorder, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_Erase(self: *const T, bFullErase: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).Erase(@ptrCast(*const IDiscRecorder, self), bFullErase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscRecorder.VTable, self.vtable).Close(@ptrCast(*const IDiscRecorder, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDiscRecorders_Value = @import("../zig.zig").Guid.initString("9b1921e1-54ac-11d3-9144-00104ba11c5e");
pub const IID_IEnumDiscRecorders = &IID_IEnumDiscRecorders_Value;
pub const IEnumDiscRecorders = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDiscRecorders,
            cRecorders: u32,
            ppRecorder: [*]?*IDiscRecorder,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDiscRecorders,
            cRecorders: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDiscRecorders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDiscRecorders,
            ppEnum: ?*?*IEnumDiscRecorders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscRecorders_Next(self: *const T, cRecorders: u32, ppRecorder: [*]?*IDiscRecorder, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiscRecorders.VTable, self.vtable).Next(@ptrCast(*const IEnumDiscRecorders, self), cRecorders, ppRecorder, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscRecorders_Skip(self: *const T, cRecorders: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiscRecorders.VTable, self.vtable).Skip(@ptrCast(*const IEnumDiscRecorders, self), cRecorders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscRecorders_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiscRecorders.VTable, self.vtable).Reset(@ptrCast(*const IEnumDiscRecorders, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscRecorders_Clone(self: *const T, ppEnum: ?*?*IEnumDiscRecorders) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiscRecorders.VTable, self.vtable).Clone(@ptrCast(*const IEnumDiscRecorders, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDiscMasterFormats_Value = @import("../zig.zig").Guid.initString("ddf445e1-54ba-11d3-9144-00104ba11c5e");
pub const IID_IEnumDiscMasterFormats = &IID_IEnumDiscMasterFormats_Value;
pub const IEnumDiscMasterFormats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDiscMasterFormats,
            cFormats: u32,
            lpiidFormatID: [*]Guid,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDiscMasterFormats,
            cFormats: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDiscMasterFormats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDiscMasterFormats,
            ppEnum: ?*?*IEnumDiscMasterFormats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscMasterFormats_Next(self: *const T, cFormats: u32, lpiidFormatID: [*]Guid, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiscMasterFormats.VTable, self.vtable).Next(@ptrCast(*const IEnumDiscMasterFormats, self), cFormats, lpiidFormatID, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscMasterFormats_Skip(self: *const T, cFormats: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiscMasterFormats.VTable, self.vtable).Skip(@ptrCast(*const IEnumDiscMasterFormats, self), cFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscMasterFormats_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiscMasterFormats.VTable, self.vtable).Reset(@ptrCast(*const IEnumDiscMasterFormats, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscMasterFormats_Clone(self: *const T, ppEnum: ?*?*IEnumDiscMasterFormats) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDiscMasterFormats.VTable, self.vtable).Clone(@ptrCast(*const IEnumDiscMasterFormats, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRedbookDiscMaster_Value = @import("../zig.zig").Guid.initString("e3bc42cd-4e5c-11d3-9144-00104ba11c5e");
pub const IID_IRedbookDiscMaster = &IID_IRedbookDiscMaster_Value;
pub const IRedbookDiscMaster = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTotalAudioTracks: fn(
            self: *const IRedbookDiscMaster,
            pnTracks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalAudioBlocks: fn(
            self: *const IRedbookDiscMaster,
            pnBlocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUsedAudioBlocks: fn(
            self: *const IRedbookDiscMaster,
            pnBlocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableAudioTrackBlocks: fn(
            self: *const IRedbookDiscMaster,
            pnBlocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioBlockSize: fn(
            self: *const IRedbookDiscMaster,
            pnBlockBytes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAudioTrack: fn(
            self: *const IRedbookDiscMaster,
            nBlocks: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAudioTrackBlocks: fn(
            self: *const IRedbookDiscMaster,
            pby: [*:0]u8,
            cb: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseAudioTrack: fn(
            self: *const IRedbookDiscMaster,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetTotalAudioTracks(self: *const T, pnTracks: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRedbookDiscMaster.VTable, self.vtable).GetTotalAudioTracks(@ptrCast(*const IRedbookDiscMaster, self), pnTracks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetTotalAudioBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRedbookDiscMaster.VTable, self.vtable).GetTotalAudioBlocks(@ptrCast(*const IRedbookDiscMaster, self), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetUsedAudioBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRedbookDiscMaster.VTable, self.vtable).GetUsedAudioBlocks(@ptrCast(*const IRedbookDiscMaster, self), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetAvailableAudioTrackBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRedbookDiscMaster.VTable, self.vtable).GetAvailableAudioTrackBlocks(@ptrCast(*const IRedbookDiscMaster, self), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetAudioBlockSize(self: *const T, pnBlockBytes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRedbookDiscMaster.VTable, self.vtable).GetAudioBlockSize(@ptrCast(*const IRedbookDiscMaster, self), pnBlockBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_CreateAudioTrack(self: *const T, nBlocks: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRedbookDiscMaster.VTable, self.vtable).CreateAudioTrack(@ptrCast(*const IRedbookDiscMaster, self), nBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_AddAudioTrackBlocks(self: *const T, pby: [*:0]u8, cb: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRedbookDiscMaster.VTable, self.vtable).AddAudioTrackBlocks(@ptrCast(*const IRedbookDiscMaster, self), pby, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_CloseAudioTrack(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRedbookDiscMaster.VTable, self.vtable).CloseAudioTrack(@ptrCast(*const IRedbookDiscMaster, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IJolietDiscMaster_Value = @import("../zig.zig").Guid.initString("e3bc42ce-4e5c-11d3-9144-00104ba11c5e");
pub const IID_IJolietDiscMaster = &IID_IJolietDiscMaster_Value;
pub const IJolietDiscMaster = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTotalDataBlocks: fn(
            self: *const IJolietDiscMaster,
            pnBlocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUsedDataBlocks: fn(
            self: *const IJolietDiscMaster,
            pnBlocks: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataBlockSize: fn(
            self: *const IJolietDiscMaster,
            pnBlockBytes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddData: fn(
            self: *const IJolietDiscMaster,
            pStorage: ?*IStorage,
            lFileOverwrite: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetJolietProperties: fn(
            self: *const IJolietDiscMaster,
            ppPropStg: ?*?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetJolietProperties: fn(
            self: *const IJolietDiscMaster,
            pPropStg: ?*IPropertyStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_GetTotalDataBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IJolietDiscMaster.VTable, self.vtable).GetTotalDataBlocks(@ptrCast(*const IJolietDiscMaster, self), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_GetUsedDataBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IJolietDiscMaster.VTable, self.vtable).GetUsedDataBlocks(@ptrCast(*const IJolietDiscMaster, self), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_GetDataBlockSize(self: *const T, pnBlockBytes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IJolietDiscMaster.VTable, self.vtable).GetDataBlockSize(@ptrCast(*const IJolietDiscMaster, self), pnBlockBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_AddData(self: *const T, pStorage: ?*IStorage, lFileOverwrite: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IJolietDiscMaster.VTable, self.vtable).AddData(@ptrCast(*const IJolietDiscMaster, self), pStorage, lFileOverwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_GetJolietProperties(self: *const T, ppPropStg: ?*?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IJolietDiscMaster.VTable, self.vtable).GetJolietProperties(@ptrCast(*const IJolietDiscMaster, self), ppPropStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_SetJolietProperties(self: *const T, pPropStg: ?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IJolietDiscMaster.VTable, self.vtable).SetJolietProperties(@ptrCast(*const IJolietDiscMaster, self), pPropStg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiscMasterProgressEvents_Value = @import("../zig.zig").Guid.initString("ec9e51c1-4e5d-11d3-9144-00104ba11c5e");
pub const IID_IDiscMasterProgressEvents = &IID_IDiscMasterProgressEvents_Value;
pub const IDiscMasterProgressEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCancel: fn(
            self: *const IDiscMasterProgressEvents,
            pbCancel: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyPnPActivity: fn(
            self: *const IDiscMasterProgressEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyAddProgress: fn(
            self: *const IDiscMasterProgressEvents,
            nCompletedSteps: i32,
            nTotalSteps: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyBlockProgress: fn(
            self: *const IDiscMasterProgressEvents,
            nCompleted: i32,
            nTotal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyTrackProgress: fn(
            self: *const IDiscMasterProgressEvents,
            nCurrentTrack: i32,
            nTotalTracks: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyPreparingBurn: fn(
            self: *const IDiscMasterProgressEvents,
            nEstimatedSeconds: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyClosingDisc: fn(
            self: *const IDiscMasterProgressEvents,
            nEstimatedSeconds: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyBurnComplete: fn(
            self: *const IDiscMasterProgressEvents,
            status: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEraseComplete: fn(
            self: *const IDiscMasterProgressEvents,
            status: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_QueryCancel(self: *const T, pbCancel: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMasterProgressEvents.VTable, self.vtable).QueryCancel(@ptrCast(*const IDiscMasterProgressEvents, self), pbCancel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyPnPActivity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMasterProgressEvents.VTable, self.vtable).NotifyPnPActivity(@ptrCast(*const IDiscMasterProgressEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyAddProgress(self: *const T, nCompletedSteps: i32, nTotalSteps: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMasterProgressEvents.VTable, self.vtable).NotifyAddProgress(@ptrCast(*const IDiscMasterProgressEvents, self), nCompletedSteps, nTotalSteps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyBlockProgress(self: *const T, nCompleted: i32, nTotal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMasterProgressEvents.VTable, self.vtable).NotifyBlockProgress(@ptrCast(*const IDiscMasterProgressEvents, self), nCompleted, nTotal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyTrackProgress(self: *const T, nCurrentTrack: i32, nTotalTracks: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMasterProgressEvents.VTable, self.vtable).NotifyTrackProgress(@ptrCast(*const IDiscMasterProgressEvents, self), nCurrentTrack, nTotalTracks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyPreparingBurn(self: *const T, nEstimatedSeconds: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMasterProgressEvents.VTable, self.vtable).NotifyPreparingBurn(@ptrCast(*const IDiscMasterProgressEvents, self), nEstimatedSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyClosingDisc(self: *const T, nEstimatedSeconds: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMasterProgressEvents.VTable, self.vtable).NotifyClosingDisc(@ptrCast(*const IDiscMasterProgressEvents, self), nEstimatedSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyBurnComplete(self: *const T, status: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMasterProgressEvents.VTable, self.vtable).NotifyBurnComplete(@ptrCast(*const IDiscMasterProgressEvents, self), status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyEraseComplete(self: *const T, status: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMasterProgressEvents.VTable, self.vtable).NotifyEraseComplete(@ptrCast(*const IDiscMasterProgressEvents, self), status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiscMaster_Value = @import("../zig.zig").Guid.initString("520cca62-51a5-11d3-9144-00104ba11c5e");
pub const IID_IDiscMaster = &IID_IDiscMaster_Value;
pub const IDiscMaster = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IDiscMaster,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDiscMasterFormats: fn(
            self: *const IDiscMaster,
            ppEnum: ?*?*IEnumDiscMasterFormats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveDiscMasterFormat: fn(
            self: *const IDiscMaster,
            lpiid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveDiscMasterFormat: fn(
            self: *const IDiscMaster,
            riid: ?*const Guid,
            ppUnk: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDiscRecorders: fn(
            self: *const IDiscMaster,
            ppEnum: ?*?*IEnumDiscRecorders,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveDiscRecorder: fn(
            self: *const IDiscMaster,
            ppRecorder: ?*?*IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveDiscRecorder: fn(
            self: *const IDiscMaster,
            pRecorder: ?*IDiscRecorder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearFormatContent: fn(
            self: *const IDiscMaster,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgressAdvise: fn(
            self: *const IDiscMaster,
            pEvents: ?*IDiscMasterProgressEvents,
            pvCookie: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProgressUnadvise: fn(
            self: *const IDiscMaster,
            vCookie: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecordDisc: fn(
            self: *const IDiscMaster,
            bSimulate: u8,
            bEjectAfterBurn: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IDiscMaster,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_Open(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).Open(@ptrCast(*const IDiscMaster, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_EnumDiscMasterFormats(self: *const T, ppEnum: ?*?*IEnumDiscMasterFormats) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).EnumDiscMasterFormats(@ptrCast(*const IDiscMaster, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_GetActiveDiscMasterFormat(self: *const T, lpiid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).GetActiveDiscMasterFormat(@ptrCast(*const IDiscMaster, self), lpiid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_SetActiveDiscMasterFormat(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).SetActiveDiscMasterFormat(@ptrCast(*const IDiscMaster, self), riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_EnumDiscRecorders(self: *const T, ppEnum: ?*?*IEnumDiscRecorders) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).EnumDiscRecorders(@ptrCast(*const IDiscMaster, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_GetActiveDiscRecorder(self: *const T, ppRecorder: ?*?*IDiscRecorder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).GetActiveDiscRecorder(@ptrCast(*const IDiscMaster, self), ppRecorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_SetActiveDiscRecorder(self: *const T, pRecorder: ?*IDiscRecorder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).SetActiveDiscRecorder(@ptrCast(*const IDiscMaster, self), pRecorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_ClearFormatContent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).ClearFormatContent(@ptrCast(*const IDiscMaster, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_ProgressAdvise(self: *const T, pEvents: ?*IDiscMasterProgressEvents, pvCookie: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).ProgressAdvise(@ptrCast(*const IDiscMaster, self), pEvents, pvCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_ProgressUnadvise(self: *const T, vCookie: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).ProgressUnadvise(@ptrCast(*const IDiscMaster, self), vCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_RecordDisc(self: *const T, bSimulate: u8, bEjectAfterBurn: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).RecordDisc(@ptrCast(*const IDiscMaster, self), bSimulate, bEjectAfterBurn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDiscMaster.VTable, self.vtable).Close(@ptrCast(*const IDiscMaster, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _MSGSESS = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const MSGCALLRELEASE = fn(
    ulCallerData: u32,
    lpMessage: ?*IMessage,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SPropAttrArray = extern struct {
    cValues: u32,
    aPropAttr: [1]u32,
};

const CLSID_tagIMMPID_MP_STRUCT_Value = @import("../zig.zig").Guid.initString("13384cf0-b3c4-11d1-aa92-00aa006bc80b");
pub const CLSID_tagIMMPID_MP_STRUCT = &CLSID_tagIMMPID_MP_STRUCT_Value;

pub const IMMPID_MP_ENUM = enum(i32) {
    BEFORE__ = 4095,
    RECIPIENT_LIST = 4096,
    CONTENT_FILE_NAME = 4097,
    SENDER_ADDRESS_SMTP = 4098,
    SENDER_ADDRESS_X500 = 4099,
    SENDER_ADDRESS_X400 = 4100,
    SENDER_ADDRESS_LEGACY_EX_DN = 4101,
    DOMAIN_LIST = 4102,
    PICKUP_FILE_NAME = 4103,
    AUTHENTICATED_USER_NAME = 4104,
    CONNECTION_IP_ADDRESS = 4105,
    HELO_DOMAIN = 4106,
    EIGHTBIT_MIME_OPTION = 4107,
    CHUNKING_OPTION = 4108,
    BINARYMIME_OPTION = 4109,
    REMOTE_AUTHENTICATION_TYPE = 4110,
    ERROR_CODE = 4111,
    DSN_ENVID_VALUE = 4112,
    DSN_RET_VALUE = 4113,
    REMOTE_SERVER_DSN_CAPABLE = 4114,
    ARRIVAL_TIME = 4115,
    MESSAGE_STATUS = 4116,
    EXPIRE_DELAY = 4117,
    EXPIRE_NDR = 4118,
    LOCAL_EXPIRE_DELAY = 4119,
    LOCAL_EXPIRE_NDR = 4120,
    ARRIVAL_FILETIME = 4121,
    HR_CAT_STATUS = 4122,
    MSG_GUID = 4123,
    SUPERSEDES_MSG_GUID = 4124,
    SCANNED_FOR_CRLF_DOT_CRLF = 4125,
    FOUND_EMBEDDED_CRLF_DOT_CRLF = 4126,
    MSG_SIZE_HINT = 4127,
    RFC822_MSG_ID = 4128,
    RFC822_MSG_SUBJECT = 4129,
    RFC822_FROM_ADDRESS = 4130,
    RFC822_TO_ADDRESS = 4131,
    RFC822_CC_ADDRESS = 4132,
    RFC822_BCC_ADDRESS = 4133,
    CONNECTION_SERVER_IP_ADDRESS = 4134,
    SERVER_NAME = 4135,
    SERVER_VERSION = 4136,
    NUM_RECIPIENTS = 4137,
    X_PRIORITY = 4138,
    FROM_ADDRESS = 4139,
    SENDER_ADDRESS = 4140,
    DEFERRED_DELIVERY_FILETIME = 4141,
    SENDER_ADDRESS_OTHER = 4142,
    ORIGINAL_ARRIVAL_TIME = 4143,
    MSGCLASS = 4144,
    CONTENT_TYPE = 4145,
    ENCRYPTION_TYPE = 4146,
    CONNECTION_SERVER_PORT = 4147,
    CLIENT_AUTH_USER = 4148,
    CLIENT_AUTH_TYPE = 4149,
    CRC_GLOBAL = 4150,
    CRC_RECIPS = 4151,
    INBOUND_MAIL_FROM_AUTH = 4152,
    AFTER__ = 4153,
};
pub const IMMPID_MP_BEFORE__ = IMMPID_MP_ENUM.BEFORE__;
pub const IMMPID_MP_RECIPIENT_LIST = IMMPID_MP_ENUM.RECIPIENT_LIST;
pub const IMMPID_MP_CONTENT_FILE_NAME = IMMPID_MP_ENUM.CONTENT_FILE_NAME;
pub const IMMPID_MP_SENDER_ADDRESS_SMTP = IMMPID_MP_ENUM.SENDER_ADDRESS_SMTP;
pub const IMMPID_MP_SENDER_ADDRESS_X500 = IMMPID_MP_ENUM.SENDER_ADDRESS_X500;
pub const IMMPID_MP_SENDER_ADDRESS_X400 = IMMPID_MP_ENUM.SENDER_ADDRESS_X400;
pub const IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN = IMMPID_MP_ENUM.SENDER_ADDRESS_LEGACY_EX_DN;
pub const IMMPID_MP_DOMAIN_LIST = IMMPID_MP_ENUM.DOMAIN_LIST;
pub const IMMPID_MP_PICKUP_FILE_NAME = IMMPID_MP_ENUM.PICKUP_FILE_NAME;
pub const IMMPID_MP_AUTHENTICATED_USER_NAME = IMMPID_MP_ENUM.AUTHENTICATED_USER_NAME;
pub const IMMPID_MP_CONNECTION_IP_ADDRESS = IMMPID_MP_ENUM.CONNECTION_IP_ADDRESS;
pub const IMMPID_MP_HELO_DOMAIN = IMMPID_MP_ENUM.HELO_DOMAIN;
pub const IMMPID_MP_EIGHTBIT_MIME_OPTION = IMMPID_MP_ENUM.EIGHTBIT_MIME_OPTION;
pub const IMMPID_MP_CHUNKING_OPTION = IMMPID_MP_ENUM.CHUNKING_OPTION;
pub const IMMPID_MP_BINARYMIME_OPTION = IMMPID_MP_ENUM.BINARYMIME_OPTION;
pub const IMMPID_MP_REMOTE_AUTHENTICATION_TYPE = IMMPID_MP_ENUM.REMOTE_AUTHENTICATION_TYPE;
pub const IMMPID_MP_ERROR_CODE = IMMPID_MP_ENUM.ERROR_CODE;
pub const IMMPID_MP_DSN_ENVID_VALUE = IMMPID_MP_ENUM.DSN_ENVID_VALUE;
pub const IMMPID_MP_DSN_RET_VALUE = IMMPID_MP_ENUM.DSN_RET_VALUE;
pub const IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE = IMMPID_MP_ENUM.REMOTE_SERVER_DSN_CAPABLE;
pub const IMMPID_MP_ARRIVAL_TIME = IMMPID_MP_ENUM.ARRIVAL_TIME;
pub const IMMPID_MP_MESSAGE_STATUS = IMMPID_MP_ENUM.MESSAGE_STATUS;
pub const IMMPID_MP_EXPIRE_DELAY = IMMPID_MP_ENUM.EXPIRE_DELAY;
pub const IMMPID_MP_EXPIRE_NDR = IMMPID_MP_ENUM.EXPIRE_NDR;
pub const IMMPID_MP_LOCAL_EXPIRE_DELAY = IMMPID_MP_ENUM.LOCAL_EXPIRE_DELAY;
pub const IMMPID_MP_LOCAL_EXPIRE_NDR = IMMPID_MP_ENUM.LOCAL_EXPIRE_NDR;
pub const IMMPID_MP_ARRIVAL_FILETIME = IMMPID_MP_ENUM.ARRIVAL_FILETIME;
pub const IMMPID_MP_HR_CAT_STATUS = IMMPID_MP_ENUM.HR_CAT_STATUS;
pub const IMMPID_MP_MSG_GUID = IMMPID_MP_ENUM.MSG_GUID;
pub const IMMPID_MP_SUPERSEDES_MSG_GUID = IMMPID_MP_ENUM.SUPERSEDES_MSG_GUID;
pub const IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF = IMMPID_MP_ENUM.SCANNED_FOR_CRLF_DOT_CRLF;
pub const IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF = IMMPID_MP_ENUM.FOUND_EMBEDDED_CRLF_DOT_CRLF;
pub const IMMPID_MP_MSG_SIZE_HINT = IMMPID_MP_ENUM.MSG_SIZE_HINT;
pub const IMMPID_MP_RFC822_MSG_ID = IMMPID_MP_ENUM.RFC822_MSG_ID;
pub const IMMPID_MP_RFC822_MSG_SUBJECT = IMMPID_MP_ENUM.RFC822_MSG_SUBJECT;
pub const IMMPID_MP_RFC822_FROM_ADDRESS = IMMPID_MP_ENUM.RFC822_FROM_ADDRESS;
pub const IMMPID_MP_RFC822_TO_ADDRESS = IMMPID_MP_ENUM.RFC822_TO_ADDRESS;
pub const IMMPID_MP_RFC822_CC_ADDRESS = IMMPID_MP_ENUM.RFC822_CC_ADDRESS;
pub const IMMPID_MP_RFC822_BCC_ADDRESS = IMMPID_MP_ENUM.RFC822_BCC_ADDRESS;
pub const IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS = IMMPID_MP_ENUM.CONNECTION_SERVER_IP_ADDRESS;
pub const IMMPID_MP_SERVER_NAME = IMMPID_MP_ENUM.SERVER_NAME;
pub const IMMPID_MP_SERVER_VERSION = IMMPID_MP_ENUM.SERVER_VERSION;
pub const IMMPID_MP_NUM_RECIPIENTS = IMMPID_MP_ENUM.NUM_RECIPIENTS;
pub const IMMPID_MP_X_PRIORITY = IMMPID_MP_ENUM.X_PRIORITY;
pub const IMMPID_MP_FROM_ADDRESS = IMMPID_MP_ENUM.FROM_ADDRESS;
pub const IMMPID_MP_SENDER_ADDRESS = IMMPID_MP_ENUM.SENDER_ADDRESS;
pub const IMMPID_MP_DEFERRED_DELIVERY_FILETIME = IMMPID_MP_ENUM.DEFERRED_DELIVERY_FILETIME;
pub const IMMPID_MP_SENDER_ADDRESS_OTHER = IMMPID_MP_ENUM.SENDER_ADDRESS_OTHER;
pub const IMMPID_MP_ORIGINAL_ARRIVAL_TIME = IMMPID_MP_ENUM.ORIGINAL_ARRIVAL_TIME;
pub const IMMPID_MP_MSGCLASS = IMMPID_MP_ENUM.MSGCLASS;
pub const IMMPID_MP_CONTENT_TYPE = IMMPID_MP_ENUM.CONTENT_TYPE;
pub const IMMPID_MP_ENCRYPTION_TYPE = IMMPID_MP_ENUM.ENCRYPTION_TYPE;
pub const IMMPID_MP_CONNECTION_SERVER_PORT = IMMPID_MP_ENUM.CONNECTION_SERVER_PORT;
pub const IMMPID_MP_CLIENT_AUTH_USER = IMMPID_MP_ENUM.CLIENT_AUTH_USER;
pub const IMMPID_MP_CLIENT_AUTH_TYPE = IMMPID_MP_ENUM.CLIENT_AUTH_TYPE;
pub const IMMPID_MP_CRC_GLOBAL = IMMPID_MP_ENUM.CRC_GLOBAL;
pub const IMMPID_MP_CRC_RECIPS = IMMPID_MP_ENUM.CRC_RECIPS;
pub const IMMPID_MP_INBOUND_MAIL_FROM_AUTH = IMMPID_MP_ENUM.INBOUND_MAIL_FROM_AUTH;
pub const IMMPID_MP_AFTER__ = IMMPID_MP_ENUM.AFTER__;

const CLSID_tagIMMPID_RP_STRUCT_Value = @import("../zig.zig").Guid.initString("79e82048-d320-11d1-9ff4-00c04fa37348");
pub const CLSID_tagIMMPID_RP_STRUCT = &CLSID_tagIMMPID_RP_STRUCT_Value;

pub const IMMPID_RP_ENUM = enum(i32) {
    BEFORE__ = 8191,
    DSN_NOTIFY_SUCCESS = 8192,
    DSN_NOTIFY_INVALID = 8193,
    ADDRESS_TYPE = 8194,
    ADDRESS = 8195,
    ADDRESS_TYPE_SMTP = 8196,
    ERROR_CODE = 8197,
    ERROR_STRING = 8198,
    DSN_NOTIFY_VALUE = 8199,
    DSN_ORCPT_VALUE = 8200,
    ADDRESS_SMTP = 8201,
    ADDRESS_X400 = 8202,
    ADDRESS_X500 = 8203,
    LEGACY_EX_DN = 8204,
    RECIPIENT_FLAGS = 8205,
    SMTP_STATUS_STRING = 8206,
    DSN_PRE_CAT_ADDRESS = 8207,
    MDB_GUID = 8208,
    USER_GUID = 8209,
    DOMAIN = 8210,
    ADDRESS_OTHER = 8211,
    DISPLAY_NAME = 8212,
    AFTER__ = 8213,
};
pub const IMMPID_RP_BEFORE__ = IMMPID_RP_ENUM.BEFORE__;
pub const IMMPID_RP_DSN_NOTIFY_SUCCESS = IMMPID_RP_ENUM.DSN_NOTIFY_SUCCESS;
pub const IMMPID_RP_DSN_NOTIFY_INVALID = IMMPID_RP_ENUM.DSN_NOTIFY_INVALID;
pub const IMMPID_RP_ADDRESS_TYPE = IMMPID_RP_ENUM.ADDRESS_TYPE;
pub const IMMPID_RP_ADDRESS = IMMPID_RP_ENUM.ADDRESS;
pub const IMMPID_RP_ADDRESS_TYPE_SMTP = IMMPID_RP_ENUM.ADDRESS_TYPE_SMTP;
pub const IMMPID_RP_ERROR_CODE = IMMPID_RP_ENUM.ERROR_CODE;
pub const IMMPID_RP_ERROR_STRING = IMMPID_RP_ENUM.ERROR_STRING;
pub const IMMPID_RP_DSN_NOTIFY_VALUE = IMMPID_RP_ENUM.DSN_NOTIFY_VALUE;
pub const IMMPID_RP_DSN_ORCPT_VALUE = IMMPID_RP_ENUM.DSN_ORCPT_VALUE;
pub const IMMPID_RP_ADDRESS_SMTP = IMMPID_RP_ENUM.ADDRESS_SMTP;
pub const IMMPID_RP_ADDRESS_X400 = IMMPID_RP_ENUM.ADDRESS_X400;
pub const IMMPID_RP_ADDRESS_X500 = IMMPID_RP_ENUM.ADDRESS_X500;
pub const IMMPID_RP_LEGACY_EX_DN = IMMPID_RP_ENUM.LEGACY_EX_DN;
pub const IMMPID_RP_RECIPIENT_FLAGS = IMMPID_RP_ENUM.RECIPIENT_FLAGS;
pub const IMMPID_RP_SMTP_STATUS_STRING = IMMPID_RP_ENUM.SMTP_STATUS_STRING;
pub const IMMPID_RP_DSN_PRE_CAT_ADDRESS = IMMPID_RP_ENUM.DSN_PRE_CAT_ADDRESS;
pub const IMMPID_RP_MDB_GUID = IMMPID_RP_ENUM.MDB_GUID;
pub const IMMPID_RP_USER_GUID = IMMPID_RP_ENUM.USER_GUID;
pub const IMMPID_RP_DOMAIN = IMMPID_RP_ENUM.DOMAIN;
pub const IMMPID_RP_ADDRESS_OTHER = IMMPID_RP_ENUM.ADDRESS_OTHER;
pub const IMMPID_RP_DISPLAY_NAME = IMMPID_RP_ENUM.DISPLAY_NAME;
pub const IMMPID_RP_AFTER__ = IMMPID_RP_ENUM.AFTER__;

const CLSID_tagIMMPID_MPV_STRUCT_Value = @import("../zig.zig").Guid.initString("cbe69706-c9bd-11d1-9ff2-00c04fa37348");
pub const CLSID_tagIMMPID_MPV_STRUCT = &CLSID_tagIMMPID_MPV_STRUCT_Value;

pub const IMMPID_MPV_ENUM = enum(i32) {
    BEFORE__ = 12287,
    STORE_DRIVER_HANDLE = 12288,
    MESSAGE_CREATION_FLAGS = 12289,
    MESSAGE_OPEN_HANDLES = 12290,
    TOTAL_OPEN_HANDLES = 12291,
    TOTAL_OPEN_PROPERTY_STREAM_HANDLES = 12292,
    TOTAL_OPEN_CONTENT_HANDLES = 12293,
    AFTER__ = 12294,
};
pub const IMMPID_MPV_BEFORE__ = IMMPID_MPV_ENUM.BEFORE__;
pub const IMMPID_MPV_STORE_DRIVER_HANDLE = IMMPID_MPV_ENUM.STORE_DRIVER_HANDLE;
pub const IMMPID_MPV_MESSAGE_CREATION_FLAGS = IMMPID_MPV_ENUM.MESSAGE_CREATION_FLAGS;
pub const IMMPID_MPV_MESSAGE_OPEN_HANDLES = IMMPID_MPV_ENUM.MESSAGE_OPEN_HANDLES;
pub const IMMPID_MPV_TOTAL_OPEN_HANDLES = IMMPID_MPV_ENUM.TOTAL_OPEN_HANDLES;
pub const IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES = IMMPID_MPV_ENUM.TOTAL_OPEN_PROPERTY_STREAM_HANDLES;
pub const IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES = IMMPID_MPV_ENUM.TOTAL_OPEN_CONTENT_HANDLES;
pub const IMMPID_MPV_AFTER__ = IMMPID_MPV_ENUM.AFTER__;

pub const IMMP_MPV_STORE_DRIVER_HANDLE = extern struct {
    guidSignature: Guid,
};

const CLSID_tagIMMPID_RPV_STRUCT_Value = @import("../zig.zig").Guid.initString("79e82049-d320-11d1-9ff4-00c04fa37348");
pub const CLSID_tagIMMPID_RPV_STRUCT = &CLSID_tagIMMPID_RPV_STRUCT_Value;

pub const IMMPID_RPV_ENUM = enum(i32) {
    BEFORE__ = 16383,
    DONT_DELIVER = 16384,
    NO_NAME_COLLISIONS = 16385,
    AFTER__ = 16386,
};
pub const IMMPID_RPV_BEFORE__ = IMMPID_RPV_ENUM.BEFORE__;
pub const IMMPID_RPV_DONT_DELIVER = IMMPID_RPV_ENUM.DONT_DELIVER;
pub const IMMPID_RPV_NO_NAME_COLLISIONS = IMMPID_RPV_ENUM.NO_NAME_COLLISIONS;
pub const IMMPID_RPV_AFTER__ = IMMPID_RPV_ENUM.AFTER__;

const CLSID_tagIMMPID_NMP_STRUCT_Value = @import("../zig.zig").Guid.initString("7433a9aa-20e2-11d2-94d6-00c04fa379f1");
pub const CLSID_tagIMMPID_NMP_STRUCT = &CLSID_tagIMMPID_NMP_STRUCT_Value;

pub const IMMPID_NMP_ENUM = enum(i32) {
    BEFORE__ = 24575,
    SECONDARY_GROUPS = 24576,
    SECONDARY_ARTNUM = 24577,
    PRIMARY_GROUP = 24578,
    PRIMARY_ARTID = 24579,
    POST_TOKEN = 24580,
    NEWSGROUP_LIST = 24581,
    HEADERS = 24582,
    NNTP_PROCESSING = 24583,
    NNTP_APPROVED_HEADER = 24584,
    AFTER__ = 24585,
};
pub const IMMPID_NMP_BEFORE__ = IMMPID_NMP_ENUM.BEFORE__;
pub const IMMPID_NMP_SECONDARY_GROUPS = IMMPID_NMP_ENUM.SECONDARY_GROUPS;
pub const IMMPID_NMP_SECONDARY_ARTNUM = IMMPID_NMP_ENUM.SECONDARY_ARTNUM;
pub const IMMPID_NMP_PRIMARY_GROUP = IMMPID_NMP_ENUM.PRIMARY_GROUP;
pub const IMMPID_NMP_PRIMARY_ARTID = IMMPID_NMP_ENUM.PRIMARY_ARTID;
pub const IMMPID_NMP_POST_TOKEN = IMMPID_NMP_ENUM.POST_TOKEN;
pub const IMMPID_NMP_NEWSGROUP_LIST = IMMPID_NMP_ENUM.NEWSGROUP_LIST;
pub const IMMPID_NMP_HEADERS = IMMPID_NMP_ENUM.HEADERS;
pub const IMMPID_NMP_NNTP_PROCESSING = IMMPID_NMP_ENUM.NNTP_PROCESSING;
pub const IMMPID_NMP_NNTP_APPROVED_HEADER = IMMPID_NMP_ENUM.NNTP_APPROVED_HEADER;
pub const IMMPID_NMP_AFTER__ = IMMPID_NMP_ENUM.AFTER__;

const CLSID_tagIMMPID_CPV_STRUCT_Value = @import("../zig.zig").Guid.initString("a2a76b2a-e52d-11d1-aa64-00c04fa35b82");
pub const CLSID_tagIMMPID_CPV_STRUCT = &CLSID_tagIMMPID_CPV_STRUCT_Value;

pub const IMMPID_CPV_ENUM = enum(i32) {
    V_BEFORE__ = 32767,
    _START = 32768,
    V_AFTER__ = 32769,
};
pub const IMMPID_CPV_BEFORE__ = IMMPID_CPV_ENUM.V_BEFORE__;
pub const IMMPID_CP_START = IMMPID_CPV_ENUM._START;
pub const IMMPID_CPV_AFTER__ = IMMPID_CPV_ENUM.V_AFTER__;

pub const tagIMMPID_GUIDLIST_ITEM = extern struct {
    pguid: ?*const Guid,
    dwStart: u32,
    dwLast: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (6)
//--------------------------------------------------------------------------------
pub extern "MAPI32" fn OpenIMsgSession(
    lpMalloc: ?*IMalloc,
    ulFlags: u32,
    lppMsgSess: ?*?*_MSGSESS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn CloseIMsgSession(
    lpMsgSess: ?*_MSGSESS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MAPI32" fn OpenIMsgOnIStg(
    lpMsgSess: ?*_MSGSESS,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpMalloc: ?*IMalloc,
    lpMapiSup: ?*anyopaque,
    lpStg: ?*IStorage,
    lpfMsgCallRelease: ?*?MSGCALLRELEASE,
    ulCallerData: u32,
    ulFlags: u32,
    lppMsg: ?*?*IMessage,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn GetAttribIMsgOnIStg(
    lpObject: ?*anyopaque,
    lpPropTagArray: ?*SPropTagArray,
    lppPropAttrArray: ?*?*SPropAttrArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn SetAttribIMsgOnIStg(
    lpObject: ?*anyopaque,
    lpPropTags: ?*SPropTagArray,
    lpPropAttrs: ?*SPropAttrArray,
    lppPropProblems: ?*?*SPropProblemArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn MapStorageSCode(
    StgSCode: i32,
) callconv(@import("std").os.windows.WINAPI) i32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (18)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumVARIANT = @import("../system/ole.zig").IEnumVARIANT;
const IMalloc = @import("../system/com.zig").IMalloc;
const IMessage = @import("../system/address_book.zig").IMessage;
const IPropertyStorage = @import("../system/com/structured_storage.zig").IPropertyStorage;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPALLOCATEBUFFER = @import("../system/address_book.zig").LPALLOCATEBUFFER;
const LPALLOCATEMORE = @import("../system/address_book.zig").LPALLOCATEMORE;
const LPFREEBUFFER = @import("../system/address_book.zig").LPFREEBUFFER;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const SPropProblemArray = @import("../system/address_book.zig").SPropProblemArray;
const SPropTagArray = @import("../system/address_book.zig").SPropTagArray;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "MSGCALLRELEASE")) { _ = MSGCALLRELEASE; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
