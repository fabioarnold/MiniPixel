//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (43)
//--------------------------------------------------------------------------------
pub const FD_EVENTID_PRIVATE = @as(u32, 100);
pub const FD_EVENTID = @as(u32, 1000);
pub const FD_EVENTID_SEARCHCOMPLETE = @as(u32, 1000);
pub const FD_EVENTID_ASYNCTHREADEXIT = @as(u32, 1001);
pub const FD_EVENTID_SEARCHSTART = @as(u32, 1002);
pub const FD_EVENTID_IPADDRESSCHANGE = @as(u32, 1003);
pub const FD_EVENTID_QUERYREFRESH = @as(u32, 1004);
pub const SID_PnpProvider = Guid.initString("8101368e-cabb-4426-acff-96c410812000");
pub const SID_UPnPActivator = Guid.initString("0d0d66eb-cf74-4164-b52f-08344672dd46");
pub const SID_EnumInterface = Guid.initString("40eab0b9-4d7f-4b53-a334-1581dd9041f4");
pub const SID_PNPXPropertyStore = Guid.initString("a86530b1-542f-439f-b71c-b0756b13677a");
pub const SID_PNPXAssociation = Guid.initString("cee8ccc9-4f6b-4469-a235-5a22869eef03");
pub const SID_PNPXServiceCollection = Guid.initString("439e80ee-a217-4712-9fa6-deabd9c2a727");
pub const SID_FDPairingHandler = Guid.initString("383b69fa-5486-49da-91f5-d63c24c8e9d0");
pub const SID_EnumDeviceFunction = Guid.initString("13e0e9e2-c3fa-4e3c-906e-64502fa4dc95");
pub const SID_UnpairProvider = Guid.initString("89a502fc-857b-4698-a0b7-027192002f9e");
pub const SID_DeviceDisplayStatusManager = Guid.initString("f59aa553-8309-46ca-9736-1ac3c62d6031");
pub const SID_FunctionDiscoveryProviderRefresh = Guid.initString("2b4cbdc9-31c4-40d4-a62d-772aa174ed52");
pub const SID_UninstallDeviceFunction = Guid.initString("c920566e-5671-4496-8025-bf0b89bd44cd");
pub const FMTID_FD = Guid.initString("904b03a2-471d-423c-a584-f3483238a146");
pub const FD_Visibility_Default = @as(u32, 0);
pub const FD_Visibility_Hidden = @as(u32, 1);
pub const FMTID_Device = Guid.initString("78c34fc8-104a-4aca-9ea4-524d52996e57");
pub const FMTID_DeviceInterface = Guid.initString("53808008-07bb-4661-bc3c-b5953e708560");
pub const FMTID_Pairing = Guid.initString("8807cae6-7db6-4f10-8ee4-435eaa1392bc");
pub const FMTID_WSD = Guid.initString("92506491-ff95-4724-a05a-5b81885a7c92");
pub const FMTID_PNPX = Guid.initString("656a3bb3-ecc0-43fd-8477-4ae0404a96cd");
pub const FMTID_PNPXDynamicProperty = Guid.initString("4fc5077e-b686-44be-93e3-86cafe368ccd");
pub const PNPX_INSTALLSTATE_NOTINSTALLED = @as(u32, 0);
pub const PNPX_INSTALLSTATE_INSTALLED = @as(u32, 1);
pub const PNPX_INSTALLSTATE_INSTALLING = @as(u32, 2);
pub const PNPX_INSTALLSTATE_FAILED = @as(u32, 3);
pub const FD_LONGHORN = @as(u32, 1);
pub const MAX_FDCONSTRAINTNAME_LENGTH = @as(u32, 100);
pub const MAX_FDCONSTRAINTVALUE_LENGTH = @as(u32, 1000);
pub const E_FDPAIRING_NOCONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1882193919));
pub const E_FDPAIRING_HWFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1882193918));
pub const E_FDPAIRING_AUTHFAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1882193917));
pub const E_FDPAIRING_CONNECTTIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1882193916));
pub const E_FDPAIRING_TOOMANYCONNECTIONS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1882193915));
pub const E_FDPAIRING_AUTHNOTALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1882193914));
pub const E_FDPAIRING_IPBUSDISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1882193913));
pub const E_FDPAIRING_NOPROFILES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1882193912));

//--------------------------------------------------------------------------------
// Section: Types (27)
//--------------------------------------------------------------------------------
pub const PropertyConstraint = enum(i32) {
    EQUALS = 0,
    NOTEQUAL = 1,
    LESSTHAN = 2,
    LESSTHANOREQUAL = 3,
    GREATERTHAN = 4,
    GREATERTHANOREQUAL = 5,
    STARTSWITH = 6,
    EXISTS = 7,
    DOESNOTEXIST = 8,
    CONTAINS = 9,
};
pub const QC_EQUALS = PropertyConstraint.EQUALS;
pub const QC_NOTEQUAL = PropertyConstraint.NOTEQUAL;
pub const QC_LESSTHAN = PropertyConstraint.LESSTHAN;
pub const QC_LESSTHANOREQUAL = PropertyConstraint.LESSTHANOREQUAL;
pub const QC_GREATERTHAN = PropertyConstraint.GREATERTHAN;
pub const QC_GREATERTHANOREQUAL = PropertyConstraint.GREATERTHANOREQUAL;
pub const QC_STARTSWITH = PropertyConstraint.STARTSWITH;
pub const QC_EXISTS = PropertyConstraint.EXISTS;
pub const QC_DOESNOTEXIST = PropertyConstraint.DOESNOTEXIST;
pub const QC_CONTAINS = PropertyConstraint.CONTAINS;

pub const SystemVisibilityFlags = enum(i32) {
    SYSTEM = 0,
    USER = 1,
};
pub const SVF_SYSTEM = SystemVisibilityFlags.SYSTEM;
pub const SVF_USER = SystemVisibilityFlags.USER;

pub const QueryUpdateAction = enum(i32) {
    ADD = 0,
    REMOVE = 1,
    CHANGE = 2,
};
pub const QUA_ADD = QueryUpdateAction.ADD;
pub const QUA_REMOVE = QueryUpdateAction.REMOVE;
pub const QUA_CHANGE = QueryUpdateAction.CHANGE;

pub const QueryCategoryType = enum(i32) {
    PROVIDER = 0,
    LAYERED = 1,
};
pub const QCT_PROVIDER = QueryCategoryType.PROVIDER;
pub const QCT_LAYERED = QueryCategoryType.LAYERED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionDiscoveryNotification_Value = @import("../zig.zig").Guid.initString("5f6c1ba8-5330-422e-a368-572b244d3f87");
pub const IID_IFunctionDiscoveryNotification = &IID_IFunctionDiscoveryNotification_Value;
pub const IFunctionDiscoveryNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdate: fn(
            self: *const IFunctionDiscoveryNotification,
            enumQueryUpdateAction: QueryUpdateAction,
            fdqcQueryContext: u64,
            pIFunctionInstance: ?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnError: fn(
            self: *const IFunctionDiscoveryNotification,
            hr: HRESULT,
            fdqcQueryContext: u64,
            pszProvider: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEvent: fn(
            self: *const IFunctionDiscoveryNotification,
            dwEventID: u32,
            fdqcQueryContext: u64,
            pszProvider: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryNotification_OnUpdate(self: *const T, enumQueryUpdateAction: QueryUpdateAction, fdqcQueryContext: u64, pIFunctionInstance: ?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryNotification.VTable, self.vtable).OnUpdate(@ptrCast(*const IFunctionDiscoveryNotification, self), enumQueryUpdateAction, fdqcQueryContext, pIFunctionInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryNotification_OnError(self: *const T, hr: HRESULT, fdqcQueryContext: u64, pszProvider: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryNotification.VTable, self.vtable).OnError(@ptrCast(*const IFunctionDiscoveryNotification, self), hr, fdqcQueryContext, pszProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryNotification_OnEvent(self: *const T, dwEventID: u32, fdqcQueryContext: u64, pszProvider: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryNotification.VTable, self.vtable).OnEvent(@ptrCast(*const IFunctionDiscoveryNotification, self), dwEventID, fdqcQueryContext, pszProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionDiscovery_Value = @import("../zig.zig").Guid.initString("4df99b70-e148-4432-b004-4c9eeb535a5e");
pub const IID_IFunctionDiscovery = &IID_IFunctionDiscovery_Value;
pub const IFunctionDiscovery = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInstanceCollection: fn(
            self: *const IFunctionDiscovery,
            pszCategory: ?[*:0]const u16,
            pszSubCategory: ?[*:0]const u16,
            fIncludeAllSubCategories: BOOL,
            ppIFunctionInstanceCollection: ?*?*IFunctionInstanceCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInstance: fn(
            self: *const IFunctionDiscovery,
            pszFunctionInstanceIdentity: ?[*:0]const u16,
            ppIFunctionInstance: ?*?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstanceCollectionQuery: fn(
            self: *const IFunctionDiscovery,
            pszCategory: ?[*:0]const u16,
            pszSubCategory: ?[*:0]const u16,
            fIncludeAllSubCategories: BOOL,
            pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification,
            pfdqcQueryContext: ?*u64,
            ppIFunctionInstanceCollectionQuery: ?*?*IFunctionInstanceCollectionQuery,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstanceQuery: fn(
            self: *const IFunctionDiscovery,
            pszFunctionInstanceIdentity: ?[*:0]const u16,
            pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification,
            pfdqcQueryContext: ?*u64,
            ppIFunctionInstanceQuery: ?*?*IFunctionInstanceQuery,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddInstance: fn(
            self: *const IFunctionDiscovery,
            enumSystemVisibility: SystemVisibilityFlags,
            pszCategory: ?[*:0]const u16,
            pszSubCategory: ?[*:0]const u16,
            pszCategoryIdentity: ?[*:0]const u16,
            ppIFunctionInstance: ?*?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveInstance: fn(
            self: *const IFunctionDiscovery,
            enumSystemVisibility: SystemVisibilityFlags,
            pszCategory: ?[*:0]const u16,
            pszSubCategory: ?[*:0]const u16,
            pszCategoryIdentity: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscovery_GetInstanceCollection(self: *const T, pszCategory: ?[*:0]const u16, pszSubCategory: ?[*:0]const u16, fIncludeAllSubCategories: BOOL, ppIFunctionInstanceCollection: ?*?*IFunctionInstanceCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscovery.VTable, self.vtable).GetInstanceCollection(@ptrCast(*const IFunctionDiscovery, self), pszCategory, pszSubCategory, fIncludeAllSubCategories, ppIFunctionInstanceCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscovery_GetInstance(self: *const T, pszFunctionInstanceIdentity: ?[*:0]const u16, ppIFunctionInstance: ?*?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscovery.VTable, self.vtable).GetInstance(@ptrCast(*const IFunctionDiscovery, self), pszFunctionInstanceIdentity, ppIFunctionInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscovery_CreateInstanceCollectionQuery(self: *const T, pszCategory: ?[*:0]const u16, pszSubCategory: ?[*:0]const u16, fIncludeAllSubCategories: BOOL, pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification, pfdqcQueryContext: ?*u64, ppIFunctionInstanceCollectionQuery: ?*?*IFunctionInstanceCollectionQuery) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscovery.VTable, self.vtable).CreateInstanceCollectionQuery(@ptrCast(*const IFunctionDiscovery, self), pszCategory, pszSubCategory, fIncludeAllSubCategories, pIFunctionDiscoveryNotification, pfdqcQueryContext, ppIFunctionInstanceCollectionQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscovery_CreateInstanceQuery(self: *const T, pszFunctionInstanceIdentity: ?[*:0]const u16, pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification, pfdqcQueryContext: ?*u64, ppIFunctionInstanceQuery: ?*?*IFunctionInstanceQuery) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscovery.VTable, self.vtable).CreateInstanceQuery(@ptrCast(*const IFunctionDiscovery, self), pszFunctionInstanceIdentity, pIFunctionDiscoveryNotification, pfdqcQueryContext, ppIFunctionInstanceQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscovery_AddInstance(self: *const T, enumSystemVisibility: SystemVisibilityFlags, pszCategory: ?[*:0]const u16, pszSubCategory: ?[*:0]const u16, pszCategoryIdentity: ?[*:0]const u16, ppIFunctionInstance: ?*?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscovery.VTable, self.vtable).AddInstance(@ptrCast(*const IFunctionDiscovery, self), enumSystemVisibility, pszCategory, pszSubCategory, pszCategoryIdentity, ppIFunctionInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscovery_RemoveInstance(self: *const T, enumSystemVisibility: SystemVisibilityFlags, pszCategory: ?[*:0]const u16, pszSubCategory: ?[*:0]const u16, pszCategoryIdentity: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscovery.VTable, self.vtable).RemoveInstance(@ptrCast(*const IFunctionDiscovery, self), enumSystemVisibility, pszCategory, pszSubCategory, pszCategoryIdentity);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionInstance_Value = @import("../zig.zig").Guid.initString("33591c10-0bed-4f02-b0ab-1530d5533ee9");
pub const IID_IFunctionInstance = &IID_IFunctionInstance_Value;
pub const IFunctionInstance = extern struct {
    pub const VTable = extern struct {
        base: IServiceProvider.VTable,
        GetID: fn(
            self: *const IFunctionInstance,
            ppszCoMemIdentity: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderInstanceID: fn(
            self: *const IFunctionInstance,
            ppszCoMemProviderInstanceIdentity: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenPropertyStore: fn(
            self: *const IFunctionInstance,
            dwStgAccess: u32,
            ppIPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategory: fn(
            self: *const IFunctionInstance,
            ppszCoMemCategory: ?*?*u16,
            ppszCoMemSubCategory: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IServiceProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstance_GetID(self: *const T, ppszCoMemIdentity: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstance.VTable, self.vtable).GetID(@ptrCast(*const IFunctionInstance, self), ppszCoMemIdentity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstance_GetProviderInstanceID(self: *const T, ppszCoMemProviderInstanceIdentity: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstance.VTable, self.vtable).GetProviderInstanceID(@ptrCast(*const IFunctionInstance, self), ppszCoMemProviderInstanceIdentity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstance_OpenPropertyStore(self: *const T, dwStgAccess: u32, ppIPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstance.VTable, self.vtable).OpenPropertyStore(@ptrCast(*const IFunctionInstance, self), dwStgAccess, ppIPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstance_GetCategory(self: *const T, ppszCoMemCategory: ?*?*u16, ppszCoMemSubCategory: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstance.VTable, self.vtable).GetCategory(@ptrCast(*const IFunctionInstance, self), ppszCoMemCategory, ppszCoMemSubCategory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionInstanceCollection_Value = @import("../zig.zig").Guid.initString("f0a3d895-855c-42a2-948d-2f97d450ecb1");
pub const IID_IFunctionInstanceCollection = &IID_IFunctionInstanceCollection_Value;
pub const IFunctionInstanceCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IFunctionInstanceCollection,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: fn(
            self: *const IFunctionInstanceCollection,
            pszInstanceIdentity: ?[*:0]const u16,
            pdwIndex: ?*u32,
            ppIFunctionInstance: ?*?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IFunctionInstanceCollection,
            dwIndex: u32,
            ppIFunctionInstance: ?*?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IFunctionInstanceCollection,
            pIFunctionInstance: ?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IFunctionInstanceCollection,
            dwIndex: u32,
            ppIFunctionInstance: ?*?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IFunctionInstanceCollection,
            dwIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAll: fn(
            self: *const IFunctionInstanceCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollection_GetCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollection.VTable, self.vtable).GetCount(@ptrCast(*const IFunctionInstanceCollection, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollection_Get(self: *const T, pszInstanceIdentity: ?[*:0]const u16, pdwIndex: ?*u32, ppIFunctionInstance: ?*?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollection.VTable, self.vtable).Get(@ptrCast(*const IFunctionInstanceCollection, self), pszInstanceIdentity, pdwIndex, ppIFunctionInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollection_Item(self: *const T, dwIndex: u32, ppIFunctionInstance: ?*?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollection.VTable, self.vtable).Item(@ptrCast(*const IFunctionInstanceCollection, self), dwIndex, ppIFunctionInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollection_Add(self: *const T, pIFunctionInstance: ?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollection.VTable, self.vtable).Add(@ptrCast(*const IFunctionInstanceCollection, self), pIFunctionInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollection_Remove(self: *const T, dwIndex: u32, ppIFunctionInstance: ?*?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollection.VTable, self.vtable).Remove(@ptrCast(*const IFunctionInstanceCollection, self), dwIndex, ppIFunctionInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollection_Delete(self: *const T, dwIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollection.VTable, self.vtable).Delete(@ptrCast(*const IFunctionInstanceCollection, self), dwIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollection_DeleteAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollection.VTable, self.vtable).DeleteAll(@ptrCast(*const IFunctionInstanceCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPropertyStoreCollection_Value = @import("../zig.zig").Guid.initString("d14d9c30-12d2-42d8-bce4-c60c2bb226fa");
pub const IID_IPropertyStoreCollection = &IID_IPropertyStoreCollection_Value;
pub const IPropertyStoreCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IPropertyStoreCollection,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: fn(
            self: *const IPropertyStoreCollection,
            pszInstanceIdentity: ?[*:0]const u16,
            pdwIndex: ?*u32,
            ppIPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IPropertyStoreCollection,
            dwIndex: u32,
            ppIPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IPropertyStoreCollection,
            pIPropertyStore: ?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IPropertyStoreCollection,
            dwIndex: u32,
            pIPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IPropertyStoreCollection,
            dwIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAll: fn(
            self: *const IPropertyStoreCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStoreCollection_GetCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStoreCollection.VTable, self.vtable).GetCount(@ptrCast(*const IPropertyStoreCollection, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStoreCollection_Get(self: *const T, pszInstanceIdentity: ?[*:0]const u16, pdwIndex: ?*u32, ppIPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStoreCollection.VTable, self.vtable).Get(@ptrCast(*const IPropertyStoreCollection, self), pszInstanceIdentity, pdwIndex, ppIPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStoreCollection_Item(self: *const T, dwIndex: u32, ppIPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStoreCollection.VTable, self.vtable).Item(@ptrCast(*const IPropertyStoreCollection, self), dwIndex, ppIPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStoreCollection_Add(self: *const T, pIPropertyStore: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStoreCollection.VTable, self.vtable).Add(@ptrCast(*const IPropertyStoreCollection, self), pIPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStoreCollection_Remove(self: *const T, dwIndex: u32, pIPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStoreCollection.VTable, self.vtable).Remove(@ptrCast(*const IPropertyStoreCollection, self), dwIndex, pIPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStoreCollection_Delete(self: *const T, dwIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStoreCollection.VTable, self.vtable).Delete(@ptrCast(*const IPropertyStoreCollection, self), dwIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStoreCollection_DeleteAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyStoreCollection.VTable, self.vtable).DeleteAll(@ptrCast(*const IPropertyStoreCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionInstanceQuery_Value = @import("../zig.zig").Guid.initString("6242bc6b-90ec-4b37-bb46-e229fd84ed95");
pub const IID_IFunctionInstanceQuery = &IID_IFunctionInstanceQuery_Value;
pub const IFunctionInstanceQuery = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Execute: fn(
            self: *const IFunctionInstanceQuery,
            ppIFunctionInstance: ?*?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceQuery_Execute(self: *const T, ppIFunctionInstance: ?*?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceQuery.VTable, self.vtable).Execute(@ptrCast(*const IFunctionInstanceQuery, self), ppIFunctionInstance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionInstanceCollectionQuery_Value = @import("../zig.zig").Guid.initString("57cc6fd2-c09a-4289-bb72-25f04142058e");
pub const IID_IFunctionInstanceCollectionQuery = &IID_IFunctionInstanceCollectionQuery_Value;
pub const IFunctionInstanceCollectionQuery = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddQueryConstraint: fn(
            self: *const IFunctionInstanceCollectionQuery,
            pszConstraintName: ?[*:0]const u16,
            pszConstraintValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyConstraint: fn(
            self: *const IFunctionInstanceCollectionQuery,
            Key: ?*const PROPERTYKEY,
            pv: ?*const PROPVARIANT,
            enumPropertyConstraint: PropertyConstraint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IFunctionInstanceCollectionQuery,
            ppIFunctionInstanceCollection: ?*?*IFunctionInstanceCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollectionQuery_AddQueryConstraint(self: *const T, pszConstraintName: ?[*:0]const u16, pszConstraintValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollectionQuery.VTable, self.vtable).AddQueryConstraint(@ptrCast(*const IFunctionInstanceCollectionQuery, self), pszConstraintName, pszConstraintValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollectionQuery_AddPropertyConstraint(self: *const T, Key: ?*const PROPERTYKEY, pv: ?*const PROPVARIANT, enumPropertyConstraint: PropertyConstraint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollectionQuery.VTable, self.vtable).AddPropertyConstraint(@ptrCast(*const IFunctionInstanceCollectionQuery, self), Key, pv, enumPropertyConstraint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionInstanceCollectionQuery_Execute(self: *const T, ppIFunctionInstanceCollection: ?*?*IFunctionInstanceCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionInstanceCollectionQuery.VTable, self.vtable).Execute(@ptrCast(*const IFunctionInstanceCollectionQuery, self), ppIFunctionInstanceCollection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionDiscoveryProvider_Value = @import("../zig.zig").Guid.initString("dcde394f-1478-4813-a402-f6fb10657222");
pub const IID_IFunctionDiscoveryProvider = &IID_IFunctionDiscoveryProvider_Value;
pub const IFunctionDiscoveryProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IFunctionDiscoveryProvider,
            pIFunctionDiscoveryProviderFactory: ?*IFunctionDiscoveryProviderFactory,
            pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification,
            lcidUserDefault: u32,
            pdwStgAccessCapabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IFunctionDiscoveryProvider,
            pIFunctionDiscoveryProviderQuery: ?*IFunctionDiscoveryProviderQuery,
            ppIFunctionInstanceCollection: ?*?*IFunctionInstanceCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndQuery: fn(
            self: *const IFunctionDiscoveryProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstancePropertyStoreValidateAccess: fn(
            self: *const IFunctionDiscoveryProvider,
            pIFunctionInstance: ?*IFunctionInstance,
            iProviderInstanceContext: isize,
            dwStgAccess: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstancePropertyStoreOpen: fn(
            self: *const IFunctionDiscoveryProvider,
            pIFunctionInstance: ?*IFunctionInstance,
            iProviderInstanceContext: isize,
            dwStgAccess: u32,
            ppIPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstancePropertyStoreFlush: fn(
            self: *const IFunctionDiscoveryProvider,
            pIFunctionInstance: ?*IFunctionInstance,
            iProviderInstanceContext: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstanceQueryService: fn(
            self: *const IFunctionDiscoveryProvider,
            pIFunctionInstance: ?*IFunctionInstance,
            iProviderInstanceContext: isize,
            guidService: ?*const Guid,
            riid: ?*const Guid,
            ppIUnknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstanceReleased: fn(
            self: *const IFunctionDiscoveryProvider,
            pIFunctionInstance: ?*IFunctionInstance,
            iProviderInstanceContext: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProvider_Initialize(self: *const T, pIFunctionDiscoveryProviderFactory: ?*IFunctionDiscoveryProviderFactory, pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification, lcidUserDefault: u32, pdwStgAccessCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProvider.VTable, self.vtable).Initialize(@ptrCast(*const IFunctionDiscoveryProvider, self), pIFunctionDiscoveryProviderFactory, pIFunctionDiscoveryNotification, lcidUserDefault, pdwStgAccessCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProvider_Query(self: *const T, pIFunctionDiscoveryProviderQuery: ?*IFunctionDiscoveryProviderQuery, ppIFunctionInstanceCollection: ?*?*IFunctionInstanceCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProvider.VTable, self.vtable).Query(@ptrCast(*const IFunctionDiscoveryProvider, self), pIFunctionDiscoveryProviderQuery, ppIFunctionInstanceCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProvider_EndQuery(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProvider.VTable, self.vtable).EndQuery(@ptrCast(*const IFunctionDiscoveryProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProvider_InstancePropertyStoreValidateAccess(self: *const T, pIFunctionInstance: ?*IFunctionInstance, iProviderInstanceContext: isize, dwStgAccess: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProvider.VTable, self.vtable).InstancePropertyStoreValidateAccess(@ptrCast(*const IFunctionDiscoveryProvider, self), pIFunctionInstance, iProviderInstanceContext, dwStgAccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProvider_InstancePropertyStoreOpen(self: *const T, pIFunctionInstance: ?*IFunctionInstance, iProviderInstanceContext: isize, dwStgAccess: u32, ppIPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProvider.VTable, self.vtable).InstancePropertyStoreOpen(@ptrCast(*const IFunctionDiscoveryProvider, self), pIFunctionInstance, iProviderInstanceContext, dwStgAccess, ppIPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProvider_InstancePropertyStoreFlush(self: *const T, pIFunctionInstance: ?*IFunctionInstance, iProviderInstanceContext: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProvider.VTable, self.vtable).InstancePropertyStoreFlush(@ptrCast(*const IFunctionDiscoveryProvider, self), pIFunctionInstance, iProviderInstanceContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProvider_InstanceQueryService(self: *const T, pIFunctionInstance: ?*IFunctionInstance, iProviderInstanceContext: isize, guidService: ?*const Guid, riid: ?*const Guid, ppIUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProvider.VTable, self.vtable).InstanceQueryService(@ptrCast(*const IFunctionDiscoveryProvider, self), pIFunctionInstance, iProviderInstanceContext, guidService, riid, ppIUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProvider_InstanceReleased(self: *const T, pIFunctionInstance: ?*IFunctionInstance, iProviderInstanceContext: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProvider.VTable, self.vtable).InstanceReleased(@ptrCast(*const IFunctionDiscoveryProvider, self), pIFunctionInstance, iProviderInstanceContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProviderProperties_Value = @import("../zig.zig").Guid.initString("cf986ea6-3b5f-4c5f-b88a-2f8b20ceef17");
pub const IID_IProviderProperties = &IID_IProviderProperties_Value;
pub const IProviderProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IProviderProperties,
            pIFunctionInstance: ?*IFunctionInstance,
            iProviderInstanceContext: isize,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAt: fn(
            self: *const IProviderProperties,
            pIFunctionInstance: ?*IFunctionInstance,
            iProviderInstanceContext: isize,
            dwIndex: u32,
            pKey: ?*PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IProviderProperties,
            pIFunctionInstance: ?*IFunctionInstance,
            iProviderInstanceContext: isize,
            Key: ?*const PROPERTYKEY,
            ppropVar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const IProviderProperties,
            pIFunctionInstance: ?*IFunctionInstance,
            iProviderInstanceContext: isize,
            Key: ?*const PROPERTYKEY,
            ppropVar: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderProperties_GetCount(self: *const T, pIFunctionInstance: ?*IFunctionInstance, iProviderInstanceContext: isize, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderProperties.VTable, self.vtable).GetCount(@ptrCast(*const IProviderProperties, self), pIFunctionInstance, iProviderInstanceContext, pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderProperties_GetAt(self: *const T, pIFunctionInstance: ?*IFunctionInstance, iProviderInstanceContext: isize, dwIndex: u32, pKey: ?*PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderProperties.VTable, self.vtable).GetAt(@ptrCast(*const IProviderProperties, self), pIFunctionInstance, iProviderInstanceContext, dwIndex, pKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderProperties_GetValue(self: *const T, pIFunctionInstance: ?*IFunctionInstance, iProviderInstanceContext: isize, Key: ?*const PROPERTYKEY, ppropVar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderProperties.VTable, self.vtable).GetValue(@ptrCast(*const IProviderProperties, self), pIFunctionInstance, iProviderInstanceContext, Key, ppropVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderProperties_SetValue(self: *const T, pIFunctionInstance: ?*IFunctionInstance, iProviderInstanceContext: isize, Key: ?*const PROPERTYKEY, ppropVar: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderProperties.VTable, self.vtable).SetValue(@ptrCast(*const IProviderProperties, self), pIFunctionInstance, iProviderInstanceContext, Key, ppropVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProviderPublishing_Value = @import("../zig.zig").Guid.initString("cd1b9a04-206c-4a05-a0c8-1635a21a2b7c");
pub const IID_IProviderPublishing = &IID_IProviderPublishing_Value;
pub const IProviderPublishing = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: fn(
            self: *const IProviderPublishing,
            enumVisibilityFlags: SystemVisibilityFlags,
            pszSubCategory: ?[*:0]const u16,
            pszProviderInstanceIdentity: ?[*:0]const u16,
            ppIFunctionInstance: ?*?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveInstance: fn(
            self: *const IProviderPublishing,
            enumVisibilityFlags: SystemVisibilityFlags,
            pszSubCategory: ?[*:0]const u16,
            pszProviderInstanceIdentity: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderPublishing_CreateInstance(self: *const T, enumVisibilityFlags: SystemVisibilityFlags, pszSubCategory: ?[*:0]const u16, pszProviderInstanceIdentity: ?[*:0]const u16, ppIFunctionInstance: ?*?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderPublishing.VTable, self.vtable).CreateInstance(@ptrCast(*const IProviderPublishing, self), enumVisibilityFlags, pszSubCategory, pszProviderInstanceIdentity, ppIFunctionInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderPublishing_RemoveInstance(self: *const T, enumVisibilityFlags: SystemVisibilityFlags, pszSubCategory: ?[*:0]const u16, pszProviderInstanceIdentity: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderPublishing.VTable, self.vtable).RemoveInstance(@ptrCast(*const IProviderPublishing, self), enumVisibilityFlags, pszSubCategory, pszProviderInstanceIdentity);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionDiscoveryProviderFactory_Value = @import("../zig.zig").Guid.initString("86443ff0-1ad5-4e68-a45a-40c2c329de3b");
pub const IID_IFunctionDiscoveryProviderFactory = &IID_IFunctionDiscoveryProviderFactory_Value;
pub const IFunctionDiscoveryProviderFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePropertyStore: fn(
            self: *const IFunctionDiscoveryProviderFactory,
            ppIPropertyStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstance: fn(
            self: *const IFunctionDiscoveryProviderFactory,
            pszSubCategory: ?[*:0]const u16,
            pszProviderInstanceIdentity: ?[*:0]const u16,
            iProviderInstanceContext: isize,
            pIPropertyStore: ?*IPropertyStore,
            pIFunctionDiscoveryProvider: ?*IFunctionDiscoveryProvider,
            ppIFunctionInstance: ?*?*IFunctionInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFunctionInstanceCollection: fn(
            self: *const IFunctionDiscoveryProviderFactory,
            ppIFunctionInstanceCollection: ?*?*IFunctionInstanceCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProviderFactory_CreatePropertyStore(self: *const T, ppIPropertyStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProviderFactory.VTable, self.vtable).CreatePropertyStore(@ptrCast(*const IFunctionDiscoveryProviderFactory, self), ppIPropertyStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProviderFactory_CreateInstance(self: *const T, pszSubCategory: ?[*:0]const u16, pszProviderInstanceIdentity: ?[*:0]const u16, iProviderInstanceContext: isize, pIPropertyStore: ?*IPropertyStore, pIFunctionDiscoveryProvider: ?*IFunctionDiscoveryProvider, ppIFunctionInstance: ?*?*IFunctionInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProviderFactory.VTable, self.vtable).CreateInstance(@ptrCast(*const IFunctionDiscoveryProviderFactory, self), pszSubCategory, pszProviderInstanceIdentity, iProviderInstanceContext, pIPropertyStore, pIFunctionDiscoveryProvider, ppIFunctionInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProviderFactory_CreateFunctionInstanceCollection(self: *const T, ppIFunctionInstanceCollection: ?*?*IFunctionInstanceCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProviderFactory.VTable, self.vtable).CreateFunctionInstanceCollection(@ptrCast(*const IFunctionDiscoveryProviderFactory, self), ppIFunctionInstanceCollection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionDiscoveryProviderQuery_Value = @import("../zig.zig").Guid.initString("6876ea98-baec-46db-bc20-75a76e267a3a");
pub const IID_IFunctionDiscoveryProviderQuery = &IID_IFunctionDiscoveryProviderQuery_Value;
pub const IFunctionDiscoveryProviderQuery = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsInstanceQuery: fn(
            self: *const IFunctionDiscoveryProviderQuery,
            pisInstanceQuery: ?*BOOL,
            ppszConstraintValue: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubcategoryQuery: fn(
            self: *const IFunctionDiscoveryProviderQuery,
            pisSubcategoryQuery: ?*BOOL,
            ppszConstraintValue: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQueryConstraints: fn(
            self: *const IFunctionDiscoveryProviderQuery,
            ppIProviderQueryConstraints: ?*?*IProviderQueryConstraintCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyConstraints: fn(
            self: *const IFunctionDiscoveryProviderQuery,
            ppIProviderPropertyConstraints: ?*?*IProviderPropertyConstraintCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProviderQuery_IsInstanceQuery(self: *const T, pisInstanceQuery: ?*BOOL, ppszConstraintValue: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProviderQuery.VTable, self.vtable).IsInstanceQuery(@ptrCast(*const IFunctionDiscoveryProviderQuery, self), pisInstanceQuery, ppszConstraintValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProviderQuery_IsSubcategoryQuery(self: *const T, pisSubcategoryQuery: ?*BOOL, ppszConstraintValue: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProviderQuery.VTable, self.vtable).IsSubcategoryQuery(@ptrCast(*const IFunctionDiscoveryProviderQuery, self), pisSubcategoryQuery, ppszConstraintValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProviderQuery_GetQueryConstraints(self: *const T, ppIProviderQueryConstraints: ?*?*IProviderQueryConstraintCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProviderQuery.VTable, self.vtable).GetQueryConstraints(@ptrCast(*const IFunctionDiscoveryProviderQuery, self), ppIProviderQueryConstraints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryProviderQuery_GetPropertyConstraints(self: *const T, ppIProviderPropertyConstraints: ?*?*IProviderPropertyConstraintCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryProviderQuery.VTable, self.vtable).GetPropertyConstraints(@ptrCast(*const IFunctionDiscoveryProviderQuery, self), ppIProviderPropertyConstraints);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProviderQueryConstraintCollection_Value = @import("../zig.zig").Guid.initString("9c243e11-3261-4bcd-b922-84a873d460ae");
pub const IID_IProviderQueryConstraintCollection = &IID_IProviderQueryConstraintCollection_Value;
pub const IProviderQueryConstraintCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IProviderQueryConstraintCollection,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: fn(
            self: *const IProviderQueryConstraintCollection,
            pszConstraintName: ?[*:0]const u16,
            ppszConstraintValue: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IProviderQueryConstraintCollection,
            dwIndex: u32,
            ppszConstraintName: ?*?*u16,
            ppszConstraintValue: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IProviderQueryConstraintCollection,
            ppszConstraintName: ?*?*u16,
            ppszConstraintValue: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IProviderQueryConstraintCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IProviderQueryConstraintCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderQueryConstraintCollection_GetCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderQueryConstraintCollection.VTable, self.vtable).GetCount(@ptrCast(*const IProviderQueryConstraintCollection, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderQueryConstraintCollection_Get(self: *const T, pszConstraintName: ?[*:0]const u16, ppszConstraintValue: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderQueryConstraintCollection.VTable, self.vtable).Get(@ptrCast(*const IProviderQueryConstraintCollection, self), pszConstraintName, ppszConstraintValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderQueryConstraintCollection_Item(self: *const T, dwIndex: u32, ppszConstraintName: ?*?*u16, ppszConstraintValue: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderQueryConstraintCollection.VTable, self.vtable).Item(@ptrCast(*const IProviderQueryConstraintCollection, self), dwIndex, ppszConstraintName, ppszConstraintValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderQueryConstraintCollection_Next(self: *const T, ppszConstraintName: ?*?*u16, ppszConstraintValue: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderQueryConstraintCollection.VTable, self.vtable).Next(@ptrCast(*const IProviderQueryConstraintCollection, self), ppszConstraintName, ppszConstraintValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderQueryConstraintCollection_Skip(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderQueryConstraintCollection.VTable, self.vtable).Skip(@ptrCast(*const IProviderQueryConstraintCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderQueryConstraintCollection_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderQueryConstraintCollection.VTable, self.vtable).Reset(@ptrCast(*const IProviderQueryConstraintCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProviderPropertyConstraintCollection_Value = @import("../zig.zig").Guid.initString("f4fae42f-5778-4a13-8540-b5fd8c1398dd");
pub const IID_IProviderPropertyConstraintCollection = &IID_IProviderPropertyConstraintCollection_Value;
pub const IProviderPropertyConstraintCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IProviderPropertyConstraintCollection,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: fn(
            self: *const IProviderPropertyConstraintCollection,
            Key: ?*const PROPERTYKEY,
            pPropVar: ?*PROPVARIANT,
            pdwPropertyConstraint: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IProviderPropertyConstraintCollection,
            dwIndex: u32,
            pKey: ?*PROPERTYKEY,
            pPropVar: ?*PROPVARIANT,
            pdwPropertyConstraint: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IProviderPropertyConstraintCollection,
            pKey: ?*PROPERTYKEY,
            pPropVar: ?*PROPVARIANT,
            pdwPropertyConstraint: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IProviderPropertyConstraintCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IProviderPropertyConstraintCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderPropertyConstraintCollection_GetCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderPropertyConstraintCollection.VTable, self.vtable).GetCount(@ptrCast(*const IProviderPropertyConstraintCollection, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderPropertyConstraintCollection_Get(self: *const T, Key: ?*const PROPERTYKEY, pPropVar: ?*PROPVARIANT, pdwPropertyConstraint: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderPropertyConstraintCollection.VTable, self.vtable).Get(@ptrCast(*const IProviderPropertyConstraintCollection, self), Key, pPropVar, pdwPropertyConstraint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderPropertyConstraintCollection_Item(self: *const T, dwIndex: u32, pKey: ?*PROPERTYKEY, pPropVar: ?*PROPVARIANT, pdwPropertyConstraint: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderPropertyConstraintCollection.VTable, self.vtable).Item(@ptrCast(*const IProviderPropertyConstraintCollection, self), dwIndex, pKey, pPropVar, pdwPropertyConstraint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderPropertyConstraintCollection_Next(self: *const T, pKey: ?*PROPERTYKEY, pPropVar: ?*PROPVARIANT, pdwPropertyConstraint: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderPropertyConstraintCollection.VTable, self.vtable).Next(@ptrCast(*const IProviderPropertyConstraintCollection, self), pKey, pPropVar, pdwPropertyConstraint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderPropertyConstraintCollection_Skip(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderPropertyConstraintCollection.VTable, self.vtable).Skip(@ptrCast(*const IProviderPropertyConstraintCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderPropertyConstraintCollection_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderPropertyConstraintCollection.VTable, self.vtable).Reset(@ptrCast(*const IProviderPropertyConstraintCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFunctionDiscoveryServiceProvider_Value = @import("../zig.zig").Guid.initString("4c81ed02-1b04-43f2-a451-69966cbcd1c2");
pub const IID_IFunctionDiscoveryServiceProvider = &IID_IFunctionDiscoveryServiceProvider_Value;
pub const IFunctionDiscoveryServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IFunctionDiscoveryServiceProvider,
            pIFunctionInstance: ?*IFunctionInstance,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFunctionDiscoveryServiceProvider_Initialize(self: *const T, pIFunctionInstance: ?*IFunctionInstance, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFunctionDiscoveryServiceProvider.VTable, self.vtable).Initialize(@ptrCast(*const IFunctionDiscoveryServiceProvider, self), pIFunctionInstance, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_PNPXAssociation_Value = @import("../zig.zig").Guid.initString("cee8ccc9-4f6b-4469-a235-5a22869eef03");
pub const CLSID_PNPXAssociation = &CLSID_PNPXAssociation_Value;

const CLSID_PNPXPairingHandler_Value = @import("../zig.zig").Guid.initString("b8a27942-ade7-4085-aa6e-4fadc7ada1ef");
pub const CLSID_PNPXPairingHandler = &CLSID_PNPXPairingHandler_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPNPXAssociation_Value = @import("../zig.zig").Guid.initString("0bd7e521-4da6-42d5-81ba-1981b6b94075");
pub const IID_IPNPXAssociation = &IID_IPNPXAssociation_Value;
pub const IPNPXAssociation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Associate: fn(
            self: *const IPNPXAssociation,
            pszSubcategory: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unassociate: fn(
            self: *const IPNPXAssociation,
            pszSubcategory: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IPNPXAssociation,
            pszSubcategory: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPNPXAssociation_Associate(self: *const T, pszSubcategory: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPNPXAssociation.VTable, self.vtable).Associate(@ptrCast(*const IPNPXAssociation, self), pszSubcategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPNPXAssociation_Unassociate(self: *const T, pszSubcategory: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPNPXAssociation.VTable, self.vtable).Unassociate(@ptrCast(*const IPNPXAssociation, self), pszSubcategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPNPXAssociation_Delete(self: *const T, pszSubcategory: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPNPXAssociation.VTable, self.vtable).Delete(@ptrCast(*const IPNPXAssociation, self), pszSubcategory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPNPXDeviceAssociation_Value = @import("../zig.zig").Guid.initString("eed366d0-35b8-4fc5-8d20-7e5bd31f6ded");
pub const IID_IPNPXDeviceAssociation = &IID_IPNPXDeviceAssociation_Value;
pub const IPNPXDeviceAssociation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Associate: fn(
            self: *const IPNPXDeviceAssociation,
            pszSubCategory: ?[*:0]const u16,
            pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unassociate: fn(
            self: *const IPNPXDeviceAssociation,
            pszSubCategory: ?[*:0]const u16,
            pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IPNPXDeviceAssociation,
            pszSubcategory: ?[*:0]const u16,
            pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPNPXDeviceAssociation_Associate(self: *const T, pszSubCategory: ?[*:0]const u16, pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPNPXDeviceAssociation.VTable, self.vtable).Associate(@ptrCast(*const IPNPXDeviceAssociation, self), pszSubCategory, pIFunctionDiscoveryNotification);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPNPXDeviceAssociation_Unassociate(self: *const T, pszSubCategory: ?[*:0]const u16, pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPNPXDeviceAssociation.VTable, self.vtable).Unassociate(@ptrCast(*const IPNPXDeviceAssociation, self), pszSubCategory, pIFunctionDiscoveryNotification);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPNPXDeviceAssociation_Delete(self: *const T, pszSubcategory: ?[*:0]const u16, pIFunctionDiscoveryNotification: ?*IFunctionDiscoveryNotification) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPNPXDeviceAssociation.VTable, self.vtable).Delete(@ptrCast(*const IPNPXDeviceAssociation, self), pszSubcategory, pIFunctionDiscoveryNotification);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_FunctionDiscovery_Value = @import("../zig.zig").Guid.initString("c72be2ec-8e90-452c-b29a-ab8ff1c071fc");
pub const CLSID_FunctionDiscovery = &CLSID_FunctionDiscovery_Value;

const CLSID_PropertyStore_Value = @import("../zig.zig").Guid.initString("e4796550-df61-448b-9193-13fc1341b163");
pub const CLSID_PropertyStore = &CLSID_PropertyStore_Value;

const CLSID_FunctionInstanceCollection_Value = @import("../zig.zig").Guid.initString("ba818ce5-b55f-443f-ad39-2fe89be6191f");
pub const CLSID_FunctionInstanceCollection = &CLSID_FunctionInstanceCollection_Value;

const CLSID_PropertyStoreCollection_Value = @import("../zig.zig").Guid.initString("edd36029-d753-4862-aa5b-5bccad2a4d29");
pub const CLSID_PropertyStoreCollection = &CLSID_PropertyStoreCollection_Value;


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const HRESULT = @import("../foundation.zig").HRESULT;
const IPropertyStore = @import("../ui/shell/properties_system.zig").IPropertyStore;
const IServiceProvider = @import("../system/com.zig").IServiceProvider;
const IUnknown = @import("../system/com.zig").IUnknown;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
