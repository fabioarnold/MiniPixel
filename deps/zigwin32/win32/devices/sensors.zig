//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (121)
//--------------------------------------------------------------------------------
pub const GUID_DEVINTERFACE_SENSOR = Guid.initString("ba1bb692-9b7a-4833-9a1e-525ed134e7e2");
pub const SENSOR_EVENT_STATE_CHANGED = Guid.initString("bfd96016-6bd7-4560-ad34-f2f6607e8f81");
pub const SENSOR_EVENT_DATA_UPDATED = Guid.initString("2ed0f2a4-0087-41d3-87db-6773370b3c88");
pub const SENSOR_EVENT_PROPERTY_CHANGED = Guid.initString("2358f099-84c9-4d3d-90df-c2421e2b2045");
pub const SENSOR_EVENT_ACCELEROMETER_SHAKE = Guid.initString("825f5a94-0f48-4396-9ca0-6ecb5c99d915");
pub const SENSOR_EVENT_PARAMETER_COMMON_GUID = Guid.initString("64346e30-8728-4b34-bdf6-4f52442c5c28");
pub const SENSOR_ERROR_PARAMETER_COMMON_GUID = Guid.initString("77112bcd-fce1-4f43-b8b8-a88256adb4b3");
pub const SENSOR_PROPERTY_COMMON_GUID = Guid.initString("7f8383ec-d3ec-495c-a8cf-b8bbe85c2920");
pub const SENSOR_CATEGORY_ALL = Guid.initString("c317c286-c468-4288-9975-d4c4587c442c");
pub const SENSOR_CATEGORY_LOCATION = Guid.initString("bfa794e4-f964-4fdb-90f6-51056bfe4b44");
pub const SENSOR_CATEGORY_ENVIRONMENTAL = Guid.initString("323439aa-7f66-492b-ba0c-73e9aa0a65d5");
pub const SENSOR_CATEGORY_MOTION = Guid.initString("cd09daf1-3b2e-4c3d-b598-b5e5ff93fd46");
pub const SENSOR_CATEGORY_ORIENTATION = Guid.initString("9e6c04b6-96fe-4954-b726-68682a473f69");
pub const SENSOR_CATEGORY_MECHANICAL = Guid.initString("8d131d68-8ef7-4656-80b5-cccbd93791c5");
pub const SENSOR_CATEGORY_ELECTRICAL = Guid.initString("fb73fcd8-fc4a-483c-ac58-27b691c6beff");
pub const SENSOR_CATEGORY_BIOMETRIC = Guid.initString("ca19690f-a2c7-477d-a99e-99ec6e2b5648");
pub const SENSOR_CATEGORY_LIGHT = Guid.initString("17a665c0-9063-4216-b202-5c7a255e18ce");
pub const SENSOR_CATEGORY_SCANNER = Guid.initString("b000e77e-f5b5-420f-815d-0270a726f270");
pub const SENSOR_CATEGORY_OTHER = Guid.initString("2c90e7a9-f4c9-4fa2-af37-56d471fe5a3d");
pub const SENSOR_CATEGORY_UNSUPPORTED = Guid.initString("2beae7fa-19b0-48c5-a1f6-b5480dc206b0");
pub const SENSOR_TYPE_LOCATION_GPS = Guid.initString("ed4ca589-327a-4ff9-a560-91da4b48275e");
pub const SENSOR_TYPE_LOCATION_STATIC = Guid.initString("095f8184-0fa9-4445-8e6e-b70f320b6b4c");
pub const SENSOR_TYPE_LOCATION_LOOKUP = Guid.initString("3b2eae4a-72ce-436d-96d2-3c5b8570e987");
pub const SENSOR_TYPE_LOCATION_TRIANGULATION = Guid.initString("691c341a-5406-4fe1-942f-2246cbeb39e0");
pub const SENSOR_TYPE_LOCATION_OTHER = Guid.initString("9b2d0566-0368-4f71-b88d-533f132031de");
pub const SENSOR_TYPE_LOCATION_BROADCAST = Guid.initString("d26988cf-5162-4039-bb17-4c58b698e44a");
pub const SENSOR_TYPE_LOCATION_DEAD_RECKONING = Guid.initString("1a37d538-f28b-42da-9fce-a9d0a2a6d829");
pub const SENSOR_TYPE_ENVIRONMENTAL_TEMPERATURE = Guid.initString("04fd0ec4-d5da-45fa-95a9-5db38ee19306");
pub const SENSOR_TYPE_ENVIRONMENTAL_ATMOSPHERIC_PRESSURE = Guid.initString("0e903829-ff8a-4a93-97df-3dcbde402288");
pub const SENSOR_TYPE_ENVIRONMENTAL_HUMIDITY = Guid.initString("5c72bf67-bd7e-4257-990b-98a3ba3b400a");
pub const SENSOR_TYPE_ENVIRONMENTAL_WIND_SPEED = Guid.initString("dd50607b-a45f-42cd-8efd-ec61761c4226");
pub const SENSOR_TYPE_ENVIRONMENTAL_WIND_DIRECTION = Guid.initString("9ef57a35-9306-434d-af09-37fa5a9c00bd");
pub const SENSOR_TYPE_ACCELEROMETER_1D = Guid.initString("c04d2387-7340-4cc2-991e-3b18cb8ef2f4");
pub const SENSOR_TYPE_ACCELEROMETER_2D = Guid.initString("b2c517a8-f6b5-4ba6-a423-5df560b4cc07");
pub const SENSOR_TYPE_ACCELEROMETER_3D = Guid.initString("c2fb0f5f-e2d2-4c78-bcd0-352a9582819d");
pub const SENSOR_TYPE_MOTION_DETECTOR = Guid.initString("5c7c1a12-30a5-43b9-a4b2-cf09ec5b7be8");
pub const SENSOR_TYPE_GYROMETER_1D = Guid.initString("fa088734-f552-4584-8324-edfaf649652c");
pub const SENSOR_TYPE_GYROMETER_2D = Guid.initString("31ef4f83-919b-48bf-8de0-5d7a9d240556");
pub const SENSOR_TYPE_GYROMETER_3D = Guid.initString("09485f5a-759e-42c2-bd4b-a349b75c8643");
pub const SENSOR_TYPE_SPEEDOMETER = Guid.initString("6bd73c1f-0bb4-4310-81b2-dfc18a52bf94");
pub const SENSOR_TYPE_COMPASS_1D = Guid.initString("a415f6c5-cb50-49d0-8e62-a8270bd7a26c");
pub const SENSOR_TYPE_COMPASS_2D = Guid.initString("15655cc0-997a-4d30-84db-57caba3648bb");
pub const SENSOR_TYPE_COMPASS_3D = Guid.initString("76b5ce0d-17dd-414d-93a1-e127f40bdf6e");
pub const SENSOR_TYPE_INCLINOMETER_1D = Guid.initString("b96f98c5-7a75-4ba7-94e9-ac868c966dd8");
pub const SENSOR_TYPE_INCLINOMETER_2D = Guid.initString("ab140f6d-83eb-4264-b70b-b16a5b256a01");
pub const SENSOR_TYPE_INCLINOMETER_3D = Guid.initString("b84919fb-ea85-4976-8444-6f6f5c6d31db");
pub const SENSOR_TYPE_DISTANCE_1D = Guid.initString("5f14ab2f-1407-4306-a93f-b1dbabe4f9c0");
pub const SENSOR_TYPE_DISTANCE_2D = Guid.initString("5cf9a46c-a9a2-4e55-b6a1-a04aafa95a92");
pub const SENSOR_TYPE_DISTANCE_3D = Guid.initString("a20cae31-0e25-4772-9fe5-96608a1354b2");
pub const SENSOR_TYPE_AGGREGATED_QUADRANT_ORIENTATION = Guid.initString("9f81f1af-c4ab-4307-9904-c828bfb90829");
pub const SENSOR_TYPE_AGGREGATED_DEVICE_ORIENTATION = Guid.initString("cdb5d8f7-3cfd-41c8-8542-cce622cf5d6e");
pub const SENSOR_TYPE_AGGREGATED_SIMPLE_DEVICE_ORIENTATION = Guid.initString("86a19291-0482-402c-bf4c-addac52b1c39");
pub const SENSOR_TYPE_VOLTAGE = Guid.initString("c5484637-4fb7-4953-98b8-a56d8aa1fb1e");
pub const SENSOR_TYPE_CURRENT = Guid.initString("5adc9fce-15a0-4bbe-a1ad-2d38a9ae831c");
pub const SENSOR_TYPE_CAPACITANCE = Guid.initString("ca2ffb1c-2317-49c0-a0b4-b63ce63461a0");
pub const SENSOR_TYPE_RESISTANCE = Guid.initString("9993d2c8-c157-4a52-a7b5-195c76037231");
pub const SENSOR_TYPE_INDUCTANCE = Guid.initString("dc1d933f-c435-4c7d-a2fe-607192a524d3");
pub const SENSOR_TYPE_ELECTRICAL_POWER = Guid.initString("212f10f5-14ab-4376-9a43-a7794098c2fe");
pub const SENSOR_TYPE_POTENTIOMETER = Guid.initString("2b3681a9-cadc-45aa-a6ff-54957c8bb440");
pub const SENSOR_TYPE_FREQUENCY = Guid.initString("8cd2cbb6-73e6-4640-a709-72ae8fb60d7f");
pub const SENSOR_TYPE_BOOLEAN_SWITCH = Guid.initString("9c7e371f-1041-460b-8d5c-71e4752e350c");
pub const SENSOR_TYPE_MULTIVALUE_SWITCH = Guid.initString("b3ee4d76-37a4-4402-b25e-99c60a775fa1");
pub const SENSOR_TYPE_FORCE = Guid.initString("c2ab2b02-1a1c-4778-a81b-954a1788cc75");
pub const SENSOR_TYPE_SCALE = Guid.initString("c06dd92c-7feb-438e-9bf6-82207fff5bb8");
pub const SENSOR_TYPE_PRESSURE = Guid.initString("26d31f34-6352-41cf-b793-ea0713d53d77");
pub const SENSOR_TYPE_STRAIN = Guid.initString("c6d1ec0e-6803-4361-ad3d-85bcc58c6d29");
pub const SENSOR_TYPE_BOOLEAN_SWITCH_ARRAY = Guid.initString("545c8ba5-b143-4545-868f-ca7fd986b4f6");
pub const SENSOR_TYPE_HUMAN_PRESENCE = Guid.initString("c138c12b-ad52-451c-9375-87f518ff10c6");
pub const SENSOR_TYPE_HUMAN_PROXIMITY = Guid.initString("5220dae9-3179-4430-9f90-06266d2a34de");
pub const SENSOR_TYPE_TOUCH = Guid.initString("17db3018-06c4-4f7d-81af-9274b7599c27");
pub const SENSOR_TYPE_AMBIENT_LIGHT = Guid.initString("97f115c8-599a-4153-8894-d2d12899918a");
pub const SENSOR_TYPE_RFID_SCANNER = Guid.initString("44328ef5-02dd-4e8d-ad5d-9249832b2eca");
pub const SENSOR_TYPE_BARCODE_SCANNER = Guid.initString("990b3d8f-85bb-45ff-914d-998c04f372df");
pub const SENSOR_TYPE_CUSTOM = Guid.initString("e83af229-8640-4d18-a213-e22675ebb2c3");
pub const SENSOR_TYPE_UNKNOWN = Guid.initString("10ba83e3-ef4f-41ed-9885-a87d6435a8e1");
pub const SENSOR_DATA_TYPE_COMMON_GUID = Guid.initString("db5e0cf2-cf1f-4c18-b46c-d86011d62150");
pub const SENSOR_DATA_TYPE_LOCATION_GUID = Guid.initString("055c74d8-ca6f-47d6-95c6-1ed3637a0ff4");
pub const SENSOR_DATA_TYPE_ENVIRONMENTAL_GUID = Guid.initString("8b0aa2f1-2d57-42ee-8cc0-4d27622b46c4");
pub const SENSOR_DATA_TYPE_MOTION_GUID = Guid.initString("3f8a69a2-07c5-4e48-a965-cd797aab56d5");
pub const SENSOR_DATA_TYPE_ORIENTATION_GUID = Guid.initString("1637d8a2-4248-4275-865d-558de84aedfd");
pub const SENSOR_DATA_TYPE_GUID_MECHANICAL_GUID = Guid.initString("38564a7c-f2f2-49bb-9b2b-ba60f66a58df");
pub const SENSOR_DATA_TYPE_BIOMETRIC_GUID = Guid.initString("2299288a-6d9e-4b0b-b7ec-3528f89e40af");
pub const SENSOR_DATA_TYPE_LIGHT_GUID = Guid.initString("e4c77ce2-dcb7-46e9-8439-4fec548833a6");
pub const SENSOR_DATA_TYPE_SCANNER_GUID = Guid.initString("d7a59a3c-3421-44ab-8d3a-9de8ab6c4cae");
pub const SENSOR_DATA_TYPE_ELECTRICAL_GUID = Guid.initString("bbb246d1-e242-4780-a2d3-cded84f35842");
pub const SENSOR_DATA_TYPE_CUSTOM_GUID = Guid.initString("b14c764f-07cf-41e8-9d82-ebe3d0776a6f");
pub const SENSOR_PROPERTY_TEST_GUID = Guid.initString("e1e962f4-6e65-45f7-9c36-d487b7b1bd34");
pub const GNSS_CLEAR_ALL_ASSISTANCE_DATA = @as(u32, 1);
pub const GUID_SensorCategory_All = Guid.initString("c317c286-c468-4288-9975-d4c4587c442c");
pub const GUID_SensorCategory_Biometric = Guid.initString("ca19690f-a2c7-477d-a99e-99ec6e2b5648");
pub const GUID_SensorCategory_Electrical = Guid.initString("fb73fcd8-fc4a-483c-ac58-27b691c6beff");
pub const GUID_SensorCategory_Environmental = Guid.initString("323439aa-7f66-492b-ba0c-73e9aa0a65d5");
pub const GUID_SensorCategory_Light = Guid.initString("17a665c0-9063-4216-b202-5c7a255e18ce");
pub const GUID_SensorCategory_Location = Guid.initString("bfa794e4-f964-4fdb-90f6-51056bfe4b44");
pub const GUID_SensorCategory_Mechanical = Guid.initString("8d131d68-8ef7-4656-80b5-cccbd93791c5");
pub const GUID_SensorCategory_Motion = Guid.initString("cd09daf1-3b2e-4c3d-b598-b5e5ff93fd46");
pub const GUID_SensorCategory_Orientation = Guid.initString("9e6c04b6-96fe-4954-b726-68682a473f69");
pub const GUID_SensorCategory_Other = Guid.initString("2c90e7a9-f4c9-4fa2-af37-56d471fe5a3d");
pub const GUID_SensorCategory_PersonalActivity = Guid.initString("f1609081-1e12-412b-a14d-cbb0e95bd2e5");
pub const GUID_SensorCategory_Scanner = Guid.initString("b000e77e-f5b5-420f-815d-0270a726f270");
pub const GUID_SensorCategory_Unsupported = Guid.initString("2beae7fa-19b0-48c5-a1f6-b5480dc206b0");
pub const GUID_SensorType_Accelerometer3D = Guid.initString("c2fb0f5f-e2d2-4c78-bcd0-352a9582819d");
pub const GUID_SensorType_ActivityDetection = Guid.initString("9d9e0118-1807-4f2e-96e4-2ce57142e196");
pub const GUID_SensorType_AmbientLight = Guid.initString("97f115c8-599a-4153-8894-d2d12899918a");
pub const GUID_SensorType_Barometer = Guid.initString("0e903829-ff8a-4a93-97df-3dcbde402288");
pub const GUID_SensorType_Custom = Guid.initString("e83af229-8640-4d18-a213-e22675ebb2c3");
pub const GUID_SensorType_FloorElevation = Guid.initString("ade4987f-7ac4-4dfa-9722-0a027181c747");
pub const GUID_SensorType_GeomagneticOrientation = Guid.initString("e77195f8-2d1f-4823-971b-1c4467556c9d");
pub const GUID_SensorType_GravityVector = Guid.initString("03b52c73-bb76-463f-9524-38de76eb700b");
pub const GUID_SensorType_Gyrometer3D = Guid.initString("09485f5a-759e-42c2-bd4b-a349b75c8643");
pub const GUID_SensorType_Humidity = Guid.initString("5c72bf67-bd7e-4257-990b-98a3ba3b400a");
pub const GUID_SensorType_LinearAccelerometer = Guid.initString("038b0283-97b4-41c8-bc24-5ff1aa48fec7");
pub const GUID_SensorType_Magnetometer3D = Guid.initString("55e5effb-15c7-40df-8698-a84b7c863c53");
pub const GUID_SensorType_Orientation = Guid.initString("cdb5d8f7-3cfd-41c8-8542-cce622cf5d6e");
pub const GUID_SensorType_Pedometer = Guid.initString("b19f89af-e3eb-444b-8dea-202575a71599");
pub const GUID_SensorType_Proximity = Guid.initString("5220dae9-3179-4430-9f90-06266d2a34de");
pub const GUID_SensorType_RelativeOrientation = Guid.initString("40993b51-4706-44dc-98d5-c920c037ffab");
pub const GUID_SensorType_SimpleDeviceOrientation = Guid.initString("86a19291-0482-402c-bf4c-addac52b1c39");
pub const GUID_SensorType_Temperature = Guid.initString("04fd0ec4-d5da-45fa-95a9-5db38ee19306");
pub const GUID_SensorType_HingeAngle = Guid.initString("82358065-f4c4-4da1-b272-13c23332a207");
pub const SENSOR_PROPERTY_LIST_HEADER_SIZE = @as(u32, 8);

//--------------------------------------------------------------------------------
// Section: Types (36)
//--------------------------------------------------------------------------------
const CLSID_SensorManager_Value = @import("../zig.zig").Guid.initString("77a1c827-fcd2-4689-8915-9d613cc5fa3e");
pub const CLSID_SensorManager = &CLSID_SensorManager_Value;

const CLSID_SensorCollection_Value = @import("../zig.zig").Guid.initString("79c43adb-a429-469f-aa39-2f2b74b75937");
pub const CLSID_SensorCollection = &CLSID_SensorCollection_Value;

const CLSID_Sensor_Value = @import("../zig.zig").Guid.initString("e97ced00-523a-4133-bf6f-d3a2dae7f6ba");
pub const CLSID_Sensor = &CLSID_Sensor_Value;

const CLSID_SensorDataReport_Value = @import("../zig.zig").Guid.initString("4ea9d6ef-694b-4218-8816-ccda8da74bba");
pub const CLSID_SensorDataReport = &CLSID_SensorDataReport_Value;

pub const SensorState = enum(i32) {
    MIN = 0,
    // READY = 0, this enum value conflicts with MIN
    NOT_AVAILABLE = 1,
    NO_DATA = 2,
    INITIALIZING = 3,
    ACCESS_DENIED = 4,
    ERROR = 5,
    // MAX = 5, this enum value conflicts with ERROR
};
pub const SENSOR_STATE_MIN = SensorState.MIN;
pub const SENSOR_STATE_READY = SensorState.MIN;
pub const SENSOR_STATE_NOT_AVAILABLE = SensorState.NOT_AVAILABLE;
pub const SENSOR_STATE_NO_DATA = SensorState.NO_DATA;
pub const SENSOR_STATE_INITIALIZING = SensorState.INITIALIZING;
pub const SENSOR_STATE_ACCESS_DENIED = SensorState.ACCESS_DENIED;
pub const SENSOR_STATE_ERROR = SensorState.ERROR;
pub const SENSOR_STATE_MAX = SensorState.ERROR;

pub const SensorConnectionType = enum(i32) {
    INTEGRATED = 0,
    ATTACHED = 1,
    EXTERNAL = 2,
};
pub const SENSOR_CONNECTION_TYPE_PC_INTEGRATED = SensorConnectionType.INTEGRATED;
pub const SENSOR_CONNECTION_TYPE_PC_ATTACHED = SensorConnectionType.ATTACHED;
pub const SENSOR_CONNECTION_TYPE_PC_EXTERNAL = SensorConnectionType.EXTERNAL;

pub const LOCATION_DESIRED_ACCURACY = enum(i32) {
    DEFAULT = 0,
    HIGH = 1,
};
pub const LOCATION_DESIRED_ACCURACY_DEFAULT = LOCATION_DESIRED_ACCURACY.DEFAULT;
pub const LOCATION_DESIRED_ACCURACY_HIGH = LOCATION_DESIRED_ACCURACY.HIGH;

pub const LOCATION_POSITION_SOURCE = enum(i32) {
    CELLULAR = 0,
    SATELLITE = 1,
    WIFI = 2,
    IPADDRESS = 3,
    UNKNOWN = 4,
};
pub const LOCATION_POSITION_SOURCE_CELLULAR = LOCATION_POSITION_SOURCE.CELLULAR;
pub const LOCATION_POSITION_SOURCE_SATELLITE = LOCATION_POSITION_SOURCE.SATELLITE;
pub const LOCATION_POSITION_SOURCE_WIFI = LOCATION_POSITION_SOURCE.WIFI;
pub const LOCATION_POSITION_SOURCE_IPADDRESS = LOCATION_POSITION_SOURCE.IPADDRESS;
pub const LOCATION_POSITION_SOURCE_UNKNOWN = LOCATION_POSITION_SOURCE.UNKNOWN;

pub const SimpleDeviceOrientation = enum(i32) {
    NOT_ROTATED = 0,
    ROTATED_90 = 1,
    ROTATED_180 = 2,
    ROTATED_270 = 3,
    ROTATED_FACE_UP = 4,
    ROTATED_FACE_DOWN = 5,
};
pub const SIMPLE_DEVICE_ORIENTATION_NOT_ROTATED = SimpleDeviceOrientation.NOT_ROTATED;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_90 = SimpleDeviceOrientation.ROTATED_90;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_180 = SimpleDeviceOrientation.ROTATED_180;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_270 = SimpleDeviceOrientation.ROTATED_270;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_UP = SimpleDeviceOrientation.ROTATED_FACE_UP;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_DOWN = SimpleDeviceOrientation.ROTATED_FACE_DOWN;

pub const MagnetometerAccuracy = enum(i32) {
    UNKNOWN = 0,
    UNRELIABLE = 1,
    APPROXIMATE = 2,
    HIGH = 3,
};
pub const MAGNETOMETER_ACCURACY_UNKNOWN = MagnetometerAccuracy.UNKNOWN;
pub const MAGNETOMETER_ACCURACY_UNRELIABLE = MagnetometerAccuracy.UNRELIABLE;
pub const MAGNETOMETER_ACCURACY_APPROXIMATE = MagnetometerAccuracy.APPROXIMATE;
pub const MAGNETOMETER_ACCURACY_HIGH = MagnetometerAccuracy.HIGH;

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorManager_Value = @import("../zig.zig").Guid.initString("bd77db67-45a8-42dc-8d00-6dcf15f8377a");
pub const IID_ISensorManager = &IID_ISensorManager_Value;
pub const ISensorManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSensorsByCategory: fn(
            self: *const ISensorManager,
            sensorCategory: ?*Guid,
            ppSensorsFound: ?*?*ISensorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorsByType: fn(
            self: *const ISensorManager,
            sensorType: ?*Guid,
            ppSensorsFound: ?*?*ISensorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorByID: fn(
            self: *const ISensorManager,
            sensorID: ?*Guid,
            ppSensor: ?*?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventSink: fn(
            self: *const ISensorManager,
            pEvents: ?*ISensorManagerEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestPermissions: fn(
            self: *const ISensorManager,
            hParent: ?HWND,
            pSensors: ?*ISensorCollection,
            fModal: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_GetSensorsByCategory(self: *const T, sensorCategory: ?*Guid, ppSensorsFound: ?*?*ISensorCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).GetSensorsByCategory(@ptrCast(*const ISensorManager, self), sensorCategory, ppSensorsFound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_GetSensorsByType(self: *const T, sensorType: ?*Guid, ppSensorsFound: ?*?*ISensorCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).GetSensorsByType(@ptrCast(*const ISensorManager, self), sensorType, ppSensorsFound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_GetSensorByID(self: *const T, sensorID: ?*Guid, ppSensor: ?*?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).GetSensorByID(@ptrCast(*const ISensorManager, self), sensorID, ppSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_SetEventSink(self: *const T, pEvents: ?*ISensorManagerEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).SetEventSink(@ptrCast(*const ISensorManager, self), pEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_RequestPermissions(self: *const T, hParent: ?HWND, pSensors: ?*ISensorCollection, fModal: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).RequestPermissions(@ptrCast(*const ISensorManager, self), hParent, pSensors, fModal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ILocationPermissions_Value = @import("../zig.zig").Guid.initString("d5fb0a7f-e74e-44f5-8e02-4806863a274f");
pub const IID_ILocationPermissions = &IID_ILocationPermissions_Value;
pub const ILocationPermissions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGlobalLocationPermission: fn(
            self: *const ILocationPermissions,
            pfEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckLocationCapability: fn(
            self: *const ILocationPermissions,
            dwClientThreadId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocationPermissions_GetGlobalLocationPermission(self: *const T, pfEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocationPermissions.VTable, self.vtable).GetGlobalLocationPermission(@ptrCast(*const ILocationPermissions, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocationPermissions_CheckLocationCapability(self: *const T, dwClientThreadId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocationPermissions.VTable, self.vtable).CheckLocationCapability(@ptrCast(*const ILocationPermissions, self), dwClientThreadId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorCollection_Value = @import("../zig.zig").Guid.initString("23571e11-e545-4dd8-a337-b89bf44b10df");
pub const IID_ISensorCollection = &IID_ISensorCollection_Value;
pub const ISensorCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAt: fn(
            self: *const ISensorCollection,
            ulIndex: u32,
            ppSensor: ?*?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ISensorCollection,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ISensorCollection,
            pSensor: ?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ISensorCollection,
            pSensor: ?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveByID: fn(
            self: *const ISensorCollection,
            sensorID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ISensorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_GetAt(self: *const T, ulIndex: u32, ppSensor: ?*?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).GetAt(@ptrCast(*const ISensorCollection, self), ulIndex, ppSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_GetCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).GetCount(@ptrCast(*const ISensorCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_Add(self: *const T, pSensor: ?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).Add(@ptrCast(*const ISensorCollection, self), pSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_Remove(self: *const T, pSensor: ?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).Remove(@ptrCast(*const ISensorCollection, self), pSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_RemoveByID(self: *const T, sensorID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).RemoveByID(@ptrCast(*const ISensorCollection, self), sensorID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).Clear(@ptrCast(*const ISensorCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensor_Value = @import("../zig.zig").Guid.initString("5fa08f80-2657-458e-af75-46f73fa6ac5c");
pub const IID_ISensor = &IID_ISensor_Value;
pub const ISensor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetID: fn(
            self: *const ISensor,
            pID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategory: fn(
            self: *const ISensor,
            pSensorCategory: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ISensor,
            pSensorType: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFriendlyName: fn(
            self: *const ISensor,
            pFriendlyName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ISensor,
            key: ?*const PROPERTYKEY,
            pProperty: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const ISensor,
            pKeys: ?*IPortableDeviceKeyCollection,
            ppProperties: ?*?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedDataFields: fn(
            self: *const ISensor,
            ppDataFields: ?*?*IPortableDeviceKeyCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const ISensor,
            pProperties: ?*IPortableDeviceValues,
            ppResults: ?*?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupportsDataField: fn(
            self: *const ISensor,
            key: ?*const PROPERTYKEY,
            pIsSupported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const ISensor,
            pState: ?*SensorState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: fn(
            self: *const ISensor,
            ppDataReport: ?*?*ISensorDataReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupportsEvent: fn(
            self: *const ISensor,
            eventGuid: ?*const Guid,
            pIsSupported: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventInterest: fn(
            self: *const ISensor,
            ppValues: ?[*]?*Guid,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventInterest: fn(
            self: *const ISensor,
            pValues: ?[*]Guid,
            count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventSink: fn(
            self: *const ISensor,
            pEvents: ?*ISensorEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetID(self: *const T, pID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetID(@ptrCast(*const ISensor, self), pID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetCategory(self: *const T, pSensorCategory: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetCategory(@ptrCast(*const ISensor, self), pSensorCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetType(self: *const T, pSensorType: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetType(@ptrCast(*const ISensor, self), pSensorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetFriendlyName(self: *const T, pFriendlyName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetFriendlyName(@ptrCast(*const ISensor, self), pFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetProperty(self: *const T, key: ?*const PROPERTYKEY, pProperty: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetProperty(@ptrCast(*const ISensor, self), key, pProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetProperties(self: *const T, pKeys: ?*IPortableDeviceKeyCollection, ppProperties: ?*?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetProperties(@ptrCast(*const ISensor, self), pKeys, ppProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetSupportedDataFields(self: *const T, ppDataFields: ?*?*IPortableDeviceKeyCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetSupportedDataFields(@ptrCast(*const ISensor, self), ppDataFields);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SetProperties(self: *const T, pProperties: ?*IPortableDeviceValues, ppResults: ?*?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SetProperties(@ptrCast(*const ISensor, self), pProperties, ppResults);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SupportsDataField(self: *const T, key: ?*const PROPERTYKEY, pIsSupported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SupportsDataField(@ptrCast(*const ISensor, self), key, pIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetState(self: *const T, pState: ?*SensorState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetState(@ptrCast(*const ISensor, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetData(self: *const T, ppDataReport: ?*?*ISensorDataReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetData(@ptrCast(*const ISensor, self), ppDataReport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SupportsEvent(self: *const T, eventGuid: ?*const Guid, pIsSupported: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SupportsEvent(@ptrCast(*const ISensor, self), eventGuid, pIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetEventInterest(self: *const T, ppValues: ?[*]?*Guid, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetEventInterest(@ptrCast(*const ISensor, self), ppValues, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SetEventInterest(self: *const T, pValues: ?[*]Guid, count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SetEventInterest(@ptrCast(*const ISensor, self), pValues, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SetEventSink(self: *const T, pEvents: ?*ISensorEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SetEventSink(@ptrCast(*const ISensor, self), pEvents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorDataReport_Value = @import("../zig.zig").Guid.initString("0ab9df9b-c4b5-4796-8898-0470706a2e1d");
pub const IID_ISensorDataReport = &IID_ISensorDataReport_Value;
pub const ISensorDataReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTimestamp: fn(
            self: *const ISensorDataReport,
            pTimeStamp: ?*SYSTEMTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorValue: fn(
            self: *const ISensorDataReport,
            pKey: ?*const PROPERTYKEY,
            pValue: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorValues: fn(
            self: *const ISensorDataReport,
            pKeys: ?*IPortableDeviceKeyCollection,
            ppValues: ?*?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorDataReport_GetTimestamp(self: *const T, pTimeStamp: ?*SYSTEMTIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorDataReport.VTable, self.vtable).GetTimestamp(@ptrCast(*const ISensorDataReport, self), pTimeStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorDataReport_GetSensorValue(self: *const T, pKey: ?*const PROPERTYKEY, pValue: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorDataReport.VTable, self.vtable).GetSensorValue(@ptrCast(*const ISensorDataReport, self), pKey, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorDataReport_GetSensorValues(self: *const T, pKeys: ?*IPortableDeviceKeyCollection, ppValues: ?*?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorDataReport.VTable, self.vtable).GetSensorValues(@ptrCast(*const ISensorDataReport, self), pKeys, ppValues);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorManagerEvents_Value = @import("../zig.zig").Guid.initString("9b3b0b86-266a-4aad-b21f-fde5501001b7");
pub const IID_ISensorManagerEvents = &IID_ISensorManagerEvents_Value;
pub const ISensorManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSensorEnter: fn(
            self: *const ISensorManagerEvents,
            pSensor: ?*ISensor,
            state: SensorState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManagerEvents_OnSensorEnter(self: *const T, pSensor: ?*ISensor, state: SensorState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManagerEvents.VTable, self.vtable).OnSensorEnter(@ptrCast(*const ISensorManagerEvents, self), pSensor, state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISensorEvents_Value = @import("../zig.zig").Guid.initString("5d8dcc91-4641-47e7-b7c3-b74f48a6c391");
pub const IID_ISensorEvents = &IID_ISensorEvents_Value;
pub const ISensorEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStateChanged: fn(
            self: *const ISensorEvents,
            pSensor: ?*ISensor,
            state: SensorState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDataUpdated: fn(
            self: *const ISensorEvents,
            pSensor: ?*ISensor,
            pNewData: ?*ISensorDataReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEvent: fn(
            self: *const ISensorEvents,
            pSensor: ?*ISensor,
            eventID: ?*const Guid,
            pEventData: ?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLeave: fn(
            self: *const ISensorEvents,
            ID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnStateChanged(self: *const T, pSensor: ?*ISensor, state: SensorState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnStateChanged(@ptrCast(*const ISensorEvents, self), pSensor, state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnDataUpdated(self: *const T, pSensor: ?*ISensor, pNewData: ?*ISensorDataReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnDataUpdated(@ptrCast(*const ISensorEvents, self), pSensor, pNewData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnEvent(self: *const T, pSensor: ?*ISensor, eventID: ?*const Guid, pEventData: ?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnEvent(@ptrCast(*const ISensorEvents, self), pSensor, eventID, pEventData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnLeave(self: *const T, ID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnLeave(@ptrCast(*const ISensorEvents, self), ID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ACTIVITY_STATE_COUNT = enum(i32) {
    t = 8,
};
pub const ActivityStateCount = ACTIVITY_STATE_COUNT.t;

pub const ACTIVITY_STATE = enum(i32) {
    Unknown = 1,
    Stationary = 2,
    Fidgeting = 4,
    Walking = 8,
    Running = 16,
    InVehicle = 32,
    Biking = 64,
    Idle = 128,
    Max = 256,
    Force_Dword = -1,
};
pub const ActivityState_Unknown = ACTIVITY_STATE.Unknown;
pub const ActivityState_Stationary = ACTIVITY_STATE.Stationary;
pub const ActivityState_Fidgeting = ACTIVITY_STATE.Fidgeting;
pub const ActivityState_Walking = ACTIVITY_STATE.Walking;
pub const ActivityState_Running = ACTIVITY_STATE.Running;
pub const ActivityState_InVehicle = ACTIVITY_STATE.InVehicle;
pub const ActivityState_Biking = ACTIVITY_STATE.Biking;
pub const ActivityState_Idle = ACTIVITY_STATE.Idle;
pub const ActivityState_Max = ACTIVITY_STATE.Max;
pub const ActivityState_Force_Dword = ACTIVITY_STATE.Force_Dword;

pub const ELEVATION_CHANGE_MODE = enum(i32) {
    Unknown = 0,
    Elevator = 1,
    Stepping = 2,
    Max = 3,
    Force_Dword = -1,
};
pub const ElevationChangeMode_Unknown = ELEVATION_CHANGE_MODE.Unknown;
pub const ElevationChangeMode_Elevator = ELEVATION_CHANGE_MODE.Elevator;
pub const ElevationChangeMode_Stepping = ELEVATION_CHANGE_MODE.Stepping;
pub const ElevationChangeMode_Max = ELEVATION_CHANGE_MODE.Max;
pub const ElevationChangeMode_Force_Dword = ELEVATION_CHANGE_MODE.Force_Dword;

pub const MAGNETOMETER_ACCURACY = enum(i32) {
    Unknown = 0,
    Unreliable = 1,
    Approximate = 2,
    High = 3,
};
pub const MagnetometerAccuracy_Unknown = MAGNETOMETER_ACCURACY.Unknown;
pub const MagnetometerAccuracy_Unreliable = MAGNETOMETER_ACCURACY.Unreliable;
pub const MagnetometerAccuracy_Approximate = MAGNETOMETER_ACCURACY.Approximate;
pub const MagnetometerAccuracy_High = MAGNETOMETER_ACCURACY.High;

pub const PEDOMETER_STEP_TYPE_COUNT = enum(i32) {
    t = 3,
};
pub const PedometerStepTypeCount = PEDOMETER_STEP_TYPE_COUNT.t;

pub const PEDOMETER_STEP_TYPE = enum(i32) {
    Unknown = 1,
    Walking = 2,
    Running = 4,
    Max = 8,
    Force_Dword = -1,
};
pub const PedometerStepType_Unknown = PEDOMETER_STEP_TYPE.Unknown;
pub const PedometerStepType_Walking = PEDOMETER_STEP_TYPE.Walking;
pub const PedometerStepType_Running = PEDOMETER_STEP_TYPE.Running;
pub const PedometerStepType_Max = PEDOMETER_STEP_TYPE.Max;
pub const PedometerStepType_Force_Dword = PEDOMETER_STEP_TYPE.Force_Dword;

pub const PROXIMITY_TYPE = enum(i32) {
    ObjectProximity = 0,
    HumanProximity = 1,
    Force_Dword = -1,
};
pub const ProximityType_ObjectProximity = PROXIMITY_TYPE.ObjectProximity;
pub const ProximityType_HumanProximity = PROXIMITY_TYPE.HumanProximity;
pub const ProximityType_Force_Dword = PROXIMITY_TYPE.Force_Dword;

pub const HUMAN_PRESENCE_DETECTION_TYPE_COUNT = enum(i32) {
    t = 4,
};
pub const HumanPresenceDetectionTypeCount = HUMAN_PRESENCE_DETECTION_TYPE_COUNT.t;

pub const HUMAN_PRESENCE_DETECTION_TYPE = enum(i32) {
    VendorDefinedNonBiometric = 1,
    VendorDefinedBiometric = 2,
    FacialBiometric = 4,
    AudioBiometric = 8,
    Force_Dword = -1,
};
pub const HumanPresenceDetectionType_VendorDefinedNonBiometric = HUMAN_PRESENCE_DETECTION_TYPE.VendorDefinedNonBiometric;
pub const HumanPresenceDetectionType_VendorDefinedBiometric = HUMAN_PRESENCE_DETECTION_TYPE.VendorDefinedBiometric;
pub const HumanPresenceDetectionType_FacialBiometric = HUMAN_PRESENCE_DETECTION_TYPE.FacialBiometric;
pub const HumanPresenceDetectionType_AudioBiometric = HUMAN_PRESENCE_DETECTION_TYPE.AudioBiometric;
pub const HumanPresenceDetectionType_Force_Dword = HUMAN_PRESENCE_DETECTION_TYPE.Force_Dword;

pub const SIMPLE_DEVICE_ORIENTATION = enum(i32) {
    NotRotated = 0,
    Rotated90DegreesCounterclockwise = 1,
    Rotated180DegreesCounterclockwise = 2,
    Rotated270DegreesCounterclockwise = 3,
    Faceup = 4,
    Facedown = 5,
};
pub const SimpleDeviceOrientation_NotRotated = SIMPLE_DEVICE_ORIENTATION.NotRotated;
pub const SimpleDeviceOrientation_Rotated90DegreesCounterclockwise = SIMPLE_DEVICE_ORIENTATION.Rotated90DegreesCounterclockwise;
pub const SimpleDeviceOrientation_Rotated180DegreesCounterclockwise = SIMPLE_DEVICE_ORIENTATION.Rotated180DegreesCounterclockwise;
pub const SimpleDeviceOrientation_Rotated270DegreesCounterclockwise = SIMPLE_DEVICE_ORIENTATION.Rotated270DegreesCounterclockwise;
pub const SimpleDeviceOrientation_Faceup = SIMPLE_DEVICE_ORIENTATION.Faceup;
pub const SimpleDeviceOrientation_Facedown = SIMPLE_DEVICE_ORIENTATION.Facedown;

pub const SENSOR_STATE = enum(i32) {
    Initializing = 0,
    Idle = 1,
    Active = 2,
    Error = 3,
};
pub const SensorState_Initializing = SENSOR_STATE.Initializing;
pub const SensorState_Idle = SENSOR_STATE.Idle;
pub const SensorState_Active = SENSOR_STATE.Active;
pub const SensorState_Error = SENSOR_STATE.Error;

pub const SENSOR_CONNECTION_TYPES = enum(i32) {
    Integrated = 0,
    Attached = 1,
    External = 2,
};
pub const SensorConnectionType_Integrated = SENSOR_CONNECTION_TYPES.Integrated;
pub const SensorConnectionType_Attached = SENSOR_CONNECTION_TYPES.Attached;
pub const SensorConnectionType_External = SENSOR_CONNECTION_TYPES.External;

pub const SENSOR_VALUE_PAIR = extern struct {
    Key: PROPERTYKEY,
    Value: PROPVARIANT,
};

pub const SENSOR_COLLECTION_LIST = extern struct {
    AllocatedSizeInBytes: u32,
    Count: u32,
    List: [1]SENSOR_VALUE_PAIR,
};

pub const SENSOR_PROPERTY_LIST = extern struct {
    AllocatedSizeInBytes: u32,
    Count: u32,
    List: [1]PROPERTYKEY,
};

pub const VEC3D = extern struct {
    X: f32,
    Y: f32,
    Z: f32,
};

pub const MATRIX3X3 = extern struct {
    Anonymous: extern union {
        Anonymous1: extern struct {
            A11: f32,
            A12: f32,
            A13: f32,
            A21: f32,
            A22: f32,
            A23: f32,
            A31: f32,
            A32: f32,
            A33: f32,
        },
        Anonymous2: extern struct {
            V1: VEC3D,
            V2: VEC3D,
            V3: VEC3D,
        },
        M: [9]f32,
    },
};

pub const QUATERNION = extern struct {
    X: f32,
    Y: f32,
    Z: f32,
    W: f32,
};

pub const AXIS = enum(i32) {
    X = 0,
    Y = 1,
    Z = 2,
    MAX = 3,
};
pub const AXIS_X = AXIS.X;
pub const AXIS_Y = AXIS.Y;
pub const AXIS_Z = AXIS.Z;
pub const AXIS_MAX = AXIS.MAX;


//--------------------------------------------------------------------------------
// Section: Functions (40)
//--------------------------------------------------------------------------------
pub extern "SensorsUtilsV2" fn GetPerformanceTime(
    TimeMs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn InitPropVariantFromFloat(
    fltVal: f32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetPropVariant(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    TypeCheck: BOOLEAN,
    pValue: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeySetPropVariant(
    pList: ?*SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    TypeCheck: BOOLEAN,
    pValue: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetFileTime(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    pRetValue: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetGuid(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    pRetValue: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetBool(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    pRetValue: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetUlong(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    pRetValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetUshort(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    pRetValue: ?*u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetFloat(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    pRetValue: ?*f32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetDouble(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    pRetValue: ?*f64,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetInt32(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    pRetValue: ?*i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetInt64(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    pRetValue: ?*i64,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetNthUlong(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    Occurrence: u32,
    pRetValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetNthUshort(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    Occurrence: u32,
    pRetValue: ?*u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropKeyFindKeyGetNthInt64(
    pList: ?*const SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
    Occurrence: u32,
    pRetValue: ?*i64,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn IsKeyPresentInPropertyList(
    pList: ?*SENSOR_PROPERTY_LIST,
    pKey: ?*const PROPERTYKEY,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "SensorsUtilsV2" fn IsKeyPresentInCollectionList(
    pList: ?*SENSOR_COLLECTION_LIST,
    pKey: ?*const PROPERTYKEY,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "SensorsUtilsV2" fn IsCollectionListSame(
    ListA: ?*const SENSOR_COLLECTION_LIST,
    ListB: ?*const SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "SensorsUtilsV2" fn PropVariantGetInformation(
    PropVariantValue: ?*const PROPVARIANT,
    PropVariantOffset: ?*u32,
    PropVariantSize: ?*u32,
    PropVariantPointer: ?*?*anyopaque,
    RemappedType: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropertiesListCopy(
    Target: ?*SENSOR_PROPERTY_LIST,
    Source: ?*const SENSOR_PROPERTY_LIST,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn PropertiesListGetFillableCount(
    BufferSizeBytes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SensorsUtilsV2" fn CollectionsListGetMarshalledSize(
    Collection: ?*const SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SensorsUtilsV2" fn CollectionsListCopyAndMarshall(
    Target: ?*SENSOR_COLLECTION_LIST,
    Source: ?*const SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn CollectionsListMarshall(
    Target: ?*SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn CollectionsListGetMarshalledSizeWithoutSerialization(
    Collection: ?*const SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SensorsUtilsV2" fn CollectionsListUpdateMarshalledPointer(
    Collection: ?*SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn SerializationBufferAllocate(
    SizeInBytes: u32,
    pBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn SerializationBufferFree(
    Buffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "SensorsUtilsV2" fn CollectionsListGetSerializedSize(
    Collection: ?*const SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SensorsUtilsV2" fn CollectionsListSerializeToBuffer(
    SourceCollection: ?*const SENSOR_COLLECTION_LIST,
    TargetBufferSizeInBytes: u32,
    // TODO: what to do with BytesParamIndex 1?
    TargetBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn CollectionsListAllocateBufferAndSerialize(
    SourceCollection: ?*const SENSOR_COLLECTION_LIST,
    pTargetBufferSizeInBytes: ?*u32,
    pTargetBuffer: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn CollectionsListDeserializeFromBuffer(
    SourceBufferSizeInBytes: u32,
    // TODO: what to do with BytesParamIndex 0?
    SourceBuffer: ?*const u8,
    TargetCollection: ?*SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn SensorCollectionGetAt(
    Index: u32,
    pSensorsList: ?*SENSOR_COLLECTION_LIST,
    pKey: ?*PROPERTYKEY,
    pValue: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn CollectionsListGetFillableCount(
    BufferSizeBytes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SensorsUtilsV2" fn EvaluateActivityThresholds(
    newSample: ?*SENSOR_COLLECTION_LIST,
    oldSample: ?*SENSOR_COLLECTION_LIST,
    thresholds: ?*SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "SensorsUtilsV2" fn CollectionsListSortSubscribedActivitiesByConfidence(
    thresholds: ?*SENSOR_COLLECTION_LIST,
    pCollection: ?*SENSOR_COLLECTION_LIST,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "SensorsUtilsV2" fn InitPropVariantFromCLSIDArray(
    members: [*]Guid,
    size: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "SensorsUtilsV2" fn IsSensorSubscribed(
    subscriptionList: ?*SENSOR_COLLECTION_LIST,
    currentType: Guid,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "SensorsUtilsV2" fn IsGUIDPresentInList(
    guidArray: [*]const Guid,
    arrayLength: u32,
    guidElem: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (14)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IPortableDeviceKeyCollection = @import("../devices/portable_devices.zig").IPortableDeviceKeyCollection;
const IPortableDeviceValues = @import("../devices/portable_devices.zig").IPortableDeviceValues;
const IUnknown = @import("../system/com.zig").IUnknown;
const NTSTATUS = @import("../foundation.zig").NTSTATUS;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
