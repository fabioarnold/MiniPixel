//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (39)
//--------------------------------------------------------------------------------
pub const MARSHALINTERFACE_MIN = @as(u32, 500);
pub const ASYNC_MODE_COMPATIBILITY = @as(i32, 1);
pub const ASYNC_MODE_DEFAULT = @as(i32, 0);
pub const STGTY_REPEAT = @as(i32, 256);
pub const STG_TOEND = @as(i32, -1);
pub const STG_LAYOUT_SEQUENTIAL = @as(i32, 0);
pub const STG_LAYOUT_INTERLEAVED = @as(i32, 1);
pub const COM_RIGHTS_EXECUTE = @as(u32, 1);
pub const COM_RIGHTS_EXECUTE_LOCAL = @as(u32, 2);
pub const COM_RIGHTS_EXECUTE_REMOTE = @as(u32, 4);
pub const COM_RIGHTS_ACTIVATE_LOCAL = @as(u32, 8);
pub const COM_RIGHTS_ACTIVATE_REMOTE = @as(u32, 16);
pub const COM_RIGHTS_RESERVED1 = @as(u32, 32);
pub const COM_RIGHTS_RESERVED2 = @as(u32, 64);
pub const CWMO_MAX_HANDLES = @as(u32, 56);
pub const ROTREGFLAGS_ALLOWANYCLIENT = @as(u32, 1);
pub const APPIDREGFLAGS_ACTIVATE_IUSERVER_INDESKTOP = @as(u32, 1);
pub const APPIDREGFLAGS_SECURE_SERVER_PROCESS_SD_AND_BIND = @as(u32, 2);
pub const APPIDREGFLAGS_ISSUE_ACTIVATION_RPC_AT_IDENTIFY = @as(u32, 4);
pub const APPIDREGFLAGS_IUSERVER_UNMODIFIED_LOGON_TOKEN = @as(u32, 8);
pub const APPIDREGFLAGS_IUSERVER_SELF_SID_IN_LAUNCH_PERMISSION = @as(u32, 16);
pub const APPIDREGFLAGS_IUSERVER_ACTIVATE_IN_CLIENT_SESSION_ONLY = @as(u32, 32);
pub const APPIDREGFLAGS_RESERVED1 = @as(u32, 64);
pub const APPIDREGFLAGS_RESERVED2 = @as(u32, 128);
pub const APPIDREGFLAGS_RESERVED3 = @as(u32, 256);
pub const APPIDREGFLAGS_RESERVED4 = @as(u32, 512);
pub const APPIDREGFLAGS_RESERVED5 = @as(u32, 1024);
pub const APPIDREGFLAGS_AAA_NO_IMPLICIT_ACTIVATE_AS_IU = @as(u32, 2048);
pub const APPIDREGFLAGS_RESERVED7 = @as(u32, 4096);
pub const APPIDREGFLAGS_RESERVED8 = @as(u32, 8192);
pub const APPIDREGFLAGS_RESERVED9 = @as(u32, 16384);
pub const DCOMSCM_ACTIVATION_USE_ALL_AUTHNSERVICES = @as(u32, 1);
pub const DCOMSCM_ACTIVATION_DISALLOW_UNSECURE_CALL = @as(u32, 2);
pub const DCOMSCM_RESOLVE_USE_ALL_AUTHNSERVICES = @as(u32, 4);
pub const DCOMSCM_RESOLVE_DISALLOW_UNSECURE_CALL = @as(u32, 8);
pub const DCOMSCM_PING_USE_MID_AUTHNSERVICE = @as(u32, 16);
pub const DCOMSCM_PING_DISALLOW_UNSECURE_CALL = @as(u32, 32);
pub const MAXLSN = @as(u64, 9223372036854775807);
pub const DMUS_ERRBASE = @as(u32, 4096);

//--------------------------------------------------------------------------------
// Section: Types (232)
//--------------------------------------------------------------------------------
pub const LPEXCEPFINO_DEFERRED_FILLIN = fn(
    pExcepInfo: ?*EXCEPINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const URI_CREATE_FLAGS = enum(u32) {
    ALLOW_RELATIVE = 1,
    ALLOW_IMPLICIT_WILDCARD_SCHEME = 2,
    ALLOW_IMPLICIT_FILE_SCHEME = 4,
    NOFRAG = 8,
    NO_CANONICALIZE = 16,
    CANONICALIZE = 256,
    FILE_USE_DOS_PATH = 32,
    DECODE_EXTRA_INFO = 64,
    NO_DECODE_EXTRA_INFO = 128,
    CRACK_UNKNOWN_SCHEMES = 512,
    NO_CRACK_UNKNOWN_SCHEMES = 1024,
    PRE_PROCESS_HTML_URI = 2048,
    NO_PRE_PROCESS_HTML_URI = 4096,
    IE_SETTINGS = 8192,
    NO_IE_SETTINGS = 16384,
    NO_ENCODE_FORBIDDEN_CHARACTERS = 32768,
    NORMALIZE_INTL_CHARACTERS = 65536,
    CANONICALIZE_ABSOLUTE = 131072,
    _,
    pub fn initFlags(o: struct {
        ALLOW_RELATIVE: u1 = 0,
        ALLOW_IMPLICIT_WILDCARD_SCHEME: u1 = 0,
        ALLOW_IMPLICIT_FILE_SCHEME: u1 = 0,
        NOFRAG: u1 = 0,
        NO_CANONICALIZE: u1 = 0,
        CANONICALIZE: u1 = 0,
        FILE_USE_DOS_PATH: u1 = 0,
        DECODE_EXTRA_INFO: u1 = 0,
        NO_DECODE_EXTRA_INFO: u1 = 0,
        CRACK_UNKNOWN_SCHEMES: u1 = 0,
        NO_CRACK_UNKNOWN_SCHEMES: u1 = 0,
        PRE_PROCESS_HTML_URI: u1 = 0,
        NO_PRE_PROCESS_HTML_URI: u1 = 0,
        IE_SETTINGS: u1 = 0,
        NO_IE_SETTINGS: u1 = 0,
        NO_ENCODE_FORBIDDEN_CHARACTERS: u1 = 0,
        NORMALIZE_INTL_CHARACTERS: u1 = 0,
        CANONICALIZE_ABSOLUTE: u1 = 0,
    }) URI_CREATE_FLAGS {
        return @intToEnum(URI_CREATE_FLAGS,
              (if (o.ALLOW_RELATIVE == 1) @enumToInt(URI_CREATE_FLAGS.ALLOW_RELATIVE) else 0)
            | (if (o.ALLOW_IMPLICIT_WILDCARD_SCHEME == 1) @enumToInt(URI_CREATE_FLAGS.ALLOW_IMPLICIT_WILDCARD_SCHEME) else 0)
            | (if (o.ALLOW_IMPLICIT_FILE_SCHEME == 1) @enumToInt(URI_CREATE_FLAGS.ALLOW_IMPLICIT_FILE_SCHEME) else 0)
            | (if (o.NOFRAG == 1) @enumToInt(URI_CREATE_FLAGS.NOFRAG) else 0)
            | (if (o.NO_CANONICALIZE == 1) @enumToInt(URI_CREATE_FLAGS.NO_CANONICALIZE) else 0)
            | (if (o.CANONICALIZE == 1) @enumToInt(URI_CREATE_FLAGS.CANONICALIZE) else 0)
            | (if (o.FILE_USE_DOS_PATH == 1) @enumToInt(URI_CREATE_FLAGS.FILE_USE_DOS_PATH) else 0)
            | (if (o.DECODE_EXTRA_INFO == 1) @enumToInt(URI_CREATE_FLAGS.DECODE_EXTRA_INFO) else 0)
            | (if (o.NO_DECODE_EXTRA_INFO == 1) @enumToInt(URI_CREATE_FLAGS.NO_DECODE_EXTRA_INFO) else 0)
            | (if (o.CRACK_UNKNOWN_SCHEMES == 1) @enumToInt(URI_CREATE_FLAGS.CRACK_UNKNOWN_SCHEMES) else 0)
            | (if (o.NO_CRACK_UNKNOWN_SCHEMES == 1) @enumToInt(URI_CREATE_FLAGS.NO_CRACK_UNKNOWN_SCHEMES) else 0)
            | (if (o.PRE_PROCESS_HTML_URI == 1) @enumToInt(URI_CREATE_FLAGS.PRE_PROCESS_HTML_URI) else 0)
            | (if (o.NO_PRE_PROCESS_HTML_URI == 1) @enumToInt(URI_CREATE_FLAGS.NO_PRE_PROCESS_HTML_URI) else 0)
            | (if (o.IE_SETTINGS == 1) @enumToInt(URI_CREATE_FLAGS.IE_SETTINGS) else 0)
            | (if (o.NO_IE_SETTINGS == 1) @enumToInt(URI_CREATE_FLAGS.NO_IE_SETTINGS) else 0)
            | (if (o.NO_ENCODE_FORBIDDEN_CHARACTERS == 1) @enumToInt(URI_CREATE_FLAGS.NO_ENCODE_FORBIDDEN_CHARACTERS) else 0)
            | (if (o.NORMALIZE_INTL_CHARACTERS == 1) @enumToInt(URI_CREATE_FLAGS.NORMALIZE_INTL_CHARACTERS) else 0)
            | (if (o.CANONICALIZE_ABSOLUTE == 1) @enumToInt(URI_CREATE_FLAGS.CANONICALIZE_ABSOLUTE) else 0)
        );
    }
};
pub const Uri_CREATE_ALLOW_RELATIVE = URI_CREATE_FLAGS.ALLOW_RELATIVE;
pub const Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_WILDCARD_SCHEME;
pub const Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_FILE_SCHEME;
pub const Uri_CREATE_NOFRAG = URI_CREATE_FLAGS.NOFRAG;
pub const Uri_CREATE_NO_CANONICALIZE = URI_CREATE_FLAGS.NO_CANONICALIZE;
pub const Uri_CREATE_CANONICALIZE = URI_CREATE_FLAGS.CANONICALIZE;
pub const Uri_CREATE_FILE_USE_DOS_PATH = URI_CREATE_FLAGS.FILE_USE_DOS_PATH;
pub const Uri_CREATE_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.DECODE_EXTRA_INFO;
pub const Uri_CREATE_NO_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.NO_DECODE_EXTRA_INFO;
pub const Uri_CREATE_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.NO_CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_NO_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.NO_PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_IE_SETTINGS = URI_CREATE_FLAGS.IE_SETTINGS;
pub const Uri_CREATE_NO_IE_SETTINGS = URI_CREATE_FLAGS.NO_IE_SETTINGS;
pub const Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS = URI_CREATE_FLAGS.NO_ENCODE_FORBIDDEN_CHARACTERS;
pub const Uri_CREATE_NORMALIZE_INTL_CHARACTERS = URI_CREATE_FLAGS.NORMALIZE_INTL_CHARACTERS;
pub const Uri_CREATE_CANONICALIZE_ABSOLUTE = URI_CREATE_FLAGS.CANONICALIZE_ABSOLUTE;

pub const RPC_C_AUTHN_LEVEL = enum(u32) {
    DEFAULT = 0,
    NONE = 1,
    CONNECT = 2,
    CALL = 3,
    PKT = 4,
    PKT_INTEGRITY = 5,
    PKT_PRIVACY = 6,
};
pub const RPC_C_AUTHN_LEVEL_DEFAULT = RPC_C_AUTHN_LEVEL.DEFAULT;
pub const RPC_C_AUTHN_LEVEL_NONE = RPC_C_AUTHN_LEVEL.NONE;
pub const RPC_C_AUTHN_LEVEL_CONNECT = RPC_C_AUTHN_LEVEL.CONNECT;
pub const RPC_C_AUTHN_LEVEL_CALL = RPC_C_AUTHN_LEVEL.CALL;
pub const RPC_C_AUTHN_LEVEL_PKT = RPC_C_AUTHN_LEVEL.PKT;
pub const RPC_C_AUTHN_LEVEL_PKT_INTEGRITY = RPC_C_AUTHN_LEVEL.PKT_INTEGRITY;
pub const RPC_C_AUTHN_LEVEL_PKT_PRIVACY = RPC_C_AUTHN_LEVEL.PKT_PRIVACY;

pub const RPC_C_IMP_LEVEL = enum(u32) {
    DEFAULT = 0,
    ANONYMOUS = 1,
    IDENTIFY = 2,
    IMPERSONATE = 3,
    DELEGATE = 4,
};
pub const RPC_C_IMP_LEVEL_DEFAULT = RPC_C_IMP_LEVEL.DEFAULT;
pub const RPC_C_IMP_LEVEL_ANONYMOUS = RPC_C_IMP_LEVEL.ANONYMOUS;
pub const RPC_C_IMP_LEVEL_IDENTIFY = RPC_C_IMP_LEVEL.IDENTIFY;
pub const RPC_C_IMP_LEVEL_IMPERSONATE = RPC_C_IMP_LEVEL.IMPERSONATE;
pub const RPC_C_IMP_LEVEL_DELEGATE = RPC_C_IMP_LEVEL.DELEGATE;

pub const CO_MTA_USAGE_COOKIE = isize;

pub const CO_DEVICE_CATALOG_COOKIE = isize;

pub const DVASPECT = enum(i32) {
    CONTENT = 1,
    THUMBNAIL = 2,
    ICON = 4,
    DOCPRINT = 8,
};
pub const DVASPECT_CONTENT = DVASPECT.CONTENT;
pub const DVASPECT_THUMBNAIL = DVASPECT.THUMBNAIL;
pub const DVASPECT_ICON = DVASPECT.ICON;
pub const DVASPECT_DOCPRINT = DVASPECT.DOCPRINT;

pub const CY = extern union {
    Anonymous: extern struct {
        Lo: u32,
        Hi: i32,
    },
    int64: i64,
};

pub const CSPLATFORM = extern struct {
    dwPlatformId: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
    dwProcessorArch: u32,
};

pub const QUERYCONTEXT = extern struct {
    dwContext: u32,
    Platform: CSPLATFORM,
    Locale: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
};

pub const TYSPEC = enum(i32) {
    CLSID = 0,
    FILEEXT = 1,
    MIMETYPE = 2,
    FILENAME = 3,
    PROGID = 4,
    PACKAGENAME = 5,
    OBJECTID = 6,
};
pub const TYSPEC_CLSID = TYSPEC.CLSID;
pub const TYSPEC_FILEEXT = TYSPEC.FILEEXT;
pub const TYSPEC_MIMETYPE = TYSPEC.MIMETYPE;
pub const TYSPEC_FILENAME = TYSPEC.FILENAME;
pub const TYSPEC_PROGID = TYSPEC.PROGID;
pub const TYSPEC_PACKAGENAME = TYSPEC.PACKAGENAME;
pub const TYSPEC_OBJECTID = TYSPEC.OBJECTID;

pub const uCLSSPEC = extern struct {
    tyspec: u32,
    tagged_union: extern struct {
        clsid: Guid,
        pFileExt: ?PWSTR,
        pMimeType: ?PWSTR,
        pProgId: ?PWSTR,
        pFileName: ?PWSTR,
        ByName: extern struct {
            pPackageName: ?PWSTR,
            PolicyId: Guid,
        },
        ByObjectId: extern struct {
            ObjectId: Guid,
            PolicyId: Guid,
        },
    },
};

pub const REGCLS = enum(i32) {
    SINGLEUSE = 0,
    MULTIPLEUSE = 1,
    MULTI_SEPARATE = 2,
    SUSPENDED = 4,
    SURROGATE = 8,
    AGILE = 16,
};
pub const REGCLS_SINGLEUSE = REGCLS.SINGLEUSE;
pub const REGCLS_MULTIPLEUSE = REGCLS.MULTIPLEUSE;
pub const REGCLS_MULTI_SEPARATE = REGCLS.MULTI_SEPARATE;
pub const REGCLS_SUSPENDED = REGCLS.SUSPENDED;
pub const REGCLS_SURROGATE = REGCLS.SURROGATE;
pub const REGCLS_AGILE = REGCLS.AGILE;

pub const COINITBASE = enum(i32) {
    D = 0,
};
pub const COINITBASE_MULTITHREADED = COINITBASE.D;

pub const COAUTHIDENTITY = extern struct {
    User: ?*u16,
    UserLength: u32,
    Domain: ?*u16,
    DomainLength: u32,
    Password: ?*u16,
    PasswordLength: u32,
    Flags: u32,
};

pub const COAUTHINFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pwszServerPrincName: ?PWSTR,
    dwAuthnLevel: u32,
    dwImpersonationLevel: u32,
    pAuthIdentityData: ?*COAUTHIDENTITY,
    dwCapabilities: u32,
};

pub const MEMCTX = enum(i32) {
    TASK = 1,
    SHARED = 2,
    MACSYSTEM = 3,
    UNKNOWN = -1,
    SAME = -2,
};
pub const MEMCTX_TASK = MEMCTX.TASK;
pub const MEMCTX_SHARED = MEMCTX.SHARED;
pub const MEMCTX_MACSYSTEM = MEMCTX.MACSYSTEM;
pub const MEMCTX_UNKNOWN = MEMCTX.UNKNOWN;
pub const MEMCTX_SAME = MEMCTX.SAME;

pub const CLSCTX = enum(u32) {
    INPROC_SERVER = 1,
    INPROC_HANDLER = 2,
    LOCAL_SERVER = 4,
    INPROC_SERVER16 = 8,
    REMOTE_SERVER = 16,
    INPROC_HANDLER16 = 32,
    RESERVED1 = 64,
    RESERVED2 = 128,
    RESERVED3 = 256,
    RESERVED4 = 512,
    NO_CODE_DOWNLOAD = 1024,
    RESERVED5 = 2048,
    NO_CUSTOM_MARSHAL = 4096,
    ENABLE_CODE_DOWNLOAD = 8192,
    NO_FAILURE_LOG = 16384,
    DISABLE_AAA = 32768,
    ENABLE_AAA = 65536,
    FROM_DEFAULT_CONTEXT = 131072,
    ACTIVATE_X86_SERVER = 262144,
    // ACTIVATE_32_BIT_SERVER = 262144, this enum value conflicts with ACTIVATE_X86_SERVER
    ACTIVATE_64_BIT_SERVER = 524288,
    ENABLE_CLOAKING = 1048576,
    APPCONTAINER = 4194304,
    ACTIVATE_AAA_AS_IU = 8388608,
    RESERVED6 = 16777216,
    ACTIVATE_ARM32_SERVER = 33554432,
    PS_DLL = 2147483648,
    ALL = 23,
    SERVER = 21,
    _,
    pub fn initFlags(o: struct {
        INPROC_SERVER: u1 = 0,
        INPROC_HANDLER: u1 = 0,
        LOCAL_SERVER: u1 = 0,
        INPROC_SERVER16: u1 = 0,
        REMOTE_SERVER: u1 = 0,
        INPROC_HANDLER16: u1 = 0,
        RESERVED1: u1 = 0,
        RESERVED2: u1 = 0,
        RESERVED3: u1 = 0,
        RESERVED4: u1 = 0,
        NO_CODE_DOWNLOAD: u1 = 0,
        RESERVED5: u1 = 0,
        NO_CUSTOM_MARSHAL: u1 = 0,
        ENABLE_CODE_DOWNLOAD: u1 = 0,
        NO_FAILURE_LOG: u1 = 0,
        DISABLE_AAA: u1 = 0,
        ENABLE_AAA: u1 = 0,
        FROM_DEFAULT_CONTEXT: u1 = 0,
        ACTIVATE_X86_SERVER: u1 = 0,
        ACTIVATE_64_BIT_SERVER: u1 = 0,
        ENABLE_CLOAKING: u1 = 0,
        APPCONTAINER: u1 = 0,
        ACTIVATE_AAA_AS_IU: u1 = 0,
        RESERVED6: u1 = 0,
        ACTIVATE_ARM32_SERVER: u1 = 0,
        PS_DLL: u1 = 0,
        ALL: u1 = 0,
        SERVER: u1 = 0,
    }) CLSCTX {
        return @intToEnum(CLSCTX,
              (if (o.INPROC_SERVER == 1) @enumToInt(CLSCTX.INPROC_SERVER) else 0)
            | (if (o.INPROC_HANDLER == 1) @enumToInt(CLSCTX.INPROC_HANDLER) else 0)
            | (if (o.LOCAL_SERVER == 1) @enumToInt(CLSCTX.LOCAL_SERVER) else 0)
            | (if (o.INPROC_SERVER16 == 1) @enumToInt(CLSCTX.INPROC_SERVER16) else 0)
            | (if (o.REMOTE_SERVER == 1) @enumToInt(CLSCTX.REMOTE_SERVER) else 0)
            | (if (o.INPROC_HANDLER16 == 1) @enumToInt(CLSCTX.INPROC_HANDLER16) else 0)
            | (if (o.RESERVED1 == 1) @enumToInt(CLSCTX.RESERVED1) else 0)
            | (if (o.RESERVED2 == 1) @enumToInt(CLSCTX.RESERVED2) else 0)
            | (if (o.RESERVED3 == 1) @enumToInt(CLSCTX.RESERVED3) else 0)
            | (if (o.RESERVED4 == 1) @enumToInt(CLSCTX.RESERVED4) else 0)
            | (if (o.NO_CODE_DOWNLOAD == 1) @enumToInt(CLSCTX.NO_CODE_DOWNLOAD) else 0)
            | (if (o.RESERVED5 == 1) @enumToInt(CLSCTX.RESERVED5) else 0)
            | (if (o.NO_CUSTOM_MARSHAL == 1) @enumToInt(CLSCTX.NO_CUSTOM_MARSHAL) else 0)
            | (if (o.ENABLE_CODE_DOWNLOAD == 1) @enumToInt(CLSCTX.ENABLE_CODE_DOWNLOAD) else 0)
            | (if (o.NO_FAILURE_LOG == 1) @enumToInt(CLSCTX.NO_FAILURE_LOG) else 0)
            | (if (o.DISABLE_AAA == 1) @enumToInt(CLSCTX.DISABLE_AAA) else 0)
            | (if (o.ENABLE_AAA == 1) @enumToInt(CLSCTX.ENABLE_AAA) else 0)
            | (if (o.FROM_DEFAULT_CONTEXT == 1) @enumToInt(CLSCTX.FROM_DEFAULT_CONTEXT) else 0)
            | (if (o.ACTIVATE_X86_SERVER == 1) @enumToInt(CLSCTX.ACTIVATE_X86_SERVER) else 0)
            | (if (o.ACTIVATE_64_BIT_SERVER == 1) @enumToInt(CLSCTX.ACTIVATE_64_BIT_SERVER) else 0)
            | (if (o.ENABLE_CLOAKING == 1) @enumToInt(CLSCTX.ENABLE_CLOAKING) else 0)
            | (if (o.APPCONTAINER == 1) @enumToInt(CLSCTX.APPCONTAINER) else 0)
            | (if (o.ACTIVATE_AAA_AS_IU == 1) @enumToInt(CLSCTX.ACTIVATE_AAA_AS_IU) else 0)
            | (if (o.RESERVED6 == 1) @enumToInt(CLSCTX.RESERVED6) else 0)
            | (if (o.ACTIVATE_ARM32_SERVER == 1) @enumToInt(CLSCTX.ACTIVATE_ARM32_SERVER) else 0)
            | (if (o.PS_DLL == 1) @enumToInt(CLSCTX.PS_DLL) else 0)
            | (if (o.ALL == 1) @enumToInt(CLSCTX.ALL) else 0)
            | (if (o.SERVER == 1) @enumToInt(CLSCTX.SERVER) else 0)
        );
    }
};
pub const CLSCTX_INPROC_SERVER = CLSCTX.INPROC_SERVER;
pub const CLSCTX_INPROC_HANDLER = CLSCTX.INPROC_HANDLER;
pub const CLSCTX_LOCAL_SERVER = CLSCTX.LOCAL_SERVER;
pub const CLSCTX_INPROC_SERVER16 = CLSCTX.INPROC_SERVER16;
pub const CLSCTX_REMOTE_SERVER = CLSCTX.REMOTE_SERVER;
pub const CLSCTX_INPROC_HANDLER16 = CLSCTX.INPROC_HANDLER16;
pub const CLSCTX_RESERVED1 = CLSCTX.RESERVED1;
pub const CLSCTX_RESERVED2 = CLSCTX.RESERVED2;
pub const CLSCTX_RESERVED3 = CLSCTX.RESERVED3;
pub const CLSCTX_RESERVED4 = CLSCTX.RESERVED4;
pub const CLSCTX_NO_CODE_DOWNLOAD = CLSCTX.NO_CODE_DOWNLOAD;
pub const CLSCTX_RESERVED5 = CLSCTX.RESERVED5;
pub const CLSCTX_NO_CUSTOM_MARSHAL = CLSCTX.NO_CUSTOM_MARSHAL;
pub const CLSCTX_ENABLE_CODE_DOWNLOAD = CLSCTX.ENABLE_CODE_DOWNLOAD;
pub const CLSCTX_NO_FAILURE_LOG = CLSCTX.NO_FAILURE_LOG;
pub const CLSCTX_DISABLE_AAA = CLSCTX.DISABLE_AAA;
pub const CLSCTX_ENABLE_AAA = CLSCTX.ENABLE_AAA;
pub const CLSCTX_FROM_DEFAULT_CONTEXT = CLSCTX.FROM_DEFAULT_CONTEXT;
pub const CLSCTX_ACTIVATE_X86_SERVER = CLSCTX.ACTIVATE_X86_SERVER;
pub const CLSCTX_ACTIVATE_32_BIT_SERVER = CLSCTX.ACTIVATE_X86_SERVER;
pub const CLSCTX_ACTIVATE_64_BIT_SERVER = CLSCTX.ACTIVATE_64_BIT_SERVER;
pub const CLSCTX_ENABLE_CLOAKING = CLSCTX.ENABLE_CLOAKING;
pub const CLSCTX_APPCONTAINER = CLSCTX.APPCONTAINER;
pub const CLSCTX_ACTIVATE_AAA_AS_IU = CLSCTX.ACTIVATE_AAA_AS_IU;
pub const CLSCTX_RESERVED6 = CLSCTX.RESERVED6;
pub const CLSCTX_ACTIVATE_ARM32_SERVER = CLSCTX.ACTIVATE_ARM32_SERVER;
pub const CLSCTX_PS_DLL = CLSCTX.PS_DLL;
pub const CLSCTX_ALL = CLSCTX.ALL;
pub const CLSCTX_SERVER = CLSCTX.SERVER;

pub const MSHLFLAGS = enum(i32) {
    NORMAL = 0,
    TABLESTRONG = 1,
    TABLEWEAK = 2,
    NOPING = 4,
    RESERVED1 = 8,
    RESERVED2 = 16,
    RESERVED3 = 32,
    RESERVED4 = 64,
};
pub const MSHLFLAGS_NORMAL = MSHLFLAGS.NORMAL;
pub const MSHLFLAGS_TABLESTRONG = MSHLFLAGS.TABLESTRONG;
pub const MSHLFLAGS_TABLEWEAK = MSHLFLAGS.TABLEWEAK;
pub const MSHLFLAGS_NOPING = MSHLFLAGS.NOPING;
pub const MSHLFLAGS_RESERVED1 = MSHLFLAGS.RESERVED1;
pub const MSHLFLAGS_RESERVED2 = MSHLFLAGS.RESERVED2;
pub const MSHLFLAGS_RESERVED3 = MSHLFLAGS.RESERVED3;
pub const MSHLFLAGS_RESERVED4 = MSHLFLAGS.RESERVED4;

pub const MSHCTX = enum(i32) {
    LOCAL = 0,
    NOSHAREDMEM = 1,
    DIFFERENTMACHINE = 2,
    INPROC = 3,
    CROSSCTX = 4,
    CONTAINER = 5,
};
pub const MSHCTX_LOCAL = MSHCTX.LOCAL;
pub const MSHCTX_NOSHAREDMEM = MSHCTX.NOSHAREDMEM;
pub const MSHCTX_DIFFERENTMACHINE = MSHCTX.DIFFERENTMACHINE;
pub const MSHCTX_INPROC = MSHCTX.INPROC;
pub const MSHCTX_CROSSCTX = MSHCTX.CROSSCTX;
pub const MSHCTX_CONTAINER = MSHCTX.CONTAINER;

pub const BYTE_BLOB = extern struct {
    clSize: u32,
    abData: [1]u8,
};

pub const WORD_BLOB = extern struct {
    clSize: u32,
    asData: [1]u16,
};

pub const DWORD_BLOB = extern struct {
    clSize: u32,
    alData: [1]u32,
};

pub const FLAGGED_BYTE_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    abData: [1]u8,
};

pub const FLAGGED_WORD_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    asData: [1]u16,
};

pub const BYTE_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u8,
};

pub const SHORT_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u16,
};

pub const LONG_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u32,
};

pub const HYPER_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*i64,
};

pub const BLOB = extern struct {
    cbSize: u32,
    pBlobData: ?*u8,
};

pub const IEnumContextProps = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const IContext = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IUnknown_Value = @import("../zig.zig").Guid.initString("00000000-0000-0000-c000-000000000046");
pub const IID_IUnknown = &IID_IUnknown_Value;
pub const IUnknown = extern struct {
    pub const VTable = extern struct {
        QueryInterface: fn(
            self: *const IUnknown,
            riid: ?*const Guid,
            ppvObject: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRef: fn(
            self: *const IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Release: fn(
            self: *const IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUnknown_QueryInterface(self: *const T, riid: ?*const Guid, ppvObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUnknown.VTable, self.vtable).QueryInterface(@ptrCast(*const IUnknown, self), riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUnknown_AddRef(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IUnknown.VTable, self.vtable).AddRef(@ptrCast(*const IUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUnknown_Release(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IUnknown.VTable, self.vtable).Release(@ptrCast(*const IUnknown, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIUnknown_Value = @import("../zig.zig").Guid.initString("000e0000-0000-0000-c000-000000000046");
pub const IID_AsyncIUnknown = &IID_AsyncIUnknown_Value;
pub const AsyncIUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_QueryInterface: fn(
            self: *const AsyncIUnknown,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_QueryInterface: fn(
            self: *const AsyncIUnknown,
            ppvObject: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_AddRef: fn(
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_AddRef: fn(
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Begin_Release: fn(
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Release: fn(
            self: *const AsyncIUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Begin_QueryInterface(self: *const T, riid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Begin_QueryInterface(@ptrCast(*const AsyncIUnknown, self), riid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Finish_QueryInterface(self: *const T, ppvObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Finish_QueryInterface(@ptrCast(*const AsyncIUnknown, self), ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Begin_AddRef(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Begin_AddRef(@ptrCast(*const AsyncIUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Finish_AddRef(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Finish_AddRef(@ptrCast(*const AsyncIUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Begin_Release(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Begin_Release(@ptrCast(*const AsyncIUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIUnknown_Finish_Release(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const AsyncIUnknown.VTable, self.vtable).Finish_Release(@ptrCast(*const AsyncIUnknown, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassFactory_Value = @import("../zig.zig").Guid.initString("00000001-0000-0000-c000-000000000046");
pub const IID_IClassFactory = &IID_IClassFactory_Value;
pub const IClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: fn(
            self: *const IClassFactory,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppvObject: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockServer: fn(
            self: *const IClassFactory,
            fLock: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClassFactory_CreateInstance(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppvObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClassFactory.VTable, self.vtable).CreateInstance(@ptrCast(*const IClassFactory, self), pUnkOuter, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClassFactory_LockServer(self: *const T, fLock: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClassFactory.VTable, self.vtable).LockServer(@ptrCast(*const IClassFactory, self), fLock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COSERVERINFO = extern struct {
    dwReserved1: u32,
    pwszName: ?PWSTR,
    pAuthInfo: ?*COAUTHINFO,
    dwReserved2: u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INoMarshal_Value = @import("../zig.zig").Guid.initString("ecc8691b-c1db-4dc0-855e-65f6c551af49");
pub const IID_INoMarshal = &IID_INoMarshal_Value;
pub const INoMarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAgileObject_Value = @import("../zig.zig").Guid.initString("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90");
pub const IID_IAgileObject = &IID_IAgileObject_Value;
pub const IAgileObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActivationFilter_Value = @import("../zig.zig").Guid.initString("00000017-0000-0000-c000-000000000046");
pub const IID_IActivationFilter = &IID_IActivationFilter_Value;
pub const IActivationFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleActivation: fn(
            self: *const IActivationFilter,
            dwActivationType: u32,
            rclsid: ?*const Guid,
            pReplacementClsId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActivationFilter_HandleActivation(self: *const T, dwActivationType: u32, rclsid: ?*const Guid, pReplacementClsId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActivationFilter.VTable, self.vtable).HandleActivation(@ptrCast(*const IActivationFilter, self), dwActivationType, rclsid, pReplacementClsId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMalloc_Value = @import("../zig.zig").Guid.initString("00000002-0000-0000-c000-000000000046");
pub const IID_IMalloc = &IID_IMalloc_Value;
pub const IMalloc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Alloc: fn(
            self: *const IMalloc,
            cb: usize,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        Realloc: fn(
            self: *const IMalloc,
            pv: ?*anyopaque,
            cb: usize,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        Free: fn(
            self: *const IMalloc,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetSize: fn(
            self: *const IMalloc,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        DidAlloc: fn(
            self: *const IMalloc,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        HeapMinimize: fn(
            self: *const IMalloc,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_Alloc(self: *const T, cb: usize) callconv(.Inline) ?*anyopaque {
            return @ptrCast(*const IMalloc.VTable, self.vtable).Alloc(@ptrCast(*const IMalloc, self), cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_Realloc(self: *const T, pv: ?*anyopaque, cb: usize) callconv(.Inline) ?*anyopaque {
            return @ptrCast(*const IMalloc.VTable, self.vtable).Realloc(@ptrCast(*const IMalloc, self), pv, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_Free(self: *const T, pv: ?*anyopaque) callconv(.Inline) void {
            return @ptrCast(*const IMalloc.VTable, self.vtable).Free(@ptrCast(*const IMalloc, self), pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_GetSize(self: *const T, pv: ?*anyopaque) callconv(.Inline) usize {
            return @ptrCast(*const IMalloc.VTable, self.vtable).GetSize(@ptrCast(*const IMalloc, self), pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_DidAlloc(self: *const T, pv: ?*anyopaque) callconv(.Inline) i32 {
            return @ptrCast(*const IMalloc.VTable, self.vtable).DidAlloc(@ptrCast(*const IMalloc, self), pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMalloc_HeapMinimize(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMalloc.VTable, self.vtable).HeapMinimize(@ptrCast(*const IMalloc, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStdMarshalInfo_Value = @import("../zig.zig").Guid.initString("00000018-0000-0000-c000-000000000046");
pub const IID_IStdMarshalInfo = &IID_IStdMarshalInfo_Value;
pub const IStdMarshalInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassForHandler: fn(
            self: *const IStdMarshalInfo,
            dwDestContext: u32,
            pvDestContext: ?*anyopaque,
            pClsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStdMarshalInfo_GetClassForHandler(self: *const T, dwDestContext: u32, pvDestContext: ?*anyopaque, pClsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStdMarshalInfo.VTable, self.vtable).GetClassForHandler(@ptrCast(*const IStdMarshalInfo, self), dwDestContext, pvDestContext, pClsid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EXTCONN = enum(i32) {
    STRONG = 1,
    WEAK = 2,
    CALLABLE = 4,
};
pub const EXTCONN_STRONG = EXTCONN.STRONG;
pub const EXTCONN_WEAK = EXTCONN.WEAK;
pub const EXTCONN_CALLABLE = EXTCONN.CALLABLE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IExternalConnection_Value = @import("../zig.zig").Guid.initString("00000019-0000-0000-c000-000000000046");
pub const IID_IExternalConnection = &IID_IExternalConnection_Value;
pub const IExternalConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddConnection: fn(
            self: *const IExternalConnection,
            extconn: u32,
            reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        ReleaseConnection: fn(
            self: *const IExternalConnection,
            extconn: u32,
            reserved: u32,
            fLastReleaseCloses: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExternalConnection_AddConnection(self: *const T, extconn: u32, reserved: u32) callconv(.Inline) u32 {
            return @ptrCast(*const IExternalConnection.VTable, self.vtable).AddConnection(@ptrCast(*const IExternalConnection, self), extconn, reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExternalConnection_ReleaseConnection(self: *const T, extconn: u32, reserved: u32, fLastReleaseCloses: BOOL) callconv(.Inline) u32 {
            return @ptrCast(*const IExternalConnection.VTable, self.vtable).ReleaseConnection(@ptrCast(*const IExternalConnection, self), extconn, reserved, fLastReleaseCloses);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MULTI_QI = extern struct {
    pIID: ?*const Guid,
    pItf: ?*IUnknown,
    hr: HRESULT,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMultiQI_Value = @import("../zig.zig").Guid.initString("00000020-0000-0000-c000-000000000046");
pub const IID_IMultiQI = &IID_IMultiQI_Value;
pub const IMultiQI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryMultipleInterfaces: fn(
            self: *const IMultiQI,
            cMQIs: u32,
            pMQIs: [*]MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiQI_QueryMultipleInterfaces(self: *const T, cMQIs: u32, pMQIs: [*]MULTI_QI) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultiQI.VTable, self.vtable).QueryMultipleInterfaces(@ptrCast(*const IMultiQI, self), cMQIs, pMQIs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIMultiQI_Value = @import("../zig.zig").Guid.initString("000e0020-0000-0000-c000-000000000046");
pub const IID_AsyncIMultiQI = &IID_AsyncIMultiQI_Value;
pub const AsyncIMultiQI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_QueryMultipleInterfaces: fn(
            self: *const AsyncIMultiQI,
            cMQIs: u32,
            pMQIs: [*]MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_QueryMultipleInterfaces: fn(
            self: *const AsyncIMultiQI,
            pMQIs: ?*MULTI_QI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIMultiQI_Begin_QueryMultipleInterfaces(self: *const T, cMQIs: u32, pMQIs: [*]MULTI_QI) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIMultiQI.VTable, self.vtable).Begin_QueryMultipleInterfaces(@ptrCast(*const AsyncIMultiQI, self), cMQIs, pMQIs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIMultiQI_Finish_QueryMultipleInterfaces(self: *const T, pMQIs: ?*MULTI_QI) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIMultiQI.VTable, self.vtable).Finish_QueryMultipleInterfaces(@ptrCast(*const AsyncIMultiQI, self), pMQIs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IInternalUnknown_Value = @import("../zig.zig").Guid.initString("00000021-0000-0000-c000-000000000046");
pub const IID_IInternalUnknown = &IID_IInternalUnknown_Value;
pub const IInternalUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryInternalInterface: fn(
            self: *const IInternalUnknown,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternalUnknown_QueryInternalInterface(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternalUnknown.VTable, self.vtable).QueryInternalInterface(@ptrCast(*const IInternalUnknown, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumUnknown_Value = @import("../zig.zig").Guid.initString("00000100-0000-0000-c000-000000000046");
pub const IID_IEnumUnknown = &IID_IEnumUnknown_Value;
pub const IEnumUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumUnknown,
            celt: u32,
            rgelt: [*]?*IUnknown,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumUnknown,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumUnknown,
            ppenum: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumUnknown_Next(self: *const T, celt: u32, rgelt: [*]?*IUnknown, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumUnknown.VTable, self.vtable).Next(@ptrCast(*const IEnumUnknown, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumUnknown_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumUnknown.VTable, self.vtable).Skip(@ptrCast(*const IEnumUnknown, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumUnknown_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumUnknown.VTable, self.vtable).Reset(@ptrCast(*const IEnumUnknown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumUnknown_Clone(self: *const T, ppenum: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumUnknown.VTable, self.vtable).Clone(@ptrCast(*const IEnumUnknown, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumString_Value = @import("../zig.zig").Guid.initString("00000101-0000-0000-c000-000000000046");
pub const IID_IEnumString = &IID_IEnumString_Value;
pub const IEnumString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumString,
            celt: u32,
            rgelt: [*]?PWSTR,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumString,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumString,
            ppenum: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumString_Next(self: *const T, celt: u32, rgelt: [*]?PWSTR, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumString.VTable, self.vtable).Next(@ptrCast(*const IEnumString, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumString_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumString.VTable, self.vtable).Skip(@ptrCast(*const IEnumString, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumString_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumString.VTable, self.vtable).Reset(@ptrCast(*const IEnumString, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumString_Clone(self: *const T, ppenum: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumString.VTable, self.vtable).Clone(@ptrCast(*const IEnumString, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISequentialStream_Value = @import("../zig.zig").Guid.initString("0c733a30-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISequentialStream = &IID_ISequentialStream_Value;
pub const ISequentialStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: fn(
            self: *const ISequentialStream,
            // TODO: what to do with BytesParamIndex 1?
            pv: ?*anyopaque,
            cb: u32,
            pcbRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const ISequentialStream,
            // TODO: what to do with BytesParamIndex 1?
            pv: ?*const anyopaque,
            cb: u32,
            pcbWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISequentialStream_Read(self: *const T, pv: ?*anyopaque, cb: u32, pcbRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISequentialStream.VTable, self.vtable).Read(@ptrCast(*const ISequentialStream, self), pv, cb, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISequentialStream_Write(self: *const T, pv: ?*const anyopaque, cb: u32, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISequentialStream.VTable, self.vtable).Write(@ptrCast(*const ISequentialStream, self), pv, cb, pcbWritten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STATSTG = extern struct {
    pwcsName: ?PWSTR,
    type: u32,
    cbSize: ULARGE_INTEGER,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    grfMode: u32,
    grfLocksSupported: u32,
    clsid: Guid,
    grfStateBits: u32,
    reserved: u32,
};

pub const STGTY = enum(i32) {
    STORAGE = 1,
    STREAM = 2,
    LOCKBYTES = 3,
    PROPERTY = 4,
};
pub const STGTY_STORAGE = STGTY.STORAGE;
pub const STGTY_STREAM = STGTY.STREAM;
pub const STGTY_LOCKBYTES = STGTY.LOCKBYTES;
pub const STGTY_PROPERTY = STGTY.PROPERTY;

pub const STREAM_SEEK = enum(u32) {
    SET = 0,
    CUR = 1,
    END = 2,
};
pub const STREAM_SEEK_SET = STREAM_SEEK.SET;
pub const STREAM_SEEK_CUR = STREAM_SEEK.CUR;
pub const STREAM_SEEK_END = STREAM_SEEK.END;

// TODO: this type is limited to platform 'windows5.0'
const IID_IStream_Value = @import("../zig.zig").Guid.initString("0000000c-0000-0000-c000-000000000046");
pub const IID_IStream = &IID_IStream_Value;
pub const IStream = extern struct {
    pub const VTable = extern struct {
        base: ISequentialStream.VTable,
        Seek: fn(
            self: *const IStream,
            dlibMove: LARGE_INTEGER,
            dwOrigin: STREAM_SEEK,
            plibNewPosition: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: fn(
            self: *const IStream,
            libNewSize: ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTo: fn(
            self: *const IStream,
            pstm: ?*IStream,
            cb: ULARGE_INTEGER,
            pcbRead: ?*ULARGE_INTEGER,
            pcbWritten: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IStream,
            grfCommitFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revert: fn(
            self: *const IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockRegion: fn(
            self: *const IStream,
            libOffset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dwLockType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockRegion: fn(
            self: *const IStream,
            libOffset: ULARGE_INTEGER,
            cb: ULARGE_INTEGER,
            dwLockType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stat: fn(
            self: *const IStream,
            pstatstg: ?*STATSTG,
            grfStatFlag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IStream,
            ppstm: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISequentialStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Seek(self: *const T, dlibMove: LARGE_INTEGER, dwOrigin: STREAM_SEEK, plibNewPosition: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Seek(@ptrCast(*const IStream, self), dlibMove, dwOrigin, plibNewPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_SetSize(self: *const T, libNewSize: ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).SetSize(@ptrCast(*const IStream, self), libNewSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_CopyTo(self: *const T, pstm: ?*IStream, cb: ULARGE_INTEGER, pcbRead: ?*ULARGE_INTEGER, pcbWritten: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).CopyTo(@ptrCast(*const IStream, self), pstm, cb, pcbRead, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Commit(self: *const T, grfCommitFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Commit(@ptrCast(*const IStream, self), grfCommitFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Revert(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Revert(@ptrCast(*const IStream, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_LockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).LockRegion(@ptrCast(*const IStream, self), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_UnlockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).UnlockRegion(@ptrCast(*const IStream, self), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Stat(self: *const T, pstatstg: ?*STATSTG, grfStatFlag: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Stat(@ptrCast(*const IStream, self), pstatstg, grfStatFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStream_Clone(self: *const T, ppstm: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStream.VTable, self.vtable).Clone(@ptrCast(*const IStream, self), ppstm);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RPCOLEMESSAGE = extern struct {
    reserved1: ?*anyopaque,
    dataRepresentation: u32,
    Buffer: ?*anyopaque,
    cbBuffer: u32,
    iMethod: u32,
    reserved2: [5]?*anyopaque,
    rpcFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcChannelBuffer_Value = @import("../zig.zig").Guid.initString("d5f56b60-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcChannelBuffer = &IID_IRpcChannelBuffer_Value;
pub const IRpcChannelBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: fn(
            self: *const IRpcChannelBuffer,
            pMessage: ?*RPCOLEMESSAGE,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendReceive: fn(
            self: *const IRpcChannelBuffer,
            pMessage: ?*RPCOLEMESSAGE,
            pStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: fn(
            self: *const IRpcChannelBuffer,
            pMessage: ?*RPCOLEMESSAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestCtx: fn(
            self: *const IRpcChannelBuffer,
            pdwDestContext: ?*u32,
            ppvDestContext: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConnected: fn(
            self: *const IRpcChannelBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_GetBuffer(self: *const T, pMessage: ?*RPCOLEMESSAGE, riid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).GetBuffer(@ptrCast(*const IRpcChannelBuffer, self), pMessage, riid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_SendReceive(self: *const T, pMessage: ?*RPCOLEMESSAGE, pStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).SendReceive(@ptrCast(*const IRpcChannelBuffer, self), pMessage, pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_FreeBuffer(self: *const T, pMessage: ?*RPCOLEMESSAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).FreeBuffer(@ptrCast(*const IRpcChannelBuffer, self), pMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_GetDestCtx(self: *const T, pdwDestContext: ?*u32, ppvDestContext: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).GetDestCtx(@ptrCast(*const IRpcChannelBuffer, self), pdwDestContext, ppvDestContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer_IsConnected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer.VTable, self.vtable).IsConnected(@ptrCast(*const IRpcChannelBuffer, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcChannelBuffer2_Value = @import("../zig.zig").Guid.initString("594f31d0-7f19-11d0-b194-00a0c90dc8bf");
pub const IID_IRpcChannelBuffer2 = &IID_IRpcChannelBuffer2_Value;
pub const IRpcChannelBuffer2 = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer.VTable,
        GetProtocolVersion: fn(
            self: *const IRpcChannelBuffer2,
            pdwVersion: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRpcChannelBuffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer2_GetProtocolVersion(self: *const T, pdwVersion: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer2.VTable, self.vtable).GetProtocolVersion(@ptrCast(*const IRpcChannelBuffer2, self), pdwVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAsyncRpcChannelBuffer_Value = @import("../zig.zig").Guid.initString("a5029fb6-3c34-11d1-9c99-00c04fb998aa");
pub const IID_IAsyncRpcChannelBuffer = &IID_IAsyncRpcChannelBuffer_Value;
pub const IAsyncRpcChannelBuffer = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer2.VTable,
        Send: fn(
            self: *const IAsyncRpcChannelBuffer,
            pMsg: ?*RPCOLEMESSAGE,
            pSync: ?*ISynchronize,
            pulStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Receive: fn(
            self: *const IAsyncRpcChannelBuffer,
            pMsg: ?*RPCOLEMESSAGE,
            pulStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestCtxEx: fn(
            self: *const IAsyncRpcChannelBuffer,
            pMsg: ?*RPCOLEMESSAGE,
            pdwDestContext: ?*u32,
            ppvDestContext: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRpcChannelBuffer2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncRpcChannelBuffer_Send(self: *const T, pMsg: ?*RPCOLEMESSAGE, pSync: ?*ISynchronize, pulStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncRpcChannelBuffer.VTable, self.vtable).Send(@ptrCast(*const IAsyncRpcChannelBuffer, self), pMsg, pSync, pulStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncRpcChannelBuffer_Receive(self: *const T, pMsg: ?*RPCOLEMESSAGE, pulStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncRpcChannelBuffer.VTable, self.vtable).Receive(@ptrCast(*const IAsyncRpcChannelBuffer, self), pMsg, pulStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncRpcChannelBuffer_GetDestCtxEx(self: *const T, pMsg: ?*RPCOLEMESSAGE, pdwDestContext: ?*u32, ppvDestContext: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncRpcChannelBuffer.VTable, self.vtable).GetDestCtxEx(@ptrCast(*const IAsyncRpcChannelBuffer, self), pMsg, pdwDestContext, ppvDestContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcChannelBuffer3_Value = @import("../zig.zig").Guid.initString("25b15600-0115-11d0-bf0d-00aa00b8dfd2");
pub const IID_IRpcChannelBuffer3 = &IID_IRpcChannelBuffer3_Value;
pub const IRpcChannelBuffer3 = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer2.VTable,
        Send: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            pulStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Receive: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            ulSize: u32,
            pulStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallContext: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            riid: ?*const Guid,
            pInterface: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDestCtxEx: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            pdwDestContext: ?*u32,
            ppvDestContext: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            pState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterAsync: fn(
            self: *const IRpcChannelBuffer3,
            pMsg: ?*RPCOLEMESSAGE,
            pAsyncMgr: ?*IAsyncManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRpcChannelBuffer2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_Send(self: *const T, pMsg: ?*RPCOLEMESSAGE, pulStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).Send(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, pulStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_Receive(self: *const T, pMsg: ?*RPCOLEMESSAGE, ulSize: u32, pulStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).Receive(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, ulSize, pulStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_Cancel(self: *const T, pMsg: ?*RPCOLEMESSAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).Cancel(@ptrCast(*const IRpcChannelBuffer3, self), pMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_GetCallContext(self: *const T, pMsg: ?*RPCOLEMESSAGE, riid: ?*const Guid, pInterface: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).GetCallContext(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, riid, pInterface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_GetDestCtxEx(self: *const T, pMsg: ?*RPCOLEMESSAGE, pdwDestContext: ?*u32, ppvDestContext: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).GetDestCtxEx(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, pdwDestContext, ppvDestContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_GetState(self: *const T, pMsg: ?*RPCOLEMESSAGE, pState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).GetState(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcChannelBuffer3_RegisterAsync(self: *const T, pMsg: ?*RPCOLEMESSAGE, pAsyncMgr: ?*IAsyncManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcChannelBuffer3.VTable, self.vtable).RegisterAsync(@ptrCast(*const IRpcChannelBuffer3, self), pMsg, pAsyncMgr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcSyntaxNegotiate_Value = @import("../zig.zig").Guid.initString("58a08519-24c8-4935-b482-3fd823333a4f");
pub const IID_IRpcSyntaxNegotiate = &IID_IRpcSyntaxNegotiate_Value;
pub const IRpcSyntaxNegotiate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NegotiateSyntax: fn(
            self: *const IRpcSyntaxNegotiate,
            pMsg: ?*RPCOLEMESSAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcSyntaxNegotiate_NegotiateSyntax(self: *const T, pMsg: ?*RPCOLEMESSAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcSyntaxNegotiate.VTable, self.vtable).NegotiateSyntax(@ptrCast(*const IRpcSyntaxNegotiate, self), pMsg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcProxyBuffer_Value = @import("../zig.zig").Guid.initString("d5f56a34-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcProxyBuffer = &IID_IRpcProxyBuffer_Value;
pub const IRpcProxyBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: fn(
            self: *const IRpcProxyBuffer,
            pRpcChannelBuffer: ?*IRpcChannelBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IRpcProxyBuffer,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcProxyBuffer_Connect(self: *const T, pRpcChannelBuffer: ?*IRpcChannelBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcProxyBuffer.VTable, self.vtable).Connect(@ptrCast(*const IRpcProxyBuffer, self), pRpcChannelBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcProxyBuffer_Disconnect(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IRpcProxyBuffer.VTable, self.vtable).Disconnect(@ptrCast(*const IRpcProxyBuffer, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcStubBuffer_Value = @import("../zig.zig").Guid.initString("d5f56afc-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcStubBuffer = &IID_IRpcStubBuffer_Value;
pub const IRpcStubBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: fn(
            self: *const IRpcStubBuffer,
            pUnkServer: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Invoke: fn(
            self: *const IRpcStubBuffer,
            _prpcmsg: ?*RPCOLEMESSAGE,
            _pRpcChannelBuffer: ?*IRpcChannelBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIIDSupported: fn(
            self: *const IRpcStubBuffer,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) ?*IRpcStubBuffer,
        CountRefs: fn(
            self: *const IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        DebugServerQueryInterface: fn(
            self: *const IRpcStubBuffer,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DebugServerRelease: fn(
            self: *const IRpcStubBuffer,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_Connect(self: *const T, pUnkServer: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).Connect(@ptrCast(*const IRpcStubBuffer, self), pUnkServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_Disconnect(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).Disconnect(@ptrCast(*const IRpcStubBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_Invoke(self: *const T, _prpcmsg: ?*RPCOLEMESSAGE, _pRpcChannelBuffer: ?*IRpcChannelBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).Invoke(@ptrCast(*const IRpcStubBuffer, self), _prpcmsg, _pRpcChannelBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_IsIIDSupported(self: *const T, riid: ?*const Guid) callconv(.Inline) ?*IRpcStubBuffer {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).IsIIDSupported(@ptrCast(*const IRpcStubBuffer, self), riid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_CountRefs(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).CountRefs(@ptrCast(*const IRpcStubBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_DebugServerQueryInterface(self: *const T, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).DebugServerQueryInterface(@ptrCast(*const IRpcStubBuffer, self), ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcStubBuffer_DebugServerRelease(self: *const T, pv: ?*anyopaque) callconv(.Inline) void {
            return @ptrCast(*const IRpcStubBuffer.VTable, self.vtable).DebugServerRelease(@ptrCast(*const IRpcStubBuffer, self), pv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPSFactoryBuffer_Value = @import("../zig.zig").Guid.initString("d5f569d0-593b-101a-b569-08002b2dbf7a");
pub const IID_IPSFactoryBuffer = &IID_IPSFactoryBuffer_Value;
pub const IPSFactoryBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProxy: fn(
            self: *const IPSFactoryBuffer,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppProxy: ?*?*IRpcProxyBuffer,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStub: fn(
            self: *const IPSFactoryBuffer,
            riid: ?*const Guid,
            pUnkServer: ?*IUnknown,
            ppStub: ?*?*IRpcStubBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPSFactoryBuffer_CreateProxy(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppProxy: ?*?*IRpcProxyBuffer, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPSFactoryBuffer.VTable, self.vtable).CreateProxy(@ptrCast(*const IPSFactoryBuffer, self), pUnkOuter, riid, ppProxy, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPSFactoryBuffer_CreateStub(self: *const T, riid: ?*const Guid, pUnkServer: ?*IUnknown, ppStub: ?*?*IRpcStubBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPSFactoryBuffer.VTable, self.vtable).CreateStub(@ptrCast(*const IPSFactoryBuffer, self), riid, pUnkServer, ppStub);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SChannelHookCallInfo = extern struct {
    iid: Guid,
    cbSize: u32,
    uCausality: Guid,
    dwServerPid: u32,
    iMethod: u32,
    pObject: ?*anyopaque,
};

const IID_IChannelHook_Value = @import("../zig.zig").Guid.initString("1008c4a0-7613-11cf-9af1-0020af6e72f4");
pub const IID_IChannelHook = &IID_IChannelHook_Value;
pub const IChannelHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ClientGetSize: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            pDataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ClientFillBuffer: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            pDataSize: ?*u32,
            pDataBuffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ClientNotify: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            cbDataSize: u32,
            pDataBuffer: ?*anyopaque,
            lDataRep: u32,
            hrFault: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ServerNotify: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            cbDataSize: u32,
            pDataBuffer: ?*anyopaque,
            lDataRep: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ServerGetSize: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            hrFault: HRESULT,
            pDataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ServerFillBuffer: fn(
            self: *const IChannelHook,
            uExtent: ?*const Guid,
            riid: ?*const Guid,
            pDataSize: ?*u32,
            pDataBuffer: ?*anyopaque,
            hrFault: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ClientGetSize(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, pDataSize: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ClientGetSize(@ptrCast(*const IChannelHook, self), uExtent, riid, pDataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ClientFillBuffer(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, pDataSize: ?*u32, pDataBuffer: ?*anyopaque) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ClientFillBuffer(@ptrCast(*const IChannelHook, self), uExtent, riid, pDataSize, pDataBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ClientNotify(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, cbDataSize: u32, pDataBuffer: ?*anyopaque, lDataRep: u32, hrFault: HRESULT) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ClientNotify(@ptrCast(*const IChannelHook, self), uExtent, riid, cbDataSize, pDataBuffer, lDataRep, hrFault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ServerNotify(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, cbDataSize: u32, pDataBuffer: ?*anyopaque, lDataRep: u32) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ServerNotify(@ptrCast(*const IChannelHook, self), uExtent, riid, cbDataSize, pDataBuffer, lDataRep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ServerGetSize(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, hrFault: HRESULT, pDataSize: ?*u32) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ServerGetSize(@ptrCast(*const IChannelHook, self), uExtent, riid, hrFault, pDataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelHook_ServerFillBuffer(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, pDataSize: ?*u32, pDataBuffer: ?*anyopaque, hrFault: HRESULT) callconv(.Inline) void {
            return @ptrCast(*const IChannelHook.VTable, self.vtable).ServerFillBuffer(@ptrCast(*const IChannelHook, self), uExtent, riid, pDataSize, pDataBuffer, hrFault);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SOLE_AUTHENTICATION_SERVICE = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pPrincipalName: ?PWSTR,
    hr: HRESULT,
};

pub const EOLE_AUTHENTICATION_CAPABILITIES = enum(i32) {
    NONE = 0,
    MUTUAL_AUTH = 1,
    STATIC_CLOAKING = 32,
    DYNAMIC_CLOAKING = 64,
    ANY_AUTHORITY = 128,
    MAKE_FULLSIC = 256,
    DEFAULT = 2048,
    SECURE_REFS = 2,
    ACCESS_CONTROL = 4,
    APPID = 8,
    DYNAMIC = 16,
    REQUIRE_FULLSIC = 512,
    AUTO_IMPERSONATE = 1024,
    DISABLE_AAA = 4096,
    NO_CUSTOM_MARSHAL = 8192,
    RESERVED1 = 16384,
};
pub const EOAC_NONE = EOLE_AUTHENTICATION_CAPABILITIES.NONE;
pub const EOAC_MUTUAL_AUTH = EOLE_AUTHENTICATION_CAPABILITIES.MUTUAL_AUTH;
pub const EOAC_STATIC_CLOAKING = EOLE_AUTHENTICATION_CAPABILITIES.STATIC_CLOAKING;
pub const EOAC_DYNAMIC_CLOAKING = EOLE_AUTHENTICATION_CAPABILITIES.DYNAMIC_CLOAKING;
pub const EOAC_ANY_AUTHORITY = EOLE_AUTHENTICATION_CAPABILITIES.ANY_AUTHORITY;
pub const EOAC_MAKE_FULLSIC = EOLE_AUTHENTICATION_CAPABILITIES.MAKE_FULLSIC;
pub const EOAC_DEFAULT = EOLE_AUTHENTICATION_CAPABILITIES.DEFAULT;
pub const EOAC_SECURE_REFS = EOLE_AUTHENTICATION_CAPABILITIES.SECURE_REFS;
pub const EOAC_ACCESS_CONTROL = EOLE_AUTHENTICATION_CAPABILITIES.ACCESS_CONTROL;
pub const EOAC_APPID = EOLE_AUTHENTICATION_CAPABILITIES.APPID;
pub const EOAC_DYNAMIC = EOLE_AUTHENTICATION_CAPABILITIES.DYNAMIC;
pub const EOAC_REQUIRE_FULLSIC = EOLE_AUTHENTICATION_CAPABILITIES.REQUIRE_FULLSIC;
pub const EOAC_AUTO_IMPERSONATE = EOLE_AUTHENTICATION_CAPABILITIES.AUTO_IMPERSONATE;
pub const EOAC_DISABLE_AAA = EOLE_AUTHENTICATION_CAPABILITIES.DISABLE_AAA;
pub const EOAC_NO_CUSTOM_MARSHAL = EOLE_AUTHENTICATION_CAPABILITIES.NO_CUSTOM_MARSHAL;
pub const EOAC_RESERVED1 = EOLE_AUTHENTICATION_CAPABILITIES.RESERVED1;

pub const SOLE_AUTHENTICATION_INFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pAuthInfo: ?*anyopaque,
};

pub const SOLE_AUTHENTICATION_LIST = extern struct {
    cAuthInfo: u32,
    aAuthInfo: ?*SOLE_AUTHENTICATION_INFO,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClientSecurity_Value = @import("../zig.zig").Guid.initString("0000013d-0000-0000-c000-000000000046");
pub const IID_IClientSecurity = &IID_IClientSecurity_Value;
pub const IClientSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryBlanket: fn(
            self: *const IClientSecurity,
            pProxy: ?*IUnknown,
            pAuthnSvc: ?*u32,
            pAuthzSvc: ?*u32,
            pServerPrincName: ?*?*u16,
            pAuthnLevel: ?*RPC_C_AUTHN_LEVEL,
            pImpLevel: ?*RPC_C_IMP_LEVEL,
            pAuthInfo: ?*?*anyopaque,
            pCapabilites: ?*EOLE_AUTHENTICATION_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBlanket: fn(
            self: *const IClientSecurity,
            pProxy: ?*IUnknown,
            dwAuthnSvc: u32,
            dwAuthzSvc: u32,
            pServerPrincName: ?PWSTR,
            dwAuthnLevel: RPC_C_AUTHN_LEVEL,
            dwImpLevel: RPC_C_IMP_LEVEL,
            pAuthInfo: ?*anyopaque,
            dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyProxy: fn(
            self: *const IClientSecurity,
            pProxy: ?*IUnknown,
            ppCopy: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientSecurity_QueryBlanket(self: *const T, pProxy: ?*IUnknown, pAuthnSvc: ?*u32, pAuthzSvc: ?*u32, pServerPrincName: ?*?*u16, pAuthnLevel: ?*RPC_C_AUTHN_LEVEL, pImpLevel: ?*RPC_C_IMP_LEVEL, pAuthInfo: ?*?*anyopaque, pCapabilites: ?*EOLE_AUTHENTICATION_CAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientSecurity.VTable, self.vtable).QueryBlanket(@ptrCast(*const IClientSecurity, self), pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName, pAuthnLevel, pImpLevel, pAuthInfo, pCapabilites);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientSecurity_SetBlanket(self: *const T, pProxy: ?*IUnknown, dwAuthnSvc: u32, dwAuthzSvc: u32, pServerPrincName: ?PWSTR, dwAuthnLevel: RPC_C_AUTHN_LEVEL, dwImpLevel: RPC_C_IMP_LEVEL, pAuthInfo: ?*anyopaque, dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientSecurity.VTable, self.vtable).SetBlanket(@ptrCast(*const IClientSecurity, self), pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientSecurity_CopyProxy(self: *const T, pProxy: ?*IUnknown, ppCopy: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientSecurity.VTable, self.vtable).CopyProxy(@ptrCast(*const IClientSecurity, self), pProxy, ppCopy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IServerSecurity_Value = @import("../zig.zig").Guid.initString("0000013e-0000-0000-c000-000000000046");
pub const IID_IServerSecurity = &IID_IServerSecurity_Value;
pub const IServerSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryBlanket: fn(
            self: *const IServerSecurity,
            pAuthnSvc: ?*u32,
            pAuthzSvc: ?*u32,
            pServerPrincName: ?*?*u16,
            pAuthnLevel: ?*u32,
            pImpLevel: ?*u32,
            pPrivs: ?*?*anyopaque,
            pCapabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImpersonateClient: fn(
            self: *const IServerSecurity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevertToSelf: fn(
            self: *const IServerSecurity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsImpersonating: fn(
            self: *const IServerSecurity,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerSecurity_QueryBlanket(self: *const T, pAuthnSvc: ?*u32, pAuthzSvc: ?*u32, pServerPrincName: ?*?*u16, pAuthnLevel: ?*u32, pImpLevel: ?*u32, pPrivs: ?*?*anyopaque, pCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerSecurity.VTable, self.vtable).QueryBlanket(@ptrCast(*const IServerSecurity, self), pAuthnSvc, pAuthzSvc, pServerPrincName, pAuthnLevel, pImpLevel, pPrivs, pCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerSecurity_ImpersonateClient(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerSecurity.VTable, self.vtable).ImpersonateClient(@ptrCast(*const IServerSecurity, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerSecurity_RevertToSelf(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServerSecurity.VTable, self.vtable).RevertToSelf(@ptrCast(*const IServerSecurity, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerSecurity_IsImpersonating(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IServerSecurity.VTable, self.vtable).IsImpersonating(@ptrCast(*const IServerSecurity, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RPCOPT_PROPERTIES = enum(i32) {
    RPCTIMEOUT = 1,
    SERVER_LOCALITY = 2,
    RESERVED1 = 4,
    RESERVED2 = 5,
    RESERVED3 = 8,
    RESERVED4 = 16,
};
pub const COMBND_RPCTIMEOUT = RPCOPT_PROPERTIES.RPCTIMEOUT;
pub const COMBND_SERVER_LOCALITY = RPCOPT_PROPERTIES.SERVER_LOCALITY;
pub const COMBND_RESERVED1 = RPCOPT_PROPERTIES.RESERVED1;
pub const COMBND_RESERVED2 = RPCOPT_PROPERTIES.RESERVED2;
pub const COMBND_RESERVED3 = RPCOPT_PROPERTIES.RESERVED3;
pub const COMBND_RESERVED4 = RPCOPT_PROPERTIES.RESERVED4;

pub const RPCOPT_SERVER_LOCALITY_VALUES = enum(i32) {
    PROCESS_LOCAL = 0,
    MACHINE_LOCAL = 1,
    REMOTE = 2,
};
pub const SERVER_LOCALITY_PROCESS_LOCAL = RPCOPT_SERVER_LOCALITY_VALUES.PROCESS_LOCAL;
pub const SERVER_LOCALITY_MACHINE_LOCAL = RPCOPT_SERVER_LOCALITY_VALUES.MACHINE_LOCAL;
pub const SERVER_LOCALITY_REMOTE = RPCOPT_SERVER_LOCALITY_VALUES.REMOTE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcOptions_Value = @import("../zig.zig").Guid.initString("00000144-0000-0000-c000-000000000046");
pub const IID_IRpcOptions = &IID_IRpcOptions_Value;
pub const IRpcOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Set: fn(
            self: *const IRpcOptions,
            pPrx: ?*IUnknown,
            dwProperty: RPCOPT_PROPERTIES,
            dwValue: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IRpcOptions,
            pPrx: ?*IUnknown,
            dwProperty: RPCOPT_PROPERTIES,
            pdwValue: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcOptions_Set(self: *const T, pPrx: ?*IUnknown, dwProperty: RPCOPT_PROPERTIES, dwValue: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcOptions.VTable, self.vtable).Set(@ptrCast(*const IRpcOptions, self), pPrx, dwProperty, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcOptions_Query(self: *const T, pPrx: ?*IUnknown, dwProperty: RPCOPT_PROPERTIES, pdwValue: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcOptions.VTable, self.vtable).Query(@ptrCast(*const IRpcOptions, self), pPrx, dwProperty, pdwValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const GLOBALOPT_PROPERTIES = enum(i32) {
    EXCEPTION_HANDLING = 1,
    APPID = 2,
    RPC_THREADPOOL_SETTING = 3,
    RO_SETTINGS = 4,
    UNMARSHALING_POLICY = 5,
    PROPERTIES_RESERVED1 = 6,
    PROPERTIES_RESERVED2 = 7,
    PROPERTIES_RESERVED3 = 8,
};
pub const COMGLB_EXCEPTION_HANDLING = GLOBALOPT_PROPERTIES.EXCEPTION_HANDLING;
pub const COMGLB_APPID = GLOBALOPT_PROPERTIES.APPID;
pub const COMGLB_RPC_THREADPOOL_SETTING = GLOBALOPT_PROPERTIES.RPC_THREADPOOL_SETTING;
pub const COMGLB_RO_SETTINGS = GLOBALOPT_PROPERTIES.RO_SETTINGS;
pub const COMGLB_UNMARSHALING_POLICY = GLOBALOPT_PROPERTIES.UNMARSHALING_POLICY;
pub const COMGLB_PROPERTIES_RESERVED1 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED1;
pub const COMGLB_PROPERTIES_RESERVED2 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED2;
pub const COMGLB_PROPERTIES_RESERVED3 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED3;

pub const GLOBALOPT_EH_VALUES = enum(i32) {
    HANDLE = 0,
    DONOT_HANDLE_FATAL = 1,
    // DONOT_HANDLE = 1, this enum value conflicts with DONOT_HANDLE_FATAL
    DONOT_HANDLE_ANY = 2,
};
pub const COMGLB_EXCEPTION_HANDLE = GLOBALOPT_EH_VALUES.HANDLE;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = GLOBALOPT_EH_VALUES.DONOT_HANDLE_FATAL;
pub const COMGLB_EXCEPTION_DONOT_HANDLE = GLOBALOPT_EH_VALUES.DONOT_HANDLE_FATAL;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_ANY = GLOBALOPT_EH_VALUES.DONOT_HANDLE_ANY;

pub const GLOBALOPT_RPCTP_VALUES = enum(i32) {
    DEFAULT_POOL = 0,
    PRIVATE_POOL = 1,
};
pub const COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = GLOBALOPT_RPCTP_VALUES.DEFAULT_POOL;
pub const COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = GLOBALOPT_RPCTP_VALUES.PRIVATE_POOL;

pub const GLOBALOPT_RO_FLAGS = enum(i32) {
    STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = 1,
    STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = 2,
    STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = 4,
    FAST_RUNDOWN = 8,
    RESERVED1 = 16,
    RESERVED2 = 32,
    RESERVED3 = 64,
    STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = 128,
    RESERVED4 = 256,
    RESERVED5 = 512,
    RESERVED6 = 1024,
};
pub const COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_REMOVE_TOUCH_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES;
pub const COMGLB_FAST_RUNDOWN = GLOBALOPT_RO_FLAGS.FAST_RUNDOWN;
pub const COMGLB_RESERVED1 = GLOBALOPT_RO_FLAGS.RESERVED1;
pub const COMGLB_RESERVED2 = GLOBALOPT_RO_FLAGS.RESERVED2;
pub const COMGLB_RESERVED3 = GLOBALOPT_RO_FLAGS.RESERVED3;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES;
pub const COMGLB_RESERVED4 = GLOBALOPT_RO_FLAGS.RESERVED4;
pub const COMGLB_RESERVED5 = GLOBALOPT_RO_FLAGS.RESERVED5;
pub const COMGLB_RESERVED6 = GLOBALOPT_RO_FLAGS.RESERVED6;

pub const GLOBALOPT_UNMARSHALING_POLICY_VALUES = enum(i32) {
    NORMAL = 0,
    STRONG = 1,
    HYBRID = 2,
};
pub const COMGLB_UNMARSHALING_POLICY_NORMAL = GLOBALOPT_UNMARSHALING_POLICY_VALUES.NORMAL;
pub const COMGLB_UNMARSHALING_POLICY_STRONG = GLOBALOPT_UNMARSHALING_POLICY_VALUES.STRONG;
pub const COMGLB_UNMARSHALING_POLICY_HYBRID = GLOBALOPT_UNMARSHALING_POLICY_VALUES.HYBRID;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IGlobalOptions_Value = @import("../zig.zig").Guid.initString("0000015b-0000-0000-c000-000000000046");
pub const IID_IGlobalOptions = &IID_IGlobalOptions_Value;
pub const IGlobalOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Set: fn(
            self: *const IGlobalOptions,
            dwProperty: GLOBALOPT_PROPERTIES,
            dwValue: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IGlobalOptions,
            dwProperty: GLOBALOPT_PROPERTIES,
            pdwValue: ?*usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalOptions_Set(self: *const T, dwProperty: GLOBALOPT_PROPERTIES, dwValue: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalOptions.VTable, self.vtable).Set(@ptrCast(*const IGlobalOptions, self), dwProperty, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalOptions_Query(self: *const T, dwProperty: GLOBALOPT_PROPERTIES, pdwValue: ?*usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalOptions.VTable, self.vtable).Query(@ptrCast(*const IGlobalOptions, self), dwProperty, pdwValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISurrogate_Value = @import("../zig.zig").Guid.initString("00000022-0000-0000-c000-000000000046");
pub const IID_ISurrogate = &IID_ISurrogate_Value;
pub const ISurrogate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadDllServer: fn(
            self: *const ISurrogate,
            Clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeSurrogate: fn(
            self: *const ISurrogate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogate_LoadDllServer(self: *const T, Clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogate.VTable, self.vtable).LoadDllServer(@ptrCast(*const ISurrogate, self), Clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogate_FreeSurrogate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogate.VTable, self.vtable).FreeSurrogate(@ptrCast(*const ISurrogate, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IGlobalInterfaceTable_Value = @import("../zig.zig").Guid.initString("00000146-0000-0000-c000-000000000046");
pub const IID_IGlobalInterfaceTable = &IID_IGlobalInterfaceTable_Value;
pub const IGlobalInterfaceTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterInterfaceInGlobal: fn(
            self: *const IGlobalInterfaceTable,
            pUnk: ?*IUnknown,
            riid: ?*const Guid,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeInterfaceFromGlobal: fn(
            self: *const IGlobalInterfaceTable,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterfaceFromGlobal: fn(
            self: *const IGlobalInterfaceTable,
            dwCookie: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalInterfaceTable_RegisterInterfaceInGlobal(self: *const T, pUnk: ?*IUnknown, riid: ?*const Guid, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalInterfaceTable.VTable, self.vtable).RegisterInterfaceInGlobal(@ptrCast(*const IGlobalInterfaceTable, self), pUnk, riid, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalInterfaceTable_RevokeInterfaceFromGlobal(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalInterfaceTable.VTable, self.vtable).RevokeInterfaceFromGlobal(@ptrCast(*const IGlobalInterfaceTable, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGlobalInterfaceTable_GetInterfaceFromGlobal(self: *const T, dwCookie: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGlobalInterfaceTable.VTable, self.vtable).GetInterfaceFromGlobal(@ptrCast(*const IGlobalInterfaceTable, self), dwCookie, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronize_Value = @import("../zig.zig").Guid.initString("00000030-0000-0000-c000-000000000046");
pub const IID_ISynchronize = &IID_ISynchronize_Value;
pub const ISynchronize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Wait: fn(
            self: *const ISynchronize,
            dwFlags: u32,
            dwMilliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Signal: fn(
            self: *const ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronize_Wait(self: *const T, dwFlags: u32, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronize.VTable, self.vtable).Wait(@ptrCast(*const ISynchronize, self), dwFlags, dwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronize_Signal(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronize.VTable, self.vtable).Signal(@ptrCast(*const ISynchronize, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronize_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronize.VTable, self.vtable).Reset(@ptrCast(*const ISynchronize, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeHandle_Value = @import("../zig.zig").Guid.initString("00000031-0000-0000-c000-000000000046");
pub const IID_ISynchronizeHandle = &IID_ISynchronizeHandle_Value;
pub const ISynchronizeHandle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHandle: fn(
            self: *const ISynchronizeHandle,
            ph: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeHandle_GetHandle(self: *const T, ph: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeHandle.VTable, self.vtable).GetHandle(@ptrCast(*const ISynchronizeHandle, self), ph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeEvent_Value = @import("../zig.zig").Guid.initString("00000032-0000-0000-c000-000000000046");
pub const IID_ISynchronizeEvent = &IID_ISynchronizeEvent_Value;
pub const ISynchronizeEvent = extern struct {
    pub const VTable = extern struct {
        base: ISynchronizeHandle.VTable,
        SetEventHandle: fn(
            self: *const ISynchronizeEvent,
            ph: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISynchronizeHandle.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeEvent_SetEventHandle(self: *const T, ph: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeEvent.VTable, self.vtable).SetEventHandle(@ptrCast(*const ISynchronizeEvent, self), ph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeContainer_Value = @import("../zig.zig").Guid.initString("00000033-0000-0000-c000-000000000046");
pub const IID_ISynchronizeContainer = &IID_ISynchronizeContainer_Value;
pub const ISynchronizeContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddSynchronize: fn(
            self: *const ISynchronizeContainer,
            pSync: ?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitMultiple: fn(
            self: *const ISynchronizeContainer,
            dwFlags: u32,
            dwTimeOut: u32,
            ppSync: ?*?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeContainer_AddSynchronize(self: *const T, pSync: ?*ISynchronize) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeContainer.VTable, self.vtable).AddSynchronize(@ptrCast(*const ISynchronizeContainer, self), pSync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeContainer_WaitMultiple(self: *const T, dwFlags: u32, dwTimeOut: u32, ppSync: ?*?*ISynchronize) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeContainer.VTable, self.vtable).WaitMultiple(@ptrCast(*const ISynchronizeContainer, self), dwFlags, dwTimeOut, ppSync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISynchronizeMutex_Value = @import("../zig.zig").Guid.initString("00000025-0000-0000-c000-000000000046");
pub const IID_ISynchronizeMutex = &IID_ISynchronizeMutex_Value;
pub const ISynchronizeMutex = extern struct {
    pub const VTable = extern struct {
        base: ISynchronize.VTable,
        ReleaseMutex: fn(
            self: *const ISynchronizeMutex,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISynchronize.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizeMutex_ReleaseMutex(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizeMutex.VTable, self.vtable).ReleaseMutex(@ptrCast(*const ISynchronizeMutex, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICancelMethodCalls_Value = @import("../zig.zig").Guid.initString("00000029-0000-0000-c000-000000000046");
pub const IID_ICancelMethodCalls = &IID_ICancelMethodCalls_Value;
pub const ICancelMethodCalls = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: fn(
            self: *const ICancelMethodCalls,
            ulSeconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestCancel: fn(
            self: *const ICancelMethodCalls,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICancelMethodCalls_Cancel(self: *const T, ulSeconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICancelMethodCalls.VTable, self.vtable).Cancel(@ptrCast(*const ICancelMethodCalls, self), ulSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICancelMethodCalls_TestCancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICancelMethodCalls.VTable, self.vtable).TestCancel(@ptrCast(*const ICancelMethodCalls, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DCOM_CALL_STATE = enum(i32) {
    NONE = 0,
    CALL_COMPLETE = 1,
    CALL_CANCELED = 2,
};
pub const DCOM_NONE = DCOM_CALL_STATE.NONE;
pub const DCOM_CALL_COMPLETE = DCOM_CALL_STATE.CALL_COMPLETE;
pub const DCOM_CALL_CANCELED = DCOM_CALL_STATE.CALL_CANCELED;

const IID_IAsyncManager_Value = @import("../zig.zig").Guid.initString("0000002a-0000-0000-c000-000000000046");
pub const IID_IAsyncManager = &IID_IAsyncManager_Value;
pub const IAsyncManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompleteCall: fn(
            self: *const IAsyncManager,
            Result: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallContext: fn(
            self: *const IAsyncManager,
            riid: ?*const Guid,
            pInterface: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IAsyncManager,
            pulStateFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncManager_CompleteCall(self: *const T, Result: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncManager.VTable, self.vtable).CompleteCall(@ptrCast(*const IAsyncManager, self), Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncManager_GetCallContext(self: *const T, riid: ?*const Guid, pInterface: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncManager.VTable, self.vtable).GetCallContext(@ptrCast(*const IAsyncManager, self), riid, pInterface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncManager_GetState(self: *const T, pulStateFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAsyncManager.VTable, self.vtable).GetState(@ptrCast(*const IAsyncManager, self), pulStateFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFactory_Value = @import("../zig.zig").Guid.initString("1c733a30-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICallFactory = &IID_ICallFactory_Value;
pub const ICallFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCall: fn(
            self: *const ICallFactory,
            riid: ?*const Guid,
            pCtrlUnk: ?*IUnknown,
            riid2: ?*const Guid,
            ppv: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFactory_CreateCall(self: *const T, riid: ?*const Guid, pCtrlUnk: ?*IUnknown, riid2: ?*const Guid, ppv: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFactory.VTable, self.vtable).CreateCall(@ptrCast(*const ICallFactory, self), riid, pCtrlUnk, riid2, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcHelper_Value = @import("../zig.zig").Guid.initString("00000149-0000-0000-c000-000000000046");
pub const IID_IRpcHelper = &IID_IRpcHelper_Value;
pub const IRpcHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDCOMProtocolVersion: fn(
            self: *const IRpcHelper,
            pComVersion: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIIDFromOBJREF: fn(
            self: *const IRpcHelper,
            pObjRef: ?*anyopaque,
            piid: ?*?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcHelper_GetDCOMProtocolVersion(self: *const T, pComVersion: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcHelper.VTable, self.vtable).GetDCOMProtocolVersion(@ptrCast(*const IRpcHelper, self), pComVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRpcHelper_GetIIDFromOBJREF(self: *const T, pObjRef: ?*anyopaque, piid: ?*?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRpcHelper.VTable, self.vtable).GetIIDFromOBJREF(@ptrCast(*const IRpcHelper, self), pObjRef, piid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IReleaseMarshalBuffers_Value = @import("../zig.zig").Guid.initString("eb0cb9e8-7996-11d2-872e-0000f8080859");
pub const IID_IReleaseMarshalBuffers = &IID_IReleaseMarshalBuffers_Value;
pub const IReleaseMarshalBuffers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReleaseMarshalBuffer: fn(
            self: *const IReleaseMarshalBuffers,
            pMsg: ?*RPCOLEMESSAGE,
            dwFlags: u32,
            pChnl: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReleaseMarshalBuffers_ReleaseMarshalBuffer(self: *const T, pMsg: ?*RPCOLEMESSAGE, dwFlags: u32, pChnl: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReleaseMarshalBuffers.VTable, self.vtable).ReleaseMarshalBuffer(@ptrCast(*const IReleaseMarshalBuffers, self), pMsg, dwFlags, pChnl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWaitMultiple_Value = @import("../zig.zig").Guid.initString("0000002b-0000-0000-c000-000000000046");
pub const IID_IWaitMultiple = &IID_IWaitMultiple_Value;
pub const IWaitMultiple = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitMultiple: fn(
            self: *const IWaitMultiple,
            timeout: u32,
            pSync: ?*?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSynchronize: fn(
            self: *const IWaitMultiple,
            pSync: ?*ISynchronize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWaitMultiple_WaitMultiple(self: *const T, timeout: u32, pSync: ?*?*ISynchronize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWaitMultiple.VTable, self.vtable).WaitMultiple(@ptrCast(*const IWaitMultiple, self), timeout, pSync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWaitMultiple_AddSynchronize(self: *const T, pSync: ?*ISynchronize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWaitMultiple.VTable, self.vtable).AddSynchronize(@ptrCast(*const IWaitMultiple, self), pSync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAddrTrackingControl_Value = @import("../zig.zig").Guid.initString("00000147-0000-0000-c000-000000000046");
pub const IID_IAddrTrackingControl = &IID_IAddrTrackingControl_Value;
pub const IAddrTrackingControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableCOMDynamicAddrTracking: fn(
            self: *const IAddrTrackingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableCOMDynamicAddrTracking: fn(
            self: *const IAddrTrackingControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrTrackingControl_EnableCOMDynamicAddrTracking(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrTrackingControl.VTable, self.vtable).EnableCOMDynamicAddrTracking(@ptrCast(*const IAddrTrackingControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrTrackingControl_DisableCOMDynamicAddrTracking(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrTrackingControl.VTable, self.vtable).DisableCOMDynamicAddrTracking(@ptrCast(*const IAddrTrackingControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAddrExclusionControl_Value = @import("../zig.zig").Guid.initString("00000148-0000-0000-c000-000000000046");
pub const IID_IAddrExclusionControl = &IID_IAddrExclusionControl_Value;
pub const IAddrExclusionControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentAddrExclusionList: fn(
            self: *const IAddrExclusionControl,
            riid: ?*const Guid,
            ppEnumerator: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAddrExclusionList: fn(
            self: *const IAddrExclusionControl,
            pEnumerator: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrExclusionControl_GetCurrentAddrExclusionList(self: *const T, riid: ?*const Guid, ppEnumerator: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrExclusionControl.VTable, self.vtable).GetCurrentAddrExclusionList(@ptrCast(*const IAddrExclusionControl, self), riid, ppEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrExclusionControl_UpdateAddrExclusionList(self: *const T, pEnumerator: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrExclusionControl.VTable, self.vtable).UpdateAddrExclusionList(@ptrCast(*const IAddrExclusionControl, self), pEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeByte_Value = @import("../zig.zig").Guid.initString("db2f3aca-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeByte = &IID_IPipeByte_Value;
pub const IPipeByte = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: fn(
            self: *const IPipeByte,
            buf: [*:0]u8,
            cRequest: u32,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: fn(
            self: *const IPipeByte,
            buf: [*:0]u8,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeByte_Pull(self: *const T, buf: [*:0]u8, cRequest: u32, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeByte.VTable, self.vtable).Pull(@ptrCast(*const IPipeByte, self), buf, cRequest, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeByte_Push(self: *const T, buf: [*:0]u8, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeByte.VTable, self.vtable).Push(@ptrCast(*const IPipeByte, self), buf, cSent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeByte_Value = @import("../zig.zig").Guid.initString("db2f3acb-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeByte = &IID_AsyncIPipeByte_Value;
pub const AsyncIPipeByte = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: fn(
            self: *const AsyncIPipeByte,
            cRequest: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Pull: fn(
            self: *const AsyncIPipeByte,
            buf: [*:0]u8,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Push: fn(
            self: *const AsyncIPipeByte,
            buf: [*:0]u8,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Push: fn(
            self: *const AsyncIPipeByte,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeByte_Begin_Pull(self: *const T, cRequest: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeByte.VTable, self.vtable).Begin_Pull(@ptrCast(*const AsyncIPipeByte, self), cRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeByte_Finish_Pull(self: *const T, buf: [*:0]u8, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeByte.VTable, self.vtable).Finish_Pull(@ptrCast(*const AsyncIPipeByte, self), buf, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeByte_Begin_Push(self: *const T, buf: [*:0]u8, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeByte.VTable, self.vtable).Begin_Push(@ptrCast(*const AsyncIPipeByte, self), buf, cSent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeByte_Finish_Push(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeByte.VTable, self.vtable).Finish_Push(@ptrCast(*const AsyncIPipeByte, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeLong_Value = @import("../zig.zig").Guid.initString("db2f3acc-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeLong = &IID_IPipeLong_Value;
pub const IPipeLong = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: fn(
            self: *const IPipeLong,
            buf: [*]i32,
            cRequest: u32,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: fn(
            self: *const IPipeLong,
            buf: [*]i32,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeLong_Pull(self: *const T, buf: [*]i32, cRequest: u32, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeLong.VTable, self.vtable).Pull(@ptrCast(*const IPipeLong, self), buf, cRequest, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeLong_Push(self: *const T, buf: [*]i32, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeLong.VTable, self.vtable).Push(@ptrCast(*const IPipeLong, self), buf, cSent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeLong_Value = @import("../zig.zig").Guid.initString("db2f3acd-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeLong = &IID_AsyncIPipeLong_Value;
pub const AsyncIPipeLong = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: fn(
            self: *const AsyncIPipeLong,
            cRequest: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Pull: fn(
            self: *const AsyncIPipeLong,
            buf: [*]i32,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Push: fn(
            self: *const AsyncIPipeLong,
            buf: [*]i32,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Push: fn(
            self: *const AsyncIPipeLong,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeLong_Begin_Pull(self: *const T, cRequest: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeLong.VTable, self.vtable).Begin_Pull(@ptrCast(*const AsyncIPipeLong, self), cRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeLong_Finish_Pull(self: *const T, buf: [*]i32, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeLong.VTable, self.vtable).Finish_Pull(@ptrCast(*const AsyncIPipeLong, self), buf, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeLong_Begin_Push(self: *const T, buf: [*]i32, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeLong.VTable, self.vtable).Begin_Push(@ptrCast(*const AsyncIPipeLong, self), buf, cSent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeLong_Finish_Push(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeLong.VTable, self.vtable).Finish_Push(@ptrCast(*const AsyncIPipeLong, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeDouble_Value = @import("../zig.zig").Guid.initString("db2f3ace-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeDouble = &IID_IPipeDouble_Value;
pub const IPipeDouble = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: fn(
            self: *const IPipeDouble,
            buf: [*]f64,
            cRequest: u32,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Push: fn(
            self: *const IPipeDouble,
            buf: [*]f64,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeDouble_Pull(self: *const T, buf: [*]f64, cRequest: u32, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeDouble.VTable, self.vtable).Pull(@ptrCast(*const IPipeDouble, self), buf, cRequest, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPipeDouble_Push(self: *const T, buf: [*]f64, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPipeDouble.VTable, self.vtable).Push(@ptrCast(*const IPipeDouble, self), buf, cSent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeDouble_Value = @import("../zig.zig").Guid.initString("db2f3acf-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeDouble = &IID_AsyncIPipeDouble_Value;
pub const AsyncIPipeDouble = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: fn(
            self: *const AsyncIPipeDouble,
            cRequest: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Pull: fn(
            self: *const AsyncIPipeDouble,
            buf: [*]f64,
            pcReturned: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_Push: fn(
            self: *const AsyncIPipeDouble,
            buf: [*]f64,
            cSent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_Push: fn(
            self: *const AsyncIPipeDouble,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeDouble_Begin_Pull(self: *const T, cRequest: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeDouble.VTable, self.vtable).Begin_Pull(@ptrCast(*const AsyncIPipeDouble, self), cRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeDouble_Finish_Pull(self: *const T, buf: [*]f64, pcReturned: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeDouble.VTable, self.vtable).Finish_Pull(@ptrCast(*const AsyncIPipeDouble, self), buf, pcReturned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeDouble_Begin_Push(self: *const T, buf: [*]f64, cSent: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeDouble.VTable, self.vtable).Begin_Push(@ptrCast(*const AsyncIPipeDouble, self), buf, cSent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIPipeDouble_Finish_Push(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIPipeDouble.VTable, self.vtable).Finish_Push(@ptrCast(*const AsyncIPipeDouble, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APTTYPEQUALIFIER = enum(i32) {
    NONE = 0,
    IMPLICIT_MTA = 1,
    NA_ON_MTA = 2,
    NA_ON_STA = 3,
    NA_ON_IMPLICIT_MTA = 4,
    NA_ON_MAINSTA = 5,
    APPLICATION_STA = 6,
    RESERVED_1 = 7,
};
pub const APTTYPEQUALIFIER_NONE = APTTYPEQUALIFIER.NONE;
pub const APTTYPEQUALIFIER_IMPLICIT_MTA = APTTYPEQUALIFIER.IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MTA = APTTYPEQUALIFIER.NA_ON_MTA;
pub const APTTYPEQUALIFIER_NA_ON_STA = APTTYPEQUALIFIER.NA_ON_STA;
pub const APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = APTTYPEQUALIFIER.NA_ON_IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MAINSTA = APTTYPEQUALIFIER.NA_ON_MAINSTA;
pub const APTTYPEQUALIFIER_APPLICATION_STA = APTTYPEQUALIFIER.APPLICATION_STA;
pub const APTTYPEQUALIFIER_RESERVED_1 = APTTYPEQUALIFIER.RESERVED_1;

pub const APTTYPE = enum(i32) {
    CURRENT = -1,
    STA = 0,
    MTA = 1,
    NA = 2,
    MAINSTA = 3,
};
pub const APTTYPE_CURRENT = APTTYPE.CURRENT;
pub const APTTYPE_STA = APTTYPE.STA;
pub const APTTYPE_MTA = APTTYPE.MTA;
pub const APTTYPE_NA = APTTYPE.NA;
pub const APTTYPE_MAINSTA = APTTYPE.MAINSTA;

pub const THDTYPE = enum(i32) {
    BLOCKMESSAGES = 0,
    PROCESSMESSAGES = 1,
};
pub const THDTYPE_BLOCKMESSAGES = THDTYPE.BLOCKMESSAGES;
pub const THDTYPE_PROCESSMESSAGES = THDTYPE.PROCESSMESSAGES;

// TODO: this type is limited to platform 'windows5.0'
const IID_IComThreadingInfo_Value = @import("../zig.zig").Guid.initString("000001ce-0000-0000-c000-000000000046");
pub const IID_IComThreadingInfo = &IID_IComThreadingInfo_Value;
pub const IComThreadingInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentApartmentType: fn(
            self: *const IComThreadingInfo,
            pAptType: ?*APTTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadType: fn(
            self: *const IComThreadingInfo,
            pThreadType: ?*THDTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLogicalThreadId: fn(
            self: *const IComThreadingInfo,
            pguidLogicalThreadId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentLogicalThreadId: fn(
            self: *const IComThreadingInfo,
            rguid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComThreadingInfo_GetCurrentApartmentType(self: *const T, pAptType: ?*APTTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComThreadingInfo.VTable, self.vtable).GetCurrentApartmentType(@ptrCast(*const IComThreadingInfo, self), pAptType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComThreadingInfo_GetCurrentThreadType(self: *const T, pThreadType: ?*THDTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComThreadingInfo.VTable, self.vtable).GetCurrentThreadType(@ptrCast(*const IComThreadingInfo, self), pThreadType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComThreadingInfo_GetCurrentLogicalThreadId(self: *const T, pguidLogicalThreadId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComThreadingInfo.VTable, self.vtable).GetCurrentLogicalThreadId(@ptrCast(*const IComThreadingInfo, self), pguidLogicalThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComThreadingInfo_SetCurrentLogicalThreadId(self: *const T, rguid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComThreadingInfo.VTable, self.vtable).SetCurrentLogicalThreadId(@ptrCast(*const IComThreadingInfo, self), rguid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProcessInitControl_Value = @import("../zig.zig").Guid.initString("72380d55-8d2b-43a3-8513-2b6ef31434e9");
pub const IID_IProcessInitControl = &IID_IProcessInitControl_Value;
pub const IProcessInitControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetInitializerTimeout: fn(
            self: *const IProcessInitControl,
            dwSecondsRemaining: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessInitControl_ResetInitializerTimeout(self: *const T, dwSecondsRemaining: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessInitControl.VTable, self.vtable).ResetInitializerTimeout(@ptrCast(*const IProcessInitControl, self), dwSecondsRemaining);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFastRundown_Value = @import("../zig.zig").Guid.initString("00000040-0000-0000-c000-000000000046");
pub const IID_IFastRundown = &IID_IFastRundown_Value;
pub const IFastRundown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CO_MARSHALING_CONTEXT_ATTRIBUTES = enum(i32) {
    SOURCE_IS_APP_CONTAINER = 0,
    CONTEXT_ATTRIBUTE_RESERVED_1 = -2147483648,
    CONTEXT_ATTRIBUTE_RESERVED_2 = -2147483647,
    CONTEXT_ATTRIBUTE_RESERVED_3 = -2147483646,
    CONTEXT_ATTRIBUTE_RESERVED_4 = -2147483645,
    CONTEXT_ATTRIBUTE_RESERVED_5 = -2147483644,
    CONTEXT_ATTRIBUTE_RESERVED_6 = -2147483643,
    CONTEXT_ATTRIBUTE_RESERVED_7 = -2147483642,
    CONTEXT_ATTRIBUTE_RESERVED_8 = -2147483641,
    CONTEXT_ATTRIBUTE_RESERVED_9 = -2147483640,
    CONTEXT_ATTRIBUTE_RESERVED_10 = -2147483639,
    CONTEXT_ATTRIBUTE_RESERVED_11 = -2147483638,
    CONTEXT_ATTRIBUTE_RESERVED_12 = -2147483637,
    CONTEXT_ATTRIBUTE_RESERVED_13 = -2147483636,
    CONTEXT_ATTRIBUTE_RESERVED_14 = -2147483635,
    CONTEXT_ATTRIBUTE_RESERVED_15 = -2147483634,
    CONTEXT_ATTRIBUTE_RESERVED_16 = -2147483633,
    CONTEXT_ATTRIBUTE_RESERVED_17 = -2147483632,
    CONTEXT_ATTRIBUTE_RESERVED_18 = -2147483631,
};
pub const CO_MARSHALING_SOURCE_IS_APP_CONTAINER = CO_MARSHALING_CONTEXT_ATTRIBUTES.SOURCE_IS_APP_CONTAINER;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_1;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_2;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_3;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_4;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_5;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_6;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_7;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_8;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_9;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_10;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_11;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_12;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_13;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_14;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_15;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_16;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_17;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_18 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_18;

pub const MachineGlobalObjectTableRegistrationToken__ = extern struct {
    unused: i32,
};

const IID_IMachineGlobalObjectTable_Value = @import("../zig.zig").Guid.initString("26d709ac-f70b-4421-a96f-d2878fafb00d");
pub const IID_IMachineGlobalObjectTable = &IID_IMachineGlobalObjectTable_Value;
pub const IMachineGlobalObjectTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterObject: fn(
            self: *const IMachineGlobalObjectTable,
            clsid: ?*const Guid,
            identifier: ?[*:0]const u16,
            object: ?*IUnknown,
            token: ?*?*MachineGlobalObjectTableRegistrationToken__,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const IMachineGlobalObjectTable,
            clsid: ?*const Guid,
            identifier: ?[*:0]const u16,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeObject: fn(
            self: *const IMachineGlobalObjectTable,
            token: ?*MachineGlobalObjectTableRegistrationToken__,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineGlobalObjectTable_RegisterObject(self: *const T, clsid: ?*const Guid, identifier: ?[*:0]const u16, object: ?*IUnknown, token: ?*?*MachineGlobalObjectTableRegistrationToken__) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineGlobalObjectTable.VTable, self.vtable).RegisterObject(@ptrCast(*const IMachineGlobalObjectTable, self), clsid, identifier, object, token);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineGlobalObjectTable_GetObject(self: *const T, clsid: ?*const Guid, identifier: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineGlobalObjectTable.VTable, self.vtable).GetObject(@ptrCast(*const IMachineGlobalObjectTable, self), clsid, identifier, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineGlobalObjectTable_RevokeObject(self: *const T, token: ?*MachineGlobalObjectTableRegistrationToken__) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineGlobalObjectTable.VTable, self.vtable).RevokeObject(@ptrCast(*const IMachineGlobalObjectTable, self), token);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMallocSpy_Value = @import("../zig.zig").Guid.initString("0000001d-0000-0000-c000-000000000046");
pub const IID_IMallocSpy = &IID_IMallocSpy_Value;
pub const IMallocSpy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreAlloc: fn(
            self: *const IMallocSpy,
            cbRequest: usize,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        PostAlloc: fn(
            self: *const IMallocSpy,
            pActual: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PreFree: fn(
            self: *const IMallocSpy,
            pRequest: ?*anyopaque,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PostFree: fn(
            self: *const IMallocSpy,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PreRealloc: fn(
            self: *const IMallocSpy,
            pRequest: ?*anyopaque,
            cbRequest: usize,
            ppNewRequest: ?*?*anyopaque,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        PostRealloc: fn(
            self: *const IMallocSpy,
            pActual: ?*anyopaque,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PreGetSize: fn(
            self: *const IMallocSpy,
            pRequest: ?*anyopaque,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PostGetSize: fn(
            self: *const IMallocSpy,
            cbActual: usize,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) usize,
        PreDidAlloc: fn(
            self: *const IMallocSpy,
            pRequest: ?*anyopaque,
            fSpyed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        PostDidAlloc: fn(
            self: *const IMallocSpy,
            pRequest: ?*anyopaque,
            fSpyed: BOOL,
            fActual: i32,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        PreHeapMinimize: fn(
            self: *const IMallocSpy,
        ) callconv(@import("std").os.windows.WINAPI) void,
        PostHeapMinimize: fn(
            self: *const IMallocSpy,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreAlloc(self: *const T, cbRequest: usize) callconv(.Inline) usize {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreAlloc(@ptrCast(*const IMallocSpy, self), cbRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostAlloc(self: *const T, pActual: ?*anyopaque) callconv(.Inline) ?*anyopaque {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostAlloc(@ptrCast(*const IMallocSpy, self), pActual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreFree(self: *const T, pRequest: ?*anyopaque, fSpyed: BOOL) callconv(.Inline) ?*anyopaque {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreFree(@ptrCast(*const IMallocSpy, self), pRequest, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostFree(self: *const T, fSpyed: BOOL) callconv(.Inline) void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostFree(@ptrCast(*const IMallocSpy, self), fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreRealloc(self: *const T, pRequest: ?*anyopaque, cbRequest: usize, ppNewRequest: ?*?*anyopaque, fSpyed: BOOL) callconv(.Inline) usize {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreRealloc(@ptrCast(*const IMallocSpy, self), pRequest, cbRequest, ppNewRequest, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostRealloc(self: *const T, pActual: ?*anyopaque, fSpyed: BOOL) callconv(.Inline) ?*anyopaque {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostRealloc(@ptrCast(*const IMallocSpy, self), pActual, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreGetSize(self: *const T, pRequest: ?*anyopaque, fSpyed: BOOL) callconv(.Inline) ?*anyopaque {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreGetSize(@ptrCast(*const IMallocSpy, self), pRequest, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostGetSize(self: *const T, cbActual: usize, fSpyed: BOOL) callconv(.Inline) usize {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostGetSize(@ptrCast(*const IMallocSpy, self), cbActual, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreDidAlloc(self: *const T, pRequest: ?*anyopaque, fSpyed: BOOL) callconv(.Inline) ?*anyopaque {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreDidAlloc(@ptrCast(*const IMallocSpy, self), pRequest, fSpyed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostDidAlloc(self: *const T, pRequest: ?*anyopaque, fSpyed: BOOL, fActual: i32) callconv(.Inline) i32 {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostDidAlloc(@ptrCast(*const IMallocSpy, self), pRequest, fSpyed, fActual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PreHeapMinimize(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PreHeapMinimize(@ptrCast(*const IMallocSpy, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMallocSpy_PostHeapMinimize(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMallocSpy.VTable, self.vtable).PostHeapMinimize(@ptrCast(*const IMallocSpy, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BIND_OPTS = extern struct {
    cbStruct: u32,
    grfFlags: u32,
    grfMode: u32,
    dwTickCountDeadline: u32,
};

pub const BIND_OPTS2 = extern struct {
    __AnonymousBase_objidl_L9017_C36: BIND_OPTS,
    dwTrackFlags: u32,
    dwClassContext: u32,
    locale: u32,
    pServerInfo: ?*COSERVERINFO,
};

pub const BIND_OPTS3 = extern struct {
    __AnonymousBase_objidl_L9041_C36: BIND_OPTS2,
    hwnd: ?HWND,
};

pub const BIND_FLAGS = enum(i32) {
    MAYBOTHERUSER = 1,
    JUSTTESTEXISTENCE = 2,
};
pub const BIND_MAYBOTHERUSER = BIND_FLAGS.MAYBOTHERUSER;
pub const BIND_JUSTTESTEXISTENCE = BIND_FLAGS.JUSTTESTEXISTENCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IBindCtx_Value = @import("../zig.zig").Guid.initString("0000000e-0000-0000-c000-000000000046");
pub const IID_IBindCtx = &IID_IBindCtx_Value;
pub const IBindCtx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterObjectBound: fn(
            self: *const IBindCtx,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeObjectBound: fn(
            self: *const IBindCtx,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBoundObjects: fn(
            self: *const IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBindOptions: fn(
            self: *const IBindCtx,
            pbindopts: ?*BIND_OPTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindOptions: fn(
            self: *const IBindCtx,
            pbindopts: ?*BIND_OPTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningObjectTable: fn(
            self: *const IBindCtx,
            pprot: ?*?*IRunningObjectTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterObjectParam: fn(
            self: *const IBindCtx,
            pszKey: ?PWSTR,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectParam: fn(
            self: *const IBindCtx,
            pszKey: ?PWSTR,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumObjectParam: fn(
            self: *const IBindCtx,
            ppenum: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeObjectParam: fn(
            self: *const IBindCtx,
            pszKey: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_RegisterObjectBound(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).RegisterObjectBound(@ptrCast(*const IBindCtx, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_RevokeObjectBound(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).RevokeObjectBound(@ptrCast(*const IBindCtx, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_ReleaseBoundObjects(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).ReleaseBoundObjects(@ptrCast(*const IBindCtx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_SetBindOptions(self: *const T, pbindopts: ?*BIND_OPTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).SetBindOptions(@ptrCast(*const IBindCtx, self), pbindopts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_GetBindOptions(self: *const T, pbindopts: ?*BIND_OPTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).GetBindOptions(@ptrCast(*const IBindCtx, self), pbindopts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_GetRunningObjectTable(self: *const T, pprot: ?*?*IRunningObjectTable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).GetRunningObjectTable(@ptrCast(*const IBindCtx, self), pprot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_RegisterObjectParam(self: *const T, pszKey: ?PWSTR, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).RegisterObjectParam(@ptrCast(*const IBindCtx, self), pszKey, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_GetObjectParam(self: *const T, pszKey: ?PWSTR, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).GetObjectParam(@ptrCast(*const IBindCtx, self), pszKey, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_EnumObjectParam(self: *const T, ppenum: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).EnumObjectParam(@ptrCast(*const IBindCtx, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCtx_RevokeObjectParam(self: *const T, pszKey: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCtx.VTable, self.vtable).RevokeObjectParam(@ptrCast(*const IBindCtx, self), pszKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumMoniker_Value = @import("../zig.zig").Guid.initString("00000102-0000-0000-c000-000000000046");
pub const IID_IEnumMoniker = &IID_IEnumMoniker_Value;
pub const IEnumMoniker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMoniker,
            celt: u32,
            rgelt: [*]?*IMoniker,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMoniker,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMoniker,
            ppenum: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMoniker_Next(self: *const T, celt: u32, rgelt: [*]?*IMoniker, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMoniker.VTable, self.vtable).Next(@ptrCast(*const IEnumMoniker, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMoniker_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMoniker.VTable, self.vtable).Skip(@ptrCast(*const IEnumMoniker, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMoniker_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMoniker.VTable, self.vtable).Reset(@ptrCast(*const IEnumMoniker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMoniker_Clone(self: *const T, ppenum: ?*?*IEnumMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMoniker.VTable, self.vtable).Clone(@ptrCast(*const IEnumMoniker, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunnableObject_Value = @import("../zig.zig").Guid.initString("00000126-0000-0000-c000-000000000046");
pub const IID_IRunnableObject = &IID_IRunnableObject_Value;
pub const IRunnableObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRunningClass: fn(
            self: *const IRunnableObject,
            lpClsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IRunnableObject,
            pbc: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: fn(
            self: *const IRunnableObject,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        LockRunning: fn(
            self: *const IRunnableObject,
            fLock: BOOL,
            fLastUnlockCloses: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetContainedObject: fn(
            self: *const IRunnableObject,
            fContained: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_GetRunningClass(self: *const T, lpClsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).GetRunningClass(@ptrCast(*const IRunnableObject, self), lpClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_Run(self: *const T, pbc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).Run(@ptrCast(*const IRunnableObject, self), pbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_IsRunning(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).IsRunning(@ptrCast(*const IRunnableObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_LockRunning(self: *const T, fLock: BOOL, fLastUnlockCloses: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).LockRunning(@ptrCast(*const IRunnableObject, self), fLock, fLastUnlockCloses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableObject_SetContainedObject(self: *const T, fContained: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableObject.VTable, self.vtable).SetContainedObject(@ptrCast(*const IRunnableObject, self), fContained);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunningObjectTable_Value = @import("../zig.zig").Guid.initString("00000010-0000-0000-c000-000000000046");
pub const IID_IRunningObjectTable = &IID_IRunningObjectTable_Value;
pub const IRunningObjectTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: fn(
            self: *const IRunningObjectTable,
            grfFlags: u32,
            punkObject: ?*IUnknown,
            pmkObjectName: ?*IMoniker,
            pdwRegister: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revoke: fn(
            self: *const IRunningObjectTable,
            dwRegister: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: fn(
            self: *const IRunningObjectTable,
            pmkObjectName: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const IRunningObjectTable,
            pmkObjectName: ?*IMoniker,
            ppunkObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NoteChangeTime: fn(
            self: *const IRunningObjectTable,
            dwRegister: u32,
            pfiletime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeOfLastChange: fn(
            self: *const IRunningObjectTable,
            pmkObjectName: ?*IMoniker,
            pfiletime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRunning: fn(
            self: *const IRunningObjectTable,
            ppenumMoniker: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_Register(self: *const T, grfFlags: u32, punkObject: ?*IUnknown, pmkObjectName: ?*IMoniker, pdwRegister: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).Register(@ptrCast(*const IRunningObjectTable, self), grfFlags, punkObject, pmkObjectName, pdwRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_Revoke(self: *const T, dwRegister: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).Revoke(@ptrCast(*const IRunningObjectTable, self), dwRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_IsRunning(self: *const T, pmkObjectName: ?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).IsRunning(@ptrCast(*const IRunningObjectTable, self), pmkObjectName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_GetObject(self: *const T, pmkObjectName: ?*IMoniker, ppunkObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).GetObject(@ptrCast(*const IRunningObjectTable, self), pmkObjectName, ppunkObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_NoteChangeTime(self: *const T, dwRegister: u32, pfiletime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).NoteChangeTime(@ptrCast(*const IRunningObjectTable, self), dwRegister, pfiletime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_GetTimeOfLastChange(self: *const T, pmkObjectName: ?*IMoniker, pfiletime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).GetTimeOfLastChange(@ptrCast(*const IRunningObjectTable, self), pmkObjectName, pfiletime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningObjectTable_EnumRunning(self: *const T, ppenumMoniker: ?*?*IEnumMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningObjectTable.VTable, self.vtable).EnumRunning(@ptrCast(*const IRunningObjectTable, self), ppenumMoniker);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersist_Value = @import("../zig.zig").Guid.initString("0000010c-0000-0000-c000-000000000046");
pub const IID_IPersist = &IID_IPersist_Value;
pub const IPersist = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassID: fn(
            self: *const IPersist,
            pClassID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersist_GetClassID(self: *const T, pClassID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersist.VTable, self.vtable).GetClassID(@ptrCast(*const IPersist, self), pClassID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStream_Value = @import("../zig.zig").Guid.initString("00000109-0000-0000-c000-000000000046");
pub const IID_IPersistStream = &IID_IPersistStream_Value;
pub const IPersistStream = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: fn(
            self: *const IPersistStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistStream,
            pStm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistStream,
            pStm: ?*IStream,
            fClearDirty: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeMax: fn(
            self: *const IPersistStream,
            pcbSize: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStream_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStream.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistStream, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStream_Load(self: *const T, pStm: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStream.VTable, self.vtable).Load(@ptrCast(*const IPersistStream, self), pStm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStream_Save(self: *const T, pStm: ?*IStream, fClearDirty: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStream.VTable, self.vtable).Save(@ptrCast(*const IPersistStream, self), pStm, fClearDirty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStream_GetSizeMax(self: *const T, pcbSize: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStream.VTable, self.vtable).GetSizeMax(@ptrCast(*const IPersistStream, self), pcbSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MKSYS = enum(i32) {
    NONE = 0,
    GENERICCOMPOSITE = 1,
    FILEMONIKER = 2,
    ANTIMONIKER = 3,
    ITEMMONIKER = 4,
    POINTERMONIKER = 5,
    CLASSMONIKER = 7,
    OBJREFMONIKER = 8,
    SESSIONMONIKER = 9,
    LUAMONIKER = 10,
};
pub const MKSYS_NONE = MKSYS.NONE;
pub const MKSYS_GENERICCOMPOSITE = MKSYS.GENERICCOMPOSITE;
pub const MKSYS_FILEMONIKER = MKSYS.FILEMONIKER;
pub const MKSYS_ANTIMONIKER = MKSYS.ANTIMONIKER;
pub const MKSYS_ITEMMONIKER = MKSYS.ITEMMONIKER;
pub const MKSYS_POINTERMONIKER = MKSYS.POINTERMONIKER;
pub const MKSYS_CLASSMONIKER = MKSYS.CLASSMONIKER;
pub const MKSYS_OBJREFMONIKER = MKSYS.OBJREFMONIKER;
pub const MKSYS_SESSIONMONIKER = MKSYS.SESSIONMONIKER;
pub const MKSYS_LUAMONIKER = MKSYS.LUAMONIKER;

pub const MKREDUCE = enum(i32) {
    ONE = 196608,
    TOUSER = 131072,
    THROUGHUSER = 65536,
    ALL = 0,
};
pub const MKRREDUCE_ONE = MKREDUCE.ONE;
pub const MKRREDUCE_TOUSER = MKREDUCE.TOUSER;
pub const MKRREDUCE_THROUGHUSER = MKREDUCE.THROUGHUSER;
pub const MKRREDUCE_ALL = MKREDUCE.ALL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMoniker_Value = @import("../zig.zig").Guid.initString("0000000f-0000-0000-c000-000000000046");
pub const IID_IMoniker = &IID_IMoniker_Value;
pub const IMoniker = extern struct {
    pub const VTable = extern struct {
        base: IPersistStream.VTable,
        BindToObject: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            riidResult: ?*const Guid,
            ppvResult: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToStorage: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            riid: ?*const Guid,
            ppvObj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reduce: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            dwReduceHowFar: u32,
            ppmkToLeft: ?*?*IMoniker,
            ppmkReduced: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComposeWith: fn(
            self: *const IMoniker,
            pmkRight: ?*IMoniker,
            fOnlyIfNotGeneric: BOOL,
            ppmkComposite: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enum: fn(
            self: *const IMoniker,
            fForward: BOOL,
            ppenumMoniker: ?*?*IEnumMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IMoniker,
            pmkOtherMoniker: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hash: fn(
            self: *const IMoniker,
            pdwHash: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            pmkNewlyRunning: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeOfLastChange: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            pFileTime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Inverse: fn(
            self: *const IMoniker,
            ppmk: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommonPrefixWith: fn(
            self: *const IMoniker,
            pmkOther: ?*IMoniker,
            ppmkPrefix: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RelativePathTo: fn(
            self: *const IMoniker,
            pmkOther: ?*IMoniker,
            ppmkRelPath: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            ppszDisplayName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseDisplayName: fn(
            self: *const IMoniker,
            pbc: ?*IBindCtx,
            pmkToLeft: ?*IMoniker,
            pszDisplayName: ?PWSTR,
            pchEaten: ?*u32,
            ppmkOut: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSystemMoniker: fn(
            self: *const IMoniker,
            pdwMksys: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_BindToObject(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, riidResult: ?*const Guid, ppvResult: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).BindToObject(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, riidResult, ppvResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_BindToStorage(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, riid: ?*const Guid, ppvObj: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).BindToStorage(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, riid, ppvObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_Reduce(self: *const T, pbc: ?*IBindCtx, dwReduceHowFar: u32, ppmkToLeft: ?*?*IMoniker, ppmkReduced: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).Reduce(@ptrCast(*const IMoniker, self), pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_ComposeWith(self: *const T, pmkRight: ?*IMoniker, fOnlyIfNotGeneric: BOOL, ppmkComposite: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).ComposeWith(@ptrCast(*const IMoniker, self), pmkRight, fOnlyIfNotGeneric, ppmkComposite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_Enum(self: *const T, fForward: BOOL, ppenumMoniker: ?*?*IEnumMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).Enum(@ptrCast(*const IMoniker, self), fForward, ppenumMoniker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_IsEqual(self: *const T, pmkOtherMoniker: ?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).IsEqual(@ptrCast(*const IMoniker, self), pmkOtherMoniker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_Hash(self: *const T, pdwHash: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).Hash(@ptrCast(*const IMoniker, self), pdwHash);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_IsRunning(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, pmkNewlyRunning: ?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).IsRunning(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, pmkNewlyRunning);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_GetTimeOfLastChange(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, pFileTime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).GetTimeOfLastChange(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, pFileTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_Inverse(self: *const T, ppmk: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).Inverse(@ptrCast(*const IMoniker, self), ppmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_CommonPrefixWith(self: *const T, pmkOther: ?*IMoniker, ppmkPrefix: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).CommonPrefixWith(@ptrCast(*const IMoniker, self), pmkOther, ppmkPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_RelativePathTo(self: *const T, pmkOther: ?*IMoniker, ppmkRelPath: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).RelativePathTo(@ptrCast(*const IMoniker, self), pmkOther, ppmkRelPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_GetDisplayName(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, ppszDisplayName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).GetDisplayName(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, ppszDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_ParseDisplayName(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, pszDisplayName: ?PWSTR, pchEaten: ?*u32, ppmkOut: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).ParseDisplayName(@ptrCast(*const IMoniker, self), pbc, pmkToLeft, pszDisplayName, pchEaten, ppmkOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMoniker_IsSystemMoniker(self: *const T, pdwMksys: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMoniker.VTable, self.vtable).IsSystemMoniker(@ptrCast(*const IMoniker, self), pdwMksys);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IROTData_Value = @import("../zig.zig").Guid.initString("f29f6bc0-5021-11ce-aa15-00006901293f");
pub const IID_IROTData = &IID_IROTData_Value;
pub const IROTData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetComparisonData: fn(
            self: *const IROTData,
            pbData: [*:0]u8,
            cbMax: u32,
            pcbData: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IROTData_GetComparisonData(self: *const T, pbData: [*:0]u8, cbMax: u32, pcbData: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IROTData.VTable, self.vtable).GetComparisonData(@ptrCast(*const IROTData, self), pbData, cbMax, pcbData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistFile_Value = @import("../zig.zig").Guid.initString("0000010b-0000-0000-c000-000000000046");
pub const IID_IPersistFile = &IID_IPersistFile_Value;
pub const IPersistFile = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: fn(
            self: *const IPersistFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistFile,
            pszFileName: ?[*:0]const u16,
            dwMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistFile,
            pszFileName: ?[*:0]const u16,
            fRemember: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: fn(
            self: *const IPersistFile,
            pszFileName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurFile: fn(
            self: *const IPersistFile,
            ppszFileName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistFile, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_Load(self: *const T, pszFileName: ?[*:0]const u16, dwMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).Load(@ptrCast(*const IPersistFile, self), pszFileName, dwMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_Save(self: *const T, pszFileName: ?[*:0]const u16, fRemember: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).Save(@ptrCast(*const IPersistFile, self), pszFileName, fRemember);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_SaveCompleted(self: *const T, pszFileName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).SaveCompleted(@ptrCast(*const IPersistFile, self), pszFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFile_GetCurFile(self: *const T, ppszFileName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFile.VTable, self.vtable).GetCurFile(@ptrCast(*const IPersistFile, self), ppszFileName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVTARGETDEVICE = extern struct {
    tdSize: u32,
    tdDriverNameOffset: u16,
    tdDeviceNameOffset: u16,
    tdPortNameOffset: u16,
    tdExtDevmodeOffset: u16,
    tdData: [1]u8,
};

pub const FORMATETC = extern struct {
    cfFormat: u16,
    ptd: ?*DVTARGETDEVICE,
    dwAspect: u32,
    lindex: i32,
    tymed: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumFORMATETC_Value = @import("../zig.zig").Guid.initString("00000103-0000-0000-c000-000000000046");
pub const IID_IEnumFORMATETC = &IID_IEnumFORMATETC_Value;
pub const IEnumFORMATETC = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumFORMATETC,
            celt: u32,
            rgelt: [*]FORMATETC,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumFORMATETC,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumFORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumFORMATETC,
            ppenum: ?*?*IEnumFORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFORMATETC_Next(self: *const T, celt: u32, rgelt: [*]FORMATETC, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFORMATETC.VTable, self.vtable).Next(@ptrCast(*const IEnumFORMATETC, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFORMATETC_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFORMATETC.VTable, self.vtable).Skip(@ptrCast(*const IEnumFORMATETC, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFORMATETC_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFORMATETC.VTable, self.vtable).Reset(@ptrCast(*const IEnumFORMATETC, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFORMATETC_Clone(self: *const T, ppenum: ?*?*IEnumFORMATETC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFORMATETC.VTable, self.vtable).Clone(@ptrCast(*const IEnumFORMATETC, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ADVF = enum(i32) {
    _NODATA = 1,
    _PRIMEFIRST = 2,
    _ONLYONCE = 4,
    _DATAONSTOP = 64,
    CACHE_NOHANDLER = 8,
    CACHE_FORCEBUILTIN = 16,
    CACHE_ONSAVE = 32,
};
pub const ADVF_NODATA = ADVF._NODATA;
pub const ADVF_PRIMEFIRST = ADVF._PRIMEFIRST;
pub const ADVF_ONLYONCE = ADVF._ONLYONCE;
pub const ADVF_DATAONSTOP = ADVF._DATAONSTOP;
pub const ADVFCACHE_NOHANDLER = ADVF.CACHE_NOHANDLER;
pub const ADVFCACHE_FORCEBUILTIN = ADVF.CACHE_FORCEBUILTIN;
pub const ADVFCACHE_ONSAVE = ADVF.CACHE_ONSAVE;

pub const STATDATA = extern struct {
    formatetc: FORMATETC,
    advf: u32,
    pAdvSink: ?*IAdviseSink,
    dwConnection: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATDATA_Value = @import("../zig.zig").Guid.initString("00000105-0000-0000-c000-000000000046");
pub const IID_IEnumSTATDATA = &IID_IEnumSTATDATA_Value;
pub const IEnumSTATDATA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSTATDATA,
            celt: u32,
            rgelt: [*]STATDATA,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSTATDATA,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSTATDATA,
            ppenum: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATDATA_Next(self: *const T, celt: u32, rgelt: [*]STATDATA, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATDATA.VTable, self.vtable).Next(@ptrCast(*const IEnumSTATDATA, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATDATA_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATDATA.VTable, self.vtable).Skip(@ptrCast(*const IEnumSTATDATA, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATDATA_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATDATA.VTable, self.vtable).Reset(@ptrCast(*const IEnumSTATDATA, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATDATA_Clone(self: *const T, ppenum: ?*?*IEnumSTATDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSTATDATA.VTable, self.vtable).Clone(@ptrCast(*const IEnumSTATDATA, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TYMED = enum(i32) {
    HGLOBAL = 1,
    FILE = 2,
    ISTREAM = 4,
    ISTORAGE = 8,
    GDI = 16,
    MFPICT = 32,
    ENHMF = 64,
    NULL = 0,
};
pub const TYMED_HGLOBAL = TYMED.HGLOBAL;
pub const TYMED_FILE = TYMED.FILE;
pub const TYMED_ISTREAM = TYMED.ISTREAM;
pub const TYMED_ISTORAGE = TYMED.ISTORAGE;
pub const TYMED_GDI = TYMED.GDI;
pub const TYMED_MFPICT = TYMED.MFPICT;
pub const TYMED_ENHMF = TYMED.ENHMF;
pub const TYMED_NULL = TYMED.NULL;

pub const RemSTGMEDIUM = extern struct {
    tymed: u32,
    dwHandleType: u32,
    pData: u32,
    pUnkForRelease: u32,
    cbData: u32,
    data: [1]u8,
};

pub const STGMEDIUM = extern struct {
    tymed: u32,
    Anonymous: extern union {
        hBitmap: ?HBITMAP,
        hMetaFilePict: ?*anyopaque,
        hEnhMetaFile: ?HENHMETAFILE,
        hGlobal: isize,
        lpszFileName: ?PWSTR,
        pstm: ?*IStream,
        pstg: ?*IStorage,
    },
    pUnkForRelease: ?*IUnknown,
};

pub const GDI_OBJECT = extern struct {
    ObjectType: u32,
    u: extern struct {
        hBitmap: ?*userHBITMAP,
        hPalette: ?*userHPALETTE,
        hGeneric: ?*userHGLOBAL,
    },
};

pub const userSTGMEDIUM = extern struct {
    pub const _STGMEDIUM_UNION = extern struct {
        tymed: u32,
        u: extern struct {
            hMetaFilePict: ?*userHMETAFILEPICT,
            hHEnhMetaFile: ?*userHENHMETAFILE,
            hGdiHandle: ?*GDI_OBJECT,
            hGlobal: ?*userHGLOBAL,
            lpszFileName: ?PWSTR,
            pstm: ?*BYTE_BLOB,
            pstg: ?*BYTE_BLOB,
        },
    };
    pUnkForRelease: ?*IUnknown,
};

pub const userFLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: userSTGMEDIUM,
};

pub const FLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: STGMEDIUM,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSink_Value = @import("../zig.zig").Guid.initString("0000010f-0000-0000-c000-000000000046");
pub const IID_IAdviseSink = &IID_IAdviseSink_Value;
pub const IAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDataChange: fn(
            self: *const IAdviseSink,
            pFormatetc: ?*FORMATETC,
            pStgmed: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnViewChange: fn(
            self: *const IAdviseSink,
            dwAspect: u32,
            lindex: i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnRename: fn(
            self: *const IAdviseSink,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnSave: fn(
            self: *const IAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnClose: fn(
            self: *const IAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnDataChange(self: *const T, pFormatetc: ?*FORMATETC, pStgmed: ?*STGMEDIUM) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnDataChange(@ptrCast(*const IAdviseSink, self), pFormatetc, pStgmed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnViewChange(self: *const T, dwAspect: u32, lindex: i32) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnViewChange(@ptrCast(*const IAdviseSink, self), dwAspect, lindex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnRename(self: *const T, pmk: ?*IMoniker) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnRename(@ptrCast(*const IAdviseSink, self), pmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnSave(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnSave(@ptrCast(*const IAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink_OnClose(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink.VTable, self.vtable).OnClose(@ptrCast(*const IAdviseSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAdviseSink_Value = @import("../zig.zig").Guid.initString("00000150-0000-0000-c000-000000000046");
pub const IID_AsyncIAdviseSink = &IID_AsyncIAdviseSink_Value;
pub const AsyncIAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_OnDataChange: fn(
            self: *const AsyncIAdviseSink,
            pFormatetc: ?*FORMATETC,
            pStgmed: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnDataChange: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnViewChange: fn(
            self: *const AsyncIAdviseSink,
            dwAspect: u32,
            lindex: i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnViewChange: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnRename: fn(
            self: *const AsyncIAdviseSink,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnRename: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnSave: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnSave: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Begin_OnClose: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnClose: fn(
            self: *const AsyncIAdviseSink,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnDataChange(self: *const T, pFormatetc: ?*FORMATETC, pStgmed: ?*STGMEDIUM) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnDataChange(@ptrCast(*const AsyncIAdviseSink, self), pFormatetc, pStgmed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnDataChange(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnDataChange(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnViewChange(self: *const T, dwAspect: u32, lindex: i32) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnViewChange(@ptrCast(*const AsyncIAdviseSink, self), dwAspect, lindex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnViewChange(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnViewChange(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnRename(self: *const T, pmk: ?*IMoniker) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnRename(@ptrCast(*const AsyncIAdviseSink, self), pmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnRename(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnRename(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnSave(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnSave(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnSave(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnSave(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Begin_OnClose(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Begin_OnClose(@ptrCast(*const AsyncIAdviseSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink_Finish_OnClose(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink.VTable, self.vtable).Finish_OnClose(@ptrCast(*const AsyncIAdviseSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSink2_Value = @import("../zig.zig").Guid.initString("00000125-0000-0000-c000-000000000046");
pub const IID_IAdviseSink2 = &IID_IAdviseSink2_Value;
pub const IAdviseSink2 = extern struct {
    pub const VTable = extern struct {
        base: IAdviseSink.VTable,
        OnLinkSrcChange: fn(
            self: *const IAdviseSink2,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAdviseSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdviseSink2_OnLinkSrcChange(self: *const T, pmk: ?*IMoniker) callconv(.Inline) void {
            return @ptrCast(*const IAdviseSink2.VTable, self.vtable).OnLinkSrcChange(@ptrCast(*const IAdviseSink2, self), pmk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAdviseSink2_Value = @import("../zig.zig").Guid.initString("00000151-0000-0000-c000-000000000046");
pub const IID_AsyncIAdviseSink2 = &IID_AsyncIAdviseSink2_Value;
pub const AsyncIAdviseSink2 = extern struct {
    pub const VTable = extern struct {
        base: AsyncIAdviseSink.VTable,
        Begin_OnLinkSrcChange: fn(
            self: *const AsyncIAdviseSink2,
            pmk: ?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Finish_OnLinkSrcChange: fn(
            self: *const AsyncIAdviseSink2,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace AsyncIAdviseSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink2_Begin_OnLinkSrcChange(self: *const T, pmk: ?*IMoniker) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink2.VTable, self.vtable).Begin_OnLinkSrcChange(@ptrCast(*const AsyncIAdviseSink2, self), pmk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIAdviseSink2_Finish_OnLinkSrcChange(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const AsyncIAdviseSink2.VTable, self.vtable).Finish_OnLinkSrcChange(@ptrCast(*const AsyncIAdviseSink2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DATADIR = enum(i32) {
    GET = 1,
    SET = 2,
};
pub const DATADIR_GET = DATADIR.GET;
pub const DATADIR_SET = DATADIR.SET;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDataObject_Value = @import("../zig.zig").Guid.initString("0000010e-0000-0000-c000-000000000046");
pub const IID_IDataObject = &IID_IDataObject_Value;
pub const IDataObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: fn(
            self: *const IDataObject,
            pformatetcIn: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataHere: fn(
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryGetData: fn(
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCanonicalFormatEtc: fn(
            self: *const IDataObject,
            pformatectIn: ?*FORMATETC,
            pformatetcOut: ?*FORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetData: fn(
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
            pmedium: ?*STGMEDIUM,
            fRelease: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumFormatEtc: fn(
            self: *const IDataObject,
            dwDirection: u32,
            ppenumFormatEtc: ?*?*IEnumFORMATETC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DAdvise: fn(
            self: *const IDataObject,
            pformatetc: ?*FORMATETC,
            advf: u32,
            pAdvSink: ?*IAdviseSink,
            pdwConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DUnadvise: fn(
            self: *const IDataObject,
            dwConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumDAdvise: fn(
            self: *const IDataObject,
            ppenumAdvise: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_GetData(self: *const T, pformatetcIn: ?*FORMATETC, pmedium: ?*STGMEDIUM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).GetData(@ptrCast(*const IDataObject, self), pformatetcIn, pmedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_GetDataHere(self: *const T, pformatetc: ?*FORMATETC, pmedium: ?*STGMEDIUM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).GetDataHere(@ptrCast(*const IDataObject, self), pformatetc, pmedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_QueryGetData(self: *const T, pformatetc: ?*FORMATETC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).QueryGetData(@ptrCast(*const IDataObject, self), pformatetc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_GetCanonicalFormatEtc(self: *const T, pformatectIn: ?*FORMATETC, pformatetcOut: ?*FORMATETC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).GetCanonicalFormatEtc(@ptrCast(*const IDataObject, self), pformatectIn, pformatetcOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_SetData(self: *const T, pformatetc: ?*FORMATETC, pmedium: ?*STGMEDIUM, fRelease: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).SetData(@ptrCast(*const IDataObject, self), pformatetc, pmedium, fRelease);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_EnumFormatEtc(self: *const T, dwDirection: u32, ppenumFormatEtc: ?*?*IEnumFORMATETC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).EnumFormatEtc(@ptrCast(*const IDataObject, self), dwDirection, ppenumFormatEtc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_DAdvise(self: *const T, pformatetc: ?*FORMATETC, advf: u32, pAdvSink: ?*IAdviseSink, pdwConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).DAdvise(@ptrCast(*const IDataObject, self), pformatetc, advf, pAdvSink, pdwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_DUnadvise(self: *const T, dwConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).DUnadvise(@ptrCast(*const IDataObject, self), dwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObject_EnumDAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObject.VTable, self.vtable).EnumDAdvise(@ptrCast(*const IDataObject, self), ppenumAdvise);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDataAdviseHolder_Value = @import("../zig.zig").Guid.initString("00000110-0000-0000-c000-000000000046");
pub const IID_IDataAdviseHolder = &IID_IDataAdviseHolder_Value;
pub const IDataAdviseHolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: fn(
            self: *const IDataAdviseHolder,
            pDataObject: ?*IDataObject,
            pFetc: ?*FORMATETC,
            advf: u32,
            pAdvise: ?*IAdviseSink,
            pdwConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IDataAdviseHolder,
            dwConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumAdvise: fn(
            self: *const IDataAdviseHolder,
            ppenumAdvise: ?*?*IEnumSTATDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendOnDataChange: fn(
            self: *const IDataAdviseHolder,
            pDataObject: ?*IDataObject,
            dwReserved: u32,
            advf: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataAdviseHolder_Advise(self: *const T, pDataObject: ?*IDataObject, pFetc: ?*FORMATETC, advf: u32, pAdvise: ?*IAdviseSink, pdwConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataAdviseHolder.VTable, self.vtable).Advise(@ptrCast(*const IDataAdviseHolder, self), pDataObject, pFetc, advf, pAdvise, pdwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataAdviseHolder_Unadvise(self: *const T, dwConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataAdviseHolder.VTable, self.vtable).Unadvise(@ptrCast(*const IDataAdviseHolder, self), dwConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataAdviseHolder_EnumAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataAdviseHolder.VTable, self.vtable).EnumAdvise(@ptrCast(*const IDataAdviseHolder, self), ppenumAdvise);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataAdviseHolder_SendOnDataChange(self: *const T, pDataObject: ?*IDataObject, dwReserved: u32, advf: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataAdviseHolder.VTable, self.vtable).SendOnDataChange(@ptrCast(*const IDataAdviseHolder, self), pDataObject, dwReserved, advf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CALLTYPE = enum(i32) {
    TOPLEVEL = 1,
    NESTED = 2,
    ASYNC = 3,
    TOPLEVEL_CALLPENDING = 4,
    ASYNC_CALLPENDING = 5,
};
pub const CALLTYPE_TOPLEVEL = CALLTYPE.TOPLEVEL;
pub const CALLTYPE_NESTED = CALLTYPE.NESTED;
pub const CALLTYPE_ASYNC = CALLTYPE.ASYNC;
pub const CALLTYPE_TOPLEVEL_CALLPENDING = CALLTYPE.TOPLEVEL_CALLPENDING;
pub const CALLTYPE_ASYNC_CALLPENDING = CALLTYPE.ASYNC_CALLPENDING;

pub const SERVERCALL = enum(i32) {
    ISHANDLED = 0,
    REJECTED = 1,
    RETRYLATER = 2,
};
pub const SERVERCALL_ISHANDLED = SERVERCALL.ISHANDLED;
pub const SERVERCALL_REJECTED = SERVERCALL.REJECTED;
pub const SERVERCALL_RETRYLATER = SERVERCALL.RETRYLATER;

pub const PENDINGTYPE = enum(i32) {
    TOPLEVEL = 1,
    NESTED = 2,
};
pub const PENDINGTYPE_TOPLEVEL = PENDINGTYPE.TOPLEVEL;
pub const PENDINGTYPE_NESTED = PENDINGTYPE.NESTED;

pub const PENDINGMSG = enum(i32) {
    CANCELCALL = 0,
    WAITNOPROCESS = 1,
    WAITDEFPROCESS = 2,
};
pub const PENDINGMSG_CANCELCALL = PENDINGMSG.CANCELCALL;
pub const PENDINGMSG_WAITNOPROCESS = PENDINGMSG.WAITNOPROCESS;
pub const PENDINGMSG_WAITDEFPROCESS = PENDINGMSG.WAITDEFPROCESS;

pub const INTERFACEINFO = extern struct {
    pUnk: ?*IUnknown,
    iid: Guid,
    wMethod: u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassActivator_Value = @import("../zig.zig").Guid.initString("00000140-0000-0000-c000-000000000046");
pub const IID_IClassActivator = &IID_IClassActivator_Value;
pub const IClassActivator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassObject: fn(
            self: *const IClassActivator,
            rclsid: ?*const Guid,
            dwClassContext: u32,
            locale: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClassActivator_GetClassObject(self: *const T, rclsid: ?*const Guid, dwClassContext: u32, locale: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClassActivator.VTable, self.vtable).GetClassObject(@ptrCast(*const IClassActivator, self), rclsid, dwClassContext, locale, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProgressNotify_Value = @import("../zig.zig").Guid.initString("a9d758a0-4617-11cf-95fc-00aa00680db4");
pub const IID_IProgressNotify = &IID_IProgressNotify_Value;
pub const IProgressNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnProgress: fn(
            self: *const IProgressNotify,
            dwProgressCurrent: u32,
            dwProgressMaximum: u32,
            fAccurate: BOOL,
            fOwner: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressNotify_OnProgress(self: *const T, dwProgressCurrent: u32, dwProgressMaximum: u32, fAccurate: BOOL, fOwner: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressNotify.VTable, self.vtable).OnProgress(@ptrCast(*const IProgressNotify, self), dwProgressCurrent, dwProgressMaximum, fAccurate, fOwner);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const StorageLayout = extern struct {
    LayoutType: u32,
    pwcsElementName: ?PWSTR,
    cOffset: LARGE_INTEGER,
    cBytes: LARGE_INTEGER,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBlockingLock_Value = @import("../zig.zig").Guid.initString("30f3d47a-6447-11d1-8e3c-00c04fb9386d");
pub const IID_IBlockingLock = &IID_IBlockingLock_Value;
pub const IBlockingLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Lock: fn(
            self: *const IBlockingLock,
            dwTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unlock: fn(
            self: *const IBlockingLock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockingLock_Lock(self: *const T, dwTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockingLock.VTable, self.vtable).Lock(@ptrCast(*const IBlockingLock, self), dwTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockingLock_Unlock(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockingLock.VTable, self.vtable).Unlock(@ptrCast(*const IBlockingLock, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITimeAndNoticeControl_Value = @import("../zig.zig").Guid.initString("bc0bf6ae-8878-11d1-83e9-00c04fc2c6d4");
pub const IID_ITimeAndNoticeControl = &IID_ITimeAndNoticeControl_Value;
pub const ITimeAndNoticeControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SuppressChanges: fn(
            self: *const ITimeAndNoticeControl,
            res1: u32,
            res2: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimeAndNoticeControl_SuppressChanges(self: *const T, res1: u32, res2: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITimeAndNoticeControl.VTable, self.vtable).SuppressChanges(@ptrCast(*const ITimeAndNoticeControl, self), res1, res2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOplockStorage_Value = @import("../zig.zig").Guid.initString("8d19c834-8879-11d1-83e9-00c04fc2c6d4");
pub const IID_IOplockStorage = &IID_IOplockStorage_Value;
pub const IOplockStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStorageEx: fn(
            self: *const IOplockStorage,
            pwcsName: ?[*:0]const u16,
            grfMode: u32,
            stgfmt: u32,
            grfAttrs: u32,
            riid: ?*const Guid,
            ppstgOpen: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenStorageEx: fn(
            self: *const IOplockStorage,
            pwcsName: ?[*:0]const u16,
            grfMode: u32,
            stgfmt: u32,
            grfAttrs: u32,
            riid: ?*const Guid,
            ppstgOpen: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOplockStorage_CreateStorageEx(self: *const T, pwcsName: ?[*:0]const u16, grfMode: u32, stgfmt: u32, grfAttrs: u32, riid: ?*const Guid, ppstgOpen: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOplockStorage.VTable, self.vtable).CreateStorageEx(@ptrCast(*const IOplockStorage, self), pwcsName, grfMode, stgfmt, grfAttrs, riid, ppstgOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOplockStorage_OpenStorageEx(self: *const T, pwcsName: ?[*:0]const u16, grfMode: u32, stgfmt: u32, grfAttrs: u32, riid: ?*const Guid, ppstgOpen: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOplockStorage.VTable, self.vtable).OpenStorageEx(@ptrCast(*const IOplockStorage, self), pwcsName, grfMode, stgfmt, grfAttrs, riid, ppstgOpen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlMon_Value = @import("../zig.zig").Guid.initString("00000026-0000-0000-c000-000000000046");
pub const IID_IUrlMon = &IID_IUrlMon_Value;
pub const IUrlMon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AsyncGetClassBits: fn(
            self: *const IUrlMon,
            rclsid: ?*const Guid,
            pszTYPE: ?[*:0]const u16,
            pszExt: ?[*:0]const u16,
            dwFileVersionMS: u32,
            dwFileVersionLS: u32,
            pszCodeBase: ?[*:0]const u16,
            pbc: ?*IBindCtx,
            dwClassContext: u32,
            riid: ?*const Guid,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlMon_AsyncGetClassBits(self: *const T, rclsid: ?*const Guid, pszTYPE: ?[*:0]const u16, pszExt: ?[*:0]const u16, dwFileVersionMS: u32, dwFileVersionLS: u32, pszCodeBase: ?[*:0]const u16, pbc: ?*IBindCtx, dwClassContext: u32, riid: ?*const Guid, flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlMon.VTable, self.vtable).AsyncGetClassBits(@ptrCast(*const IUrlMon, self), rclsid, pszTYPE, pszExt, dwFileVersionMS, dwFileVersionLS, pszCodeBase, pbc, dwClassContext, riid, flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IForegroundTransfer_Value = @import("../zig.zig").Guid.initString("00000145-0000-0000-c000-000000000046");
pub const IID_IForegroundTransfer = &IID_IForegroundTransfer_Value;
pub const IForegroundTransfer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllowForegroundTransfer: fn(
            self: *const IForegroundTransfer,
            lpvReserved: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IForegroundTransfer_AllowForegroundTransfer(self: *const T, lpvReserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IForegroundTransfer.VTable, self.vtable).AllowForegroundTransfer(@ptrCast(*const IForegroundTransfer, self), lpvReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ApplicationType = enum(i32) {
    ServerApplication = 0,
    LibraryApplication = 1,
};
pub const ServerApplication = ApplicationType.ServerApplication;
pub const LibraryApplication = ApplicationType.LibraryApplication;

pub const ShutdownType = enum(i32) {
    IdleShutdown = 0,
    ForcedShutdown = 1,
};
pub const IdleShutdown = ShutdownType.IdleShutdown;
pub const ForcedShutdown = ShutdownType.ForcedShutdown;

// TODO: this type is limited to platform 'windows5.0'
const IID_IProcessLock_Value = @import("../zig.zig").Guid.initString("000001d5-0000-0000-c000-000000000046");
pub const IID_IProcessLock = &IID_IProcessLock_Value;
pub const IProcessLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefOnProcess: fn(
            self: *const IProcessLock,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        ReleaseRefOnProcess: fn(
            self: *const IProcessLock,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessLock_AddRefOnProcess(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IProcessLock.VTable, self.vtable).AddRefOnProcess(@ptrCast(*const IProcessLock, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessLock_ReleaseRefOnProcess(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IProcessLock.VTable, self.vtable).ReleaseRefOnProcess(@ptrCast(*const IProcessLock, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISurrogateService_Value = @import("../zig.zig").Guid.initString("000001d4-0000-0000-c000-000000000046");
pub const IID_ISurrogateService = &IID_ISurrogateService_Value;
pub const ISurrogateService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const ISurrogateService,
            rguidProcessID: ?*const Guid,
            pProcessLock: ?*IProcessLock,
            pfApplicationAware: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplicationLaunch: fn(
            self: *const ISurrogateService,
            rguidApplID: ?*const Guid,
            appType: ApplicationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplicationFree: fn(
            self: *const ISurrogateService,
            rguidApplID: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CatalogRefresh: fn(
            self: *const ISurrogateService,
            ulReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessShutdown: fn(
            self: *const ISurrogateService,
            shutdownType: ShutdownType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_Init(self: *const T, rguidProcessID: ?*const Guid, pProcessLock: ?*IProcessLock, pfApplicationAware: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).Init(@ptrCast(*const ISurrogateService, self), rguidProcessID, pProcessLock, pfApplicationAware);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_ApplicationLaunch(self: *const T, rguidApplID: ?*const Guid, appType: ApplicationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).ApplicationLaunch(@ptrCast(*const ISurrogateService, self), rguidApplID, appType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_ApplicationFree(self: *const T, rguidApplID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).ApplicationFree(@ptrCast(*const ISurrogateService, self), rguidApplID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_CatalogRefresh(self: *const T, ulReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).CatalogRefresh(@ptrCast(*const ISurrogateService, self), ulReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurrogateService_ProcessShutdown(self: *const T, shutdownType: ShutdownType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurrogateService.VTable, self.vtable).ProcessShutdown(@ptrCast(*const ISurrogateService, self), shutdownType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInitializeSpy_Value = @import("../zig.zig").Guid.initString("00000034-0000-0000-c000-000000000046");
pub const IID_IInitializeSpy = &IID_IInitializeSpy_Value;
pub const IInitializeSpy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreInitialize: fn(
            self: *const IInitializeSpy,
            dwCoInit: u32,
            dwCurThreadAptRefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostInitialize: fn(
            self: *const IInitializeSpy,
            hrCoInit: HRESULT,
            dwCoInit: u32,
            dwNewThreadAptRefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUninitialize: fn(
            self: *const IInitializeSpy,
            dwCurThreadAptRefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUninitialize: fn(
            self: *const IInitializeSpy,
            dwNewThreadAptRefs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeSpy_PreInitialize(self: *const T, dwCoInit: u32, dwCurThreadAptRefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeSpy.VTable, self.vtable).PreInitialize(@ptrCast(*const IInitializeSpy, self), dwCoInit, dwCurThreadAptRefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeSpy_PostInitialize(self: *const T, hrCoInit: HRESULT, dwCoInit: u32, dwNewThreadAptRefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeSpy.VTable, self.vtable).PostInitialize(@ptrCast(*const IInitializeSpy, self), hrCoInit, dwCoInit, dwNewThreadAptRefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeSpy_PreUninitialize(self: *const T, dwCurThreadAptRefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeSpy.VTable, self.vtable).PreUninitialize(@ptrCast(*const IInitializeSpy, self), dwCurThreadAptRefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeSpy_PostUninitialize(self: *const T, dwNewThreadAptRefs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeSpy.VTable, self.vtable).PostUninitialize(@ptrCast(*const IInitializeSpy, self), dwNewThreadAptRefs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COINIT = enum(u32) {
    APARTMENTTHREADED = 2,
    MULTITHREADED = 0,
    DISABLE_OLE1DDE = 4,
    SPEED_OVER_MEMORY = 8,
    _,
    pub fn initFlags(o: struct {
        APARTMENTTHREADED: u1 = 0,
        MULTITHREADED: u1 = 0,
        DISABLE_OLE1DDE: u1 = 0,
        SPEED_OVER_MEMORY: u1 = 0,
    }) COINIT {
        return @intToEnum(COINIT,
              (if (o.APARTMENTTHREADED == 1) @enumToInt(COINIT.APARTMENTTHREADED) else 0)
            | (if (o.MULTITHREADED == 1) @enumToInt(COINIT.MULTITHREADED) else 0)
            | (if (o.DISABLE_OLE1DDE == 1) @enumToInt(COINIT.DISABLE_OLE1DDE) else 0)
            | (if (o.SPEED_OVER_MEMORY == 1) @enumToInt(COINIT.SPEED_OVER_MEMORY) else 0)
        );
    }
};
pub const COINIT_APARTMENTTHREADED = COINIT.APARTMENTTHREADED;
pub const COINIT_MULTITHREADED = COINIT.MULTITHREADED;
pub const COINIT_DISABLE_OLE1DDE = COINIT.DISABLE_OLE1DDE;
pub const COINIT_SPEED_OVER_MEMORY = COINIT.SPEED_OVER_MEMORY;

pub const COMSD = enum(i32) {
    LAUNCHPERMISSIONS = 0,
    ACCESSPERMISSIONS = 1,
    LAUNCHRESTRICTIONS = 2,
    ACCESSRESTRICTIONS = 3,
};
pub const SD_LAUNCHPERMISSIONS = COMSD.LAUNCHPERMISSIONS;
pub const SD_ACCESSPERMISSIONS = COMSD.ACCESSPERMISSIONS;
pub const SD_LAUNCHRESTRICTIONS = COMSD.LAUNCHRESTRICTIONS;
pub const SD_ACCESSRESTRICTIONS = COMSD.ACCESSRESTRICTIONS;

const IID_IServiceProvider_Value = @import("../zig.zig").Guid.initString("6d5140c1-7436-11ce-8034-00aa006009fa");
pub const IID_IServiceProvider = &IID_IServiceProvider_Value;
pub const IServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryService: fn(
            self: *const IServiceProvider,
            guidService: ?*const Guid,
            riid: ?*const Guid,
            ppvObject: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceProvider_QueryService(self: *const T, guidService: ?*const Guid, riid: ?*const Guid, ppvObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServiceProvider.VTable, self.vtable).QueryService(@ptrCast(*const IServiceProvider, self), guidService, riid, ppvObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COWAIT_FLAGS = enum(i32) {
    DEFAULT = 0,
    WAITALL = 1,
    ALERTABLE = 2,
    INPUTAVAILABLE = 4,
    DISPATCH_CALLS = 8,
    DISPATCH_WINDOW_MESSAGES = 16,
};
pub const COWAIT_DEFAULT = COWAIT_FLAGS.DEFAULT;
pub const COWAIT_WAITALL = COWAIT_FLAGS.WAITALL;
pub const COWAIT_ALERTABLE = COWAIT_FLAGS.ALERTABLE;
pub const COWAIT_INPUTAVAILABLE = COWAIT_FLAGS.INPUTAVAILABLE;
pub const COWAIT_DISPATCH_CALLS = COWAIT_FLAGS.DISPATCH_CALLS;
pub const COWAIT_DISPATCH_WINDOW_MESSAGES = COWAIT_FLAGS.DISPATCH_WINDOW_MESSAGES;

pub const CWMO_FLAGS = enum(i32) {
    EFAULT = 0,
    ISPATCH_CALLS = 1,
    ISPATCH_WINDOW_MESSAGES = 2,
};
pub const CWMO_DEFAULT = CWMO_FLAGS.EFAULT;
pub const CWMO_DISPATCH_CALLS = CWMO_FLAGS.ISPATCH_CALLS;
pub const CWMO_DISPATCH_WINDOW_MESSAGES = CWMO_FLAGS.ISPATCH_WINDOW_MESSAGES;

pub const LPFNGETCLASSOBJECT = fn(
    param0: ?*const Guid,
    param1: ?*const Guid,
    param2: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPFNCANUNLOADNOW = fn(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumGUID_Value = @import("../zig.zig").Guid.initString("0002e000-0000-0000-c000-000000000046");
pub const IID_IEnumGUID = &IID_IEnumGUID_Value;
pub const IEnumGUID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumGUID,
            celt: u32,
            rgelt: [*]Guid,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumGUID,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumGUID,
            ppenum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGUID_Next(self: *const T, celt: u32, rgelt: [*]Guid, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGUID.VTable, self.vtable).Next(@ptrCast(*const IEnumGUID, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGUID_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGUID.VTable, self.vtable).Skip(@ptrCast(*const IEnumGUID, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGUID_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGUID.VTable, self.vtable).Reset(@ptrCast(*const IEnumGUID, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGUID_Clone(self: *const T, ppenum: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumGUID.VTable, self.vtable).Clone(@ptrCast(*const IEnumGUID, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CATEGORYINFO = extern struct {
    catid: Guid,
    lcid: u32,
    szDescription: [128]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumCATEGORYINFO_Value = @import("../zig.zig").Guid.initString("0002e011-0000-0000-c000-000000000046");
pub const IID_IEnumCATEGORYINFO = &IID_IEnumCATEGORYINFO_Value;
pub const IEnumCATEGORYINFO = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumCATEGORYINFO,
            celt: u32,
            rgelt: [*]CATEGORYINFO,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumCATEGORYINFO,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumCATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumCATEGORYINFO,
            ppenum: ?*?*IEnumCATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCATEGORYINFO_Next(self: *const T, celt: u32, rgelt: [*]CATEGORYINFO, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCATEGORYINFO.VTable, self.vtable).Next(@ptrCast(*const IEnumCATEGORYINFO, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCATEGORYINFO_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCATEGORYINFO.VTable, self.vtable).Skip(@ptrCast(*const IEnumCATEGORYINFO, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCATEGORYINFO_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCATEGORYINFO.VTable, self.vtable).Reset(@ptrCast(*const IEnumCATEGORYINFO, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumCATEGORYINFO_Clone(self: *const T, ppenum: ?*?*IEnumCATEGORYINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumCATEGORYINFO.VTable, self.vtable).Clone(@ptrCast(*const IEnumCATEGORYINFO, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICatRegister_Value = @import("../zig.zig").Guid.initString("0002e012-0000-0000-c000-000000000046");
pub const IID_ICatRegister = &IID_ICatRegister_Value;
pub const ICatRegister = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCategories: fn(
            self: *const ICatRegister,
            cCategories: u32,
            rgCategoryInfo: [*]CATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterCategories: fn(
            self: *const ICatRegister,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterClassImplCategories: fn(
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterClassImplCategories: fn(
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterClassReqCategories: fn(
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterClassReqCategories: fn(
            self: *const ICatRegister,
            rclsid: ?*const Guid,
            cCategories: u32,
            rgcatid: [*]Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_RegisterCategories(self: *const T, cCategories: u32, rgCategoryInfo: [*]CATEGORYINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).RegisterCategories(@ptrCast(*const ICatRegister, self), cCategories, rgCategoryInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_UnRegisterCategories(self: *const T, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).UnRegisterCategories(@ptrCast(*const ICatRegister, self), cCategories, rgcatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_RegisterClassImplCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).RegisterClassImplCategories(@ptrCast(*const ICatRegister, self), rclsid, cCategories, rgcatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_UnRegisterClassImplCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).UnRegisterClassImplCategories(@ptrCast(*const ICatRegister, self), rclsid, cCategories, rgcatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_RegisterClassReqCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).RegisterClassReqCategories(@ptrCast(*const ICatRegister, self), rclsid, cCategories, rgcatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatRegister_UnRegisterClassReqCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatRegister.VTable, self.vtable).UnRegisterClassReqCategories(@ptrCast(*const ICatRegister, self), rclsid, cCategories, rgcatid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICatInformation_Value = @import("../zig.zig").Guid.initString("0002e013-0000-0000-c000-000000000046");
pub const IID_ICatInformation = &IID_ICatInformation_Value;
pub const ICatInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumCategories: fn(
            self: *const ICatInformation,
            lcid: u32,
            ppenumCategoryInfo: ?*?*IEnumCATEGORYINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategoryDesc: fn(
            self: *const ICatInformation,
            rcatid: ?*Guid,
            lcid: u32,
            pszDesc: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumClassesOfCategories: fn(
            self: *const ICatInformation,
            cImplemented: u32,
            rgcatidImpl: [*]const Guid,
            cRequired: u32,
            rgcatidReq: [*]const Guid,
            ppenumClsid: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsClassOfCategories: fn(
            self: *const ICatInformation,
            rclsid: ?*const Guid,
            cImplemented: u32,
            rgcatidImpl: [*]const Guid,
            cRequired: u32,
            rgcatidReq: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumImplCategoriesOfClass: fn(
            self: *const ICatInformation,
            rclsid: ?*const Guid,
            ppenumCatid: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumReqCategoriesOfClass: fn(
            self: *const ICatInformation,
            rclsid: ?*const Guid,
            ppenumCatid: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_EnumCategories(self: *const T, lcid: u32, ppenumCategoryInfo: ?*?*IEnumCATEGORYINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).EnumCategories(@ptrCast(*const ICatInformation, self), lcid, ppenumCategoryInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_GetCategoryDesc(self: *const T, rcatid: ?*Guid, lcid: u32, pszDesc: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).GetCategoryDesc(@ptrCast(*const ICatInformation, self), rcatid, lcid, pszDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_EnumClassesOfCategories(self: *const T, cImplemented: u32, rgcatidImpl: [*]const Guid, cRequired: u32, rgcatidReq: [*]const Guid, ppenumClsid: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).EnumClassesOfCategories(@ptrCast(*const ICatInformation, self), cImplemented, rgcatidImpl, cRequired, rgcatidReq, ppenumClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_IsClassOfCategories(self: *const T, rclsid: ?*const Guid, cImplemented: u32, rgcatidImpl: [*]const Guid, cRequired: u32, rgcatidReq: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).IsClassOfCategories(@ptrCast(*const ICatInformation, self), rclsid, cImplemented, rgcatidImpl, cRequired, rgcatidReq);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_EnumImplCategoriesOfClass(self: *const T, rclsid: ?*const Guid, ppenumCatid: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).EnumImplCategoriesOfClass(@ptrCast(*const ICatInformation, self), rclsid, ppenumCatid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatInformation_EnumReqCategoriesOfClass(self: *const T, rclsid: ?*const Guid, ppenumCatid: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatInformation.VTable, self.vtable).EnumReqCategoriesOfClass(@ptrCast(*const ICatInformation, self), rclsid, ppenumCatid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ComCallData = extern struct {
    dwDispid: u32,
    dwReserved: u32,
    pUserDefined: ?*anyopaque,
};

pub const PFNCONTEXTCALL = fn(
    pParam: ?*ComCallData,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
const IID_IContextCallback_Value = @import("../zig.zig").Guid.initString("000001da-0000-0000-c000-000000000046");
pub const IID_IContextCallback = &IID_IContextCallback_Value;
pub const IContextCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ContextCallback: fn(
            self: *const IContextCallback,
            pfnCallback: ?PFNCONTEXTCALL,
            pParam: ?*ComCallData,
            riid: ?*const Guid,
            iMethod: i32,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextCallback_ContextCallback(self: *const T, pfnCallback: ?PFNCONTEXTCALL, pParam: ?*ComCallData, riid: ?*const Guid, iMethod: i32, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextCallback.VTable, self.vtable).ContextCallback(@ptrCast(*const IContextCallback, self), pfnCallback, pParam, riid, iMethod, pUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBinding_Value = @import("../zig.zig").Guid.initString("79eac9c0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBinding = &IID_IBinding_Value;
pub const IBinding = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Abort: fn(
            self: *const IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPriority: fn(
            self: *const IBinding,
            nPriority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: fn(
            self: *const IBinding,
            pnPriority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindResult: fn(
            self: *const IBinding,
            pclsidProtocol: ?*Guid,
            pdwResult: ?*u32,
            pszResult: ?*?PWSTR,
            pdwReserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).Abort(@ptrCast(*const IBinding, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_Suspend(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).Suspend(@ptrCast(*const IBinding, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).Resume(@ptrCast(*const IBinding, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_SetPriority(self: *const T, nPriority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).SetPriority(@ptrCast(*const IBinding, self), nPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_GetPriority(self: *const T, pnPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).GetPriority(@ptrCast(*const IBinding, self), pnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBinding_GetBindResult(self: *const T, pclsidProtocol: ?*Guid, pdwResult: ?*u32, pszResult: ?*?PWSTR, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBinding.VTable, self.vtable).GetBindResult(@ptrCast(*const IBinding, self), pclsidProtocol, pdwResult, pszResult, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BINDINFOF = enum(i32) {
    STGMEDDATA = 1,
    DEXTRAINFO = 2,
};
pub const BINDINFOF_URLENCODESTGMEDDATA = BINDINFOF.STGMEDDATA;
pub const BINDINFOF_URLENCODEDEXTRAINFO = BINDINFOF.DEXTRAINFO;

pub const BINDINFO = extern struct {
    cbSize: u32,
    szExtraInfo: ?PWSTR,
    stgmedData: STGMEDIUM,
    grfBindInfoF: u32,
    dwBindVerb: u32,
    szCustomVerb: ?PWSTR,
    cbstgmedData: u32,
    dwOptions: u32,
    dwOptionsFlags: u32,
    dwCodePage: u32,
    securityAttributes: SECURITY_ATTRIBUTES,
    iid: Guid,
    pUnk: ?*IUnknown,
    dwReserved: u32,
};

const IID_IBindStatusCallback_Value = @import("../zig.zig").Guid.initString("79eac9c1-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBindStatusCallback = &IID_IBindStatusCallback_Value;
pub const IBindStatusCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartBinding: fn(
            self: *const IBindStatusCallback,
            dwReserved: u32,
            pib: ?*IBinding,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: fn(
            self: *const IBindStatusCallback,
            pnPriority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLowResource: fn(
            self: *const IBindStatusCallback,
            reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnProgress: fn(
            self: *const IBindStatusCallback,
            ulProgress: u32,
            ulProgressMax: u32,
            ulStatusCode: u32,
            szStatusText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStopBinding: fn(
            self: *const IBindStatusCallback,
            hresult: HRESULT,
            szError: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindInfo: fn(
            self: *const IBindStatusCallback,
            grfBINDF: ?*u32,
            pbindinfo: ?*BINDINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDataAvailable: fn(
            self: *const IBindStatusCallback,
            grfBSCF: u32,
            dwSize: u32,
            pformatetc: ?*FORMATETC,
            pstgmed: ?*STGMEDIUM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnObjectAvailable: fn(
            self: *const IBindStatusCallback,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnStartBinding(self: *const T, dwReserved: u32, pib: ?*IBinding) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnStartBinding(@ptrCast(*const IBindStatusCallback, self), dwReserved, pib);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_GetPriority(self: *const T, pnPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).GetPriority(@ptrCast(*const IBindStatusCallback, self), pnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnLowResource(self: *const T, reserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnLowResource(@ptrCast(*const IBindStatusCallback, self), reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnProgress(self: *const T, ulProgress: u32, ulProgressMax: u32, ulStatusCode: u32, szStatusText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnProgress(@ptrCast(*const IBindStatusCallback, self), ulProgress, ulProgressMax, ulStatusCode, szStatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnStopBinding(self: *const T, hresult: HRESULT, szError: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnStopBinding(@ptrCast(*const IBindStatusCallback, self), hresult, szError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_GetBindInfo(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).GetBindInfo(@ptrCast(*const IBindStatusCallback, self), grfBINDF, pbindinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnDataAvailable(self: *const T, grfBSCF: u32, dwSize: u32, pformatetc: ?*FORMATETC, pstgmed: ?*STGMEDIUM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnDataAvailable(@ptrCast(*const IBindStatusCallback, self), grfBSCF, dwSize, pformatetc, pstgmed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallback_OnObjectAvailable(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallback.VTable, self.vtable).OnObjectAvailable(@ptrCast(*const IBindStatusCallback, self), riid, punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindStatusCallbackEx_Value = @import("../zig.zig").Guid.initString("aaa74ef9-8ee7-4659-88d9-f8c504da73cc");
pub const IID_IBindStatusCallbackEx = &IID_IBindStatusCallbackEx_Value;
pub const IBindStatusCallbackEx = extern struct {
    pub const VTable = extern struct {
        base: IBindStatusCallback.VTable,
        GetBindInfoEx: fn(
            self: *const IBindStatusCallbackEx,
            grfBINDF: ?*u32,
            pbindinfo: ?*BINDINFO,
            grfBINDF2: ?*u32,
            pdwReserved: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBindStatusCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindStatusCallbackEx_GetBindInfoEx(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO, grfBINDF2: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindStatusCallbackEx.VTable, self.vtable).GetBindInfoEx(@ptrCast(*const IBindStatusCallbackEx, self), grfBINDF, pbindinfo, grfBINDF2, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAuthenticate_Value = @import("../zig.zig").Guid.initString("79eac9d0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IAuthenticate = &IID_IAuthenticate_Value;
pub const IAuthenticate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Authenticate: fn(
            self: *const IAuthenticate,
            phwnd: ?*?HWND,
            pszUsername: ?*?PWSTR,
            pszPassword: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAuthenticate_Authenticate(self: *const T, phwnd: ?*?HWND, pszUsername: ?*?PWSTR, pszPassword: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAuthenticate.VTable, self.vtable).Authenticate(@ptrCast(*const IAuthenticate, self), phwnd, pszUsername, pszPassword);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AUTHENTICATEINFO = extern struct {
    dwFlags: u32,
    dwReserved: u32,
};

const IID_IAuthenticateEx_Value = @import("../zig.zig").Guid.initString("2ad1edaf-d83d-48b5-9adf-03dbe19f53bd");
pub const IID_IAuthenticateEx = &IID_IAuthenticateEx_Value;
pub const IAuthenticateEx = extern struct {
    pub const VTable = extern struct {
        base: IAuthenticate.VTable,
        AuthenticateEx: fn(
            self: *const IAuthenticateEx,
            phwnd: ?*?HWND,
            pszUsername: ?*?PWSTR,
            pszPassword: ?*?PWSTR,
            pauthinfo: ?*AUTHENTICATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAuthenticate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAuthenticateEx_AuthenticateEx(self: *const T, phwnd: ?*?HWND, pszUsername: ?*?PWSTR, pszPassword: ?*?PWSTR, pauthinfo: ?*AUTHENTICATEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAuthenticateEx.VTable, self.vtable).AuthenticateEx(@ptrCast(*const IAuthenticateEx, self), phwnd, pszUsername, pszPassword, pauthinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Uri_PROPERTY = enum(i32) {
    ABSOLUTE_URI = 0,
    // STRING_START = 0, this enum value conflicts with ABSOLUTE_URI
    AUTHORITY = 1,
    DISPLAY_URI = 2,
    DOMAIN = 3,
    EXTENSION = 4,
    FRAGMENT = 5,
    HOST = 6,
    PASSWORD = 7,
    PATH = 8,
    PATH_AND_QUERY = 9,
    QUERY = 10,
    RAW_URI = 11,
    SCHEME_NAME = 12,
    USER_INFO = 13,
    USER_NAME = 14,
    // STRING_LAST = 14, this enum value conflicts with USER_NAME
    HOST_TYPE = 15,
    // DWORD_START = 15, this enum value conflicts with HOST_TYPE
    PORT = 16,
    SCHEME = 17,
    ZONE = 18,
    // DWORD_LAST = 18, this enum value conflicts with ZONE
};
pub const Uri_PROPERTY_ABSOLUTE_URI = Uri_PROPERTY.ABSOLUTE_URI;
pub const Uri_PROPERTY_STRING_START = Uri_PROPERTY.ABSOLUTE_URI;
pub const Uri_PROPERTY_AUTHORITY = Uri_PROPERTY.AUTHORITY;
pub const Uri_PROPERTY_DISPLAY_URI = Uri_PROPERTY.DISPLAY_URI;
pub const Uri_PROPERTY_DOMAIN = Uri_PROPERTY.DOMAIN;
pub const Uri_PROPERTY_EXTENSION = Uri_PROPERTY.EXTENSION;
pub const Uri_PROPERTY_FRAGMENT = Uri_PROPERTY.FRAGMENT;
pub const Uri_PROPERTY_HOST = Uri_PROPERTY.HOST;
pub const Uri_PROPERTY_PASSWORD = Uri_PROPERTY.PASSWORD;
pub const Uri_PROPERTY_PATH = Uri_PROPERTY.PATH;
pub const Uri_PROPERTY_PATH_AND_QUERY = Uri_PROPERTY.PATH_AND_QUERY;
pub const Uri_PROPERTY_QUERY = Uri_PROPERTY.QUERY;
pub const Uri_PROPERTY_RAW_URI = Uri_PROPERTY.RAW_URI;
pub const Uri_PROPERTY_SCHEME_NAME = Uri_PROPERTY.SCHEME_NAME;
pub const Uri_PROPERTY_USER_INFO = Uri_PROPERTY.USER_INFO;
pub const Uri_PROPERTY_USER_NAME = Uri_PROPERTY.USER_NAME;
pub const Uri_PROPERTY_STRING_LAST = Uri_PROPERTY.USER_NAME;
pub const Uri_PROPERTY_HOST_TYPE = Uri_PROPERTY.HOST_TYPE;
pub const Uri_PROPERTY_DWORD_START = Uri_PROPERTY.HOST_TYPE;
pub const Uri_PROPERTY_PORT = Uri_PROPERTY.PORT;
pub const Uri_PROPERTY_SCHEME = Uri_PROPERTY.SCHEME;
pub const Uri_PROPERTY_ZONE = Uri_PROPERTY.ZONE;
pub const Uri_PROPERTY_DWORD_LAST = Uri_PROPERTY.ZONE;

const IID_IUri_Value = @import("../zig.zig").Guid.initString("a39ee748-6a27-4817-a6f2-13914bef5890");
pub const IID_IUri = &IID_IUri_Value;
pub const IUri = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyBSTR: fn(
            self: *const IUri,
            uriProp: Uri_PROPERTY,
            pbstrProperty: ?*?BSTR,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyLength: fn(
            self: *const IUri,
            uriProp: Uri_PROPERTY,
            pcchProperty: ?*u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyDWORD: fn(
            self: *const IUri,
            uriProp: Uri_PROPERTY,
            pdwProperty: ?*u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasProperty: fn(
            self: *const IUri,
            uriProp: Uri_PROPERTY,
            pfHasProperty: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAbsoluteUri: fn(
            self: *const IUri,
            pbstrAbsoluteUri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAuthority: fn(
            self: *const IUri,
            pbstrAuthority: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayUri: fn(
            self: *const IUri,
            pbstrDisplayString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDomain: fn(
            self: *const IUri,
            pbstrDomain: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtension: fn(
            self: *const IUri,
            pbstrExtension: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFragment: fn(
            self: *const IUri,
            pbstrFragment: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHost: fn(
            self: *const IUri,
            pbstrHost: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassword: fn(
            self: *const IUri,
            pbstrPassword: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: fn(
            self: *const IUri,
            pbstrPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPathAndQuery: fn(
            self: *const IUri,
            pbstrPathAndQuery: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuery: fn(
            self: *const IUri,
            pbstrQuery: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawUri: fn(
            self: *const IUri,
            pbstrRawUri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemeName: fn(
            self: *const IUri,
            pbstrSchemeName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserInfo: fn(
            self: *const IUri,
            pbstrUserInfo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserName: fn(
            self: *const IUri,
            pbstrUserName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHostType: fn(
            self: *const IUri,
            pdwHostType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPort: fn(
            self: *const IUri,
            pdwPort: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScheme: fn(
            self: *const IUri,
            pdwScheme: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZone: fn(
            self: *const IUri,
            pdwZone: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const IUri,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IUri,
            pUri: ?*IUri,
            pfEqual: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPropertyBSTR(self: *const T, uriProp: Uri_PROPERTY, pbstrProperty: ?*?BSTR, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPropertyBSTR(@ptrCast(*const IUri, self), uriProp, pbstrProperty, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPropertyLength(self: *const T, uriProp: Uri_PROPERTY, pcchProperty: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPropertyLength(@ptrCast(*const IUri, self), uriProp, pcchProperty, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPropertyDWORD(self: *const T, uriProp: Uri_PROPERTY, pdwProperty: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPropertyDWORD(@ptrCast(*const IUri, self), uriProp, pdwProperty, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_HasProperty(self: *const T, uriProp: Uri_PROPERTY, pfHasProperty: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).HasProperty(@ptrCast(*const IUri, self), uriProp, pfHasProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetAbsoluteUri(self: *const T, pbstrAbsoluteUri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetAbsoluteUri(@ptrCast(*const IUri, self), pbstrAbsoluteUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetAuthority(self: *const T, pbstrAuthority: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetAuthority(@ptrCast(*const IUri, self), pbstrAuthority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetDisplayUri(self: *const T, pbstrDisplayString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetDisplayUri(@ptrCast(*const IUri, self), pbstrDisplayString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetDomain(self: *const T, pbstrDomain: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetDomain(@ptrCast(*const IUri, self), pbstrDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetExtension(self: *const T, pbstrExtension: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetExtension(@ptrCast(*const IUri, self), pbstrExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetFragment(self: *const T, pbstrFragment: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetFragment(@ptrCast(*const IUri, self), pbstrFragment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetHost(self: *const T, pbstrHost: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetHost(@ptrCast(*const IUri, self), pbstrHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPassword(self: *const T, pbstrPassword: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPassword(@ptrCast(*const IUri, self), pbstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPath(self: *const T, pbstrPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPath(@ptrCast(*const IUri, self), pbstrPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPathAndQuery(self: *const T, pbstrPathAndQuery: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPathAndQuery(@ptrCast(*const IUri, self), pbstrPathAndQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetQuery(self: *const T, pbstrQuery: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetQuery(@ptrCast(*const IUri, self), pbstrQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetRawUri(self: *const T, pbstrRawUri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetRawUri(@ptrCast(*const IUri, self), pbstrRawUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetSchemeName(self: *const T, pbstrSchemeName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetSchemeName(@ptrCast(*const IUri, self), pbstrSchemeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetUserInfo(self: *const T, pbstrUserInfo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetUserInfo(@ptrCast(*const IUri, self), pbstrUserInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetUserName(self: *const T, pbstrUserName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetUserName(@ptrCast(*const IUri, self), pbstrUserName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetHostType(self: *const T, pdwHostType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetHostType(@ptrCast(*const IUri, self), pdwHostType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetPort(self: *const T, pdwPort: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetPort(@ptrCast(*const IUri, self), pdwPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetScheme(self: *const T, pdwScheme: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetScheme(@ptrCast(*const IUri, self), pdwScheme);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetZone(self: *const T, pdwZone: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetZone(@ptrCast(*const IUri, self), pdwZone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_GetProperties(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).GetProperties(@ptrCast(*const IUri, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUri_IsEqual(self: *const T, pUri: ?*IUri, pfEqual: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUri.VTable, self.vtable).IsEqual(@ptrCast(*const IUri, self), pUri, pfEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUriBuilder_Value = @import("../zig.zig").Guid.initString("4221b2e1-8955-46c0-bd5b-de9897565de7");
pub const IID_IUriBuilder = &IID_IUriBuilder_Value;
pub const IUriBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateUriSimple: fn(
            self: *const IUriBuilder,
            dwAllowEncodingPropertyMask: u32,
            dwReserved: usize,
            ppIUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUri: fn(
            self: *const IUriBuilder,
            dwCreateFlags: u32,
            dwAllowEncodingPropertyMask: u32,
            dwReserved: usize,
            ppIUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUriWithFlags: fn(
            self: *const IUriBuilder,
            dwCreateFlags: u32,
            dwUriBuilderFlags: u32,
            dwAllowEncodingPropertyMask: u32,
            dwReserved: usize,
            ppIUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIUri: fn(
            self: *const IUriBuilder,
            ppIUri: ?*?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIUri: fn(
            self: *const IUriBuilder,
            pIUri: ?*IUri,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFragment: fn(
            self: *const IUriBuilder,
            pcchFragment: ?*u32,
            ppwzFragment: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHost: fn(
            self: *const IUriBuilder,
            pcchHost: ?*u32,
            ppwzHost: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassword: fn(
            self: *const IUriBuilder,
            pcchPassword: ?*u32,
            ppwzPassword: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: fn(
            self: *const IUriBuilder,
            pcchPath: ?*u32,
            ppwzPath: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPort: fn(
            self: *const IUriBuilder,
            pfHasPort: ?*BOOL,
            pdwPort: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuery: fn(
            self: *const IUriBuilder,
            pcchQuery: ?*u32,
            ppwzQuery: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemeName: fn(
            self: *const IUriBuilder,
            pcchSchemeName: ?*u32,
            ppwzSchemeName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserName: fn(
            self: *const IUriBuilder,
            pcchUserName: ?*u32,
            ppwzUserName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFragment: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHost: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPassword: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPath: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPort: fn(
            self: *const IUriBuilder,
            fHasPort: BOOL,
            dwNewValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuery: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSchemeName: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUserName: fn(
            self: *const IUriBuilder,
            pwzNewValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProperties: fn(
            self: *const IUriBuilder,
            dwPropertyMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasBeenModified: fn(
            self: *const IUriBuilder,
            pfModified: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_CreateUriSimple(self: *const T, dwAllowEncodingPropertyMask: u32, dwReserved: usize, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).CreateUriSimple(@ptrCast(*const IUriBuilder, self), dwAllowEncodingPropertyMask, dwReserved, ppIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_CreateUri(self: *const T, dwCreateFlags: u32, dwAllowEncodingPropertyMask: u32, dwReserved: usize, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).CreateUri(@ptrCast(*const IUriBuilder, self), dwCreateFlags, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_CreateUriWithFlags(self: *const T, dwCreateFlags: u32, dwUriBuilderFlags: u32, dwAllowEncodingPropertyMask: u32, dwReserved: usize, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).CreateUriWithFlags(@ptrCast(*const IUriBuilder, self), dwCreateFlags, dwUriBuilderFlags, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetIUri(self: *const T, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetIUri(@ptrCast(*const IUriBuilder, self), ppIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetIUri(self: *const T, pIUri: ?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetIUri(@ptrCast(*const IUriBuilder, self), pIUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetFragment(self: *const T, pcchFragment: ?*u32, ppwzFragment: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetFragment(@ptrCast(*const IUriBuilder, self), pcchFragment, ppwzFragment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetHost(self: *const T, pcchHost: ?*u32, ppwzHost: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetHost(@ptrCast(*const IUriBuilder, self), pcchHost, ppwzHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetPassword(self: *const T, pcchPassword: ?*u32, ppwzPassword: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetPassword(@ptrCast(*const IUriBuilder, self), pcchPassword, ppwzPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetPath(self: *const T, pcchPath: ?*u32, ppwzPath: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetPath(@ptrCast(*const IUriBuilder, self), pcchPath, ppwzPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetPort(self: *const T, pfHasPort: ?*BOOL, pdwPort: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetPort(@ptrCast(*const IUriBuilder, self), pfHasPort, pdwPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetQuery(self: *const T, pcchQuery: ?*u32, ppwzQuery: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetQuery(@ptrCast(*const IUriBuilder, self), pcchQuery, ppwzQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetSchemeName(self: *const T, pcchSchemeName: ?*u32, ppwzSchemeName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetSchemeName(@ptrCast(*const IUriBuilder, self), pcchSchemeName, ppwzSchemeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_GetUserName(self: *const T, pcchUserName: ?*u32, ppwzUserName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).GetUserName(@ptrCast(*const IUriBuilder, self), pcchUserName, ppwzUserName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetFragment(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetFragment(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetHost(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetHost(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetPassword(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetPassword(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetPath(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetPath(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetPort(self: *const T, fHasPort: BOOL, dwNewValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetPort(@ptrCast(*const IUriBuilder, self), fHasPort, dwNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetQuery(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetQuery(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetSchemeName(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetSchemeName(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_SetUserName(self: *const T, pwzNewValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).SetUserName(@ptrCast(*const IUriBuilder, self), pwzNewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_RemoveProperties(self: *const T, dwPropertyMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).RemoveProperties(@ptrCast(*const IUriBuilder, self), dwPropertyMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilder_HasBeenModified(self: *const T, pfModified: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilder.VTable, self.vtable).HasBeenModified(@ptrCast(*const IUriBuilder, self), pfModified);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindHost_Value = @import("../zig.zig").Guid.initString("fc4801a1-2ba9-11cf-a229-00aa003d7352");
pub const IID_IBindHost = &IID_IBindHost_Value;
pub const IBindHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMoniker: fn(
            self: *const IBindHost,
            szName: ?PWSTR,
            pBC: ?*IBindCtx,
            ppmk: ?*?*IMoniker,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MonikerBindToStorage: fn(
            self: *const IBindHost,
            pMk: ?*IMoniker,
            pBC: ?*IBindCtx,
            pBSC: ?*IBindStatusCallback,
            riid: ?*const Guid,
            ppvObj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MonikerBindToObject: fn(
            self: *const IBindHost,
            pMk: ?*IMoniker,
            pBC: ?*IBindCtx,
            pBSC: ?*IBindStatusCallback,
            riid: ?*const Guid,
            ppvObj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindHost_CreateMoniker(self: *const T, szName: ?PWSTR, pBC: ?*IBindCtx, ppmk: ?*?*IMoniker, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindHost.VTable, self.vtable).CreateMoniker(@ptrCast(*const IBindHost, self), szName, pBC, ppmk, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindHost_MonikerBindToStorage(self: *const T, pMk: ?*IMoniker, pBC: ?*IBindCtx, pBSC: ?*IBindStatusCallback, riid: ?*const Guid, ppvObj: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindHost.VTable, self.vtable).MonikerBindToStorage(@ptrCast(*const IBindHost, self), pMk, pBC, pBSC, riid, ppvObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindHost_MonikerBindToObject(self: *const T, pMk: ?*IMoniker, pBC: ?*IBindCtx, pBSC: ?*IBindStatusCallback, riid: ?*const Guid, ppvObj: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindHost.VTable, self.vtable).MonikerBindToObject(@ptrCast(*const IBindHost, self), pMk, pBC, pBSC, riid, ppvObj);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SAFEARRAYBOUND = extern struct {
    cElements: u32,
    lLbound: i32,
};

pub const SAFEARRAY = extern struct {
    cDims: u16,
    fFeatures: u16,
    cbElements: u32,
    cLocks: u32,
    pvData: ?*anyopaque,
    rgsabound: [1]SAFEARRAYBOUND,
};

pub const VARIANT = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            vt: u16,
            wReserved1: u16,
            wReserved2: u16,
            wReserved3: u16,
            Anonymous: extern union {
                llVal: i64,
                lVal: i32,
                bVal: u8,
                iVal: i16,
                fltVal: f32,
                dblVal: f64,
                boolVal: i16,
                __OBSOLETE__VARIANT_BOOL: i16,
                scode: i32,
                cyVal: CY,
                date: f64,
                bstrVal: ?BSTR,
                punkVal: ?*IUnknown,
                pdispVal: ?*IDispatch,
                parray: ?*SAFEARRAY,
                pbVal: ?*u8,
                piVal: ?*i16,
                plVal: ?*i32,
                pllVal: ?*i64,
                pfltVal: ?*f32,
                pdblVal: ?*f64,
                pboolVal: ?*i16,
                __OBSOLETE__VARIANT_PBOOL: ?*i16,
                pscode: ?*i32,
                pcyVal: ?*CY,
                pdate: ?*f64,
                pbstrVal: ?*?BSTR,
                ppunkVal: ?*?*IUnknown,
                ppdispVal: ?*?*IDispatch,
                pparray: ?*?*SAFEARRAY,
                pvarVal: ?*VARIANT,
                byref: ?*anyopaque,
                cVal: CHAR,
                uiVal: u16,
                ulVal: u32,
                ullVal: u64,
                intVal: i32,
                uintVal: u32,
                pdecVal: ?*DECIMAL,
                pcVal: ?PSTR,
                puiVal: ?*u16,
                pulVal: ?*u32,
                pullVal: ?*u64,
                pintVal: ?*i32,
                puintVal: ?*u32,
                Anonymous: extern struct {
                    pvRecord: ?*anyopaque,
                    pRecInfo: ?*IRecordInfo,
                },
            },
        },
        decVal: DECIMAL,
    },
};

pub const TYPEKIND = enum(i32) {
    ENUM = 0,
    RECORD = 1,
    MODULE = 2,
    INTERFACE = 3,
    DISPATCH = 4,
    COCLASS = 5,
    ALIAS = 6,
    UNION = 7,
    MAX = 8,
};
pub const TKIND_ENUM = TYPEKIND.ENUM;
pub const TKIND_RECORD = TYPEKIND.RECORD;
pub const TKIND_MODULE = TYPEKIND.MODULE;
pub const TKIND_INTERFACE = TYPEKIND.INTERFACE;
pub const TKIND_DISPATCH = TYPEKIND.DISPATCH;
pub const TKIND_COCLASS = TYPEKIND.COCLASS;
pub const TKIND_ALIAS = TYPEKIND.ALIAS;
pub const TKIND_UNION = TYPEKIND.UNION;
pub const TKIND_MAX = TYPEKIND.MAX;

pub const TYPEDESC = extern struct {
    Anonymous: extern union {
        lptdesc: ?*TYPEDESC,
        lpadesc: ?*ARRAYDESC,
        hreftype: u32,
    },
    vt: u16,
};

pub const IDLDESC = extern struct {
    dwReserved: usize,
    wIDLFlags: u16,
};

pub const ELEMDESC = extern struct {
    tdesc: TYPEDESC,
    Anonymous: extern union {
        idldesc: IDLDESC,
        paramdesc: PARAMDESC,
    },
};

pub const TYPEATTR = extern struct {
    guid: Guid,
    lcid: u32,
    dwReserved: u32,
    memidConstructor: i32,
    memidDestructor: i32,
    lpstrSchema: ?PWSTR,
    cbSizeInstance: u32,
    typekind: TYPEKIND,
    cFuncs: u16,
    cVars: u16,
    cImplTypes: u16,
    cbSizeVft: u16,
    cbAlignment: u16,
    wTypeFlags: u16,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    tdescAlias: TYPEDESC,
    idldescType: IDLDESC,
};

pub const DISPPARAMS = extern struct {
    rgvarg: ?*VARIANT,
    rgdispidNamedArgs: ?*i32,
    cArgs: u32,
    cNamedArgs: u32,
};

pub const EXCEPINFO = extern struct {
    wCode: u16,
    wReserved: u16,
    bstrSource: ?BSTR,
    bstrDescription: ?BSTR,
    bstrHelpFile: ?BSTR,
    dwHelpContext: u32,
    pvReserved: ?*anyopaque,
    pfnDeferredFillIn: ?LPEXCEPFINO_DEFERRED_FILLIN,
    scode: i32,
};

pub const CALLCONV = enum(i32) {
    FASTCALL = 0,
    CDECL = 1,
    MSCPASCAL = 2,
    // PASCAL = 2, this enum value conflicts with MSCPASCAL
    MACPASCAL = 3,
    STDCALL = 4,
    FPFASTCALL = 5,
    SYSCALL = 6,
    MPWCDECL = 7,
    MPWPASCAL = 8,
    MAX = 9,
};
pub const CC_FASTCALL = CALLCONV.FASTCALL;
pub const CC_CDECL = CALLCONV.CDECL;
pub const CC_MSCPASCAL = CALLCONV.MSCPASCAL;
pub const CC_PASCAL = CALLCONV.MSCPASCAL;
pub const CC_MACPASCAL = CALLCONV.MACPASCAL;
pub const CC_STDCALL = CALLCONV.STDCALL;
pub const CC_FPFASTCALL = CALLCONV.FPFASTCALL;
pub const CC_SYSCALL = CALLCONV.SYSCALL;
pub const CC_MPWCDECL = CALLCONV.MPWCDECL;
pub const CC_MPWPASCAL = CALLCONV.MPWPASCAL;
pub const CC_MAX = CALLCONV.MAX;

pub const FUNCKIND = enum(i32) {
    VIRTUAL = 0,
    PUREVIRTUAL = 1,
    NONVIRTUAL = 2,
    STATIC = 3,
    DISPATCH = 4,
};
pub const FUNC_VIRTUAL = FUNCKIND.VIRTUAL;
pub const FUNC_PUREVIRTUAL = FUNCKIND.PUREVIRTUAL;
pub const FUNC_NONVIRTUAL = FUNCKIND.NONVIRTUAL;
pub const FUNC_STATIC = FUNCKIND.STATIC;
pub const FUNC_DISPATCH = FUNCKIND.DISPATCH;

pub const INVOKEKIND = enum(i32) {
    FUNC = 1,
    PROPERTYGET = 2,
    PROPERTYPUT = 4,
    PROPERTYPUTREF = 8,
};
pub const INVOKE_FUNC = INVOKEKIND.FUNC;
pub const INVOKE_PROPERTYGET = INVOKEKIND.PROPERTYGET;
pub const INVOKE_PROPERTYPUT = INVOKEKIND.PROPERTYPUT;
pub const INVOKE_PROPERTYPUTREF = INVOKEKIND.PROPERTYPUTREF;

pub const FUNCDESC = extern struct {
    memid: i32,
    lprgscode: ?*i32,
    lprgelemdescParam: ?*ELEMDESC,
    funckind: FUNCKIND,
    invkind: INVOKEKIND,
    @"callconv": CALLCONV,
    cParams: i16,
    cParamsOpt: i16,
    oVft: i16,
    cScodes: i16,
    elemdescFunc: ELEMDESC,
    wFuncFlags: u16,
};

pub const VARKIND = enum(i32) {
    PERINSTANCE = 0,
    STATIC = 1,
    CONST = 2,
    DISPATCH = 3,
};
pub const VAR_PERINSTANCE = VARKIND.PERINSTANCE;
pub const VAR_STATIC = VARKIND.STATIC;
pub const VAR_CONST = VARKIND.CONST;
pub const VAR_DISPATCH = VARKIND.DISPATCH;

pub const VARDESC = extern struct {
    memid: i32,
    lpstrSchema: ?PWSTR,
    Anonymous: extern union {
        oInst: u32,
        lpvarValue: ?*VARIANT,
    },
    elemdescVar: ELEMDESC,
    wVarFlags: u16,
    varkind: VARKIND,
};

pub const CUSTDATAITEM = extern struct {
    guid: Guid,
    varValue: VARIANT,
};

pub const CUSTDATA = extern struct {
    cCustData: u32,
    prgCustData: ?*CUSTDATAITEM,
};

const IID_IDispatch_Value = @import("../zig.zig").Guid.initString("00020400-0000-0000-c000-000000000046");
pub const IID_IDispatch = &IID_IDispatch_Value;
pub const IDispatch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeInfoCount: fn(
            self: *const IDispatch,
            pctinfo: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfo: fn(
            self: *const IDispatch,
            iTInfo: u32,
            lcid: u32,
            ppTInfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDsOfNames: fn(
            self: *const IDispatch,
            riid: ?*const Guid,
            rgszNames: [*]?PWSTR,
            cNames: u32,
            lcid: u32,
            rgDispId: [*]i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const IDispatch,
            dispIdMember: i32,
            riid: ?*const Guid,
            lcid: u32,
            wFlags: u16,
            pDispParams: ?*DISPPARAMS,
            pVarResult: ?*VARIANT,
            pExcepInfo: ?*EXCEPINFO,
            puArgErr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatch_GetTypeInfoCount(self: *const T, pctinfo: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatch.VTable, self.vtable).GetTypeInfoCount(@ptrCast(*const IDispatch, self), pctinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatch_GetTypeInfo(self: *const T, iTInfo: u32, lcid: u32, ppTInfo: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatch.VTable, self.vtable).GetTypeInfo(@ptrCast(*const IDispatch, self), iTInfo, lcid, ppTInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatch_GetIDsOfNames(self: *const T, riid: ?*const Guid, rgszNames: [*]?PWSTR, cNames: u32, lcid: u32, rgDispId: [*]i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatch.VTable, self.vtable).GetIDsOfNames(@ptrCast(*const IDispatch, self), riid, rgszNames, cNames, lcid, rgDispId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDispatch_Invoke(self: *const T, dispIdMember: i32, riid: ?*const Guid, lcid: u32, wFlags: u16, pDispParams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pExcepInfo: ?*EXCEPINFO, puArgErr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDispatch.VTable, self.vtable).Invoke(@ptrCast(*const IDispatch, self), dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DESCKIND = enum(i32) {
    NONE = 0,
    FUNCDESC = 1,
    VARDESC = 2,
    TYPECOMP = 3,
    IMPLICITAPPOBJ = 4,
    MAX = 5,
};
pub const DESCKIND_NONE = DESCKIND.NONE;
pub const DESCKIND_FUNCDESC = DESCKIND.FUNCDESC;
pub const DESCKIND_VARDESC = DESCKIND.VARDESC;
pub const DESCKIND_TYPECOMP = DESCKIND.TYPECOMP;
pub const DESCKIND_IMPLICITAPPOBJ = DESCKIND.IMPLICITAPPOBJ;
pub const DESCKIND_MAX = DESCKIND.MAX;

pub const BINDPTR = extern union {
    lpfuncdesc: ?*FUNCDESC,
    lpvardesc: ?*VARDESC,
    lptcomp: ?*ITypeComp,
};

const IID_ITypeComp_Value = @import("../zig.zig").Guid.initString("00020403-0000-0000-c000-000000000046");
pub const IID_ITypeComp = &IID_ITypeComp_Value;
pub const ITypeComp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Bind: fn(
            self: *const ITypeComp,
            szName: ?PWSTR,
            lHashVal: u32,
            wFlags: u16,
            ppTInfo: ?*?*ITypeInfo,
            pDescKind: ?*DESCKIND,
            pBindPtr: ?*BINDPTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindType: fn(
            self: *const ITypeComp,
            szName: ?PWSTR,
            lHashVal: u32,
            ppTInfo: ?*?*ITypeInfo,
            ppTComp: ?*?*ITypeComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeComp_Bind(self: *const T, szName: ?PWSTR, lHashVal: u32, wFlags: u16, ppTInfo: ?*?*ITypeInfo, pDescKind: ?*DESCKIND, pBindPtr: ?*BINDPTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeComp.VTable, self.vtable).Bind(@ptrCast(*const ITypeComp, self), szName, lHashVal, wFlags, ppTInfo, pDescKind, pBindPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeComp_BindType(self: *const T, szName: ?PWSTR, lHashVal: u32, ppTInfo: ?*?*ITypeInfo, ppTComp: ?*?*ITypeComp) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeComp.VTable, self.vtable).BindType(@ptrCast(*const ITypeComp, self), szName, lHashVal, ppTInfo, ppTComp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeInfo_Value = @import("../zig.zig").Guid.initString("00020401-0000-0000-c000-000000000046");
pub const IID_ITypeInfo = &IID_ITypeInfo_Value;
pub const ITypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeAttr: fn(
            self: *const ITypeInfo,
            ppTypeAttr: ?*?*TYPEATTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeComp: fn(
            self: *const ITypeInfo,
            ppTComp: ?*?*ITypeComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFuncDesc: fn(
            self: *const ITypeInfo,
            index: u32,
            ppFuncDesc: ?*?*FUNCDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVarDesc: fn(
            self: *const ITypeInfo,
            index: u32,
            ppVarDesc: ?*?*VARDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNames: fn(
            self: *const ITypeInfo,
            memid: i32,
            rgBstrNames: [*]?BSTR,
            cMaxNames: u32,
            pcNames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRefTypeOfImplType: fn(
            self: *const ITypeInfo,
            index: u32,
            pRefType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplTypeFlags: fn(
            self: *const ITypeInfo,
            index: u32,
            pImplTypeFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDsOfNames: fn(
            self: *const ITypeInfo,
            rgszNames: [*]?PWSTR,
            cNames: u32,
            pMemId: [*]i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const ITypeInfo,
            pvInstance: ?*anyopaque,
            memid: i32,
            wFlags: u16,
            pDispParams: ?*DISPPARAMS,
            pVarResult: ?*VARIANT,
            pExcepInfo: ?*EXCEPINFO,
            puArgErr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation: fn(
            self: *const ITypeInfo,
            memid: i32,
            pBstrName: ?*?BSTR,
            pBstrDocString: ?*?BSTR,
            pdwHelpContext: ?*u32,
            pBstrHelpFile: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDllEntry: fn(
            self: *const ITypeInfo,
            memid: i32,
            invKind: INVOKEKIND,
            pBstrDllName: ?*?BSTR,
            pBstrName: ?*?BSTR,
            pwOrdinal: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRefTypeInfo: fn(
            self: *const ITypeInfo,
            hRefType: u32,
            ppTInfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddressOfMember: fn(
            self: *const ITypeInfo,
            memid: i32,
            invKind: INVOKEKIND,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstance: fn(
            self: *const ITypeInfo,
            pUnkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppvObj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMops: fn(
            self: *const ITypeInfo,
            memid: i32,
            pBstrMops: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainingTypeLib: fn(
            self: *const ITypeInfo,
            ppTLib: ?*?*ITypeLib,
            pIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseTypeAttr: fn(
            self: *const ITypeInfo,
            pTypeAttr: ?*TYPEATTR,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ReleaseFuncDesc: fn(
            self: *const ITypeInfo,
            pFuncDesc: ?*FUNCDESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ReleaseVarDesc: fn(
            self: *const ITypeInfo,
            pVarDesc: ?*VARDESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetTypeAttr(self: *const T, ppTypeAttr: ?*?*TYPEATTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetTypeAttr(@ptrCast(*const ITypeInfo, self), ppTypeAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetTypeComp(self: *const T, ppTComp: ?*?*ITypeComp) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetTypeComp(@ptrCast(*const ITypeInfo, self), ppTComp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetFuncDesc(self: *const T, index: u32, ppFuncDesc: ?*?*FUNCDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetFuncDesc(@ptrCast(*const ITypeInfo, self), index, ppFuncDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetVarDesc(self: *const T, index: u32, ppVarDesc: ?*?*VARDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetVarDesc(@ptrCast(*const ITypeInfo, self), index, ppVarDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetNames(self: *const T, memid: i32, rgBstrNames: [*]?BSTR, cMaxNames: u32, pcNames: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetNames(@ptrCast(*const ITypeInfo, self), memid, rgBstrNames, cMaxNames, pcNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetRefTypeOfImplType(self: *const T, index: u32, pRefType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetRefTypeOfImplType(@ptrCast(*const ITypeInfo, self), index, pRefType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetImplTypeFlags(self: *const T, index: u32, pImplTypeFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetImplTypeFlags(@ptrCast(*const ITypeInfo, self), index, pImplTypeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetIDsOfNames(self: *const T, rgszNames: [*]?PWSTR, cNames: u32, pMemId: [*]i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetIDsOfNames(@ptrCast(*const ITypeInfo, self), rgszNames, cNames, pMemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_Invoke(self: *const T, pvInstance: ?*anyopaque, memid: i32, wFlags: u16, pDispParams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pExcepInfo: ?*EXCEPINFO, puArgErr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).Invoke(@ptrCast(*const ITypeInfo, self), pvInstance, memid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetDocumentation(self: *const T, memid: i32, pBstrName: ?*?BSTR, pBstrDocString: ?*?BSTR, pdwHelpContext: ?*u32, pBstrHelpFile: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetDocumentation(@ptrCast(*const ITypeInfo, self), memid, pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetDllEntry(self: *const T, memid: i32, invKind: INVOKEKIND, pBstrDllName: ?*?BSTR, pBstrName: ?*?BSTR, pwOrdinal: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetDllEntry(@ptrCast(*const ITypeInfo, self), memid, invKind, pBstrDllName, pBstrName, pwOrdinal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetRefTypeInfo(self: *const T, hRefType: u32, ppTInfo: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetRefTypeInfo(@ptrCast(*const ITypeInfo, self), hRefType, ppTInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_AddressOfMember(self: *const T, memid: i32, invKind: INVOKEKIND, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).AddressOfMember(@ptrCast(*const ITypeInfo, self), memid, invKind, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_CreateInstance(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppvObj: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).CreateInstance(@ptrCast(*const ITypeInfo, self), pUnkOuter, riid, ppvObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetMops(self: *const T, memid: i32, pBstrMops: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetMops(@ptrCast(*const ITypeInfo, self), memid, pBstrMops);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_GetContainingTypeLib(self: *const T, ppTLib: ?*?*ITypeLib, pIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).GetContainingTypeLib(@ptrCast(*const ITypeInfo, self), ppTLib, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_ReleaseTypeAttr(self: *const T, pTypeAttr: ?*TYPEATTR) callconv(.Inline) void {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).ReleaseTypeAttr(@ptrCast(*const ITypeInfo, self), pTypeAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_ReleaseFuncDesc(self: *const T, pFuncDesc: ?*FUNCDESC) callconv(.Inline) void {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).ReleaseFuncDesc(@ptrCast(*const ITypeInfo, self), pFuncDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo_ReleaseVarDesc(self: *const T, pVarDesc: ?*VARDESC) callconv(.Inline) void {
            return @ptrCast(*const ITypeInfo.VTable, self.vtable).ReleaseVarDesc(@ptrCast(*const ITypeInfo, self), pVarDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeInfo2_Value = @import("../zig.zig").Guid.initString("00020412-0000-0000-c000-000000000046");
pub const IID_ITypeInfo2 = &IID_ITypeInfo2_Value;
pub const ITypeInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ITypeInfo.VTable,
        GetTypeKind: fn(
            self: *const ITypeInfo2,
            pTypeKind: ?*TYPEKIND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeFlags: fn(
            self: *const ITypeInfo2,
            pTypeFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFuncIndexOfMemId: fn(
            self: *const ITypeInfo2,
            memid: i32,
            invKind: INVOKEKIND,
            pFuncIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVarIndexOfMemId: fn(
            self: *const ITypeInfo2,
            memid: i32,
            pVarIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustData: fn(
            self: *const ITypeInfo2,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFuncCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamCustData: fn(
            self: *const ITypeInfo2,
            indexFunc: u32,
            indexParam: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVarCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplTypeCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation2: fn(
            self: *const ITypeInfo2,
            memid: i32,
            lcid: u32,
            pbstrHelpString: ?*?BSTR,
            pdwHelpStringContext: ?*u32,
            pbstrHelpStringDll: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCustData: fn(
            self: *const ITypeInfo2,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllFuncCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllParamCustData: fn(
            self: *const ITypeInfo2,
            indexFunc: u32,
            indexParam: u32,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllVarCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllImplTypeCustData: fn(
            self: *const ITypeInfo2,
            index: u32,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITypeInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetTypeKind(self: *const T, pTypeKind: ?*TYPEKIND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetTypeKind(@ptrCast(*const ITypeInfo2, self), pTypeKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetTypeFlags(self: *const T, pTypeFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetTypeFlags(@ptrCast(*const ITypeInfo2, self), pTypeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetFuncIndexOfMemId(self: *const T, memid: i32, invKind: INVOKEKIND, pFuncIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetFuncIndexOfMemId(@ptrCast(*const ITypeInfo2, self), memid, invKind, pFuncIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetVarIndexOfMemId(self: *const T, memid: i32, pVarIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetVarIndexOfMemId(@ptrCast(*const ITypeInfo2, self), memid, pVarIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetCustData(@ptrCast(*const ITypeInfo2, self), guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetFuncCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetFuncCustData(@ptrCast(*const ITypeInfo2, self), index, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetParamCustData(self: *const T, indexFunc: u32, indexParam: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetParamCustData(@ptrCast(*const ITypeInfo2, self), indexFunc, indexParam, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetVarCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetVarCustData(@ptrCast(*const ITypeInfo2, self), index, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetImplTypeCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetImplTypeCustData(@ptrCast(*const ITypeInfo2, self), index, guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetDocumentation2(self: *const T, memid: i32, lcid: u32, pbstrHelpString: ?*?BSTR, pdwHelpStringContext: ?*u32, pbstrHelpStringDll: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetDocumentation2(@ptrCast(*const ITypeInfo2, self), memid, lcid, pbstrHelpString, pdwHelpStringContext, pbstrHelpStringDll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllCustData(self: *const T, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllCustData(@ptrCast(*const ITypeInfo2, self), pCustData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllFuncCustData(self: *const T, index: u32, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllFuncCustData(@ptrCast(*const ITypeInfo2, self), index, pCustData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllParamCustData(self: *const T, indexFunc: u32, indexParam: u32, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllParamCustData(@ptrCast(*const ITypeInfo2, self), indexFunc, indexParam, pCustData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllVarCustData(self: *const T, index: u32, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllVarCustData(@ptrCast(*const ITypeInfo2, self), index, pCustData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeInfo2_GetAllImplTypeCustData(self: *const T, index: u32, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeInfo2.VTable, self.vtable).GetAllImplTypeCustData(@ptrCast(*const ITypeInfo2, self), index, pCustData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYSKIND = enum(i32) {
    WIN16 = 0,
    WIN32 = 1,
    MAC = 2,
    WIN64 = 3,
};
pub const SYS_WIN16 = SYSKIND.WIN16;
pub const SYS_WIN32 = SYSKIND.WIN32;
pub const SYS_MAC = SYSKIND.MAC;
pub const SYS_WIN64 = SYSKIND.WIN64;

pub const TLIBATTR = extern struct {
    guid: Guid,
    lcid: u32,
    syskind: SYSKIND,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    wLibFlags: u16,
};

const IID_ITypeLib_Value = @import("../zig.zig").Guid.initString("00020402-0000-0000-c000-000000000046");
pub const IID_ITypeLib = &IID_ITypeLib_Value;
pub const ITypeLib = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeInfoCount: fn(
            self: *const ITypeLib,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetTypeInfo: fn(
            self: *const ITypeLib,
            index: u32,
            ppTInfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfoType: fn(
            self: *const ITypeLib,
            index: u32,
            pTKind: ?*TYPEKIND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfoOfGuid: fn(
            self: *const ITypeLib,
            guid: ?*const Guid,
            ppTinfo: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLibAttr: fn(
            self: *const ITypeLib,
            ppTLibAttr: ?*?*TLIBATTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeComp: fn(
            self: *const ITypeLib,
            ppTComp: ?*?*ITypeComp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation: fn(
            self: *const ITypeLib,
            index: i32,
            pBstrName: ?*?BSTR,
            pBstrDocString: ?*?BSTR,
            pdwHelpContext: ?*u32,
            pBstrHelpFile: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsName: fn(
            self: *const ITypeLib,
            szNameBuf: ?PWSTR,
            lHashVal: u32,
            pfName: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindName: fn(
            self: *const ITypeLib,
            szNameBuf: ?PWSTR,
            lHashVal: u32,
            ppTInfo: [*]?*ITypeInfo,
            rgMemId: [*]i32,
            pcFound: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseTLibAttr: fn(
            self: *const ITypeLib,
            pTLibAttr: ?*TLIBATTR,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeInfoCount(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeInfoCount(@ptrCast(*const ITypeLib, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeInfo(self: *const T, index: u32, ppTInfo: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeInfo(@ptrCast(*const ITypeLib, self), index, ppTInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeInfoType(self: *const T, index: u32, pTKind: ?*TYPEKIND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeInfoType(@ptrCast(*const ITypeLib, self), index, pTKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeInfoOfGuid(self: *const T, guid: ?*const Guid, ppTinfo: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeInfoOfGuid(@ptrCast(*const ITypeLib, self), guid, ppTinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetLibAttr(self: *const T, ppTLibAttr: ?*?*TLIBATTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetLibAttr(@ptrCast(*const ITypeLib, self), ppTLibAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetTypeComp(self: *const T, ppTComp: ?*?*ITypeComp) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetTypeComp(@ptrCast(*const ITypeLib, self), ppTComp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_GetDocumentation(self: *const T, index: i32, pBstrName: ?*?BSTR, pBstrDocString: ?*?BSTR, pdwHelpContext: ?*u32, pBstrHelpFile: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).GetDocumentation(@ptrCast(*const ITypeLib, self), index, pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_IsName(self: *const T, szNameBuf: ?PWSTR, lHashVal: u32, pfName: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).IsName(@ptrCast(*const ITypeLib, self), szNameBuf, lHashVal, pfName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_FindName(self: *const T, szNameBuf: ?PWSTR, lHashVal: u32, ppTInfo: [*]?*ITypeInfo, rgMemId: [*]i32, pcFound: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).FindName(@ptrCast(*const ITypeLib, self), szNameBuf, lHashVal, ppTInfo, rgMemId, pcFound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib_ReleaseTLibAttr(self: *const T, pTLibAttr: ?*TLIBATTR) callconv(.Inline) void {
            return @ptrCast(*const ITypeLib.VTable, self.vtable).ReleaseTLibAttr(@ptrCast(*const ITypeLib, self), pTLibAttr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLib2_Value = @import("../zig.zig").Guid.initString("00020411-0000-0000-c000-000000000046");
pub const IID_ITypeLib2 = &IID_ITypeLib2_Value;
pub const ITypeLib2 = extern struct {
    pub const VTable = extern struct {
        base: ITypeLib.VTable,
        GetCustData: fn(
            self: *const ITypeLib2,
            guid: ?*const Guid,
            pVarVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLibStatistics: fn(
            self: *const ITypeLib2,
            pcUniqueNames: ?*u32,
            pcchUniqueNames: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentation2: fn(
            self: *const ITypeLib2,
            index: i32,
            lcid: u32,
            pbstrHelpString: ?*?BSTR,
            pdwHelpStringContext: ?*u32,
            pbstrHelpStringDll: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCustData: fn(
            self: *const ITypeLib2,
            pCustData: ?*CUSTDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITypeLib.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib2_GetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib2.VTable, self.vtable).GetCustData(@ptrCast(*const ITypeLib2, self), guid, pVarVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib2_GetLibStatistics(self: *const T, pcUniqueNames: ?*u32, pcchUniqueNames: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib2.VTable, self.vtable).GetLibStatistics(@ptrCast(*const ITypeLib2, self), pcUniqueNames, pcchUniqueNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib2_GetDocumentation2(self: *const T, index: i32, lcid: u32, pbstrHelpString: ?*?BSTR, pdwHelpStringContext: ?*u32, pbstrHelpStringDll: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib2.VTable, self.vtable).GetDocumentation2(@ptrCast(*const ITypeLib2, self), index, lcid, pbstrHelpString, pdwHelpStringContext, pbstrHelpStringDll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLib2_GetAllCustData(self: *const T, pCustData: ?*CUSTDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLib2.VTable, self.vtable).GetAllCustData(@ptrCast(*const ITypeLib2, self), pCustData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorInfo_Value = @import("../zig.zig").Guid.initString("1cf2b120-547d-101b-8e65-08002b2bd119");
pub const IID_IErrorInfo = &IID_IErrorInfo_Value;
pub const IErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGUID: fn(
            self: *const IErrorInfo,
            pGUID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSource: fn(
            self: *const IErrorInfo,
            pBstrSource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IErrorInfo,
            pBstrDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpFile: fn(
            self: *const IErrorInfo,
            pBstrHelpFile: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpContext: fn(
            self: *const IErrorInfo,
            pdwHelpContext: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetGUID(self: *const T, pGUID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetGUID(@ptrCast(*const IErrorInfo, self), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetSource(self: *const T, pBstrSource: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetSource(@ptrCast(*const IErrorInfo, self), pBstrSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetDescription(self: *const T, pBstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetDescription(@ptrCast(*const IErrorInfo, self), pBstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetHelpFile(self: *const T, pBstrHelpFile: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetHelpFile(@ptrCast(*const IErrorInfo, self), pBstrHelpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorInfo_GetHelpContext(self: *const T, pdwHelpContext: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorInfo.VTable, self.vtable).GetHelpContext(@ptrCast(*const IErrorInfo, self), pdwHelpContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISupportErrorInfo_Value = @import("../zig.zig").Guid.initString("df0b3d60-548f-101b-8e65-08002b2bd119");
pub const IID_ISupportErrorInfo = &IID_ISupportErrorInfo_Value;
pub const ISupportErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InterfaceSupportsErrorInfo: fn(
            self: *const ISupportErrorInfo,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISupportErrorInfo_InterfaceSupportsErrorInfo(self: *const T, riid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISupportErrorInfo.VTable, self.vtable).InterfaceSupportsErrorInfo(@ptrCast(*const ISupportErrorInfo, self), riid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorLog_Value = @import("../zig.zig").Guid.initString("3127ca40-446e-11ce-8135-00aa004bb851");
pub const IID_IErrorLog = &IID_IErrorLog_Value;
pub const IErrorLog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddError: fn(
            self: *const IErrorLog,
            pszPropName: ?[*:0]const u16,
            pExcepInfo: ?*EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorLog_AddError(self: *const T, pszPropName: ?[*:0]const u16, pExcepInfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorLog.VTable, self.vtable).AddError(@ptrCast(*const IErrorLog, self), pszPropName, pExcepInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLibRegistrationReader_Value = @import("../zig.zig").Guid.initString("ed6a8a2a-b160-4e77-8f73-aa7435cd5c27");
pub const IID_ITypeLibRegistrationReader = &IID_ITypeLibRegistrationReader_Value;
pub const ITypeLibRegistrationReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumTypeLibRegistrations: fn(
            self: *const ITypeLibRegistrationReader,
            ppEnumUnknown: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistrationReader_EnumTypeLibRegistrations(self: *const T, ppEnumUnknown: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistrationReader.VTable, self.vtable).EnumTypeLibRegistrations(@ptrCast(*const ITypeLibRegistrationReader, self), ppEnumUnknown);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLibRegistration_Value = @import("../zig.zig").Guid.initString("76a3e735-02df-4a12-98eb-043ad3600af3");
pub const IID_ITypeLibRegistration = &IID_ITypeLibRegistration_Value;
pub const ITypeLibRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGuid: fn(
            self: *const ITypeLibRegistration,
            pGuid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const ITypeLibRegistration,
            pVersion: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLcid: fn(
            self: *const ITypeLibRegistration,
            pLcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWin32Path: fn(
            self: *const ITypeLibRegistration,
            pWin32Path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWin64Path: fn(
            self: *const ITypeLibRegistration,
            pWin64Path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const ITypeLibRegistration,
            pDisplayName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const ITypeLibRegistration,
            pFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpDir: fn(
            self: *const ITypeLibRegistration,
            pHelpDir: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetGuid(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetGuid(@ptrCast(*const ITypeLibRegistration, self), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetVersion(self: *const T, pVersion: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetVersion(@ptrCast(*const ITypeLibRegistration, self), pVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetLcid(self: *const T, pLcid: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetLcid(@ptrCast(*const ITypeLibRegistration, self), pLcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetWin32Path(self: *const T, pWin32Path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetWin32Path(@ptrCast(*const ITypeLibRegistration, self), pWin32Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetWin64Path(self: *const T, pWin64Path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetWin64Path(@ptrCast(*const ITypeLibRegistration, self), pWin64Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetDisplayName(self: *const T, pDisplayName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetDisplayName(@ptrCast(*const ITypeLibRegistration, self), pDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetFlags(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetFlags(@ptrCast(*const ITypeLibRegistration, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeLibRegistration_GetHelpDir(self: *const T, pHelpDir: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITypeLibRegistration.VTable, self.vtable).GetHelpDir(@ptrCast(*const ITypeLibRegistration, self), pHelpDir);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CONNECTDATA = extern struct {
    pUnk: ?*IUnknown,
    dwCookie: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumConnections_Value = @import("../zig.zig").Guid.initString("b196b287-bab4-101a-b69c-00aa00341d07");
pub const IID_IEnumConnections = &IID_IEnumConnections_Value;
pub const IEnumConnections = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumConnections,
            cConnections: u32,
            rgcd: [*]CONNECTDATA,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumConnections,
            cConnections: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumConnections,
            ppEnum: ?*?*IEnumConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnections_Next(self: *const T, cConnections: u32, rgcd: [*]CONNECTDATA, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnections.VTable, self.vtable).Next(@ptrCast(*const IEnumConnections, self), cConnections, rgcd, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnections_Skip(self: *const T, cConnections: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnections.VTable, self.vtable).Skip(@ptrCast(*const IEnumConnections, self), cConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnections_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnections.VTable, self.vtable).Reset(@ptrCast(*const IEnumConnections, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnections_Clone(self: *const T, ppEnum: ?*?*IEnumConnections) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnections.VTable, self.vtable).Clone(@ptrCast(*const IEnumConnections, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConnectionPoint_Value = @import("../zig.zig").Guid.initString("b196b286-bab4-101a-b69c-00aa00341d07");
pub const IID_IConnectionPoint = &IID_IConnectionPoint_Value;
pub const IConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectionInterface: fn(
            self: *const IConnectionPoint,
            pIID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectionPointContainer: fn(
            self: *const IConnectionPoint,
            ppCPC: ?*?*IConnectionPointContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IConnectionPoint,
            pUnkSink: ?*IUnknown,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IConnectionPoint,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumConnections: fn(
            self: *const IConnectionPoint,
            ppEnum: ?*?*IEnumConnections,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_GetConnectionInterface(self: *const T, pIID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).GetConnectionInterface(@ptrCast(*const IConnectionPoint, self), pIID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_GetConnectionPointContainer(self: *const T, ppCPC: ?*?*IConnectionPointContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).GetConnectionPointContainer(@ptrCast(*const IConnectionPoint, self), ppCPC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_Advise(self: *const T, pUnkSink: ?*IUnknown, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).Advise(@ptrCast(*const IConnectionPoint, self), pUnkSink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).Unadvise(@ptrCast(*const IConnectionPoint, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPoint_EnumConnections(self: *const T, ppEnum: ?*?*IEnumConnections) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPoint.VTable, self.vtable).EnumConnections(@ptrCast(*const IConnectionPoint, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumConnectionPoints_Value = @import("../zig.zig").Guid.initString("b196b285-bab4-101a-b69c-00aa00341d07");
pub const IID_IEnumConnectionPoints = &IID_IEnumConnectionPoints_Value;
pub const IEnumConnectionPoints = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumConnectionPoints,
            cConnections: u32,
            ppCP: [*]?*IConnectionPoint,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumConnectionPoints,
            cConnections: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumConnectionPoints,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumConnectionPoints,
            ppEnum: ?*?*IEnumConnectionPoints,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnectionPoints_Next(self: *const T, cConnections: u32, ppCP: [*]?*IConnectionPoint, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnectionPoints.VTable, self.vtable).Next(@ptrCast(*const IEnumConnectionPoints, self), cConnections, ppCP, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnectionPoints_Skip(self: *const T, cConnections: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnectionPoints.VTable, self.vtable).Skip(@ptrCast(*const IEnumConnectionPoints, self), cConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnectionPoints_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnectionPoints.VTable, self.vtable).Reset(@ptrCast(*const IEnumConnectionPoints, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumConnectionPoints_Clone(self: *const T, ppEnum: ?*?*IEnumConnectionPoints) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumConnectionPoints.VTable, self.vtable).Clone(@ptrCast(*const IEnumConnectionPoints, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConnectionPointContainer_Value = @import("../zig.zig").Guid.initString("b196b284-bab4-101a-b69c-00aa00341d07");
pub const IID_IConnectionPointContainer = &IID_IConnectionPointContainer_Value;
pub const IConnectionPointContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumConnectionPoints: fn(
            self: *const IConnectionPointContainer,
            ppEnum: ?*?*IEnumConnectionPoints,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindConnectionPoint: fn(
            self: *const IConnectionPointContainer,
            riid: ?*const Guid,
            ppCP: ?*?*IConnectionPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPointContainer_EnumConnectionPoints(self: *const T, ppEnum: ?*?*IEnumConnectionPoints) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPointContainer.VTable, self.vtable).EnumConnectionPoints(@ptrCast(*const IConnectionPointContainer, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectionPointContainer_FindConnectionPoint(self: *const T, riid: ?*const Guid, ppCP: ?*?*IConnectionPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectionPointContainer.VTable, self.vtable).FindConnectionPoint(@ptrCast(*const IConnectionPointContainer, self), riid, ppCP);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPersistMemory_Value = @import("../zig.zig").Guid.initString("bd1ae5e0-a6ae-11ce-bd37-504200c10000");
pub const IID_IPersistMemory = &IID_IPersistMemory_Value;
pub const IPersistMemory = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: fn(
            self: *const IPersistMemory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistMemory,
            pMem: [*]u8,
            cbSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistMemory,
            pMem: [*]u8,
            fClearDirty: BOOL,
            cbSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeMax: fn(
            self: *const IPersistMemory,
            pCbSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitNew: fn(
            self: *const IPersistMemory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistMemory, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_Load(self: *const T, pMem: [*]u8, cbSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).Load(@ptrCast(*const IPersistMemory, self), pMem, cbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_Save(self: *const T, pMem: [*]u8, fClearDirty: BOOL, cbSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).Save(@ptrCast(*const IPersistMemory, self), pMem, fClearDirty, cbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_GetSizeMax(self: *const T, pCbSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).GetSizeMax(@ptrCast(*const IPersistMemory, self), pCbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMemory_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMemory.VTable, self.vtable).InitNew(@ptrCast(*const IPersistMemory, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStreamInit_Value = @import("../zig.zig").Guid.initString("7fd52380-4e07-101b-ae2d-08002b2ec713");
pub const IID_IPersistStreamInit = &IID_IPersistStreamInit_Value;
pub const IPersistStreamInit = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: fn(
            self: *const IPersistStreamInit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IPersistStreamInit,
            pStm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IPersistStreamInit,
            pStm: ?*IStream,
            fClearDirty: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSizeMax: fn(
            self: *const IPersistStreamInit,
            pCbSize: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitNew: fn(
            self: *const IPersistStreamInit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistStreamInit, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_Load(self: *const T, pStm: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).Load(@ptrCast(*const IPersistStreamInit, self), pStm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_Save(self: *const T, pStm: ?*IStream, fClearDirty: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).Save(@ptrCast(*const IPersistStreamInit, self), pStm, fClearDirty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_GetSizeMax(self: *const T, pCbSize: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).GetSizeMax(@ptrCast(*const IPersistStreamInit, self), pCbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStreamInit_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistStreamInit.VTable, self.vtable).InitNew(@ptrCast(*const IPersistStreamInit, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (110)
//--------------------------------------------------------------------------------
pub extern "ole32" fn CoBuildVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoInitialize(
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterMallocSpy(
    pMallocSpy: ?*IMallocSpy,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRevokeMallocSpy(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLE32" fn CoRegisterInitializeSpy(
    pSpy: ?*IInitializeSpy,
    puliCookie: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRevokeInitializeSpy(
    uliCookie: ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetSystemSecurityPermissions(
    comSDType: COMSD,
    ppSD: ?*?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoLoadLibrary(
    lpszLibName: ?PWSTR,
    bAutoFree: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFreeLibrary(
    hInst: ?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFreeAllLibraries(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoAllowSetForegroundWindow(
    pUnk: ?*IUnknown,
    lpvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn DcomChannelSetHResult(
    pvReserved: ?*anyopaque,
    pulReserved: ?*u32,
    appsHR: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoIsOle1Class(
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CLSIDFromProgIDEx(
    lpszProgID: ?[*:0]const u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFileTimeToDosDateTime(
    lpFileTime: ?*FILETIME,
    lpDosDate: ?*u16,
    lpDosTime: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoDosDateTimeToFileTime(
    nDosDate: u16,
    nDosTime: u16,
    lpFileTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFileTimeNow(
    lpFileTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoRegisterChannelHook(
    ExtensionUuid: ?*const Guid,
    pChannelHook: ?*IChannelHook,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTreatAsClass(
    clsidOld: ?*const Guid,
    clsidNew: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateDataAdviseHolder(
    ppDAHolder: ?*?*IDataAdviseHolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateDataCache(
    pUnkOuter: ?*IUnknown,
    rclsid: ?*const Guid,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoInstall(
    pbc: ?*IBindCtx,
    dwFlags: u32,
    pClassSpec: ?*uCLSSPEC,
    pQuery: ?*QUERYCONTEXT,
    pszCodeBase: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn BindMoniker(
    pmk: ?*IMoniker,
    grfOpt: u32,
    iidResult: ?*const Guid,
    ppvResult: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetObject(
    pszName: ?[*:0]const u16,
    pBindOptions: ?*BIND_OPTS,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn MkParseDisplayName(
    pbc: ?*IBindCtx,
    szUserName: ?[*:0]const u16,
    pchEaten: ?*u32,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MonikerRelativePathTo(
    pmkSrc: ?*IMoniker,
    pmkDest: ?*IMoniker,
    ppmkRelPath: ?*?*IMoniker,
    dwReserved: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MonikerCommonPrefixWith(
    pmkThis: ?*IMoniker,
    pmkOther: ?*IMoniker,
    ppmkCommon: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateBindCtx(
    reserved: u32,
    ppbc: ?*?*IBindCtx,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateGenericComposite(
    pmkFirst: ?*IMoniker,
    pmkRest: ?*IMoniker,
    ppmkComposite: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn GetClassFile(
    szFilename: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateClassMoniker(
    rclsid: ?*const Guid,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateFileMoniker(
    lpszPathName: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateItemMoniker(
    lpszDelim: ?[*:0]const u16,
    lpszItem: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateAntiMoniker(
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreatePointerMoniker(
    punk: ?*IUnknown,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CreateObjrefMoniker(
    punk: ?*IUnknown,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn GetRunningObjectTable(
    reserved: u32,
    pprot: ?*?*IRunningObjectTable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CreateStdProgressIndicator(
    hwndParent: ?HWND,
    pszTitle: ?[*:0]const u16,
    pIbscCaller: ?*IBindStatusCallback,
    ppIbsc: ?*?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetMalloc(
    dwMemContext: u32,
    ppMalloc: ?*?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoUninitialize(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCurrentProcess(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoInitializeEx(
    pvReserved: ?*anyopaque,
    dwCoInit: COINIT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCallerTID(
    lpdwTID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCurrentLogicalThreadId(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetContextToken(
    pToken: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "OLE32" fn CoGetApartmentType(
    pAptType: ?*APTTYPE,
    pAptQualifier: ?*APTTYPEQUALIFIER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoIncrementMTAUsage(
    pCookie: ?*CO_MTA_USAGE_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoDecrementMTAUsage(
    Cookie: CO_MTA_USAGE_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "OLE32" fn CoAllowUnmarshalerCLSID(
    clsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetObjectContext(
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetClassObject(
    rclsid: ?*const Guid,
    dwClsContext: CLSCTX,
    pvReserved: ?*anyopaque,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterClassObject(
    rclsid: ?*const Guid,
    pUnk: ?*IUnknown,
    dwClsContext: CLSCTX,
    flags: u32,
    lpdwRegister: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRevokeClassObject(
    dwRegister: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoResumeClassObjects(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoSuspendClassObjects(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoAddRefServerProcess(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoReleaseServerProcess(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetPSClsid(
    riid: ?*const Guid,
    pClsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterPSClsid(
    riid: ?*const Guid,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRegisterSurrogate(
    pSurrogate: ?*ISurrogate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoDisconnectObject(
    pUnk: ?*IUnknown,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoLockObjectExternal(
    pUnk: ?*IUnknown,
    fLock: BOOL,
    fLastUnlockReleases: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoIsHandlerConnected(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCreateFreeThreadedMarshaler(
    punkOuter: ?*IUnknown,
    ppunkMarshal: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoFreeUnusedLibraries(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLE32" fn CoFreeUnusedLibrariesEx(
    dwUnloadDelay: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "OLE32" fn CoDisconnectContext(
    dwTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoInitializeSecurity(
    pSecDesc: ?*SECURITY_DESCRIPTOR,
    cAuthSvc: i32,
    asAuthSvc: ?[*]SOLE_AUTHENTICATION_SERVICE,
    pReserved1: ?*anyopaque,
    dwAuthnLevel: RPC_C_AUTHN_LEVEL,
    dwImpLevel: RPC_C_IMP_LEVEL,
    pAuthList: ?*anyopaque,
    dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
    pReserved3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCallContext(
    riid: ?*const Guid,
    ppInterface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoQueryProxyBlanket(
    pProxy: ?*IUnknown,
    pwAuthnSvc: ?*u32,
    pAuthzSvc: ?*u32,
    pServerPrincName: ?*?PWSTR,
    pAuthnLevel: ?*u32,
    pImpLevel: ?*u32,
    pAuthInfo: ?*?*anyopaque,
    pCapabilites: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoSetProxyBlanket(
    pProxy: ?*IUnknown,
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pServerPrincName: ?PWSTR,
    dwAuthnLevel: RPC_C_AUTHN_LEVEL,
    dwImpLevel: RPC_C_IMP_LEVEL,
    pAuthInfo: ?*anyopaque,
    dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCopyProxy(
    pProxy: ?*IUnknown,
    ppCopy: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoQueryClientBlanket(
    pAuthnSvc: ?*u32,
    pAuthzSvc: ?*u32,
    pServerPrincName: ?*?PWSTR,
    pAuthnLevel: ?*u32,
    pImpLevel: ?*u32,
    pPrivs: ?*?*anyopaque,
    pCapabilities: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoImpersonateClient(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoRevertToSelf(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoQueryAuthenticationServices(
    pcAuthSvc: ?*u32,
    asAuthSvc: ?*?*SOLE_AUTHENTICATION_SERVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoSwitchCallContext(
    pNewObject: ?*IUnknown,
    ppOldObject: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCreateInstance(
    rclsid: ?*const Guid,
    pUnkOuter: ?*IUnknown,
    dwClsContext: CLSCTX,
    riid: *const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCreateInstanceEx(
    Clsid: ?*const Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    pServerInfo: ?*COSERVERINFO,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "OLE32" fn CoCreateInstanceFromApp(
    Clsid: ?*const Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    reserved: ?*anyopaque,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLE32" fn CoRegisterActivationFilter(
    pActivationFilter: ?*IActivationFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetCancelObject(
    dwThreadId: u32,
    iid: ?*const Guid,
    ppUnk: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoSetCancelObject(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCancelCall(
    dwThreadId: u32,
    ulTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTestCancel(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoEnableCallCancellation(
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoDisableCallCancellation(
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StringFromCLSID(
    rclsid: ?*const Guid,
    lplpsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CLSIDFromString(
    lpsz: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StringFromIID(
    rclsid: ?*const Guid,
    lplpsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn IIDFromString(
    lpsz: ?[*:0]const u16,
    lpiid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn ProgIDFromCLSID(
    clsid: ?*const Guid,
    lplpszProgID: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CLSIDFromProgID(
    lpszProgID: ?[*:0]const u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn StringFromGUID2(
    rguid: ?*const Guid,
    lpsz: [*:0]u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoCreateGuid(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoWaitForMultipleHandles(
    dwFlags: u32,
    dwTimeout: u32,
    cHandles: u32,
    pHandles: [*]?HANDLE,
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoWaitForMultipleObjects(
    dwFlags: u32,
    dwTimeout: u32,
    cHandles: u32,
    pHandles: [*]const ?HANDLE,
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoGetTreatAsClass(
    clsidOld: ?*const Guid,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "OLE32" fn CoInvalidateRemoteMachineBindings(
    pszMachineName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTaskMemAlloc(
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTaskMemRealloc(
    pv: ?*anyopaque,
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "OLE32" fn CoTaskMemFree(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn CoRegisterDeviceCatalog(
    deviceInstanceId: ?[*:0]const u16,
    cookie: ?*CO_DEVICE_CATALOG_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn CoRevokeDeviceCatalog(
    cookie: CO_DEVICE_CATALOG_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "URLMON" fn CreateUri(
    pwzURI: ?[*:0]const u16,
    dwFlags: URI_CREATE_FLAGS,
    dwReserved: usize,
    ppURI: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "URLMON" fn CreateUriWithFragment(
    pwzURI: ?[*:0]const u16,
    pwzFragment: ?[*:0]const u16,
    dwFlags: u32,
    dwReserved: usize,
    ppURI: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateUriFromMultiByteString(
    pszANSIInputUri: ?[*:0]const u8,
    dwEncodingFlags: u32,
    dwCodePage: u32,
    dwCreateFlags: u32,
    dwReserved: usize,
    ppUri: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "URLMON" fn CreateIUriBuilder(
    pIUri: ?*IUri,
    dwFlags: u32,
    dwReserved: usize,
    ppIUriBuilder: ?*?*IUriBuilder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn SetErrorInfo(
    dwReserved: u32,
    perrinfo: ?*IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEAUT32" fn GetErrorInfo(
    dwReserved: u32,
    pperrinfo: ?*?*IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (27)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const ARRAYDESC = @import("../system/ole.zig").ARRAYDESC;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const DECIMAL = @import("../foundation.zig").DECIMAL;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HENHMETAFILE = @import("../graphics/gdi.zig").HENHMETAFILE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IRecordInfo = @import("../system/ole.zig").IRecordInfo;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PARAMDESC = @import("../system/ole.zig").PARAMDESC;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;
const SECURITY_DESCRIPTOR = @import("../security.zig").SECURITY_DESCRIPTOR;
const ULARGE_INTEGER = @import("../foundation.zig").ULARGE_INTEGER;
const userHBITMAP = @import("../system/system_services.zig").userHBITMAP;
const userHENHMETAFILE = @import("../system/system_services.zig").userHENHMETAFILE;
const userHGLOBAL = @import("../system/system_services.zig").userHGLOBAL;
const userHMETAFILEPICT = @import("../system/system_services.zig").userHMETAFILEPICT;
const userHPALETTE = @import("../system/system_services.zig").userHPALETTE;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPEXCEPFINO_DEFERRED_FILLIN")) { _ = LPEXCEPFINO_DEFERRED_FILLIN; }
    if (@hasDecl(@This(), "LPFNGETCLASSOBJECT")) { _ = LPFNGETCLASSOBJECT; }
    if (@hasDecl(@This(), "LPFNCANUNLOADNOW")) { _ = LPFNCANUNLOADNOW; }
    if (@hasDecl(@This(), "PFNCONTEXTCALL")) { _ = PFNCONTEXTCALL; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (7)
//--------------------------------------------------------------------------------
pub const call_obj = @import("com/call_obj.zig");
pub const channel_credentials = @import("com/channel_credentials.zig");
pub const events = @import("com/events.zig");
pub const marshal = @import("com/marshal.zig");
pub const structured_storage = @import("com/structured_storage.zig");
pub const ui = @import("com/ui.zig");
pub const urlmon = @import("com/urlmon.zig");
