//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (208)
//--------------------------------------------------------------------------------
pub const PROP_ID_SECURE_MIN = @as(u32, 26608);
pub const PROP_ID_SECURE_MAX = @as(u32, 26623);
pub const MAPI_DIM = @as(u32, 1);
pub const MAPI_P1 = @as(u32, 268435456);
pub const MAPI_SUBMITTED = @as(u32, 2147483648);
pub const MAPI_SHORTTERM = @as(u32, 128);
pub const MAPI_NOTRECIP = @as(u32, 64);
pub const MAPI_THISSESSION = @as(u32, 32);
pub const MAPI_NOW = @as(u32, 16);
pub const MAPI_NOTRESERVED = @as(u32, 8);
pub const MAPI_COMPOUND = @as(u32, 128);
pub const MV_FLAG = @as(u32, 4096);
pub const PROP_ID_NULL = @as(u32, 0);
pub const PROP_ID_INVALID = @as(u32, 65535);
pub const MV_INSTANCE = @as(u32, 8192);
pub const TABLE_CHANGED = @as(u32, 1);
pub const TABLE_ERROR = @as(u32, 2);
pub const TABLE_ROW_ADDED = @as(u32, 3);
pub const TABLE_ROW_DELETED = @as(u32, 4);
pub const TABLE_ROW_MODIFIED = @as(u32, 5);
pub const TABLE_SORT_DONE = @as(u32, 6);
pub const TABLE_RESTRICT_DONE = @as(u32, 7);
pub const TABLE_SETCOL_DONE = @as(u32, 8);
pub const TABLE_RELOAD = @as(u32, 9);
pub const MAPI_ERROR_VERSION = @as(i32, 0);
pub const MAPI_USE_DEFAULT = @as(u32, 64);
pub const MNID_ID = @as(u32, 0);
pub const MNID_STRING = @as(u32, 1);
pub const WAB_LOCAL_CONTAINERS = @as(u32, 1048576);
pub const WAB_PROFILE_CONTENTS = @as(u32, 2097152);
pub const WAB_IGNORE_PROFILES = @as(u32, 8388608);
pub const MAPI_ONE_OFF_NO_RICH_INFO = @as(u32, 1);
pub const UI_SERVICE = @as(u32, 2);
pub const SERVICE_UI_ALWAYS = @as(u32, 2);
pub const SERVICE_UI_ALLOWED = @as(u32, 16);
pub const UI_CURRENT_PROVIDER_FIRST = @as(u32, 4);
pub const WABOBJECT_LDAPURL_RETURN_MAILUSER = @as(u32, 1);
pub const WABOBJECT_ME_NEW = @as(u32, 1);
pub const WABOBJECT_ME_NOCREATE = @as(u32, 2);
pub const WAB_VCARD_FILE = @as(u32, 0);
pub const WAB_VCARD_STREAM = @as(u32, 1);
pub const WAB_USE_OE_SENDMAIL = @as(u32, 1);
pub const WAB_ENABLE_PROFILES = @as(u32, 4194304);
pub const WAB_DISPLAY_LDAPURL = @as(u32, 1);
pub const WAB_CONTEXT_ADRLIST = @as(u32, 2);
pub const WAB_DISPLAY_ISNTDS = @as(u32, 4);
pub const E_IMAPI_REQUEST_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600702));
pub const E_IMAPI_RECORDER_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600701));
pub const S_IMAPI_SPEEDADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141124));
pub const S_IMAPI_ROTATIONADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141125));
pub const S_IMAPI_BOTHADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141126));
pub const E_IMAPI_BURN_VERIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600697));
pub const S_IMAPI_COMMAND_HAS_SENSE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141632));
pub const E_IMAPI_RECORDER_NO_SUCH_MODE_PAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600191));
pub const E_IMAPI_RECORDER_MEDIA_NO_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600190));
pub const E_IMAPI_RECORDER_MEDIA_INCOMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600189));
pub const E_IMAPI_RECORDER_MEDIA_UPSIDE_DOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600188));
pub const E_IMAPI_RECORDER_MEDIA_BECOMING_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600187));
pub const E_IMAPI_RECORDER_MEDIA_FORMAT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600186));
pub const E_IMAPI_RECORDER_MEDIA_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600185));
pub const E_IMAPI_RECORDER_INVALID_MODE_PARAMETERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600184));
pub const E_IMAPI_RECORDER_MEDIA_WRITE_PROTECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600183));
pub const E_IMAPI_RECORDER_NO_SUCH_FEATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600182));
pub const E_IMAPI_RECORDER_FEATURE_IS_NOT_CURRENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600181));
pub const E_IMAPI_RECORDER_GET_CONFIGURATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600180));
pub const E_IMAPI_RECORDER_COMMAND_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600179));
pub const E_IMAPI_RECORDER_DVD_STRUCTURE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600178));
pub const E_IMAPI_RECORDER_MEDIA_SPEED_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600177));
pub const E_IMAPI_RECORDER_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600176));
pub const E_IMAPI_RECORDER_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600175));
pub const E_IMAPI_RECORDER_MEDIA_NOT_FORMATTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600174));
pub const E_IMAPI_RECORDER_INVALID_RESPONSE_FROM_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599937));
pub const E_IMAPI_LOSS_OF_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599936));
pub const E_IMAPI_UNEXPECTED_RESPONSE_FROM_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599935));
pub const S_IMAPI_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141890));
pub const E_IMAPI_DF2DATA_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599680));
pub const E_IMAPI_DF2DATA_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599679));
pub const E_IMAPI_DF2DATA_INVALID_MEDIA_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599678));
pub const E_IMAPI_DF2DATA_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599677));
pub const E_IMAPI_DF2DATA_STREAM_TOO_LARGE_FOR_CURRENT_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599676));
pub const E_IMAPI_DF2DATA_MEDIA_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599675));
pub const E_IMAPI_DF2DATA_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599674));
pub const E_IMAPI_DF2DATA_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599673));
pub const E_IMAPI_DF2DATA_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599672));
pub const E_IMAPI_DF2TAO_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599424));
pub const E_IMAPI_DF2TAO_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599423));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599422));
pub const E_IMAPI_DF2TAO_MEDIA_IS_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599421));
pub const E_IMAPI_DF2TAO_PROPERTY_FOR_BLANK_MEDIA_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599420));
pub const E_IMAPI_DF2TAO_TABLE_OF_CONTENTS_EMPTY_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599419));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599418));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599417));
pub const E_IMAPI_DF2TAO_TRACK_LIMIT_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599416));
pub const E_IMAPI_DF2TAO_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599415));
pub const E_IMAPI_DF2TAO_NO_RECORDER_SPECIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599414));
pub const E_IMAPI_DF2TAO_INVALID_ISRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599413));
pub const E_IMAPI_DF2TAO_INVALID_MCN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599412));
pub const E_IMAPI_DF2TAO_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599411));
pub const E_IMAPI_DF2TAO_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599410));
pub const E_IMAPI_DF2TAO_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599409));
pub const E_IMAPI_DF2RAW_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599168));
pub const E_IMAPI_DF2RAW_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599167));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599166));
pub const E_IMAPI_DF2RAW_MEDIA_IS_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599165));
pub const E_IMAPI_DF2RAW_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599164));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599162));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599161));
pub const E_IMAPI_DF2RAW_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599159));
pub const E_IMAPI_DF2RAW_NO_RECORDER_SPECIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599158));
pub const E_IMAPI_DF2RAW_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599155));
pub const E_IMAPI_DF2RAW_DATA_BLOCK_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599154));
pub const E_IMAPI_DF2RAW_STREAM_LEADIN_TOO_SHORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599153));
pub const E_IMAPI_DF2RAW_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599152));
pub const E_IMAPI_ERASE_RECORDER_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340224));
pub const E_IMAPI_ERASE_ONLY_ONE_RECORDER_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340223));
pub const E_IMAPI_ERASE_DISC_INFORMATION_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340222));
pub const E_IMAPI_ERASE_MODE_PAGE_2A_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340221));
pub const E_IMAPI_ERASE_MEDIA_IS_NOT_ERASABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340220));
pub const E_IMAPI_ERASE_DRIVE_FAILED_ERASE_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340219));
pub const E_IMAPI_ERASE_TOOK_LONGER_THAN_ONE_HOUR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340218));
pub const E_IMAPI_ERASE_UNEXPECTED_DRIVE_RESPONSE_DURING_ERASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340217));
pub const E_IMAPI_ERASE_DRIVE_FAILED_SPINUP_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340216));
pub const E_IMAPI_ERASE_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598391));
pub const E_IMAPI_ERASE_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598390));
pub const E_IMAPI_ERASE_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598389));
pub const E_IMAPI_RAW_IMAGE_IS_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339968));
pub const E_IMAPI_RAW_IMAGE_TOO_MANY_TRACKS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339967));
pub const E_IMAPI_RAW_IMAGE_SECTOR_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339966));
pub const E_IMAPI_RAW_IMAGE_NO_TRACKS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339965));
pub const E_IMAPI_RAW_IMAGE_TRACKS_ALREADY_ADDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339964));
pub const E_IMAPI_RAW_IMAGE_INSUFFICIENT_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339963));
pub const E_IMAPI_RAW_IMAGE_TOO_MANY_TRACK_INDEXES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339962));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339961));
pub const S_IMAPI_RAW_IMAGE_TRACK_INDEX_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11143688));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_OFFSET_ZERO_CANNOT_BE_CLEARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339959));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_TOO_CLOSE_TO_OTHER_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339958));
pub const FACILITY_IMAPI2 = @as(u32, 170);
pub const IMAPI_E_FSI_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555392));
pub const IMAPI_E_INVALID_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555391));
pub const IMAPI_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555390));
pub const IMAPI_E_NO_OUTPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555389));
pub const IMAPI_E_INVALID_VOLUME_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555388));
pub const IMAPI_E_INVALID_DATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555387));
pub const IMAPI_E_FILE_SYSTEM_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555386));
pub const IMAPI_E_NOT_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555384));
pub const IMAPI_E_NOT_DIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555383));
pub const IMAPI_E_DIR_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555382));
pub const IMAPI_E_NOT_IN_FILE_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555381));
pub const IMAPI_E_INVALID_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555376));
pub const IMAPI_E_RESTRICTED_NAME_VIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555375));
pub const IMAPI_E_DUP_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555374));
pub const IMAPI_E_NO_UNIQUE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555373));
pub const IMAPI_E_ITEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555368));
pub const IMAPI_E_FILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555367));
pub const IMAPI_E_DIR_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555366));
pub const IMAPI_E_IMAGE_SIZE_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555360));
pub const IMAPI_E_IMAGE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555359));
pub const IMAPI_E_DATA_STREAM_INCONSISTENCY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555352));
pub const IMAPI_E_DATA_STREAM_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555351));
pub const IMAPI_E_DATA_STREAM_CREATE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555350));
pub const IMAPI_E_DIRECTORY_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555349));
pub const IMAPI_E_TOO_MANY_DIRS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555344));
pub const IMAPI_E_ISO9660_LEVELS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555343));
pub const IMAPI_E_DATA_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555342));
pub const IMAPI_E_INCOMPATIBLE_PREVIOUS_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555341));
pub const IMAPI_E_STASHFILE_OPEN_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555336));
pub const IMAPI_E_STASHFILE_SEEK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555335));
pub const IMAPI_E_STASHFILE_WRITE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555334));
pub const IMAPI_E_STASHFILE_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555333));
pub const IMAPI_E_INVALID_WORKING_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555328));
pub const IMAPI_E_WORKING_DIRECTORY_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555327));
pub const IMAPI_E_STASHFILE_MOVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555326));
pub const IMAPI_E_BOOT_IMAGE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555320));
pub const IMAPI_E_BOOT_OBJECT_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555319));
pub const IMAPI_E_BOOT_EMULATION_IMAGE_SIZE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555318));
pub const IMAPI_E_EMPTY_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555312));
pub const IMAPI_E_NO_SUPPORTED_FILE_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555311));
pub const IMAPI_E_FILE_SYSTEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555310));
pub const IMAPI_E_FILE_SYSTEM_READ_CONSISTENCY_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555309));
pub const IMAPI_E_FILE_SYSTEM_FEATURE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555308));
pub const IMAPI_E_IMPORT_TYPE_COLLISION_FILE_EXISTS_AS_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555307));
pub const IMAPI_E_IMPORT_SEEK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555306));
pub const IMAPI_E_IMPORT_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555305));
pub const IMAPI_E_DISC_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555304));
pub const IMAPI_E_IMPORT_MEDIA_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555303));
pub const IMAPI_E_UDF_NOT_WRITE_COMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555302));
pub const IMAPI_E_INCOMPATIBLE_MULTISESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555301));
pub const IMAPI_E_NO_COMPATIBLE_MULTISESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555300));
pub const IMAPI_E_MULTISESSION_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555299));
pub const IMAPI_E_IMPORT_TYPE_COLLISION_DIRECTORY_EXISTS_AS_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555298));
pub const IMAPI_S_IMAGE_FEATURE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11186527));
pub const IMAPI_E_PROPERTY_NOT_ACCESSIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555296));
pub const IMAPI_E_UDF_REVISION_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555295));
pub const IMAPI_E_BAD_MULTISESSION_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555294));
pub const IMAPI_E_FILE_SYSTEM_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555293));
pub const IMAPI_E_IMAGEMANAGER_IMAGE_NOT_ALIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555136));
pub const IMAPI_E_IMAGEMANAGER_NO_VALID_VD_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555135));
pub const IMAPI_E_IMAGEMANAGER_NO_IMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555134));
pub const IMAPI_E_IMAGEMANAGER_IMAGE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555133));
pub const MAPI_E_CALL_FAILED = @as(i32, -2147467259);
pub const MAPI_E_NOT_ENOUGH_MEMORY = @as(i32, -2147024882);
pub const MAPI_E_INVALID_PARAMETER = @as(i32, -2147024809);
pub const MAPI_E_INTERFACE_NOT_SUPPORTED = @as(i32, -2147467262);
pub const MAPI_E_NO_ACCESS = @as(i32, -2147024891);
pub const TAD_ALL_ROWS = @as(u32, 1);
pub const PRILOWEST = @as(i32, -32768);
pub const PRIHIGHEST = @as(u32, 32767);
pub const PRIUSER = @as(u32, 0);

//--------------------------------------------------------------------------------
// Section: Types (129)
//--------------------------------------------------------------------------------
pub const ENTRYID = extern struct {
    abFlags: [4]u8,
    ab: [1]u8,
};

pub const MAPIUID = extern struct {
    ab: [16]u8,
};

pub const SPropTagArray = extern struct {
    cValues: u32,
    aulPropTag: [1]u32,
};

pub const SBinary = extern struct {
    cb: u32,
    lpb: ?*u8,
};

pub const SShortArray = extern struct {
    cValues: u32,
    lpi: ?*i16,
};

pub const SGuidArray = extern struct {
    cValues: u32,
    lpguid: ?*Guid,
};

pub const SRealArray = extern struct {
    cValues: u32,
    lpflt: ?*f32,
};

pub const SLongArray = extern struct {
    cValues: u32,
    lpl: ?*i32,
};

pub const SLargeIntegerArray = extern struct {
    cValues: u32,
    lpli: ?*LARGE_INTEGER,
};

pub const SDateTimeArray = extern struct {
    cValues: u32,
    lpft: ?*FILETIME,
};

pub const SAppTimeArray = extern struct {
    cValues: u32,
    lpat: ?*f64,
};

pub const SCurrencyArray = extern struct {
    cValues: u32,
    lpcur: ?*CY,
};

pub const SBinaryArray = extern struct {
    cValues: u32,
    lpbin: ?*SBinary,
};

pub const SDoubleArray = extern struct {
    cValues: u32,
    lpdbl: ?*f64,
};

pub const SWStringArray = extern struct {
    cValues: u32,
    lppszW: ?*?PWSTR,
};

pub const SLPSTRArray = extern struct {
    cValues: u32,
    lppszA: ?*?PSTR,
};

pub const _PV = extern union {
    i: i16,
    l: i32,
    ul: u32,
    flt: f32,
    dbl: f64,
    b: u16,
    cur: CY,
    at: f64,
    ft: FILETIME,
    lpszA: ?PSTR,
    bin: SBinary,
    lpszW: ?PWSTR,
    lpguid: ?*Guid,
    li: LARGE_INTEGER,
    MVi: SShortArray,
    MVl: SLongArray,
    MVflt: SRealArray,
    MVdbl: SDoubleArray,
    MVcur: SCurrencyArray,
    MVat: SAppTimeArray,
    MVft: SDateTimeArray,
    MVbin: SBinaryArray,
    MVszA: SLPSTRArray,
    MVszW: SWStringArray,
    MVguid: SGuidArray,
    MVli: SLargeIntegerArray,
    err: i32,
    x: i32,
};

pub const SPropValue = extern struct {
    ulPropTag: u32,
    dwAlignPad: u32,
    Value: _PV,
};

pub const SPropProblem = extern struct {
    ulIndex: u32,
    ulPropTag: u32,
    scode: i32,
};

pub const SPropProblemArray = extern struct {
    cProblem: u32,
    aProblem: [1]SPropProblem,
};

pub const FLATENTRY = extern struct {
    cb: u32,
    abEntry: [1]u8,
};

pub const FLATENTRYLIST = extern struct {
    cEntries: u32,
    cbEntries: u32,
    abEntries: [1]u8,
};

pub const MTSID = extern struct {
    cb: u32,
    ab: [1]u8,
};

pub const FLATMTSIDLIST = extern struct {
    cMTSIDs: u32,
    cbMTSIDs: u32,
    abMTSIDs: [1]u8,
};

pub const ADRENTRY = extern struct {
    ulReserved1: u32,
    cValues: u32,
    rgPropVals: ?*SPropValue,
};

pub const ADRLIST = extern struct {
    cEntries: u32,
    aEntries: [1]ADRENTRY,
};

pub const SRow = extern struct {
    ulAdrEntryPad: u32,
    cValues: u32,
    lpProps: ?*SPropValue,
};

pub const SRowSet = extern struct {
    cRows: u32,
    aRow: [1]SRow,
};

pub const LPALLOCATEBUFFER = fn(
    cbSize: u32,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPALLOCATEMORE = fn(
    cbSize: u32,
    lpObject: ?*anyopaque,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFREEBUFFER = fn(
    lpBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const MAPIERROR = extern struct {
    ulVersion: u32,
    lpszError: ?*i8,
    lpszComponent: ?*i8,
    ulLowLevelError: u32,
    ulContext: u32,
};

pub const ERROR_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    scode: i32,
    ulFlags: u32,
    lpMAPIError: ?*MAPIERROR,
};

pub const NEWMAIL_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    cbParentID: u32,
    lpParentID: ?*ENTRYID,
    ulFlags: u32,
    lpszMessageClass: ?*i8,
    ulMessageFlags: u32,
};

pub const OBJECT_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    ulObjType: u32,
    cbParentID: u32,
    lpParentID: ?*ENTRYID,
    cbOldID: u32,
    lpOldID: ?*ENTRYID,
    cbOldParentID: u32,
    lpOldParentID: ?*ENTRYID,
    lpPropTagArray: ?*SPropTagArray,
};

pub const TABLE_NOTIFICATION = extern struct {
    ulTableEvent: u32,
    hResult: HRESULT,
    propIndex: SPropValue,
    propPrior: SPropValue,
    row: SRow,
    ulPad: u32,
};

pub const EXTENDED_NOTIFICATION = extern struct {
    ulEvent: u32,
    cb: u32,
    pbEventParameters: ?*u8,
};

pub const STATUS_OBJECT_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    cValues: u32,
    lpPropVals: ?*SPropValue,
};

pub const NOTIFICATION = extern struct {
    ulEventType: u32,
    ulAlignPad: u32,
    info: extern union {
        err: ERROR_NOTIFICATION,
        newmail: NEWMAIL_NOTIFICATION,
        obj: OBJECT_NOTIFICATION,
        tab: TABLE_NOTIFICATION,
        ext: EXTENDED_NOTIFICATION,
        statobj: STATUS_OBJECT_NOTIFICATION,
    },
};

pub const IMAPIAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: fn(
            self: *const IMAPIAdviseSink,
            cNotif: u32,
            lpNotifications: ?*NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIAdviseSink_OnNotify(self: *const T, cNotif: u32, lpNotifications: ?*NOTIFICATION) callconv(.Inline) u32 {
            return @ptrCast(*const IMAPIAdviseSink.VTable, self.vtable).OnNotify(@ptrCast(*const IMAPIAdviseSink, self), cNotif, lpNotifications);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const LPNOTIFCALLBACK = fn(
    lpvContext: ?*anyopaque,
    cNotification: u32,
    lpNotifications: ?*NOTIFICATION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const IMAPIProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Progress: fn(
            self: *const IMAPIProgress,
            ulValue: u32,
            ulCount: u32,
            ulTotal: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IMAPIProgress,
            lpulFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMax: fn(
            self: *const IMAPIProgress,
            lpulMax: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMin: fn(
            self: *const IMAPIProgress,
            lpulMin: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLimits: fn(
            self: *const IMAPIProgress,
            lpulMin: ?*u32,
            lpulMax: ?*u32,
            lpulFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProgress_Progress(self: *const T, ulValue: u32, ulCount: u32, ulTotal: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProgress.VTable, self.vtable).Progress(@ptrCast(*const IMAPIProgress, self), ulValue, ulCount, ulTotal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProgress_GetFlags(self: *const T, lpulFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProgress.VTable, self.vtable).GetFlags(@ptrCast(*const IMAPIProgress, self), lpulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProgress_GetMax(self: *const T, lpulMax: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProgress.VTable, self.vtable).GetMax(@ptrCast(*const IMAPIProgress, self), lpulMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProgress_GetMin(self: *const T, lpulMin: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProgress.VTable, self.vtable).GetMin(@ptrCast(*const IMAPIProgress, self), lpulMin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProgress_SetLimits(self: *const T, lpulMin: ?*u32, lpulMax: ?*u32, lpulFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProgress.VTable, self.vtable).SetLimits(@ptrCast(*const IMAPIProgress, self), lpulMin, lpulMax, lpulFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MAPINAMEID = extern struct {
    lpguid: ?*Guid,
    ulKind: u32,
    Kind: extern union {
        lID: i32,
        lpwstrName: ?PWSTR,
    },
};

pub const IMAPIProp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: fn(
            self: *const IMAPIProp,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveChanges: fn(
            self: *const IMAPIProp,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProps: fn(
            self: *const IMAPIProp,
            lpPropTagArray: ?*SPropTagArray,
            ulFlags: u32,
            lpcValues: ?*u32,
            lppPropArray: ?*?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropList: fn(
            self: *const IMAPIProp,
            ulFlags: u32,
            lppPropTagArray: ?*?*SPropTagArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenProperty: fn(
            self: *const IMAPIProp,
            ulPropTag: u32,
            lpiid: ?*Guid,
            ulInterfaceOptions: u32,
            ulFlags: u32,
            lppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProps: fn(
            self: *const IMAPIProp,
            cValues: u32,
            lpPropArray: ?*SPropValue,
            lppProblems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteProps: fn(
            self: *const IMAPIProp,
            lpPropTagArray: ?*SPropTagArray,
            lppProblems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTo: fn(
            self: *const IMAPIProp,
            ciidExclude: u32,
            rgiidExclude: ?*Guid,
            lpExcludeProps: ?*SPropTagArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            lpInterface: ?*Guid,
            lpDestObj: ?*anyopaque,
            ulFlags: u32,
            lppProblems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyProps: fn(
            self: *const IMAPIProp,
            lpIncludeProps: ?*SPropTagArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            lpInterface: ?*Guid,
            lpDestObj: ?*anyopaque,
            ulFlags: u32,
            lppProblems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamesFromIDs: fn(
            self: *const IMAPIProp,
            lppPropTags: ?*?*SPropTagArray,
            lpPropSetGuid: ?*Guid,
            ulFlags: u32,
            lpcPropNames: ?*u32,
            lpppPropNames: ?*?*?*MAPINAMEID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDsFromNames: fn(
            self: *const IMAPIProp,
            cPropNames: u32,
            lppPropNames: ?*?*MAPINAMEID,
            ulFlags: u32,
            lppPropTags: ?*?*SPropTagArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).GetLastError(@ptrCast(*const IMAPIProp, self), hResult, ulFlags, lppMAPIError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_SaveChanges(self: *const T, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).SaveChanges(@ptrCast(*const IMAPIProp, self), ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_GetProps(self: *const T, lpPropTagArray: ?*SPropTagArray, ulFlags: u32, lpcValues: ?*u32, lppPropArray: ?*?*SPropValue) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).GetProps(@ptrCast(*const IMAPIProp, self), lpPropTagArray, ulFlags, lpcValues, lppPropArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_GetPropList(self: *const T, ulFlags: u32, lppPropTagArray: ?*?*SPropTagArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).GetPropList(@ptrCast(*const IMAPIProp, self), ulFlags, lppPropTagArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_OpenProperty(self: *const T, ulPropTag: u32, lpiid: ?*Guid, ulInterfaceOptions: u32, ulFlags: u32, lppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).OpenProperty(@ptrCast(*const IMAPIProp, self), ulPropTag, lpiid, ulInterfaceOptions, ulFlags, lppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_SetProps(self: *const T, cValues: u32, lpPropArray: ?*SPropValue, lppProblems: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).SetProps(@ptrCast(*const IMAPIProp, self), cValues, lpPropArray, lppProblems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_DeleteProps(self: *const T, lpPropTagArray: ?*SPropTagArray, lppProblems: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).DeleteProps(@ptrCast(*const IMAPIProp, self), lpPropTagArray, lppProblems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_CopyTo(self: *const T, ciidExclude: u32, rgiidExclude: ?*Guid, lpExcludeProps: ?*SPropTagArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, lpInterface: ?*Guid, lpDestObj: ?*anyopaque, ulFlags: u32, lppProblems: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).CopyTo(@ptrCast(*const IMAPIProp, self), ciidExclude, rgiidExclude, lpExcludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_CopyProps(self: *const T, lpIncludeProps: ?*SPropTagArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, lpInterface: ?*Guid, lpDestObj: ?*anyopaque, ulFlags: u32, lppProblems: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).CopyProps(@ptrCast(*const IMAPIProp, self), lpIncludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_GetNamesFromIDs(self: *const T, lppPropTags: ?*?*SPropTagArray, lpPropSetGuid: ?*Guid, ulFlags: u32, lpcPropNames: ?*u32, lpppPropNames: ?*?*?*MAPINAMEID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).GetNamesFromIDs(@ptrCast(*const IMAPIProp, self), lppPropTags, lpPropSetGuid, ulFlags, lpcPropNames, lpppPropNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIProp_GetIDsFromNames(self: *const T, cPropNames: u32, lppPropNames: ?*?*MAPINAMEID, ulFlags: u32, lppPropTags: ?*?*SPropTagArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIProp.VTable, self.vtable).GetIDsFromNames(@ptrCast(*const IMAPIProp, self), cPropNames, lppPropNames, ulFlags, lppPropTags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SSortOrder = extern struct {
    ulPropTag: u32,
    ulOrder: u32,
};

pub const SSortOrderSet = extern struct {
    cSorts: u32,
    cCategories: u32,
    cExpanded: u32,
    aSort: [1]SSortOrder,
};

pub const SAndRestriction = extern struct {
    cRes: u32,
    lpRes: ?*SRestriction,
};

pub const SOrRestriction = extern struct {
    cRes: u32,
    lpRes: ?*SRestriction,
};

pub const SNotRestriction = extern struct {
    ulReserved: u32,
    lpRes: ?*SRestriction,
};

pub const SContentRestriction = extern struct {
    ulFuzzyLevel: u32,
    ulPropTag: u32,
    lpProp: ?*SPropValue,
};

pub const SBitMaskRestriction = extern struct {
    relBMR: u32,
    ulPropTag: u32,
    ulMask: u32,
};

pub const SPropertyRestriction = extern struct {
    relop: u32,
    ulPropTag: u32,
    lpProp: ?*SPropValue,
};

pub const SComparePropsRestriction = extern struct {
    relop: u32,
    ulPropTag1: u32,
    ulPropTag2: u32,
};

pub const SSizeRestriction = extern struct {
    relop: u32,
    ulPropTag: u32,
    cb: u32,
};

pub const SExistRestriction = extern struct {
    ulReserved1: u32,
    ulPropTag: u32,
    ulReserved2: u32,
};

pub const SSubRestriction = extern struct {
    ulSubObject: u32,
    lpRes: ?*SRestriction,
};

pub const SCommentRestriction = extern struct {
    cValues: u32,
    lpRes: ?*SRestriction,
    lpProp: ?*SPropValue,
};

pub const SRestriction = extern struct {
    rt: u32,
    res: extern union {
        resCompareProps: SComparePropsRestriction,
        resAnd: SAndRestriction,
        resOr: SOrRestriction,
        resNot: SNotRestriction,
        resContent: SContentRestriction,
        resProperty: SPropertyRestriction,
        resBitMask: SBitMaskRestriction,
        resSize: SSizeRestriction,
        resExist: SExistRestriction,
        resSub: SSubRestriction,
        resComment: SCommentRestriction,
    },
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMAPITable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: fn(
            self: *const IMAPITable,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IMAPITable,
            ulEventMask: u32,
            lpAdviseSink: ?*IMAPIAdviseSink,
            lpulConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IMAPITable,
            ulConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const IMAPITable,
            lpulTableStatus: ?*u32,
            lpulTableType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumns: fn(
            self: *const IMAPITable,
            lpPropTagArray: ?*SPropTagArray,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryColumns: fn(
            self: *const IMAPITable,
            ulFlags: u32,
            lpPropTagArray: ?*?*SPropTagArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowCount: fn(
            self: *const IMAPITable,
            ulFlags: u32,
            lpulCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SeekRow: fn(
            self: *const IMAPITable,
            bkOrigin: u32,
            lRowCount: i32,
            lplRowsSought: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SeekRowApprox: fn(
            self: *const IMAPITable,
            ulNumerator: u32,
            ulDenominator: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPosition: fn(
            self: *const IMAPITable,
            lpulRow: ?*u32,
            lpulNumerator: ?*u32,
            lpulDenominator: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindRow: fn(
            self: *const IMAPITable,
            lpRestriction: ?*SRestriction,
            bkOrigin: u32,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Restrict: fn(
            self: *const IMAPITable,
            lpRestriction: ?*SRestriction,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBookmark: fn(
            self: *const IMAPITable,
            lpbkPosition: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBookmark: fn(
            self: *const IMAPITable,
            bkPosition: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SortTable: fn(
            self: *const IMAPITable,
            lpSortCriteria: ?*SSortOrderSet,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QuerySortOrder: fn(
            self: *const IMAPITable,
            lppSortCriteria: ?*?*SSortOrderSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryRows: fn(
            self: *const IMAPITable,
            lRowCount: i32,
            ulFlags: u32,
            lppRows: ?*?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExpandRow: fn(
            self: *const IMAPITable,
            cbInstanceKey: u32,
            pbInstanceKey: ?*u8,
            ulRowCount: u32,
            ulFlags: u32,
            lppRows: ?*?*SRowSet,
            lpulMoreRows: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CollapseRow: fn(
            self: *const IMAPITable,
            cbInstanceKey: u32,
            pbInstanceKey: ?*u8,
            ulFlags: u32,
            lpulRowCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForCompletion: fn(
            self: *const IMAPITable,
            ulFlags: u32,
            ulTimeout: u32,
            lpulTableStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCollapseState: fn(
            self: *const IMAPITable,
            ulFlags: u32,
            cbInstanceKey: u32,
            lpbInstanceKey: ?*u8,
            lpcbCollapseState: ?*u32,
            lppbCollapseState: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCollapseState: fn(
            self: *const IMAPITable,
            ulFlags: u32,
            cbCollapseState: u32,
            pbCollapseState: ?*u8,
            lpbkLocation: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).GetLastError(@ptrCast(*const IMAPITable, self), hResult, ulFlags, lppMAPIError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_Advise(self: *const T, ulEventMask: u32, lpAdviseSink: ?*IMAPIAdviseSink, lpulConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).Advise(@ptrCast(*const IMAPITable, self), ulEventMask, lpAdviseSink, lpulConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_Unadvise(self: *const T, ulConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).Unadvise(@ptrCast(*const IMAPITable, self), ulConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_GetStatus(self: *const T, lpulTableStatus: ?*u32, lpulTableType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).GetStatus(@ptrCast(*const IMAPITable, self), lpulTableStatus, lpulTableType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_SetColumns(self: *const T, lpPropTagArray: ?*SPropTagArray, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).SetColumns(@ptrCast(*const IMAPITable, self), lpPropTagArray, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_QueryColumns(self: *const T, ulFlags: u32, lpPropTagArray: ?*?*SPropTagArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).QueryColumns(@ptrCast(*const IMAPITable, self), ulFlags, lpPropTagArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_GetRowCount(self: *const T, ulFlags: u32, lpulCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).GetRowCount(@ptrCast(*const IMAPITable, self), ulFlags, lpulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_SeekRow(self: *const T, bkOrigin: u32, lRowCount: i32, lplRowsSought: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).SeekRow(@ptrCast(*const IMAPITable, self), bkOrigin, lRowCount, lplRowsSought);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_SeekRowApprox(self: *const T, ulNumerator: u32, ulDenominator: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).SeekRowApprox(@ptrCast(*const IMAPITable, self), ulNumerator, ulDenominator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_QueryPosition(self: *const T, lpulRow: ?*u32, lpulNumerator: ?*u32, lpulDenominator: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).QueryPosition(@ptrCast(*const IMAPITable, self), lpulRow, lpulNumerator, lpulDenominator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_FindRow(self: *const T, lpRestriction: ?*SRestriction, bkOrigin: u32, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).FindRow(@ptrCast(*const IMAPITable, self), lpRestriction, bkOrigin, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_Restrict(self: *const T, lpRestriction: ?*SRestriction, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).Restrict(@ptrCast(*const IMAPITable, self), lpRestriction, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_CreateBookmark(self: *const T, lpbkPosition: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).CreateBookmark(@ptrCast(*const IMAPITable, self), lpbkPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_FreeBookmark(self: *const T, bkPosition: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).FreeBookmark(@ptrCast(*const IMAPITable, self), bkPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_SortTable(self: *const T, lpSortCriteria: ?*SSortOrderSet, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).SortTable(@ptrCast(*const IMAPITable, self), lpSortCriteria, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_QuerySortOrder(self: *const T, lppSortCriteria: ?*?*SSortOrderSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).QuerySortOrder(@ptrCast(*const IMAPITable, self), lppSortCriteria);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_QueryRows(self: *const T, lRowCount: i32, ulFlags: u32, lppRows: ?*?*SRowSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).QueryRows(@ptrCast(*const IMAPITable, self), lRowCount, ulFlags, lppRows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).Abort(@ptrCast(*const IMAPITable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_ExpandRow(self: *const T, cbInstanceKey: u32, pbInstanceKey: ?*u8, ulRowCount: u32, ulFlags: u32, lppRows: ?*?*SRowSet, lpulMoreRows: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).ExpandRow(@ptrCast(*const IMAPITable, self), cbInstanceKey, pbInstanceKey, ulRowCount, ulFlags, lppRows, lpulMoreRows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_CollapseRow(self: *const T, cbInstanceKey: u32, pbInstanceKey: ?*u8, ulFlags: u32, lpulRowCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).CollapseRow(@ptrCast(*const IMAPITable, self), cbInstanceKey, pbInstanceKey, ulFlags, lpulRowCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_WaitForCompletion(self: *const T, ulFlags: u32, ulTimeout: u32, lpulTableStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).WaitForCompletion(@ptrCast(*const IMAPITable, self), ulFlags, ulTimeout, lpulTableStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_GetCollapseState(self: *const T, ulFlags: u32, cbInstanceKey: u32, lpbInstanceKey: ?*u8, lpcbCollapseState: ?*u32, lppbCollapseState: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).GetCollapseState(@ptrCast(*const IMAPITable, self), ulFlags, cbInstanceKey, lpbInstanceKey, lpcbCollapseState, lppbCollapseState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPITable_SetCollapseState(self: *const T, ulFlags: u32, cbCollapseState: u32, pbCollapseState: ?*u8, lpbkLocation: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPITable.VTable, self.vtable).SetCollapseState(@ptrCast(*const IMAPITable, self), ulFlags, cbCollapseState, pbCollapseState, lpbkLocation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IProfSect = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIProp.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMAPIStatus = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        ValidateState: fn(
            self: *const IMAPIStatus,
            ulUIParam: usize,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SettingsDialog: fn(
            self: *const IMAPIStatus,
            ulUIParam: usize,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangePassword: fn(
            self: *const IMAPIStatus,
            lpOldPass: ?*i8,
            lpNewPass: ?*i8,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushQueues: fn(
            self: *const IMAPIStatus,
            ulUIParam: usize,
            cbTargetTransport: u32,
            lpTargetTransport: ?[*]ENTRYID,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIProp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIStatus_ValidateState(self: *const T, ulUIParam: usize, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIStatus.VTable, self.vtable).ValidateState(@ptrCast(*const IMAPIStatus, self), ulUIParam, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIStatus_SettingsDialog(self: *const T, ulUIParam: usize, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIStatus.VTable, self.vtable).SettingsDialog(@ptrCast(*const IMAPIStatus, self), ulUIParam, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIStatus_ChangePassword(self: *const T, lpOldPass: ?*i8, lpNewPass: ?*i8, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIStatus.VTable, self.vtable).ChangePassword(@ptrCast(*const IMAPIStatus, self), lpOldPass, lpNewPass, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIStatus_FlushQueues(self: *const T, ulUIParam: usize, cbTargetTransport: u32, lpTargetTransport: ?[*]ENTRYID, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIStatus.VTable, self.vtable).FlushQueues(@ptrCast(*const IMAPIStatus, self), ulUIParam, cbTargetTransport, lpTargetTransport, ulFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMAPIContainer = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        GetContentsTable: fn(
            self: *const IMAPIContainer,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHierarchyTable: fn(
            self: *const IMAPIContainer,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenEntry: fn(
            self: *const IMAPIContainer,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lpulObjType: ?*u32,
            lppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSearchCriteria: fn(
            self: *const IMAPIContainer,
            lpRestriction: ?*SRestriction,
            lpContainerList: ?*SBinaryArray,
            ulSearchFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSearchCriteria: fn(
            self: *const IMAPIContainer,
            ulFlags: u32,
            lppRestriction: ?*?*SRestriction,
            lppContainerList: ?*?*SBinaryArray,
            lpulSearchState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIProp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIContainer_GetContentsTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIContainer.VTable, self.vtable).GetContentsTable(@ptrCast(*const IMAPIContainer, self), ulFlags, lppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIContainer_GetHierarchyTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIContainer.VTable, self.vtable).GetHierarchyTable(@ptrCast(*const IMAPIContainer, self), ulFlags, lppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIContainer_OpenEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, ulFlags: u32, lpulObjType: ?*u32, lppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIContainer.VTable, self.vtable).OpenEntry(@ptrCast(*const IMAPIContainer, self), cbEntryID, lpEntryID, lpInterface, ulFlags, lpulObjType, lppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIContainer_SetSearchCriteria(self: *const T, lpRestriction: ?*SRestriction, lpContainerList: ?*SBinaryArray, ulSearchFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIContainer.VTable, self.vtable).SetSearchCriteria(@ptrCast(*const IMAPIContainer, self), lpRestriction, lpContainerList, ulSearchFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIContainer_GetSearchCriteria(self: *const T, ulFlags: u32, lppRestriction: ?*?*SRestriction, lppContainerList: ?*?*SBinaryArray, lpulSearchState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIContainer.VTable, self.vtable).GetSearchCriteria(@ptrCast(*const IMAPIContainer, self), ulFlags, lppRestriction, lppContainerList, lpulSearchState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _flaglist = extern struct {
    cFlags: u32,
    ulFlag: [1]u32,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IABContainer = extern struct {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateEntry: fn(
            self: *const IABContainer,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulCreateFlags: u32,
            lppMAPIPropEntry: ?*?*IMAPIProp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyEntries: fn(
            self: *const IABContainer,
            lpEntries: ?*SBinaryArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteEntries: fn(
            self: *const IABContainer,
            lpEntries: ?*SBinaryArray,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveNames: fn(
            self: *const IABContainer,
            lpPropTagArray: ?*SPropTagArray,
            ulFlags: u32,
            lpAdrList: ?*ADRLIST,
            lpFlagList: ?*_flaglist,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIContainer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IABContainer_CreateEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulCreateFlags: u32, lppMAPIPropEntry: ?*?*IMAPIProp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IABContainer.VTable, self.vtable).CreateEntry(@ptrCast(*const IABContainer, self), cbEntryID, lpEntryID, ulCreateFlags, lppMAPIPropEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IABContainer_CopyEntries(self: *const T, lpEntries: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IABContainer.VTable, self.vtable).CopyEntries(@ptrCast(*const IABContainer, self), lpEntries, ulUIParam, lpProgress, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IABContainer_DeleteEntries(self: *const T, lpEntries: ?*SBinaryArray, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IABContainer.VTable, self.vtable).DeleteEntries(@ptrCast(*const IABContainer, self), lpEntries, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IABContainer_ResolveNames(self: *const T, lpPropTagArray: ?*SPropTagArray, ulFlags: u32, lpAdrList: ?*ADRLIST, lpFlagList: ?*_flaglist) callconv(.Inline) HRESULT {
            return @ptrCast(*const IABContainer.VTable, self.vtable).ResolveNames(@ptrCast(*const IABContainer, self), lpPropTagArray, ulFlags, lpAdrList, lpFlagList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMailUser = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIProp.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IDistList = extern struct {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateEntry: fn(
            self: *const IDistList,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulCreateFlags: u32,
            lppMAPIPropEntry: ?*?*IMAPIProp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyEntries: fn(
            self: *const IDistList,
            lpEntries: ?*SBinaryArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteEntries: fn(
            self: *const IDistList,
            lpEntries: ?*SBinaryArray,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveNames: fn(
            self: *const IDistList,
            lpPropTagArray: ?*SPropTagArray,
            ulFlags: u32,
            lpAdrList: ?*ADRLIST,
            lpFlagList: ?*_flaglist,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIContainer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistList_CreateEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulCreateFlags: u32, lppMAPIPropEntry: ?*?*IMAPIProp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDistList.VTable, self.vtable).CreateEntry(@ptrCast(*const IDistList, self), cbEntryID, lpEntryID, ulCreateFlags, lppMAPIPropEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistList_CopyEntries(self: *const T, lpEntries: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDistList.VTable, self.vtable).CopyEntries(@ptrCast(*const IDistList, self), lpEntries, ulUIParam, lpProgress, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistList_DeleteEntries(self: *const T, lpEntries: ?*SBinaryArray, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDistList.VTable, self.vtable).DeleteEntries(@ptrCast(*const IDistList, self), lpEntries, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistList_ResolveNames(self: *const T, lpPropTagArray: ?*SPropTagArray, ulFlags: u32, lpAdrList: ?*ADRLIST, lpFlagList: ?*_flaglist) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDistList.VTable, self.vtable).ResolveNames(@ptrCast(*const IDistList, self), lpPropTagArray, ulFlags, lpAdrList, lpFlagList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMAPIFolder = extern struct {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateMessage: fn(
            self: *const IMAPIFolder,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lppMessage: ?*?*IMessage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyMessages: fn(
            self: *const IMAPIFolder,
            lpMsgList: ?*SBinaryArray,
            lpInterface: ?*Guid,
            lpDestFolder: ?*anyopaque,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMessages: fn(
            self: *const IMAPIFolder,
            lpMsgList: ?*SBinaryArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFolder: fn(
            self: *const IMAPIFolder,
            ulFolderType: u32,
            lpszFolderName: ?*i8,
            lpszFolderComment: ?*i8,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lppFolder: ?*?*IMAPIFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyFolder: fn(
            self: *const IMAPIFolder,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            lpInterface: ?*Guid,
            lpDestFolder: ?*anyopaque,
            lpszNewFolderName: ?*i8,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteFolder: fn(
            self: *const IMAPIFolder,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReadFlags: fn(
            self: *const IMAPIFolder,
            lpMsgList: ?*SBinaryArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageStatus: fn(
            self: *const IMAPIFolder,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulFlags: u32,
            lpulMessageStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMessageStatus: fn(
            self: *const IMAPIFolder,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulNewStatus: u32,
            ulNewStatusMask: u32,
            lpulOldStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveContentsSort: fn(
            self: *const IMAPIFolder,
            lpSortCriteria: ?*SSortOrderSet,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EmptyFolder: fn(
            self: *const IMAPIFolder,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIContainer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_CreateMessage(self: *const T, lpInterface: ?*Guid, ulFlags: u32, lppMessage: ?*?*IMessage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).CreateMessage(@ptrCast(*const IMAPIFolder, self), lpInterface, ulFlags, lppMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_CopyMessages(self: *const T, lpMsgList: ?*SBinaryArray, lpInterface: ?*Guid, lpDestFolder: ?*anyopaque, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).CopyMessages(@ptrCast(*const IMAPIFolder, self), lpMsgList, lpInterface, lpDestFolder, ulUIParam, lpProgress, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_DeleteMessages(self: *const T, lpMsgList: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).DeleteMessages(@ptrCast(*const IMAPIFolder, self), lpMsgList, ulUIParam, lpProgress, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_CreateFolder(self: *const T, ulFolderType: u32, lpszFolderName: ?*i8, lpszFolderComment: ?*i8, lpInterface: ?*Guid, ulFlags: u32, lppFolder: ?*?*IMAPIFolder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).CreateFolder(@ptrCast(*const IMAPIFolder, self), ulFolderType, lpszFolderName, lpszFolderComment, lpInterface, ulFlags, lppFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_CopyFolder(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, lpDestFolder: ?*anyopaque, lpszNewFolderName: ?*i8, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).CopyFolder(@ptrCast(*const IMAPIFolder, self), cbEntryID, lpEntryID, lpInterface, lpDestFolder, lpszNewFolderName, ulUIParam, lpProgress, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_DeleteFolder(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).DeleteFolder(@ptrCast(*const IMAPIFolder, self), cbEntryID, lpEntryID, ulUIParam, lpProgress, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_SetReadFlags(self: *const T, lpMsgList: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).SetReadFlags(@ptrCast(*const IMAPIFolder, self), lpMsgList, ulUIParam, lpProgress, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_GetMessageStatus(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulFlags: u32, lpulMessageStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).GetMessageStatus(@ptrCast(*const IMAPIFolder, self), cbEntryID, lpEntryID, ulFlags, lpulMessageStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_SetMessageStatus(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulNewStatus: u32, ulNewStatusMask: u32, lpulOldStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).SetMessageStatus(@ptrCast(*const IMAPIFolder, self), cbEntryID, lpEntryID, ulNewStatus, ulNewStatusMask, lpulOldStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_SaveContentsSort(self: *const T, lpSortCriteria: ?*SSortOrderSet, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).SaveContentsSort(@ptrCast(*const IMAPIFolder, self), lpSortCriteria, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIFolder_EmptyFolder(self: *const T, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIFolder.VTable, self.vtable).EmptyFolder(@ptrCast(*const IMAPIFolder, self), ulUIParam, lpProgress, ulFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMsgStore = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        Advise: fn(
            self: *const IMsgStore,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulEventMask: u32,
            lpAdviseSink: ?*IMAPIAdviseSink,
            lpulConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IMsgStore,
            ulConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEntryIDs: fn(
            self: *const IMsgStore,
            cbEntryID1: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID1: ?*ENTRYID,
            cbEntryID2: u32,
            // TODO: what to do with BytesParamIndex 2?
            lpEntryID2: ?*ENTRYID,
            ulFlags: u32,
            lpulResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenEntry: fn(
            self: *const IMsgStore,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lpulObjType: ?*u32,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReceiveFolder: fn(
            self: *const IMsgStore,
            lpszMessageClass: ?*i8,
            ulFlags: u32,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 2?
            lpEntryID: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReceiveFolder: fn(
            self: *const IMsgStore,
            lpszMessageClass: ?*i8,
            ulFlags: u32,
            lpcbEntryID: ?*u32,
            lppEntryID: ?*?*ENTRYID,
            lppszExplicitClass: ?*?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReceiveFolderTable: fn(
            self: *const IMsgStore,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoreLogoff: fn(
            self: *const IMsgStore,
            lpulFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortSubmit: fn(
            self: *const IMsgStore,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutgoingQueue: fn(
            self: *const IMsgStore,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLockState: fn(
            self: *const IMsgStore,
            lpMessage: ?*IMessage,
            ulLockState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FinishedMsg: fn(
            self: *const IMsgStore,
            ulFlags: u32,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 1?
            lpEntryID: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyNewMail: fn(
            self: *const IMsgStore,
            lpNotification: ?*NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIProp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_Advise(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulEventMask: u32, lpAdviseSink: ?*IMAPIAdviseSink, lpulConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).Advise(@ptrCast(*const IMsgStore, self), cbEntryID, lpEntryID, ulEventMask, lpAdviseSink, lpulConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_Unadvise(self: *const T, ulConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).Unadvise(@ptrCast(*const IMsgStore, self), ulConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_CompareEntryIDs(self: *const T, cbEntryID1: u32, lpEntryID1: ?*ENTRYID, cbEntryID2: u32, lpEntryID2: ?*ENTRYID, ulFlags: u32, lpulResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).CompareEntryIDs(@ptrCast(*const IMsgStore, self), cbEntryID1, lpEntryID1, cbEntryID2, lpEntryID2, ulFlags, lpulResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_OpenEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, ulFlags: u32, lpulObjType: ?*u32, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).OpenEntry(@ptrCast(*const IMsgStore, self), cbEntryID, lpEntryID, lpInterface, ulFlags, lpulObjType, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_SetReceiveFolder(self: *const T, lpszMessageClass: ?*i8, ulFlags: u32, cbEntryID: u32, lpEntryID: ?*ENTRYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).SetReceiveFolder(@ptrCast(*const IMsgStore, self), lpszMessageClass, ulFlags, cbEntryID, lpEntryID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_GetReceiveFolder(self: *const T, lpszMessageClass: ?*i8, ulFlags: u32, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID, lppszExplicitClass: ?*?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).GetReceiveFolder(@ptrCast(*const IMsgStore, self), lpszMessageClass, ulFlags, lpcbEntryID, lppEntryID, lppszExplicitClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_GetReceiveFolderTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).GetReceiveFolderTable(@ptrCast(*const IMsgStore, self), ulFlags, lppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_StoreLogoff(self: *const T, lpulFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).StoreLogoff(@ptrCast(*const IMsgStore, self), lpulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_AbortSubmit(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).AbortSubmit(@ptrCast(*const IMsgStore, self), cbEntryID, lpEntryID, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_GetOutgoingQueue(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).GetOutgoingQueue(@ptrCast(*const IMsgStore, self), ulFlags, lppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_SetLockState(self: *const T, lpMessage: ?*IMessage, ulLockState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).SetLockState(@ptrCast(*const IMsgStore, self), lpMessage, ulLockState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_FinishedMsg(self: *const T, ulFlags: u32, cbEntryID: u32, lpEntryID: ?*ENTRYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).FinishedMsg(@ptrCast(*const IMsgStore, self), ulFlags, cbEntryID, lpEntryID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsgStore_NotifyNewMail(self: *const T, lpNotification: ?*NOTIFICATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsgStore.VTable, self.vtable).NotifyNewMail(@ptrCast(*const IMsgStore, self), lpNotification);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMessage = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        GetAttachmentTable: fn(
            self: *const IMessage,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenAttach: fn(
            self: *const IMessage,
            ulAttachmentNum: u32,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lppAttach: ?*?*IAttach,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAttach: fn(
            self: *const IMessage,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lpulAttachmentNum: ?*u32,
            lppAttach: ?*?*IAttach,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAttach: fn(
            self: *const IMessage,
            ulAttachmentNum: u32,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecipientTable: fn(
            self: *const IMessage,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyRecipients: fn(
            self: *const IMessage,
            ulFlags: u32,
            lpMods: ?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubmitMessage: fn(
            self: *const IMessage,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReadFlag: fn(
            self: *const IMessage,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIProp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessage_GetAttachmentTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessage.VTable, self.vtable).GetAttachmentTable(@ptrCast(*const IMessage, self), ulFlags, lppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessage_OpenAttach(self: *const T, ulAttachmentNum: u32, lpInterface: ?*Guid, ulFlags: u32, lppAttach: ?*?*IAttach) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessage.VTable, self.vtable).OpenAttach(@ptrCast(*const IMessage, self), ulAttachmentNum, lpInterface, ulFlags, lppAttach);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessage_CreateAttach(self: *const T, lpInterface: ?*Guid, ulFlags: u32, lpulAttachmentNum: ?*u32, lppAttach: ?*?*IAttach) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessage.VTable, self.vtable).CreateAttach(@ptrCast(*const IMessage, self), lpInterface, ulFlags, lpulAttachmentNum, lppAttach);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessage_DeleteAttach(self: *const T, ulAttachmentNum: u32, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessage.VTable, self.vtable).DeleteAttach(@ptrCast(*const IMessage, self), ulAttachmentNum, ulUIParam, lpProgress, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessage_GetRecipientTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessage.VTable, self.vtable).GetRecipientTable(@ptrCast(*const IMessage, self), ulFlags, lppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessage_ModifyRecipients(self: *const T, ulFlags: u32, lpMods: ?*ADRLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessage.VTable, self.vtable).ModifyRecipients(@ptrCast(*const IMessage, self), ulFlags, lpMods);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessage_SubmitMessage(self: *const T, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessage.VTable, self.vtable).SubmitMessage(@ptrCast(*const IMessage, self), ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessage_SetReadFlag(self: *const T, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessage.VTable, self.vtable).SetReadFlag(@ptrCast(*const IMessage, self), ulFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IAttach = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIProp.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const LPFNABSDI = fn(
    ulUIParam: usize,
    lpvmsg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFNDISMISS = fn(
    ulUIParam: usize,
    lpvContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPFNBUTTON = fn(
    ulUIParam: usize,
    lpvContext: ?*anyopaque,
    cbEntryID: u32,
    lpSelection: ?*ENTRYID,
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ADRPARM = extern struct {
    cbABContEntryID: u32,
    lpABContEntryID: ?*ENTRYID,
    ulFlags: u32,
    lpReserved: ?*anyopaque,
    ulHelpContext: u32,
    lpszHelpFileName: ?*i8,
    lpfnABSDI: ?LPFNABSDI,
    lpfnDismiss: ?LPFNDISMISS,
    lpvDismissContext: ?*anyopaque,
    lpszCaption: ?*i8,
    lpszNewEntryTitle: ?*i8,
    lpszDestWellsTitle: ?*i8,
    cDestFields: u32,
    nDestFieldFocus: u32,
    lppszDestTitles: ?*?*i8,
    lpulDestComps: ?*u32,
    lpContRestriction: ?*SRestriction,
    lpHierRestriction: ?*SRestriction,
};

pub const IMAPIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: fn(
            self: *const IMAPIControl,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: fn(
            self: *const IMAPIControl,
            ulFlags: u32,
            ulUIParam: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IMAPIControl,
            ulFlags: u32,
            lpulState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIControl_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIControl.VTable, self.vtable).GetLastError(@ptrCast(*const IMAPIControl, self), hResult, ulFlags, lppMAPIError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIControl_Activate(self: *const T, ulFlags: u32, ulUIParam: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIControl.VTable, self.vtable).Activate(@ptrCast(*const IMAPIControl, self), ulFlags, ulUIParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMAPIControl_GetState(self: *const T, ulFlags: u32, lpulState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMAPIControl.VTable, self.vtable).GetState(@ptrCast(*const IMAPIControl, self), ulFlags, lpulState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DTBLLABEL = extern struct {
    ulbLpszLabelName: u32,
    ulFlags: u32,
};

pub const DTBLEDIT = extern struct {
    ulbLpszCharsAllowed: u32,
    ulFlags: u32,
    ulNumCharsAllowed: u32,
    ulPropTag: u32,
};

pub const DTBLLBX = extern struct {
    ulFlags: u32,
    ulPRSetProperty: u32,
    ulPRTableName: u32,
};

pub const DTBLCOMBOBOX = extern struct {
    ulbLpszCharsAllowed: u32,
    ulFlags: u32,
    ulNumCharsAllowed: u32,
    ulPRPropertyName: u32,
    ulPRTableName: u32,
};

pub const DTBLDDLBX = extern struct {
    ulFlags: u32,
    ulPRDisplayProperty: u32,
    ulPRSetProperty: u32,
    ulPRTableName: u32,
};

pub const DTBLCHECKBOX = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulPRPropertyName: u32,
};

pub const DTBLGROUPBOX = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
};

pub const DTBLBUTTON = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulPRControl: u32,
};

pub const DTBLPAGE = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulbLpszComponent: u32,
    ulContext: u32,
};

pub const DTBLRADIOBUTTON = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulcButtons: u32,
    ulPropTag: u32,
    lReturnValue: i32,
};

pub const DTBLMVLISTBOX = extern struct {
    ulFlags: u32,
    ulMVPropTag: u32,
};

pub const DTBLMVDDLBX = extern struct {
    ulFlags: u32,
    ulMVPropTag: u32,
};

pub const IProviderAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: fn(
            self: *const IProviderAdmin,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderTable: fn(
            self: *const IProviderAdmin,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProvider: fn(
            self: *const IProviderAdmin,
            lpszProvider: ?*i8,
            cValues: u32,
            lpProps: [*]SPropValue,
            ulUIParam: usize,
            ulFlags: u32,
            lpUID: ?*MAPIUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteProvider: fn(
            self: *const IProviderAdmin,
            lpUID: ?*MAPIUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenProfileSection: fn(
            self: *const IProviderAdmin,
            lpUID: ?*MAPIUID,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lppProfSect: ?*?*IProfSect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderAdmin_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderAdmin.VTable, self.vtable).GetLastError(@ptrCast(*const IProviderAdmin, self), hResult, ulFlags, lppMAPIError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderAdmin_GetProviderTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderAdmin.VTable, self.vtable).GetProviderTable(@ptrCast(*const IProviderAdmin, self), ulFlags, lppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderAdmin_CreateProvider(self: *const T, lpszProvider: ?*i8, cValues: u32, lpProps: [*]SPropValue, ulUIParam: usize, ulFlags: u32, lpUID: ?*MAPIUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderAdmin.VTable, self.vtable).CreateProvider(@ptrCast(*const IProviderAdmin, self), lpszProvider, cValues, lpProps, ulUIParam, ulFlags, lpUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderAdmin_DeleteProvider(self: *const T, lpUID: ?*MAPIUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderAdmin.VTable, self.vtable).DeleteProvider(@ptrCast(*const IProviderAdmin, self), lpUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProviderAdmin_OpenProfileSection(self: *const T, lpUID: ?*MAPIUID, lpInterface: ?*Guid, ulFlags: u32, lppProfSect: ?*?*IProfSect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProviderAdmin.VTable, self.vtable).OpenProfileSection(@ptrCast(*const IProviderAdmin, self), lpUID, lpInterface, ulFlags, lppProfSect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Gender = enum(i32) {
    Unspecified = 0,
    Female = 1,
    Male = 2,
};
pub const genderUnspecified = Gender.Unspecified;
pub const genderFemale = Gender.Female;
pub const genderMale = Gender.Male;

pub const CALLERRELEASE = fn(
    ulCallerData: u32,
    lpTblData: ?*ITableData,
    lpVue: ?*IMAPITable,
) callconv(@import("std").os.windows.WINAPI) void;

pub const ITableData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HrGetView: fn(
            self: *const ITableData,
            lpSSortOrderSet: ?*SSortOrderSet,
            lpfCallerRelease: ?*?CALLERRELEASE,
            ulCallerData: u32,
            lppMAPITable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrModifyRow: fn(
            self: *const ITableData,
            param0: ?*SRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrDeleteRow: fn(
            self: *const ITableData,
            lpSPropValue: ?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrQueryRow: fn(
            self: *const ITableData,
            lpsPropValue: ?*SPropValue,
            lppSRow: ?*?*SRow,
            lpuliRow: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrEnumRow: fn(
            self: *const ITableData,
            ulRowNumber: u32,
            lppSRow: ?*?*SRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrNotify: fn(
            self: *const ITableData,
            ulFlags: u32,
            cValues: u32,
            lpSPropValue: ?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrInsertRow: fn(
            self: *const ITableData,
            uliRow: u32,
            lpSRow: ?*SRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrModifyRows: fn(
            self: *const ITableData,
            ulFlags: u32,
            lpSRowSet: ?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrDeleteRows: fn(
            self: *const ITableData,
            ulFlags: u32,
            lprowsetToDelete: ?*SRowSet,
            cRowsDeleted: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableData_HrGetView(self: *const T, lpSSortOrderSet: ?*SSortOrderSet, lpfCallerRelease: ?*?CALLERRELEASE, ulCallerData: u32, lppMAPITable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableData.VTable, self.vtable).HrGetView(@ptrCast(*const ITableData, self), lpSSortOrderSet, lpfCallerRelease, ulCallerData, lppMAPITable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableData_HrModifyRow(self: *const T, param0: ?*SRow) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableData.VTable, self.vtable).HrModifyRow(@ptrCast(*const ITableData, self), param0);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableData_HrDeleteRow(self: *const T, lpSPropValue: ?*SPropValue) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableData.VTable, self.vtable).HrDeleteRow(@ptrCast(*const ITableData, self), lpSPropValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableData_HrQueryRow(self: *const T, lpsPropValue: ?*SPropValue, lppSRow: ?*?*SRow, lpuliRow: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableData.VTable, self.vtable).HrQueryRow(@ptrCast(*const ITableData, self), lpsPropValue, lppSRow, lpuliRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableData_HrEnumRow(self: *const T, ulRowNumber: u32, lppSRow: ?*?*SRow) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableData.VTable, self.vtable).HrEnumRow(@ptrCast(*const ITableData, self), ulRowNumber, lppSRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableData_HrNotify(self: *const T, ulFlags: u32, cValues: u32, lpSPropValue: ?*SPropValue) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableData.VTable, self.vtable).HrNotify(@ptrCast(*const ITableData, self), ulFlags, cValues, lpSPropValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableData_HrInsertRow(self: *const T, uliRow: u32, lpSRow: ?*SRow) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableData.VTable, self.vtable).HrInsertRow(@ptrCast(*const ITableData, self), uliRow, lpSRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableData_HrModifyRows(self: *const T, ulFlags: u32, lpSRowSet: ?*SRowSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableData.VTable, self.vtable).HrModifyRows(@ptrCast(*const ITableData, self), ulFlags, lpSRowSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableData_HrDeleteRows(self: *const T, ulFlags: u32, lprowsetToDelete: ?*SRowSet, cRowsDeleted: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableData.VTable, self.vtable).HrDeleteRows(@ptrCast(*const ITableData, self), ulFlags, lprowsetToDelete, cRowsDeleted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IPropData = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        HrSetObjAccess: fn(
            self: *const IPropData,
            ulAccess: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrSetPropAccess: fn(
            self: *const IPropData,
            lpPropTagArray: ?*SPropTagArray,
            rgulAccess: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrGetPropAccess: fn(
            self: *const IPropData,
            lppPropTagArray: ?*?*SPropTagArray,
            lprgulAccess: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrAddObjProps: fn(
            self: *const IPropData,
            lppPropTagArray: ?*SPropTagArray,
            lprgulAccess: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIProp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropData_HrSetObjAccess(self: *const T, ulAccess: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropData.VTable, self.vtable).HrSetObjAccess(@ptrCast(*const IPropData, self), ulAccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropData_HrSetPropAccess(self: *const T, lpPropTagArray: ?*SPropTagArray, rgulAccess: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropData.VTable, self.vtable).HrSetPropAccess(@ptrCast(*const IPropData, self), lpPropTagArray, rgulAccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropData_HrGetPropAccess(self: *const T, lppPropTagArray: ?*?*SPropTagArray, lprgulAccess: ?*?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropData.VTable, self.vtable).HrGetPropAccess(@ptrCast(*const IPropData, self), lppPropTagArray, lprgulAccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropData_HrAddObjProps(self: *const T, lppPropTagArray: ?*SPropTagArray, lprgulAccess: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropData.VTable, self.vtable).HrAddObjProps(@ptrCast(*const IPropData, self), lppPropTagArray, lprgulAccess);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FNIDLE = fn(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFNIDLE = fn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPOPENSTREAMONFILE = fn(
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
    ulFlags: u32,
    lpszFileName: ?*i8,
    lpszPrefix: ?*i8,
    lppStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DTCTL = extern struct {
    ulCtlType: u32,
    ulCtlFlags: u32,
    lpbNotif: ?*u8,
    cbNotif: u32,
    lpszFilter: ?*i8,
    ulItemID: u32,
    ctl: extern union {
        lpv: ?*anyopaque,
        lplabel: ?*DTBLLABEL,
        lpedit: ?*DTBLEDIT,
        lplbx: ?*DTBLLBX,
        lpcombobox: ?*DTBLCOMBOBOX,
        lpddlbx: ?*DTBLDDLBX,
        lpcheckbox: ?*DTBLCHECKBOX,
        lpgroupbox: ?*DTBLGROUPBOX,
        lpbutton: ?*DTBLBUTTON,
        lpradiobutton: ?*DTBLRADIOBUTTON,
        lpmvlbx: ?*DTBLMVLISTBOX,
        lpmvddlbx: ?*DTBLMVDDLBX,
        lppage: ?*DTBLPAGE,
    },
};

pub const DTPAGE = extern struct {
    cctl: u32,
    lpszResourceName: ?*i8,
    Anonymous: extern union {
        lpszComponent: ?*i8,
        ulItemID: u32,
    },
    lpctl: ?*DTCTL,
};

pub const LPDISPATCHNOTIFICATIONS = fn(
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPCREATECONVERSATIONINDEX = fn(
    cbParent: u32,
    lpbParent: ?*u8,
    lpcbConvIndex: ?*u32,
    lppbConvIndex: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub const IAddrBook = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        OpenEntry: fn(
            self: *const IAddrBook,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lpulObjType: ?*u32,
            lppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEntryIDs: fn(
            self: *const IAddrBook,
            cbEntryID1: u32,
            lpEntryID1: ?*ENTRYID,
            cbEntryID2: u32,
            lpEntryID2: ?*ENTRYID,
            ulFlags: u32,
            lpulResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IAddrBook,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
            ulEventMask: u32,
            lpAdviseSink: ?*IMAPIAdviseSink,
            lpulConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IAddrBook,
            ulConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateOneOff: fn(
            self: *const IAddrBook,
            lpszName: ?*i8,
            lpszAdrType: ?*i8,
            lpszAddress: ?*i8,
            ulFlags: u32,
            lpcbEntryID: ?*u32,
            lppEntryID: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewEntry: fn(
            self: *const IAddrBook,
            ulUIParam: u32,
            ulFlags: u32,
            cbEIDContainer: u32,
            lpEIDContainer: ?*ENTRYID,
            cbEIDNewEntryTpl: u32,
            lpEIDNewEntryTpl: ?*ENTRYID,
            lpcbEIDNewEntry: ?*u32,
            lppEIDNewEntry: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveName: fn(
            self: *const IAddrBook,
            ulUIParam: usize,
            ulFlags: u32,
            lpszNewEntryTitle: ?*i8,
            lpAdrList: ?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Address: fn(
            self: *const IAddrBook,
            lpulUIParam: ?*u32,
            lpAdrParms: ?*ADRPARM,
            lppAdrList: ?*?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Details: fn(
            self: *const IAddrBook,
            lpulUIParam: ?*usize,
            lpfnDismiss: ?LPFNDISMISS,
            lpvDismissContext: ?*anyopaque,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
            lpfButtonCallback: ?LPFNBUTTON,
            lpvButtonContext: ?*anyopaque,
            lpszButtonText: ?*i8,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecipOptions: fn(
            self: *const IAddrBook,
            ulUIParam: u32,
            ulFlags: u32,
            lpRecip: ?*ADRENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDefaultRecipOpt: fn(
            self: *const IAddrBook,
            lpszAdrType: ?*i8,
            ulFlags: u32,
            lpcValues: ?*u32,
            lppOptions: ?*?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPAB: fn(
            self: *const IAddrBook,
            lpcbEntryID: ?*u32,
            lppEntryID: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPAB: fn(
            self: *const IAddrBook,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultDir: fn(
            self: *const IAddrBook,
            lpcbEntryID: ?*u32,
            lppEntryID: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultDir: fn(
            self: *const IAddrBook,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSearchPath: fn(
            self: *const IAddrBook,
            ulFlags: u32,
            lppSearchPath: ?*?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSearchPath: fn(
            self: *const IAddrBook,
            ulFlags: u32,
            lpSearchPath: ?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrepareRecips: fn(
            self: *const IAddrBook,
            ulFlags: u32,
            lpPropTagArray: ?*SPropTagArray,
            lpRecipList: ?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMAPIProp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_OpenEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, ulFlags: u32, lpulObjType: ?*u32, lppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).OpenEntry(@ptrCast(*const IAddrBook, self), cbEntryID, lpEntryID, lpInterface, ulFlags, lpulObjType, lppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_CompareEntryIDs(self: *const T, cbEntryID1: u32, lpEntryID1: ?*ENTRYID, cbEntryID2: u32, lpEntryID2: ?*ENTRYID, ulFlags: u32, lpulResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).CompareEntryIDs(@ptrCast(*const IAddrBook, self), cbEntryID1, lpEntryID1, cbEntryID2, lpEntryID2, ulFlags, lpulResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_Advise(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulEventMask: u32, lpAdviseSink: ?*IMAPIAdviseSink, lpulConnection: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).Advise(@ptrCast(*const IAddrBook, self), cbEntryID, lpEntryID, ulEventMask, lpAdviseSink, lpulConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_Unadvise(self: *const T, ulConnection: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).Unadvise(@ptrCast(*const IAddrBook, self), ulConnection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_CreateOneOff(self: *const T, lpszName: ?*i8, lpszAdrType: ?*i8, lpszAddress: ?*i8, ulFlags: u32, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).CreateOneOff(@ptrCast(*const IAddrBook, self), lpszName, lpszAdrType, lpszAddress, ulFlags, lpcbEntryID, lppEntryID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_NewEntry(self: *const T, ulUIParam: u32, ulFlags: u32, cbEIDContainer: u32, lpEIDContainer: ?*ENTRYID, cbEIDNewEntryTpl: u32, lpEIDNewEntryTpl: ?*ENTRYID, lpcbEIDNewEntry: ?*u32, lppEIDNewEntry: ?*?*ENTRYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).NewEntry(@ptrCast(*const IAddrBook, self), ulUIParam, ulFlags, cbEIDContainer, lpEIDContainer, cbEIDNewEntryTpl, lpEIDNewEntryTpl, lpcbEIDNewEntry, lppEIDNewEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_ResolveName(self: *const T, ulUIParam: usize, ulFlags: u32, lpszNewEntryTitle: ?*i8, lpAdrList: ?*ADRLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).ResolveName(@ptrCast(*const IAddrBook, self), ulUIParam, ulFlags, lpszNewEntryTitle, lpAdrList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_Address(self: *const T, lpulUIParam: ?*u32, lpAdrParms: ?*ADRPARM, lppAdrList: ?*?*ADRLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).Address(@ptrCast(*const IAddrBook, self), lpulUIParam, lpAdrParms, lppAdrList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_Details(self: *const T, lpulUIParam: ?*usize, lpfnDismiss: ?LPFNDISMISS, lpvDismissContext: ?*anyopaque, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpfButtonCallback: ?LPFNBUTTON, lpvButtonContext: ?*anyopaque, lpszButtonText: ?*i8, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).Details(@ptrCast(*const IAddrBook, self), lpulUIParam, lpfnDismiss, lpvDismissContext, cbEntryID, lpEntryID, lpfButtonCallback, lpvButtonContext, lpszButtonText, ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_RecipOptions(self: *const T, ulUIParam: u32, ulFlags: u32, lpRecip: ?*ADRENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).RecipOptions(@ptrCast(*const IAddrBook, self), ulUIParam, ulFlags, lpRecip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_QueryDefaultRecipOpt(self: *const T, lpszAdrType: ?*i8, ulFlags: u32, lpcValues: ?*u32, lppOptions: ?*?*SPropValue) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).QueryDefaultRecipOpt(@ptrCast(*const IAddrBook, self), lpszAdrType, ulFlags, lpcValues, lppOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_GetPAB(self: *const T, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).GetPAB(@ptrCast(*const IAddrBook, self), lpcbEntryID, lppEntryID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_SetPAB(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).SetPAB(@ptrCast(*const IAddrBook, self), cbEntryID, lpEntryID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_GetDefaultDir(self: *const T, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).GetDefaultDir(@ptrCast(*const IAddrBook, self), lpcbEntryID, lppEntryID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_SetDefaultDir(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).SetDefaultDir(@ptrCast(*const IAddrBook, self), cbEntryID, lpEntryID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_GetSearchPath(self: *const T, ulFlags: u32, lppSearchPath: ?*?*SRowSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).GetSearchPath(@ptrCast(*const IAddrBook, self), ulFlags, lppSearchPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_SetSearchPath(self: *const T, ulFlags: u32, lpSearchPath: ?*SRowSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).SetSearchPath(@ptrCast(*const IAddrBook, self), ulFlags, lpSearchPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAddrBook_PrepareRecips(self: *const T, ulFlags: u32, lpPropTagArray: ?*SPropTagArray, lpRecipList: ?*ADRLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAddrBook.VTable, self.vtable).PrepareRecips(@ptrCast(*const IAddrBook, self), ulFlags, lpPropTagArray, lpRecipList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _WABACTIONITEM = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

// TODO: this type is limited to platform 'windows5.0'
pub const IWABObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: fn(
            self: *const IWABObject,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateBuffer: fn(
            self: *const IWABObject,
            cbSize: u32,
            lppBuffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateMore: fn(
            self: *const IWABObject,
            cbSize: u32,
            lpObject: ?*anyopaque,
            lppBuffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: fn(
            self: *const IWABObject,
            lpBuffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Backup: fn(
            self: *const IWABObject,
            lpFileName: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: fn(
            self: *const IWABObject,
            lpWIP: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardDisplay: fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
            lpszFileName: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LDAPUrl: fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
            ulFlags: u32,
            lpszURL: ?PSTR,
            lppMailUser: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardCreate: fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpszVCard: ?PSTR,
            lpMailUser: ?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardRetrieve: fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpszVCard: ?PSTR,
            lppMailUser: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMe: fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpdwAction: ?*u32,
            lpsbEID: ?*SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMe: fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            sbEID: SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).GetLastError(@ptrCast(*const IWABObject, self), hResult, ulFlags, lppMAPIError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_AllocateBuffer(self: *const T, cbSize: u32, lppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).AllocateBuffer(@ptrCast(*const IWABObject, self), cbSize, lppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_AllocateMore(self: *const T, cbSize: u32, lpObject: ?*anyopaque, lppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).AllocateMore(@ptrCast(*const IWABObject, self), cbSize, lpObject, lppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_FreeBuffer(self: *const T, lpBuffer: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).FreeBuffer(@ptrCast(*const IWABObject, self), lpBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_Backup(self: *const T, lpFileName: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).Backup(@ptrCast(*const IWABObject, self), lpFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_Import(self: *const T, lpWIP: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).Import(@ptrCast(*const IWABObject, self), lpWIP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_Find(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).Find(@ptrCast(*const IWABObject, self), lpIAB, hWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_VCardDisplay(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND, lpszFileName: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).VCardDisplay(@ptrCast(*const IWABObject, self), lpIAB, hWnd, lpszFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_LDAPUrl(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND, ulFlags: u32, lpszURL: ?PSTR, lppMailUser: ?*?*IMailUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).LDAPUrl(@ptrCast(*const IWABObject, self), lpIAB, hWnd, ulFlags, lpszURL, lppMailUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_VCardCreate(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lpMailUser: ?*IMailUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).VCardCreate(@ptrCast(*const IWABObject, self), lpIAB, ulFlags, lpszVCard, lpMailUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_VCardRetrieve(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lppMailUser: ?*?*IMailUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).VCardRetrieve(@ptrCast(*const IWABObject, self), lpIAB, ulFlags, lpszVCard, lppMailUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_GetMe(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpdwAction: ?*u32, lpsbEID: ?*SBinary, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).GetMe(@ptrCast(*const IWABObject, self), lpIAB, ulFlags, lpdwAction, lpsbEID, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABObject_SetMe(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, sbEID: SBinary, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABObject.VTable, self.vtable).SetMe(@ptrCast(*const IWABObject, self), lpIAB, ulFlags, sbEID, hwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IWABOBJECT_QueryInterface_METHOD = fn(
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_AddRef_METHOD = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const IWABOBJECT_Release_METHOD = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const IWABOBJECT_GetLastError_METHOD = fn(
    hResult: HRESULT,
    ulFlags: u32,
    lppMAPIError: ?*?*MAPIERROR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_AllocateBuffer_METHOD = fn(
    cbSize: u32,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_AllocateMore_METHOD = fn(
    cbSize: u32,
    lpObject: ?*anyopaque,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_FreeBuffer_METHOD = fn(
    lpBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_Backup_METHOD = fn(
    lpFileName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_Import_METHOD = fn(
    lpWIP: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_Find_METHOD = fn(
    lpIAB: ?*IAddrBook,
    hWnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_VCardDisplay_METHOD = fn(
    lpIAB: ?*IAddrBook,
    hWnd: ?HWND,
    lpszFileName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_LDAPUrl_METHOD = fn(
    lpIAB: ?*IAddrBook,
    hWnd: ?HWND,
    ulFlags: u32,
    lpszURL: ?PSTR,
    lppMailUser: ?*?*IMailUser,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_VCardCreate_METHOD = fn(
    lpIAB: ?*IAddrBook,
    ulFlags: u32,
    lpszVCard: ?PSTR,
    lpMailUser: ?*IMailUser,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_VCardRetrieve_METHOD = fn(
    lpIAB: ?*IAddrBook,
    ulFlags: u32,
    lpszVCard: ?PSTR,
    lppMailUser: ?*?*IMailUser,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_GetMe_METHOD = fn(
    lpIAB: ?*IAddrBook,
    ulFlags: u32,
    lpdwAction: ?*u32,
    lpsbEID: ?*SBinary,
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_SetMe_METHOD = fn(
    lpIAB: ?*IAddrBook,
    ulFlags: u32,
    sbEID: SBinary,
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_ = extern struct {
    pub const VTable = extern struct {
        QueryInterface: fn(
            self: *const IWABOBJECT_,
            riid: ?*const Guid,
            ppvObj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRef: fn(
            self: *const IWABOBJECT_,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Release: fn(
            self: *const IWABOBJECT_,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetLastError: fn(
            self: *const IWABOBJECT_,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateBuffer: fn(
            self: *const IWABOBJECT_,
            cbSize: u32,
            lppBuffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateMore: fn(
            self: *const IWABOBJECT_,
            cbSize: u32,
            lpObject: ?*anyopaque,
            lppBuffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: fn(
            self: *const IWABOBJECT_,
            lpBuffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Backup: fn(
            self: *const IWABOBJECT_,
            lpFileName: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: fn(
            self: *const IWABOBJECT_,
            lpWIP: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardDisplay: fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
            lpszFileName: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LDAPUrl: fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
            ulFlags: u32,
            lpszURL: ?PSTR,
            lppMailUser: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardCreate: fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpszVCard: ?PSTR,
            lpMailUser: ?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardRetrieve: fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpszVCard: ?PSTR,
            lppMailUser: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMe: fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpdwAction: ?*u32,
            lpsbEID: ?*SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMe: fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            sbEID: SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__QueryInterface(self: *const T, riid: ?*const Guid, ppvObj: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).QueryInterface(@ptrCast(*const IWABOBJECT_, self), riid, ppvObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__AddRef(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).AddRef(@ptrCast(*const IWABOBJECT_, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__Release(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).Release(@ptrCast(*const IWABOBJECT_, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).GetLastError(@ptrCast(*const IWABOBJECT_, self), hResult, ulFlags, lppMAPIError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__AllocateBuffer(self: *const T, cbSize: u32, lppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).AllocateBuffer(@ptrCast(*const IWABOBJECT_, self), cbSize, lppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__AllocateMore(self: *const T, cbSize: u32, lpObject: ?*anyopaque, lppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).AllocateMore(@ptrCast(*const IWABOBJECT_, self), cbSize, lpObject, lppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__FreeBuffer(self: *const T, lpBuffer: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).FreeBuffer(@ptrCast(*const IWABOBJECT_, self), lpBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__Backup(self: *const T, lpFileName: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).Backup(@ptrCast(*const IWABOBJECT_, self), lpFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__Import(self: *const T, lpWIP: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).Import(@ptrCast(*const IWABOBJECT_, self), lpWIP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__Find(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).Find(@ptrCast(*const IWABOBJECT_, self), lpIAB, hWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__VCardDisplay(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND, lpszFileName: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).VCardDisplay(@ptrCast(*const IWABOBJECT_, self), lpIAB, hWnd, lpszFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__LDAPUrl(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND, ulFlags: u32, lpszURL: ?PSTR, lppMailUser: ?*?*IMailUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).LDAPUrl(@ptrCast(*const IWABOBJECT_, self), lpIAB, hWnd, ulFlags, lpszURL, lppMailUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__VCardCreate(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lpMailUser: ?*IMailUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).VCardCreate(@ptrCast(*const IWABOBJECT_, self), lpIAB, ulFlags, lpszVCard, lpMailUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__VCardRetrieve(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lppMailUser: ?*?*IMailUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).VCardRetrieve(@ptrCast(*const IWABOBJECT_, self), lpIAB, ulFlags, lpszVCard, lppMailUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__GetMe(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpdwAction: ?*u32, lpsbEID: ?*SBinary, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).GetMe(@ptrCast(*const IWABOBJECT_, self), lpIAB, ulFlags, lpdwAction, lpsbEID, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABOBJECT__SetMe(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, sbEID: SBinary, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABOBJECT_.VTable, self.vtable).SetMe(@ptrCast(*const IWABOBJECT_, self), lpIAB, ulFlags, sbEID, hwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WAB_PARAM = extern struct {
    cbSize: u32,
    hwnd: ?HWND,
    szFileName: ?PSTR,
    ulFlags: u32,
    guidPSExt: Guid,
};

pub const LPWABOPEN = fn(
    lppAdrBook: ?*?*IAddrBook,
    lppWABObject: ?*?*IWABObject,
    lpWP: ?*WAB_PARAM,
    Reserved2: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPWABOPENEX = fn(
    lppAdrBook: ?*?*IAddrBook,
    lppWABObject: ?*?*IWABObject,
    lpWP: ?*WAB_PARAM,
    Reserved: u32,
    fnAllocateBuffer: ?LPALLOCATEBUFFER,
    fnAllocateMore: ?LPALLOCATEMORE,
    fnFreeBuffer: ?LPFREEBUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const WABIMPORTPARAM = extern struct {
    cbSize: u32,
    lpAdrBook: ?*IAddrBook,
    hWnd: ?HWND,
    ulFlags: u32,
    lpszFileName: ?PSTR,
};

pub const WABEXTDISPLAY = extern struct {
    cbSize: u32,
    lpWABObject: ?*IWABObject,
    lpAdrBook: ?*IAddrBook,
    lpPropObj: ?*IMAPIProp,
    fReadOnly: BOOL,
    fDataChanged: BOOL,
    ulFlags: u32,
    lpv: ?*anyopaque,
    lpsz: ?*i8,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWABExtInit_Value = @import("../zig.zig").Guid.initString("ea22ebf0-87a4-11d1-9acf-00a0c91f9c8b");
pub const IID_IWABExtInit = &IID_IWABExtInit_Value;
pub const IWABExtInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IWABExtInit,
            lpWABExtDisplay: ?*WABEXTDISPLAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWABExtInit_Initialize(self: *const T, lpWABExtDisplay: ?*WABEXTDISPLAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWABExtInit.VTable, self.vtable).Initialize(@ptrCast(*const IWABExtInit, self), lpWABExtDisplay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const LPWABALLOCATEBUFFER = fn(
    lpWABObject: ?*IWABObject,
    cbSize: u32,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWABALLOCATEMORE = fn(
    lpWABObject: ?*IWABObject,
    cbSize: u32,
    lpObject: ?*anyopaque,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWABFREEBUFFER = fn(
    lpWABObject: ?*IWABObject,
    lpBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const NOTIFKEY = extern struct {
    cb: u32,
    ab: [1]u8,
};


//--------------------------------------------------------------------------------
// Section: Functions (57)
//--------------------------------------------------------------------------------
pub extern "rtm" fn CreateTable(
    lpInterface: ?*Guid,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpvReserved: ?*anyopaque,
    ulTableType: u32,
    ulPropTagIndexColumn: u32,
    lpSPropTagArrayColumns: ?*SPropTagArray,
    lppTableData: ?*?*ITableData,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn CreateIProp(
    lpInterface: ?*Guid,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpvReserved: ?*anyopaque,
    lppPropData: ?*?*IPropData,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn MAPIInitIdle(
    lpvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn MAPIDeinitIdle(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MAPI32" fn FtgRegisterIdleRoutine(
    lpfnIdle: ?PFNIDLE,
    lpvIdleParam: ?*anyopaque,
    priIdle: i16,
    csecIdle: u32,
    iroIdle: u16,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "MAPI32" fn DeregisterIdleRoutine(
    ftg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MAPI32" fn EnableIdleRoutine(
    ftg: ?*anyopaque,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MAPI32" fn ChangeIdleRoutine(
    ftg: ?*anyopaque,
    lpfnIdle: ?PFNIDLE,
    lpvIdleParam: ?*anyopaque,
    priIdle: i16,
    csecIdle: u32,
    iroIdle: u16,
    ircIdle: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MAPI32" fn MAPIGetDefaultMalloc(
) callconv(@import("std").os.windows.WINAPI) ?*IMalloc;

pub extern "MAPI32" fn OpenStreamOnFile(
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
    ulFlags: u32,
    lpszFileName: ?*i8,
    lpszPrefix: ?*i8,
    lppStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn PropCopyMore(
    lpSPropValueDest: ?*SPropValue,
    lpSPropValueSrc: ?*SPropValue,
    lpfAllocMore: ?LPALLOCATEMORE,
    lpvObject: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn UlPropSize(
    lpSPropValue: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MAPI32" fn FEqualNames(
    lpName1: ?*MAPINAMEID,
    lpName2: ?*MAPINAMEID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MAPI32" fn FPropContainsProp(
    lpSPropValueDst: ?*SPropValue,
    lpSPropValueSrc: ?*SPropValue,
    ulFuzzyLevel: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MAPI32" fn FPropCompareProp(
    lpSPropValue1: ?*SPropValue,
    ulRelOp: u32,
    lpSPropValue2: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MAPI32" fn LPropCompareProp(
    lpSPropValueA: ?*SPropValue,
    lpSPropValueB: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn HrAddColumns(
    lptbl: ?*IMAPITable,
    lpproptagColumnsNew: ?*SPropTagArray,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn HrAddColumnsEx(
    lptbl: ?*IMAPITable,
    lpproptagColumnsNew: ?*SPropTagArray,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpfnFilterColumns: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn HrAllocAdviseSink(
    lpfnCallback: ?LPNOTIFCALLBACK,
    lpvContext: ?*anyopaque,
    lppAdviseSink: ?*?*IMAPIAdviseSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn HrThisThreadAdviseSink(
    lpAdviseSink: ?*IMAPIAdviseSink,
    lppAdviseSink: ?*?*IMAPIAdviseSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn HrDispatchNotifications(
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn BuildDisplayTable(
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpMalloc: ?*IMalloc,
    hInstance: ?HINSTANCE,
    cPages: u32,
    lpPage: ?*DTPAGE,
    ulFlags: u32,
    lppTable: ?*?*IMAPITable,
    lppTblData: ?*?*ITableData,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn ScCountNotifications(
    cNotifications: i32,
    lpNotifications: ?*NOTIFICATION,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn ScCopyNotifications(
    cNotification: i32,
    lpNotifications: ?*NOTIFICATION,
    lpvDst: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn ScRelocNotifications(
    cNotification: i32,
    lpNotifications: ?*NOTIFICATION,
    lpvBaseOld: ?*anyopaque,
    lpvBaseNew: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn ScCountProps(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn LpValFindProp(
    ulPropTag: u32,
    cValues: u32,
    lpPropArray: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) ?*SPropValue;

pub extern "MAPI32" fn ScCopyProps(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpvDst: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn ScRelocProps(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpvBaseOld: ?*anyopaque,
    lpvBaseNew: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn ScDupPropset(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lppPropArray: ?*?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn UlAddRef(
    lpunk: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MAPI32" fn UlRelease(
    lpunk: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MAPI32" fn HrGetOneProp(
    lpMapiProp: ?*IMAPIProp,
    ulPropTag: u32,
    lppProp: ?*?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn HrSetOneProp(
    lpMapiProp: ?*IMAPIProp,
    lpProp: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn FPropExists(
    lpMapiProp: ?*IMAPIProp,
    ulPropTag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MAPI32" fn PpropFindProp(
    lpPropArray: ?*SPropValue,
    cValues: u32,
    ulPropTag: u32,
) callconv(@import("std").os.windows.WINAPI) ?*SPropValue;

pub extern "MAPI32" fn FreePadrlist(
    lpAdrlist: ?*ADRLIST,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MAPI32" fn FreeProws(
    lpRows: ?*SRowSet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MAPI32" fn HrQueryAllRows(
    lpTable: ?*IMAPITable,
    lpPropTags: ?*SPropTagArray,
    lpRestriction: ?*SRestriction,
    lpSortOrderSet: ?*SSortOrderSet,
    crowsMax: i32,
    lppRows: ?*?*SRowSet,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn SzFindCh(
    lpsz: ?*i8,
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "MAPI32" fn SzFindLastCh(
    lpsz: ?*i8,
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "MAPI32" fn SzFindSz(
    lpsz: ?*i8,
    lpszKey: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "MAPI32" fn UFromSz(
    lpsz: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MAPI32" fn ScUNCFromLocalPath(
    lpszLocal: ?PSTR,
    lpszUNC: [*:0]u8,
    cchUNC: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn ScLocalPathFromUNC(
    lpszUNC: ?PSTR,
    lpszLocal: [*:0]u8,
    cchLocal: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn FtAddFt(
    ftAddend1: FILETIME,
    ftAddend2: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "MAPI32" fn FtMulDwDw(
    ftMultiplicand: u32,
    ftMultiplier: u32,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "MAPI32" fn FtMulDw(
    ftMultiplier: u32,
    ftMultiplicand: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "MAPI32" fn FtSubFt(
    ftMinuend: FILETIME,
    ftSubtrahend: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "MAPI32" fn FtNegFt(
    ft: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "MAPI32" fn ScCreateConversationIndex(
    cbParent: u32,
    lpbParent: ?*u8,
    lpcbConvIndex: ?*u32,
    lppbConvIndex: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn WrapStoreEntryID(
    ulFlags: u32,
    lpszDLLName: ?*i8,
    cbOrigEntry: u32,
    // TODO: what to do with BytesParamIndex 2?
    lpOrigEntry: ?*ENTRYID,
    lpcbWrappedEntry: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    lppWrappedEntry: ?*?*ENTRYID,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn RTFSync(
    lpMessage: ?*IMessage,
    ulFlags: u32,
    lpfMessageUpdated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn WrapCompressedRTFStream(
    lpCompressedRTFStream: ?*IStream,
    ulFlags: u32,
    lpUncompressedRTFStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn HrIStorageFromStream(
    lpUnkIn: ?*IUnknown,
    lpInterface: ?*Guid,
    ulFlags: u32,
    lppStorageOut: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MAPI32" fn ScInitMapiUtil(
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MAPI32" fn DeinitMapiUtil(
) callconv(@import("std").os.windows.WINAPI) void;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (14)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const CY = @import("../system/com.zig").CY;
const FILETIME = @import("../foundation.zig").FILETIME;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IMalloc = @import("../system/com.zig").IMalloc;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPALLOCATEBUFFER")) { _ = LPALLOCATEBUFFER; }
    if (@hasDecl(@This(), "LPALLOCATEMORE")) { _ = LPALLOCATEMORE; }
    if (@hasDecl(@This(), "LPFREEBUFFER")) { _ = LPFREEBUFFER; }
    if (@hasDecl(@This(), "LPNOTIFCALLBACK")) { _ = LPNOTIFCALLBACK; }
    if (@hasDecl(@This(), "LPFNABSDI")) { _ = LPFNABSDI; }
    if (@hasDecl(@This(), "LPFNDISMISS")) { _ = LPFNDISMISS; }
    if (@hasDecl(@This(), "LPFNBUTTON")) { _ = LPFNBUTTON; }
    if (@hasDecl(@This(), "CALLERRELEASE")) { _ = CALLERRELEASE; }
    if (@hasDecl(@This(), "FNIDLE")) { _ = FNIDLE; }
    if (@hasDecl(@This(), "PFNIDLE")) { _ = PFNIDLE; }
    if (@hasDecl(@This(), "LPOPENSTREAMONFILE")) { _ = LPOPENSTREAMONFILE; }
    if (@hasDecl(@This(), "LPDISPATCHNOTIFICATIONS")) { _ = LPDISPATCHNOTIFICATIONS; }
    if (@hasDecl(@This(), "LPCREATECONVERSATIONINDEX")) { _ = LPCREATECONVERSATIONINDEX; }
    if (@hasDecl(@This(), "IWABOBJECT_QueryInterface_METHOD")) { _ = IWABOBJECT_QueryInterface_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_AddRef_METHOD")) { _ = IWABOBJECT_AddRef_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_Release_METHOD")) { _ = IWABOBJECT_Release_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_GetLastError_METHOD")) { _ = IWABOBJECT_GetLastError_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_AllocateBuffer_METHOD")) { _ = IWABOBJECT_AllocateBuffer_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_AllocateMore_METHOD")) { _ = IWABOBJECT_AllocateMore_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_FreeBuffer_METHOD")) { _ = IWABOBJECT_FreeBuffer_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_Backup_METHOD")) { _ = IWABOBJECT_Backup_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_Import_METHOD")) { _ = IWABOBJECT_Import_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_Find_METHOD")) { _ = IWABOBJECT_Find_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_VCardDisplay_METHOD")) { _ = IWABOBJECT_VCardDisplay_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_LDAPUrl_METHOD")) { _ = IWABOBJECT_LDAPUrl_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_VCardCreate_METHOD")) { _ = IWABOBJECT_VCardCreate_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_VCardRetrieve_METHOD")) { _ = IWABOBJECT_VCardRetrieve_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_GetMe_METHOD")) { _ = IWABOBJECT_GetMe_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_SetMe_METHOD")) { _ = IWABOBJECT_SetMe_METHOD; }
    if (@hasDecl(@This(), "LPWABOPEN")) { _ = LPWABOPEN; }
    if (@hasDecl(@This(), "LPWABOPENEX")) { _ = LPWABOPENEX; }
    if (@hasDecl(@This(), "LPWABALLOCATEBUFFER")) { _ = LPWABALLOCATEBUFFER; }
    if (@hasDecl(@This(), "LPWABALLOCATEMORE")) { _ = LPWABALLOCATEMORE; }
    if (@hasDecl(@This(), "LPWABFREEBUFFER")) { _ = LPWABFREEBUFFER; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
