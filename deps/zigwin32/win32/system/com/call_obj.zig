//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (14)
//--------------------------------------------------------------------------------
pub const CALLFRAMEINFO = extern struct {
    iMethod: u32,
    fHasInValues: BOOL,
    fHasInOutValues: BOOL,
    fHasOutValues: BOOL,
    fDerivesFromIDispatch: BOOL,
    cInInterfacesMax: i32,
    cInOutInterfacesMax: i32,
    cOutInterfacesMax: i32,
    cTopLevelInInterfaces: i32,
    iid: Guid,
    cMethod: u32,
    cParams: u32,
};

pub const CALLFRAMEPARAMINFO = extern struct {
    fIn: BOOLEAN,
    fOut: BOOLEAN,
    stackOffset: u32,
    cbParam: u32,
};

pub const CALLFRAME_COPY = enum(i32) {
    NESTED = 1,
    INDEPENDENT = 2,
};
pub const CALLFRAME_COPY_NESTED = CALLFRAME_COPY.NESTED;
pub const CALLFRAME_COPY_INDEPENDENT = CALLFRAME_COPY.INDEPENDENT;

pub const CALLFRAME_FREE = enum(i32) {
    NONE = 0,
    IN = 1,
    INOUT = 2,
    OUT = 4,
    TOP_INOUT = 8,
    TOP_OUT = 16,
    ALL = 31,
};
pub const CALLFRAME_FREE_NONE = CALLFRAME_FREE.NONE;
pub const CALLFRAME_FREE_IN = CALLFRAME_FREE.IN;
pub const CALLFRAME_FREE_INOUT = CALLFRAME_FREE.INOUT;
pub const CALLFRAME_FREE_OUT = CALLFRAME_FREE.OUT;
pub const CALLFRAME_FREE_TOP_INOUT = CALLFRAME_FREE.TOP_INOUT;
pub const CALLFRAME_FREE_TOP_OUT = CALLFRAME_FREE.TOP_OUT;
pub const CALLFRAME_FREE_ALL = CALLFRAME_FREE.ALL;

pub const CALLFRAME_NULL = enum(i32) {
    NONE = 0,
    INOUT = 2,
    OUT = 4,
    ALL = 6,
};
pub const CALLFRAME_NULL_NONE = CALLFRAME_NULL.NONE;
pub const CALLFRAME_NULL_INOUT = CALLFRAME_NULL.INOUT;
pub const CALLFRAME_NULL_OUT = CALLFRAME_NULL.OUT;
pub const CALLFRAME_NULL_ALL = CALLFRAME_NULL.ALL;

pub const CALLFRAME_WALK = enum(i32) {
    IN = 1,
    INOUT = 2,
    OUT = 4,
};
pub const CALLFRAME_WALK_IN = CALLFRAME_WALK.IN;
pub const CALLFRAME_WALK_INOUT = CALLFRAME_WALK.INOUT;
pub const CALLFRAME_WALK_OUT = CALLFRAME_WALK.OUT;

pub const CALLFRAME_MARSHALCONTEXT = extern struct {
    fIn: BOOLEAN,
    dwDestContext: u32,
    pvDestContext: ?*anyopaque,
    punkReserved: ?*IUnknown,
    guidTransferSyntax: Guid,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFrame_Value = @import("../../zig.zig").Guid.initString("d573b4b0-894e-11d2-b8b6-00c04fb9618a");
pub const IID_ICallFrame = &IID_ICallFrame_Value;
pub const ICallFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: fn(
            self: *const ICallFrame,
            pInfo: ?*CALLFRAMEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIIDAndMethod: fn(
            self: *const ICallFrame,
            pIID: ?*Guid,
            piMethod: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNames: fn(
            self: *const ICallFrame,
            pwszInterface: ?*?PWSTR,
            pwszMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackLocation: fn(
            self: *const ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        SetStackLocation: fn(
            self: *const ICallFrame,
            pvStack: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetReturnValue: fn(
            self: *const ICallFrame,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetReturnValue: fn(
            self: *const ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParamInfo: fn(
            self: *const ICallFrame,
            iparam: u32,
            pInfo: ?*CALLFRAMEPARAMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParam: fn(
            self: *const ICallFrame,
            iparam: u32,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParam: fn(
            self: *const ICallFrame,
            iparam: u32,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const ICallFrame,
            copyControl: CALLFRAME_COPY,
            pWalker: ?*ICallFrameWalker,
            ppFrame: ?*?*ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Free: fn(
            self: *const ICallFrame,
            pframeArgsDest: ?*ICallFrame,
            pWalkerDestFree: ?*ICallFrameWalker,
            pWalkerCopy: ?*ICallFrameWalker,
            freeFlags: u32,
            pWalkerFree: ?*ICallFrameWalker,
            nullFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeParam: fn(
            self: *const ICallFrame,
            iparam: u32,
            freeFlags: u32,
            pWalkerFree: ?*ICallFrameWalker,
            nullFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WalkFrame: fn(
            self: *const ICallFrame,
            walkWhat: u32,
            pWalker: ?*ICallFrameWalker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarshalSizeMax: fn(
            self: *const ICallFrame,
            pmshlContext: ?*CALLFRAME_MARSHALCONTEXT,
            mshlflags: MSHLFLAGS,
            pcbBufferNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Marshal: fn(
            self: *const ICallFrame,
            pmshlContext: ?*CALLFRAME_MARSHALCONTEXT,
            mshlflags: MSHLFLAGS,
            pBuffer: [*]u8,
            cbBuffer: u32,
            pcbBufferUsed: ?*u32,
            pdataRep: ?*u32,
            prpcFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unmarshal: fn(
            self: *const ICallFrame,
            pBuffer: [*]u8,
            cbBuffer: u32,
            dataRep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
            pcbUnmarshalled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMarshalData: fn(
            self: *const ICallFrame,
            pBuffer: [*]u8,
            cbBuffer: u32,
            ibFirstRelease: u32,
            dataRep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const ICallFrame,
            pvReceiver: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetInfo(self: *const T, pInfo: ?*CALLFRAMEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetInfo(@ptrCast(*const ICallFrame, self), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetIIDAndMethod(self: *const T, pIID: ?*Guid, piMethod: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetIIDAndMethod(@ptrCast(*const ICallFrame, self), pIID, piMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetNames(self: *const T, pwszInterface: ?*?PWSTR, pwszMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetNames(@ptrCast(*const ICallFrame, self), pwszInterface, pwszMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetStackLocation(self: *const T) callconv(.Inline) ?*anyopaque {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetStackLocation(@ptrCast(*const ICallFrame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_SetStackLocation(self: *const T, pvStack: ?*anyopaque) callconv(.Inline) void {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).SetStackLocation(@ptrCast(*const ICallFrame, self), pvStack);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_SetReturnValue(self: *const T, hr: HRESULT) callconv(.Inline) void {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).SetReturnValue(@ptrCast(*const ICallFrame, self), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetReturnValue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetReturnValue(@ptrCast(*const ICallFrame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetParamInfo(self: *const T, iparam: u32, pInfo: ?*CALLFRAMEPARAMINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetParamInfo(@ptrCast(*const ICallFrame, self), iparam, pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_SetParam(self: *const T, iparam: u32, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).SetParam(@ptrCast(*const ICallFrame, self), iparam, pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetParam(self: *const T, iparam: u32, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetParam(@ptrCast(*const ICallFrame, self), iparam, pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Copy(self: *const T, copyControl: CALLFRAME_COPY, pWalker: ?*ICallFrameWalker, ppFrame: ?*?*ICallFrame) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Copy(@ptrCast(*const ICallFrame, self), copyControl, pWalker, ppFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Free(self: *const T, pframeArgsDest: ?*ICallFrame, pWalkerDestFree: ?*ICallFrameWalker, pWalkerCopy: ?*ICallFrameWalker, freeFlags: u32, pWalkerFree: ?*ICallFrameWalker, nullFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Free(@ptrCast(*const ICallFrame, self), pframeArgsDest, pWalkerDestFree, pWalkerCopy, freeFlags, pWalkerFree, nullFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_FreeParam(self: *const T, iparam: u32, freeFlags: u32, pWalkerFree: ?*ICallFrameWalker, nullFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).FreeParam(@ptrCast(*const ICallFrame, self), iparam, freeFlags, pWalkerFree, nullFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_WalkFrame(self: *const T, walkWhat: u32, pWalker: ?*ICallFrameWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).WalkFrame(@ptrCast(*const ICallFrame, self), walkWhat, pWalker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_GetMarshalSizeMax(self: *const T, pmshlContext: ?*CALLFRAME_MARSHALCONTEXT, mshlflags: MSHLFLAGS, pcbBufferNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).GetMarshalSizeMax(@ptrCast(*const ICallFrame, self), pmshlContext, mshlflags, pcbBufferNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Marshal(self: *const T, pmshlContext: ?*CALLFRAME_MARSHALCONTEXT, mshlflags: MSHLFLAGS, pBuffer: [*]u8, cbBuffer: u32, pcbBufferUsed: ?*u32, pdataRep: ?*u32, prpcFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Marshal(@ptrCast(*const ICallFrame, self), pmshlContext, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Unmarshal(self: *const T, pBuffer: [*]u8, cbBuffer: u32, dataRep: u32, pcontext: ?*CALLFRAME_MARSHALCONTEXT, pcbUnmarshalled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Unmarshal(@ptrCast(*const ICallFrame, self), pBuffer, cbBuffer, dataRep, pcontext, pcbUnmarshalled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_ReleaseMarshalData(self: *const T, pBuffer: [*]u8, cbBuffer: u32, ibFirstRelease: u32, dataRep: u32, pcontext: ?*CALLFRAME_MARSHALCONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).ReleaseMarshalData(@ptrCast(*const ICallFrame, self), pBuffer, cbBuffer, ibFirstRelease, dataRep, pcontext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrame_Invoke(self: *const T, pvReceiver: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrame.VTable, self.vtable).Invoke(@ptrCast(*const ICallFrame, self), pvReceiver);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallIndirect_Value = @import("../../zig.zig").Guid.initString("d573b4b1-894e-11d2-b8b6-00c04fb9618a");
pub const IID_ICallIndirect = &IID_ICallIndirect_Value;
pub const ICallIndirect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CallIndirect: fn(
            self: *const ICallIndirect,
            phrReturn: ?*HRESULT,
            iMethod: u32,
            pvArgs: ?*anyopaque,
            cbArgs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMethodInfo: fn(
            self: *const ICallIndirect,
            iMethod: u32,
            pInfo: ?*CALLFRAMEINFO,
            pwszMethod: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackSize: fn(
            self: *const ICallIndirect,
            iMethod: u32,
            cbArgs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIID: fn(
            self: *const ICallIndirect,
            piid: ?*Guid,
            pfDerivesFromIDispatch: ?*BOOL,
            pcMethod: ?*u32,
            pwszInterface: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallIndirect_CallIndirect(self: *const T, phrReturn: ?*HRESULT, iMethod: u32, pvArgs: ?*anyopaque, cbArgs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallIndirect.VTable, self.vtable).CallIndirect(@ptrCast(*const ICallIndirect, self), phrReturn, iMethod, pvArgs, cbArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallIndirect_GetMethodInfo(self: *const T, iMethod: u32, pInfo: ?*CALLFRAMEINFO, pwszMethod: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallIndirect.VTable, self.vtable).GetMethodInfo(@ptrCast(*const ICallIndirect, self), iMethod, pInfo, pwszMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallIndirect_GetStackSize(self: *const T, iMethod: u32, cbArgs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallIndirect.VTable, self.vtable).GetStackSize(@ptrCast(*const ICallIndirect, self), iMethod, cbArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallIndirect_GetIID(self: *const T, piid: ?*Guid, pfDerivesFromIDispatch: ?*BOOL, pcMethod: ?*u32, pwszInterface: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallIndirect.VTable, self.vtable).GetIID(@ptrCast(*const ICallIndirect, self), piid, pfDerivesFromIDispatch, pcMethod, pwszInterface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallInterceptor_Value = @import("../../zig.zig").Guid.initString("60c7ca75-896d-11d2-b8b6-00c04fb9618a");
pub const IID_ICallInterceptor = &IID_ICallInterceptor_Value;
pub const ICallInterceptor = extern struct {
    pub const VTable = extern struct {
        base: ICallIndirect.VTable,
        RegisterSink: fn(
            self: *const ICallInterceptor,
            psink: ?*ICallFrameEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisteredSink: fn(
            self: *const ICallInterceptor,
            ppsink: ?*?*ICallFrameEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICallIndirect.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallInterceptor_RegisterSink(self: *const T, psink: ?*ICallFrameEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallInterceptor.VTable, self.vtable).RegisterSink(@ptrCast(*const ICallInterceptor, self), psink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallInterceptor_GetRegisteredSink(self: *const T, ppsink: ?*?*ICallFrameEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallInterceptor.VTable, self.vtable).GetRegisteredSink(@ptrCast(*const ICallInterceptor, self), ppsink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFrameEvents_Value = @import("../../zig.zig").Guid.initString("fd5e0843-fc91-11d0-97d7-00c04fb9618a");
pub const IID_ICallFrameEvents = &IID_ICallFrameEvents_Value;
pub const ICallFrameEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCall: fn(
            self: *const ICallFrameEvents,
            pFrame: ?*ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrameEvents_OnCall(self: *const T, pFrame: ?*ICallFrame) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrameEvents.VTable, self.vtable).OnCall(@ptrCast(*const ICallFrameEvents, self), pFrame);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallUnmarshal_Value = @import("../../zig.zig").Guid.initString("5333b003-2e42-11d2-b89d-00c04fb9618a");
pub const IID_ICallUnmarshal = &IID_ICallUnmarshal_Value;
pub const ICallUnmarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Unmarshal: fn(
            self: *const ICallUnmarshal,
            iMethod: u32,
            pBuffer: [*]u8,
            cbBuffer: u32,
            fForceBufferCopy: BOOL,
            dataRep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
            pcbUnmarshalled: ?*u32,
            ppFrame: ?*?*ICallFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseMarshalData: fn(
            self: *const ICallUnmarshal,
            iMethod: u32,
            pBuffer: [*]u8,
            cbBuffer: u32,
            ibFirstRelease: u32,
            dataRep: u32,
            pcontext: ?*CALLFRAME_MARSHALCONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallUnmarshal_Unmarshal(self: *const T, iMethod: u32, pBuffer: [*]u8, cbBuffer: u32, fForceBufferCopy: BOOL, dataRep: u32, pcontext: ?*CALLFRAME_MARSHALCONTEXT, pcbUnmarshalled: ?*u32, ppFrame: ?*?*ICallFrame) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallUnmarshal.VTable, self.vtable).Unmarshal(@ptrCast(*const ICallUnmarshal, self), iMethod, pBuffer, cbBuffer, fForceBufferCopy, dataRep, pcontext, pcbUnmarshalled, ppFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallUnmarshal_ReleaseMarshalData(self: *const T, iMethod: u32, pBuffer: [*]u8, cbBuffer: u32, ibFirstRelease: u32, dataRep: u32, pcontext: ?*CALLFRAME_MARSHALCONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallUnmarshal.VTable, self.vtable).ReleaseMarshalData(@ptrCast(*const ICallUnmarshal, self), iMethod, pBuffer, cbBuffer, ibFirstRelease, dataRep, pcontext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFrameWalker_Value = @import("../../zig.zig").Guid.initString("08b23919-392d-11d2-b8a4-00c04fb9618a");
pub const IID_ICallFrameWalker = &IID_ICallFrameWalker_Value;
pub const ICallFrameWalker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnWalkInterface: fn(
            self: *const ICallFrameWalker,
            iid: ?*const Guid,
            ppvInterface: ?*?*anyopaque,
            fIn: BOOL,
            fOut: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICallFrameWalker_OnWalkInterface(self: *const T, iid: ?*const Guid, ppvInterface: ?*?*anyopaque, fIn: BOOL, fOut: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICallFrameWalker.VTable, self.vtable).OnWalkInterface(@ptrCast(*const ICallFrameWalker, self), iid, ppvInterface, fIn, fOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInterfaceRelated_Value = @import("../../zig.zig").Guid.initString("d1fb5a79-7706-11d1-adba-00c04fc2adc0");
pub const IID_IInterfaceRelated = &IID_IInterfaceRelated_Value;
pub const IInterfaceRelated = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIID: fn(
            self: *const IInterfaceRelated,
            iid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIID: fn(
            self: *const IInterfaceRelated,
            piid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInterfaceRelated_SetIID(self: *const T, iid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInterfaceRelated.VTable, self.vtable).SetIID(@ptrCast(*const IInterfaceRelated, self), iid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInterfaceRelated_GetIID(self: *const T, piid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInterfaceRelated.VTable, self.vtable).GetIID(@ptrCast(*const IInterfaceRelated, self), piid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (2)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInterceptor(
    iidIntercepted: ?*const Guid,
    punkOuter: ?*IUnknown,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoGetInterceptorFromTypeInfo(
    iidIntercepted: ?*const Guid,
    punkOuter: ?*IUnknown,
    typeInfo: ?*ITypeInfo,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BOOLEAN = @import("../../foundation.zig").BOOLEAN;
const HRESULT = @import("../../foundation.zig").HRESULT;
const ITypeInfo = @import("../../system/com.zig").ITypeInfo;
const IUnknown = @import("../../system/com.zig").IUnknown;
const MSHLFLAGS = @import("../../system/com.zig").MSHLFLAGS;
const PWSTR = @import("../../foundation.zig").PWSTR;
const VARIANT = @import("../../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
