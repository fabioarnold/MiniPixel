//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (349)
//--------------------------------------------------------------------------------
pub const UIALL = @as(u32, 32768);
pub const LOGTOKEN_TYPE_MASK = @as(u32, 3);
pub const LOGTOKEN_UNSPECIFIED = @as(u32, 0);
pub const LOGTOKEN_NO_LOG = @as(u32, 1);
pub const LOGTOKEN_SETUPAPI_APPLOG = @as(u32, 2);
pub const LOGTOKEN_SETUPAPI_DEVLOG = @as(u32, 3);
pub const TXTLOG_SETUPAPI_DEVLOG = @as(u32, 1);
pub const TXTLOG_SETUPAPI_CMDLINE = @as(u32, 2);
pub const TXTLOG_SETUPAPI_BITS = @as(u32, 3);
pub const TXTLOG_ERROR = @as(u32, 1);
pub const TXTLOG_WARNING = @as(u32, 2);
pub const TXTLOG_SYSTEM_STATE_CHANGE = @as(u32, 3);
pub const TXTLOG_SUMMARY = @as(u32, 4);
pub const TXTLOG_DETAILS = @as(u32, 5);
pub const TXTLOG_VERBOSE = @as(u32, 6);
pub const TXTLOG_VERY_VERBOSE = @as(u32, 7);
pub const TXTLOG_RESERVED_FLAGS = @as(u32, 65520);
pub const TXTLOG_TIMESTAMP = @as(u32, 65536);
pub const TXTLOG_DEPTH_INCR = @as(u32, 131072);
pub const TXTLOG_DEPTH_DECR = @as(u32, 262144);
pub const TXTLOG_TAB_1 = @as(u32, 524288);
pub const TXTLOG_FLUSH_FILE = @as(u32, 1048576);
pub const TXTLOG_DEVINST = @as(u32, 1);
pub const TXTLOG_INF = @as(u32, 2);
pub const TXTLOG_FILEQ = @as(u32, 4);
pub const TXTLOG_COPYFILES = @as(u32, 8);
pub const TXTLOG_SIGVERIF = @as(u32, 32);
pub const TXTLOG_BACKUP = @as(u32, 128);
pub const TXTLOG_UI = @as(u32, 256);
pub const TXTLOG_UTIL = @as(u32, 512);
pub const TXTLOG_INFDB = @as(u32, 1024);
pub const TXTLOG_DRVSETUP = @as(u32, 4194304);
pub const TXTLOG_POLICY = @as(u32, 8388608);
pub const TXTLOG_NEWDEV = @as(u32, 16777216);
pub const TXTLOG_UMPNPMGR = @as(u32, 33554432);
pub const TXTLOG_DRIVER_STORE = @as(u32, 67108864);
pub const TXTLOG_SETUP = @as(u32, 134217728);
pub const TXTLOG_CMI = @as(u32, 268435456);
pub const TXTLOG_DEVMGR = @as(u32, 536870912);
pub const TXTLOG_INSTALLER = @as(u32, 1073741824);
pub const TXTLOG_VENDOR = @as(u32, 2147483648);
pub const CLSID_EvalCom2 = Guid.initString("6e5e1910-8053-4660-b795-6b612e29bc58");
pub const _WIN32_MSM = @as(u32, 100);
pub const LIBID_MsmMergeTypeLib = Guid.initString("0adda82f-2c26-11d2-ad65-00a0c9af11a6");
pub const CLSID_MsmMerge2 = Guid.initString("f94985d5-29f9-4743-9805-99bc3f35b678");
pub const _WIN32_MSI = @as(u32, 500);
pub const MAX_GUID_CHARS = @as(u32, 38);
pub const MAX_FEATURE_CHARS = @as(u32, 38);
pub const MSI_INVALID_HASH_IS_FATAL = @as(u32, 1);
pub const ERROR_ROLLBACK_DISABLED = @as(u32, 1653);
pub const MSI_NULL_INTEGER = @as(u32, 2147483648);
pub const INSTALLMESSAGE_TYPEMASK = @as(i32, -16777216);
pub const STREAM_FORMAT_COMPLIB_MODULE = @as(u32, 0);
pub const STREAM_FORMAT_COMPLIB_MANIFEST = @as(u32, 1);
pub const STREAM_FORMAT_WIN32_MODULE = @as(u32, 2);
pub const STREAM_FORMAT_WIN32_MANIFEST = @as(u32, 4);
pub const IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH = @as(u32, 1);
pub const ASSEMBLYINFO_FLAG_INSTALLED = @as(u32, 1);
pub const ASSEMBLYINFO_FLAG_PAYLOADRESIDENT = @as(u32, 2);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED = @as(u32, 1);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED = @as(u32, 2);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED = @as(u32, 3);
pub const FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID = Guid.initString("8cedc215-ac4b-488b-93c0-a50a49cb2fb8");
pub const FUSION_REFCOUNT_FILEPATH_GUID = Guid.initString("b02f9d65-fb77-4f7a-afa5-b391309f11c9");
pub const FUSION_REFCOUNT_OPAQUE_STRING_GUID = Guid.initString("2ec93463-b0c3-45e1-8364-327e96aea856");
pub const SFC_DISABLE_NORMAL = @as(u32, 0);
pub const SFC_DISABLE_ASK = @as(u32, 1);
pub const SFC_DISABLE_ONCE = @as(u32, 2);
pub const SFC_DISABLE_SETUP = @as(u32, 3);
pub const SFC_DISABLE_NOPOPUPS = @as(u32, 4);
pub const SFC_SCAN_NORMAL = @as(u32, 0);
pub const SFC_SCAN_ALWAYS = @as(u32, 1);
pub const SFC_SCAN_ONCE = @as(u32, 2);
pub const SFC_SCAN_IMMEDIATE = @as(u32, 3);
pub const SFC_QUOTA_DEFAULT = @as(u32, 50);
pub const PID_TITLE = @as(u32, 2);
pub const PID_SUBJECT = @as(u32, 3);
pub const PID_AUTHOR = @as(u32, 4);
pub const PID_KEYWORDS = @as(u32, 5);
pub const PID_COMMENTS = @as(u32, 6);
pub const PID_TEMPLATE = @as(u32, 7);
pub const PID_LASTAUTHOR = @as(u32, 8);
pub const PID_REVNUMBER = @as(u32, 9);
pub const PID_EDITTIME = @as(u32, 10);
pub const PID_LASTPRINTED = @as(u32, 11);
pub const PID_CREATE_DTM = @as(u32, 12);
pub const PID_LASTSAVE_DTM = @as(u32, 13);
pub const PID_PAGECOUNT = @as(u32, 14);
pub const PID_WORDCOUNT = @as(u32, 15);
pub const PID_CHARCOUNT = @as(u32, 16);
pub const PID_THUMBNAIL = @as(u32, 17);
pub const PID_APPNAME = @as(u32, 18);
pub const PID_MSIVERSION = @as(u32, 14);
pub const PID_MSISOURCE = @as(u32, 15);
pub const PID_MSIRESTRICT = @as(u32, 16);
pub const PATCH_OPTION_USE_BEST = @as(u32, 0);
pub const PATCH_OPTION_USE_LZX_BEST = @as(u32, 3);
pub const PATCH_OPTION_USE_LZX_A = @as(u32, 1);
pub const PATCH_OPTION_USE_LZX_B = @as(u32, 2);
pub const PATCH_OPTION_USE_LZX_LARGE = @as(u32, 4);
pub const PATCH_OPTION_NO_BINDFIX = @as(u32, 65536);
pub const PATCH_OPTION_NO_LOCKFIX = @as(u32, 131072);
pub const PATCH_OPTION_NO_REBASE = @as(u32, 262144);
pub const PATCH_OPTION_FAIL_IF_SAME_FILE = @as(u32, 524288);
pub const PATCH_OPTION_FAIL_IF_BIGGER = @as(u32, 1048576);
pub const PATCH_OPTION_NO_CHECKSUM = @as(u32, 2097152);
pub const PATCH_OPTION_NO_RESTIMEFIX = @as(u32, 4194304);
pub const PATCH_OPTION_NO_TIMESTAMP = @as(u32, 8388608);
pub const PATCH_OPTION_SIGNATURE_MD5 = @as(u32, 16777216);
pub const PATCH_OPTION_INTERLEAVE_FILES = @as(u32, 1073741824);
pub const PATCH_OPTION_RESERVED1 = @as(u32, 2147483648);
pub const PATCH_OPTION_VALID_FLAGS = @as(u32, 3237937159);
pub const PATCH_SYMBOL_NO_IMAGEHLP = @as(u32, 1);
pub const PATCH_SYMBOL_NO_FAILURES = @as(u32, 2);
pub const PATCH_SYMBOL_UNDECORATED_TOO = @as(u32, 4);
pub const PATCH_SYMBOL_RESERVED1 = @as(u32, 2147483648);
pub const PATCH_TRANSFORM_PE_RESOURCE_2 = @as(u32, 256);
pub const PATCH_TRANSFORM_PE_IRELOC_2 = @as(u32, 512);
pub const APPLY_OPTION_FAIL_IF_EXACT = @as(u32, 1);
pub const APPLY_OPTION_FAIL_IF_CLOSE = @as(u32, 2);
pub const APPLY_OPTION_TEST_ONLY = @as(u32, 4);
pub const APPLY_OPTION_VALID_FLAGS = @as(u32, 7);
pub const ERROR_PATCH_ENCODE_FAILURE = @as(u32, 3222155521);
pub const ERROR_PATCH_INVALID_OPTIONS = @as(u32, 3222155522);
pub const ERROR_PATCH_SAME_FILE = @as(u32, 3222155523);
pub const ERROR_PATCH_RETAIN_RANGES_DIFFER = @as(u32, 3222155524);
pub const ERROR_PATCH_BIGGER_THAN_COMPRESSED = @as(u32, 3222155525);
pub const ERROR_PATCH_IMAGEHLP_FAILURE = @as(u32, 3222155526);
pub const ERROR_PATCH_DECODE_FAILURE = @as(u32, 3222159617);
pub const ERROR_PATCH_CORRUPT = @as(u32, 3222159618);
pub const ERROR_PATCH_NEWER_FORMAT = @as(u32, 3222159619);
pub const ERROR_PATCH_WRONG_FILE = @as(u32, 3222159620);
pub const ERROR_PATCH_NOT_NECESSARY = @as(u32, 3222159621);
pub const ERROR_PATCH_NOT_AVAILABLE = @as(u32, 3222159622);
pub const ERROR_PCW_BASE = @as(u32, 3222163713);
pub const ERROR_PCW_PCP_DOESNT_EXIST = @as(u32, 3222163713);
pub const ERROR_PCW_PCP_BAD_FORMAT = @as(u32, 3222163714);
pub const ERROR_PCW_CANT_CREATE_TEMP_FOLDER = @as(u32, 3222163715);
pub const ERROR_PCW_MISSING_PATCH_PATH = @as(u32, 3222163716);
pub const ERROR_PCW_CANT_OVERWRITE_PATCH = @as(u32, 3222163717);
pub const ERROR_PCW_CANT_CREATE_PATCH_FILE = @as(u32, 3222163718);
pub const ERROR_PCW_MISSING_PATCH_GUID = @as(u32, 3222163719);
pub const ERROR_PCW_BAD_PATCH_GUID = @as(u32, 3222163720);
pub const ERROR_PCW_BAD_GUIDS_TO_REPLACE = @as(u32, 3222163721);
pub const ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST = @as(u32, 3222163722);
pub const ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH = @as(u32, 3222163723);
pub const ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS = @as(u32, 3222163725);
pub const ERROR_PCW_OODS_COPYING_MSI = @as(u32, 3222163726);
pub const ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG = @as(u32, 3222163727);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_NAME = @as(u32, 3222163728);
pub const ERROR_PCW_DUP_UPGRADED_IMAGE_NAME = @as(u32, 3222163729);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG = @as(u32, 3222163730);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY = @as(u32, 3222163731);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST = @as(u32, 3222163732);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI = @as(u32, 3222163733);
pub const ERROR_PCW_UPGRADED_IMAGE_COMPRESSED = @as(u32, 3222163734);
pub const ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG = @as(u32, 3222163735);
pub const ERROR_PCW_BAD_TARGET_IMAGE_NAME = @as(u32, 3222163736);
pub const ERROR_PCW_DUP_TARGET_IMAGE_NAME = @as(u32, 3222163737);
pub const ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG = @as(u32, 3222163738);
pub const ERROR_PCW_TARGET_IMAGE_PATH_EMPTY = @as(u32, 3222163739);
pub const ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST = @as(u32, 3222163740);
pub const ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI = @as(u32, 3222163741);
pub const ERROR_PCW_TARGET_IMAGE_COMPRESSED = @as(u32, 3222163742);
pub const ERROR_PCW_TARGET_BAD_PROD_VALIDATE = @as(u32, 3222163743);
pub const ERROR_PCW_TARGET_BAD_PROD_CODE_VAL = @as(u32, 3222163744);
pub const ERROR_PCW_UPGRADED_MISSING_SRC_FILES = @as(u32, 3222163745);
pub const ERROR_PCW_TARGET_MISSING_SRC_FILES = @as(u32, 3222163746);
pub const ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG = @as(u32, 3222163747);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_NAME = @as(u32, 3222163748);
pub const ERROR_PCW_DUP_IMAGE_FAMILY_NAME = @as(u32, 3222163749);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP = @as(u32, 3222163750);
pub const ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY = @as(u32, 3222163751);
pub const ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY = @as(u32, 3222163752);
pub const ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY = @as(u32, 3222163753);
pub const ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY = @as(u32, 3222163754);
pub const ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY = @as(u32, 3222163755);
pub const ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD = @as(u32, 3222163756);
pub const ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE = @as(u32, 3222163757);
pub const ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE = @as(u32, 3222163758);
pub const ERROR_PCW_EXTFILE_MISSING_FILE = @as(u32, 3222163759);
pub const ERROR_PCW_BAD_FILE_SEQUENCE_START = @as(u32, 3222163770);
pub const ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER = @as(u32, 3222163771);
pub const ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE = @as(u32, 3222163772);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_DISKID = @as(u32, 3222163773);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART = @as(u32, 3222163774);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY = @as(u32, 3222163775);
pub const ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED = @as(u32, 3222163776);
pub const ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE = @as(u32, 3222163777);
pub const ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD = @as(u32, 3222163778);
pub const ERROR_PCW_MISMATCHED_PRODUCT_CODES = @as(u32, 3222163779);
pub const ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS = @as(u32, 3222163780);
pub const ERROR_PCW_CANNOT_WRITE_DDF = @as(u32, 3222163781);
pub const ERROR_PCW_CANNOT_RUN_MAKECAB = @as(u32, 3222163782);
pub const ERROR_PCW_WRITE_SUMMARY_PROPERTIES = @as(u32, 3222163787);
pub const ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY = @as(u32, 3222163788);
pub const ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY = @as(u32, 3222163789);
pub const ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY = @as(u32, 3222163790);
pub const ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD = @as(u32, 3222163791);
pub const ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG = @as(u32, 3222163792);
pub const ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST = @as(u32, 3222163793);
pub const ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI = @as(u32, 3222163794);
pub const ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE = @as(u32, 3222163795);
pub const ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD = @as(u32, 3222163796);
pub const ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY = @as(u32, 3222163797);
pub const ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY = @as(u32, 3222163798);
pub const ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY = @as(u32, 3222163799);
pub const ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG = @as(u32, 3222163800);
pub const ERROR_PCW_BAD_FAMILY_RANGE_NAME = @as(u32, 3222163801);
pub const ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY = @as(u32, 3222163802);
pub const ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY = @as(u32, 3222163803);
pub const ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS = @as(u32, 3222163804);
pub const ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS = @as(u32, 3222163805);
pub const ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS = @as(u32, 3222163806);
pub const ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS = @as(u32, 3222163807);
pub const ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS = @as(u32, 3222163808);
pub const ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS = @as(u32, 3222163809);
pub const ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH = @as(u32, 3222163810);
pub const ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS = @as(u32, 3222163811);
pub const ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS = @as(u32, 3222163812);
pub const ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS = @as(u32, 3222163813);
pub const ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS = @as(u32, 3222163814);
pub const ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH = @as(u32, 3222163815);
pub const ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS = @as(u32, 3222163816);
pub const ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS = @as(u32, 3222163817);
pub const ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS = @as(u32, 3222163819);
pub const ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS = @as(u32, 3222163820);
pub const ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS = @as(u32, 3222163821);
pub const ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS = @as(u32, 3222163822);
pub const ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH = @as(u32, 3222163823);
pub const ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS = @as(u32, 3222163824);
pub const ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS = @as(u32, 3222163825);
pub const ERROR_PCW_CANT_GENERATE_TRANSFORM = @as(u32, 3222163827);
pub const ERROR_PCW_CANT_CREATE_SUMMARY_INFO = @as(u32, 3222163828);
pub const ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND = @as(u32, 3222163829);
pub const ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND = @as(u32, 3222163830);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE = @as(u32, 3222163831);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION = @as(u32, 3222163832);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE = @as(u32, 3222163833);
pub const ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE = @as(u32, 3222163834);
pub const ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION = @as(u32, 3222163835);
pub const ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE = @as(u32, 3222163836);
pub const ERROR_PCW_MATCHED_PRODUCT_VERSIONS = @as(u32, 3222163837);
pub const ERROR_PCW_OBSOLETION_WITH_SEQUENCE_DATA = @as(u32, 3222163838);
pub const ERROR_PCW_OBSOLETION_WITH_MSI30 = @as(u32, 3222163839);
pub const ERROR_PCW_OBSOLETION_WITH_PATCHSEQUENCE = @as(u32, 3222163840);
pub const ERROR_PCW_CANNOT_CREATE_TABLE = @as(u32, 3222163841);
pub const ERROR_PCW_CANT_GENERATE_SEQUENCEINFO_MAJORUPGD = @as(u32, 3222163842);
pub const ERROR_PCW_MAJOR_UPGD_WITHOUT_SEQUENCING = @as(u32, 3222163843);
pub const ERROR_PCW_BAD_PRODUCTVERSION_VALIDATION = @as(u32, 3222163844);
pub const ERROR_PCW_BAD_TRANSFORMSET = @as(u32, 3222163845);
pub const ERROR_PCW_BAD_TGT_UPD_IMAGES = @as(u32, 3222163846);
pub const ERROR_PCW_BAD_SUPERCEDENCE = @as(u32, 3222163847);
pub const ERROR_PCW_BAD_SEQUENCE = @as(u32, 3222163848);
pub const ERROR_PCW_BAD_TARGET = @as(u32, 3222163849);
pub const ERROR_PCW_NULL_PATCHFAMILY = @as(u32, 3222163850);
pub const ERROR_PCW_NULL_SEQUENCE_NUMBER = @as(u32, 3222163851);
pub const ERROR_PCW_BAD_VERSION_STRING = @as(u32, 3222163852);
pub const ERROR_PCW_BAD_MAJOR_VERSION = @as(u32, 3222163853);
pub const ERROR_PCW_SEQUENCING_BAD_TARGET = @as(u32, 3222163854);
pub const ERROR_PCW_PATCHMETADATA_PROP_NOT_SET = @as(u32, 3222163855);
pub const ERROR_PCW_INVALID_PATCHMETADATA_PROP = @as(u32, 3222163856);
pub const ERROR_PCW_INVALID_SUPERCEDENCE = @as(u32, 3222163857);
pub const ERROR_PCW_DUPLICATE_SEQUENCE_RECORD = @as(u32, 3222163858);
pub const ERROR_PCW_WRONG_PATCHMETADATA_STRD_PROP = @as(u32, 3222163859);
pub const ERROR_PCW_INVALID_PARAMETER = @as(u32, 3222163860);
pub const ERROR_PCW_CREATEFILE_LOG_FAILED = @as(u32, 3222163861);
pub const ERROR_PCW_INVALID_LOG_LEVEL = @as(u32, 3222163862);
pub const ERROR_PCW_INVALID_UI_LEVEL = @as(u32, 3222163863);
pub const ERROR_PCW_ERROR_WRITING_TO_LOG = @as(u32, 3222163864);
pub const ERROR_PCW_OUT_OF_MEMORY = @as(u32, 3222163865);
pub const ERROR_PCW_UNKNOWN_ERROR = @as(u32, 3222163866);
pub const ERROR_PCW_UNKNOWN_INFO = @as(u32, 3222163867);
pub const ERROR_PCW_UNKNOWN_WARN = @as(u32, 3222163868);
pub const ERROR_PCW_OPEN_VIEW = @as(u32, 3222163869);
pub const ERROR_PCW_EXECUTE_VIEW = @as(u32, 3222163870);
pub const ERROR_PCW_VIEW_FETCH = @as(u32, 3222163871);
pub const ERROR_PCW_FAILED_EXPAND_PATH = @as(u32, 3222163872);
pub const ERROR_PCW_INTERNAL_ERROR = @as(u32, 3222163969);
pub const ERROR_PCW_INVALID_PCP_PROPERTY = @as(u32, 3222163970);
pub const ERROR_PCW_INVALID_PCP_TARGETIMAGES = @as(u32, 3222163971);
pub const ERROR_PCW_LAX_VALIDATION_FLAGS = @as(u32, 3222163972);
pub const ERROR_PCW_FAILED_CREATE_TRANSFORM = @as(u32, 3222163973);
pub const ERROR_PCW_CANT_DELETE_TEMP_FOLDER = @as(u32, 3222163974);
pub const ERROR_PCW_MISSING_DIRECTORY_TABLE = @as(u32, 3222163975);
pub const ERROR_PCW_INVALID_SUPERSEDENCE_VALUE = @as(u32, 3222163976);
pub const ERROR_PCW_INVALID_PATCH_TYPE_SEQUENCING = @as(u32, 3222163977);
pub const ERROR_PCW_CANT_READ_FILE = @as(u32, 3222163978);
pub const ERROR_PCW_TARGET_WRONG_PRODUCT_VERSION_COMP = @as(u32, 3222163979);
pub const ERROR_PCW_INVALID_PCP_UPGRADEDFILESTOIGNORE = @as(u32, 3222163980);
pub const ERROR_PCW_INVALID_PCP_UPGRADEDIMAGES = @as(u32, 3222163981);
pub const ERROR_PCW_INVALID_PCP_EXTERNALFILES = @as(u32, 3222163982);
pub const ERROR_PCW_INVALID_PCP_IMAGEFAMILIES = @as(u32, 3222163983);
pub const ERROR_PCW_INVALID_PCP_PATCHSEQUENCE = @as(u32, 3222163984);
pub const ERROR_PCW_INVALID_PCP_TARGETFILES_OPTIONALDATA = @as(u32, 3222163985);
pub const ERROR_PCW_INVALID_PCP_UPGRADEDFILES_OPTIONALDATA = @as(u32, 3222163986);
pub const ERROR_PCW_MISSING_PATCHMETADATA = @as(u32, 3222163987);
pub const ERROR_PCW_IMAGE_PATH_NOT_EXIST = @as(u32, 3222163988);
pub const ERROR_PCW_INVALID_RANGE_ELEMENT = @as(u32, 3222163989);
pub const ERROR_PCW_INVALID_MAJOR_VERSION = @as(u32, 3222163990);
pub const ERROR_PCW_INVALID_PCP_PROPERTIES = @as(u32, 3222163991);
pub const ERROR_PCW_INVALID_PCP_FAMILYFILERANGES = @as(u32, 3222163992);
pub const INFO_BASE = @as(u32, 3222229249);
pub const INFO_PASSED_MAIN_CONTROL = @as(u32, 3222229249);
pub const INFO_ENTERING_PHASE_I_VALIDATION = @as(u32, 3222229250);
pub const INFO_ENTERING_PHASE_I = @as(u32, 3222229251);
pub const INFO_PCP_PATH = @as(u32, 3222229252);
pub const INFO_TEMP_DIR = @as(u32, 3222229253);
pub const INFO_SET_OPTIONS = @as(u32, 3222229254);
pub const INFO_PROPERTY = @as(u32, 3222229255);
pub const INFO_ENTERING_PHASE_II = @as(u32, 3222229256);
pub const INFO_ENTERING_PHASE_III = @as(u32, 3222229257);
pub const INFO_ENTERING_PHASE_IV = @as(u32, 3222229258);
pub const INFO_ENTERING_PHASE_V = @as(u32, 3222229259);
pub const INFO_GENERATING_METADATA = @as(u32, 3222229265);
pub const INFO_TEMP_DIR_CLEANUP = @as(u32, 3222229266);
pub const INFO_PATCHCACHE_FILEINFO_FAILURE = @as(u32, 3222229267);
pub const INFO_PATCHCACHE_PCI_READFAILURE = @as(u32, 3222229268);
pub const INFO_PATCHCACHE_PCI_WRITEFAILURE = @as(u32, 3222229269);
pub const INFO_USING_USER_MSI_FOR_PATCH_TABLES = @as(u32, 3222229270);
pub const INFO_SUCCESSFUL_PATCH_CREATION = @as(u32, 3222229271);
pub const WARN_BASE = @as(u32, 3222294785);
pub const WARN_MAJOR_UPGRADE_PATCH = @as(u32, 3222294785);
pub const WARN_SEQUENCE_DATA_GENERATION_DISABLED = @as(u32, 3222294786);
pub const WARN_SEQUENCE_DATA_SUPERSEDENCE_IGNORED = @as(u32, 3222294787);
pub const WARN_IMPROPER_TRANSFORM_VALIDATION = @as(u32, 3222294788);
pub const WARN_PCW_MISMATCHED_PRODUCT_CODES = @as(u32, 3222294789);
pub const WARN_PCW_MISMATCHED_PRODUCT_VERSIONS = @as(u32, 3222294790);
pub const WARN_INVALID_TRANSFORM_VALIDATION = @as(u32, 3222294791);
pub const WARN_BAD_MAJOR_VERSION = @as(u32, 3222294792);
pub const WARN_FILE_VERSION_DOWNREV = @as(u32, 3222294793);
pub const WARN_EQUAL_FILE_VERSION = @as(u32, 3222294794);
pub const WARN_PATCHPROPERTYNOTSET = @as(u32, 3222294795);
pub const WARN_OBSOLETION_WITH_SEQUENCE_DATA = @as(u32, 3222294802);
pub const WARN_OBSOLETION_WITH_MSI30 = @as(u32, 3222294801);
pub const WARN_OBSOLETION_WITH_PATCHSEQUENCE = @as(u32, 3222294803);
pub const DELTA_MAX_HASH_SIZE = @as(u32, 32);
pub const cchMaxInteger = @as(i32, 12);
pub const LOGNONE = @as(u32, 0);
pub const LOGINFO = @as(u32, 1);
pub const LOGWARN = @as(u32, 2);
pub const LOGERR = @as(u32, 4);
pub const LOGPERFMESSAGES = @as(u32, 8);
pub const LOGALL = @as(u32, 15);
pub const UINONE = @as(u32, 0);
pub const UILOGBITS = @as(u32, 15);
pub const DEFAULT_MINIMUM_REQUIRED_MSI_VERSION = @as(u32, 100);
pub const DEFAULT_FILE_SEQUENCE_START = @as(u32, 2);
pub const DEFAULT_DISK_ID = @as(u32, 2);

//--------------------------------------------------------------------------------
// Section: Types (179)
//--------------------------------------------------------------------------------
pub const MSIASSEMBLYINFO = enum(u32) {
    NETASSEMBLY = 0,
    WIN32ASSEMBLY = 1,
};
pub const MSIASSEMBLYINFO_NETASSEMBLY = MSIASSEMBLYINFO.NETASSEMBLY;
pub const MSIASSEMBLYINFO_WIN32ASSEMBLY = MSIASSEMBLYINFO.WIN32ASSEMBLY;

pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION = enum(u32) {
    UNINSTALLED = 1,
    STILL_IN_USE = 2,
    ALREADY_UNINSTALLED = 3,
    DELETE_PENDING = 4,
};
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.UNINSTALLED;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.STILL_IN_USE;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.ALREADY_UNINSTALLED;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.DELETE_PENDING;

pub const QUERYASMINFO_FLAGS = enum(u32) {
    E = 1,
    _,
    pub fn initFlags(o: struct {
        E: u1 = 0,
    }) QUERYASMINFO_FLAGS {
        return @intToEnum(QUERYASMINFO_FLAGS,
              (if (o.E == 1) @enumToInt(QUERYASMINFO_FLAGS.E) else 0)
        );
    }
};
pub const QUERYASMINFO_FLAG_VALIDATE = QUERYASMINFO_FLAGS.E;

// TODO: this type has a FreeFunc 'MsiCloseHandle', what can Zig do with this information?
pub const MSIHANDLE = u32;

pub const RESULTTYPES = enum(i32) {
    Unknown = 0,
    Error = 1,
    Warning = 2,
    Info = 3,
};
pub const ieUnknown = RESULTTYPES.Unknown;
pub const ieError = RESULTTYPES.Error;
pub const ieWarning = RESULTTYPES.Warning;
pub const ieInfo = RESULTTYPES.Info;

pub const STATUSTYPES = enum(i32) {
    GetCUB = 0,
    ICECount = 1,
    Merge = 2,
    SummaryInfo = 3,
    CreateEngine = 4,
    Starting = 5,
    RunICE = 6,
    Shutdown = 7,
    Success = 8,
    Fail = 9,
    Cancel = 10,
};
pub const ieStatusGetCUB = STATUSTYPES.GetCUB;
pub const ieStatusICECount = STATUSTYPES.ICECount;
pub const ieStatusMerge = STATUSTYPES.Merge;
pub const ieStatusSummaryInfo = STATUSTYPES.SummaryInfo;
pub const ieStatusCreateEngine = STATUSTYPES.CreateEngine;
pub const ieStatusStarting = STATUSTYPES.Starting;
pub const ieStatusRunICE = STATUSTYPES.RunICE;
pub const ieStatusShutdown = STATUSTYPES.Shutdown;
pub const ieStatusSuccess = STATUSTYPES.Success;
pub const ieStatusFail = STATUSTYPES.Fail;
pub const ieStatusCancel = STATUSTYPES.Cancel;

pub const LPDISPLAYVAL = fn(
    pContext: ?*anyopaque,
    uiType: RESULTTYPES,
    szwVal: ?[*:0]const u16,
    szwDescription: ?[*:0]const u16,
    szwLocation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPEVALCOMCALLBACK = fn(
    iStatus: STATUSTYPES,
    szData: ?[*:0]const u16,
    pContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const IID_IValidate_Value = @import("../zig.zig").Guid.initString("e482e5c6-e31e-4143-a2e6-dbc3d8e4b8d3");
pub const IID_IValidate = &IID_IValidate_Value;
pub const IValidate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenDatabase: fn(
            self: *const IValidate,
            szDatabase: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenCUB: fn(
            self: *const IValidate,
            szCUBFile: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDatabase: fn(
            self: *const IValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseCUB: fn(
            self: *const IValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplay: fn(
            self: *const IValidate,
            pDisplayFunction: ?LPDISPLAYVAL,
            pContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IValidate,
            pStatusFunction: ?LPEVALCOMCALLBACK,
            pContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: fn(
            self: *const IValidate,
            wzICEs: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_OpenDatabase(self: *const T, szDatabase: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).OpenDatabase(@ptrCast(*const IValidate, self), szDatabase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_OpenCUB(self: *const T, szCUBFile: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).OpenCUB(@ptrCast(*const IValidate, self), szCUBFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_CloseDatabase(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).CloseDatabase(@ptrCast(*const IValidate, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_CloseCUB(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).CloseCUB(@ptrCast(*const IValidate, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_SetDisplay(self: *const T, pDisplayFunction: ?LPDISPLAYVAL, pContext: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).SetDisplay(@ptrCast(*const IValidate, self), pDisplayFunction, pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_SetStatus(self: *const T, pStatusFunction: ?LPEVALCOMCALLBACK, pContext: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).SetStatus(@ptrCast(*const IValidate, self), pStatusFunction, pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_Validate(self: *const T, wzICEs: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).Validate(@ptrCast(*const IValidate, self), wzICEs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MsmMerge_Value = @import("../zig.zig").Guid.initString("0adda830-2c26-11d2-ad65-00a0c9af11a6");
pub const CLSID_MsmMerge = &CLSID_MsmMerge_Value;

pub const msmErrorType = enum(i32) {
    LanguageUnsupported = 1,
    LanguageFailed = 2,
    Exclusion = 3,
    TableMerge = 4,
    ResequenceMerge = 5,
    FileCreate = 6,
    DirCreate = 7,
    FeatureRequired = 8,
};
pub const msmErrorLanguageUnsupported = msmErrorType.LanguageUnsupported;
pub const msmErrorLanguageFailed = msmErrorType.LanguageFailed;
pub const msmErrorExclusion = msmErrorType.Exclusion;
pub const msmErrorTableMerge = msmErrorType.TableMerge;
pub const msmErrorResequenceMerge = msmErrorType.ResequenceMerge;
pub const msmErrorFileCreate = msmErrorType.FileCreate;
pub const msmErrorDirCreate = msmErrorType.DirCreate;
pub const msmErrorFeatureRequired = msmErrorType.FeatureRequired;

const IID_IEnumMsmString_Value = @import("../zig.zig").Guid.initString("0adda826-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmString = &IID_IEnumMsmString_Value;
pub const IEnumMsmString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMsmString,
            cFetch: u32,
            rgbstrStrings: ?*?BSTR,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMsmString,
            cSkip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMsmString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMsmString,
            pemsmStrings: ?*?*IEnumMsmString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmString_Next(self: *const T, cFetch: u32, rgbstrStrings: ?*?BSTR, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmString.VTable, self.vtable).Next(@ptrCast(*const IEnumMsmString, self), cFetch, rgbstrStrings, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmString_Skip(self: *const T, cSkip: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmString.VTable, self.vtable).Skip(@ptrCast(*const IEnumMsmString, self), cSkip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmString_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmString.VTable, self.vtable).Reset(@ptrCast(*const IEnumMsmString, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmString_Clone(self: *const T, pemsmStrings: ?*?*IEnumMsmString) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmString.VTable, self.vtable).Clone(@ptrCast(*const IEnumMsmString, self), pemsmStrings);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmStrings_Value = @import("../zig.zig").Guid.initString("0adda827-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmStrings = &IID_IMsmStrings_Value;
pub const IMsmStrings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMsmStrings,
            Item: i32,
            Return: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMsmStrings,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMsmStrings,
            NewEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmStrings_get_Item(self: *const T, Item: i32, Return: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmStrings.VTable, self.vtable).get_Item(@ptrCast(*const IMsmStrings, self), Item, Return);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmStrings_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmStrings.VTable, self.vtable).get_Count(@ptrCast(*const IMsmStrings, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmStrings_get__NewEnum(self: *const T, NewEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmStrings.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMsmStrings, self), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmError_Value = @import("../zig.zig").Guid.initString("0adda828-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmError = &IID_IMsmError_Value;
pub const IMsmError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IMsmError,
            ErrorType: ?*msmErrorType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IMsmError,
            ErrorPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: fn(
            self: *const IMsmError,
            ErrorLanguage: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DatabaseTable: fn(
            self: *const IMsmError,
            ErrorTable: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DatabaseKeys: fn(
            self: *const IMsmError,
            ErrorKeys: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleTable: fn(
            self: *const IMsmError,
            ErrorTable: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleKeys: fn(
            self: *const IMsmError,
            ErrorKeys: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_Type(self: *const T, ErrorType: ?*msmErrorType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_Type(@ptrCast(*const IMsmError, self), ErrorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_Path(self: *const T, ErrorPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_Path(@ptrCast(*const IMsmError, self), ErrorPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_Language(self: *const T, ErrorLanguage: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_Language(@ptrCast(*const IMsmError, self), ErrorLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_DatabaseTable(self: *const T, ErrorTable: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_DatabaseTable(@ptrCast(*const IMsmError, self), ErrorTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_DatabaseKeys(self: *const T, ErrorKeys: ?*?*IMsmStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_DatabaseKeys(@ptrCast(*const IMsmError, self), ErrorKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_ModuleTable(self: *const T, ErrorTable: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_ModuleTable(@ptrCast(*const IMsmError, self), ErrorTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_ModuleKeys(self: *const T, ErrorKeys: ?*?*IMsmStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_ModuleKeys(@ptrCast(*const IMsmError, self), ErrorKeys);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMsmError_Value = @import("../zig.zig").Guid.initString("0adda829-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmError = &IID_IEnumMsmError_Value;
pub const IEnumMsmError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMsmError,
            cFetch: u32,
            rgmsmErrors: ?*?*IMsmError,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMsmError,
            cSkip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMsmError,
            pemsmErrors: ?*?*IEnumMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmError_Next(self: *const T, cFetch: u32, rgmsmErrors: ?*?*IMsmError, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmError.VTable, self.vtable).Next(@ptrCast(*const IEnumMsmError, self), cFetch, rgmsmErrors, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmError_Skip(self: *const T, cSkip: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmError.VTable, self.vtable).Skip(@ptrCast(*const IEnumMsmError, self), cSkip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmError_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmError.VTable, self.vtable).Reset(@ptrCast(*const IEnumMsmError, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmError_Clone(self: *const T, pemsmErrors: ?*?*IEnumMsmError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmError.VTable, self.vtable).Clone(@ptrCast(*const IEnumMsmError, self), pemsmErrors);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmErrors_Value = @import("../zig.zig").Guid.initString("0adda82a-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmErrors = &IID_IMsmErrors_Value;
pub const IMsmErrors = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMsmErrors,
            Item: i32,
            Return: ?*?*IMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMsmErrors,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMsmErrors,
            NewEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmErrors_get_Item(self: *const T, Item: i32, Return: ?*?*IMsmError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmErrors.VTable, self.vtable).get_Item(@ptrCast(*const IMsmErrors, self), Item, Return);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmErrors_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmErrors.VTable, self.vtable).get_Count(@ptrCast(*const IMsmErrors, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmErrors_get__NewEnum(self: *const T, NewEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmErrors.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMsmErrors, self), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmDependency_Value = @import("../zig.zig").Guid.initString("0adda82b-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmDependency = &IID_IMsmDependency_Value;
pub const IMsmDependency = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Module: fn(
            self: *const IMsmDependency,
            Module: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: fn(
            self: *const IMsmDependency,
            Language: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const IMsmDependency,
            Version: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependency_get_Module(self: *const T, Module: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependency.VTable, self.vtable).get_Module(@ptrCast(*const IMsmDependency, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependency_get_Language(self: *const T, Language: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependency.VTable, self.vtable).get_Language(@ptrCast(*const IMsmDependency, self), Language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependency_get_Version(self: *const T, Version: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependency.VTable, self.vtable).get_Version(@ptrCast(*const IMsmDependency, self), Version);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMsmDependency_Value = @import("../zig.zig").Guid.initString("0adda82c-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmDependency = &IID_IEnumMsmDependency_Value;
pub const IEnumMsmDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMsmDependency,
            cFetch: u32,
            rgmsmDependencies: ?*?*IMsmDependency,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMsmDependency,
            cSkip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMsmDependency,
            pemsmDependencies: ?*?*IEnumMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmDependency_Next(self: *const T, cFetch: u32, rgmsmDependencies: ?*?*IMsmDependency, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmDependency.VTable, self.vtable).Next(@ptrCast(*const IEnumMsmDependency, self), cFetch, rgmsmDependencies, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmDependency_Skip(self: *const T, cSkip: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmDependency.VTable, self.vtable).Skip(@ptrCast(*const IEnumMsmDependency, self), cSkip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmDependency_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmDependency.VTable, self.vtable).Reset(@ptrCast(*const IEnumMsmDependency, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmDependency_Clone(self: *const T, pemsmDependencies: ?*?*IEnumMsmDependency) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmDependency.VTable, self.vtable).Clone(@ptrCast(*const IEnumMsmDependency, self), pemsmDependencies);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmDependencies_Value = @import("../zig.zig").Guid.initString("0adda82d-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmDependencies = &IID_IMsmDependencies_Value;
pub const IMsmDependencies = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMsmDependencies,
            Item: i32,
            Return: ?*?*IMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMsmDependencies,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMsmDependencies,
            NewEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependencies_get_Item(self: *const T, Item: i32, Return: ?*?*IMsmDependency) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependencies.VTable, self.vtable).get_Item(@ptrCast(*const IMsmDependencies, self), Item, Return);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependencies_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependencies.VTable, self.vtable).get_Count(@ptrCast(*const IMsmDependencies, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependencies_get__NewEnum(self: *const T, NewEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependencies.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMsmDependencies, self), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmMerge_Value = @import("../zig.zig").Guid.initString("0adda82e-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmMerge = &IID_IMsmMerge_Value;
pub const IMsmMerge = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OpenDatabase: fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenModule: fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
            Language: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDatabase: fn(
            self: *const IMsmMerge,
            Commit: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseModule: fn(
            self: *const IMsmMerge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLog: fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLog: fn(
            self: *const IMsmMerge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Log: fn(
            self: *const IMsmMerge,
            Message: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Errors: fn(
            self: *const IMsmMerge,
            Errors: ?*?*IMsmErrors,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Dependencies: fn(
            self: *const IMsmMerge,
            Dependencies: ?*?*IMsmDependencies,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Merge: fn(
            self: *const IMsmMerge,
            Feature: ?BSTR,
            RedirectDir: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Connect: fn(
            self: *const IMsmMerge,
            Feature: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExtractCAB: fn(
            self: *const IMsmMerge,
            FileName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExtractFiles: fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_OpenDatabase(self: *const T, Path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).OpenDatabase(@ptrCast(*const IMsmMerge, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_OpenModule(self: *const T, Path: ?BSTR, Language: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).OpenModule(@ptrCast(*const IMsmMerge, self), Path, Language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_CloseDatabase(self: *const T, Commit: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).CloseDatabase(@ptrCast(*const IMsmMerge, self), Commit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_CloseModule(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).CloseModule(@ptrCast(*const IMsmMerge, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_OpenLog(self: *const T, Path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).OpenLog(@ptrCast(*const IMsmMerge, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_CloseLog(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).CloseLog(@ptrCast(*const IMsmMerge, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_Log(self: *const T, Message: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).Log(@ptrCast(*const IMsmMerge, self), Message);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_get_Errors(self: *const T, Errors: ?*?*IMsmErrors) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).get_Errors(@ptrCast(*const IMsmMerge, self), Errors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_get_Dependencies(self: *const T, Dependencies: ?*?*IMsmDependencies) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).get_Dependencies(@ptrCast(*const IMsmMerge, self), Dependencies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_Merge(self: *const T, Feature: ?BSTR, RedirectDir: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).Merge(@ptrCast(*const IMsmMerge, self), Feature, RedirectDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_Connect(self: *const T, Feature: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).Connect(@ptrCast(*const IMsmMerge, self), Feature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_ExtractCAB(self: *const T, FileName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).ExtractCAB(@ptrCast(*const IMsmMerge, self), FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_ExtractFiles(self: *const T, Path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).ExtractFiles(@ptrCast(*const IMsmMerge, self), Path);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmGetFiles_Value = @import("../zig.zig").Guid.initString("7041ae26-2d78-11d2-888a-00a0c981b015");
pub const IID_IMsmGetFiles = &IID_IMsmGetFiles_Value;
pub const IMsmGetFiles = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleFiles: fn(
            self: *const IMsmGetFiles,
            Files: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmGetFiles_get_ModuleFiles(self: *const T, Files: ?*?*IMsmStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmGetFiles.VTable, self.vtable).get_ModuleFiles(@ptrCast(*const IMsmGetFiles, self), Files);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PMSIHANDLE = extern struct {
    m_h: MSIHANDLE,
};

pub const INSTALLMESSAGE = enum(i32) {
    FATALEXIT = 0,
    ERROR = 16777216,
    WARNING = 33554432,
    USER = 50331648,
    INFO = 67108864,
    FILESINUSE = 83886080,
    RESOLVESOURCE = 100663296,
    OUTOFDISKSPACE = 117440512,
    ACTIONSTART = 134217728,
    ACTIONDATA = 150994944,
    PROGRESS = 167772160,
    COMMONDATA = 184549376,
    INITIALIZE = 201326592,
    TERMINATE = 218103808,
    SHOWDIALOG = 234881024,
    PERFORMANCE = 251658240,
    RMFILESINUSE = 419430400,
    INSTALLSTART = 436207616,
    INSTALLEND = 452984832,
};
pub const INSTALLMESSAGE_FATALEXIT = INSTALLMESSAGE.FATALEXIT;
pub const INSTALLMESSAGE_ERROR = INSTALLMESSAGE.ERROR;
pub const INSTALLMESSAGE_WARNING = INSTALLMESSAGE.WARNING;
pub const INSTALLMESSAGE_USER = INSTALLMESSAGE.USER;
pub const INSTALLMESSAGE_INFO = INSTALLMESSAGE.INFO;
pub const INSTALLMESSAGE_FILESINUSE = INSTALLMESSAGE.FILESINUSE;
pub const INSTALLMESSAGE_RESOLVESOURCE = INSTALLMESSAGE.RESOLVESOURCE;
pub const INSTALLMESSAGE_OUTOFDISKSPACE = INSTALLMESSAGE.OUTOFDISKSPACE;
pub const INSTALLMESSAGE_ACTIONSTART = INSTALLMESSAGE.ACTIONSTART;
pub const INSTALLMESSAGE_ACTIONDATA = INSTALLMESSAGE.ACTIONDATA;
pub const INSTALLMESSAGE_PROGRESS = INSTALLMESSAGE.PROGRESS;
pub const INSTALLMESSAGE_COMMONDATA = INSTALLMESSAGE.COMMONDATA;
pub const INSTALLMESSAGE_INITIALIZE = INSTALLMESSAGE.INITIALIZE;
pub const INSTALLMESSAGE_TERMINATE = INSTALLMESSAGE.TERMINATE;
pub const INSTALLMESSAGE_SHOWDIALOG = INSTALLMESSAGE.SHOWDIALOG;
pub const INSTALLMESSAGE_PERFORMANCE = INSTALLMESSAGE.PERFORMANCE;
pub const INSTALLMESSAGE_RMFILESINUSE = INSTALLMESSAGE.RMFILESINUSE;
pub const INSTALLMESSAGE_INSTALLSTART = INSTALLMESSAGE.INSTALLSTART;
pub const INSTALLMESSAGE_INSTALLEND = INSTALLMESSAGE.INSTALLEND;

pub const INSTALLUI_HANDLERA = fn(
    pvContext: ?*anyopaque,
    iMessageType: u32,
    szMessage: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INSTALLUI_HANDLERW = fn(
    pvContext: ?*anyopaque,
    iMessageType: u32,
    szMessage: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PINSTALLUI_HANDLER_RECORD = fn(
    pvContext: ?*anyopaque,
    iMessageType: u32,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INSTALLUILEVEL = enum(i32) {
    NOCHANGE = 0,
    DEFAULT = 1,
    NONE = 2,
    BASIC = 3,
    REDUCED = 4,
    FULL = 5,
    ENDDIALOG = 128,
    PROGRESSONLY = 64,
    HIDECANCEL = 32,
    SOURCERESONLY = 256,
    UACONLY = 512,
};
pub const INSTALLUILEVEL_NOCHANGE = INSTALLUILEVEL.NOCHANGE;
pub const INSTALLUILEVEL_DEFAULT = INSTALLUILEVEL.DEFAULT;
pub const INSTALLUILEVEL_NONE = INSTALLUILEVEL.NONE;
pub const INSTALLUILEVEL_BASIC = INSTALLUILEVEL.BASIC;
pub const INSTALLUILEVEL_REDUCED = INSTALLUILEVEL.REDUCED;
pub const INSTALLUILEVEL_FULL = INSTALLUILEVEL.FULL;
pub const INSTALLUILEVEL_ENDDIALOG = INSTALLUILEVEL.ENDDIALOG;
pub const INSTALLUILEVEL_PROGRESSONLY = INSTALLUILEVEL.PROGRESSONLY;
pub const INSTALLUILEVEL_HIDECANCEL = INSTALLUILEVEL.HIDECANCEL;
pub const INSTALLUILEVEL_SOURCERESONLY = INSTALLUILEVEL.SOURCERESONLY;
pub const INSTALLUILEVEL_UACONLY = INSTALLUILEVEL.UACONLY;

pub const INSTALLSTATE = enum(i32) {
    NOTUSED = -7,
    BADCONFIG = -6,
    INCOMPLETE = -5,
    SOURCEABSENT = -4,
    MOREDATA = -3,
    INVALIDARG = -2,
    UNKNOWN = -1,
    BROKEN = 0,
    ADVERTISED = 1,
    // REMOVED = 1, this enum value conflicts with ADVERTISED
    ABSENT = 2,
    LOCAL = 3,
    SOURCE = 4,
    DEFAULT = 5,
};
pub const INSTALLSTATE_NOTUSED = INSTALLSTATE.NOTUSED;
pub const INSTALLSTATE_BADCONFIG = INSTALLSTATE.BADCONFIG;
pub const INSTALLSTATE_INCOMPLETE = INSTALLSTATE.INCOMPLETE;
pub const INSTALLSTATE_SOURCEABSENT = INSTALLSTATE.SOURCEABSENT;
pub const INSTALLSTATE_MOREDATA = INSTALLSTATE.MOREDATA;
pub const INSTALLSTATE_INVALIDARG = INSTALLSTATE.INVALIDARG;
pub const INSTALLSTATE_UNKNOWN = INSTALLSTATE.UNKNOWN;
pub const INSTALLSTATE_BROKEN = INSTALLSTATE.BROKEN;
pub const INSTALLSTATE_ADVERTISED = INSTALLSTATE.ADVERTISED;
pub const INSTALLSTATE_REMOVED = INSTALLSTATE.ADVERTISED;
pub const INSTALLSTATE_ABSENT = INSTALLSTATE.ABSENT;
pub const INSTALLSTATE_LOCAL = INSTALLSTATE.LOCAL;
pub const INSTALLSTATE_SOURCE = INSTALLSTATE.SOURCE;
pub const INSTALLSTATE_DEFAULT = INSTALLSTATE.DEFAULT;

pub const USERINFOSTATE = enum(i32) {
    MOREDATA = -3,
    INVALIDARG = -2,
    UNKNOWN = -1,
    ABSENT = 0,
    PRESENT = 1,
};
pub const USERINFOSTATE_MOREDATA = USERINFOSTATE.MOREDATA;
pub const USERINFOSTATE_INVALIDARG = USERINFOSTATE.INVALIDARG;
pub const USERINFOSTATE_UNKNOWN = USERINFOSTATE.UNKNOWN;
pub const USERINFOSTATE_ABSENT = USERINFOSTATE.ABSENT;
pub const USERINFOSTATE_PRESENT = USERINFOSTATE.PRESENT;

pub const INSTALLLEVEL = enum(i32) {
    DEFAULT = 0,
    MINIMUM = 1,
    MAXIMUM = 65535,
};
pub const INSTALLLEVEL_DEFAULT = INSTALLLEVEL.DEFAULT;
pub const INSTALLLEVEL_MINIMUM = INSTALLLEVEL.MINIMUM;
pub const INSTALLLEVEL_MAXIMUM = INSTALLLEVEL.MAXIMUM;

pub const REINSTALLMODE = enum(i32) {
    REPAIR = 1,
    FILEMISSING = 2,
    FILEOLDERVERSION = 4,
    FILEEQUALVERSION = 8,
    FILEEXACT = 16,
    FILEVERIFY = 32,
    FILEREPLACE = 64,
    MACHINEDATA = 128,
    USERDATA = 256,
    SHORTCUT = 512,
    PACKAGE = 1024,
};
pub const REINSTALLMODE_REPAIR = REINSTALLMODE.REPAIR;
pub const REINSTALLMODE_FILEMISSING = REINSTALLMODE.FILEMISSING;
pub const REINSTALLMODE_FILEOLDERVERSION = REINSTALLMODE.FILEOLDERVERSION;
pub const REINSTALLMODE_FILEEQUALVERSION = REINSTALLMODE.FILEEQUALVERSION;
pub const REINSTALLMODE_FILEEXACT = REINSTALLMODE.FILEEXACT;
pub const REINSTALLMODE_FILEVERIFY = REINSTALLMODE.FILEVERIFY;
pub const REINSTALLMODE_FILEREPLACE = REINSTALLMODE.FILEREPLACE;
pub const REINSTALLMODE_MACHINEDATA = REINSTALLMODE.MACHINEDATA;
pub const REINSTALLMODE_USERDATA = REINSTALLMODE.USERDATA;
pub const REINSTALLMODE_SHORTCUT = REINSTALLMODE.SHORTCUT;
pub const REINSTALLMODE_PACKAGE = REINSTALLMODE.PACKAGE;

pub const INSTALLOGMODE = enum(i32) {
    FATALEXIT = 1,
    ERROR = 2,
    WARNING = 4,
    USER = 8,
    INFO = 16,
    RESOLVESOURCE = 64,
    OUTOFDISKSPACE = 128,
    ACTIONSTART = 256,
    ACTIONDATA = 512,
    COMMONDATA = 2048,
    PROPERTYDUMP = 1024,
    VERBOSE = 4096,
    EXTRADEBUG = 8192,
    LOGONLYONERROR = 16384,
    LOGPERFORMANCE = 32768,
    // PROGRESS = 1024, this enum value conflicts with PROPERTYDUMP
    // INITIALIZE = 4096, this enum value conflicts with VERBOSE
    // TERMINATE = 8192, this enum value conflicts with EXTRADEBUG
    // SHOWDIALOG = 16384, this enum value conflicts with LOGONLYONERROR
    FILESINUSE = 32,
    RMFILESINUSE = 33554432,
    INSTALLSTART = 67108864,
    INSTALLEND = 134217728,
};
pub const INSTALLLOGMODE_FATALEXIT = INSTALLOGMODE.FATALEXIT;
pub const INSTALLLOGMODE_ERROR = INSTALLOGMODE.ERROR;
pub const INSTALLLOGMODE_WARNING = INSTALLOGMODE.WARNING;
pub const INSTALLLOGMODE_USER = INSTALLOGMODE.USER;
pub const INSTALLLOGMODE_INFO = INSTALLOGMODE.INFO;
pub const INSTALLLOGMODE_RESOLVESOURCE = INSTALLOGMODE.RESOLVESOURCE;
pub const INSTALLLOGMODE_OUTOFDISKSPACE = INSTALLOGMODE.OUTOFDISKSPACE;
pub const INSTALLLOGMODE_ACTIONSTART = INSTALLOGMODE.ACTIONSTART;
pub const INSTALLLOGMODE_ACTIONDATA = INSTALLOGMODE.ACTIONDATA;
pub const INSTALLLOGMODE_COMMONDATA = INSTALLOGMODE.COMMONDATA;
pub const INSTALLLOGMODE_PROPERTYDUMP = INSTALLOGMODE.PROPERTYDUMP;
pub const INSTALLLOGMODE_VERBOSE = INSTALLOGMODE.VERBOSE;
pub const INSTALLLOGMODE_EXTRADEBUG = INSTALLOGMODE.EXTRADEBUG;
pub const INSTALLLOGMODE_LOGONLYONERROR = INSTALLOGMODE.LOGONLYONERROR;
pub const INSTALLLOGMODE_LOGPERFORMANCE = INSTALLOGMODE.LOGPERFORMANCE;
pub const INSTALLLOGMODE_PROGRESS = INSTALLOGMODE.PROPERTYDUMP;
pub const INSTALLLOGMODE_INITIALIZE = INSTALLOGMODE.VERBOSE;
pub const INSTALLLOGMODE_TERMINATE = INSTALLOGMODE.EXTRADEBUG;
pub const INSTALLLOGMODE_SHOWDIALOG = INSTALLOGMODE.LOGONLYONERROR;
pub const INSTALLLOGMODE_FILESINUSE = INSTALLOGMODE.FILESINUSE;
pub const INSTALLLOGMODE_RMFILESINUSE = INSTALLOGMODE.RMFILESINUSE;
pub const INSTALLLOGMODE_INSTALLSTART = INSTALLOGMODE.INSTALLSTART;
pub const INSTALLLOGMODE_INSTALLEND = INSTALLOGMODE.INSTALLEND;

pub const INSTALLLOGATTRIBUTES = enum(i32) {
    APPEND = 1,
    FLUSHEACHLINE = 2,
};
pub const INSTALLLOGATTRIBUTES_APPEND = INSTALLLOGATTRIBUTES.APPEND;
pub const INSTALLLOGATTRIBUTES_FLUSHEACHLINE = INSTALLLOGATTRIBUTES.FLUSHEACHLINE;

pub const INSTALLFEATUREATTRIBUTE = enum(i32) {
    FAVORLOCAL = 1,
    FAVORSOURCE = 2,
    FOLLOWPARENT = 4,
    FAVORADVERTISE = 8,
    DISALLOWADVERTISE = 16,
    NOUNSUPPORTEDADVERTISE = 32,
};
pub const INSTALLFEATUREATTRIBUTE_FAVORLOCAL = INSTALLFEATUREATTRIBUTE.FAVORLOCAL;
pub const INSTALLFEATUREATTRIBUTE_FAVORSOURCE = INSTALLFEATUREATTRIBUTE.FAVORSOURCE;
pub const INSTALLFEATUREATTRIBUTE_FOLLOWPARENT = INSTALLFEATUREATTRIBUTE.FOLLOWPARENT;
pub const INSTALLFEATUREATTRIBUTE_FAVORADVERTISE = INSTALLFEATUREATTRIBUTE.FAVORADVERTISE;
pub const INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE = INSTALLFEATUREATTRIBUTE.DISALLOWADVERTISE;
pub const INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE = INSTALLFEATUREATTRIBUTE.NOUNSUPPORTEDADVERTISE;

pub const INSTALLMODE = enum(i32) {
    NODETECTION_ANY = -4,
    NOSOURCERESOLUTION = -3,
    NODETECTION = -2,
    EXISTING = -1,
    DEFAULT = 0,
};
pub const INSTALLMODE_NODETECTION_ANY = INSTALLMODE.NODETECTION_ANY;
pub const INSTALLMODE_NOSOURCERESOLUTION = INSTALLMODE.NOSOURCERESOLUTION;
pub const INSTALLMODE_NODETECTION = INSTALLMODE.NODETECTION;
pub const INSTALLMODE_EXISTING = INSTALLMODE.EXISTING;
pub const INSTALLMODE_DEFAULT = INSTALLMODE.DEFAULT;

pub const MSIPATCHSTATE = enum(i32) {
    INVALID = 0,
    APPLIED = 1,
    SUPERSEDED = 2,
    OBSOLETED = 4,
    REGISTERED = 8,
    ALL = 15,
};
pub const MSIPATCHSTATE_INVALID = MSIPATCHSTATE.INVALID;
pub const MSIPATCHSTATE_APPLIED = MSIPATCHSTATE.APPLIED;
pub const MSIPATCHSTATE_SUPERSEDED = MSIPATCHSTATE.SUPERSEDED;
pub const MSIPATCHSTATE_OBSOLETED = MSIPATCHSTATE.OBSOLETED;
pub const MSIPATCHSTATE_REGISTERED = MSIPATCHSTATE.REGISTERED;
pub const MSIPATCHSTATE_ALL = MSIPATCHSTATE.ALL;

pub const MSIINSTALLCONTEXT = enum(i32) {
    FIRSTVISIBLE = 0,
    // NONE = 0, this enum value conflicts with FIRSTVISIBLE
    USERMANAGED = 1,
    USERUNMANAGED = 2,
    MACHINE = 4,
    ALL = 7,
    ALLUSERMANAGED = 8,
};
pub const MSIINSTALLCONTEXT_FIRSTVISIBLE = MSIINSTALLCONTEXT.FIRSTVISIBLE;
pub const MSIINSTALLCONTEXT_NONE = MSIINSTALLCONTEXT.FIRSTVISIBLE;
pub const MSIINSTALLCONTEXT_USERMANAGED = MSIINSTALLCONTEXT.USERMANAGED;
pub const MSIINSTALLCONTEXT_USERUNMANAGED = MSIINSTALLCONTEXT.USERUNMANAGED;
pub const MSIINSTALLCONTEXT_MACHINE = MSIINSTALLCONTEXT.MACHINE;
pub const MSIINSTALLCONTEXT_ALL = MSIINSTALLCONTEXT.ALL;
pub const MSIINSTALLCONTEXT_ALLUSERMANAGED = MSIINSTALLCONTEXT.ALLUSERMANAGED;

pub const MSIPATCHDATATYPE = enum(i32) {
    PATCHFILE = 0,
    XMLPATH = 1,
    XMLBLOB = 2,
};
pub const MSIPATCH_DATATYPE_PATCHFILE = MSIPATCHDATATYPE.PATCHFILE;
pub const MSIPATCH_DATATYPE_XMLPATH = MSIPATCHDATATYPE.XMLPATH;
pub const MSIPATCH_DATATYPE_XMLBLOB = MSIPATCHDATATYPE.XMLBLOB;

pub const MSIPATCHSEQUENCEINFOA = extern struct {
    szPatchData: ?[*:0]const u8,
    ePatchDataType: MSIPATCHDATATYPE,
    dwOrder: u32,
    uStatus: u32,
};

pub const MSIPATCHSEQUENCEINFOW = extern struct {
    szPatchData: ?[*:0]const u16,
    ePatchDataType: MSIPATCHDATATYPE,
    dwOrder: u32,
    uStatus: u32,
};

pub const SCRIPTFLAGS = enum(i32) {
    CACHEINFO = 1,
    SHORTCUTS = 4,
    MACHINEASSIGN = 8,
    REGDATA_CNFGINFO = 32,
    VALIDATE_TRANSFORMS_LIST = 64,
    REGDATA_CLASSINFO = 128,
    REGDATA_EXTENSIONINFO = 256,
    REGDATA_APPINFO = 384,
    REGDATA = 416,
};
pub const SCRIPTFLAGS_CACHEINFO = SCRIPTFLAGS.CACHEINFO;
pub const SCRIPTFLAGS_SHORTCUTS = SCRIPTFLAGS.SHORTCUTS;
pub const SCRIPTFLAGS_MACHINEASSIGN = SCRIPTFLAGS.MACHINEASSIGN;
pub const SCRIPTFLAGS_REGDATA_CNFGINFO = SCRIPTFLAGS.REGDATA_CNFGINFO;
pub const SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST = SCRIPTFLAGS.VALIDATE_TRANSFORMS_LIST;
pub const SCRIPTFLAGS_REGDATA_CLASSINFO = SCRIPTFLAGS.REGDATA_CLASSINFO;
pub const SCRIPTFLAGS_REGDATA_EXTENSIONINFO = SCRIPTFLAGS.REGDATA_EXTENSIONINFO;
pub const SCRIPTFLAGS_REGDATA_APPINFO = SCRIPTFLAGS.REGDATA_APPINFO;
pub const SCRIPTFLAGS_REGDATA = SCRIPTFLAGS.REGDATA;

pub const ADVERTISEFLAGS = enum(i32) {
    MACHINEASSIGN = 0,
    USERASSIGN = 1,
};
pub const ADVERTISEFLAGS_MACHINEASSIGN = ADVERTISEFLAGS.MACHINEASSIGN;
pub const ADVERTISEFLAGS_USERASSIGN = ADVERTISEFLAGS.USERASSIGN;

pub const INSTALLTYPE = enum(i32) {
    DEFAULT = 0,
    NETWORK_IMAGE = 1,
    SINGLE_INSTANCE = 2,
};
pub const INSTALLTYPE_DEFAULT = INSTALLTYPE.DEFAULT;
pub const INSTALLTYPE_NETWORK_IMAGE = INSTALLTYPE.NETWORK_IMAGE;
pub const INSTALLTYPE_SINGLE_INSTANCE = INSTALLTYPE.SINGLE_INSTANCE;

pub const MSIFILEHASHINFO = extern struct {
    dwFileHashInfoSize: u32,
    dwData: [4]u32,
};

pub const MSIARCHITECTUREFLAGS = enum(i32) {
    X86 = 1,
    IA64 = 2,
    AMD64 = 4,
    ARM = 8,
};
pub const MSIARCHITECTUREFLAGS_X86 = MSIARCHITECTUREFLAGS.X86;
pub const MSIARCHITECTUREFLAGS_IA64 = MSIARCHITECTUREFLAGS.IA64;
pub const MSIARCHITECTUREFLAGS_AMD64 = MSIARCHITECTUREFLAGS.AMD64;
pub const MSIARCHITECTUREFLAGS_ARM = MSIARCHITECTUREFLAGS.ARM;

pub const MSIOPENPACKAGEFLAGS = enum(i32) {
    E = 1,
};
pub const MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE = MSIOPENPACKAGEFLAGS.E;

pub const MSIADVERTISEOPTIONFLAGS = enum(i32) {
    E = 1,
};
pub const MSIADVERTISEOPTIONFLAGS_INSTANCE = MSIADVERTISEOPTIONFLAGS.E;

pub const MSISOURCETYPE = enum(i32) {
    UNKNOWN = 0,
    NETWORK = 1,
    URL = 2,
    MEDIA = 4,
};
pub const MSISOURCETYPE_UNKNOWN = MSISOURCETYPE.UNKNOWN;
pub const MSISOURCETYPE_NETWORK = MSISOURCETYPE.NETWORK;
pub const MSISOURCETYPE_URL = MSISOURCETYPE.URL;
pub const MSISOURCETYPE_MEDIA = MSISOURCETYPE.MEDIA;

pub const MSICODE = enum(i32) {
    RODUCT = 0,
    ATCH = 1073741824,
};
pub const MSICODE_PRODUCT = MSICODE.RODUCT;
pub const MSICODE_PATCH = MSICODE.ATCH;

pub const MSITRANSACTION = enum(i32) {
    CHAIN_EMBEDDEDUI = 1,
    JOIN_EXISTING_EMBEDDEDUI = 2,
};
pub const MSITRANSACTION_CHAIN_EMBEDDEDUI = MSITRANSACTION.CHAIN_EMBEDDEDUI;
pub const MSITRANSACTION_JOIN_EXISTING_EMBEDDEDUI = MSITRANSACTION.JOIN_EXISTING_EMBEDDEDUI;

pub const MSITRANSACTIONSTATE = enum(u32) {
    ROLLBACK = 0,
    COMMIT = 1,
};
pub const MSITRANSACTIONSTATE_ROLLBACK = MSITRANSACTIONSTATE.ROLLBACK;
pub const MSITRANSACTIONSTATE_COMMIT = MSITRANSACTIONSTATE.COMMIT;

pub const MSIDBSTATE = enum(i32) {
    ERROR = -1,
    READ = 0,
    WRITE = 1,
};
pub const MSIDBSTATE_ERROR = MSIDBSTATE.ERROR;
pub const MSIDBSTATE_READ = MSIDBSTATE.READ;
pub const MSIDBSTATE_WRITE = MSIDBSTATE.WRITE;

pub const MSIMODIFY = enum(i32) {
    SEEK = -1,
    REFRESH = 0,
    INSERT = 1,
    UPDATE = 2,
    ASSIGN = 3,
    REPLACE = 4,
    MERGE = 5,
    DELETE = 6,
    INSERT_TEMPORARY = 7,
    VALIDATE = 8,
    VALIDATE_NEW = 9,
    VALIDATE_FIELD = 10,
    VALIDATE_DELETE = 11,
};
pub const MSIMODIFY_SEEK = MSIMODIFY.SEEK;
pub const MSIMODIFY_REFRESH = MSIMODIFY.REFRESH;
pub const MSIMODIFY_INSERT = MSIMODIFY.INSERT;
pub const MSIMODIFY_UPDATE = MSIMODIFY.UPDATE;
pub const MSIMODIFY_ASSIGN = MSIMODIFY.ASSIGN;
pub const MSIMODIFY_REPLACE = MSIMODIFY.REPLACE;
pub const MSIMODIFY_MERGE = MSIMODIFY.MERGE;
pub const MSIMODIFY_DELETE = MSIMODIFY.DELETE;
pub const MSIMODIFY_INSERT_TEMPORARY = MSIMODIFY.INSERT_TEMPORARY;
pub const MSIMODIFY_VALIDATE = MSIMODIFY.VALIDATE;
pub const MSIMODIFY_VALIDATE_NEW = MSIMODIFY.VALIDATE_NEW;
pub const MSIMODIFY_VALIDATE_FIELD = MSIMODIFY.VALIDATE_FIELD;
pub const MSIMODIFY_VALIDATE_DELETE = MSIMODIFY.VALIDATE_DELETE;

pub const MSICOLINFO = enum(i32) {
    NAMES = 0,
    TYPES = 1,
};
pub const MSICOLINFO_NAMES = MSICOLINFO.NAMES;
pub const MSICOLINFO_TYPES = MSICOLINFO.TYPES;

pub const MSICONDITION = enum(i32) {
    FALSE = 0,
    TRUE = 1,
    NONE = 2,
    ERROR = 3,
};
pub const MSICONDITION_FALSE = MSICONDITION.FALSE;
pub const MSICONDITION_TRUE = MSICONDITION.TRUE;
pub const MSICONDITION_NONE = MSICONDITION.NONE;
pub const MSICONDITION_ERROR = MSICONDITION.ERROR;

pub const MSICOSTTREE = enum(i32) {
    SELFONLY = 0,
    CHILDREN = 1,
    PARENTS = 2,
    RESERVED = 3,
};
pub const MSICOSTTREE_SELFONLY = MSICOSTTREE.SELFONLY;
pub const MSICOSTTREE_CHILDREN = MSICOSTTREE.CHILDREN;
pub const MSICOSTTREE_PARENTS = MSICOSTTREE.PARENTS;
pub const MSICOSTTREE_RESERVED = MSICOSTTREE.RESERVED;

pub const MSIDBERROR = enum(i32) {
    INVALIDARG = -3,
    MOREDATA = -2,
    FUNCTIONERROR = -1,
    NOERROR = 0,
    DUPLICATEKEY = 1,
    REQUIRED = 2,
    BADLINK = 3,
    OVERFLOW = 4,
    UNDERFLOW = 5,
    NOTINSET = 6,
    BADVERSION = 7,
    BADCASE = 8,
    BADGUID = 9,
    BADWILDCARD = 10,
    BADIDENTIFIER = 11,
    BADLANGUAGE = 12,
    BADFILENAME = 13,
    BADPATH = 14,
    BADCONDITION = 15,
    BADFORMATTED = 16,
    BADTEMPLATE = 17,
    BADDEFAULTDIR = 18,
    BADREGPATH = 19,
    BADCUSTOMSOURCE = 20,
    BADPROPERTY = 21,
    MISSINGDATA = 22,
    BADCATEGORY = 23,
    BADKEYTABLE = 24,
    BADMAXMINVALUES = 25,
    BADCABINET = 26,
    BADSHORTCUT = 27,
    STRINGOVERFLOW = 28,
    BADLOCALIZEATTRIB = 29,
};
pub const MSIDBERROR_INVALIDARG = MSIDBERROR.INVALIDARG;
pub const MSIDBERROR_MOREDATA = MSIDBERROR.MOREDATA;
pub const MSIDBERROR_FUNCTIONERROR = MSIDBERROR.FUNCTIONERROR;
pub const MSIDBERROR_NOERROR = MSIDBERROR.NOERROR;
pub const MSIDBERROR_DUPLICATEKEY = MSIDBERROR.DUPLICATEKEY;
pub const MSIDBERROR_REQUIRED = MSIDBERROR.REQUIRED;
pub const MSIDBERROR_BADLINK = MSIDBERROR.BADLINK;
pub const MSIDBERROR_OVERFLOW = MSIDBERROR.OVERFLOW;
pub const MSIDBERROR_UNDERFLOW = MSIDBERROR.UNDERFLOW;
pub const MSIDBERROR_NOTINSET = MSIDBERROR.NOTINSET;
pub const MSIDBERROR_BADVERSION = MSIDBERROR.BADVERSION;
pub const MSIDBERROR_BADCASE = MSIDBERROR.BADCASE;
pub const MSIDBERROR_BADGUID = MSIDBERROR.BADGUID;
pub const MSIDBERROR_BADWILDCARD = MSIDBERROR.BADWILDCARD;
pub const MSIDBERROR_BADIDENTIFIER = MSIDBERROR.BADIDENTIFIER;
pub const MSIDBERROR_BADLANGUAGE = MSIDBERROR.BADLANGUAGE;
pub const MSIDBERROR_BADFILENAME = MSIDBERROR.BADFILENAME;
pub const MSIDBERROR_BADPATH = MSIDBERROR.BADPATH;
pub const MSIDBERROR_BADCONDITION = MSIDBERROR.BADCONDITION;
pub const MSIDBERROR_BADFORMATTED = MSIDBERROR.BADFORMATTED;
pub const MSIDBERROR_BADTEMPLATE = MSIDBERROR.BADTEMPLATE;
pub const MSIDBERROR_BADDEFAULTDIR = MSIDBERROR.BADDEFAULTDIR;
pub const MSIDBERROR_BADREGPATH = MSIDBERROR.BADREGPATH;
pub const MSIDBERROR_BADCUSTOMSOURCE = MSIDBERROR.BADCUSTOMSOURCE;
pub const MSIDBERROR_BADPROPERTY = MSIDBERROR.BADPROPERTY;
pub const MSIDBERROR_MISSINGDATA = MSIDBERROR.MISSINGDATA;
pub const MSIDBERROR_BADCATEGORY = MSIDBERROR.BADCATEGORY;
pub const MSIDBERROR_BADKEYTABLE = MSIDBERROR.BADKEYTABLE;
pub const MSIDBERROR_BADMAXMINVALUES = MSIDBERROR.BADMAXMINVALUES;
pub const MSIDBERROR_BADCABINET = MSIDBERROR.BADCABINET;
pub const MSIDBERROR_BADSHORTCUT = MSIDBERROR.BADSHORTCUT;
pub const MSIDBERROR_STRINGOVERFLOW = MSIDBERROR.STRINGOVERFLOW;
pub const MSIDBERROR_BADLOCALIZEATTRIB = MSIDBERROR.BADLOCALIZEATTRIB;

pub const MSIRUNMODE = enum(i32) {
    ADMIN = 0,
    ADVERTISE = 1,
    MAINTENANCE = 2,
    ROLLBACKENABLED = 3,
    LOGENABLED = 4,
    OPERATIONS = 5,
    REBOOTATEND = 6,
    REBOOTNOW = 7,
    CABINET = 8,
    SOURCESHORTNAMES = 9,
    TARGETSHORTNAMES = 10,
    RESERVED11 = 11,
    WINDOWS9X = 12,
    ZAWENABLED = 13,
    RESERVED14 = 14,
    RESERVED15 = 15,
    SCHEDULED = 16,
    ROLLBACK = 17,
    COMMIT = 18,
};
pub const MSIRUNMODE_ADMIN = MSIRUNMODE.ADMIN;
pub const MSIRUNMODE_ADVERTISE = MSIRUNMODE.ADVERTISE;
pub const MSIRUNMODE_MAINTENANCE = MSIRUNMODE.MAINTENANCE;
pub const MSIRUNMODE_ROLLBACKENABLED = MSIRUNMODE.ROLLBACKENABLED;
pub const MSIRUNMODE_LOGENABLED = MSIRUNMODE.LOGENABLED;
pub const MSIRUNMODE_OPERATIONS = MSIRUNMODE.OPERATIONS;
pub const MSIRUNMODE_REBOOTATEND = MSIRUNMODE.REBOOTATEND;
pub const MSIRUNMODE_REBOOTNOW = MSIRUNMODE.REBOOTNOW;
pub const MSIRUNMODE_CABINET = MSIRUNMODE.CABINET;
pub const MSIRUNMODE_SOURCESHORTNAMES = MSIRUNMODE.SOURCESHORTNAMES;
pub const MSIRUNMODE_TARGETSHORTNAMES = MSIRUNMODE.TARGETSHORTNAMES;
pub const MSIRUNMODE_RESERVED11 = MSIRUNMODE.RESERVED11;
pub const MSIRUNMODE_WINDOWS9X = MSIRUNMODE.WINDOWS9X;
pub const MSIRUNMODE_ZAWENABLED = MSIRUNMODE.ZAWENABLED;
pub const MSIRUNMODE_RESERVED14 = MSIRUNMODE.RESERVED14;
pub const MSIRUNMODE_RESERVED15 = MSIRUNMODE.RESERVED15;
pub const MSIRUNMODE_SCHEDULED = MSIRUNMODE.SCHEDULED;
pub const MSIRUNMODE_ROLLBACK = MSIRUNMODE.ROLLBACK;
pub const MSIRUNMODE_COMMIT = MSIRUNMODE.COMMIT;

pub const MSITRANSFORM_ERROR = enum(i32) {
    ADDEXISTINGROW = 1,
    DELMISSINGROW = 2,
    ADDEXISTINGTABLE = 4,
    DELMISSINGTABLE = 8,
    UPDATEMISSINGROW = 16,
    CHANGECODEPAGE = 32,
    VIEWTRANSFORM = 256,
    NONE = 0,
};
pub const MSITRANSFORM_ERROR_ADDEXISTINGROW = MSITRANSFORM_ERROR.ADDEXISTINGROW;
pub const MSITRANSFORM_ERROR_DELMISSINGROW = MSITRANSFORM_ERROR.DELMISSINGROW;
pub const MSITRANSFORM_ERROR_ADDEXISTINGTABLE = MSITRANSFORM_ERROR.ADDEXISTINGTABLE;
pub const MSITRANSFORM_ERROR_DELMISSINGTABLE = MSITRANSFORM_ERROR.DELMISSINGTABLE;
pub const MSITRANSFORM_ERROR_UPDATEMISSINGROW = MSITRANSFORM_ERROR.UPDATEMISSINGROW;
pub const MSITRANSFORM_ERROR_CHANGECODEPAGE = MSITRANSFORM_ERROR.CHANGECODEPAGE;
pub const MSITRANSFORM_ERROR_VIEWTRANSFORM = MSITRANSFORM_ERROR.VIEWTRANSFORM;
pub const MSITRANSFORM_ERROR_NONE = MSITRANSFORM_ERROR.NONE;

pub const MSITRANSFORM_VALIDATE = enum(i32) {
    LANGUAGE = 1,
    PRODUCT = 2,
    PLATFORM = 4,
    MAJORVERSION = 8,
    MINORVERSION = 16,
    UPDATEVERSION = 32,
    NEWLESSBASEVERSION = 64,
    NEWLESSEQUALBASEVERSION = 128,
    NEWEQUALBASEVERSION = 256,
    NEWGREATEREQUALBASEVERSION = 512,
    NEWGREATERBASEVERSION = 1024,
    UPGRADECODE = 2048,
};
pub const MSITRANSFORM_VALIDATE_LANGUAGE = MSITRANSFORM_VALIDATE.LANGUAGE;
pub const MSITRANSFORM_VALIDATE_PRODUCT = MSITRANSFORM_VALIDATE.PRODUCT;
pub const MSITRANSFORM_VALIDATE_PLATFORM = MSITRANSFORM_VALIDATE.PLATFORM;
pub const MSITRANSFORM_VALIDATE_MAJORVERSION = MSITRANSFORM_VALIDATE.MAJORVERSION;
pub const MSITRANSFORM_VALIDATE_MINORVERSION = MSITRANSFORM_VALIDATE.MINORVERSION;
pub const MSITRANSFORM_VALIDATE_UPDATEVERSION = MSITRANSFORM_VALIDATE.UPDATEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION = MSITRANSFORM_VALIDATE.NEWLESSBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWLESSEQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWEQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWGREATEREQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION = MSITRANSFORM_VALIDATE.NEWGREATERBASEVERSION;
pub const MSITRANSFORM_VALIDATE_UPGRADECODE = MSITRANSFORM_VALIDATE.UPGRADECODE;

pub const ASSEMBLY_INFO = extern struct {
    cbAssemblyInfo: u32,
    dwAssemblyFlags: u32,
    uliAssemblySizeInKB: ULARGE_INTEGER,
    pszCurrentAssemblyPathBuf: ?PWSTR,
    cchBuf: u32,
};

pub const FUSION_INSTALL_REFERENCE = extern struct {
    cbSize: u32,
    dwFlags: u32,
    guidScheme: Guid,
    szIdentifier: ?[*:0]const u16,
    szNonCannonicalData: ?[*:0]const u16,
};

pub const ASM_NAME = enum(i32) {
    PUBLIC_KEY = 0,
    PUBLIC_KEY_TOKEN = 1,
    HASH_VALUE = 2,
    NAME = 3,
    MAJOR_VERSION = 4,
    MINOR_VERSION = 5,
    BUILD_NUMBER = 6,
    REVISION_NUMBER = 7,
    CULTURE = 8,
    PROCESSOR_ID_ARRAY = 9,
    OSINFO_ARRAY = 10,
    HASH_ALGID = 11,
    ALIAS = 12,
    CODEBASE_URL = 13,
    CODEBASE_LASTMOD = 14,
    NULL_PUBLIC_KEY = 15,
    NULL_PUBLIC_KEY_TOKEN = 16,
    CUSTOM = 17,
    NULL_CUSTOM = 18,
    MVID = 19,
    MAX_PARAMS = 20,
};
pub const ASM_NAME_PUBLIC_KEY = ASM_NAME.PUBLIC_KEY;
pub const ASM_NAME_PUBLIC_KEY_TOKEN = ASM_NAME.PUBLIC_KEY_TOKEN;
pub const ASM_NAME_HASH_VALUE = ASM_NAME.HASH_VALUE;
pub const ASM_NAME_NAME = ASM_NAME.NAME;
pub const ASM_NAME_MAJOR_VERSION = ASM_NAME.MAJOR_VERSION;
pub const ASM_NAME_MINOR_VERSION = ASM_NAME.MINOR_VERSION;
pub const ASM_NAME_BUILD_NUMBER = ASM_NAME.BUILD_NUMBER;
pub const ASM_NAME_REVISION_NUMBER = ASM_NAME.REVISION_NUMBER;
pub const ASM_NAME_CULTURE = ASM_NAME.CULTURE;
pub const ASM_NAME_PROCESSOR_ID_ARRAY = ASM_NAME.PROCESSOR_ID_ARRAY;
pub const ASM_NAME_OSINFO_ARRAY = ASM_NAME.OSINFO_ARRAY;
pub const ASM_NAME_HASH_ALGID = ASM_NAME.HASH_ALGID;
pub const ASM_NAME_ALIAS = ASM_NAME.ALIAS;
pub const ASM_NAME_CODEBASE_URL = ASM_NAME.CODEBASE_URL;
pub const ASM_NAME_CODEBASE_LASTMOD = ASM_NAME.CODEBASE_LASTMOD;
pub const ASM_NAME_NULL_PUBLIC_KEY = ASM_NAME.NULL_PUBLIC_KEY;
pub const ASM_NAME_NULL_PUBLIC_KEY_TOKEN = ASM_NAME.NULL_PUBLIC_KEY_TOKEN;
pub const ASM_NAME_CUSTOM = ASM_NAME.CUSTOM;
pub const ASM_NAME_NULL_CUSTOM = ASM_NAME.NULL_CUSTOM;
pub const ASM_NAME_MVID = ASM_NAME.MVID;
pub const ASM_NAME_MAX_PARAMS = ASM_NAME.MAX_PARAMS;

pub const ASM_BIND_FLAGS = enum(u32) {
    FORCE_CACHE_INSTALL = 1,
    RFS_INTEGRITY_CHECK = 2,
    RFS_MODULE_CHECK = 4,
    BINPATH_PROBE_ONLY = 8,
    SHARED_BINPATH_HINT = 16,
    PARENT_ASM_HINT = 32,
    _,
    pub fn initFlags(o: struct {
        FORCE_CACHE_INSTALL: u1 = 0,
        RFS_INTEGRITY_CHECK: u1 = 0,
        RFS_MODULE_CHECK: u1 = 0,
        BINPATH_PROBE_ONLY: u1 = 0,
        SHARED_BINPATH_HINT: u1 = 0,
        PARENT_ASM_HINT: u1 = 0,
    }) ASM_BIND_FLAGS {
        return @intToEnum(ASM_BIND_FLAGS,
              (if (o.FORCE_CACHE_INSTALL == 1) @enumToInt(ASM_BIND_FLAGS.FORCE_CACHE_INSTALL) else 0)
            | (if (o.RFS_INTEGRITY_CHECK == 1) @enumToInt(ASM_BIND_FLAGS.RFS_INTEGRITY_CHECK) else 0)
            | (if (o.RFS_MODULE_CHECK == 1) @enumToInt(ASM_BIND_FLAGS.RFS_MODULE_CHECK) else 0)
            | (if (o.BINPATH_PROBE_ONLY == 1) @enumToInt(ASM_BIND_FLAGS.BINPATH_PROBE_ONLY) else 0)
            | (if (o.SHARED_BINPATH_HINT == 1) @enumToInt(ASM_BIND_FLAGS.SHARED_BINPATH_HINT) else 0)
            | (if (o.PARENT_ASM_HINT == 1) @enumToInt(ASM_BIND_FLAGS.PARENT_ASM_HINT) else 0)
        );
    }
};
pub const ASM_BINDF_FORCE_CACHE_INSTALL = ASM_BIND_FLAGS.FORCE_CACHE_INSTALL;
pub const ASM_BINDF_RFS_INTEGRITY_CHECK = ASM_BIND_FLAGS.RFS_INTEGRITY_CHECK;
pub const ASM_BINDF_RFS_MODULE_CHECK = ASM_BIND_FLAGS.RFS_MODULE_CHECK;
pub const ASM_BINDF_BINPATH_PROBE_ONLY = ASM_BIND_FLAGS.BINPATH_PROBE_ONLY;
pub const ASM_BINDF_SHARED_BINPATH_HINT = ASM_BIND_FLAGS.SHARED_BINPATH_HINT;
pub const ASM_BINDF_PARENT_ASM_HINT = ASM_BIND_FLAGS.PARENT_ASM_HINT;

pub const ASM_DISPLAY_FLAGS = enum(i32) {
    VERSION = 1,
    CULTURE = 2,
    PUBLIC_KEY_TOKEN = 4,
    PUBLIC_KEY = 8,
    CUSTOM = 16,
    PROCESSORARCHITECTURE = 32,
    LANGUAGEID = 64,
};
pub const ASM_DISPLAYF_VERSION = ASM_DISPLAY_FLAGS.VERSION;
pub const ASM_DISPLAYF_CULTURE = ASM_DISPLAY_FLAGS.CULTURE;
pub const ASM_DISPLAYF_PUBLIC_KEY_TOKEN = ASM_DISPLAY_FLAGS.PUBLIC_KEY_TOKEN;
pub const ASM_DISPLAYF_PUBLIC_KEY = ASM_DISPLAY_FLAGS.PUBLIC_KEY;
pub const ASM_DISPLAYF_CUSTOM = ASM_DISPLAY_FLAGS.CUSTOM;
pub const ASM_DISPLAYF_PROCESSORARCHITECTURE = ASM_DISPLAY_FLAGS.PROCESSORARCHITECTURE;
pub const ASM_DISPLAYF_LANGUAGEID = ASM_DISPLAY_FLAGS.LANGUAGEID;

pub const ASM_CMP_FLAGS = enum(i32) {
    NAME = 1,
    MAJOR_VERSION = 2,
    MINOR_VERSION = 4,
    BUILD_NUMBER = 8,
    REVISION_NUMBER = 16,
    PUBLIC_KEY_TOKEN = 32,
    CULTURE = 64,
    CUSTOM = 128,
    ALL = 255,
    DEFAULT = 256,
};
pub const ASM_CMPF_NAME = ASM_CMP_FLAGS.NAME;
pub const ASM_CMPF_MAJOR_VERSION = ASM_CMP_FLAGS.MAJOR_VERSION;
pub const ASM_CMPF_MINOR_VERSION = ASM_CMP_FLAGS.MINOR_VERSION;
pub const ASM_CMPF_BUILD_NUMBER = ASM_CMP_FLAGS.BUILD_NUMBER;
pub const ASM_CMPF_REVISION_NUMBER = ASM_CMP_FLAGS.REVISION_NUMBER;
pub const ASM_CMPF_PUBLIC_KEY_TOKEN = ASM_CMP_FLAGS.PUBLIC_KEY_TOKEN;
pub const ASM_CMPF_CULTURE = ASM_CMP_FLAGS.CULTURE;
pub const ASM_CMPF_CUSTOM = ASM_CMP_FLAGS.CUSTOM;
pub const ASM_CMPF_ALL = ASM_CMP_FLAGS.ALL;
pub const ASM_CMPF_DEFAULT = ASM_CMP_FLAGS.DEFAULT;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyName_Value = @import("../zig.zig").Guid.initString("cd193bc0-b4bc-11d2-9833-00c04fc31d2e");
pub const IID_IAssemblyName = &IID_IAssemblyName_Value;
pub const IAssemblyName = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProperty: fn(
            self: *const IAssemblyName,
            PropertyId: u32,
            pvProperty: ?*anyopaque,
            cbProperty: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAssemblyName,
            PropertyId: u32,
            pvProperty: ?*anyopaque,
            pcbProperty: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finalize: fn(
            self: *const IAssemblyName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const IAssemblyName,
            szDisplayName: ?[*:0]u16,
            pccDisplayName: ?*u32,
            dwDisplayFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reserved: fn(
            self: *const IAssemblyName,
            refIID: ?*const Guid,
            pUnkReserved1: ?*IUnknown,
            pUnkReserved2: ?*IUnknown,
            szReserved: ?[*:0]const u16,
            llReserved: i64,
            pvReserved: ?*anyopaque,
            cbReserved: u32,
            ppReserved: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IAssemblyName,
            lpcwBuffer: ?*u32,
            pwzName: ?[*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const IAssemblyName,
            pdwVersionHi: ?*u32,
            pdwVersionLow: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IAssemblyName,
            pName: ?*IAssemblyName,
            dwCmpFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IAssemblyName,
            pName: ?*?*IAssemblyName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_SetProperty(self: *const T, PropertyId: u32, pvProperty: ?*anyopaque, cbProperty: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).SetProperty(@ptrCast(*const IAssemblyName, self), PropertyId, pvProperty, cbProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_GetProperty(self: *const T, PropertyId: u32, pvProperty: ?*anyopaque, pcbProperty: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).GetProperty(@ptrCast(*const IAssemblyName, self), PropertyId, pvProperty, pcbProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_Finalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).Finalize(@ptrCast(*const IAssemblyName, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_GetDisplayName(self: *const T, szDisplayName: ?[*:0]u16, pccDisplayName: ?*u32, dwDisplayFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).GetDisplayName(@ptrCast(*const IAssemblyName, self), szDisplayName, pccDisplayName, dwDisplayFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_Reserved(self: *const T, refIID: ?*const Guid, pUnkReserved1: ?*IUnknown, pUnkReserved2: ?*IUnknown, szReserved: ?[*:0]const u16, llReserved: i64, pvReserved: ?*anyopaque, cbReserved: u32, ppReserved: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).Reserved(@ptrCast(*const IAssemblyName, self), refIID, pUnkReserved1, pUnkReserved2, szReserved, llReserved, pvReserved, cbReserved, ppReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_GetName(self: *const T, lpcwBuffer: ?*u32, pwzName: ?[*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).GetName(@ptrCast(*const IAssemblyName, self), lpcwBuffer, pwzName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_GetVersion(self: *const T, pdwVersionHi: ?*u32, pdwVersionLow: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).GetVersion(@ptrCast(*const IAssemblyName, self), pdwVersionHi, pdwVersionLow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_IsEqual(self: *const T, pName: ?*IAssemblyName, dwCmpFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).IsEqual(@ptrCast(*const IAssemblyName, self), pName, dwCmpFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_Clone(self: *const T, pName: ?*?*IAssemblyName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).Clone(@ptrCast(*const IAssemblyName, self), pName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyCacheItem_Value = @import("../zig.zig").Guid.initString("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae");
pub const IID_IAssemblyCacheItem = &IID_IAssemblyCacheItem_Value;
pub const IAssemblyCacheItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStream: fn(
            self: *const IAssemblyCacheItem,
            dwFlags: u32,
            pszStreamName: ?[*:0]const u16,
            dwFormat: u32,
            dwFormatFlags: u32,
            ppIStream: ?*?*IStream,
            puliMaxSize: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IAssemblyCacheItem,
            dwFlags: u32,
            pulDisposition: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortItem: fn(
            self: *const IAssemblyCacheItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCacheItem_CreateStream(self: *const T, dwFlags: u32, pszStreamName: ?[*:0]const u16, dwFormat: u32, dwFormatFlags: u32, ppIStream: ?*?*IStream, puliMaxSize: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCacheItem.VTable, self.vtable).CreateStream(@ptrCast(*const IAssemblyCacheItem, self), dwFlags, pszStreamName, dwFormat, dwFormatFlags, ppIStream, puliMaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCacheItem_Commit(self: *const T, dwFlags: u32, pulDisposition: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCacheItem.VTable, self.vtable).Commit(@ptrCast(*const IAssemblyCacheItem, self), dwFlags, pulDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCacheItem_AbortItem(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCacheItem.VTable, self.vtable).AbortItem(@ptrCast(*const IAssemblyCacheItem, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyCache_Value = @import("../zig.zig").Guid.initString("e707dcde-d1cd-11d2-bab9-00c04f8eceae");
pub const IID_IAssemblyCache = &IID_IAssemblyCache_Value;
pub const IAssemblyCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UninstallAssembly: fn(
            self: *const IAssemblyCache,
            dwFlags: u32,
            pszAssemblyName: ?[*:0]const u16,
            pRefData: ?*FUSION_INSTALL_REFERENCE,
            pulDisposition: ?*IASSEMBLYCACHE_UNINSTALL_DISPOSITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssemblyInfo: fn(
            self: *const IAssemblyCache,
            dwFlags: QUERYASMINFO_FLAGS,
            pszAssemblyName: ?[*:0]const u16,
            pAsmInfo: ?*ASSEMBLY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAssemblyCacheItem: fn(
            self: *const IAssemblyCache,
            dwFlags: u32,
            pvReserved: ?*anyopaque,
            ppAsmItem: ?*?*IAssemblyCacheItem,
            pszAssemblyName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reserved: fn(
            self: *const IAssemblyCache,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallAssembly: fn(
            self: *const IAssemblyCache,
            dwFlags: u32,
            pszManifestFilePath: ?[*:0]const u16,
            pRefData: ?*FUSION_INSTALL_REFERENCE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_UninstallAssembly(self: *const T, dwFlags: u32, pszAssemblyName: ?[*:0]const u16, pRefData: ?*FUSION_INSTALL_REFERENCE, pulDisposition: ?*IASSEMBLYCACHE_UNINSTALL_DISPOSITION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).UninstallAssembly(@ptrCast(*const IAssemblyCache, self), dwFlags, pszAssemblyName, pRefData, pulDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_QueryAssemblyInfo(self: *const T, dwFlags: QUERYASMINFO_FLAGS, pszAssemblyName: ?[*:0]const u16, pAsmInfo: ?*ASSEMBLY_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).QueryAssemblyInfo(@ptrCast(*const IAssemblyCache, self), dwFlags, pszAssemblyName, pAsmInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_CreateAssemblyCacheItem(self: *const T, dwFlags: u32, pvReserved: ?*anyopaque, ppAsmItem: ?*?*IAssemblyCacheItem, pszAssemblyName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).CreateAssemblyCacheItem(@ptrCast(*const IAssemblyCache, self), dwFlags, pvReserved, ppAsmItem, pszAssemblyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_Reserved(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).Reserved(@ptrCast(*const IAssemblyCache, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_InstallAssembly(self: *const T, dwFlags: u32, pszManifestFilePath: ?[*:0]const u16, pRefData: ?*FUSION_INSTALL_REFERENCE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).InstallAssembly(@ptrCast(*const IAssemblyCache, self), dwFlags, pszManifestFilePath, pRefData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CREATE_ASM_NAME_OBJ_FLAGS = enum(i32) {
    PARSE_DISPLAY_NAME = 1,
    SET_DEFAULT_VALUES = 2,
};
pub const CANOF_PARSE_DISPLAY_NAME = CREATE_ASM_NAME_OBJ_FLAGS.PARSE_DISPLAY_NAME;
pub const CANOF_SET_DEFAULT_VALUES = CREATE_ASM_NAME_OBJ_FLAGS.SET_DEFAULT_VALUES;

pub const PROTECTED_FILE_DATA = extern struct {
    FileName: [260]u16,
    FileNumber: u32,
};

pub const msidbControlAttributes = enum(i32) {
    AttributesVisible = 1,
    AttributesEnabled = 2,
    AttributesSunken = 4,
    AttributesIndirect = 8,
    AttributesInteger = 16,
    AttributesRTLRO = 32,
    AttributesRightAligned = 64,
    AttributesLeftScroll = 128,
    AttributesBiDi = 224,
    AttributesTransparent = 65536,
    AttributesNoPrefix = 131072,
    AttributesNoWrap = 262144,
    AttributesFormatSize = 524288,
    AttributesUsersLanguage = 1048576,
    // AttributesMultiline = 65536, this enum value conflicts with AttributesTransparent
    AttributesPasswordInput = 2097152,
    // AttributesProgress95 = 65536, this enum value conflicts with AttributesTransparent
    // AttributesRemovableVolume = 65536, this enum value conflicts with AttributesTransparent
    // AttributesFixedVolume = 131072, this enum value conflicts with AttributesNoPrefix
    // AttributesRemoteVolume = 262144, this enum value conflicts with AttributesNoWrap
    // AttributesCDROMVolume = 524288, this enum value conflicts with AttributesFormatSize
    // AttributesRAMDiskVolume = 1048576, this enum value conflicts with AttributesUsersLanguage
    // AttributesFloppyVolume = 2097152, this enum value conflicts with AttributesPasswordInput
    ShowRollbackCost = 4194304,
    // AttributesSorted = 65536, this enum value conflicts with AttributesTransparent
    // AttributesComboList = 131072, this enum value conflicts with AttributesNoPrefix
    // AttributesImageHandle = 65536, this enum value conflicts with AttributesTransparent
    // AttributesPushLike = 131072, this enum value conflicts with AttributesNoPrefix
    // AttributesBitmap = 262144, this enum value conflicts with AttributesNoWrap
    // AttributesIcon = 524288, this enum value conflicts with AttributesFormatSize
    // AttributesFixedSize = 1048576, this enum value conflicts with AttributesUsersLanguage
    // AttributesIconSize16 = 2097152, this enum value conflicts with AttributesPasswordInput
    // AttributesIconSize32 = 4194304, this enum value conflicts with ShowRollbackCost
    AttributesIconSize48 = 6291456,
    AttributesElevationShield = 8388608,
    AttributesHasBorder = 16777216,
};
pub const msidbControlAttributesVisible = msidbControlAttributes.AttributesVisible;
pub const msidbControlAttributesEnabled = msidbControlAttributes.AttributesEnabled;
pub const msidbControlAttributesSunken = msidbControlAttributes.AttributesSunken;
pub const msidbControlAttributesIndirect = msidbControlAttributes.AttributesIndirect;
pub const msidbControlAttributesInteger = msidbControlAttributes.AttributesInteger;
pub const msidbControlAttributesRTLRO = msidbControlAttributes.AttributesRTLRO;
pub const msidbControlAttributesRightAligned = msidbControlAttributes.AttributesRightAligned;
pub const msidbControlAttributesLeftScroll = msidbControlAttributes.AttributesLeftScroll;
pub const msidbControlAttributesBiDi = msidbControlAttributes.AttributesBiDi;
pub const msidbControlAttributesTransparent = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesNoPrefix = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesNoWrap = msidbControlAttributes.AttributesNoWrap;
pub const msidbControlAttributesFormatSize = msidbControlAttributes.AttributesFormatSize;
pub const msidbControlAttributesUsersLanguage = msidbControlAttributes.AttributesUsersLanguage;
pub const msidbControlAttributesMultiline = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesPasswordInput = msidbControlAttributes.AttributesPasswordInput;
pub const msidbControlAttributesProgress95 = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesRemovableVolume = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesFixedVolume = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesRemoteVolume = msidbControlAttributes.AttributesNoWrap;
pub const msidbControlAttributesCDROMVolume = msidbControlAttributes.AttributesFormatSize;
pub const msidbControlAttributesRAMDiskVolume = msidbControlAttributes.AttributesUsersLanguage;
pub const msidbControlAttributesFloppyVolume = msidbControlAttributes.AttributesPasswordInput;
pub const msidbControlShowRollbackCost = msidbControlAttributes.ShowRollbackCost;
pub const msidbControlAttributesSorted = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesComboList = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesImageHandle = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesPushLike = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesBitmap = msidbControlAttributes.AttributesNoWrap;
pub const msidbControlAttributesIcon = msidbControlAttributes.AttributesFormatSize;
pub const msidbControlAttributesFixedSize = msidbControlAttributes.AttributesUsersLanguage;
pub const msidbControlAttributesIconSize16 = msidbControlAttributes.AttributesPasswordInput;
pub const msidbControlAttributesIconSize32 = msidbControlAttributes.ShowRollbackCost;
pub const msidbControlAttributesIconSize48 = msidbControlAttributes.AttributesIconSize48;
pub const msidbControlAttributesElevationShield = msidbControlAttributes.AttributesElevationShield;
pub const msidbControlAttributesHasBorder = msidbControlAttributes.AttributesHasBorder;

pub const msidbLocatorType = enum(i32) {
    Directory = 0,
    FileName = 1,
    RawValue = 2,
    @"64bit" = 16,
};
pub const msidbLocatorTypeDirectory = msidbLocatorType.Directory;
pub const msidbLocatorTypeFileName = msidbLocatorType.FileName;
pub const msidbLocatorTypeRawValue = msidbLocatorType.RawValue;
pub const msidbLocatorType64bit = msidbLocatorType.@"64bit";

pub const msidbComponentAttributes = enum(i32) {
    LocalOnly = 0,
    SourceOnly = 1,
    Optional = 2,
    RegistryKeyPath = 4,
    SharedDllRefCount = 8,
    Permanent = 16,
    ODBCDataSource = 32,
    Transitive = 64,
    NeverOverwrite = 128,
    @"64bit" = 256,
    DisableRegistryReflection = 512,
    UninstallOnSupersedence = 1024,
    Shared = 2048,
};
pub const msidbComponentAttributesLocalOnly = msidbComponentAttributes.LocalOnly;
pub const msidbComponentAttributesSourceOnly = msidbComponentAttributes.SourceOnly;
pub const msidbComponentAttributesOptional = msidbComponentAttributes.Optional;
pub const msidbComponentAttributesRegistryKeyPath = msidbComponentAttributes.RegistryKeyPath;
pub const msidbComponentAttributesSharedDllRefCount = msidbComponentAttributes.SharedDllRefCount;
pub const msidbComponentAttributesPermanent = msidbComponentAttributes.Permanent;
pub const msidbComponentAttributesODBCDataSource = msidbComponentAttributes.ODBCDataSource;
pub const msidbComponentAttributesTransitive = msidbComponentAttributes.Transitive;
pub const msidbComponentAttributesNeverOverwrite = msidbComponentAttributes.NeverOverwrite;
pub const msidbComponentAttributes64bit = msidbComponentAttributes.@"64bit";
pub const msidbComponentAttributesDisableRegistryReflection = msidbComponentAttributes.DisableRegistryReflection;
pub const msidbComponentAttributesUninstallOnSupersedence = msidbComponentAttributes.UninstallOnSupersedence;
pub const msidbComponentAttributesShared = msidbComponentAttributes.Shared;

pub const msidbAssemblyAttributes = enum(i32) {
    URT = 0,
    Win32 = 1,
};
pub const msidbAssemblyAttributesURT = msidbAssemblyAttributes.URT;
pub const msidbAssemblyAttributesWin32 = msidbAssemblyAttributes.Win32;

pub const msidbCustomActionType = enum(i32) {
    Dll = 1,
    Exe = 2,
    TextData = 3,
    JScript = 5,
    VBScript = 6,
    Install = 7,
    BinaryData = 0,
    SourceFile = 16,
    Directory = 32,
    Property = 48,
    Continue = 64,
    Async = 128,
    FirstSequence = 256,
    OncePerProcess = 512,
    ClientRepeat = 768,
    InScript = 1024,
    // Rollback = 256, this enum value conflicts with FirstSequence
    // Commit = 512, this enum value conflicts with OncePerProcess
    NoImpersonate = 2048,
    TSAware = 16384,
    @"64BitScript" = 4096,
    HideTarget = 8192,
    PatchUninstall = 32768,
};
pub const msidbCustomActionTypeDll = msidbCustomActionType.Dll;
pub const msidbCustomActionTypeExe = msidbCustomActionType.Exe;
pub const msidbCustomActionTypeTextData = msidbCustomActionType.TextData;
pub const msidbCustomActionTypeJScript = msidbCustomActionType.JScript;
pub const msidbCustomActionTypeVBScript = msidbCustomActionType.VBScript;
pub const msidbCustomActionTypeInstall = msidbCustomActionType.Install;
pub const msidbCustomActionTypeBinaryData = msidbCustomActionType.BinaryData;
pub const msidbCustomActionTypeSourceFile = msidbCustomActionType.SourceFile;
pub const msidbCustomActionTypeDirectory = msidbCustomActionType.Directory;
pub const msidbCustomActionTypeProperty = msidbCustomActionType.Property;
pub const msidbCustomActionTypeContinue = msidbCustomActionType.Continue;
pub const msidbCustomActionTypeAsync = msidbCustomActionType.Async;
pub const msidbCustomActionTypeFirstSequence = msidbCustomActionType.FirstSequence;
pub const msidbCustomActionTypeOncePerProcess = msidbCustomActionType.OncePerProcess;
pub const msidbCustomActionTypeClientRepeat = msidbCustomActionType.ClientRepeat;
pub const msidbCustomActionTypeInScript = msidbCustomActionType.InScript;
pub const msidbCustomActionTypeRollback = msidbCustomActionType.FirstSequence;
pub const msidbCustomActionTypeCommit = msidbCustomActionType.OncePerProcess;
pub const msidbCustomActionTypeNoImpersonate = msidbCustomActionType.NoImpersonate;
pub const msidbCustomActionTypeTSAware = msidbCustomActionType.TSAware;
pub const msidbCustomActionType64BitScript = msidbCustomActionType.@"64BitScript";
pub const msidbCustomActionTypeHideTarget = msidbCustomActionType.HideTarget;
pub const msidbCustomActionTypePatchUninstall = msidbCustomActionType.PatchUninstall;

pub const msidbDialogAttributes = enum(i32) {
    Visible = 1,
    Modal = 2,
    Minimize = 4,
    SysModal = 8,
    KeepModeless = 16,
    TrackDiskSpace = 32,
    UseCustomPalette = 64,
    RTLRO = 128,
    RightAligned = 256,
    LeftScroll = 512,
    BiDi = 896,
    Error = 65536,
};
pub const msidbDialogAttributesVisible = msidbDialogAttributes.Visible;
pub const msidbDialogAttributesModal = msidbDialogAttributes.Modal;
pub const msidbDialogAttributesMinimize = msidbDialogAttributes.Minimize;
pub const msidbDialogAttributesSysModal = msidbDialogAttributes.SysModal;
pub const msidbDialogAttributesKeepModeless = msidbDialogAttributes.KeepModeless;
pub const msidbDialogAttributesTrackDiskSpace = msidbDialogAttributes.TrackDiskSpace;
pub const msidbDialogAttributesUseCustomPalette = msidbDialogAttributes.UseCustomPalette;
pub const msidbDialogAttributesRTLRO = msidbDialogAttributes.RTLRO;
pub const msidbDialogAttributesRightAligned = msidbDialogAttributes.RightAligned;
pub const msidbDialogAttributesLeftScroll = msidbDialogAttributes.LeftScroll;
pub const msidbDialogAttributesBiDi = msidbDialogAttributes.BiDi;
pub const msidbDialogAttributesError = msidbDialogAttributes.Error;

pub const msidbFeatureAttributes = enum(i32) {
    FavorLocal = 0,
    FavorSource = 1,
    FollowParent = 2,
    FavorAdvertise = 4,
    DisallowAdvertise = 8,
    UIDisallowAbsent = 16,
    NoUnsupportedAdvertise = 32,
};
pub const msidbFeatureAttributesFavorLocal = msidbFeatureAttributes.FavorLocal;
pub const msidbFeatureAttributesFavorSource = msidbFeatureAttributes.FavorSource;
pub const msidbFeatureAttributesFollowParent = msidbFeatureAttributes.FollowParent;
pub const msidbFeatureAttributesFavorAdvertise = msidbFeatureAttributes.FavorAdvertise;
pub const msidbFeatureAttributesDisallowAdvertise = msidbFeatureAttributes.DisallowAdvertise;
pub const msidbFeatureAttributesUIDisallowAbsent = msidbFeatureAttributes.UIDisallowAbsent;
pub const msidbFeatureAttributesNoUnsupportedAdvertise = msidbFeatureAttributes.NoUnsupportedAdvertise;

pub const msidbFileAttributes = enum(i32) {
    ReadOnly = 1,
    Hidden = 2,
    System = 4,
    Reserved0 = 8,
    IsolatedComp = 16,
    Reserved1 = 64,
    Reserved2 = 128,
    Reserved3 = 256,
    Vital = 512,
    Checksum = 1024,
    PatchAdded = 4096,
    Noncompressed = 8192,
    Compressed = 16384,
    Reserved4 = 32768,
};
pub const msidbFileAttributesReadOnly = msidbFileAttributes.ReadOnly;
pub const msidbFileAttributesHidden = msidbFileAttributes.Hidden;
pub const msidbFileAttributesSystem = msidbFileAttributes.System;
pub const msidbFileAttributesReserved0 = msidbFileAttributes.Reserved0;
pub const msidbFileAttributesIsolatedComp = msidbFileAttributes.IsolatedComp;
pub const msidbFileAttributesReserved1 = msidbFileAttributes.Reserved1;
pub const msidbFileAttributesReserved2 = msidbFileAttributes.Reserved2;
pub const msidbFileAttributesReserved3 = msidbFileAttributes.Reserved3;
pub const msidbFileAttributesVital = msidbFileAttributes.Vital;
pub const msidbFileAttributesChecksum = msidbFileAttributes.Checksum;
pub const msidbFileAttributesPatchAdded = msidbFileAttributes.PatchAdded;
pub const msidbFileAttributesNoncompressed = msidbFileAttributes.Noncompressed;
pub const msidbFileAttributesCompressed = msidbFileAttributes.Compressed;
pub const msidbFileAttributesReserved4 = msidbFileAttributes.Reserved4;

pub const msidbIniFileAction = enum(i32) {
    AddLine = 0,
    CreateLine = 1,
    RemoveLine = 2,
    AddTag = 3,
    RemoveTag = 4,
};
pub const msidbIniFileActionAddLine = msidbIniFileAction.AddLine;
pub const msidbIniFileActionCreateLine = msidbIniFileAction.CreateLine;
pub const msidbIniFileActionRemoveLine = msidbIniFileAction.RemoveLine;
pub const msidbIniFileActionAddTag = msidbIniFileAction.AddTag;
pub const msidbIniFileActionRemoveTag = msidbIniFileAction.RemoveTag;

pub const msidbMoveFileOptions = enum(i32) {
    e = 1,
};
pub const msidbMoveFileOptionsMove = msidbMoveFileOptions.e;

pub const msidbODBCDataSourceRegistration = enum(i32) {
    Machine = 0,
    User = 1,
};
pub const msidbODBCDataSourceRegistrationPerMachine = msidbODBCDataSourceRegistration.Machine;
pub const msidbODBCDataSourceRegistrationPerUser = msidbODBCDataSourceRegistration.User;

pub const msidbClassAttributes = enum(i32) {
    h = 1,
};
pub const msidbClassAttributesRelativePath = msidbClassAttributes.h;

pub const msidbPatchAttributes = enum(i32) {
    l = 1,
};
pub const msidbPatchAttributesNonVital = msidbPatchAttributes.l;

pub const msidbRegistryRoot = enum(i32) {
    ClassesRoot = 0,
    CurrentUser = 1,
    LocalMachine = 2,
    Users = 3,
};
pub const msidbRegistryRootClassesRoot = msidbRegistryRoot.ClassesRoot;
pub const msidbRegistryRootCurrentUser = msidbRegistryRoot.CurrentUser;
pub const msidbRegistryRootLocalMachine = msidbRegistryRoot.LocalMachine;
pub const msidbRegistryRootUsers = msidbRegistryRoot.Users;

pub const msidbRemoveFileInstallMode = enum(i32) {
    Install = 1,
    Remove = 2,
    Both = 3,
};
pub const msidbRemoveFileInstallModeOnInstall = msidbRemoveFileInstallMode.Install;
pub const msidbRemoveFileInstallModeOnRemove = msidbRemoveFileInstallMode.Remove;
pub const msidbRemoveFileInstallModeOnBoth = msidbRemoveFileInstallMode.Both;

pub const msidbServiceControlEvent = enum(i32) {
    Start = 1,
    Stop = 2,
    Delete = 8,
    UninstallStart = 16,
    UninstallStop = 32,
    UninstallDelete = 128,
};
pub const msidbServiceControlEventStart = msidbServiceControlEvent.Start;
pub const msidbServiceControlEventStop = msidbServiceControlEvent.Stop;
pub const msidbServiceControlEventDelete = msidbServiceControlEvent.Delete;
pub const msidbServiceControlEventUninstallStart = msidbServiceControlEvent.UninstallStart;
pub const msidbServiceControlEventUninstallStop = msidbServiceControlEvent.UninstallStop;
pub const msidbServiceControlEventUninstallDelete = msidbServiceControlEvent.UninstallDelete;

pub const msidbServiceConfigEvent = enum(i32) {
    Install = 1,
    Uninstall = 2,
    Reinstall = 4,
};
pub const msidbServiceConfigEventInstall = msidbServiceConfigEvent.Install;
pub const msidbServiceConfigEventUninstall = msidbServiceConfigEvent.Uninstall;
pub const msidbServiceConfigEventReinstall = msidbServiceConfigEvent.Reinstall;

pub const msidbServiceInstallErrorControl = enum(i32) {
    l = 32768,
};
pub const msidbServiceInstallErrorControlVital = msidbServiceInstallErrorControl.l;

pub const msidbTextStyleStyleBits = enum(i32) {
    Bold = 1,
    Italic = 2,
    Underline = 4,
    Strike = 8,
};
pub const msidbTextStyleStyleBitsBold = msidbTextStyleStyleBits.Bold;
pub const msidbTextStyleStyleBitsItalic = msidbTextStyleStyleBits.Italic;
pub const msidbTextStyleStyleBitsUnderline = msidbTextStyleStyleBits.Underline;
pub const msidbTextStyleStyleBitsStrike = msidbTextStyleStyleBits.Strike;

pub const msidbUpgradeAttributes = enum(i32) {
    MigrateFeatures = 1,
    OnlyDetect = 2,
    IgnoreRemoveFailure = 4,
    VersionMinInclusive = 256,
    VersionMaxInclusive = 512,
    LanguagesExclusive = 1024,
};
pub const msidbUpgradeAttributesMigrateFeatures = msidbUpgradeAttributes.MigrateFeatures;
pub const msidbUpgradeAttributesOnlyDetect = msidbUpgradeAttributes.OnlyDetect;
pub const msidbUpgradeAttributesIgnoreRemoveFailure = msidbUpgradeAttributes.IgnoreRemoveFailure;
pub const msidbUpgradeAttributesVersionMinInclusive = msidbUpgradeAttributes.VersionMinInclusive;
pub const msidbUpgradeAttributesVersionMaxInclusive = msidbUpgradeAttributes.VersionMaxInclusive;
pub const msidbUpgradeAttributesLanguagesExclusive = msidbUpgradeAttributes.LanguagesExclusive;

pub const msidbEmbeddedUIAttributes = enum(i32) {
    UI = 1,
    HandlesBasic = 2,
};
pub const msidbEmbeddedUI = msidbEmbeddedUIAttributes.UI;
pub const msidbEmbeddedHandlesBasic = msidbEmbeddedUIAttributes.HandlesBasic;

pub const msidbSumInfoSourceType = enum(i32) {
    SFN = 1,
    Compressed = 2,
    AdminImage = 4,
    LUAPackage = 8,
};
pub const msidbSumInfoSourceTypeSFN = msidbSumInfoSourceType.SFN;
pub const msidbSumInfoSourceTypeCompressed = msidbSumInfoSourceType.Compressed;
pub const msidbSumInfoSourceTypeAdminImage = msidbSumInfoSourceType.AdminImage;
pub const msidbSumInfoSourceTypeLUAPackage = msidbSumInfoSourceType.LUAPackage;

pub const msirbRebootType = enum(i32) {
    Immediate = 1,
    Deferred = 2,
};
pub const msirbRebootImmediate = msirbRebootType.Immediate;
pub const msirbRebootDeferred = msirbRebootType.Deferred;

pub const msirbRebootReason = enum(i32) {
    UndeterminedReason = 0,
    InUseFilesReason = 1,
    ScheduleRebootReason = 2,
    ForceRebootReason = 3,
    CustomActionReason = 4,
};
pub const msirbRebootUndeterminedReason = msirbRebootReason.UndeterminedReason;
pub const msirbRebootInUseFilesReason = msirbRebootReason.InUseFilesReason;
pub const msirbRebootScheduleRebootReason = msirbRebootReason.ScheduleRebootReason;
pub const msirbRebootForceRebootReason = msirbRebootReason.ForceRebootReason;
pub const msirbRebootCustomActionReason = msirbRebootReason.CustomActionReason;

pub const msifiFastInstallBits = enum(i32) {
    NoSR = 1,
    QuickCosting = 2,
    LessPrgMsg = 4,
};
pub const msifiFastInstallNoSR = msifiFastInstallBits.NoSR;
pub const msifiFastInstallQuickCosting = msifiFastInstallBits.QuickCosting;
pub const msifiFastInstallLessPrgMsg = msifiFastInstallBits.LessPrgMsg;

const CLSID_PMSvc_Value = @import("../zig.zig").Guid.initString("b9e511fc-e364-497a-a121-b7b3612cedce");
pub const CLSID_PMSvc = &CLSID_PMSvc_Value;

pub const TILE_TEMPLATE_TYPE = enum(i32) {
    INVALID = 0,
    FLIP = 5,
    DEEPLINK = 13,
    CYCLE = 14,
    METROCOUNT = 1,
    AGILESTORE = 2,
    GAMES = 3,
    CALENDAR = 4,
    MUSICVIDEO = 7,
    PEOPLE = 10,
    CONTACT = 11,
    GROUP = 12,
    DEFAULT = 15,
    BADGE = 16,
    BLOCK = 17,
    TEXT01 = 18,
    TEXT02 = 19,
    TEXT03 = 20,
    TEXT04 = 21,
    TEXT05 = 22,
    TEXT06 = 23,
    TEXT07 = 24,
    TEXT08 = 25,
    TEXT09 = 26,
    TEXT10 = 27,
    TEXT11 = 28,
    IMAGE = 29,
    IMAGECOLLECTION = 30,
    IMAGEANDTEXT01 = 31,
    IMAGEANDTEXT02 = 32,
    BLOCKANDTEXT01 = 33,
    BLOCKANDTEXT02 = 34,
    PEEKIMAGEANDTEXT01 = 35,
    PEEKIMAGEANDTEXT02 = 36,
    PEEKIMAGEANDTEXT03 = 37,
    PEEKIMAGEANDTEXT04 = 38,
    PEEKIMAGE01 = 39,
    PEEKIMAGE02 = 40,
    PEEKIMAGE03 = 41,
    PEEKIMAGE04 = 42,
    PEEKIMAGE05 = 43,
    PEEKIMAGE06 = 44,
    PEEKIMAGECOLLECTION01 = 45,
    PEEKIMAGECOLLECTION02 = 46,
    PEEKIMAGECOLLECTION03 = 47,
    PEEKIMAGECOLLECTION04 = 48,
    PEEKIMAGECOLLECTION05 = 49,
    PEEKIMAGECOLLECTION06 = 50,
    SMALLIMAGEANDTEXT01 = 51,
    SMALLIMAGEANDTEXT02 = 52,
    SMALLIMAGEANDTEXT03 = 53,
    SMALLIMAGEANDTEXT04 = 54,
    SMALLIMAGEANDTEXT05 = 55,
    METROCOUNTQUEUE = 56,
    SEARCH = 57,
    TILEFLYOUT01 = 58,
    FOLDER = 59,
    ALL = 100,
};
pub const TILE_TEMPLATE_INVALID = TILE_TEMPLATE_TYPE.INVALID;
pub const TILE_TEMPLATE_FLIP = TILE_TEMPLATE_TYPE.FLIP;
pub const TILE_TEMPLATE_DEEPLINK = TILE_TEMPLATE_TYPE.DEEPLINK;
pub const TILE_TEMPLATE_CYCLE = TILE_TEMPLATE_TYPE.CYCLE;
pub const TILE_TEMPLATE_METROCOUNT = TILE_TEMPLATE_TYPE.METROCOUNT;
pub const TILE_TEMPLATE_AGILESTORE = TILE_TEMPLATE_TYPE.AGILESTORE;
pub const TILE_TEMPLATE_GAMES = TILE_TEMPLATE_TYPE.GAMES;
pub const TILE_TEMPLATE_CALENDAR = TILE_TEMPLATE_TYPE.CALENDAR;
pub const TILE_TEMPLATE_MUSICVIDEO = TILE_TEMPLATE_TYPE.MUSICVIDEO;
pub const TILE_TEMPLATE_PEOPLE = TILE_TEMPLATE_TYPE.PEOPLE;
pub const TILE_TEMPLATE_CONTACT = TILE_TEMPLATE_TYPE.CONTACT;
pub const TILE_TEMPLATE_GROUP = TILE_TEMPLATE_TYPE.GROUP;
pub const TILE_TEMPLATE_DEFAULT = TILE_TEMPLATE_TYPE.DEFAULT;
pub const TILE_TEMPLATE_BADGE = TILE_TEMPLATE_TYPE.BADGE;
pub const TILE_TEMPLATE_BLOCK = TILE_TEMPLATE_TYPE.BLOCK;
pub const TILE_TEMPLATE_TEXT01 = TILE_TEMPLATE_TYPE.TEXT01;
pub const TILE_TEMPLATE_TEXT02 = TILE_TEMPLATE_TYPE.TEXT02;
pub const TILE_TEMPLATE_TEXT03 = TILE_TEMPLATE_TYPE.TEXT03;
pub const TILE_TEMPLATE_TEXT04 = TILE_TEMPLATE_TYPE.TEXT04;
pub const TILE_TEMPLATE_TEXT05 = TILE_TEMPLATE_TYPE.TEXT05;
pub const TILE_TEMPLATE_TEXT06 = TILE_TEMPLATE_TYPE.TEXT06;
pub const TILE_TEMPLATE_TEXT07 = TILE_TEMPLATE_TYPE.TEXT07;
pub const TILE_TEMPLATE_TEXT08 = TILE_TEMPLATE_TYPE.TEXT08;
pub const TILE_TEMPLATE_TEXT09 = TILE_TEMPLATE_TYPE.TEXT09;
pub const TILE_TEMPLATE_TEXT10 = TILE_TEMPLATE_TYPE.TEXT10;
pub const TILE_TEMPLATE_TEXT11 = TILE_TEMPLATE_TYPE.TEXT11;
pub const TILE_TEMPLATE_IMAGE = TILE_TEMPLATE_TYPE.IMAGE;
pub const TILE_TEMPLATE_IMAGECOLLECTION = TILE_TEMPLATE_TYPE.IMAGECOLLECTION;
pub const TILE_TEMPLATE_IMAGEANDTEXT01 = TILE_TEMPLATE_TYPE.IMAGEANDTEXT01;
pub const TILE_TEMPLATE_IMAGEANDTEXT02 = TILE_TEMPLATE_TYPE.IMAGEANDTEXT02;
pub const TILE_TEMPLATE_BLOCKANDTEXT01 = TILE_TEMPLATE_TYPE.BLOCKANDTEXT01;
pub const TILE_TEMPLATE_BLOCKANDTEXT02 = TILE_TEMPLATE_TYPE.BLOCKANDTEXT02;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT01 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT01;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT02 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT02;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT03 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT03;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT04 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT04;
pub const TILE_TEMPLATE_PEEKIMAGE01 = TILE_TEMPLATE_TYPE.PEEKIMAGE01;
pub const TILE_TEMPLATE_PEEKIMAGE02 = TILE_TEMPLATE_TYPE.PEEKIMAGE02;
pub const TILE_TEMPLATE_PEEKIMAGE03 = TILE_TEMPLATE_TYPE.PEEKIMAGE03;
pub const TILE_TEMPLATE_PEEKIMAGE04 = TILE_TEMPLATE_TYPE.PEEKIMAGE04;
pub const TILE_TEMPLATE_PEEKIMAGE05 = TILE_TEMPLATE_TYPE.PEEKIMAGE05;
pub const TILE_TEMPLATE_PEEKIMAGE06 = TILE_TEMPLATE_TYPE.PEEKIMAGE06;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION01 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION01;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION02 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION02;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION03 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION03;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION04 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION04;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION05 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION05;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION06 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION06;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT01 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT01;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT02 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT02;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT03 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT03;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT04 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT04;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT05 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT05;
pub const TILE_TEMPLATE_METROCOUNTQUEUE = TILE_TEMPLATE_TYPE.METROCOUNTQUEUE;
pub const TILE_TEMPLATE_SEARCH = TILE_TEMPLATE_TYPE.SEARCH;
pub const TILE_TEMPLATE_TILEFLYOUT01 = TILE_TEMPLATE_TYPE.TILEFLYOUT01;
pub const TILE_TEMPLATE_FOLDER = TILE_TEMPLATE_TYPE.FOLDER;
pub const TILE_TEMPLATE_ALL = TILE_TEMPLATE_TYPE.ALL;

pub const PM_APP_GENRE = enum(i32) {
    GAMES = 0,
    OTHER = 1,
    INVALID = 2,
};
pub const PM_APP_GENRE_GAMES = PM_APP_GENRE.GAMES;
pub const PM_APP_GENRE_OTHER = PM_APP_GENRE.OTHER;
pub const PM_APP_GENRE_INVALID = PM_APP_GENRE.INVALID;

pub const PM_APPLICATION_INSTALL_TYPE = enum(i32) {
    NORMAL = 0,
    IN_ROM = 1,
    PA = 2,
    DEBUG = 3,
    ENTERPRISE = 4,
    INVALID = 5,
};
pub const PM_APPLICATION_INSTALL_NORMAL = PM_APPLICATION_INSTALL_TYPE.NORMAL;
pub const PM_APPLICATION_INSTALL_IN_ROM = PM_APPLICATION_INSTALL_TYPE.IN_ROM;
pub const PM_APPLICATION_INSTALL_PA = PM_APPLICATION_INSTALL_TYPE.PA;
pub const PM_APPLICATION_INSTALL_DEBUG = PM_APPLICATION_INSTALL_TYPE.DEBUG;
pub const PM_APPLICATION_INSTALL_ENTERPRISE = PM_APPLICATION_INSTALL_TYPE.ENTERPRISE;
pub const PM_APPLICATION_INSTALL_INVALID = PM_APPLICATION_INSTALL_TYPE.INVALID;

pub const PM_APPLICATION_STATE = enum(i32) {
    MIN = 0,
    INSTALLED = 1,
    INSTALLING = 2,
    UPDATING = 3,
    UNINSTALLING = 4,
    LICENSE_UPDATING = 5,
    MOVING = 6,
    DISABLED_SD_CARD = 7,
    DISABLED_ENTERPRISE = 8,
    DISABLED_BACKING_UP = 9,
    DISABLED_MDIL_BINDING = 10,
    // MAX = 10, this enum value conflicts with DISABLED_MDIL_BINDING
    INVALID = 11,
};
pub const PM_APPLICATION_STATE_MIN = PM_APPLICATION_STATE.MIN;
pub const PM_APPLICATION_STATE_INSTALLED = PM_APPLICATION_STATE.INSTALLED;
pub const PM_APPLICATION_STATE_INSTALLING = PM_APPLICATION_STATE.INSTALLING;
pub const PM_APPLICATION_STATE_UPDATING = PM_APPLICATION_STATE.UPDATING;
pub const PM_APPLICATION_STATE_UNINSTALLING = PM_APPLICATION_STATE.UNINSTALLING;
pub const PM_APPLICATION_STATE_LICENSE_UPDATING = PM_APPLICATION_STATE.LICENSE_UPDATING;
pub const PM_APPLICATION_STATE_MOVING = PM_APPLICATION_STATE.MOVING;
pub const PM_APPLICATION_STATE_DISABLED_SD_CARD = PM_APPLICATION_STATE.DISABLED_SD_CARD;
pub const PM_APPLICATION_STATE_DISABLED_ENTERPRISE = PM_APPLICATION_STATE.DISABLED_ENTERPRISE;
pub const PM_APPLICATION_STATE_DISABLED_BACKING_UP = PM_APPLICATION_STATE.DISABLED_BACKING_UP;
pub const PM_APPLICATION_STATE_DISABLED_MDIL_BINDING = PM_APPLICATION_STATE.DISABLED_MDIL_BINDING;
pub const PM_APPLICATION_STATE_MAX = PM_APPLICATION_STATE.DISABLED_MDIL_BINDING;
pub const PM_APPLICATION_STATE_INVALID = PM_APPLICATION_STATE.INVALID;

pub const PM_APPLICATION_HUBTYPE = enum(i32) {
    NONMUSIC = 0,
    MUSIC = 1,
    INVALID = 2,
};
pub const PM_APPLICATION_HUBTYPE_NONMUSIC = PM_APPLICATION_HUBTYPE.NONMUSIC;
pub const PM_APPLICATION_HUBTYPE_MUSIC = PM_APPLICATION_HUBTYPE.MUSIC;
pub const PM_APPLICATION_HUBTYPE_INVALID = PM_APPLICATION_HUBTYPE.INVALID;

pub const PM_TILE_HUBTYPE = enum(i32) {
    MUSIC = 1,
    MOSETTINGS = 268435456,
    GAMES = 536870912,
    APPLIST = 1073741824,
    STARTMENU = -2147483648,
    LOCKSCREEN = 16777216,
    KIDZONE = 33554432,
    CACHED = 67108864,
    INVALID = 67108865,
};
pub const PM_TILE_HUBTYPE_MUSIC = PM_TILE_HUBTYPE.MUSIC;
pub const PM_TILE_HUBTYPE_MOSETTINGS = PM_TILE_HUBTYPE.MOSETTINGS;
pub const PM_TILE_HUBTYPE_GAMES = PM_TILE_HUBTYPE.GAMES;
pub const PM_TILE_HUBTYPE_APPLIST = PM_TILE_HUBTYPE.APPLIST;
pub const PM_TILE_HUBTYPE_STARTMENU = PM_TILE_HUBTYPE.STARTMENU;
pub const PM_TILE_HUBTYPE_LOCKSCREEN = PM_TILE_HUBTYPE.LOCKSCREEN;
pub const PM_TILE_HUBTYPE_KIDZONE = PM_TILE_HUBTYPE.KIDZONE;
pub const PM_TILE_HUBTYPE_CACHED = PM_TILE_HUBTYPE.CACHED;
pub const PM_TILE_HUBTYPE_INVALID = PM_TILE_HUBTYPE.INVALID;

pub const PM_STARTTILE_TYPE = enum(i32) {
    PRIMARY = 1,
    SECONDARY = 2,
    APPLIST = 3,
    APPLISTPRIMARY = 4,
    INVALID = 5,
};
pub const PM_STARTTILE_TYPE_PRIMARY = PM_STARTTILE_TYPE.PRIMARY;
pub const PM_STARTTILE_TYPE_SECONDARY = PM_STARTTILE_TYPE.SECONDARY;
pub const PM_STARTTILE_TYPE_APPLIST = PM_STARTTILE_TYPE.APPLIST;
pub const PM_STARTTILE_TYPE_APPLISTPRIMARY = PM_STARTTILE_TYPE.APPLISTPRIMARY;
pub const PM_STARTTILE_TYPE_INVALID = PM_STARTTILE_TYPE.INVALID;

pub const PM_TASK_TYPE = enum(i32) {
    NORMAL = 0,
    DEFAULT = 1,
    SETTINGS = 2,
    BACKGROUNDSERVICEAGENT = 3,
    BACKGROUNDWORKER = 4,
    INVALID = 5,
};
pub const PM_TASK_TYPE_NORMAL = PM_TASK_TYPE.NORMAL;
pub const PM_TASK_TYPE_DEFAULT = PM_TASK_TYPE.DEFAULT;
pub const PM_TASK_TYPE_SETTINGS = PM_TASK_TYPE.SETTINGS;
pub const PM_TASK_TYPE_BACKGROUNDSERVICEAGENT = PM_TASK_TYPE.BACKGROUNDSERVICEAGENT;
pub const PM_TASK_TYPE_BACKGROUNDWORKER = PM_TASK_TYPE.BACKGROUNDWORKER;
pub const PM_TASK_TYPE_INVALID = PM_TASK_TYPE.INVALID;

pub const PACKMAN_RUNTIME = enum(i32) {
    NATIVE = 1,
    SILVERLIGHTMOBILE = 2,
    XNA = 3,
    MODERN_NATIVE = 4,
    JUPITER = 5,
    INVALID = 6,
};
pub const PACKMAN_RUNTIME_NATIVE = PACKMAN_RUNTIME.NATIVE;
pub const PACKMAN_RUNTIME_SILVERLIGHTMOBILE = PACKMAN_RUNTIME.SILVERLIGHTMOBILE;
pub const PACKMAN_RUNTIME_XNA = PACKMAN_RUNTIME.XNA;
pub const PACKMAN_RUNTIME_MODERN_NATIVE = PACKMAN_RUNTIME.MODERN_NATIVE;
pub const PACKMAN_RUNTIME_JUPITER = PACKMAN_RUNTIME.JUPITER;
pub const PACKMAN_RUNTIME_INVALID = PACKMAN_RUNTIME.INVALID;

pub const PM_ACTIVATION_POLICY = enum(i32) {
    RESUME = 0,
    RESUMESAMEPARAMS = 1,
    REPLACE = 2,
    REPLACESAMEPARAMS = 3,
    MULTISESSION = 4,
    REPLACE_IGNOREFOREGROUND = 5,
    UNKNOWN = 6,
    INVALID = 7,
};
pub const PM_ACTIVATION_POLICY_RESUME = PM_ACTIVATION_POLICY.RESUME;
pub const PM_ACTIVATION_POLICY_RESUMESAMEPARAMS = PM_ACTIVATION_POLICY.RESUMESAMEPARAMS;
pub const PM_ACTIVATION_POLICY_REPLACE = PM_ACTIVATION_POLICY.REPLACE;
pub const PM_ACTIVATION_POLICY_REPLACESAMEPARAMS = PM_ACTIVATION_POLICY.REPLACESAMEPARAMS;
pub const PM_ACTIVATION_POLICY_MULTISESSION = PM_ACTIVATION_POLICY.MULTISESSION;
pub const PM_ACTIVATION_POLICY_REPLACE_IGNOREFOREGROUND = PM_ACTIVATION_POLICY.REPLACE_IGNOREFOREGROUND;
pub const PM_ACTIVATION_POLICY_UNKNOWN = PM_ACTIVATION_POLICY.UNKNOWN;
pub const PM_ACTIVATION_POLICY_INVALID = PM_ACTIVATION_POLICY.INVALID;

pub const PM_TASK_TRANSITION = enum(i32) {
    DEFAULT = 0,
    NONE = 1,
    TURNSTILE = 2,
    SLIDE = 3,
    SWIVEL = 4,
    READERBOARD = 5,
    CUSTOM = 6,
    INVALID = 7,
};
pub const PM_TASK_TRANSITION_DEFAULT = PM_TASK_TRANSITION.DEFAULT;
pub const PM_TASK_TRANSITION_NONE = PM_TASK_TRANSITION.NONE;
pub const PM_TASK_TRANSITION_TURNSTILE = PM_TASK_TRANSITION.TURNSTILE;
pub const PM_TASK_TRANSITION_SLIDE = PM_TASK_TRANSITION.SLIDE;
pub const PM_TASK_TRANSITION_SWIVEL = PM_TASK_TRANSITION.SWIVEL;
pub const PM_TASK_TRANSITION_READERBOARD = PM_TASK_TRANSITION.READERBOARD;
pub const PM_TASK_TRANSITION_CUSTOM = PM_TASK_TRANSITION.CUSTOM;
pub const PM_TASK_TRANSITION_INVALID = PM_TASK_TRANSITION.INVALID;

pub const PM_ENUM_APP_FILTER = enum(i32) {
    ALL = 0,
    VISIBLE = 1,
    GENRE = 2,
    NONGAMES = 3,
    HUBTYPE = 4,
    PINABLEONKIDZONE = 5,
    ALL_INCLUDE_MODERN = 6,
    FRAMEWORK = 7,
    MAX = 8,
};
pub const PM_APP_FILTER_ALL = PM_ENUM_APP_FILTER.ALL;
pub const PM_APP_FILTER_VISIBLE = PM_ENUM_APP_FILTER.VISIBLE;
pub const PM_APP_FILTER_GENRE = PM_ENUM_APP_FILTER.GENRE;
pub const PM_APP_FILTER_NONGAMES = PM_ENUM_APP_FILTER.NONGAMES;
pub const PM_APP_FILTER_HUBTYPE = PM_ENUM_APP_FILTER.HUBTYPE;
pub const PM_APP_FILTER_PINABLEONKIDZONE = PM_ENUM_APP_FILTER.PINABLEONKIDZONE;
pub const PM_APP_FILTER_ALL_INCLUDE_MODERN = PM_ENUM_APP_FILTER.ALL_INCLUDE_MODERN;
pub const PM_APP_FILTER_FRAMEWORK = PM_ENUM_APP_FILTER.FRAMEWORK;
pub const PM_APP_FILTER_MAX = PM_ENUM_APP_FILTER.MAX;

pub const PM_ENUM_TILE_FILTER = enum(i32) {
    APPLIST = 8,
    PINNED = 9,
    HUBTYPE = 10,
    APP_ALL = 11,
    MAX = 12,
};
pub const PM_TILE_FILTER_APPLIST = PM_ENUM_TILE_FILTER.APPLIST;
pub const PM_TILE_FILTER_PINNED = PM_ENUM_TILE_FILTER.PINNED;
pub const PM_TILE_FILTER_HUBTYPE = PM_ENUM_TILE_FILTER.HUBTYPE;
pub const PM_TILE_FILTER_APP_ALL = PM_ENUM_TILE_FILTER.APP_ALL;
pub const PM_TILE_FILTER_MAX = PM_ENUM_TILE_FILTER.MAX;

pub const PM_ENUM_TASK_FILTER = enum(i32) {
    APP_ALL = 12,
    TASK_TYPE = 13,
    DEHYD_SUPRESSING = 14,
    APP_TASK_TYPE = 15,
    BGEXECUTION = 16,
    MAX = 17,
};
pub const PM_TASK_FILTER_APP_ALL = PM_ENUM_TASK_FILTER.APP_ALL;
pub const PM_TASK_FILTER_TASK_TYPE = PM_ENUM_TASK_FILTER.TASK_TYPE;
pub const PM_TASK_FILTER_DEHYD_SUPRESSING = PM_ENUM_TASK_FILTER.DEHYD_SUPRESSING;
pub const PM_TASK_FILTER_APP_TASK_TYPE = PM_ENUM_TASK_FILTER.APP_TASK_TYPE;
pub const PM_TASK_FILTER_BGEXECUTION = PM_ENUM_TASK_FILTER.BGEXECUTION;
pub const PM_TASK_FILTER_MAX = PM_ENUM_TASK_FILTER.MAX;

pub const PM_ENUM_EXTENSION_FILTER = enum(i32) {
    BY_CONSUMER = 17,
    // APPCONNECT = 17, this enum value conflicts with BY_CONSUMER
    PROTOCOL_ALL = 18,
    FTASSOC_FILETYPE_ALL = 19,
    FTASSOC_CONTENTTYPE_ALL = 20,
    FTASSOC_APPLICATION_ALL = 21,
    SHARETARGET_ALL = 22,
    FILEOPENPICKER_ALL = 23,
    FILESAVEPICKER_ALL = 24,
    CACHEDFILEUPDATER_ALL = 25,
    MAX = 26,
};
pub const PM_ENUM_EXTENSION_FILTER_BY_CONSUMER = PM_ENUM_EXTENSION_FILTER.BY_CONSUMER;
pub const PM_ENUM_EXTENSION_FILTER_APPCONNECT = PM_ENUM_EXTENSION_FILTER.BY_CONSUMER;
pub const PM_ENUM_EXTENSION_FILTER_PROTOCOL_ALL = PM_ENUM_EXTENSION_FILTER.PROTOCOL_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FTASSOC_FILETYPE_ALL = PM_ENUM_EXTENSION_FILTER.FTASSOC_FILETYPE_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FTASSOC_CONTENTTYPE_ALL = PM_ENUM_EXTENSION_FILTER.FTASSOC_CONTENTTYPE_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FTASSOC_APPLICATION_ALL = PM_ENUM_EXTENSION_FILTER.FTASSOC_APPLICATION_ALL;
pub const PM_ENUM_EXTENSION_FILTER_SHARETARGET_ALL = PM_ENUM_EXTENSION_FILTER.SHARETARGET_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FILEOPENPICKER_ALL = PM_ENUM_EXTENSION_FILTER.FILEOPENPICKER_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FILESAVEPICKER_ALL = PM_ENUM_EXTENSION_FILTER.FILESAVEPICKER_ALL;
pub const PM_ENUM_EXTENSION_FILTER_CACHEDFILEUPDATER_ALL = PM_ENUM_EXTENSION_FILTER.CACHEDFILEUPDATER_ALL;
pub const PM_ENUM_EXTENSION_FILTER_MAX = PM_ENUM_EXTENSION_FILTER.MAX;

pub const PM_ENUM_BSA_FILTER = enum(i32) {
    ALL = 26,
    BY_TASKID = 27,
    BY_PRODUCTID = 28,
    BY_PERIODIC = 29,
    BY_ALL_LAUNCHONBOOT = 30,
    MAX = 31,
};
pub const PM_ENUM_BSA_FILTER_ALL = PM_ENUM_BSA_FILTER.ALL;
pub const PM_ENUM_BSA_FILTER_BY_TASKID = PM_ENUM_BSA_FILTER.BY_TASKID;
pub const PM_ENUM_BSA_FILTER_BY_PRODUCTID = PM_ENUM_BSA_FILTER.BY_PRODUCTID;
pub const PM_ENUM_BSA_FILTER_BY_PERIODIC = PM_ENUM_BSA_FILTER.BY_PERIODIC;
pub const PM_ENUM_BSA_FILTER_BY_ALL_LAUNCHONBOOT = PM_ENUM_BSA_FILTER.BY_ALL_LAUNCHONBOOT;
pub const PM_ENUM_BSA_FILTER_MAX = PM_ENUM_BSA_FILTER.MAX;

pub const PM_ENUM_BW_FILTER = enum(i32) {
    BOOTWORKER_ALL = 31,
    BY_TASKID = 32,
    MAX = 33,
};
pub const PM_ENUM_BW_FILTER_BOOTWORKER_ALL = PM_ENUM_BW_FILTER.BOOTWORKER_ALL;
pub const PM_ENUM_BW_FILTER_BY_TASKID = PM_ENUM_BW_FILTER.BY_TASKID;
pub const PM_ENUM_BW_FILTER_MAX = PM_ENUM_BW_FILTER.MAX;

pub const _tagAPPTASKTYPE = extern struct {
    ProductID: Guid,
    TaskType: PM_TASK_TYPE,
};

pub const PM_EXTENSIONCONSUMER = extern struct {
    ConsumerPID: Guid,
    ExtensionID: ?BSTR,
};

pub const PM_BSATASKID = extern struct {
    ProductID: Guid,
    TaskID: ?BSTR,
};

pub const PM_BWTASKID = extern struct {
    ProductID: Guid,
    TaskID: ?BSTR,
};

pub const PM_ENUM_FILTER = extern struct {
    FilterType: i32,
    FilterParameter: extern union {
        Dummy: i32,
        Genre: PM_APP_GENRE,
        AppHubType: PM_APPLICATION_HUBTYPE,
        HubType: PM_TILE_HUBTYPE,
        Tasktype: PM_TASK_TYPE,
        TaskProductID: Guid,
        TileProductID: Guid,
        AppTaskType: _tagAPPTASKTYPE,
        Consumer: PM_EXTENSIONCONSUMER,
        BSATask: PM_BSATASKID,
        BSAProductID: Guid,
        BWTask: PM_BWTASKID,
        ProtocolName: ?BSTR,
        FileType: ?BSTR,
        ContentType: ?BSTR,
        AppSupportedFileExtPID: Guid,
        ShareTargetFileType: ?BSTR,
    },
};

pub const PM_LIVETILE_RECURRENCE_TYPE = enum(i32) {
    INSTANT = 0,
    ONETIME = 1,
    INTERVAL = 2,
    // MAX = 2, this enum value conflicts with INTERVAL
};
pub const PM_LIVETILE_RECURRENCE_TYPE_INSTANT = PM_LIVETILE_RECURRENCE_TYPE.INSTANT;
pub const PM_LIVETILE_RECURRENCE_TYPE_ONETIME = PM_LIVETILE_RECURRENCE_TYPE.ONETIME;
pub const PM_LIVETILE_RECURRENCE_TYPE_INTERVAL = PM_LIVETILE_RECURRENCE_TYPE.INTERVAL;
pub const PM_LIVETILE_RECURRENCE_TYPE_MAX = PM_LIVETILE_RECURRENCE_TYPE.INTERVAL;

pub const PM_TILE_SIZE = enum(i32) {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    SQUARE310X310 = 3,
    TALL150X310 = 4,
    INVALID = 5,
};
pub const PM_TILE_SIZE_SMALL = PM_TILE_SIZE.SMALL;
pub const PM_TILE_SIZE_MEDIUM = PM_TILE_SIZE.MEDIUM;
pub const PM_TILE_SIZE_LARGE = PM_TILE_SIZE.LARGE;
pub const PM_TILE_SIZE_SQUARE310X310 = PM_TILE_SIZE.SQUARE310X310;
pub const PM_TILE_SIZE_TALL150X310 = PM_TILE_SIZE.TALL150X310;
pub const PM_TILE_SIZE_INVALID = PM_TILE_SIZE.INVALID;

pub const PM_LOGO_SIZE = enum(i32) {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    INVALID = 3,
};
pub const PM_LOGO_SIZE_SMALL = PM_LOGO_SIZE.SMALL;
pub const PM_LOGO_SIZE_MEDIUM = PM_LOGO_SIZE.MEDIUM;
pub const PM_LOGO_SIZE_LARGE = PM_LOGO_SIZE.LARGE;
pub const PM_LOGO_SIZE_INVALID = PM_LOGO_SIZE.INVALID;

pub const PM_STARTAPPBLOB = extern struct {
    cbSize: u32,
    ProductID: Guid,
    AppTitle: ?BSTR,
    IconPath: ?BSTR,
    IsUninstallable: BOOL,
    AppInstallType: PM_APPLICATION_INSTALL_TYPE,
    InstanceID: Guid,
    State: PM_APPLICATION_STATE,
    IsModern: BOOL,
    IsModernLightUp: BOOL,
    LightUpSupportMask: u16,
};

pub const PM_INVOCATIONINFO = extern struct {
    URIBaseOrAUMID: ?BSTR,
    URIFragmentOrArgs: ?BSTR,
};

pub const PM_STARTTILEBLOB = extern struct {
    cbSize: u32,
    ProductID: Guid,
    TileID: ?BSTR,
    TemplateType: TILE_TEMPLATE_TYPE,
    HubPosition: [32]u32,
    HubVisibilityBitmask: u32,
    IsDefault: BOOL,
    TileType: PM_STARTTILE_TYPE,
    pbPropBlob: ?*u8,
    cbPropBlob: u32,
    IsRestoring: BOOL,
    IsModern: BOOL,
    InvocationInfo: PM_INVOCATIONINFO,
};

pub const PM_INSTALLINFO = extern struct {
    ProductID: Guid,
    PackagePath: ?BSTR,
    InstanceID: Guid,
    pbLicense: ?*u8,
    cbLicense: u32,
    IsUninstallDisabled: BOOL,
    DeploymentOptions: u32,
    OfferID: Guid,
    MarketplaceAppVersion: ?BSTR,
};

pub const PM_UPDATEINFO_LEGACY = extern struct {
    ProductID: Guid,
    PackagePath: ?BSTR,
    InstanceID: Guid,
    pbLicense: ?*u8,
    cbLicense: u32,
    MarketplaceAppVersion: ?BSTR,
};

pub const PM_UPDATEINFO = extern struct {
    ProductID: Guid,
    PackagePath: ?BSTR,
    InstanceID: Guid,
    pbLicense: ?*u8,
    cbLicense: u32,
    MarketplaceAppVersion: ?BSTR,
    DeploymentOptions: u32,
};

const IID_IPMApplicationInfo_Value = @import("../zig.zig").Guid.initString("50afb58a-438c-4088-9789-f8c4899829c7");
pub const IID_IPMApplicationInfo = &IID_IPMApplicationInfo_Value;
pub const IPMApplicationInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: fn(
            self: *const IPMApplicationInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstanceID: fn(
            self: *const IPMApplicationInfo,
            pInstanceID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OfferID: fn(
            self: *const IPMApplicationInfo,
            pOfferID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultTask: fn(
            self: *const IPMApplicationInfo,
            pDefaultTask: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppTitle: fn(
            self: *const IPMApplicationInfo,
            pAppTitle: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IconPath: fn(
            self: *const IPMApplicationInfo,
            pAppIconPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotificationState: fn(
            self: *const IPMApplicationInfo,
            pIsNotified: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppInstallType: fn(
            self: *const IPMApplicationInfo,
            pAppInstallType: ?*PM_APPLICATION_INSTALL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: fn(
            self: *const IPMApplicationInfo,
            pState: ?*PM_APPLICATION_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRevoked: fn(
            self: *const IPMApplicationInfo,
            pIsRevoked: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UpdateAvailable: fn(
            self: *const IPMApplicationInfo,
            pIsUpdateAvailable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallDate: fn(
            self: *const IPMApplicationInfo,
            pInstallDate: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsUninstallable: fn(
            self: *const IPMApplicationInfo,
            pIsUninstallable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsThemable: fn(
            self: *const IPMApplicationInfo,
            pIsThemable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsTrial: fn(
            self: *const IPMApplicationInfo,
            pIsTrial: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallPath: fn(
            self: *const IPMApplicationInfo,
            pInstallPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataRoot: fn(
            self: *const IPMApplicationInfo,
            pDataRoot: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Genre: fn(
            self: *const IPMApplicationInfo,
            pGenre: ?*PM_APP_GENRE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Publisher: fn(
            self: *const IPMApplicationInfo,
            pPublisher: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Author: fn(
            self: *const IPMApplicationInfo,
            pAuthor: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IPMApplicationInfo,
            pDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const IPMApplicationInfo,
            pVersion: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: fn(
            self: *const IPMApplicationInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMajorVersion: fn(
            self: *const IPMApplicationInfo,
            pMajorVer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMinorVersion: fn(
            self: *const IPMApplicationInfo,
            pMinorVer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PublisherID: fn(
            self: *const IPMApplicationInfo,
            pPublisherID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsMultiCore: fn(
            self: *const IPMApplicationInfo,
            pIsMultiCore: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SID: fn(
            self: *const IPMApplicationInfo,
            pSID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMajorVersionLightUp: fn(
            self: *const IPMApplicationInfo,
            pMajorVer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMinorVersionLightUp: fn(
            self: *const IPMApplicationInfo,
            pMinorVer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_UpdateAvailable: fn(
            self: *const IPMApplicationInfo,
            IsUpdateAvailable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_NotificationState: fn(
            self: *const IPMApplicationInfo,
            IsNotified: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IconPath: fn(
            self: *const IPMApplicationInfo,
            AppIconPath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_UninstallableState: fn(
            self: *const IPMApplicationInfo,
            IsUninstallable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsPinableOnKidZone: fn(
            self: *const IPMApplicationInfo,
            pIsPinable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOriginallyPreInstalled: fn(
            self: *const IPMApplicationInfo,
            pIsPreinstalled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInstallOnSD: fn(
            self: *const IPMApplicationInfo,
            pIsInstallOnSD: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOptoutOnSD: fn(
            self: *const IPMApplicationInfo,
            pIsOptoutOnSD: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOptoutBackupRestore: fn(
            self: *const IPMApplicationInfo,
            pIsOptoutBackupRestore: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_EnterpriseDisabled: fn(
            self: *const IPMApplicationInfo,
            IsDisabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_EnterpriseUninstallable: fn(
            self: *const IPMApplicationInfo,
            IsUninstallable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnterpriseDisabled: fn(
            self: *const IPMApplicationInfo,
            IsDisabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnterpriseUninstallable: fn(
            self: *const IPMApplicationInfo,
            IsUninstallable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsVisibleOnAppList: fn(
            self: *const IPMApplicationInfo,
            pIsVisible: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInboxApp: fn(
            self: *const IPMApplicationInfo,
            pIsInboxApp: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StorageID: fn(
            self: *const IPMApplicationInfo,
            pStorageID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAppBlob: fn(
            self: *const IPMApplicationInfo,
            pBlob: ?*PM_STARTAPPBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsMovable: fn(
            self: *const IPMApplicationInfo,
            pIsMovable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeploymentAppEnumerationHubFilter: fn(
            self: *const IPMApplicationInfo,
            HubType: ?*PM_TILE_HUBTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModifiedDate: fn(
            self: *const IPMApplicationInfo,
            pModifiedDate: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOriginallyRestored: fn(
            self: *const IPMApplicationInfo,
            pIsRestored: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ShouldDeferMdilBind: fn(
            self: *const IPMApplicationInfo,
            pfDeferMdilBind: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFullyPreInstall: fn(
            self: *const IPMApplicationInfo,
            pfIsFullyPreInstall: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsMdilMaintenanceNeeded: fn(
            self: *const IPMApplicationInfo,
            fIsMdilMaintenanceNeeded: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_Title: fn(
            self: *const IPMApplicationInfo,
            AppTitle: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_ProductID(self: *const T, pProductID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_ProductID(@ptrCast(*const IPMApplicationInfo, self), pProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_InstanceID(self: *const T, pInstanceID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_InstanceID(@ptrCast(*const IPMApplicationInfo, self), pInstanceID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_OfferID(self: *const T, pOfferID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_OfferID(@ptrCast(*const IPMApplicationInfo, self), pOfferID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_DefaultTask(self: *const T, pDefaultTask: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_DefaultTask(@ptrCast(*const IPMApplicationInfo, self), pDefaultTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_AppTitle(self: *const T, pAppTitle: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_AppTitle(@ptrCast(*const IPMApplicationInfo, self), pAppTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IconPath(self: *const T, pAppIconPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IconPath(@ptrCast(*const IPMApplicationInfo, self), pAppIconPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_NotificationState(self: *const T, pIsNotified: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_NotificationState(@ptrCast(*const IPMApplicationInfo, self), pIsNotified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_AppInstallType(self: *const T, pAppInstallType: ?*PM_APPLICATION_INSTALL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_AppInstallType(@ptrCast(*const IPMApplicationInfo, self), pAppInstallType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_State(self: *const T, pState: ?*PM_APPLICATION_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_State(@ptrCast(*const IPMApplicationInfo, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsRevoked(self: *const T, pIsRevoked: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsRevoked(@ptrCast(*const IPMApplicationInfo, self), pIsRevoked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_UpdateAvailable(self: *const T, pIsUpdateAvailable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_UpdateAvailable(@ptrCast(*const IPMApplicationInfo, self), pIsUpdateAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_InstallDate(self: *const T, pInstallDate: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_InstallDate(@ptrCast(*const IPMApplicationInfo, self), pInstallDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsUninstallable(self: *const T, pIsUninstallable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsUninstallable(@ptrCast(*const IPMApplicationInfo, self), pIsUninstallable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsThemable(self: *const T, pIsThemable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsThemable(@ptrCast(*const IPMApplicationInfo, self), pIsThemable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsTrial(self: *const T, pIsTrial: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsTrial(@ptrCast(*const IPMApplicationInfo, self), pIsTrial);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_InstallPath(self: *const T, pInstallPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_InstallPath(@ptrCast(*const IPMApplicationInfo, self), pInstallPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_DataRoot(self: *const T, pDataRoot: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_DataRoot(@ptrCast(*const IPMApplicationInfo, self), pDataRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_Genre(self: *const T, pGenre: ?*PM_APP_GENRE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_Genre(@ptrCast(*const IPMApplicationInfo, self), pGenre);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_Publisher(self: *const T, pPublisher: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_Publisher(@ptrCast(*const IPMApplicationInfo, self), pPublisher);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_Author(self: *const T, pAuthor: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_Author(@ptrCast(*const IPMApplicationInfo, self), pAuthor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_Description(self: *const T, pDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_Description(@ptrCast(*const IPMApplicationInfo, self), pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_Version(self: *const T, pVersion: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_Version(@ptrCast(*const IPMApplicationInfo, self), pVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_InvocationInfo(self: *const T, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_InvocationInfo(@ptrCast(*const IPMApplicationInfo, self), pImageUrn, pParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_AppPlatMajorVersion(self: *const T, pMajorVer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_AppPlatMajorVersion(@ptrCast(*const IPMApplicationInfo, self), pMajorVer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_AppPlatMinorVersion(self: *const T, pMinorVer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_AppPlatMinorVersion(@ptrCast(*const IPMApplicationInfo, self), pMinorVer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_PublisherID(self: *const T, pPublisherID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_PublisherID(@ptrCast(*const IPMApplicationInfo, self), pPublisherID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsMultiCore(self: *const T, pIsMultiCore: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsMultiCore(@ptrCast(*const IPMApplicationInfo, self), pIsMultiCore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_SID(self: *const T, pSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_SID(@ptrCast(*const IPMApplicationInfo, self), pSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_AppPlatMajorVersionLightUp(self: *const T, pMajorVer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_AppPlatMajorVersionLightUp(@ptrCast(*const IPMApplicationInfo, self), pMajorVer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_AppPlatMinorVersionLightUp(self: *const T, pMinorVer: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_AppPlatMinorVersionLightUp(@ptrCast(*const IPMApplicationInfo, self), pMinorVer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_set_UpdateAvailable(self: *const T, IsUpdateAvailable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).set_UpdateAvailable(@ptrCast(*const IPMApplicationInfo, self), IsUpdateAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_set_NotificationState(self: *const T, IsNotified: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).set_NotificationState(@ptrCast(*const IPMApplicationInfo, self), IsNotified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_set_IconPath(self: *const T, AppIconPath: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).set_IconPath(@ptrCast(*const IPMApplicationInfo, self), AppIconPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_set_UninstallableState(self: *const T, IsUninstallable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).set_UninstallableState(@ptrCast(*const IPMApplicationInfo, self), IsUninstallable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsPinableOnKidZone(self: *const T, pIsPinable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsPinableOnKidZone(@ptrCast(*const IPMApplicationInfo, self), pIsPinable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsOriginallyPreInstalled(self: *const T, pIsPreinstalled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsOriginallyPreInstalled(@ptrCast(*const IPMApplicationInfo, self), pIsPreinstalled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsInstallOnSD(self: *const T, pIsInstallOnSD: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsInstallOnSD(@ptrCast(*const IPMApplicationInfo, self), pIsInstallOnSD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsOptoutOnSD(self: *const T, pIsOptoutOnSD: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsOptoutOnSD(@ptrCast(*const IPMApplicationInfo, self), pIsOptoutOnSD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsOptoutBackupRestore(self: *const T, pIsOptoutBackupRestore: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsOptoutBackupRestore(@ptrCast(*const IPMApplicationInfo, self), pIsOptoutBackupRestore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_set_EnterpriseDisabled(self: *const T, IsDisabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).set_EnterpriseDisabled(@ptrCast(*const IPMApplicationInfo, self), IsDisabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_set_EnterpriseUninstallable(self: *const T, IsUninstallable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).set_EnterpriseUninstallable(@ptrCast(*const IPMApplicationInfo, self), IsUninstallable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_EnterpriseDisabled(self: *const T, IsDisabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_EnterpriseDisabled(@ptrCast(*const IPMApplicationInfo, self), IsDisabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_EnterpriseUninstallable(self: *const T, IsUninstallable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_EnterpriseUninstallable(@ptrCast(*const IPMApplicationInfo, self), IsUninstallable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsVisibleOnAppList(self: *const T, pIsVisible: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsVisibleOnAppList(@ptrCast(*const IPMApplicationInfo, self), pIsVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsInboxApp(self: *const T, pIsInboxApp: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsInboxApp(@ptrCast(*const IPMApplicationInfo, self), pIsInboxApp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_StorageID(self: *const T, pStorageID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_StorageID(@ptrCast(*const IPMApplicationInfo, self), pStorageID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_StartAppBlob(self: *const T, pBlob: ?*PM_STARTAPPBLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_StartAppBlob(@ptrCast(*const IPMApplicationInfo, self), pBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsMovable(self: *const T, pIsMovable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsMovable(@ptrCast(*const IPMApplicationInfo, self), pIsMovable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_DeploymentAppEnumerationHubFilter(self: *const T, HubType: ?*PM_TILE_HUBTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_DeploymentAppEnumerationHubFilter(@ptrCast(*const IPMApplicationInfo, self), HubType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_ModifiedDate(self: *const T, pModifiedDate: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_ModifiedDate(@ptrCast(*const IPMApplicationInfo, self), pModifiedDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsOriginallyRestored(self: *const T, pIsRestored: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsOriginallyRestored(@ptrCast(*const IPMApplicationInfo, self), pIsRestored);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_ShouldDeferMdilBind(self: *const T, pfDeferMdilBind: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_ShouldDeferMdilBind(@ptrCast(*const IPMApplicationInfo, self), pfDeferMdilBind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_get_IsFullyPreInstall(self: *const T, pfIsFullyPreInstall: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).get_IsFullyPreInstall(@ptrCast(*const IPMApplicationInfo, self), pfIsFullyPreInstall);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_set_IsMdilMaintenanceNeeded(self: *const T, fIsMdilMaintenanceNeeded: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).set_IsMdilMaintenanceNeeded(@ptrCast(*const IPMApplicationInfo, self), fIsMdilMaintenanceNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfo_set_Title(self: *const T, AppTitle: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfo.VTable, self.vtable).set_Title(@ptrCast(*const IPMApplicationInfo, self), AppTitle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTilePropertyInfo_Value = @import("../zig.zig").Guid.initString("6c2b8017-1efa-42a7-86c0-6d4b640bf528");
pub const IID_IPMTilePropertyInfo = &IID_IPMTilePropertyInfo_Value;
pub const IPMTilePropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyID: fn(
            self: *const IPMTilePropertyInfo,
            pPropID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyValue: fn(
            self: *const IPMTilePropertyInfo,
            pPropValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_Property: fn(
            self: *const IPMTilePropertyInfo,
            PropValue: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTilePropertyInfo_get_PropertyID(self: *const T, pPropID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTilePropertyInfo.VTable, self.vtable).get_PropertyID(@ptrCast(*const IPMTilePropertyInfo, self), pPropID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTilePropertyInfo_get_PropertyValue(self: *const T, pPropValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTilePropertyInfo.VTable, self.vtable).get_PropertyValue(@ptrCast(*const IPMTilePropertyInfo, self), pPropValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTilePropertyInfo_set_Property(self: *const T, PropValue: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTilePropertyInfo.VTable, self.vtable).set_Property(@ptrCast(*const IPMTilePropertyInfo, self), PropValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTilePropertyEnumerator_Value = @import("../zig.zig").Guid.initString("cc4cd629-9047-4250-aac8-930e47812421");
pub const IID_IPMTilePropertyEnumerator = &IID_IPMTilePropertyEnumerator_Value;
pub const IPMTilePropertyEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: fn(
            self: *const IPMTilePropertyEnumerator,
            ppPropInfo: ?*?*IPMTilePropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTilePropertyEnumerator_get_Next(self: *const T, ppPropInfo: ?*?*IPMTilePropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTilePropertyEnumerator.VTable, self.vtable).get_Next(@ptrCast(*const IPMTilePropertyEnumerator, self), ppPropInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTileInfo_Value = @import("../zig.zig").Guid.initString("d1604833-2b08-4001-82cd-183ad734f752");
pub const IID_IPMTileInfo = &IID_IPMTileInfo_Value;
pub const IPMTileInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: fn(
            self: *const IPMTileInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileID: fn(
            self: *const IPMTileInfo,
            pTileID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TemplateType: fn(
            self: *const IPMTileInfo,
            pTemplateType: ?*TILE_TEMPLATE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HubPinnedState: fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            pPinned: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HubPosition: fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            pPosition: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsNotified: fn(
            self: *const IPMTileInfo,
            pIsNotified: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDefault: fn(
            self: *const IPMTileInfo,
            pIsDefault: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: fn(
            self: *const IPMTileInfo,
            pTaskID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileType: fn(
            self: *const IPMTileInfo,
            pStartTileType: ?*PM_STARTTILE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsThemable: fn(
            self: *const IPMTileInfo,
            pIsThemable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyById: fn(
            self: *const IPMTileInfo,
            PropID: u32,
            ppPropInfo: ?*?*IPMTilePropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: fn(
            self: *const IPMTileInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyEnum: fn(
            self: *const IPMTileInfo,
            ppTilePropEnum: ?*?*IPMTilePropertyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HubTileSize: fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            pSize: ?*PM_TILE_SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_HubPosition: fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            Position: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_NotifiedState: fn(
            self: *const IPMTileInfo,
            Notified: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_HubPinnedState: fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            Pinned: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_HubTileSize: fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            Size: PM_TILE_SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_InvocationInfo: fn(
            self: *const IPMTileInfo,
            TaskName: ?BSTR,
            TaskParameters: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTileBlob: fn(
            self: *const IPMTileInfo,
            pBlob: ?*PM_STARTTILEBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRestoring: fn(
            self: *const IPMTileInfo,
            pIsRestoring: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsAutoRestoreDisabled: fn(
            self: *const IPMTileInfo,
            pIsAutoRestoreDisabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsRestoring: fn(
            self: *const IPMTileInfo,
            Restoring: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsAutoRestoreDisabled: fn(
            self: *const IPMTileInfo,
            AutoRestoreDisabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_ProductID(self: *const T, pProductID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_ProductID(@ptrCast(*const IPMTileInfo, self), pProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_TileID(self: *const T, pTileID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_TileID(@ptrCast(*const IPMTileInfo, self), pTileID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_TemplateType(self: *const T, pTemplateType: ?*TILE_TEMPLATE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_TemplateType(@ptrCast(*const IPMTileInfo, self), pTemplateType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_HubPinnedState(self: *const T, HubType: PM_TILE_HUBTYPE, pPinned: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_HubPinnedState(@ptrCast(*const IPMTileInfo, self), HubType, pPinned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_HubPosition(self: *const T, HubType: PM_TILE_HUBTYPE, pPosition: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_HubPosition(@ptrCast(*const IPMTileInfo, self), HubType, pPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_IsNotified(self: *const T, pIsNotified: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_IsNotified(@ptrCast(*const IPMTileInfo, self), pIsNotified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_IsDefault(self: *const T, pIsDefault: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_IsDefault(@ptrCast(*const IPMTileInfo, self), pIsDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_TaskID(self: *const T, pTaskID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_TaskID(@ptrCast(*const IPMTileInfo, self), pTaskID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_TileType(self: *const T, pStartTileType: ?*PM_STARTTILE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_TileType(@ptrCast(*const IPMTileInfo, self), pStartTileType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_IsThemable(self: *const T, pIsThemable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_IsThemable(@ptrCast(*const IPMTileInfo, self), pIsThemable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_PropertyById(self: *const T, PropID: u32, ppPropInfo: ?*?*IPMTilePropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_PropertyById(@ptrCast(*const IPMTileInfo, self), PropID, ppPropInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_InvocationInfo(self: *const T, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_InvocationInfo(@ptrCast(*const IPMTileInfo, self), pImageUrn, pParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_PropertyEnum(self: *const T, ppTilePropEnum: ?*?*IPMTilePropertyEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_PropertyEnum(@ptrCast(*const IPMTileInfo, self), ppTilePropEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_HubTileSize(self: *const T, HubType: PM_TILE_HUBTYPE, pSize: ?*PM_TILE_SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_HubTileSize(@ptrCast(*const IPMTileInfo, self), HubType, pSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_set_HubPosition(self: *const T, HubType: PM_TILE_HUBTYPE, Position: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).set_HubPosition(@ptrCast(*const IPMTileInfo, self), HubType, Position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_set_NotifiedState(self: *const T, Notified: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).set_NotifiedState(@ptrCast(*const IPMTileInfo, self), Notified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_set_HubPinnedState(self: *const T, HubType: PM_TILE_HUBTYPE, Pinned: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).set_HubPinnedState(@ptrCast(*const IPMTileInfo, self), HubType, Pinned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_set_HubTileSize(self: *const T, HubType: PM_TILE_HUBTYPE, Size: PM_TILE_SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).set_HubTileSize(@ptrCast(*const IPMTileInfo, self), HubType, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_set_InvocationInfo(self: *const T, TaskName: ?BSTR, TaskParameters: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).set_InvocationInfo(@ptrCast(*const IPMTileInfo, self), TaskName, TaskParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_StartTileBlob(self: *const T, pBlob: ?*PM_STARTTILEBLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_StartTileBlob(@ptrCast(*const IPMTileInfo, self), pBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_IsRestoring(self: *const T, pIsRestoring: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_IsRestoring(@ptrCast(*const IPMTileInfo, self), pIsRestoring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_get_IsAutoRestoreDisabled(self: *const T, pIsAutoRestoreDisabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).get_IsAutoRestoreDisabled(@ptrCast(*const IPMTileInfo, self), pIsAutoRestoreDisabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_set_IsRestoring(self: *const T, Restoring: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).set_IsRestoring(@ptrCast(*const IPMTileInfo, self), Restoring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfo_set_IsAutoRestoreDisabled(self: *const T, AutoRestoreDisabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfo.VTable, self.vtable).set_IsAutoRestoreDisabled(@ptrCast(*const IPMTileInfo, self), AutoRestoreDisabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTileInfoEnumerator_Value = @import("../zig.zig").Guid.initString("ded83065-e462-4b2c-acb5-e39cea61c874");
pub const IID_IPMTileInfoEnumerator = &IID_IPMTileInfoEnumerator_Value;
pub const IPMTileInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: fn(
            self: *const IPMTileInfoEnumerator,
            ppTileInfo: ?*?*IPMTileInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTileInfoEnumerator_get_Next(self: *const T, ppTileInfo: ?*?*IPMTileInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTileInfoEnumerator.VTable, self.vtable).get_Next(@ptrCast(*const IPMTileInfoEnumerator, self), ppTileInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMApplicationInfoEnumerator_Value = @import("../zig.zig").Guid.initString("0ec42a96-4d46-4dc6-a3d9-a7acaac0f5fa");
pub const IID_IPMApplicationInfoEnumerator = &IID_IPMApplicationInfoEnumerator_Value;
pub const IPMApplicationInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: fn(
            self: *const IPMApplicationInfoEnumerator,
            ppAppInfo: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMApplicationInfoEnumerator_get_Next(self: *const T, ppAppInfo: ?*?*IPMApplicationInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMApplicationInfoEnumerator.VTable, self.vtable).get_Next(@ptrCast(*const IPMApplicationInfoEnumerator, self), ppAppInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMLiveTileJobInfo_Value = @import("../zig.zig").Guid.initString("6009a81f-4710-4697-b5f6-2208f6057b8e");
pub const IID_IPMLiveTileJobInfo = &IID_IPMLiveTileJobInfo_Value;
pub const IPMLiveTileJobInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: fn(
            self: *const IPMLiveTileJobInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileID: fn(
            self: *const IPMLiveTileJobInfo,
            pTileID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextSchedule: fn(
            self: *const IPMLiveTileJobInfo,
            pNextSchedule: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_NextSchedule: fn(
            self: *const IPMLiveTileJobInfo,
            ftNextSchedule: FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartSchedule: fn(
            self: *const IPMLiveTileJobInfo,
            pStartSchedule: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_StartSchedule: fn(
            self: *const IPMLiveTileJobInfo,
            ftStartSchedule: FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IntervalDuration: fn(
            self: *const IPMLiveTileJobInfo,
            pIntervalDuration: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IntervalDuration: fn(
            self: *const IPMLiveTileJobInfo,
            ulIntervalDuration: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunForever: fn(
            self: *const IPMLiveTileJobInfo,
            IsRunForever: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_RunForever: fn(
            self: *const IPMLiveTileJobInfo,
            fRunForever: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxRunCount: fn(
            self: *const IPMLiveTileJobInfo,
            pMaxRunCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_MaxRunCount: fn(
            self: *const IPMLiveTileJobInfo,
            ulMaxRunCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunCount: fn(
            self: *const IPMLiveTileJobInfo,
            pRunCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_RunCount: fn(
            self: *const IPMLiveTileJobInfo,
            ulRunCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecurrenceType: fn(
            self: *const IPMLiveTileJobInfo,
            pRecurrenceType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_RecurrenceType: fn(
            self: *const IPMLiveTileJobInfo,
            ulRecurrenceType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileXML: fn(
            self: *const IPMLiveTileJobInfo,
            pTileXml: ?[*]?*u8,
            pcbTileXml: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_TileXML: fn(
            self: *const IPMLiveTileJobInfo,
            pTileXml: [*:0]u8,
            cbTileXml: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UrlXML: fn(
            self: *const IPMLiveTileJobInfo,
            pUrlXML: ?[*]?*u8,
            pcbUrlXML: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_UrlXML: fn(
            self: *const IPMLiveTileJobInfo,
            pUrlXML: [*:0]u8,
            cbUrlXML: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttemptCount: fn(
            self: *const IPMLiveTileJobInfo,
            pAttemptCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_AttemptCount: fn(
            self: *const IPMLiveTileJobInfo,
            ulAttemptCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadState: fn(
            self: *const IPMLiveTileJobInfo,
            pDownloadState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_DownloadState: fn(
            self: *const IPMLiveTileJobInfo,
            ulDownloadState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_ProductID(self: *const T, pProductID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_ProductID(@ptrCast(*const IPMLiveTileJobInfo, self), pProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_TileID(self: *const T, pTileID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_TileID(@ptrCast(*const IPMLiveTileJobInfo, self), pTileID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_NextSchedule(self: *const T, pNextSchedule: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_NextSchedule(@ptrCast(*const IPMLiveTileJobInfo, self), pNextSchedule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_NextSchedule(self: *const T, ftNextSchedule: FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_NextSchedule(@ptrCast(*const IPMLiveTileJobInfo, self), ftNextSchedule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_StartSchedule(self: *const T, pStartSchedule: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_StartSchedule(@ptrCast(*const IPMLiveTileJobInfo, self), pStartSchedule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_StartSchedule(self: *const T, ftStartSchedule: FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_StartSchedule(@ptrCast(*const IPMLiveTileJobInfo, self), ftStartSchedule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_IntervalDuration(self: *const T, pIntervalDuration: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_IntervalDuration(@ptrCast(*const IPMLiveTileJobInfo, self), pIntervalDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_IntervalDuration(self: *const T, ulIntervalDuration: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_IntervalDuration(@ptrCast(*const IPMLiveTileJobInfo, self), ulIntervalDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_RunForever(self: *const T, IsRunForever: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_RunForever(@ptrCast(*const IPMLiveTileJobInfo, self), IsRunForever);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_RunForever(self: *const T, fRunForever: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_RunForever(@ptrCast(*const IPMLiveTileJobInfo, self), fRunForever);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_MaxRunCount(self: *const T, pMaxRunCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_MaxRunCount(@ptrCast(*const IPMLiveTileJobInfo, self), pMaxRunCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_MaxRunCount(self: *const T, ulMaxRunCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_MaxRunCount(@ptrCast(*const IPMLiveTileJobInfo, self), ulMaxRunCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_RunCount(self: *const T, pRunCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_RunCount(@ptrCast(*const IPMLiveTileJobInfo, self), pRunCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_RunCount(self: *const T, ulRunCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_RunCount(@ptrCast(*const IPMLiveTileJobInfo, self), ulRunCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_RecurrenceType(self: *const T, pRecurrenceType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_RecurrenceType(@ptrCast(*const IPMLiveTileJobInfo, self), pRecurrenceType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_RecurrenceType(self: *const T, ulRecurrenceType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_RecurrenceType(@ptrCast(*const IPMLiveTileJobInfo, self), ulRecurrenceType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_TileXML(self: *const T, pTileXml: ?[*]?*u8, pcbTileXml: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_TileXML(@ptrCast(*const IPMLiveTileJobInfo, self), pTileXml, pcbTileXml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_TileXML(self: *const T, pTileXml: [*:0]u8, cbTileXml: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_TileXML(@ptrCast(*const IPMLiveTileJobInfo, self), pTileXml, cbTileXml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_UrlXML(self: *const T, pUrlXML: ?[*]?*u8, pcbUrlXML: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_UrlXML(@ptrCast(*const IPMLiveTileJobInfo, self), pUrlXML, pcbUrlXML);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_UrlXML(self: *const T, pUrlXML: [*:0]u8, cbUrlXML: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_UrlXML(@ptrCast(*const IPMLiveTileJobInfo, self), pUrlXML, cbUrlXML);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_AttemptCount(self: *const T, pAttemptCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_AttemptCount(@ptrCast(*const IPMLiveTileJobInfo, self), pAttemptCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_AttemptCount(self: *const T, ulAttemptCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_AttemptCount(@ptrCast(*const IPMLiveTileJobInfo, self), ulAttemptCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_get_DownloadState(self: *const T, pDownloadState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).get_DownloadState(@ptrCast(*const IPMLiveTileJobInfo, self), pDownloadState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfo_set_DownloadState(self: *const T, ulDownloadState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfo.VTable, self.vtable).set_DownloadState(@ptrCast(*const IPMLiveTileJobInfo, self), ulDownloadState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMLiveTileJobInfoEnumerator_Value = @import("../zig.zig").Guid.initString("bc042582-9415-4f36-9f99-06f104c07c03");
pub const IID_IPMLiveTileJobInfoEnumerator = &IID_IPMLiveTileJobInfoEnumerator_Value;
pub const IPMLiveTileJobInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: fn(
            self: *const IPMLiveTileJobInfoEnumerator,
            ppLiveTileJobInfo: ?*?*IPMLiveTileJobInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMLiveTileJobInfoEnumerator_get_Next(self: *const T, ppLiveTileJobInfo: ?*?*IPMLiveTileJobInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMLiveTileJobInfoEnumerator.VTable, self.vtable).get_Next(@ptrCast(*const IPMLiveTileJobInfoEnumerator, self), ppLiveTileJobInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMDeploymentManager_Value = @import("../zig.zig").Guid.initString("35f785fa-1979-4a8b-bc8f-fd70eb0d1544");
pub const IID_IPMDeploymentManager = &IID_IPMDeploymentManager_Value;
pub const IPMDeploymentManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportDownloadBegin: fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportDownloadProgress: fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            usProgress: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportDownloadComplete: fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            hrResult: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginInstall: fn(
            self: *const IPMDeploymentManager,
            pInstallInfo: ?*PM_INSTALLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdate: fn(
            self: *const IPMDeploymentManager,
            pUpdateInfo: ?*PM_UPDATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDeployPackage: fn(
            self: *const IPMDeploymentManager,
            pInstallInfo: ?*PM_INSTALLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdateDeployedPackageLegacy: fn(
            self: *const IPMDeploymentManager,
            pUpdateInfo: ?*PM_UPDATEINFO_LEGACY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUninstall: fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEnterpriseAppInstall: fn(
            self: *const IPMDeploymentManager,
            pInstallInfo: ?*PM_INSTALLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEnterpriseAppUpdate: fn(
            self: *const IPMDeploymentManager,
            pUpdateInfo: ?*PM_UPDATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdateLicense: fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            offerID: Guid,
            pbLicense: [*:0]u8,
            cbLicense: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseChallenge: fn(
            self: *const IPMDeploymentManager,
            PackagePath: ?BSTR,
            ppbChallenge: ?[*]?*u8,
            pcbChallenge: ?*u32,
            ppbKID: ?[*]?*u8,
            pcbKID: ?*u32,
            ppbDeviceID: ?[*]?*u8,
            pcbDeviceID: ?*u32,
            ppbSaltValue: ?[*]?*u8,
            pcbSaltValue: ?*u32,
            ppbKGVValue: ?[*]?*u8,
            pcbKGVValue: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseChallengeByProductID: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            ppbChallenge: ?[*]?*u8,
            pcbLicense: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseChallengeByProductID2: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            ppbChallenge: ?[*]?*u8,
            pcbLicense: ?*u32,
            ppbKID: ?[*]?*u8,
            pcbKID: ?*u32,
            ppbDeviceID: ?[*]?*u8,
            pcbDeviceID: ?*u32,
            ppbSaltValue: ?[*]?*u8,
            pcbSaltValue: ?*u32,
            ppbKGVValue: ?[*]?*u8,
            pcbKGVValue: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeLicense: fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RebindMdilBinaries: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            FileNames: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RebindAllMdilBinaries: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            InstanceID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegenerateXbf: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            AssemblyPaths: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateXbfForCurrentLocale: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginProvision: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            XMLpath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDeprovision: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReindexSQLCEDatabases: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationsNeedMaintenance: fn(
            self: *const IPMDeploymentManager,
            RequiredMaintenanceOperations: u32,
            pcApplications: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateChamberProfile: fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnterprisePolicyIsApplicationAllowed: fn(
            self: *const IPMDeploymentManager,
            productId: Guid,
            publisherName: ?[*:0]const u16,
            pIsAllowed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdateDeployedPackage: fn(
            self: *const IPMDeploymentManager,
            pUpdateInfo: ?*PM_UPDATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportRestoreCancelled: fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveResourceString: fn(
            self: *const IPMDeploymentManager,
            resourceString: ?[*:0]const u16,
            pResolvedResourceString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateCapabilitiesForModernApps: fn(
            self: *const IPMDeploymentManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportDownloadStatusUpdate: fn(
            self: *const IPMDeploymentManager,
            productId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUninstallWithOptions: fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            removalOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindDeferredMdilBinaries: fn(
            self: *const IPMDeploymentManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateXamlLightupXbfForCurrentLocale: fn(
            self: *const IPMDeploymentManager,
            PackageFamilyName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddLicenseForAppx: fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            pbLicense: [*:0]u8,
            cbLicense: u32,
            pbPlayReadyHeader: ?[*:0]u8,
            cbPlayReadyHeader: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FixJunctionsForAppsOnSDCard: fn(
            self: *const IPMDeploymentManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_ReportDownloadBegin(self: *const T, productID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).ReportDownloadBegin(@ptrCast(*const IPMDeploymentManager, self), productID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_ReportDownloadProgress(self: *const T, productID: Guid, usProgress: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).ReportDownloadProgress(@ptrCast(*const IPMDeploymentManager, self), productID, usProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_ReportDownloadComplete(self: *const T, productID: Guid, hrResult: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).ReportDownloadComplete(@ptrCast(*const IPMDeploymentManager, self), productID, hrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginInstall(self: *const T, pInstallInfo: ?*PM_INSTALLINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginInstall(@ptrCast(*const IPMDeploymentManager, self), pInstallInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginUpdate(self: *const T, pUpdateInfo: ?*PM_UPDATEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginUpdate(@ptrCast(*const IPMDeploymentManager, self), pUpdateInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginDeployPackage(self: *const T, pInstallInfo: ?*PM_INSTALLINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginDeployPackage(@ptrCast(*const IPMDeploymentManager, self), pInstallInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginUpdateDeployedPackageLegacy(self: *const T, pUpdateInfo: ?*PM_UPDATEINFO_LEGACY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginUpdateDeployedPackageLegacy(@ptrCast(*const IPMDeploymentManager, self), pUpdateInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginUninstall(self: *const T, productID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginUninstall(@ptrCast(*const IPMDeploymentManager, self), productID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginEnterpriseAppInstall(self: *const T, pInstallInfo: ?*PM_INSTALLINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginEnterpriseAppInstall(@ptrCast(*const IPMDeploymentManager, self), pInstallInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginEnterpriseAppUpdate(self: *const T, pUpdateInfo: ?*PM_UPDATEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginEnterpriseAppUpdate(@ptrCast(*const IPMDeploymentManager, self), pUpdateInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginUpdateLicense(self: *const T, productID: Guid, offerID: Guid, pbLicense: [*:0]u8, cbLicense: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginUpdateLicense(@ptrCast(*const IPMDeploymentManager, self), productID, offerID, pbLicense, cbLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_GetLicenseChallenge(self: *const T, PackagePath: ?BSTR, ppbChallenge: ?[*]?*u8, pcbChallenge: ?*u32, ppbKID: ?[*]?*u8, pcbKID: ?*u32, ppbDeviceID: ?[*]?*u8, pcbDeviceID: ?*u32, ppbSaltValue: ?[*]?*u8, pcbSaltValue: ?*u32, ppbKGVValue: ?[*]?*u8, pcbKGVValue: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).GetLicenseChallenge(@ptrCast(*const IPMDeploymentManager, self), PackagePath, ppbChallenge, pcbChallenge, ppbKID, pcbKID, ppbDeviceID, pcbDeviceID, ppbSaltValue, pcbSaltValue, ppbKGVValue, pcbKGVValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_GetLicenseChallengeByProductID(self: *const T, ProductID: Guid, ppbChallenge: ?[*]?*u8, pcbLicense: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).GetLicenseChallengeByProductID(@ptrCast(*const IPMDeploymentManager, self), ProductID, ppbChallenge, pcbLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_GetLicenseChallengeByProductID2(self: *const T, ProductID: Guid, ppbChallenge: ?[*]?*u8, pcbLicense: ?*u32, ppbKID: ?[*]?*u8, pcbKID: ?*u32, ppbDeviceID: ?[*]?*u8, pcbDeviceID: ?*u32, ppbSaltValue: ?[*]?*u8, pcbSaltValue: ?*u32, ppbKGVValue: ?[*]?*u8, pcbKGVValue: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).GetLicenseChallengeByProductID2(@ptrCast(*const IPMDeploymentManager, self), ProductID, ppbChallenge, pcbLicense, ppbKID, pcbKID, ppbDeviceID, pcbDeviceID, ppbSaltValue, pcbSaltValue, ppbKGVValue, pcbKGVValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_RevokeLicense(self: *const T, productID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).RevokeLicense(@ptrCast(*const IPMDeploymentManager, self), productID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_RebindMdilBinaries(self: *const T, ProductID: Guid, FileNames: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).RebindMdilBinaries(@ptrCast(*const IPMDeploymentManager, self), ProductID, FileNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_RebindAllMdilBinaries(self: *const T, ProductID: Guid, InstanceID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).RebindAllMdilBinaries(@ptrCast(*const IPMDeploymentManager, self), ProductID, InstanceID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_RegenerateXbf(self: *const T, ProductID: Guid, AssemblyPaths: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).RegenerateXbf(@ptrCast(*const IPMDeploymentManager, self), ProductID, AssemblyPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_GenerateXbfForCurrentLocale(self: *const T, ProductID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).GenerateXbfForCurrentLocale(@ptrCast(*const IPMDeploymentManager, self), ProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginProvision(self: *const T, ProductID: Guid, XMLpath: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginProvision(@ptrCast(*const IPMDeploymentManager, self), ProductID, XMLpath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginDeprovision(self: *const T, ProductID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginDeprovision(@ptrCast(*const IPMDeploymentManager, self), ProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_ReindexSQLCEDatabases(self: *const T, ProductID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).ReindexSQLCEDatabases(@ptrCast(*const IPMDeploymentManager, self), ProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_SetApplicationsNeedMaintenance(self: *const T, RequiredMaintenanceOperations: u32, pcApplications: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).SetApplicationsNeedMaintenance(@ptrCast(*const IPMDeploymentManager, self), RequiredMaintenanceOperations, pcApplications);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_UpdateChamberProfile(self: *const T, ProductID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).UpdateChamberProfile(@ptrCast(*const IPMDeploymentManager, self), ProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_EnterprisePolicyIsApplicationAllowed(self: *const T, productId: Guid, publisherName: ?[*:0]const u16, pIsAllowed: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).EnterprisePolicyIsApplicationAllowed(@ptrCast(*const IPMDeploymentManager, self), productId, publisherName, pIsAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginUpdateDeployedPackage(self: *const T, pUpdateInfo: ?*PM_UPDATEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginUpdateDeployedPackage(@ptrCast(*const IPMDeploymentManager, self), pUpdateInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_ReportRestoreCancelled(self: *const T, productID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).ReportRestoreCancelled(@ptrCast(*const IPMDeploymentManager, self), productID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_ResolveResourceString(self: *const T, resourceString: ?[*:0]const u16, pResolvedResourceString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).ResolveResourceString(@ptrCast(*const IPMDeploymentManager, self), resourceString, pResolvedResourceString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_UpdateCapabilitiesForModernApps(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).UpdateCapabilitiesForModernApps(@ptrCast(*const IPMDeploymentManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_ReportDownloadStatusUpdate(self: *const T, productId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).ReportDownloadStatusUpdate(@ptrCast(*const IPMDeploymentManager, self), productId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BeginUninstallWithOptions(self: *const T, productID: Guid, removalOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BeginUninstallWithOptions(@ptrCast(*const IPMDeploymentManager, self), productID, removalOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_BindDeferredMdilBinaries(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).BindDeferredMdilBinaries(@ptrCast(*const IPMDeploymentManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_GenerateXamlLightupXbfForCurrentLocale(self: *const T, PackageFamilyName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).GenerateXamlLightupXbfForCurrentLocale(@ptrCast(*const IPMDeploymentManager, self), PackageFamilyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_AddLicenseForAppx(self: *const T, productID: Guid, pbLicense: [*:0]u8, cbLicense: u32, pbPlayReadyHeader: ?[*:0]u8, cbPlayReadyHeader: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).AddLicenseForAppx(@ptrCast(*const IPMDeploymentManager, self), productID, pbLicense, cbLicense, pbPlayReadyHeader, cbPlayReadyHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMDeploymentManager_FixJunctionsForAppsOnSDCard(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMDeploymentManager.VTable, self.vtable).FixJunctionsForAppsOnSDCard(@ptrCast(*const IPMDeploymentManager, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMEnumerationManager_Value = @import("../zig.zig").Guid.initString("698d57c2-292d-4cf3-b73c-d95a6922ed9a");
pub const IID_IPMEnumerationManager = &IID_IPMEnumerationManager_Value;
pub const IPMEnumerationManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllApplications: fn(
            self: *const IPMEnumerationManager,
            ppAppEnum: ?*?*IPMApplicationInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllTiles: fn(
            self: *const IPMEnumerationManager,
            ppTileEnum: ?*?*IPMTileInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllTasks: fn(
            self: *const IPMEnumerationManager,
            ppTaskEnum: ?*?*IPMTaskInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllExtensions: fn(
            self: *const IPMEnumerationManager,
            ppExtensionEnum: ?*?*IPMExtensionInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllBackgroundServiceAgents: fn(
            self: *const IPMEnumerationManager,
            ppBSAEnum: ?*?*IPMBackgroundServiceAgentInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllBackgroundWorkers: fn(
            self: *const IPMEnumerationManager,
            ppBSWEnum: ?*?*IPMBackgroundWorkerInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationInfo: fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            ppAppInfo: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileInfo: fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            TileID: ?BSTR,
            ppTileInfo: ?*?*IPMTileInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskInfo: fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            TaskID: ?BSTR,
            ppTaskInfo: ?*?*IPMTaskInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskInfoEx: fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            TaskID: ?[*:0]const u16,
            ppTaskInfo: ?*?*IPMTaskInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackgroundServiceAgentInfo: fn(
            self: *const IPMEnumerationManager,
            BSAID: u32,
            ppTaskInfo: ?*?*IPMBackgroundServiceAgentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllLiveTileJobs: fn(
            self: *const IPMEnumerationManager,
            ppLiveTileJobEnum: ?*?*IPMLiveTileJobInfoEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LiveTileJob: fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            TileID: ?BSTR,
            RecurrenceType: PM_LIVETILE_RECURRENCE_TYPE,
            ppLiveTileJobInfo: ?*?*IPMLiveTileJobInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationInfoExternal: fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            ppAppInfo: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileHandlerGenericLogo: fn(
            self: *const IPMEnumerationManager,
            FileType: ?BSTR,
            LogoSize: PM_LOGO_SIZE,
            pLogo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationInfoFromAccessClaims: fn(
            self: *const IPMEnumerationManager,
            SysAppID0: ?BSTR,
            SysAppID1: ?BSTR,
            ppAppInfo: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTileEnumeratorBlob: fn(
            self: *const IPMEnumerationManager,
            Filter: PM_ENUM_FILTER,
            pcTiles: ?*u32,
            ppTileBlobs: ?[*]?*PM_STARTTILEBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAppEnumeratorBlob: fn(
            self: *const IPMEnumerationManager,
            Filter: PM_ENUM_FILTER,
            pcApps: ?*u32,
            ppAppBlobs: ?[*]?*PM_STARTAPPBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_AllApplications(self: *const T, ppAppEnum: ?*?*IPMApplicationInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_AllApplications(@ptrCast(*const IPMEnumerationManager, self), ppAppEnum, Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_AllTiles(self: *const T, ppTileEnum: ?*?*IPMTileInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_AllTiles(@ptrCast(*const IPMEnumerationManager, self), ppTileEnum, Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_AllTasks(self: *const T, ppTaskEnum: ?*?*IPMTaskInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_AllTasks(@ptrCast(*const IPMEnumerationManager, self), ppTaskEnum, Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_AllExtensions(self: *const T, ppExtensionEnum: ?*?*IPMExtensionInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_AllExtensions(@ptrCast(*const IPMEnumerationManager, self), ppExtensionEnum, Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_AllBackgroundServiceAgents(self: *const T, ppBSAEnum: ?*?*IPMBackgroundServiceAgentInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_AllBackgroundServiceAgents(@ptrCast(*const IPMEnumerationManager, self), ppBSAEnum, Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_AllBackgroundWorkers(self: *const T, ppBSWEnum: ?*?*IPMBackgroundWorkerInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_AllBackgroundWorkers(@ptrCast(*const IPMEnumerationManager, self), ppBSWEnum, Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_ApplicationInfo(self: *const T, ProductID: Guid, ppAppInfo: ?*?*IPMApplicationInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_ApplicationInfo(@ptrCast(*const IPMEnumerationManager, self), ProductID, ppAppInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_TileInfo(self: *const T, ProductID: Guid, TileID: ?BSTR, ppTileInfo: ?*?*IPMTileInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_TileInfo(@ptrCast(*const IPMEnumerationManager, self), ProductID, TileID, ppTileInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_TaskInfo(self: *const T, ProductID: Guid, TaskID: ?BSTR, ppTaskInfo: ?*?*IPMTaskInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_TaskInfo(@ptrCast(*const IPMEnumerationManager, self), ProductID, TaskID, ppTaskInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_TaskInfoEx(self: *const T, ProductID: Guid, TaskID: ?[*:0]const u16, ppTaskInfo: ?*?*IPMTaskInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_TaskInfoEx(@ptrCast(*const IPMEnumerationManager, self), ProductID, TaskID, ppTaskInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_BackgroundServiceAgentInfo(self: *const T, BSAID: u32, ppTaskInfo: ?*?*IPMBackgroundServiceAgentInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_BackgroundServiceAgentInfo(@ptrCast(*const IPMEnumerationManager, self), BSAID, ppTaskInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_AllLiveTileJobs(self: *const T, ppLiveTileJobEnum: ?*?*IPMLiveTileJobInfoEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_AllLiveTileJobs(@ptrCast(*const IPMEnumerationManager, self), ppLiveTileJobEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_LiveTileJob(self: *const T, ProductID: Guid, TileID: ?BSTR, RecurrenceType: PM_LIVETILE_RECURRENCE_TYPE, ppLiveTileJobInfo: ?*?*IPMLiveTileJobInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_LiveTileJob(@ptrCast(*const IPMEnumerationManager, self), ProductID, TileID, RecurrenceType, ppLiveTileJobInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_ApplicationInfoExternal(self: *const T, ProductID: Guid, ppAppInfo: ?*?*IPMApplicationInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_ApplicationInfoExternal(@ptrCast(*const IPMEnumerationManager, self), ProductID, ppAppInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_FileHandlerGenericLogo(self: *const T, FileType: ?BSTR, LogoSize: PM_LOGO_SIZE, pLogo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_FileHandlerGenericLogo(@ptrCast(*const IPMEnumerationManager, self), FileType, LogoSize, pLogo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_ApplicationInfoFromAccessClaims(self: *const T, SysAppID0: ?BSTR, SysAppID1: ?BSTR, ppAppInfo: ?*?*IPMApplicationInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_ApplicationInfoFromAccessClaims(@ptrCast(*const IPMEnumerationManager, self), SysAppID0, SysAppID1, ppAppInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_StartTileEnumeratorBlob(self: *const T, Filter: PM_ENUM_FILTER, pcTiles: ?*u32, ppTileBlobs: ?[*]?*PM_STARTTILEBLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_StartTileEnumeratorBlob(@ptrCast(*const IPMEnumerationManager, self), Filter, pcTiles, ppTileBlobs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMEnumerationManager_get_StartAppEnumeratorBlob(self: *const T, Filter: PM_ENUM_FILTER, pcApps: ?*u32, ppAppBlobs: ?[*]?*PM_STARTAPPBLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMEnumerationManager.VTable, self.vtable).get_StartAppEnumeratorBlob(@ptrCast(*const IPMEnumerationManager, self), Filter, pcApps, ppAppBlobs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTaskInfo_Value = @import("../zig.zig").Guid.initString("bf1d8c33-1bf5-4ee0-b549-6b9dd3834942");
pub const IID_IPMTaskInfo = &IID_IPMTaskInfo_Value;
pub const IPMTaskInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: fn(
            self: *const IPMTaskInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: fn(
            self: *const IPMTaskInfo,
            pTaskID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NavigationPage: fn(
            self: *const IPMTaskInfo,
            pNavigationPage: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskTransition: fn(
            self: *const IPMTaskInfo,
            pTaskTransition: ?*PM_TASK_TRANSITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RuntimeType: fn(
            self: *const IPMTaskInfo,
            pRuntimetype: ?*PACKMAN_RUNTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActivationPolicy: fn(
            self: *const IPMTaskInfo,
            pActivationPolicy: ?*PM_ACTIVATION_POLICY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskType: fn(
            self: *const IPMTaskInfo,
            pTaskType: ?*PM_TASK_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: fn(
            self: *const IPMTaskInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImagePath: fn(
            self: *const IPMTaskInfo,
            pImagePath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageParams: fn(
            self: *const IPMTaskInfo,
            pImageParams: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallRootFolder: fn(
            self: *const IPMTaskInfo,
            pInstallRootFolder: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataRootFolder: fn(
            self: *const IPMTaskInfo,
            pDataRootFolder: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSingleInstanceHost: fn(
            self: *const IPMTaskInfo,
            pIsSingleInstanceHost: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInteropEnabled: fn(
            self: *const IPMTaskInfo,
            pIsInteropEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationState: fn(
            self: *const IPMTaskInfo,
            pApplicationState: ?*PM_APPLICATION_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallType: fn(
            self: *const IPMTaskInfo,
            pInstallType: ?*PM_APPLICATION_INSTALL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const IPMTaskInfo,
            pTargetMajorVersion: ?*u8,
            pTargetMinorVersion: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitsPerPixel: fn(
            self: *const IPMTaskInfo,
            pBitsPerPixel: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressesDehydration: fn(
            self: *const IPMTaskInfo,
            pSuppressesDehydration: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackgroundExecutionAbilities: fn(
            self: *const IPMTaskInfo,
            pBackgroundExecutionAbilities: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOptedForExtendedMem: fn(
            self: *const IPMTaskInfo,
            pIsOptedIn: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_ProductID(self: *const T, pProductID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_ProductID(@ptrCast(*const IPMTaskInfo, self), pProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_TaskID(self: *const T, pTaskID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_TaskID(@ptrCast(*const IPMTaskInfo, self), pTaskID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_NavigationPage(self: *const T, pNavigationPage: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_NavigationPage(@ptrCast(*const IPMTaskInfo, self), pNavigationPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_TaskTransition(self: *const T, pTaskTransition: ?*PM_TASK_TRANSITION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_TaskTransition(@ptrCast(*const IPMTaskInfo, self), pTaskTransition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_RuntimeType(self: *const T, pRuntimetype: ?*PACKMAN_RUNTIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_RuntimeType(@ptrCast(*const IPMTaskInfo, self), pRuntimetype);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_ActivationPolicy(self: *const T, pActivationPolicy: ?*PM_ACTIVATION_POLICY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_ActivationPolicy(@ptrCast(*const IPMTaskInfo, self), pActivationPolicy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_TaskType(self: *const T, pTaskType: ?*PM_TASK_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_TaskType(@ptrCast(*const IPMTaskInfo, self), pTaskType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_InvocationInfo(self: *const T, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_InvocationInfo(@ptrCast(*const IPMTaskInfo, self), pImageUrn, pParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_ImagePath(self: *const T, pImagePath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_ImagePath(@ptrCast(*const IPMTaskInfo, self), pImagePath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_ImageParams(self: *const T, pImageParams: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_ImageParams(@ptrCast(*const IPMTaskInfo, self), pImageParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_InstallRootFolder(self: *const T, pInstallRootFolder: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_InstallRootFolder(@ptrCast(*const IPMTaskInfo, self), pInstallRootFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_DataRootFolder(self: *const T, pDataRootFolder: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_DataRootFolder(@ptrCast(*const IPMTaskInfo, self), pDataRootFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_IsSingleInstanceHost(self: *const T, pIsSingleInstanceHost: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_IsSingleInstanceHost(@ptrCast(*const IPMTaskInfo, self), pIsSingleInstanceHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_IsInteropEnabled(self: *const T, pIsInteropEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_IsInteropEnabled(@ptrCast(*const IPMTaskInfo, self), pIsInteropEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_ApplicationState(self: *const T, pApplicationState: ?*PM_APPLICATION_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_ApplicationState(@ptrCast(*const IPMTaskInfo, self), pApplicationState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_InstallType(self: *const T, pInstallType: ?*PM_APPLICATION_INSTALL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_InstallType(@ptrCast(*const IPMTaskInfo, self), pInstallType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_Version(self: *const T, pTargetMajorVersion: ?*u8, pTargetMinorVersion: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_Version(@ptrCast(*const IPMTaskInfo, self), pTargetMajorVersion, pTargetMinorVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_BitsPerPixel(self: *const T, pBitsPerPixel: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_BitsPerPixel(@ptrCast(*const IPMTaskInfo, self), pBitsPerPixel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_SuppressesDehydration(self: *const T, pSuppressesDehydration: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_SuppressesDehydration(@ptrCast(*const IPMTaskInfo, self), pSuppressesDehydration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_BackgroundExecutionAbilities(self: *const T, pBackgroundExecutionAbilities: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_BackgroundExecutionAbilities(@ptrCast(*const IPMTaskInfo, self), pBackgroundExecutionAbilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfo_get_IsOptedForExtendedMem(self: *const T, pIsOptedIn: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfo.VTable, self.vtable).get_IsOptedForExtendedMem(@ptrCast(*const IPMTaskInfo, self), pIsOptedIn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMTaskInfoEnumerator_Value = @import("../zig.zig").Guid.initString("0630b0f8-0bbc-4821-be74-c7995166ed2a");
pub const IID_IPMTaskInfoEnumerator = &IID_IPMTaskInfoEnumerator_Value;
pub const IPMTaskInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: fn(
            self: *const IPMTaskInfoEnumerator,
            ppTaskInfo: ?*?*IPMTaskInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMTaskInfoEnumerator_get_Next(self: *const T, ppTaskInfo: ?*?*IPMTaskInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMTaskInfoEnumerator.VTable, self.vtable).get_Next(@ptrCast(*const IPMTaskInfoEnumerator, self), ppTaskInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionInfo_Value = @import("../zig.zig").Guid.initString("49acde79-9788-4d0a-8aa0-1746afdb9e9d");
pub const IID_IPMExtensionInfo = &IID_IPMExtensionInfo_Value;
pub const IPMExtensionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupplierPID: fn(
            self: *const IPMExtensionInfo,
            pSupplierPID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupplierTaskID: fn(
            self: *const IPMExtensionInfo,
            pSupplierTID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: fn(
            self: *const IPMExtensionInfo,
            pTitle: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IconPath: fn(
            self: *const IPMExtensionInfo,
            pIconPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtraFile: fn(
            self: *const IPMExtensionInfo,
            pFilePath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: fn(
            self: *const IPMExtensionInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionInfo_get_SupplierPID(self: *const T, pSupplierPID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionInfo.VTable, self.vtable).get_SupplierPID(@ptrCast(*const IPMExtensionInfo, self), pSupplierPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionInfo_get_SupplierTaskID(self: *const T, pSupplierTID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionInfo.VTable, self.vtable).get_SupplierTaskID(@ptrCast(*const IPMExtensionInfo, self), pSupplierTID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionInfo_get_Title(self: *const T, pTitle: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionInfo.VTable, self.vtable).get_Title(@ptrCast(*const IPMExtensionInfo, self), pTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionInfo_get_IconPath(self: *const T, pIconPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionInfo.VTable, self.vtable).get_IconPath(@ptrCast(*const IPMExtensionInfo, self), pIconPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionInfo_get_ExtraFile(self: *const T, pFilePath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionInfo.VTable, self.vtable).get_ExtraFile(@ptrCast(*const IPMExtensionInfo, self), pFilePath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionInfo_get_InvocationInfo(self: *const T, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionInfo.VTable, self.vtable).get_InvocationInfo(@ptrCast(*const IPMExtensionInfo, self), pImageUrn, pParameters);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionFileExtensionInfo_Value = @import("../zig.zig").Guid.initString("6b87cb6c-0b88-4989-a4ec-033714f710d4");
pub const IID_IPMExtensionFileExtensionInfo = &IID_IPMExtensionFileExtensionInfo_Value;
pub const IPMExtensionFileExtensionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IPMExtensionFileExtensionInfo,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: fn(
            self: *const IPMExtensionFileExtensionInfo,
            pDisplayName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Logo: fn(
            self: *const IPMExtensionFileExtensionInfo,
            LogoSize: PM_LOGO_SIZE,
            pLogo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContentType: fn(
            self: *const IPMExtensionFileExtensionInfo,
            FileType: ?BSTR,
            pContentType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileType: fn(
            self: *const IPMExtensionFileExtensionInfo,
            ContentType: ?BSTR,
            pFileType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: fn(
            self: *const IPMExtensionFileExtensionInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllFileTypes: fn(
            self: *const IPMExtensionFileExtensionInfo,
            pcbTypes: ?*u32,
            ppTypes: ?[*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileExtensionInfo_get_Name(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileExtensionInfo.VTable, self.vtable).get_Name(@ptrCast(*const IPMExtensionFileExtensionInfo, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileExtensionInfo_get_DisplayName(self: *const T, pDisplayName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileExtensionInfo.VTable, self.vtable).get_DisplayName(@ptrCast(*const IPMExtensionFileExtensionInfo, self), pDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileExtensionInfo_get_Logo(self: *const T, LogoSize: PM_LOGO_SIZE, pLogo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileExtensionInfo.VTable, self.vtable).get_Logo(@ptrCast(*const IPMExtensionFileExtensionInfo, self), LogoSize, pLogo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileExtensionInfo_get_ContentType(self: *const T, FileType: ?BSTR, pContentType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileExtensionInfo.VTable, self.vtable).get_ContentType(@ptrCast(*const IPMExtensionFileExtensionInfo, self), FileType, pContentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileExtensionInfo_get_FileType(self: *const T, ContentType: ?BSTR, pFileType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileExtensionInfo.VTable, self.vtable).get_FileType(@ptrCast(*const IPMExtensionFileExtensionInfo, self), ContentType, pFileType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileExtensionInfo_get_InvocationInfo(self: *const T, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileExtensionInfo.VTable, self.vtable).get_InvocationInfo(@ptrCast(*const IPMExtensionFileExtensionInfo, self), pImageUrn, pParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileExtensionInfo_get_AllFileTypes(self: *const T, pcbTypes: ?*u32, ppTypes: ?[*]?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileExtensionInfo.VTable, self.vtable).get_AllFileTypes(@ptrCast(*const IPMExtensionFileExtensionInfo, self), pcbTypes, ppTypes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionProtocolInfo_Value = @import("../zig.zig").Guid.initString("1e3fa036-51eb-4453-baff-b8d8e4b46c8e");
pub const IID_IPMExtensionProtocolInfo = &IID_IPMExtensionProtocolInfo_Value;
pub const IPMExtensionProtocolInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: fn(
            self: *const IPMExtensionProtocolInfo,
            pProtocol: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: fn(
            self: *const IPMExtensionProtocolInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionProtocolInfo_get_Protocol(self: *const T, pProtocol: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionProtocolInfo.VTable, self.vtable).get_Protocol(@ptrCast(*const IPMExtensionProtocolInfo, self), pProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionProtocolInfo_get_InvocationInfo(self: *const T, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionProtocolInfo.VTable, self.vtable).get_InvocationInfo(@ptrCast(*const IPMExtensionProtocolInfo, self), pImageUrn, pParameters);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionShareTargetInfo_Value = @import("../zig.zig").Guid.initString("5471f48b-c65c-4656-8c70-242e31195fea");
pub const IID_IPMExtensionShareTargetInfo = &IID_IPMExtensionShareTargetInfo_Value;
pub const IPMExtensionShareTargetInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllFileTypes: fn(
            self: *const IPMExtensionShareTargetInfo,
            pcTypes: ?*u32,
            ppTypes: ?[*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllDataFormats: fn(
            self: *const IPMExtensionShareTargetInfo,
            pcDataFormats: ?*u32,
            ppDataFormats: ?[*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsAllFileTypes: fn(
            self: *const IPMExtensionShareTargetInfo,
            pSupportsAllTypes: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionShareTargetInfo_get_AllFileTypes(self: *const T, pcTypes: ?*u32, ppTypes: ?[*]?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionShareTargetInfo.VTable, self.vtable).get_AllFileTypes(@ptrCast(*const IPMExtensionShareTargetInfo, self), pcTypes, ppTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionShareTargetInfo_get_AllDataFormats(self: *const T, pcDataFormats: ?*u32, ppDataFormats: ?[*]?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionShareTargetInfo.VTable, self.vtable).get_AllDataFormats(@ptrCast(*const IPMExtensionShareTargetInfo, self), pcDataFormats, ppDataFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionShareTargetInfo_get_SupportsAllFileTypes(self: *const T, pSupportsAllTypes: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionShareTargetInfo.VTable, self.vtable).get_SupportsAllFileTypes(@ptrCast(*const IPMExtensionShareTargetInfo, self), pSupportsAllTypes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionContractInfo_Value = @import("../zig.zig").Guid.initString("e5666373-7ba1-467c-b819-b175db1c295b");
pub const IID_IPMExtensionContractInfo = &IID_IPMExtensionContractInfo_Value;
pub const IPMExtensionContractInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InvocationInfo: fn(
            self: *const IPMExtensionContractInfo,
            pAUMID: ?*?BSTR,
            pArgs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionContractInfo_get_InvocationInfo(self: *const T, pAUMID: ?*?BSTR, pArgs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionContractInfo.VTable, self.vtable).get_InvocationInfo(@ptrCast(*const IPMExtensionContractInfo, self), pAUMID, pArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionFileOpenPickerInfo_Value = @import("../zig.zig").Guid.initString("6dc91d25-9606-420c-9a78-e034a3418345");
pub const IID_IPMExtensionFileOpenPickerInfo = &IID_IPMExtensionFileOpenPickerInfo_Value;
pub const IPMExtensionFileOpenPickerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllFileTypes: fn(
            self: *const IPMExtensionFileOpenPickerInfo,
            pcTypes: ?*u32,
            ppTypes: ?[*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsAllFileTypes: fn(
            self: *const IPMExtensionFileOpenPickerInfo,
            pSupportsAllTypes: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileOpenPickerInfo_get_AllFileTypes(self: *const T, pcTypes: ?*u32, ppTypes: ?[*]?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileOpenPickerInfo.VTable, self.vtable).get_AllFileTypes(@ptrCast(*const IPMExtensionFileOpenPickerInfo, self), pcTypes, ppTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileOpenPickerInfo_get_SupportsAllFileTypes(self: *const T, pSupportsAllTypes: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileOpenPickerInfo.VTable, self.vtable).get_SupportsAllFileTypes(@ptrCast(*const IPMExtensionFileOpenPickerInfo, self), pSupportsAllTypes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionFileSavePickerInfo_Value = @import("../zig.zig").Guid.initString("38005cba-f81a-493e-a0f8-922c8680da43");
pub const IID_IPMExtensionFileSavePickerInfo = &IID_IPMExtensionFileSavePickerInfo_Value;
pub const IPMExtensionFileSavePickerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllFileTypes: fn(
            self: *const IPMExtensionFileSavePickerInfo,
            pcTypes: ?*u32,
            ppTypes: ?[*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsAllFileTypes: fn(
            self: *const IPMExtensionFileSavePickerInfo,
            pSupportsAllTypes: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileSavePickerInfo_get_AllFileTypes(self: *const T, pcTypes: ?*u32, ppTypes: ?[*]?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileSavePickerInfo.VTable, self.vtable).get_AllFileTypes(@ptrCast(*const IPMExtensionFileSavePickerInfo, self), pcTypes, ppTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionFileSavePickerInfo_get_SupportsAllFileTypes(self: *const T, pSupportsAllTypes: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionFileSavePickerInfo.VTable, self.vtable).get_SupportsAllFileTypes(@ptrCast(*const IPMExtensionFileSavePickerInfo, self), pSupportsAllTypes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionCachedFileUpdaterInfo_Value = @import("../zig.zig").Guid.initString("e2d77509-4e58-4ba9-af7e-b642e370e1b0");
pub const IID_IPMExtensionCachedFileUpdaterInfo = &IID_IPMExtensionCachedFileUpdaterInfo_Value;
pub const IPMExtensionCachedFileUpdaterInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsUpdates: fn(
            self: *const IPMExtensionCachedFileUpdaterInfo,
            pSupportsUpdates: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionCachedFileUpdaterInfo_get_SupportsUpdates(self: *const T, pSupportsUpdates: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionCachedFileUpdaterInfo.VTable, self.vtable).get_SupportsUpdates(@ptrCast(*const IPMExtensionCachedFileUpdaterInfo, self), pSupportsUpdates);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMExtensionInfoEnumerator_Value = @import("../zig.zig").Guid.initString("403b9e82-1171-4573-8e6f-6f33f39b83dd");
pub const IID_IPMExtensionInfoEnumerator = &IID_IPMExtensionInfoEnumerator_Value;
pub const IPMExtensionInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: fn(
            self: *const IPMExtensionInfoEnumerator,
            ppExtensionInfo: ?*?*IPMExtensionInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMExtensionInfoEnumerator_get_Next(self: *const T, ppExtensionInfo: ?*?*IPMExtensionInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMExtensionInfoEnumerator.VTable, self.vtable).get_Next(@ptrCast(*const IPMExtensionInfoEnumerator, self), ppExtensionInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMBackgroundServiceAgentInfo_Value = @import("../zig.zig").Guid.initString("3a8b46da-928c-4879-998c-09dc96f3d490");
pub const IID_IPMBackgroundServiceAgentInfo = &IID_IPMBackgroundServiceAgentInfo_Value;
pub const IPMBackgroundServiceAgentInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pTaskID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BSAID: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBSAID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGSpecifier: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBGSpecifier: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGName: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBGName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGSource: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBGSource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGType: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBGType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsPeriodic: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pIsPeriodic: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsScheduled: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pIsScheduled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsScheduleAllowed: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pIsScheduleAllowed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsLaunchOnBoot: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pLaunchOnBoot: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsScheduled: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            IsScheduled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsScheduleAllowed: fn(
            self: *const IPMBackgroundServiceAgentInfo,
            IsScheduleAllowed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_ProductID(self: *const T, pProductID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_ProductID(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_TaskID(self: *const T, pTaskID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_TaskID(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pTaskID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_BSAID(self: *const T, pBSAID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_BSAID(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pBSAID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_BGSpecifier(self: *const T, pBGSpecifier: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_BGSpecifier(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pBGSpecifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_BGName(self: *const T, pBGName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_BGName(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pBGName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_BGSource(self: *const T, pBGSource: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_BGSource(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pBGSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_BGType(self: *const T, pBGType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_BGType(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pBGType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_IsPeriodic(self: *const T, pIsPeriodic: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_IsPeriodic(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pIsPeriodic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_IsScheduled(self: *const T, pIsScheduled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_IsScheduled(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pIsScheduled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_IsScheduleAllowed(self: *const T, pIsScheduleAllowed: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_IsScheduleAllowed(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pIsScheduleAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_Description(self: *const T, pDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_Description(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_get_IsLaunchOnBoot(self: *const T, pLaunchOnBoot: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).get_IsLaunchOnBoot(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), pLaunchOnBoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_set_IsScheduled(self: *const T, IsScheduled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).set_IsScheduled(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), IsScheduled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfo_set_IsScheduleAllowed(self: *const T, IsScheduleAllowed: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfo.VTable, self.vtable).set_IsScheduleAllowed(@ptrCast(*const IPMBackgroundServiceAgentInfo, self), IsScheduleAllowed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMBackgroundWorkerInfo_Value = @import("../zig.zig").Guid.initString("7dd4531b-d3bf-4b6b-94f3-69c098b1497d");
pub const IID_IPMBackgroundWorkerInfo = &IID_IPMBackgroundWorkerInfo_Value;
pub const IPMBackgroundWorkerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: fn(
            self: *const IPMBackgroundWorkerInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: fn(
            self: *const IPMBackgroundWorkerInfo,
            pTaskID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGName: fn(
            self: *const IPMBackgroundWorkerInfo,
            pBGName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxStartupLatency: fn(
            self: *const IPMBackgroundWorkerInfo,
            pMaxStartupLatency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpectedRuntime: fn(
            self: *const IPMBackgroundWorkerInfo,
            pExpectedRuntime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBootWorker: fn(
            self: *const IPMBackgroundWorkerInfo,
            pIsBootWorker: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundWorkerInfo_get_ProductID(self: *const T, pProductID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundWorkerInfo.VTable, self.vtable).get_ProductID(@ptrCast(*const IPMBackgroundWorkerInfo, self), pProductID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundWorkerInfo_get_TaskID(self: *const T, pTaskID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundWorkerInfo.VTable, self.vtable).get_TaskID(@ptrCast(*const IPMBackgroundWorkerInfo, self), pTaskID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundWorkerInfo_get_BGName(self: *const T, pBGName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundWorkerInfo.VTable, self.vtable).get_BGName(@ptrCast(*const IPMBackgroundWorkerInfo, self), pBGName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundWorkerInfo_get_MaxStartupLatency(self: *const T, pMaxStartupLatency: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundWorkerInfo.VTable, self.vtable).get_MaxStartupLatency(@ptrCast(*const IPMBackgroundWorkerInfo, self), pMaxStartupLatency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundWorkerInfo_get_ExpectedRuntime(self: *const T, pExpectedRuntime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundWorkerInfo.VTable, self.vtable).get_ExpectedRuntime(@ptrCast(*const IPMBackgroundWorkerInfo, self), pExpectedRuntime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundWorkerInfo_get_IsBootWorker(self: *const T, pIsBootWorker: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundWorkerInfo.VTable, self.vtable).get_IsBootWorker(@ptrCast(*const IPMBackgroundWorkerInfo, self), pIsBootWorker);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMBackgroundServiceAgentInfoEnumerator_Value = @import("../zig.zig").Guid.initString("18eb2072-ab56-43b3-872c-beafb7a6b391");
pub const IID_IPMBackgroundServiceAgentInfoEnumerator = &IID_IPMBackgroundServiceAgentInfoEnumerator_Value;
pub const IPMBackgroundServiceAgentInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: fn(
            self: *const IPMBackgroundServiceAgentInfoEnumerator,
            ppBSAInfo: ?*?*IPMBackgroundServiceAgentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundServiceAgentInfoEnumerator_get_Next(self: *const T, ppBSAInfo: ?*?*IPMBackgroundServiceAgentInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundServiceAgentInfoEnumerator.VTable, self.vtable).get_Next(@ptrCast(*const IPMBackgroundServiceAgentInfoEnumerator, self), ppBSAInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMBackgroundWorkerInfoEnumerator_Value = @import("../zig.zig").Guid.initString("87f479f8-90d8-4ec7-92b9-72787e2f636b");
pub const IID_IPMBackgroundWorkerInfoEnumerator = &IID_IPMBackgroundWorkerInfoEnumerator_Value;
pub const IPMBackgroundWorkerInfoEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: fn(
            self: *const IPMBackgroundWorkerInfoEnumerator,
            ppBWInfo: ?*?*IPMBackgroundWorkerInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMBackgroundWorkerInfoEnumerator_get_Next(self: *const T, ppBWInfo: ?*?*IPMBackgroundWorkerInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPMBackgroundWorkerInfoEnumerator.VTable, self.vtable).get_Next(@ptrCast(*const IPMBackgroundWorkerInfoEnumerator, self), ppBWInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PPATCH_PROGRESS_CALLBACK = fn(
    CallbackContext: ?*anyopaque,
    CurrentPosition: u32,
    MaximumPosition: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PPATCH_SYMLOAD_CALLBACK = fn(
    WhichFile: u32,
    SymbolFileName: ?[*:0]const u8,
    SymType: u32,
    SymbolFileCheckSum: u32,
    SymbolFileTimeDate: u32,
    ImageFileCheckSum: u32,
    ImageFileTimeDate: u32,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PATCH_IGNORE_RANGE = extern struct {
    OffsetInOldFile: u32,
    LengthInBytes: u32,
};

pub const PATCH_RETAIN_RANGE = extern struct {
    OffsetInOldFile: u32,
    LengthInBytes: u32,
    OffsetInNewFile: u32,
};

pub const PATCH_OLD_FILE_INFO_A = extern struct {
    SizeOfThisStruct: u32,
    OldFileName: ?[*:0]const u8,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_OLD_FILE_INFO_W = extern struct {
    SizeOfThisStruct: u32,
    OldFileName: ?[*:0]const u16,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_OLD_FILE_INFO_H = extern struct {
    SizeOfThisStruct: u32,
    OldFileHandle: ?HANDLE,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_OLD_FILE_INFO = extern struct {
    SizeOfThisStruct: u32,
    Anonymous: extern union {
        OldFileNameA: ?[*:0]const u8,
        OldFileNameW: ?[*:0]const u16,
        OldFileHandle: ?HANDLE,
    },
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_INTERLEAVE_MAP = extern struct {
    CountRanges: u32,
    Range: [1]extern struct {
        OldOffset: u32,
        OldLength: u32,
        NewLength: u32,
    },
};

pub const PATCH_OPTION_DATA = extern struct {
    SizeOfThisStruct: u32,
    SymbolOptionFlags: u32,
    NewFileSymbolPath: ?[*:0]const u8,
    OldFileSymbolPathArray: ?*?PSTR,
    ExtendedOptionFlags: u32,
    SymLoadCallback: ?PPATCH_SYMLOAD_CALLBACK,
    SymLoadContext: ?*anyopaque,
    InterleaveMapArray: ?*?*PATCH_INTERLEAVE_MAP,
    MaxLzxWindowSize: u32,
};

pub const DELTA_INPUT = extern struct {
    Anonymous: extern union {
        lpcStart: ?*const anyopaque,
        lpStart: ?*anyopaque,
    },
    uSize: usize,
    Editable: BOOL,
};

pub const DELTA_OUTPUT = extern struct {
    lpStart: ?*anyopaque,
    uSize: usize,
};

pub const DELTA_HASH = extern struct {
    HashSize: u32,
    HashValue: [32]u8,
};

pub const DELTA_HEADER_INFO = extern struct {
    FileTypeSet: i64,
    FileType: i64,
    Flags: i64,
    TargetSize: usize,
    TargetFileTime: FILETIME,
    TargetHashAlgId: u32,
    TargetHash: DELTA_HASH,
};

pub const ACTIVATION_CONTEXT_QUERY_INDEX = extern struct {
    ulAssemblyIndex: u32,
    ulFileIndexInAssembly: u32,
};

pub const ASSEMBLY_FILE_DETAILED_INFORMATION = extern struct {
    ulFlags: u32,
    ulFilenameLength: u32,
    ulPathLength: u32,
    lpFileName: ?[*:0]const u16,
    lpFilePath: ?[*:0]const u16,
};

pub const ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = extern struct {
    ulFlags: u32,
    ulEncodedAssemblyIdentityLength: u32,
    ulManifestPathType: u32,
    ulManifestPathLength: u32,
    liManifestLastWriteTime: LARGE_INTEGER,
    ulPolicyPathType: u32,
    ulPolicyPathLength: u32,
    liPolicyLastWriteTime: LARGE_INTEGER,
    ulMetadataSatelliteRosterIndex: u32,
    ulManifestVersionMajor: u32,
    ulManifestVersionMinor: u32,
    ulPolicyVersionMajor: u32,
    ulPolicyVersionMinor: u32,
    ulAssemblyDirectoryNameLength: u32,
    lpAssemblyEncodedAssemblyIdentity: ?[*:0]const u16,
    lpAssemblyManifestPath: ?[*:0]const u16,
    lpAssemblyPolicyPath: ?[*:0]const u16,
    lpAssemblyDirectoryName: ?[*:0]const u16,
    ulFileCount: u32,
};

pub const ACTCTX_REQUESTED_RUN_LEVEL = enum(i32) {
    UNSPECIFIED = 0,
    AS_INVOKER = 1,
    HIGHEST_AVAILABLE = 2,
    REQUIRE_ADMIN = 3,
    NUMBERS = 4,
};
pub const ACTCTX_RUN_LEVEL_UNSPECIFIED = ACTCTX_REQUESTED_RUN_LEVEL.UNSPECIFIED;
pub const ACTCTX_RUN_LEVEL_AS_INVOKER = ACTCTX_REQUESTED_RUN_LEVEL.AS_INVOKER;
pub const ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = ACTCTX_REQUESTED_RUN_LEVEL.HIGHEST_AVAILABLE;
pub const ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = ACTCTX_REQUESTED_RUN_LEVEL.REQUIRE_ADMIN;
pub const ACTCTX_RUN_LEVEL_NUMBERS = ACTCTX_REQUESTED_RUN_LEVEL.NUMBERS;

pub const ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = extern struct {
    ulFlags: u32,
    RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
    UiAccess: u32,
};

pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE = enum(i32) {
    UNKNOWN = 0,
    OS = 1,
    MITIGATION = 2,
    MAXVERSIONTESTED = 3,
};
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.UNKNOWN;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.OS;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.MITIGATION;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.MAXVERSIONTESTED;

pub const COMPATIBILITY_CONTEXT_ELEMENT = extern struct {
    Id: Guid,
    Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
    MaxVersionTested: u64,
};

pub const ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = extern struct {
    ElementCount: u32,
    Elements: [1]COMPATIBILITY_CONTEXT_ELEMENT,
};

pub const ACTIVATION_CONTEXT_DETAILED_INFORMATION = extern struct {
    dwFlags: u32,
    ulFormatVersion: u32,
    ulAssemblyCount: u32,
    ulRootManifestPathType: u32,
    ulRootManifestPathChars: u32,
    ulRootConfigurationPathType: u32,
    ulRootConfigurationPathChars: u32,
    ulAppDirPathType: u32,
    ulAppDirPathChars: u32,
    lpRootManifestPath: ?[*:0]const u16,
    lpRootConfigurationPath: ?[*:0]const u16,
    lpAppDirPath: ?[*:0]const u16,
};

pub const ACTCTXA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpSource: ?[*:0]const u8,
    wProcessorArchitecture: u16,
    wLangId: u16,
    lpAssemblyDirectory: ?[*:0]const u8,
    lpResourceName: ?[*:0]const u8,
    lpApplicationName: ?[*:0]const u8,
    hModule: ?HINSTANCE,
};

pub const ACTCTXW = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpSource: ?[*:0]const u16,
    wProcessorArchitecture: u16,
    wLangId: u16,
    lpAssemblyDirectory: ?[*:0]const u16,
    lpResourceName: ?[*:0]const u16,
    lpApplicationName: ?[*:0]const u16,
    hModule: ?HINSTANCE,
};

pub const ACTCTX_SECTION_KEYED_DATA = extern struct {
    cbSize: u32,
    ulDataFormatVersion: u32,
    lpData: ?*anyopaque,
    ulLength: u32,
    lpSectionGlobalData: ?*anyopaque,
    ulSectionGlobalDataLength: u32,
    lpSectionBase: ?*anyopaque,
    ulSectionTotalLength: u32,
    hActCtx: ?HANDLE,
    ulAssemblyRosterIndex: u32,
    ulFlags: u32,
    AssemblyMetadata: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA,
};


//--------------------------------------------------------------------------------
// Section: Functions (322)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCloseHandle(
    hAny: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCloseAllHandles(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetInternalUI(
    dwUILevel: INSTALLUILEVEL,
    phWnd: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) INSTALLUILEVEL;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetExternalUIA(
    puiHandler: ?INSTALLUI_HANDLERA,
    dwMessageFilter: u32,
    pvContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?INSTALLUI_HANDLERA;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetExternalUIW(
    puiHandler: ?INSTALLUI_HANDLERW,
    dwMessageFilter: u32,
    pvContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?INSTALLUI_HANDLERW;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetExternalUIRecord(
    puiHandler: ?PINSTALLUI_HANDLER_RECORD,
    dwMessageFilter: u32,
    pvContext: ?*anyopaque,
    ppuiPrevHandler: ?PINSTALLUI_HANDLER_RECORD,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnableLogA(
    dwLogMode: INSTALLOGMODE,
    szLogFile: ?[*:0]const u8,
    dwLogAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnableLogW(
    dwLogMode: INSTALLOGMODE,
    szLogFile: ?[*:0]const u16,
    dwLogAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryProductStateA(
    szProduct: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryProductStateW(
    szProduct: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoA(
    szProduct: ?[*:0]const u8,
    szAttribute: ?[*:0]const u8,
    lpValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoW(
    szProduct: ?[*:0]const u16,
    szAttribute: ?[*:0]const u16,
    lpValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u8,
    szValue: ?[*:0]u8,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u16,
    szValue: ?[*:0]u16,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallProductA(
    szPackagePath: ?[*:0]const u8,
    szCommandLine: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallProductW(
    szPackagePath: ?[*:0]const u16,
    szCommandLine: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureProductA(
    szProduct: ?[*:0]const u8,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureProductW(
    szProduct: ?[*:0]const u16,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureProductExA(
    szProduct: ?[*:0]const u8,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
    szCommandLine: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureProductExW(
    szProduct: ?[*:0]const u16,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
    szCommandLine: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiReinstallProductA(
    szProduct: ?[*:0]const u8,
    szReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiReinstallProductW(
    szProduct: ?[*:0]const u16,
    szReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseProductExA(
    szPackagePath: ?[*:0]const u8,
    szScriptfilePath: ?[*:0]const u8,
    szTransforms: ?[*:0]const u8,
    lgidLanguage: u16,
    dwPlatform: u32,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseProductExW(
    szPackagePath: ?[*:0]const u16,
    szScriptfilePath: ?[*:0]const u16,
    szTransforms: ?[*:0]const u16,
    lgidLanguage: u16,
    dwPlatform: u32,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseProductA(
    szPackagePath: ?[*:0]const u8,
    szScriptfilePath: ?[*:0]const u8,
    szTransforms: ?[*:0]const u8,
    lgidLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseProductW(
    szPackagePath: ?[*:0]const u16,
    szScriptfilePath: ?[*:0]const u16,
    szTransforms: ?[*:0]const u16,
    lgidLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProcessAdvertiseScriptA(
    szScriptFile: ?[*:0]const u8,
    szIconFolder: ?[*:0]const u8,
    hRegData: ?HKEY,
    fShortcuts: BOOL,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProcessAdvertiseScriptW(
    szScriptFile: ?[*:0]const u16,
    szIconFolder: ?[*:0]const u16,
    hRegData: ?HKEY,
    fShortcuts: BOOL,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseScriptA(
    szScriptFile: ?[*:0]const u8,
    dwFlags: u32,
    phRegData: ?*?HKEY,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseScriptW(
    szScriptFile: ?[*:0]const u16,
    dwFlags: u32,
    phRegData: ?*?HKEY,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoFromScriptA(
    szScriptFile: ?[*:0]const u8,
    lpProductBuf39: ?PSTR,
    plgidLanguage: ?*u16,
    pdwVersion: ?*u32,
    lpNameBuf: ?[*:0]u8,
    pcchNameBuf: ?*u32,
    lpPackageBuf: ?[*:0]u8,
    pcchPackageBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoFromScriptW(
    szScriptFile: ?[*:0]const u16,
    lpProductBuf39: ?PWSTR,
    plgidLanguage: ?*u16,
    pdwVersion: ?*u32,
    lpNameBuf: ?[*:0]u16,
    pcchNameBuf: ?*u32,
    lpPackageBuf: ?[*:0]u16,
    pcchPackageBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductCodeA(
    szComponent: ?[*:0]const u8,
    lpBuf39: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductCodeW(
    szComponent: ?[*:0]const u16,
    lpBuf39: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetUserInfoA(
    szProduct: ?[*:0]const u8,
    lpUserNameBuf: ?[*:0]u8,
    pcchUserNameBuf: ?*u32,
    lpOrgNameBuf: ?[*:0]u8,
    pcchOrgNameBuf: ?*u32,
    lpSerialBuf: ?[*:0]u8,
    pcchSerialBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) USERINFOSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetUserInfoW(
    szProduct: ?[*:0]const u16,
    lpUserNameBuf: ?[*:0]u16,
    pcchUserNameBuf: ?*u32,
    lpOrgNameBuf: ?[*:0]u16,
    pcchOrgNameBuf: ?*u32,
    lpSerialBuf: ?[*:0]u16,
    pcchSerialBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) USERINFOSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCollectUserInfoA(
    szProduct: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCollectUserInfoW(
    szProduct: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiApplyPatchA(
    szPatchPackage: ?[*:0]const u8,
    szInstallPackage: ?[*:0]const u8,
    eInstallType: INSTALLTYPE,
    szCommandLine: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiApplyPatchW(
    szPatchPackage: ?[*:0]const u16,
    szInstallPackage: ?[*:0]const u16,
    eInstallType: INSTALLTYPE,
    szCommandLine: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchInfoA(
    szPatch: ?[*:0]const u8,
    szAttribute: ?[*:0]const u8,
    lpValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchInfoW(
    szPatch: ?[*:0]const u16,
    szAttribute: ?[*:0]const u16,
    lpValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumPatchesA(
    szProduct: ?[*:0]const u8,
    iPatchIndex: u32,
    lpPatchBuf: ?PSTR,
    lpTransformsBuf: [*:0]u8,
    pcchTransformsBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumPatchesW(
    szProduct: ?[*:0]const u16,
    iPatchIndex: u32,
    lpPatchBuf: ?PWSTR,
    lpTransformsBuf: [*:0]u16,
    pcchTransformsBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRemovePatchesA(
    szPatchList: ?[*:0]const u8,
    szProductCode: ?[*:0]const u8,
    eUninstallType: INSTALLTYPE,
    szPropertyList: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRemovePatchesW(
    szPatchList: ?[*:0]const u16,
    szProductCode: ?[*:0]const u16,
    eUninstallType: INSTALLTYPE,
    szPropertyList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows Vista'
pub extern "msi" fn MsiExtractPatchXMLDataA(
    szPatchPath: ?[*:0]const u8,
    dwReserved: u32,
    szXMLData: ?[*:0]u8,
    pcchXMLData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows Vista'
pub extern "msi" fn MsiExtractPatchXMLDataW(
    szPatchPath: ?[*:0]const u16,
    dwReserved: u32,
    szXMLData: ?[*:0]u16,
    pcchXMLData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchInfoExA(
    szPatchCode: ?[*:0]const u8,
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u8,
    lpValue: ?[*:0]u8,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchInfoExW(
    szPatchCode: ?[*:0]const u16,
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u16,
    lpValue: ?[*:0]u16,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiApplyMultiplePatchesA(
    szPatchPackages: ?[*:0]const u8,
    szProductCode: ?[*:0]const u8,
    szPropertiesList: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiApplyMultiplePatchesW(
    szPatchPackages: ?[*:0]const u16,
    szProductCode: ?[*:0]const u16,
    szPropertiesList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDeterminePatchSequenceA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDeterminePatchSequenceW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDetermineApplicablePatchesA(
    szProductPackagePath: ?[*:0]const u8,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDetermineApplicablePatchesW(
    szProductPackagePath: ?[*:0]const u16,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumPatchesExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: u32,
    dwFilter: u32,
    dwIndex: u32,
    szPatchCode: ?PSTR,
    szTargetProductCode: ?PSTR,
    pdwTargetProductContext: ?*MSIINSTALLCONTEXT,
    szTargetUserSid: ?[*:0]u8,
    pcchTargetUserSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumPatchesExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: u32,
    dwFilter: u32,
    dwIndex: u32,
    szPatchCode: ?PWSTR,
    szTargetProductCode: ?PWSTR,
    pdwTargetProductContext: ?*MSIINSTALLCONTEXT,
    szTargetUserSid: ?[*:0]u16,
    pcchTargetUserSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryFeatureStateA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryFeatureStateW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryFeatureStateExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szFeature: ?[*:0]const u8,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryFeatureStateExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szFeature: ?[*:0]const u16,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiUseFeatureA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiUseFeatureW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiUseFeatureExA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    dwInstallMode: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiUseFeatureExW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    dwInstallMode: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureUsageA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    pdwUseCount: ?*u32,
    pwDateUsed: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureUsageW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    pdwUseCount: ?*u32,
    pwDateUsed: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureFeatureA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureFeatureW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiReinstallFeatureA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    dwReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiReinstallFeatureW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    dwReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideComponentA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    szComponent: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideComponentW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    szComponent: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideQualifiedComponentA(
    szCategory: ?[*:0]const u8,
    szQualifier: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideQualifiedComponentW(
    szCategory: ?[*:0]const u16,
    szQualifier: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideQualifiedComponentExA(
    szCategory: ?[*:0]const u8,
    szQualifier: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    szProduct: ?[*:0]const u8,
    dwUnused1: u32,
    dwUnused2: u32,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideQualifiedComponentExW(
    szCategory: ?[*:0]const u16,
    szQualifier: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    szProduct: ?[*:0]const u16,
    dwUnused1: u32,
    dwUnused2: u32,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetComponentPathA(
    szProduct: ?[*:0]const u8,
    szComponent: ?[*:0]const u8,
    lpPathBuf: ?[*:0]u8,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetComponentPathW(
    szProduct: ?[*:0]const u16,
    szComponent: ?[*:0]const u16,
    lpPathBuf: ?[*:0]u16,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
// This function from dll 'msi' is being skipped because it has some sort of issue
pub fn MsiGetComponentPathExA() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'Windows 8'
// This function from dll 'msi' is being skipped because it has some sort of issue
pub fn MsiGetComponentPathExW() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideAssemblyA(
    szAssemblyName: ?[*:0]const u8,
    szAppContext: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    dwAssemblyInfo: MSIASSEMBLYINFO,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideAssemblyW(
    szAssemblyName: ?[*:0]const u16,
    szAppContext: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    dwAssemblyInfo: MSIASSEMBLYINFO,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryComponentStateA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szComponentCode: ?[*:0]const u8,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryComponentStateW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szComponentCode: ?[*:0]const u16,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumProductsA(
    iProductIndex: u32,
    lpProductBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumProductsW(
    iProductIndex: u32,
    lpProductBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumProductsExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: u32,
    dwIndex: u32,
    szInstalledProductCode: ?PSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u8,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumProductsExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: u32,
    dwIndex: u32,
    szInstalledProductCode: ?PWSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u16,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumRelatedProductsA(
    lpUpgradeCode: ?[*:0]const u8,
    dwReserved: u32,
    iProductIndex: u32,
    lpProductBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumRelatedProductsW(
    lpUpgradeCode: ?[*:0]const u16,
    dwReserved: u32,
    iProductIndex: u32,
    lpProductBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumFeaturesA(
    szProduct: ?[*:0]const u8,
    iFeatureIndex: u32,
    lpFeatureBuf: ?PSTR,
    lpParentBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumFeaturesW(
    szProduct: ?[*:0]const u16,
    iFeatureIndex: u32,
    lpFeatureBuf: ?PWSTR,
    lpParentBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentsA(
    iComponentIndex: u32,
    lpComponentBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentsW(
    iComponentIndex: u32,
    lpComponentBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentsExA(
    szUserSid: ?[*:0]const u8,
    dwContext: u32,
    dwIndex: u32,
    szInstalledComponentCode: ?PSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u8,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentsExW(
    szUserSid: ?[*:0]const u16,
    dwContext: u32,
    dwIndex: u32,
    szInstalledComponentCode: ?PWSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u16,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumClientsA(
    szComponent: ?[*:0]const u8,
    iProductIndex: u32,
    lpProductBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumClientsW(
    szComponent: ?[*:0]const u16,
    iProductIndex: u32,
    lpProductBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumClientsExA(
    szComponent: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwProductIndex: u32,
    szProductBuf: ?PSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u8,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumClientsExW(
    szComponent: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwProductIndex: u32,
    szProductBuf: ?PWSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u16,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentQualifiersA(
    szComponent: ?[*:0]const u8,
    iIndex: u32,
    lpQualifierBuf: [*:0]u8,
    pcchQualifierBuf: ?*u32,
    lpApplicationDataBuf: ?[*:0]u8,
    pcchApplicationDataBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentQualifiersW(
    szComponent: ?[*:0]const u16,
    iIndex: u32,
    lpQualifierBuf: [*:0]u16,
    pcchQualifierBuf: ?*u32,
    lpApplicationDataBuf: ?[*:0]u16,
    pcchApplicationDataBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenProductA(
    szProduct: ?[*:0]const u8,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenProductW(
    szProduct: ?[*:0]const u16,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenPackageA(
    szPackagePath: ?[*:0]const u8,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenPackageW(
    szPackagePath: ?[*:0]const u16,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenPackageExA(
    szPackagePath: ?[*:0]const u8,
    dwOptions: u32,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenPackageExW(
    szPackagePath: ?[*:0]const u16,
    dwOptions: u32,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchFileListA(
    szProductCode: ?[*:0]const u8,
    szPatchPackages: ?[*:0]const u8,
    pcFiles: ?*u32,
    pphFileRecords: ?*?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchFileListW(
    szProductCode: ?[*:0]const u16,
    szPatchPackages: ?[*:0]const u16,
    pcFiles: ?*u32,
    pphFileRecords: ?*?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductPropertyA(
    hProduct: MSIHANDLE,
    szProperty: ?[*:0]const u8,
    lpValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductPropertyW(
    hProduct: MSIHANDLE,
    szProperty: ?[*:0]const u16,
    lpValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiVerifyPackageA(
    szPackagePath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiVerifyPackageW(
    szPackagePath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureInfoA(
    hProduct: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    lpAttributes: ?*u32,
    lpTitleBuf: ?[*:0]u8,
    pcchTitleBuf: ?*u32,
    lpHelpBuf: ?[*:0]u8,
    pcchHelpBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureInfoW(
    hProduct: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    lpAttributes: ?*u32,
    lpTitleBuf: ?[*:0]u16,
    pcchTitleBuf: ?*u32,
    lpHelpBuf: ?[*:0]u16,
    pcchHelpBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallMissingComponentA(
    szProduct: ?[*:0]const u8,
    szComponent: ?[*:0]const u8,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallMissingComponentW(
    szProduct: ?[*:0]const u16,
    szComponent: ?[*:0]const u16,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallMissingFileA(
    szProduct: ?[*:0]const u8,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallMissingFileW(
    szProduct: ?[*:0]const u16,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiLocateComponentA(
    szComponent: ?[*:0]const u8,
    lpPathBuf: ?[*:0]u8,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiLocateComponentW(
    szComponent: ?[*:0]const u16,
    lpPathBuf: ?[*:0]u16,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearAllA(
    szProduct: ?[*:0]const u8,
    szUserName: ?[*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearAllW(
    szProduct: ?[*:0]const u16,
    szUserName: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddSourceA(
    szProduct: ?[*:0]const u8,
    szUserName: ?[*:0]const u8,
    dwReserved: u32,
    szSource: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddSourceW(
    szProduct: ?[*:0]const u16,
    szUserName: ?[*:0]const u16,
    dwReserved: u32,
    szSource: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListForceResolutionA(
    szProduct: ?[*:0]const u8,
    szUserName: ?[*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListForceResolutionW(
    szProduct: ?[*:0]const u16,
    szUserName: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddSourceExA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u8,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddSourceExW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u16,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddMediaDiskA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
    szVolumeLabel: ?[*:0]const u8,
    szDiskPrompt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddMediaDiskW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
    szVolumeLabel: ?[*:0]const u16,
    szDiskPrompt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearSourceA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearSourceW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearMediaDiskA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearMediaDiskW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearAllExA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearAllExW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListForceResolutionExA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListForceResolutionExW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListSetInfoA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u8,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListSetInfoW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u16,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListGetInfoA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u8,
    szValue: ?[*:0]u8,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListGetInfoW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u16,
    szValue: ?[*:0]u16,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListEnumSourcesA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    szSource: ?[*:0]u8,
    pcchSource: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListEnumSourcesW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    szSource: ?[*:0]u16,
    pcchSource: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListEnumMediaDisksA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    pdwDiskId: ?*u32,
    szVolumeLabel: ?[*:0]u8,
    pcchVolumeLabel: ?*u32,
    szDiskPrompt: ?[*:0]u8,
    pcchDiskPrompt: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListEnumMediaDisksW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    pdwDiskId: ?*u32,
    szVolumeLabel: ?[*:0]u16,
    pcchVolumeLabel: ?*u32,
    szDiskPrompt: ?[*:0]u16,
    pcchDiskPrompt: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileVersionA(
    szFilePath: ?[*:0]const u8,
    lpVersionBuf: ?[*:0]u8,
    pcchVersionBuf: ?*u32,
    lpLangBuf: ?[*:0]u8,
    pcchLangBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileVersionW(
    szFilePath: ?[*:0]const u16,
    lpVersionBuf: ?[*:0]u16,
    pcchVersionBuf: ?*u32,
    lpLangBuf: ?[*:0]u16,
    pcchLangBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileHashA(
    szFilePath: ?[*:0]const u8,
    dwOptions: u32,
    pHash: ?*MSIFILEHASHINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileHashW(
    szFilePath: ?[*:0]const u16,
    dwOptions: u32,
    pHash: ?*MSIFILEHASHINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileSignatureInformationA(
    szSignedObjectPath: ?[*:0]const u8,
    dwFlags: u32,
    ppcCertContext: ?*?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pbHashData: ?*u8,
    pcbHashData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileSignatureInformationW(
    szSignedObjectPath: ?[*:0]const u16,
    dwFlags: u32,
    ppcCertContext: ?*?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pbHashData: ?*u8,
    pcbHashData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetShortcutTargetA(
    szShortcutPath: ?[*:0]const u8,
    szProductCode: ?PSTR,
    szFeatureId: ?PSTR,
    szComponentCode: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetShortcutTargetW(
    szShortcutPath: ?[*:0]const u16,
    szProductCode: ?PWSTR,
    szFeatureId: ?PWSTR,
    szComponentCode: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiIsProductElevatedA(
    szProduct: ?[*:0]const u8,
    pfElevated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiIsProductElevatedW(
    szProduct: ?[*:0]const u16,
    pfElevated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiNotifySidChangeA(
    pOldSid: ?[*:0]const u8,
    pNewSid: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiNotifySidChangeW(
    pOldSid: ?[*:0]const u16,
    pNewSid: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiBeginTransactionA(
    szName: ?[*:0]const u8,
    dwTransactionAttributes: u32,
    phTransactionHandle: ?*MSIHANDLE,
    phChangeOfOwnerEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiBeginTransactionW(
    szName: ?[*:0]const u16,
    dwTransactionAttributes: u32,
    phTransactionHandle: ?*MSIHANDLE,
    phChangeOfOwnerEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEndTransaction(
    dwTransactionState: MSITRANSACTIONSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiJoinTransaction(
    hTransactionHandle: MSIHANDLE,
    dwTransactionAttributes: u32,
    phChangeOfOwnerEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseOpenViewA(
    hDatabase: MSIHANDLE,
    szQuery: ?[*:0]const u8,
    phView: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseOpenViewW(
    hDatabase: MSIHANDLE,
    szQuery: ?[*:0]const u16,
    phView: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewGetErrorA(
    hView: MSIHANDLE,
    szColumnNameBuffer: ?[*:0]u8,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) MSIDBERROR;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewGetErrorW(
    hView: MSIHANDLE,
    szColumnNameBuffer: ?[*:0]u16,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) MSIDBERROR;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewExecute(
    hView: MSIHANDLE,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewFetch(
    hView: MSIHANDLE,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewModify(
    hView: MSIHANDLE,
    eModifyMode: MSIMODIFY,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewGetColumnInfo(
    hView: MSIHANDLE,
    eColumnInfo: MSICOLINFO,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewClose(
    hView: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseGetPrimaryKeysA(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u8,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseGetPrimaryKeysW(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u16,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseIsTablePersistentA(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseIsTablePersistentW(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetSummaryInformationA(
    hDatabase: MSIHANDLE,
    szDatabasePath: ?[*:0]const u8,
    uiUpdateCount: u32,
    phSummaryInfo: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetSummaryInformationW(
    hDatabase: MSIHANDLE,
    szDatabasePath: ?[*:0]const u16,
    uiUpdateCount: u32,
    phSummaryInfo: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoGetPropertyCount(
    hSummaryInfo: MSIHANDLE,
    puiPropertyCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoSetPropertyA(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    uiDataType: u32,
    iValue: i32,
    pftValue: ?*FILETIME,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoSetPropertyW(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    uiDataType: u32,
    iValue: i32,
    pftValue: ?*FILETIME,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoGetPropertyA(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    puiDataType: ?*u32,
    piValue: ?*i32,
    pftValue: ?*FILETIME,
    szValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoGetPropertyW(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    puiDataType: ?*u32,
    piValue: ?*i32,
    pftValue: ?*FILETIME,
    szValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoPersist(
    hSummaryInfo: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenDatabaseA(
    szDatabasePath: ?[*:0]const u8,
    szPersist: ?[*:0]const u8,
    phDatabase: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenDatabaseW(
    szDatabasePath: ?[*:0]const u16,
    szPersist: ?[*:0]const u16,
    phDatabase: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseImportA(
    hDatabase: MSIHANDLE,
    szFolderPath: ?[*:0]const u8,
    szFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseImportW(
    hDatabase: MSIHANDLE,
    szFolderPath: ?[*:0]const u16,
    szFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseExportA(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u8,
    szFolderPath: ?[*:0]const u8,
    szFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseExportW(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u16,
    szFolderPath: ?[*:0]const u16,
    szFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseMergeA(
    hDatabase: MSIHANDLE,
    hDatabaseMerge: MSIHANDLE,
    szTableName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseMergeW(
    hDatabase: MSIHANDLE,
    hDatabaseMerge: MSIHANDLE,
    szTableName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseGenerateTransformA(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u8,
    iReserved1: i32,
    iReserved2: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseGenerateTransformW(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u16,
    iReserved1: i32,
    iReserved2: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseApplyTransformA(
    hDatabase: MSIHANDLE,
    szTransformFile: ?[*:0]const u8,
    iErrorConditions: MSITRANSFORM_ERROR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseApplyTransformW(
    hDatabase: MSIHANDLE,
    szTransformFile: ?[*:0]const u16,
    iErrorConditions: MSITRANSFORM_ERROR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCreateTransformSummaryInfoA(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u8,
    iErrorConditions: MSITRANSFORM_ERROR,
    iValidation: MSITRANSFORM_VALIDATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCreateTransformSummaryInfoW(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u16,
    iErrorConditions: MSITRANSFORM_ERROR,
    iValidation: MSITRANSFORM_VALIDATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseCommit(
    hDatabase: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetDatabaseState(
    hDatabase: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) MSIDBSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCreateRecord(
    cParams: u32,
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordIsNull(
    hRecord: MSIHANDLE,
    iField: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordDataSize(
    hRecord: MSIHANDLE,
    iField: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetInteger(
    hRecord: MSIHANDLE,
    iField: u32,
    iValue: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetStringA(
    hRecord: MSIHANDLE,
    iField: u32,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetStringW(
    hRecord: MSIHANDLE,
    iField: u32,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordGetInteger(
    hRecord: MSIHANDLE,
    iField: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordGetStringA(
    hRecord: MSIHANDLE,
    iField: u32,
    szValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordGetStringW(
    hRecord: MSIHANDLE,
    iField: u32,
    szValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordGetFieldCount(
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetStreamA(
    hRecord: MSIHANDLE,
    iField: u32,
    szFilePath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetStreamW(
    hRecord: MSIHANDLE,
    iField: u32,
    szFilePath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordReadStream(
    hRecord: MSIHANDLE,
    iField: u32,
    // TODO: what to do with BytesParamIndex 3?
    szDataBuf: ?PSTR,
    pcbDataBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordClearData(
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetActiveDatabase(
    hInstall: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetPropertyA(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u8,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetPropertyW(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u16,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPropertyA(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u8,
    szValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPropertyW(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u16,
    szValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetLanguage(
    hInstall: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetMode(
    hInstall: MSIHANDLE,
    eRunMode: MSIRUNMODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetMode(
    hInstall: MSIHANDLE,
    eRunMode: MSIRUNMODE,
    fState: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiFormatRecordA(
    hInstall: MSIHANDLE,
    hRecord: MSIHANDLE,
    szResultBuf: ?[*:0]u8,
    pcchResultBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiFormatRecordW(
    hInstall: MSIHANDLE,
    hRecord: MSIHANDLE,
    szResultBuf: ?[*:0]u16,
    pcchResultBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDoActionA(
    hInstall: MSIHANDLE,
    szAction: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDoActionW(
    hInstall: MSIHANDLE,
    szAction: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSequenceA(
    hInstall: MSIHANDLE,
    szTable: ?[*:0]const u8,
    iSequenceMode: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSequenceW(
    hInstall: MSIHANDLE,
    szTable: ?[*:0]const u16,
    iSequenceMode: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProcessMessage(
    hInstall: MSIHANDLE,
    eMessageType: INSTALLMESSAGE,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEvaluateConditionA(
    hInstall: MSIHANDLE,
    szCondition: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEvaluateConditionW(
    hInstall: MSIHANDLE,
    szCondition: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureStateA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureStateW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetFeatureStateA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetFeatureStateW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetFeatureAttributesA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetFeatureAttributesW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetComponentStateA(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u8,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetComponentStateW(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u16,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetComponentStateA(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u8,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetComponentStateW(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u16,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureCostA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    iCostTree: MSICOSTTREE,
    iState: INSTALLSTATE,
    piCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureCostW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    iCostTree: MSICOSTTREE,
    iState: INSTALLSTATE,
    piCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentCostsA(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u8,
    dwIndex: u32,
    iState: INSTALLSTATE,
    szDriveBuf: [*:0]u8,
    pcchDriveBuf: ?*u32,
    piCost: ?*i32,
    piTempCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentCostsW(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u16,
    dwIndex: u32,
    iState: INSTALLSTATE,
    szDriveBuf: [*:0]u16,
    pcchDriveBuf: ?*u32,
    piCost: ?*i32,
    piTempCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetInstallLevel(
    hInstall: MSIHANDLE,
    iInstallLevel: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureValidStatesA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    lpInstallStates: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureValidStatesW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    lpInstallStates: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetSourcePathA(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u8,
    szPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetSourcePathW(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u16,
    szPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetTargetPathA(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u8,
    szPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetTargetPathW(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u16,
    szPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetTargetPathA(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u8,
    szFolderPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetTargetPathW(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u16,
    szFolderPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiVerifyDiskSpace(
    hInstall: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnableUIPreview(
    hDatabase: MSIHANDLE,
    phPreview: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiPreviewDialogA(
    hPreview: MSIHANDLE,
    szDialogName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiPreviewDialogW(
    hPreview: MSIHANDLE,
    szDialogName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiPreviewBillboardA(
    hPreview: MSIHANDLE,
    szControlName: ?[*:0]const u8,
    szBillboard: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiPreviewBillboardW(
    hPreview: MSIHANDLE,
    szControlName: ?[*:0]const u16,
    szBillboard: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetLastErrorRecord(
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sfc" fn SfcGetNextProtectedFile(
    RpcHandle: ?HANDLE,
    ProtFileData: ?*PROTECTED_FILE_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sfc" fn SfcIsFileProtected(
    RpcHandle: ?HANDLE,
    ProtFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "sfc" fn SfcIsKeyProtected(
    KeyHandle: ?HKEY,
    SubKeyName: ?[*:0]const u16,
    KeySam: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "sfc" fn SfpVerifyFile(
    pszFileName: ?[*:0]const u8,
    pszError: [*:0]u8,
    dwErrSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileA(
    OldFileName: ?[*:0]const u8,
    NewFileName: ?[*:0]const u8,
    PatchFileName: ?[*:0]const u8,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileW(
    OldFileName: ?[*:0]const u16,
    NewFileName: ?[*:0]const u16,
    PatchFileName: ?[*:0]const u16,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileByHandles(
    OldFileHandle: ?HANDLE,
    NewFileHandle: ?HANDLE,
    PatchFileHandle: ?HANDLE,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileExA(
    OldFileCount: u32,
    OldFileInfoArray: [*]PATCH_OLD_FILE_INFO_A,
    NewFileName: ?[*:0]const u8,
    PatchFileName: ?[*:0]const u8,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileExW(
    OldFileCount: u32,
    OldFileInfoArray: [*]PATCH_OLD_FILE_INFO_W,
    NewFileName: ?[*:0]const u16,
    PatchFileName: ?[*:0]const u16,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileByHandlesEx(
    OldFileCount: u32,
    OldFileInfoArray: [*]PATCH_OLD_FILE_INFO_H,
    NewFileHandle: ?HANDLE,
    PatchFileHandle: ?HANDLE,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn ExtractPatchHeaderToFileA(
    PatchFileName: ?[*:0]const u8,
    PatchHeaderFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn ExtractPatchHeaderToFileW(
    PatchFileName: ?[*:0]const u16,
    PatchHeaderFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn ExtractPatchHeaderToFileByHandles(
    PatchFileHandle: ?HANDLE,
    PatchHeaderFileHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileA(
    PatchFileName: ?[*:0]const u8,
    OldFileName: ?[*:0]const u8,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileW(
    PatchFileName: ?[*:0]const u16,
    OldFileName: ?[*:0]const u16,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileByHandles(
    PatchFileHandle: ?HANDLE,
    OldFileHandle: ?HANDLE,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileByBuffers(
    // TODO: what to do with BytesParamIndex 1?
    PatchFileBuffer: ?*u8,
    PatchFileSize: u32,
    // TODO: what to do with BytesParamIndex 3?
    OldFileBuffer: ?*u8,
    OldFileSize: u32,
    NewFileSize: ?*u32,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileA(
    PatchFileName: ?[*:0]const u8,
    OldFileName: ?[*:0]const u8,
    NewFileName: ?[*:0]const u8,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileW(
    PatchFileName: ?[*:0]const u16,
    OldFileName: ?[*:0]const u16,
    NewFileName: ?[*:0]const u16,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileByHandles(
    PatchFileHandle: ?HANDLE,
    OldFileHandle: ?HANDLE,
    NewFileHandle: ?HANDLE,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileExA(
    PatchFileName: ?[*:0]const u8,
    OldFileName: ?[*:0]const u8,
    NewFileName: ?[*:0]const u8,
    ApplyOptionFlags: u32,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileExW(
    PatchFileName: ?[*:0]const u16,
    OldFileName: ?[*:0]const u16,
    NewFileName: ?[*:0]const u16,
    ApplyOptionFlags: u32,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileByHandlesEx(
    PatchFileHandle: ?HANDLE,
    OldFileHandle: ?HANDLE,
    NewFileHandle: ?HANDLE,
    ApplyOptionFlags: u32,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileByBuffers(
    // TODO: what to do with BytesParamIndex 1?
    PatchFileMapped: ?*u8,
    PatchFileSize: u32,
    // TODO: what to do with BytesParamIndex 3?
    OldFileMapped: ?*u8,
    OldFileSize: u32,
    // TODO: what to do with BytesParamIndex 5?
    NewFileBuffer: ?*?*u8,
    NewFileBufferSize: u32,
    NewFileActualSize: ?*u32,
    NewFileTime: ?*FILETIME,
    ApplyOptionFlags: u32,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureA(
    FileName: ?[*:0]const u8,
    OptionFlags: u32,
    OptionData: ?*anyopaque,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
    SignatureBufferSize: u32,
    // TODO: what to do with BytesParamIndex 7?
    SignatureBuffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureW(
    FileName: ?[*:0]const u16,
    OptionFlags: u32,
    OptionData: ?*anyopaque,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
    SignatureBufferSize: u32,
    // TODO: what to do with BytesParamIndex 7?
    SignatureBuffer: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureByHandle(
    FileHandle: ?HANDLE,
    OptionFlags: u32,
    OptionData: ?*anyopaque,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
    SignatureBufferSize: u32,
    // TODO: what to do with BytesParamIndex 7?
    SignatureBuffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureByBuffer(
    // TODO: what to do with BytesParamIndex 1?
    FileBufferWritable: ?*u8,
    FileSize: u32,
    OptionFlags: u32,
    OptionData: ?*anyopaque,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
    SignatureBufferSize: u32,
    // TODO: what to do with BytesParamIndex 8?
    SignatureBuffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn NormalizeFileForPatchSignature(
    // TODO: what to do with BytesParamIndex 1?
    FileBuffer: ?*anyopaque,
    FileSize: u32,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
    NewFileCoffBase: u32,
    NewFileCoffTime: u32,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "msdelta" fn GetDeltaInfoB(
    Delta: DELTA_INPUT,
    lpHeaderInfo: ?*DELTA_HEADER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaInfoA(
    lpDeltaName: ?[*:0]const u8,
    lpHeaderInfo: ?*DELTA_HEADER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaInfoW(
    lpDeltaName: ?[*:0]const u16,
    lpHeaderInfo: ?*DELTA_HEADER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaGetReverseB(
    ApplyFlags: i64,
    Source: DELTA_INPUT,
    Delta: DELTA_INPUT,
    lpReverseFileTime: ?*const FILETIME,
    lpTarget: ?*DELTA_OUTPUT,
    lpTargetReverse: ?*DELTA_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaB(
    ApplyFlags: i64,
    Source: DELTA_INPUT,
    Delta: DELTA_INPUT,
    lpTarget: ?*DELTA_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaProvidedB(
    ApplyFlags: i64,
    Source: DELTA_INPUT,
    Delta: DELTA_INPUT,
    // TODO: what to do with BytesParamIndex 4?
    lpTarget: ?*anyopaque,
    uTargetSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaA(
    ApplyFlags: i64,
    lpSourceName: ?[*:0]const u8,
    lpDeltaName: ?[*:0]const u8,
    lpTargetName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaW(
    ApplyFlags: i64,
    lpSourceName: ?[*:0]const u16,
    lpDeltaName: ?[*:0]const u16,
    lpTargetName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn CreateDeltaB(
    FileTypeSet: i64,
    SetFlags: i64,
    ResetFlags: i64,
    Source: DELTA_INPUT,
    Target: DELTA_INPUT,
    SourceOptions: DELTA_INPUT,
    TargetOptions: DELTA_INPUT,
    GlobalOptions: DELTA_INPUT,
    lpTargetFileTime: ?*const FILETIME,
    HashAlgId: u32,
    lpDelta: ?*DELTA_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn CreateDeltaA(
    FileTypeSet: i64,
    SetFlags: i64,
    ResetFlags: i64,
    lpSourceName: ?[*:0]const u8,
    lpTargetName: ?[*:0]const u8,
    lpSourceOptionsName: ?[*:0]const u8,
    lpTargetOptionsName: ?[*:0]const u8,
    GlobalOptions: DELTA_INPUT,
    lpTargetFileTime: ?*const FILETIME,
    HashAlgId: u32,
    lpDeltaName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn CreateDeltaW(
    FileTypeSet: i64,
    SetFlags: i64,
    ResetFlags: i64,
    lpSourceName: ?[*:0]const u16,
    lpTargetName: ?[*:0]const u16,
    lpSourceOptionsName: ?[*:0]const u16,
    lpTargetOptionsName: ?[*:0]const u16,
    GlobalOptions: DELTA_INPUT,
    lpTargetFileTime: ?*const FILETIME,
    HashAlgId: u32,
    lpDeltaName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaSignatureB(
    FileTypeSet: i64,
    HashAlgId: u32,
    Source: DELTA_INPUT,
    lpHash: ?*DELTA_HASH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaSignatureA(
    FileTypeSet: i64,
    HashAlgId: u32,
    lpSourceName: ?[*:0]const u8,
    lpHash: ?*DELTA_HASH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaSignatureW(
    FileTypeSet: i64,
    HashAlgId: u32,
    lpSourceName: ?[*:0]const u16,
    lpHash: ?*DELTA_HASH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn DeltaNormalizeProvidedB(
    FileTypeSet: i64,
    NormalizeFlags: i64,
    NormalizeOptions: DELTA_INPUT,
    // TODO: what to do with BytesParamIndex 4?
    lpSource: ?*anyopaque,
    uSourceSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn DeltaFree(
    lpMemory: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateActCtxA(
    pActCtx: ?*ACTCTXA,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateActCtxW(
    pActCtx: ?*ACTCTXW,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn AddRefActCtx(
    hActCtx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReleaseActCtx(
    hActCtx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ZombifyActCtx(
    hActCtx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ActivateActCtx(
    hActCtx: ?HANDLE,
    lpCookie: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeactivateActCtx(
    dwFlags: u32,
    ulCookie: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCurrentActCtx(
    lphActCtx: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindActCtxSectionStringA(
    dwFlags: u32,
    lpExtensionGuid: ?*const Guid,
    ulSectionId: u32,
    lpStringToFind: ?[*:0]const u8,
    ReturnedData: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindActCtxSectionStringW(
    dwFlags: u32,
    lpExtensionGuid: ?*const Guid,
    ulSectionId: u32,
    lpStringToFind: ?[*:0]const u16,
    ReturnedData: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindActCtxSectionGuid(
    dwFlags: u32,
    lpExtensionGuid: ?*const Guid,
    ulSectionId: u32,
    lpGuidToFind: ?*const Guid,
    ReturnedData: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueryActCtxW(
    dwFlags: u32,
    hActCtx: ?HANDLE,
    pvSubInstance: ?*anyopaque,
    ulInfoClass: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvBuffer: ?*anyopaque,
    cbBuffer: usize,
    pcbWrittenOrRequired: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn QueryActCtxSettingsW(
    dwFlags: u32,
    hActCtx: ?HANDLE,
    settingsNameSpace: ?[*:0]const u16,
    settingName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 5?
    pvBuffer: ?PWSTR,
    dwBuffer: usize,
    pdwWrittenOrRequired: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (133)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const INSTALLUI_HANDLER = thismodule.INSTALLUI_HANDLERA;
        pub const MSIPATCHSEQUENCEINFO = thismodule.MSIPATCHSEQUENCEINFOA;
        pub const PATCH_OLD_FILE_INFO_ = thismodule.PATCH_OLD_FILE_INFO_A;
        pub const ACTCTX = thismodule.ACTCTXA;
        pub const MsiSetExternalUI = thismodule.MsiSetExternalUIA;
        pub const MsiEnableLog = thismodule.MsiEnableLogA;
        pub const MsiQueryProductState = thismodule.MsiQueryProductStateA;
        pub const MsiGetProductInfo = thismodule.MsiGetProductInfoA;
        pub const MsiGetProductInfoEx = thismodule.MsiGetProductInfoExA;
        pub const MsiInstallProduct = thismodule.MsiInstallProductA;
        pub const MsiConfigureProduct = thismodule.MsiConfigureProductA;
        pub const MsiConfigureProductEx = thismodule.MsiConfigureProductExA;
        pub const MsiReinstallProduct = thismodule.MsiReinstallProductA;
        pub const MsiAdvertiseProductEx = thismodule.MsiAdvertiseProductExA;
        pub const MsiAdvertiseProduct = thismodule.MsiAdvertiseProductA;
        pub const MsiProcessAdvertiseScript = thismodule.MsiProcessAdvertiseScriptA;
        pub const MsiAdvertiseScript = thismodule.MsiAdvertiseScriptA;
        pub const MsiGetProductInfoFromScript = thismodule.MsiGetProductInfoFromScriptA;
        pub const MsiGetProductCode = thismodule.MsiGetProductCodeA;
        pub const MsiGetUserInfo = thismodule.MsiGetUserInfoA;
        pub const MsiCollectUserInfo = thismodule.MsiCollectUserInfoA;
        pub const MsiApplyPatch = thismodule.MsiApplyPatchA;
        pub const MsiGetPatchInfo = thismodule.MsiGetPatchInfoA;
        pub const MsiEnumPatches = thismodule.MsiEnumPatchesA;
        pub const MsiRemovePatches = thismodule.MsiRemovePatchesA;
        pub const MsiExtractPatchXMLData = thismodule.MsiExtractPatchXMLDataA;
        pub const MsiGetPatchInfoEx = thismodule.MsiGetPatchInfoExA;
        pub const MsiApplyMultiplePatches = thismodule.MsiApplyMultiplePatchesA;
        pub const MsiDeterminePatchSequence = thismodule.MsiDeterminePatchSequenceA;
        pub const MsiDetermineApplicablePatches = thismodule.MsiDetermineApplicablePatchesA;
        pub const MsiEnumPatchesEx = thismodule.MsiEnumPatchesExA;
        pub const MsiQueryFeatureState = thismodule.MsiQueryFeatureStateA;
        pub const MsiQueryFeatureStateEx = thismodule.MsiQueryFeatureStateExA;
        pub const MsiUseFeature = thismodule.MsiUseFeatureA;
        pub const MsiUseFeatureEx = thismodule.MsiUseFeatureExA;
        pub const MsiGetFeatureUsage = thismodule.MsiGetFeatureUsageA;
        pub const MsiConfigureFeature = thismodule.MsiConfigureFeatureA;
        pub const MsiReinstallFeature = thismodule.MsiReinstallFeatureA;
        pub const MsiProvideComponent = thismodule.MsiProvideComponentA;
        pub const MsiProvideQualifiedComponent = thismodule.MsiProvideQualifiedComponentA;
        pub const MsiProvideQualifiedComponentEx = thismodule.MsiProvideQualifiedComponentExA;
        pub const MsiGetComponentPath = thismodule.MsiGetComponentPathA;
        pub const MsiGetComponentPathEx = thismodule.MsiGetComponentPathExA;
        pub const MsiProvideAssembly = thismodule.MsiProvideAssemblyA;
        pub const MsiQueryComponentState = thismodule.MsiQueryComponentStateA;
        pub const MsiEnumProducts = thismodule.MsiEnumProductsA;
        pub const MsiEnumProductsEx = thismodule.MsiEnumProductsExA;
        pub const MsiEnumRelatedProducts = thismodule.MsiEnumRelatedProductsA;
        pub const MsiEnumFeatures = thismodule.MsiEnumFeaturesA;
        pub const MsiEnumComponents = thismodule.MsiEnumComponentsA;
        pub const MsiEnumComponentsEx = thismodule.MsiEnumComponentsExA;
        pub const MsiEnumClients = thismodule.MsiEnumClientsA;
        pub const MsiEnumClientsEx = thismodule.MsiEnumClientsExA;
        pub const MsiEnumComponentQualifiers = thismodule.MsiEnumComponentQualifiersA;
        pub const MsiOpenProduct = thismodule.MsiOpenProductA;
        pub const MsiOpenPackage = thismodule.MsiOpenPackageA;
        pub const MsiOpenPackageEx = thismodule.MsiOpenPackageExA;
        pub const MsiGetPatchFileList = thismodule.MsiGetPatchFileListA;
        pub const MsiGetProductProperty = thismodule.MsiGetProductPropertyA;
        pub const MsiVerifyPackage = thismodule.MsiVerifyPackageA;
        pub const MsiGetFeatureInfo = thismodule.MsiGetFeatureInfoA;
        pub const MsiInstallMissingComponent = thismodule.MsiInstallMissingComponentA;
        pub const MsiInstallMissingFile = thismodule.MsiInstallMissingFileA;
        pub const MsiLocateComponent = thismodule.MsiLocateComponentA;
        pub const MsiSourceListClearAll = thismodule.MsiSourceListClearAllA;
        pub const MsiSourceListAddSource = thismodule.MsiSourceListAddSourceA;
        pub const MsiSourceListForceResolution = thismodule.MsiSourceListForceResolutionA;
        pub const MsiSourceListAddSourceEx = thismodule.MsiSourceListAddSourceExA;
        pub const MsiSourceListAddMediaDisk = thismodule.MsiSourceListAddMediaDiskA;
        pub const MsiSourceListClearSource = thismodule.MsiSourceListClearSourceA;
        pub const MsiSourceListClearMediaDisk = thismodule.MsiSourceListClearMediaDiskA;
        pub const MsiSourceListClearAllEx = thismodule.MsiSourceListClearAllExA;
        pub const MsiSourceListForceResolutionEx = thismodule.MsiSourceListForceResolutionExA;
        pub const MsiSourceListSetInfo = thismodule.MsiSourceListSetInfoA;
        pub const MsiSourceListGetInfo = thismodule.MsiSourceListGetInfoA;
        pub const MsiSourceListEnumSources = thismodule.MsiSourceListEnumSourcesA;
        pub const MsiSourceListEnumMediaDisks = thismodule.MsiSourceListEnumMediaDisksA;
        pub const MsiGetFileVersion = thismodule.MsiGetFileVersionA;
        pub const MsiGetFileHash = thismodule.MsiGetFileHashA;
        pub const MsiGetFileSignatureInformation = thismodule.MsiGetFileSignatureInformationA;
        pub const MsiGetShortcutTarget = thismodule.MsiGetShortcutTargetA;
        pub const MsiIsProductElevated = thismodule.MsiIsProductElevatedA;
        pub const MsiNotifySidChange = thismodule.MsiNotifySidChangeA;
        pub const MsiBeginTransaction = thismodule.MsiBeginTransactionA;
        pub const MsiDatabaseOpenView = thismodule.MsiDatabaseOpenViewA;
        pub const MsiViewGetError = thismodule.MsiViewGetErrorA;
        pub const MsiDatabaseGetPrimaryKeys = thismodule.MsiDatabaseGetPrimaryKeysA;
        pub const MsiDatabaseIsTablePersistent = thismodule.MsiDatabaseIsTablePersistentA;
        pub const MsiGetSummaryInformation = thismodule.MsiGetSummaryInformationA;
        pub const MsiSummaryInfoSetProperty = thismodule.MsiSummaryInfoSetPropertyA;
        pub const MsiSummaryInfoGetProperty = thismodule.MsiSummaryInfoGetPropertyA;
        pub const MsiOpenDatabase = thismodule.MsiOpenDatabaseA;
        pub const MsiDatabaseImport = thismodule.MsiDatabaseImportA;
        pub const MsiDatabaseExport = thismodule.MsiDatabaseExportA;
        pub const MsiDatabaseMerge = thismodule.MsiDatabaseMergeA;
        pub const MsiDatabaseGenerateTransform = thismodule.MsiDatabaseGenerateTransformA;
        pub const MsiDatabaseApplyTransform = thismodule.MsiDatabaseApplyTransformA;
        pub const MsiCreateTransformSummaryInfo = thismodule.MsiCreateTransformSummaryInfoA;
        pub const MsiRecordSetString = thismodule.MsiRecordSetStringA;
        pub const MsiRecordGetString = thismodule.MsiRecordGetStringA;
        pub const MsiRecordSetStream = thismodule.MsiRecordSetStreamA;
        pub const MsiSetProperty = thismodule.MsiSetPropertyA;
        pub const MsiGetProperty = thismodule.MsiGetPropertyA;
        pub const MsiFormatRecord = thismodule.MsiFormatRecordA;
        pub const MsiDoAction = thismodule.MsiDoActionA;
        pub const MsiSequence = thismodule.MsiSequenceA;
        pub const MsiEvaluateCondition = thismodule.MsiEvaluateConditionA;
        pub const MsiGetFeatureState = thismodule.MsiGetFeatureStateA;
        pub const MsiSetFeatureState = thismodule.MsiSetFeatureStateA;
        pub const MsiSetFeatureAttributes = thismodule.MsiSetFeatureAttributesA;
        pub const MsiGetComponentState = thismodule.MsiGetComponentStateA;
        pub const MsiSetComponentState = thismodule.MsiSetComponentStateA;
        pub const MsiGetFeatureCost = thismodule.MsiGetFeatureCostA;
        pub const MsiEnumComponentCosts = thismodule.MsiEnumComponentCostsA;
        pub const MsiGetFeatureValidStates = thismodule.MsiGetFeatureValidStatesA;
        pub const MsiGetSourcePath = thismodule.MsiGetSourcePathA;
        pub const MsiGetTargetPath = thismodule.MsiGetTargetPathA;
        pub const MsiSetTargetPath = thismodule.MsiSetTargetPathA;
        pub const MsiPreviewDialog = thismodule.MsiPreviewDialogA;
        pub const MsiPreviewBillboard = thismodule.MsiPreviewBillboardA;
        pub const CreatePatchFile = thismodule.CreatePatchFileA;
        pub const CreatePatchFileEx = thismodule.CreatePatchFileExA;
        pub const ExtractPatchHeaderToFile = thismodule.ExtractPatchHeaderToFileA;
        pub const TestApplyPatchToFile = thismodule.TestApplyPatchToFileA;
        pub const ApplyPatchToFile = thismodule.ApplyPatchToFileA;
        pub const ApplyPatchToFileEx = thismodule.ApplyPatchToFileExA;
        pub const GetFilePatchSignature = thismodule.GetFilePatchSignatureA;
        pub const GetDeltaInfo = thismodule.GetDeltaInfoA;
        pub const ApplyDelta = thismodule.ApplyDeltaA;
        pub const CreateDelta = thismodule.CreateDeltaA;
        pub const GetDeltaSignature = thismodule.GetDeltaSignatureA;
        pub const CreateActCtx = thismodule.CreateActCtxA;
        pub const FindActCtxSectionString = thismodule.FindActCtxSectionStringA;
    },
    .wide => struct {
        pub const INSTALLUI_HANDLER = thismodule.INSTALLUI_HANDLERW;
        pub const MSIPATCHSEQUENCEINFO = thismodule.MSIPATCHSEQUENCEINFOW;
        pub const PATCH_OLD_FILE_INFO_ = thismodule.PATCH_OLD_FILE_INFO_W;
        pub const ACTCTX = thismodule.ACTCTXW;
        pub const MsiSetExternalUI = thismodule.MsiSetExternalUIW;
        pub const MsiEnableLog = thismodule.MsiEnableLogW;
        pub const MsiQueryProductState = thismodule.MsiQueryProductStateW;
        pub const MsiGetProductInfo = thismodule.MsiGetProductInfoW;
        pub const MsiGetProductInfoEx = thismodule.MsiGetProductInfoExW;
        pub const MsiInstallProduct = thismodule.MsiInstallProductW;
        pub const MsiConfigureProduct = thismodule.MsiConfigureProductW;
        pub const MsiConfigureProductEx = thismodule.MsiConfigureProductExW;
        pub const MsiReinstallProduct = thismodule.MsiReinstallProductW;
        pub const MsiAdvertiseProductEx = thismodule.MsiAdvertiseProductExW;
        pub const MsiAdvertiseProduct = thismodule.MsiAdvertiseProductW;
        pub const MsiProcessAdvertiseScript = thismodule.MsiProcessAdvertiseScriptW;
        pub const MsiAdvertiseScript = thismodule.MsiAdvertiseScriptW;
        pub const MsiGetProductInfoFromScript = thismodule.MsiGetProductInfoFromScriptW;
        pub const MsiGetProductCode = thismodule.MsiGetProductCodeW;
        pub const MsiGetUserInfo = thismodule.MsiGetUserInfoW;
        pub const MsiCollectUserInfo = thismodule.MsiCollectUserInfoW;
        pub const MsiApplyPatch = thismodule.MsiApplyPatchW;
        pub const MsiGetPatchInfo = thismodule.MsiGetPatchInfoW;
        pub const MsiEnumPatches = thismodule.MsiEnumPatchesW;
        pub const MsiRemovePatches = thismodule.MsiRemovePatchesW;
        pub const MsiExtractPatchXMLData = thismodule.MsiExtractPatchXMLDataW;
        pub const MsiGetPatchInfoEx = thismodule.MsiGetPatchInfoExW;
        pub const MsiApplyMultiplePatches = thismodule.MsiApplyMultiplePatchesW;
        pub const MsiDeterminePatchSequence = thismodule.MsiDeterminePatchSequenceW;
        pub const MsiDetermineApplicablePatches = thismodule.MsiDetermineApplicablePatchesW;
        pub const MsiEnumPatchesEx = thismodule.MsiEnumPatchesExW;
        pub const MsiQueryFeatureState = thismodule.MsiQueryFeatureStateW;
        pub const MsiQueryFeatureStateEx = thismodule.MsiQueryFeatureStateExW;
        pub const MsiUseFeature = thismodule.MsiUseFeatureW;
        pub const MsiUseFeatureEx = thismodule.MsiUseFeatureExW;
        pub const MsiGetFeatureUsage = thismodule.MsiGetFeatureUsageW;
        pub const MsiConfigureFeature = thismodule.MsiConfigureFeatureW;
        pub const MsiReinstallFeature = thismodule.MsiReinstallFeatureW;
        pub const MsiProvideComponent = thismodule.MsiProvideComponentW;
        pub const MsiProvideQualifiedComponent = thismodule.MsiProvideQualifiedComponentW;
        pub const MsiProvideQualifiedComponentEx = thismodule.MsiProvideQualifiedComponentExW;
        pub const MsiGetComponentPath = thismodule.MsiGetComponentPathW;
        pub const MsiGetComponentPathEx = thismodule.MsiGetComponentPathExW;
        pub const MsiProvideAssembly = thismodule.MsiProvideAssemblyW;
        pub const MsiQueryComponentState = thismodule.MsiQueryComponentStateW;
        pub const MsiEnumProducts = thismodule.MsiEnumProductsW;
        pub const MsiEnumProductsEx = thismodule.MsiEnumProductsExW;
        pub const MsiEnumRelatedProducts = thismodule.MsiEnumRelatedProductsW;
        pub const MsiEnumFeatures = thismodule.MsiEnumFeaturesW;
        pub const MsiEnumComponents = thismodule.MsiEnumComponentsW;
        pub const MsiEnumComponentsEx = thismodule.MsiEnumComponentsExW;
        pub const MsiEnumClients = thismodule.MsiEnumClientsW;
        pub const MsiEnumClientsEx = thismodule.MsiEnumClientsExW;
        pub const MsiEnumComponentQualifiers = thismodule.MsiEnumComponentQualifiersW;
        pub const MsiOpenProduct = thismodule.MsiOpenProductW;
        pub const MsiOpenPackage = thismodule.MsiOpenPackageW;
        pub const MsiOpenPackageEx = thismodule.MsiOpenPackageExW;
        pub const MsiGetPatchFileList = thismodule.MsiGetPatchFileListW;
        pub const MsiGetProductProperty = thismodule.MsiGetProductPropertyW;
        pub const MsiVerifyPackage = thismodule.MsiVerifyPackageW;
        pub const MsiGetFeatureInfo = thismodule.MsiGetFeatureInfoW;
        pub const MsiInstallMissingComponent = thismodule.MsiInstallMissingComponentW;
        pub const MsiInstallMissingFile = thismodule.MsiInstallMissingFileW;
        pub const MsiLocateComponent = thismodule.MsiLocateComponentW;
        pub const MsiSourceListClearAll = thismodule.MsiSourceListClearAllW;
        pub const MsiSourceListAddSource = thismodule.MsiSourceListAddSourceW;
        pub const MsiSourceListForceResolution = thismodule.MsiSourceListForceResolutionW;
        pub const MsiSourceListAddSourceEx = thismodule.MsiSourceListAddSourceExW;
        pub const MsiSourceListAddMediaDisk = thismodule.MsiSourceListAddMediaDiskW;
        pub const MsiSourceListClearSource = thismodule.MsiSourceListClearSourceW;
        pub const MsiSourceListClearMediaDisk = thismodule.MsiSourceListClearMediaDiskW;
        pub const MsiSourceListClearAllEx = thismodule.MsiSourceListClearAllExW;
        pub const MsiSourceListForceResolutionEx = thismodule.MsiSourceListForceResolutionExW;
        pub const MsiSourceListSetInfo = thismodule.MsiSourceListSetInfoW;
        pub const MsiSourceListGetInfo = thismodule.MsiSourceListGetInfoW;
        pub const MsiSourceListEnumSources = thismodule.MsiSourceListEnumSourcesW;
        pub const MsiSourceListEnumMediaDisks = thismodule.MsiSourceListEnumMediaDisksW;
        pub const MsiGetFileVersion = thismodule.MsiGetFileVersionW;
        pub const MsiGetFileHash = thismodule.MsiGetFileHashW;
        pub const MsiGetFileSignatureInformation = thismodule.MsiGetFileSignatureInformationW;
        pub const MsiGetShortcutTarget = thismodule.MsiGetShortcutTargetW;
        pub const MsiIsProductElevated = thismodule.MsiIsProductElevatedW;
        pub const MsiNotifySidChange = thismodule.MsiNotifySidChangeW;
        pub const MsiBeginTransaction = thismodule.MsiBeginTransactionW;
        pub const MsiDatabaseOpenView = thismodule.MsiDatabaseOpenViewW;
        pub const MsiViewGetError = thismodule.MsiViewGetErrorW;
        pub const MsiDatabaseGetPrimaryKeys = thismodule.MsiDatabaseGetPrimaryKeysW;
        pub const MsiDatabaseIsTablePersistent = thismodule.MsiDatabaseIsTablePersistentW;
        pub const MsiGetSummaryInformation = thismodule.MsiGetSummaryInformationW;
        pub const MsiSummaryInfoSetProperty = thismodule.MsiSummaryInfoSetPropertyW;
        pub const MsiSummaryInfoGetProperty = thismodule.MsiSummaryInfoGetPropertyW;
        pub const MsiOpenDatabase = thismodule.MsiOpenDatabaseW;
        pub const MsiDatabaseImport = thismodule.MsiDatabaseImportW;
        pub const MsiDatabaseExport = thismodule.MsiDatabaseExportW;
        pub const MsiDatabaseMerge = thismodule.MsiDatabaseMergeW;
        pub const MsiDatabaseGenerateTransform = thismodule.MsiDatabaseGenerateTransformW;
        pub const MsiDatabaseApplyTransform = thismodule.MsiDatabaseApplyTransformW;
        pub const MsiCreateTransformSummaryInfo = thismodule.MsiCreateTransformSummaryInfoW;
        pub const MsiRecordSetString = thismodule.MsiRecordSetStringW;
        pub const MsiRecordGetString = thismodule.MsiRecordGetStringW;
        pub const MsiRecordSetStream = thismodule.MsiRecordSetStreamW;
        pub const MsiSetProperty = thismodule.MsiSetPropertyW;
        pub const MsiGetProperty = thismodule.MsiGetPropertyW;
        pub const MsiFormatRecord = thismodule.MsiFormatRecordW;
        pub const MsiDoAction = thismodule.MsiDoActionW;
        pub const MsiSequence = thismodule.MsiSequenceW;
        pub const MsiEvaluateCondition = thismodule.MsiEvaluateConditionW;
        pub const MsiGetFeatureState = thismodule.MsiGetFeatureStateW;
        pub const MsiSetFeatureState = thismodule.MsiSetFeatureStateW;
        pub const MsiSetFeatureAttributes = thismodule.MsiSetFeatureAttributesW;
        pub const MsiGetComponentState = thismodule.MsiGetComponentStateW;
        pub const MsiSetComponentState = thismodule.MsiSetComponentStateW;
        pub const MsiGetFeatureCost = thismodule.MsiGetFeatureCostW;
        pub const MsiEnumComponentCosts = thismodule.MsiEnumComponentCostsW;
        pub const MsiGetFeatureValidStates = thismodule.MsiGetFeatureValidStatesW;
        pub const MsiGetSourcePath = thismodule.MsiGetSourcePathW;
        pub const MsiGetTargetPath = thismodule.MsiGetTargetPathW;
        pub const MsiSetTargetPath = thismodule.MsiSetTargetPathW;
        pub const MsiPreviewDialog = thismodule.MsiPreviewDialogW;
        pub const MsiPreviewBillboard = thismodule.MsiPreviewBillboardW;
        pub const CreatePatchFile = thismodule.CreatePatchFileW;
        pub const CreatePatchFileEx = thismodule.CreatePatchFileExW;
        pub const ExtractPatchHeaderToFile = thismodule.ExtractPatchHeaderToFileW;
        pub const TestApplyPatchToFile = thismodule.TestApplyPatchToFileW;
        pub const ApplyPatchToFile = thismodule.ApplyPatchToFileW;
        pub const ApplyPatchToFileEx = thismodule.ApplyPatchToFileExW;
        pub const GetFilePatchSignature = thismodule.GetFilePatchSignatureW;
        pub const GetDeltaInfo = thismodule.GetDeltaInfoW;
        pub const ApplyDelta = thismodule.ApplyDeltaW;
        pub const CreateDelta = thismodule.CreateDeltaW;
        pub const GetDeltaSignature = thismodule.GetDeltaSignatureW;
        pub const CreateActCtx = thismodule.CreateActCtxW;
        pub const FindActCtxSectionString = thismodule.FindActCtxSectionStringW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const INSTALLUI_HANDLER = *opaque{};
        pub const MSIPATCHSEQUENCEINFO = *opaque{};
        pub const PATCH_OLD_FILE_INFO_ = *opaque{};
        pub const ACTCTX = *opaque{};
        pub const MsiSetExternalUI = *opaque{};
        pub const MsiEnableLog = *opaque{};
        pub const MsiQueryProductState = *opaque{};
        pub const MsiGetProductInfo = *opaque{};
        pub const MsiGetProductInfoEx = *opaque{};
        pub const MsiInstallProduct = *opaque{};
        pub const MsiConfigureProduct = *opaque{};
        pub const MsiConfigureProductEx = *opaque{};
        pub const MsiReinstallProduct = *opaque{};
        pub const MsiAdvertiseProductEx = *opaque{};
        pub const MsiAdvertiseProduct = *opaque{};
        pub const MsiProcessAdvertiseScript = *opaque{};
        pub const MsiAdvertiseScript = *opaque{};
        pub const MsiGetProductInfoFromScript = *opaque{};
        pub const MsiGetProductCode = *opaque{};
        pub const MsiGetUserInfo = *opaque{};
        pub const MsiCollectUserInfo = *opaque{};
        pub const MsiApplyPatch = *opaque{};
        pub const MsiGetPatchInfo = *opaque{};
        pub const MsiEnumPatches = *opaque{};
        pub const MsiRemovePatches = *opaque{};
        pub const MsiExtractPatchXMLData = *opaque{};
        pub const MsiGetPatchInfoEx = *opaque{};
        pub const MsiApplyMultiplePatches = *opaque{};
        pub const MsiDeterminePatchSequence = *opaque{};
        pub const MsiDetermineApplicablePatches = *opaque{};
        pub const MsiEnumPatchesEx = *opaque{};
        pub const MsiQueryFeatureState = *opaque{};
        pub const MsiQueryFeatureStateEx = *opaque{};
        pub const MsiUseFeature = *opaque{};
        pub const MsiUseFeatureEx = *opaque{};
        pub const MsiGetFeatureUsage = *opaque{};
        pub const MsiConfigureFeature = *opaque{};
        pub const MsiReinstallFeature = *opaque{};
        pub const MsiProvideComponent = *opaque{};
        pub const MsiProvideQualifiedComponent = *opaque{};
        pub const MsiProvideQualifiedComponentEx = *opaque{};
        pub const MsiGetComponentPath = *opaque{};
        pub const MsiGetComponentPathEx = *opaque{};
        pub const MsiProvideAssembly = *opaque{};
        pub const MsiQueryComponentState = *opaque{};
        pub const MsiEnumProducts = *opaque{};
        pub const MsiEnumProductsEx = *opaque{};
        pub const MsiEnumRelatedProducts = *opaque{};
        pub const MsiEnumFeatures = *opaque{};
        pub const MsiEnumComponents = *opaque{};
        pub const MsiEnumComponentsEx = *opaque{};
        pub const MsiEnumClients = *opaque{};
        pub const MsiEnumClientsEx = *opaque{};
        pub const MsiEnumComponentQualifiers = *opaque{};
        pub const MsiOpenProduct = *opaque{};
        pub const MsiOpenPackage = *opaque{};
        pub const MsiOpenPackageEx = *opaque{};
        pub const MsiGetPatchFileList = *opaque{};
        pub const MsiGetProductProperty = *opaque{};
        pub const MsiVerifyPackage = *opaque{};
        pub const MsiGetFeatureInfo = *opaque{};
        pub const MsiInstallMissingComponent = *opaque{};
        pub const MsiInstallMissingFile = *opaque{};
        pub const MsiLocateComponent = *opaque{};
        pub const MsiSourceListClearAll = *opaque{};
        pub const MsiSourceListAddSource = *opaque{};
        pub const MsiSourceListForceResolution = *opaque{};
        pub const MsiSourceListAddSourceEx = *opaque{};
        pub const MsiSourceListAddMediaDisk = *opaque{};
        pub const MsiSourceListClearSource = *opaque{};
        pub const MsiSourceListClearMediaDisk = *opaque{};
        pub const MsiSourceListClearAllEx = *opaque{};
        pub const MsiSourceListForceResolutionEx = *opaque{};
        pub const MsiSourceListSetInfo = *opaque{};
        pub const MsiSourceListGetInfo = *opaque{};
        pub const MsiSourceListEnumSources = *opaque{};
        pub const MsiSourceListEnumMediaDisks = *opaque{};
        pub const MsiGetFileVersion = *opaque{};
        pub const MsiGetFileHash = *opaque{};
        pub const MsiGetFileSignatureInformation = *opaque{};
        pub const MsiGetShortcutTarget = *opaque{};
        pub const MsiIsProductElevated = *opaque{};
        pub const MsiNotifySidChange = *opaque{};
        pub const MsiBeginTransaction = *opaque{};
        pub const MsiDatabaseOpenView = *opaque{};
        pub const MsiViewGetError = *opaque{};
        pub const MsiDatabaseGetPrimaryKeys = *opaque{};
        pub const MsiDatabaseIsTablePersistent = *opaque{};
        pub const MsiGetSummaryInformation = *opaque{};
        pub const MsiSummaryInfoSetProperty = *opaque{};
        pub const MsiSummaryInfoGetProperty = *opaque{};
        pub const MsiOpenDatabase = *opaque{};
        pub const MsiDatabaseImport = *opaque{};
        pub const MsiDatabaseExport = *opaque{};
        pub const MsiDatabaseMerge = *opaque{};
        pub const MsiDatabaseGenerateTransform = *opaque{};
        pub const MsiDatabaseApplyTransform = *opaque{};
        pub const MsiCreateTransformSummaryInfo = *opaque{};
        pub const MsiRecordSetString = *opaque{};
        pub const MsiRecordGetString = *opaque{};
        pub const MsiRecordSetStream = *opaque{};
        pub const MsiSetProperty = *opaque{};
        pub const MsiGetProperty = *opaque{};
        pub const MsiFormatRecord = *opaque{};
        pub const MsiDoAction = *opaque{};
        pub const MsiSequence = *opaque{};
        pub const MsiEvaluateCondition = *opaque{};
        pub const MsiGetFeatureState = *opaque{};
        pub const MsiSetFeatureState = *opaque{};
        pub const MsiSetFeatureAttributes = *opaque{};
        pub const MsiGetComponentState = *opaque{};
        pub const MsiSetComponentState = *opaque{};
        pub const MsiGetFeatureCost = *opaque{};
        pub const MsiEnumComponentCosts = *opaque{};
        pub const MsiGetFeatureValidStates = *opaque{};
        pub const MsiGetSourcePath = *opaque{};
        pub const MsiGetTargetPath = *opaque{};
        pub const MsiSetTargetPath = *opaque{};
        pub const MsiPreviewDialog = *opaque{};
        pub const MsiPreviewBillboard = *opaque{};
        pub const CreatePatchFile = *opaque{};
        pub const CreatePatchFileEx = *opaque{};
        pub const ExtractPatchHeaderToFile = *opaque{};
        pub const TestApplyPatchToFile = *opaque{};
        pub const ApplyPatchToFile = *opaque{};
        pub const ApplyPatchToFileEx = *opaque{};
        pub const GetFilePatchSignature = *opaque{};
        pub const GetDeltaInfo = *opaque{};
        pub const ApplyDelta = *opaque{};
        pub const CreateDelta = *opaque{};
        pub const GetDeltaSignature = *opaque{};
        pub const CreateActCtx = *opaque{};
        pub const FindActCtxSectionString = *opaque{};
    } else struct {
        pub const INSTALLUI_HANDLER = @compileError("'INSTALLUI_HANDLER' requires that UNICODE be set to true or false in the root module");
        pub const MSIPATCHSEQUENCEINFO = @compileError("'MSIPATCHSEQUENCEINFO' requires that UNICODE be set to true or false in the root module");
        pub const PATCH_OLD_FILE_INFO_ = @compileError("'PATCH_OLD_FILE_INFO_' requires that UNICODE be set to true or false in the root module");
        pub const ACTCTX = @compileError("'ACTCTX' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetExternalUI = @compileError("'MsiSetExternalUI' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnableLog = @compileError("'MsiEnableLog' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryProductState = @compileError("'MsiQueryProductState' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductInfo = @compileError("'MsiGetProductInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductInfoEx = @compileError("'MsiGetProductInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiInstallProduct = @compileError("'MsiInstallProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiConfigureProduct = @compileError("'MsiConfigureProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiConfigureProductEx = @compileError("'MsiConfigureProductEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiReinstallProduct = @compileError("'MsiReinstallProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiAdvertiseProductEx = @compileError("'MsiAdvertiseProductEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiAdvertiseProduct = @compileError("'MsiAdvertiseProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiProcessAdvertiseScript = @compileError("'MsiProcessAdvertiseScript' requires that UNICODE be set to true or false in the root module");
        pub const MsiAdvertiseScript = @compileError("'MsiAdvertiseScript' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductInfoFromScript = @compileError("'MsiGetProductInfoFromScript' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductCode = @compileError("'MsiGetProductCode' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetUserInfo = @compileError("'MsiGetUserInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiCollectUserInfo = @compileError("'MsiCollectUserInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiApplyPatch = @compileError("'MsiApplyPatch' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetPatchInfo = @compileError("'MsiGetPatchInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumPatches = @compileError("'MsiEnumPatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiRemovePatches = @compileError("'MsiRemovePatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiExtractPatchXMLData = @compileError("'MsiExtractPatchXMLData' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetPatchInfoEx = @compileError("'MsiGetPatchInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiApplyMultiplePatches = @compileError("'MsiApplyMultiplePatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiDeterminePatchSequence = @compileError("'MsiDeterminePatchSequence' requires that UNICODE be set to true or false in the root module");
        pub const MsiDetermineApplicablePatches = @compileError("'MsiDetermineApplicablePatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumPatchesEx = @compileError("'MsiEnumPatchesEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryFeatureState = @compileError("'MsiQueryFeatureState' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryFeatureStateEx = @compileError("'MsiQueryFeatureStateEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiUseFeature = @compileError("'MsiUseFeature' requires that UNICODE be set to true or false in the root module");
        pub const MsiUseFeatureEx = @compileError("'MsiUseFeatureEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureUsage = @compileError("'MsiGetFeatureUsage' requires that UNICODE be set to true or false in the root module");
        pub const MsiConfigureFeature = @compileError("'MsiConfigureFeature' requires that UNICODE be set to true or false in the root module");
        pub const MsiReinstallFeature = @compileError("'MsiReinstallFeature' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideComponent = @compileError("'MsiProvideComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideQualifiedComponent = @compileError("'MsiProvideQualifiedComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideQualifiedComponentEx = @compileError("'MsiProvideQualifiedComponentEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetComponentPath = @compileError("'MsiGetComponentPath' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetComponentPathEx = @compileError("'MsiGetComponentPathEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideAssembly = @compileError("'MsiProvideAssembly' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryComponentState = @compileError("'MsiQueryComponentState' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumProducts = @compileError("'MsiEnumProducts' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumProductsEx = @compileError("'MsiEnumProductsEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumRelatedProducts = @compileError("'MsiEnumRelatedProducts' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumFeatures = @compileError("'MsiEnumFeatures' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponents = @compileError("'MsiEnumComponents' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponentsEx = @compileError("'MsiEnumComponentsEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumClients = @compileError("'MsiEnumClients' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumClientsEx = @compileError("'MsiEnumClientsEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponentQualifiers = @compileError("'MsiEnumComponentQualifiers' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenProduct = @compileError("'MsiOpenProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenPackage = @compileError("'MsiOpenPackage' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenPackageEx = @compileError("'MsiOpenPackageEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetPatchFileList = @compileError("'MsiGetPatchFileList' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductProperty = @compileError("'MsiGetProductProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiVerifyPackage = @compileError("'MsiVerifyPackage' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureInfo = @compileError("'MsiGetFeatureInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiInstallMissingComponent = @compileError("'MsiInstallMissingComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiInstallMissingFile = @compileError("'MsiInstallMissingFile' requires that UNICODE be set to true or false in the root module");
        pub const MsiLocateComponent = @compileError("'MsiLocateComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearAll = @compileError("'MsiSourceListClearAll' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListAddSource = @compileError("'MsiSourceListAddSource' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListForceResolution = @compileError("'MsiSourceListForceResolution' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListAddSourceEx = @compileError("'MsiSourceListAddSourceEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListAddMediaDisk = @compileError("'MsiSourceListAddMediaDisk' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearSource = @compileError("'MsiSourceListClearSource' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearMediaDisk = @compileError("'MsiSourceListClearMediaDisk' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearAllEx = @compileError("'MsiSourceListClearAllEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListForceResolutionEx = @compileError("'MsiSourceListForceResolutionEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListSetInfo = @compileError("'MsiSourceListSetInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListGetInfo = @compileError("'MsiSourceListGetInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListEnumSources = @compileError("'MsiSourceListEnumSources' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListEnumMediaDisks = @compileError("'MsiSourceListEnumMediaDisks' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFileVersion = @compileError("'MsiGetFileVersion' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFileHash = @compileError("'MsiGetFileHash' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFileSignatureInformation = @compileError("'MsiGetFileSignatureInformation' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetShortcutTarget = @compileError("'MsiGetShortcutTarget' requires that UNICODE be set to true or false in the root module");
        pub const MsiIsProductElevated = @compileError("'MsiIsProductElevated' requires that UNICODE be set to true or false in the root module");
        pub const MsiNotifySidChange = @compileError("'MsiNotifySidChange' requires that UNICODE be set to true or false in the root module");
        pub const MsiBeginTransaction = @compileError("'MsiBeginTransaction' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseOpenView = @compileError("'MsiDatabaseOpenView' requires that UNICODE be set to true or false in the root module");
        pub const MsiViewGetError = @compileError("'MsiViewGetError' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseGetPrimaryKeys = @compileError("'MsiDatabaseGetPrimaryKeys' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseIsTablePersistent = @compileError("'MsiDatabaseIsTablePersistent' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetSummaryInformation = @compileError("'MsiGetSummaryInformation' requires that UNICODE be set to true or false in the root module");
        pub const MsiSummaryInfoSetProperty = @compileError("'MsiSummaryInfoSetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiSummaryInfoGetProperty = @compileError("'MsiSummaryInfoGetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenDatabase = @compileError("'MsiOpenDatabase' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseImport = @compileError("'MsiDatabaseImport' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseExport = @compileError("'MsiDatabaseExport' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseMerge = @compileError("'MsiDatabaseMerge' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseGenerateTransform = @compileError("'MsiDatabaseGenerateTransform' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseApplyTransform = @compileError("'MsiDatabaseApplyTransform' requires that UNICODE be set to true or false in the root module");
        pub const MsiCreateTransformSummaryInfo = @compileError("'MsiCreateTransformSummaryInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiRecordSetString = @compileError("'MsiRecordSetString' requires that UNICODE be set to true or false in the root module");
        pub const MsiRecordGetString = @compileError("'MsiRecordGetString' requires that UNICODE be set to true or false in the root module");
        pub const MsiRecordSetStream = @compileError("'MsiRecordSetStream' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetProperty = @compileError("'MsiSetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProperty = @compileError("'MsiGetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiFormatRecord = @compileError("'MsiFormatRecord' requires that UNICODE be set to true or false in the root module");
        pub const MsiDoAction = @compileError("'MsiDoAction' requires that UNICODE be set to true or false in the root module");
        pub const MsiSequence = @compileError("'MsiSequence' requires that UNICODE be set to true or false in the root module");
        pub const MsiEvaluateCondition = @compileError("'MsiEvaluateCondition' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureState = @compileError("'MsiGetFeatureState' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetFeatureState = @compileError("'MsiSetFeatureState' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetFeatureAttributes = @compileError("'MsiSetFeatureAttributes' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetComponentState = @compileError("'MsiGetComponentState' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetComponentState = @compileError("'MsiSetComponentState' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureCost = @compileError("'MsiGetFeatureCost' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponentCosts = @compileError("'MsiEnumComponentCosts' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureValidStates = @compileError("'MsiGetFeatureValidStates' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetSourcePath = @compileError("'MsiGetSourcePath' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetTargetPath = @compileError("'MsiGetTargetPath' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetTargetPath = @compileError("'MsiSetTargetPath' requires that UNICODE be set to true or false in the root module");
        pub const MsiPreviewDialog = @compileError("'MsiPreviewDialog' requires that UNICODE be set to true or false in the root module");
        pub const MsiPreviewBillboard = @compileError("'MsiPreviewBillboard' requires that UNICODE be set to true or false in the root module");
        pub const CreatePatchFile = @compileError("'CreatePatchFile' requires that UNICODE be set to true or false in the root module");
        pub const CreatePatchFileEx = @compileError("'CreatePatchFileEx' requires that UNICODE be set to true or false in the root module");
        pub const ExtractPatchHeaderToFile = @compileError("'ExtractPatchHeaderToFile' requires that UNICODE be set to true or false in the root module");
        pub const TestApplyPatchToFile = @compileError("'TestApplyPatchToFile' requires that UNICODE be set to true or false in the root module");
        pub const ApplyPatchToFile = @compileError("'ApplyPatchToFile' requires that UNICODE be set to true or false in the root module");
        pub const ApplyPatchToFileEx = @compileError("'ApplyPatchToFileEx' requires that UNICODE be set to true or false in the root module");
        pub const GetFilePatchSignature = @compileError("'GetFilePatchSignature' requires that UNICODE be set to true or false in the root module");
        pub const GetDeltaInfo = @compileError("'GetDeltaInfo' requires that UNICODE be set to true or false in the root module");
        pub const ApplyDelta = @compileError("'ApplyDelta' requires that UNICODE be set to true or false in the root module");
        pub const CreateDelta = @compileError("'CreateDelta' requires that UNICODE be set to true or false in the root module");
        pub const GetDeltaSignature = @compileError("'GetDeltaSignature' requires that UNICODE be set to true or false in the root module");
        pub const CreateActCtx = @compileError("'CreateActCtx' requires that UNICODE be set to true or false in the root module");
        pub const FindActCtxSectionString = @compileError("'FindActCtxSectionString' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = @import("../system/windows_programming.zig").ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CERT_CONTEXT = @import("../security/cryptography.zig").CERT_CONTEXT;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const ULARGE_INTEGER = @import("../foundation.zig").ULARGE_INTEGER;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPDISPLAYVAL")) { _ = LPDISPLAYVAL; }
    if (@hasDecl(@This(), "LPEVALCOMCALLBACK")) { _ = LPEVALCOMCALLBACK; }
    if (@hasDecl(@This(), "INSTALLUI_HANDLERA")) { _ = INSTALLUI_HANDLERA; }
    if (@hasDecl(@This(), "INSTALLUI_HANDLERW")) { _ = INSTALLUI_HANDLERW; }
    if (@hasDecl(@This(), "PINSTALLUI_HANDLER_RECORD")) { _ = PINSTALLUI_HANDLER_RECORD; }
    if (@hasDecl(@This(), "PPATCH_PROGRESS_CALLBACK")) { _ = PPATCH_PROGRESS_CALLBACK; }
    if (@hasDecl(@This(), "PPATCH_SYMLOAD_CALLBACK")) { _ = PPATCH_SYMLOAD_CALLBACK; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
