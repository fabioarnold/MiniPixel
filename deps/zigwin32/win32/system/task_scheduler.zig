//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (43)
//--------------------------------------------------------------------------------
pub const TASK_SUNDAY = @as(u32, 1);
pub const TASK_MONDAY = @as(u32, 2);
pub const TASK_TUESDAY = @as(u32, 4);
pub const TASK_WEDNESDAY = @as(u32, 8);
pub const TASK_THURSDAY = @as(u32, 16);
pub const TASK_FRIDAY = @as(u32, 32);
pub const TASK_SATURDAY = @as(u32, 64);
pub const TASK_FIRST_WEEK = @as(u32, 1);
pub const TASK_SECOND_WEEK = @as(u32, 2);
pub const TASK_THIRD_WEEK = @as(u32, 3);
pub const TASK_FOURTH_WEEK = @as(u32, 4);
pub const TASK_LAST_WEEK = @as(u32, 5);
pub const TASK_JANUARY = @as(u32, 1);
pub const TASK_FEBRUARY = @as(u32, 2);
pub const TASK_MARCH = @as(u32, 4);
pub const TASK_APRIL = @as(u32, 8);
pub const TASK_MAY = @as(u32, 16);
pub const TASK_JUNE = @as(u32, 32);
pub const TASK_JULY = @as(u32, 64);
pub const TASK_AUGUST = @as(u32, 128);
pub const TASK_SEPTEMBER = @as(u32, 256);
pub const TASK_OCTOBER = @as(u32, 512);
pub const TASK_NOVEMBER = @as(u32, 1024);
pub const TASK_DECEMBER = @as(u32, 2048);
pub const TASK_FLAG_INTERACTIVE = @as(u32, 1);
pub const TASK_FLAG_DELETE_WHEN_DONE = @as(u32, 2);
pub const TASK_FLAG_DISABLED = @as(u32, 4);
pub const TASK_FLAG_START_ONLY_IF_IDLE = @as(u32, 16);
pub const TASK_FLAG_KILL_ON_IDLE_END = @as(u32, 32);
pub const TASK_FLAG_DONT_START_IF_ON_BATTERIES = @as(u32, 64);
pub const TASK_FLAG_KILL_IF_GOING_ON_BATTERIES = @as(u32, 128);
pub const TASK_FLAG_RUN_ONLY_IF_DOCKED = @as(u32, 256);
pub const TASK_FLAG_HIDDEN = @as(u32, 512);
pub const TASK_FLAG_RUN_IF_CONNECTED_TO_INTERNET = @as(u32, 1024);
pub const TASK_FLAG_RESTART_ON_IDLE_RESUME = @as(u32, 2048);
pub const TASK_FLAG_SYSTEM_REQUIRED = @as(u32, 4096);
pub const TASK_FLAG_RUN_ONLY_IF_LOGGED_ON = @as(u32, 8192);
pub const TASK_TRIGGER_FLAG_HAS_END_DATE = @as(u32, 1);
pub const TASK_TRIGGER_FLAG_KILL_AT_DURATION_END = @as(u32, 2);
pub const TASK_TRIGGER_FLAG_DISABLED = @as(u32, 4);
pub const TASK_MAX_RUN_TIMES = @as(u32, 1440);
pub const CLSID_CTask = Guid.initString("148bd520-a2ab-11ce-b11f-00aa00530503");
pub const CLSID_CTaskScheduler = Guid.initString("148bd52a-a2ab-11ce-b11f-00aa00530503");

//--------------------------------------------------------------------------------
// Section: Types (72)
//--------------------------------------------------------------------------------
pub const TASK_TRIGGER_TYPE = enum(i32) {
    TIME_TRIGGER_ONCE = 0,
    TIME_TRIGGER_DAILY = 1,
    TIME_TRIGGER_WEEKLY = 2,
    TIME_TRIGGER_MONTHLYDATE = 3,
    TIME_TRIGGER_MONTHLYDOW = 4,
    EVENT_TRIGGER_ON_IDLE = 5,
    EVENT_TRIGGER_AT_SYSTEMSTART = 6,
    EVENT_TRIGGER_AT_LOGON = 7,
};
pub const TASK_TIME_TRIGGER_ONCE = TASK_TRIGGER_TYPE.TIME_TRIGGER_ONCE;
pub const TASK_TIME_TRIGGER_DAILY = TASK_TRIGGER_TYPE.TIME_TRIGGER_DAILY;
pub const TASK_TIME_TRIGGER_WEEKLY = TASK_TRIGGER_TYPE.TIME_TRIGGER_WEEKLY;
pub const TASK_TIME_TRIGGER_MONTHLYDATE = TASK_TRIGGER_TYPE.TIME_TRIGGER_MONTHLYDATE;
pub const TASK_TIME_TRIGGER_MONTHLYDOW = TASK_TRIGGER_TYPE.TIME_TRIGGER_MONTHLYDOW;
pub const TASK_EVENT_TRIGGER_ON_IDLE = TASK_TRIGGER_TYPE.EVENT_TRIGGER_ON_IDLE;
pub const TASK_EVENT_TRIGGER_AT_SYSTEMSTART = TASK_TRIGGER_TYPE.EVENT_TRIGGER_AT_SYSTEMSTART;
pub const TASK_EVENT_TRIGGER_AT_LOGON = TASK_TRIGGER_TYPE.EVENT_TRIGGER_AT_LOGON;

pub const DAILY = extern struct {
    DaysInterval: u16,
};

pub const WEEKLY = extern struct {
    WeeksInterval: u16,
    rgfDaysOfTheWeek: u16,
};

pub const MONTHLYDATE = extern struct {
    rgfDays: u32,
    rgfMonths: u16,
};

pub const MONTHLYDOW = extern struct {
    wWhichWeek: u16,
    rgfDaysOfTheWeek: u16,
    rgfMonths: u16,
};

pub const TRIGGER_TYPE_UNION = extern union {
    Daily: DAILY,
    Weekly: WEEKLY,
    MonthlyDate: MONTHLYDATE,
    MonthlyDOW: MONTHLYDOW,
};

pub const TASK_TRIGGER = extern struct {
    cbTriggerSize: u16,
    Reserved1: u16,
    wBeginYear: u16,
    wBeginMonth: u16,
    wBeginDay: u16,
    wEndYear: u16,
    wEndMonth: u16,
    wEndDay: u16,
    wStartHour: u16,
    wStartMinute: u16,
    MinutesDuration: u32,
    MinutesInterval: u32,
    rgFlags: u32,
    TriggerType: TASK_TRIGGER_TYPE,
    Type: TRIGGER_TYPE_UNION,
    Reserved2: u16,
    wRandomMinutesInterval: u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITaskTrigger_Value = @import("../zig.zig").Guid.initString("148bd52b-a2ab-11ce-b11f-00aa00530503");
pub const IID_ITaskTrigger = &IID_ITaskTrigger_Value;
pub const ITaskTrigger = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTrigger: fn(
            self: *const ITaskTrigger,
            pTrigger: ?*const TASK_TRIGGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrigger: fn(
            self: *const ITaskTrigger,
            pTrigger: ?*TASK_TRIGGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTriggerString: fn(
            self: *const ITaskTrigger,
            ppwszTrigger: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskTrigger_SetTrigger(self: *const T, pTrigger: ?*const TASK_TRIGGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskTrigger.VTable, self.vtable).SetTrigger(@ptrCast(*const ITaskTrigger, self), pTrigger);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskTrigger_GetTrigger(self: *const T, pTrigger: ?*TASK_TRIGGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskTrigger.VTable, self.vtable).GetTrigger(@ptrCast(*const ITaskTrigger, self), pTrigger);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskTrigger_GetTriggerString(self: *const T, ppwszTrigger: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskTrigger.VTable, self.vtable).GetTriggerString(@ptrCast(*const ITaskTrigger, self), ppwszTrigger);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IScheduledWorkItem_Value = @import("../zig.zig").Guid.initString("a6b952f0-a4b1-11d0-997d-00aa006887ec");
pub const IID_IScheduledWorkItem = &IID_IScheduledWorkItem_Value;
pub const IScheduledWorkItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTrigger: fn(
            self: *const IScheduledWorkItem,
            piNewTrigger: ?*u16,
            ppTrigger: ?*?*ITaskTrigger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTrigger: fn(
            self: *const IScheduledWorkItem,
            iTrigger: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTriggerCount: fn(
            self: *const IScheduledWorkItem,
            pwCount: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrigger: fn(
            self: *const IScheduledWorkItem,
            iTrigger: u16,
            ppTrigger: ?*?*ITaskTrigger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTriggerString: fn(
            self: *const IScheduledWorkItem,
            iTrigger: u16,
            ppwszTrigger: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunTimes: fn(
            self: *const IScheduledWorkItem,
            pstBegin: ?*const SYSTEMTIME,
            pstEnd: ?*const SYSTEMTIME,
            pCount: ?*u16,
            rgstTaskTimes: ?*?*SYSTEMTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextRunTime: fn(
            self: *const IScheduledWorkItem,
            pstNextRun: ?*SYSTEMTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIdleWait: fn(
            self: *const IScheduledWorkItem,
            wIdleMinutes: u16,
            wDeadlineMinutes: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdleWait: fn(
            self: *const IScheduledWorkItem,
            pwIdleMinutes: ?*u16,
            pwDeadlineMinutes: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IScheduledWorkItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Terminate: fn(
            self: *const IScheduledWorkItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EditWorkItem: fn(
            self: *const IScheduledWorkItem,
            hParent: ?HWND,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMostRecentRunTime: fn(
            self: *const IScheduledWorkItem,
            pstLastRun: ?*SYSTEMTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const IScheduledWorkItem,
            phrStatus: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExitCode: fn(
            self: *const IScheduledWorkItem,
            pdwExitCode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetComment: fn(
            self: *const IScheduledWorkItem,
            pwszComment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComment: fn(
            self: *const IScheduledWorkItem,
            ppwszComment: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCreator: fn(
            self: *const IScheduledWorkItem,
            pwszCreator: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCreator: fn(
            self: *const IScheduledWorkItem,
            ppwszCreator: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWorkItemData: fn(
            self: *const IScheduledWorkItem,
            cbData: u16,
            rgbData: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWorkItemData: fn(
            self: *const IScheduledWorkItem,
            pcbData: ?*u16,
            prgbData: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetErrorRetryCount: fn(
            self: *const IScheduledWorkItem,
            wRetryCount: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorRetryCount: fn(
            self: *const IScheduledWorkItem,
            pwRetryCount: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetErrorRetryInterval: fn(
            self: *const IScheduledWorkItem,
            wRetryInterval: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorRetryInterval: fn(
            self: *const IScheduledWorkItem,
            pwRetryInterval: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IScheduledWorkItem,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IScheduledWorkItem,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAccountInformation: fn(
            self: *const IScheduledWorkItem,
            pwszAccountName: ?[*:0]const u16,
            pwszPassword: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAccountInformation: fn(
            self: *const IScheduledWorkItem,
            ppwszAccountName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_CreateTrigger(self: *const T, piNewTrigger: ?*u16, ppTrigger: ?*?*ITaskTrigger) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).CreateTrigger(@ptrCast(*const IScheduledWorkItem, self), piNewTrigger, ppTrigger);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_DeleteTrigger(self: *const T, iTrigger: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).DeleteTrigger(@ptrCast(*const IScheduledWorkItem, self), iTrigger);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetTriggerCount(self: *const T, pwCount: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetTriggerCount(@ptrCast(*const IScheduledWorkItem, self), pwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetTrigger(self: *const T, iTrigger: u16, ppTrigger: ?*?*ITaskTrigger) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetTrigger(@ptrCast(*const IScheduledWorkItem, self), iTrigger, ppTrigger);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetTriggerString(self: *const T, iTrigger: u16, ppwszTrigger: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetTriggerString(@ptrCast(*const IScheduledWorkItem, self), iTrigger, ppwszTrigger);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetRunTimes(self: *const T, pstBegin: ?*const SYSTEMTIME, pstEnd: ?*const SYSTEMTIME, pCount: ?*u16, rgstTaskTimes: ?*?*SYSTEMTIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetRunTimes(@ptrCast(*const IScheduledWorkItem, self), pstBegin, pstEnd, pCount, rgstTaskTimes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetNextRunTime(self: *const T, pstNextRun: ?*SYSTEMTIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetNextRunTime(@ptrCast(*const IScheduledWorkItem, self), pstNextRun);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_SetIdleWait(self: *const T, wIdleMinutes: u16, wDeadlineMinutes: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).SetIdleWait(@ptrCast(*const IScheduledWorkItem, self), wIdleMinutes, wDeadlineMinutes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetIdleWait(self: *const T, pwIdleMinutes: ?*u16, pwDeadlineMinutes: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetIdleWait(@ptrCast(*const IScheduledWorkItem, self), pwIdleMinutes, pwDeadlineMinutes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_Run(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).Run(@ptrCast(*const IScheduledWorkItem, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_Terminate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).Terminate(@ptrCast(*const IScheduledWorkItem, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_EditWorkItem(self: *const T, hParent: ?HWND, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).EditWorkItem(@ptrCast(*const IScheduledWorkItem, self), hParent, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetMostRecentRunTime(self: *const T, pstLastRun: ?*SYSTEMTIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetMostRecentRunTime(@ptrCast(*const IScheduledWorkItem, self), pstLastRun);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetStatus(self: *const T, phrStatus: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetStatus(@ptrCast(*const IScheduledWorkItem, self), phrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetExitCode(self: *const T, pdwExitCode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetExitCode(@ptrCast(*const IScheduledWorkItem, self), pdwExitCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_SetComment(self: *const T, pwszComment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).SetComment(@ptrCast(*const IScheduledWorkItem, self), pwszComment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetComment(self: *const T, ppwszComment: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetComment(@ptrCast(*const IScheduledWorkItem, self), ppwszComment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_SetCreator(self: *const T, pwszCreator: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).SetCreator(@ptrCast(*const IScheduledWorkItem, self), pwszCreator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetCreator(self: *const T, ppwszCreator: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetCreator(@ptrCast(*const IScheduledWorkItem, self), ppwszCreator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_SetWorkItemData(self: *const T, cbData: u16, rgbData: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).SetWorkItemData(@ptrCast(*const IScheduledWorkItem, self), cbData, rgbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetWorkItemData(self: *const T, pcbData: ?*u16, prgbData: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetWorkItemData(@ptrCast(*const IScheduledWorkItem, self), pcbData, prgbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_SetErrorRetryCount(self: *const T, wRetryCount: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).SetErrorRetryCount(@ptrCast(*const IScheduledWorkItem, self), wRetryCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetErrorRetryCount(self: *const T, pwRetryCount: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetErrorRetryCount(@ptrCast(*const IScheduledWorkItem, self), pwRetryCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_SetErrorRetryInterval(self: *const T, wRetryInterval: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).SetErrorRetryInterval(@ptrCast(*const IScheduledWorkItem, self), wRetryInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetErrorRetryInterval(self: *const T, pwRetryInterval: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetErrorRetryInterval(@ptrCast(*const IScheduledWorkItem, self), pwRetryInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_SetFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).SetFlags(@ptrCast(*const IScheduledWorkItem, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetFlags(@ptrCast(*const IScheduledWorkItem, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_SetAccountInformation(self: *const T, pwszAccountName: ?[*:0]const u16, pwszPassword: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).SetAccountInformation(@ptrCast(*const IScheduledWorkItem, self), pwszAccountName, pwszPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScheduledWorkItem_GetAccountInformation(self: *const T, ppwszAccountName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScheduledWorkItem.VTable, self.vtable).GetAccountInformation(@ptrCast(*const IScheduledWorkItem, self), ppwszAccountName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITask_Value = @import("../zig.zig").Guid.initString("148bd524-a2ab-11ce-b11f-00aa00530503");
pub const IID_ITask = &IID_ITask_Value;
pub const ITask = extern struct {
    pub const VTable = extern struct {
        base: IScheduledWorkItem.VTable,
        SetApplicationName: fn(
            self: *const ITask,
            pwszApplicationName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplicationName: fn(
            self: *const ITask,
            ppwszApplicationName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameters: fn(
            self: *const ITask,
            pwszParameters: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameters: fn(
            self: *const ITask,
            ppwszParameters: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWorkingDirectory: fn(
            self: *const ITask,
            pwszWorkingDirectory: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWorkingDirectory: fn(
            self: *const ITask,
            ppwszWorkingDirectory: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPriority: fn(
            self: *const ITask,
            dwPriority: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: fn(
            self: *const ITask,
            pdwPriority: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTaskFlags: fn(
            self: *const ITask,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTaskFlags: fn(
            self: *const ITask,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMaxRunTime: fn(
            self: *const ITask,
            dwMaxRunTimeMS: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxRunTime: fn(
            self: *const ITask,
            pdwMaxRunTimeMS: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IScheduledWorkItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_SetApplicationName(self: *const T, pwszApplicationName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).SetApplicationName(@ptrCast(*const ITask, self), pwszApplicationName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_GetApplicationName(self: *const T, ppwszApplicationName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).GetApplicationName(@ptrCast(*const ITask, self), ppwszApplicationName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_SetParameters(self: *const T, pwszParameters: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).SetParameters(@ptrCast(*const ITask, self), pwszParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_GetParameters(self: *const T, ppwszParameters: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).GetParameters(@ptrCast(*const ITask, self), ppwszParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_SetWorkingDirectory(self: *const T, pwszWorkingDirectory: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).SetWorkingDirectory(@ptrCast(*const ITask, self), pwszWorkingDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_GetWorkingDirectory(self: *const T, ppwszWorkingDirectory: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).GetWorkingDirectory(@ptrCast(*const ITask, self), ppwszWorkingDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_SetPriority(self: *const T, dwPriority: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).SetPriority(@ptrCast(*const ITask, self), dwPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_GetPriority(self: *const T, pdwPriority: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).GetPriority(@ptrCast(*const ITask, self), pdwPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_SetTaskFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).SetTaskFlags(@ptrCast(*const ITask, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_GetTaskFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).GetTaskFlags(@ptrCast(*const ITask, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_SetMaxRunTime(self: *const T, dwMaxRunTimeMS: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).SetMaxRunTime(@ptrCast(*const ITask, self), dwMaxRunTimeMS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITask_GetMaxRunTime(self: *const T, pdwMaxRunTimeMS: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITask.VTable, self.vtable).GetMaxRunTime(@ptrCast(*const ITask, self), pdwMaxRunTimeMS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumWorkItems_Value = @import("../zig.zig").Guid.initString("148bd528-a2ab-11ce-b11f-00aa00530503");
pub const IID_IEnumWorkItems = &IID_IEnumWorkItems_Value;
pub const IEnumWorkItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumWorkItems,
            celt: u32,
            rgpwszNames: ?*?*?PWSTR,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumWorkItems,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumWorkItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumWorkItems,
            ppEnumWorkItems: ?*?*IEnumWorkItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumWorkItems_Next(self: *const T, celt: u32, rgpwszNames: ?*?*?PWSTR, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumWorkItems.VTable, self.vtable).Next(@ptrCast(*const IEnumWorkItems, self), celt, rgpwszNames, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumWorkItems_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumWorkItems.VTable, self.vtable).Skip(@ptrCast(*const IEnumWorkItems, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumWorkItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumWorkItems.VTable, self.vtable).Reset(@ptrCast(*const IEnumWorkItems, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumWorkItems_Clone(self: *const T, ppEnumWorkItems: ?*?*IEnumWorkItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumWorkItems.VTable, self.vtable).Clone(@ptrCast(*const IEnumWorkItems, self), ppEnumWorkItems);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITaskScheduler_Value = @import("../zig.zig").Guid.initString("148bd527-a2ab-11ce-b11f-00aa00530503");
pub const IID_ITaskScheduler = &IID_ITaskScheduler_Value;
pub const ITaskScheduler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTargetComputer: fn(
            self: *const ITaskScheduler,
            pwszComputer: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetComputer: fn(
            self: *const ITaskScheduler,
            ppwszComputer: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enum: fn(
            self: *const ITaskScheduler,
            ppEnumWorkItems: ?*?*IEnumWorkItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: fn(
            self: *const ITaskScheduler,
            pwszName: ?[*:0]const u16,
            riid: ?*const Guid,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const ITaskScheduler,
            pwszName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewWorkItem: fn(
            self: *const ITaskScheduler,
            pwszTaskName: ?[*:0]const u16,
            rclsid: ?*const Guid,
            riid: ?*const Guid,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddWorkItem: fn(
            self: *const ITaskScheduler,
            pwszTaskName: ?[*:0]const u16,
            pWorkItem: ?*IScheduledWorkItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsOfType: fn(
            self: *const ITaskScheduler,
            pwszName: ?[*:0]const u16,
            riid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskScheduler_SetTargetComputer(self: *const T, pwszComputer: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskScheduler.VTable, self.vtable).SetTargetComputer(@ptrCast(*const ITaskScheduler, self), pwszComputer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskScheduler_GetTargetComputer(self: *const T, ppwszComputer: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskScheduler.VTable, self.vtable).GetTargetComputer(@ptrCast(*const ITaskScheduler, self), ppwszComputer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskScheduler_Enum(self: *const T, ppEnumWorkItems: ?*?*IEnumWorkItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskScheduler.VTable, self.vtable).Enum(@ptrCast(*const ITaskScheduler, self), ppEnumWorkItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskScheduler_Activate(self: *const T, pwszName: ?[*:0]const u16, riid: ?*const Guid, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskScheduler.VTable, self.vtable).Activate(@ptrCast(*const ITaskScheduler, self), pwszName, riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskScheduler_Delete(self: *const T, pwszName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskScheduler.VTable, self.vtable).Delete(@ptrCast(*const ITaskScheduler, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskScheduler_NewWorkItem(self: *const T, pwszTaskName: ?[*:0]const u16, rclsid: ?*const Guid, riid: ?*const Guid, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskScheduler.VTable, self.vtable).NewWorkItem(@ptrCast(*const ITaskScheduler, self), pwszTaskName, rclsid, riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskScheduler_AddWorkItem(self: *const T, pwszTaskName: ?[*:0]const u16, pWorkItem: ?*IScheduledWorkItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskScheduler.VTable, self.vtable).AddWorkItem(@ptrCast(*const ITaskScheduler, self), pwszTaskName, pWorkItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskScheduler_IsOfType(self: *const T, pwszName: ?[*:0]const u16, riid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskScheduler.VTable, self.vtable).IsOfType(@ptrCast(*const ITaskScheduler, self), pwszName, riid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TASKPAGE = enum(i32) {
    TASK = 0,
    SCHEDULE = 1,
    SETTINGS = 2,
};
pub const TASKPAGE_TASK = TASKPAGE.TASK;
pub const TASKPAGE_SCHEDULE = TASKPAGE.SCHEDULE;
pub const TASKPAGE_SETTINGS = TASKPAGE.SETTINGS;

// TODO: this type is limited to platform 'windows5.0'
const IID_IProvideTaskPage_Value = @import("../zig.zig").Guid.initString("4086658a-cbbb-11cf-b604-00c04fd8d565");
pub const IID_IProvideTaskPage = &IID_IProvideTaskPage_Value;
pub const IProvideTaskPage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPage: fn(
            self: *const IProvideTaskPage,
            tpType: TASKPAGE,
            fPersistChanges: BOOL,
            phPage: ?*?HPROPSHEETPAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProvideTaskPage_GetPage(self: *const T, tpType: TASKPAGE, fPersistChanges: BOOL, phPage: ?*?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProvideTaskPage.VTable, self.vtable).GetPage(@ptrCast(*const IProvideTaskPage, self), tpType, fPersistChanges, phPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_TaskScheduler_Value = @import("../zig.zig").Guid.initString("0f87369f-a4e5-4cfc-bd3e-73e6154572dd");
pub const CLSID_TaskScheduler = &CLSID_TaskScheduler_Value;

const CLSID_TaskHandlerPS_Value = @import("../zig.zig").Guid.initString("f2a69db7-da2c-4352-9066-86fee6dacac9");
pub const CLSID_TaskHandlerPS = &CLSID_TaskHandlerPS_Value;

const CLSID_TaskHandlerStatusPS_Value = @import("../zig.zig").Guid.initString("9f15266d-d7ba-48f0-93c1-e6895f6fe5ac");
pub const CLSID_TaskHandlerStatusPS = &CLSID_TaskHandlerStatusPS_Value;

pub const TASK_RUN_FLAGS = enum(i32) {
    NO_FLAGS = 0,
    AS_SELF = 1,
    IGNORE_CONSTRAINTS = 2,
    USE_SESSION_ID = 4,
    USER_SID = 8,
};
pub const TASK_RUN_NO_FLAGS = TASK_RUN_FLAGS.NO_FLAGS;
pub const TASK_RUN_AS_SELF = TASK_RUN_FLAGS.AS_SELF;
pub const TASK_RUN_IGNORE_CONSTRAINTS = TASK_RUN_FLAGS.IGNORE_CONSTRAINTS;
pub const TASK_RUN_USE_SESSION_ID = TASK_RUN_FLAGS.USE_SESSION_ID;
pub const TASK_RUN_USER_SID = TASK_RUN_FLAGS.USER_SID;

pub const TASK_ENUM_FLAGS = enum(i32) {
    N = 1,
};
pub const TASK_ENUM_HIDDEN = TASK_ENUM_FLAGS.N;

pub const TASK_LOGON_TYPE = enum(i32) {
    NONE = 0,
    PASSWORD = 1,
    S4U = 2,
    INTERACTIVE_TOKEN = 3,
    GROUP = 4,
    SERVICE_ACCOUNT = 5,
    INTERACTIVE_TOKEN_OR_PASSWORD = 6,
};
pub const TASK_LOGON_NONE = TASK_LOGON_TYPE.NONE;
pub const TASK_LOGON_PASSWORD = TASK_LOGON_TYPE.PASSWORD;
pub const TASK_LOGON_S4U = TASK_LOGON_TYPE.S4U;
pub const TASK_LOGON_INTERACTIVE_TOKEN = TASK_LOGON_TYPE.INTERACTIVE_TOKEN;
pub const TASK_LOGON_GROUP = TASK_LOGON_TYPE.GROUP;
pub const TASK_LOGON_SERVICE_ACCOUNT = TASK_LOGON_TYPE.SERVICE_ACCOUNT;
pub const TASK_LOGON_INTERACTIVE_TOKEN_OR_PASSWORD = TASK_LOGON_TYPE.INTERACTIVE_TOKEN_OR_PASSWORD;

pub const TASK_RUNLEVEL_TYPE = enum(i32) {
    LUA = 0,
    HIGHEST = 1,
};
pub const TASK_RUNLEVEL_LUA = TASK_RUNLEVEL_TYPE.LUA;
pub const TASK_RUNLEVEL_HIGHEST = TASK_RUNLEVEL_TYPE.HIGHEST;

pub const TASK_PROCESSTOKENSID_TYPE = enum(i32) {
    NONE = 0,
    UNRESTRICTED = 1,
    DEFAULT = 2,
};
pub const TASK_PROCESSTOKENSID_NONE = TASK_PROCESSTOKENSID_TYPE.NONE;
pub const TASK_PROCESSTOKENSID_UNRESTRICTED = TASK_PROCESSTOKENSID_TYPE.UNRESTRICTED;
pub const TASK_PROCESSTOKENSID_DEFAULT = TASK_PROCESSTOKENSID_TYPE.DEFAULT;

pub const TASK_STATE = enum(i32) {
    UNKNOWN = 0,
    DISABLED = 1,
    QUEUED = 2,
    READY = 3,
    RUNNING = 4,
};
pub const TASK_STATE_UNKNOWN = TASK_STATE.UNKNOWN;
pub const TASK_STATE_DISABLED = TASK_STATE.DISABLED;
pub const TASK_STATE_QUEUED = TASK_STATE.QUEUED;
pub const TASK_STATE_READY = TASK_STATE.READY;
pub const TASK_STATE_RUNNING = TASK_STATE.RUNNING;

pub const TASK_CREATION = enum(i32) {
    VALIDATE_ONLY = 1,
    CREATE = 2,
    UPDATE = 4,
    CREATE_OR_UPDATE = 6,
    DISABLE = 8,
    DONT_ADD_PRINCIPAL_ACE = 16,
    IGNORE_REGISTRATION_TRIGGERS = 32,
};
pub const TASK_VALIDATE_ONLY = TASK_CREATION.VALIDATE_ONLY;
pub const TASK_CREATE = TASK_CREATION.CREATE;
pub const TASK_UPDATE = TASK_CREATION.UPDATE;
pub const TASK_CREATE_OR_UPDATE = TASK_CREATION.CREATE_OR_UPDATE;
pub const TASK_DISABLE = TASK_CREATION.DISABLE;
pub const TASK_DONT_ADD_PRINCIPAL_ACE = TASK_CREATION.DONT_ADD_PRINCIPAL_ACE;
pub const TASK_IGNORE_REGISTRATION_TRIGGERS = TASK_CREATION.IGNORE_REGISTRATION_TRIGGERS;

pub const TASK_TRIGGER_TYPE2 = enum(i32) {
    EVENT = 0,
    TIME = 1,
    DAILY = 2,
    WEEKLY = 3,
    MONTHLY = 4,
    MONTHLYDOW = 5,
    IDLE = 6,
    REGISTRATION = 7,
    BOOT = 8,
    LOGON = 9,
    SESSION_STATE_CHANGE = 11,
    CUSTOM_TRIGGER_01 = 12,
};
pub const TASK_TRIGGER_EVENT = TASK_TRIGGER_TYPE2.EVENT;
pub const TASK_TRIGGER_TIME = TASK_TRIGGER_TYPE2.TIME;
pub const TASK_TRIGGER_DAILY = TASK_TRIGGER_TYPE2.DAILY;
pub const TASK_TRIGGER_WEEKLY = TASK_TRIGGER_TYPE2.WEEKLY;
pub const TASK_TRIGGER_MONTHLY = TASK_TRIGGER_TYPE2.MONTHLY;
pub const TASK_TRIGGER_MONTHLYDOW = TASK_TRIGGER_TYPE2.MONTHLYDOW;
pub const TASK_TRIGGER_IDLE = TASK_TRIGGER_TYPE2.IDLE;
pub const TASK_TRIGGER_REGISTRATION = TASK_TRIGGER_TYPE2.REGISTRATION;
pub const TASK_TRIGGER_BOOT = TASK_TRIGGER_TYPE2.BOOT;
pub const TASK_TRIGGER_LOGON = TASK_TRIGGER_TYPE2.LOGON;
pub const TASK_TRIGGER_SESSION_STATE_CHANGE = TASK_TRIGGER_TYPE2.SESSION_STATE_CHANGE;
pub const TASK_TRIGGER_CUSTOM_TRIGGER_01 = TASK_TRIGGER_TYPE2.CUSTOM_TRIGGER_01;

pub const TASK_SESSION_STATE_CHANGE_TYPE = enum(i32) {
    CONSOLE_CONNECT = 1,
    CONSOLE_DISCONNECT = 2,
    REMOTE_CONNECT = 3,
    REMOTE_DISCONNECT = 4,
    SESSION_LOCK = 7,
    SESSION_UNLOCK = 8,
};
pub const TASK_CONSOLE_CONNECT = TASK_SESSION_STATE_CHANGE_TYPE.CONSOLE_CONNECT;
pub const TASK_CONSOLE_DISCONNECT = TASK_SESSION_STATE_CHANGE_TYPE.CONSOLE_DISCONNECT;
pub const TASK_REMOTE_CONNECT = TASK_SESSION_STATE_CHANGE_TYPE.REMOTE_CONNECT;
pub const TASK_REMOTE_DISCONNECT = TASK_SESSION_STATE_CHANGE_TYPE.REMOTE_DISCONNECT;
pub const TASK_SESSION_LOCK = TASK_SESSION_STATE_CHANGE_TYPE.SESSION_LOCK;
pub const TASK_SESSION_UNLOCK = TASK_SESSION_STATE_CHANGE_TYPE.SESSION_UNLOCK;

pub const TASK_ACTION_TYPE = enum(i32) {
    EXEC = 0,
    COM_HANDLER = 5,
    SEND_EMAIL = 6,
    SHOW_MESSAGE = 7,
};
pub const TASK_ACTION_EXEC = TASK_ACTION_TYPE.EXEC;
pub const TASK_ACTION_COM_HANDLER = TASK_ACTION_TYPE.COM_HANDLER;
pub const TASK_ACTION_SEND_EMAIL = TASK_ACTION_TYPE.SEND_EMAIL;
pub const TASK_ACTION_SHOW_MESSAGE = TASK_ACTION_TYPE.SHOW_MESSAGE;

pub const TASK_INSTANCES_POLICY = enum(i32) {
    PARALLEL = 0,
    QUEUE = 1,
    IGNORE_NEW = 2,
    STOP_EXISTING = 3,
};
pub const TASK_INSTANCES_PARALLEL = TASK_INSTANCES_POLICY.PARALLEL;
pub const TASK_INSTANCES_QUEUE = TASK_INSTANCES_POLICY.QUEUE;
pub const TASK_INSTANCES_IGNORE_NEW = TASK_INSTANCES_POLICY.IGNORE_NEW;
pub const TASK_INSTANCES_STOP_EXISTING = TASK_INSTANCES_POLICY.STOP_EXISTING;

pub const TASK_COMPATIBILITY = enum(i32) {
    AT = 0,
    V1 = 1,
    V2 = 2,
    V2_1 = 3,
    V2_2 = 4,
    V2_3 = 5,
    V2_4 = 6,
};
pub const TASK_COMPATIBILITY_AT = TASK_COMPATIBILITY.AT;
pub const TASK_COMPATIBILITY_V1 = TASK_COMPATIBILITY.V1;
pub const TASK_COMPATIBILITY_V2 = TASK_COMPATIBILITY.V2;
pub const TASK_COMPATIBILITY_V2_1 = TASK_COMPATIBILITY.V2_1;
pub const TASK_COMPATIBILITY_V2_2 = TASK_COMPATIBILITY.V2_2;
pub const TASK_COMPATIBILITY_V2_3 = TASK_COMPATIBILITY.V2_3;
pub const TASK_COMPATIBILITY_V2_4 = TASK_COMPATIBILITY.V2_4;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskFolderCollection_Value = @import("../zig.zig").Guid.initString("79184a66-8664-423f-97f1-637356a5d812");
pub const IID_ITaskFolderCollection = &IID_ITaskFolderCollection_Value;
pub const ITaskFolderCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ITaskFolderCollection,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ITaskFolderCollection,
            index: VARIANT,
            ppFolder: ?*?*ITaskFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ITaskFolderCollection,
            ppEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolderCollection_get_Count(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolderCollection.VTable, self.vtable).get_Count(@ptrCast(*const ITaskFolderCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolderCollection_get_Item(self: *const T, index: VARIANT, ppFolder: ?*?*ITaskFolder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolderCollection.VTable, self.vtable).get_Item(@ptrCast(*const ITaskFolderCollection, self), index, ppFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolderCollection_get__NewEnum(self: *const T, ppEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolderCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const ITaskFolderCollection, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskService_Value = @import("../zig.zig").Guid.initString("2faba4c7-4da9-4013-9697-20cc3fd40f85");
pub const IID_ITaskService = &IID_ITaskService_Value;
pub const ITaskService = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetFolder: fn(
            self: *const ITaskService,
            path: ?BSTR,
            ppFolder: ?*?*ITaskFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningTasks: fn(
            self: *const ITaskService,
            flags: i32,
            ppRunningTasks: ?*?*IRunningTaskCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewTask: fn(
            self: *const ITaskService,
            flags: u32,
            ppDefinition: ?*?*ITaskDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Connect: fn(
            self: *const ITaskService,
            serverName: VARIANT,
            user: VARIANT,
            domain: VARIANT,
            password: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Connected: fn(
            self: *const ITaskService,
            pConnected: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TargetServer: fn(
            self: *const ITaskService,
            pServer: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectedUser: fn(
            self: *const ITaskService,
            pUser: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectedDomain: fn(
            self: *const ITaskService,
            pDomain: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HighestVersion: fn(
            self: *const ITaskService,
            pVersion: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskService_GetFolder(self: *const T, path: ?BSTR, ppFolder: ?*?*ITaskFolder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskService.VTable, self.vtable).GetFolder(@ptrCast(*const ITaskService, self), path, ppFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskService_GetRunningTasks(self: *const T, flags: i32, ppRunningTasks: ?*?*IRunningTaskCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskService.VTable, self.vtable).GetRunningTasks(@ptrCast(*const ITaskService, self), flags, ppRunningTasks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskService_NewTask(self: *const T, flags: u32, ppDefinition: ?*?*ITaskDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskService.VTable, self.vtable).NewTask(@ptrCast(*const ITaskService, self), flags, ppDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskService_Connect(self: *const T, serverName: VARIANT, user: VARIANT, domain: VARIANT, password: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskService.VTable, self.vtable).Connect(@ptrCast(*const ITaskService, self), serverName, user, domain, password);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskService_get_Connected(self: *const T, pConnected: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskService.VTable, self.vtable).get_Connected(@ptrCast(*const ITaskService, self), pConnected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskService_get_TargetServer(self: *const T, pServer: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskService.VTable, self.vtable).get_TargetServer(@ptrCast(*const ITaskService, self), pServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskService_get_ConnectedUser(self: *const T, pUser: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskService.VTable, self.vtable).get_ConnectedUser(@ptrCast(*const ITaskService, self), pUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskService_get_ConnectedDomain(self: *const T, pDomain: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskService.VTable, self.vtable).get_ConnectedDomain(@ptrCast(*const ITaskService, self), pDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskService_get_HighestVersion(self: *const T, pVersion: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskService.VTable, self.vtable).get_HighestVersion(@ptrCast(*const ITaskService, self), pVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskHandler_Value = @import("../zig.zig").Guid.initString("839d7762-5121-4009-9234-4f0d19394f04");
pub const IID_ITaskHandler = &IID_ITaskHandler_Value;
pub const ITaskHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const ITaskHandler,
            pHandlerServices: ?*IUnknown,
            data: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const ITaskHandler,
            pRetCode: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const ITaskHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const ITaskHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskHandler_Start(self: *const T, pHandlerServices: ?*IUnknown, data: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskHandler.VTable, self.vtable).Start(@ptrCast(*const ITaskHandler, self), pHandlerServices, data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskHandler_Stop(self: *const T, pRetCode: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskHandler.VTable, self.vtable).Stop(@ptrCast(*const ITaskHandler, self), pRetCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskHandler_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskHandler.VTable, self.vtable).Pause(@ptrCast(*const ITaskHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskHandler_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskHandler.VTable, self.vtable).Resume(@ptrCast(*const ITaskHandler, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskHandlerStatus_Value = @import("../zig.zig").Guid.initString("eaec7a8f-27a0-4ddc-8675-14726a01a38a");
pub const IID_ITaskHandlerStatus = &IID_ITaskHandlerStatus_Value;
pub const ITaskHandlerStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateStatus: fn(
            self: *const ITaskHandlerStatus,
            percentComplete: i16,
            statusMessage: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TaskCompleted: fn(
            self: *const ITaskHandlerStatus,
            taskErrCode: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskHandlerStatus_UpdateStatus(self: *const T, percentComplete: i16, statusMessage: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskHandlerStatus.VTable, self.vtable).UpdateStatus(@ptrCast(*const ITaskHandlerStatus, self), percentComplete, statusMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskHandlerStatus_TaskCompleted(self: *const T, taskErrCode: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskHandlerStatus.VTable, self.vtable).TaskCompleted(@ptrCast(*const ITaskHandlerStatus, self), taskErrCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskVariables_Value = @import("../zig.zig").Guid.initString("3e4c9351-d966-4b8b-bb87-ceba68bb0107");
pub const IID_ITaskVariables = &IID_ITaskVariables_Value;
pub const ITaskVariables = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInput: fn(
            self: *const ITaskVariables,
            pInput: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutput: fn(
            self: *const ITaskVariables,
            input: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const ITaskVariables,
            pContext: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskVariables_GetInput(self: *const T, pInput: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskVariables.VTable, self.vtable).GetInput(@ptrCast(*const ITaskVariables, self), pInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskVariables_SetOutput(self: *const T, input: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskVariables.VTable, self.vtable).SetOutput(@ptrCast(*const ITaskVariables, self), input);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskVariables_GetContext(self: *const T, pContext: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskVariables.VTable, self.vtable).GetContext(@ptrCast(*const ITaskVariables, self), pContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskNamedValuePair_Value = @import("../zig.zig").Guid.initString("39038068-2b46-4afd-8662-7bb6f868d221");
pub const IID_ITaskNamedValuePair = &IID_ITaskNamedValuePair_Value;
pub const ITaskNamedValuePair = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const ITaskNamedValuePair,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const ITaskNamedValuePair,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const ITaskNamedValuePair,
            pValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: fn(
            self: *const ITaskNamedValuePair,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValuePair_get_Name(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValuePair.VTable, self.vtable).get_Name(@ptrCast(*const ITaskNamedValuePair, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValuePair_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValuePair.VTable, self.vtable).put_Name(@ptrCast(*const ITaskNamedValuePair, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValuePair_get_Value(self: *const T, pValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValuePair.VTable, self.vtable).get_Value(@ptrCast(*const ITaskNamedValuePair, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValuePair_put_Value(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValuePair.VTable, self.vtable).put_Value(@ptrCast(*const ITaskNamedValuePair, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskNamedValueCollection_Value = @import("../zig.zig").Guid.initString("b4ef826b-63c3-46e4-a504-ef69e4f7ea4d");
pub const IID_ITaskNamedValueCollection = &IID_ITaskNamedValueCollection_Value;
pub const ITaskNamedValueCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ITaskNamedValueCollection,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ITaskNamedValueCollection,
            index: i32,
            ppPair: ?*?*ITaskNamedValuePair,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ITaskNamedValueCollection,
            ppEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: fn(
            self: *const ITaskNamedValueCollection,
            name: ?BSTR,
            value: ?BSTR,
            ppPair: ?*?*ITaskNamedValuePair,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ITaskNamedValueCollection,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ITaskNamedValueCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValueCollection_get_Count(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValueCollection.VTable, self.vtable).get_Count(@ptrCast(*const ITaskNamedValueCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValueCollection_get_Item(self: *const T, index: i32, ppPair: ?*?*ITaskNamedValuePair) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValueCollection.VTable, self.vtable).get_Item(@ptrCast(*const ITaskNamedValueCollection, self), index, ppPair);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValueCollection_get__NewEnum(self: *const T, ppEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValueCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const ITaskNamedValueCollection, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValueCollection_Create(self: *const T, name: ?BSTR, value: ?BSTR, ppPair: ?*?*ITaskNamedValuePair) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValueCollection.VTable, self.vtable).Create(@ptrCast(*const ITaskNamedValueCollection, self), name, value, ppPair);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValueCollection_Remove(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValueCollection.VTable, self.vtable).Remove(@ptrCast(*const ITaskNamedValueCollection, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskNamedValueCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskNamedValueCollection.VTable, self.vtable).Clear(@ptrCast(*const ITaskNamedValueCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRunningTask_Value = @import("../zig.zig").Guid.initString("653758fb-7b9a-4f1e-a471-beeb8e9b834e");
pub const IID_IRunningTask = &IID_IRunningTask_Value;
pub const IRunningTask = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IRunningTask,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstanceGuid: fn(
            self: *const IRunningTask,
            pGuid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IRunningTask,
            pPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: fn(
            self: *const IRunningTask,
            pState: ?*TASK_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: fn(
            self: *const IRunningTask,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IRunningTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IRunningTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnginePID: fn(
            self: *const IRunningTask,
            pPID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTask_get_Name(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTask.VTable, self.vtable).get_Name(@ptrCast(*const IRunningTask, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTask_get_InstanceGuid(self: *const T, pGuid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTask.VTable, self.vtable).get_InstanceGuid(@ptrCast(*const IRunningTask, self), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTask_get_Path(self: *const T, pPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTask.VTable, self.vtable).get_Path(@ptrCast(*const IRunningTask, self), pPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTask_get_State(self: *const T, pState: ?*TASK_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTask.VTable, self.vtable).get_State(@ptrCast(*const IRunningTask, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTask_get_CurrentAction(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTask.VTable, self.vtable).get_CurrentAction(@ptrCast(*const IRunningTask, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTask_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTask.VTable, self.vtable).Stop(@ptrCast(*const IRunningTask, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTask_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTask.VTable, self.vtable).Refresh(@ptrCast(*const IRunningTask, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTask_get_EnginePID(self: *const T, pPID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTask.VTable, self.vtable).get_EnginePID(@ptrCast(*const IRunningTask, self), pPID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRunningTaskCollection_Value = @import("../zig.zig").Guid.initString("6a67614b-6828-4fec-aa54-6d52e8f1f2db");
pub const IID_IRunningTaskCollection = &IID_IRunningTaskCollection_Value;
pub const IRunningTaskCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IRunningTaskCollection,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IRunningTaskCollection,
            index: VARIANT,
            ppRunningTask: ?*?*IRunningTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IRunningTaskCollection,
            ppEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTaskCollection_get_Count(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTaskCollection.VTable, self.vtable).get_Count(@ptrCast(*const IRunningTaskCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTaskCollection_get_Item(self: *const T, index: VARIANT, ppRunningTask: ?*?*IRunningTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTaskCollection.VTable, self.vtable).get_Item(@ptrCast(*const IRunningTaskCollection, self), index, ppRunningTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunningTaskCollection_get__NewEnum(self: *const T, ppEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunningTaskCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IRunningTaskCollection, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRegisteredTask_Value = @import("../zig.zig").Guid.initString("9c86f320-dee3-4dd1-b972-a303f26b061e");
pub const IID_IRegisteredTask = &IID_IRegisteredTask_Value;
pub const IRegisteredTask = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IRegisteredTask,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IRegisteredTask,
            pPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: fn(
            self: *const IRegisteredTask,
            pState: ?*TASK_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const IRegisteredTask,
            pEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const IRegisteredTask,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Run: fn(
            self: *const IRegisteredTask,
            params: VARIANT,
            ppRunningTask: ?*?*IRunningTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunEx: fn(
            self: *const IRegisteredTask,
            params: VARIANT,
            flags: i32,
            sessionID: i32,
            user: ?BSTR,
            ppRunningTask: ?*?*IRunningTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInstances: fn(
            self: *const IRegisteredTask,
            flags: i32,
            ppRunningTasks: ?*?*IRunningTaskCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastRunTime: fn(
            self: *const IRegisteredTask,
            pLastRunTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastTaskResult: fn(
            self: *const IRegisteredTask,
            pLastTaskResult: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfMissedRuns: fn(
            self: *const IRegisteredTask,
            pNumberOfMissedRuns: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextRunTime: fn(
            self: *const IRegisteredTask,
            pNextRunTime: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Definition: fn(
            self: *const IRegisteredTask,
            ppDefinition: ?*?*ITaskDefinition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Xml: fn(
            self: *const IRegisteredTask,
            pXml: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityDescriptor: fn(
            self: *const IRegisteredTask,
            securityInformation: i32,
            pSddl: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSecurityDescriptor: fn(
            self: *const IRegisteredTask,
            sddl: ?BSTR,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IRegisteredTask,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunTimes: fn(
            self: *const IRegisteredTask,
            pstStart: ?*const SYSTEMTIME,
            pstEnd: ?*const SYSTEMTIME,
            pCount: ?*u32,
            pRunTimes: ?*?*SYSTEMTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_Name(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_Name(@ptrCast(*const IRegisteredTask, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_Path(self: *const T, pPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_Path(@ptrCast(*const IRegisteredTask, self), pPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_State(self: *const T, pState: ?*TASK_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_State(@ptrCast(*const IRegisteredTask, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_Enabled(self: *const T, pEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_Enabled(@ptrCast(*const IRegisteredTask, self), pEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).put_Enabled(@ptrCast(*const IRegisteredTask, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_Run(self: *const T, params: VARIANT, ppRunningTask: ?*?*IRunningTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).Run(@ptrCast(*const IRegisteredTask, self), params, ppRunningTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_RunEx(self: *const T, params: VARIANT, flags: i32, sessionID: i32, user: ?BSTR, ppRunningTask: ?*?*IRunningTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).RunEx(@ptrCast(*const IRegisteredTask, self), params, flags, sessionID, user, ppRunningTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_GetInstances(self: *const T, flags: i32, ppRunningTasks: ?*?*IRunningTaskCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).GetInstances(@ptrCast(*const IRegisteredTask, self), flags, ppRunningTasks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_LastRunTime(self: *const T, pLastRunTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_LastRunTime(@ptrCast(*const IRegisteredTask, self), pLastRunTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_LastTaskResult(self: *const T, pLastTaskResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_LastTaskResult(@ptrCast(*const IRegisteredTask, self), pLastTaskResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_NumberOfMissedRuns(self: *const T, pNumberOfMissedRuns: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_NumberOfMissedRuns(@ptrCast(*const IRegisteredTask, self), pNumberOfMissedRuns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_NextRunTime(self: *const T, pNextRunTime: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_NextRunTime(@ptrCast(*const IRegisteredTask, self), pNextRunTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_Definition(self: *const T, ppDefinition: ?*?*ITaskDefinition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_Definition(@ptrCast(*const IRegisteredTask, self), ppDefinition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_get_Xml(self: *const T, pXml: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).get_Xml(@ptrCast(*const IRegisteredTask, self), pXml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_GetSecurityDescriptor(self: *const T, securityInformation: i32, pSddl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).GetSecurityDescriptor(@ptrCast(*const IRegisteredTask, self), securityInformation, pSddl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_SetSecurityDescriptor(self: *const T, sddl: ?BSTR, flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).SetSecurityDescriptor(@ptrCast(*const IRegisteredTask, self), sddl, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_Stop(self: *const T, flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).Stop(@ptrCast(*const IRegisteredTask, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTask_GetRunTimes(self: *const T, pstStart: ?*const SYSTEMTIME, pstEnd: ?*const SYSTEMTIME, pCount: ?*u32, pRunTimes: ?*?*SYSTEMTIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTask.VTable, self.vtable).GetRunTimes(@ptrCast(*const IRegisteredTask, self), pstStart, pstEnd, pCount, pRunTimes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITrigger_Value = @import("../zig.zig").Guid.initString("09941815-ea89-4b5b-89e0-2a773801fac3");
pub const IID_ITrigger = &IID_ITrigger_Value;
pub const ITrigger = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const ITrigger,
            pType: ?*TASK_TRIGGER_TYPE2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: fn(
            self: *const ITrigger,
            pId: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Id: fn(
            self: *const ITrigger,
            id: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Repetition: fn(
            self: *const ITrigger,
            ppRepeat: ?*?*IRepetitionPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Repetition: fn(
            self: *const ITrigger,
            pRepeat: ?*IRepetitionPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExecutionTimeLimit: fn(
            self: *const ITrigger,
            pTimeLimit: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExecutionTimeLimit: fn(
            self: *const ITrigger,
            timelimit: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartBoundary: fn(
            self: *const ITrigger,
            pStart: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartBoundary: fn(
            self: *const ITrigger,
            start: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EndBoundary: fn(
            self: *const ITrigger,
            pEnd: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EndBoundary: fn(
            self: *const ITrigger,
            end: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const ITrigger,
            pEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const ITrigger,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_get_Type(self: *const T, pType: ?*TASK_TRIGGER_TYPE2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).get_Type(@ptrCast(*const ITrigger, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_get_Id(self: *const T, pId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).get_Id(@ptrCast(*const ITrigger, self), pId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_put_Id(self: *const T, id: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).put_Id(@ptrCast(*const ITrigger, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_get_Repetition(self: *const T, ppRepeat: ?*?*IRepetitionPattern) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).get_Repetition(@ptrCast(*const ITrigger, self), ppRepeat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_put_Repetition(self: *const T, pRepeat: ?*IRepetitionPattern) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).put_Repetition(@ptrCast(*const ITrigger, self), pRepeat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_get_ExecutionTimeLimit(self: *const T, pTimeLimit: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).get_ExecutionTimeLimit(@ptrCast(*const ITrigger, self), pTimeLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_put_ExecutionTimeLimit(self: *const T, timelimit: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).put_ExecutionTimeLimit(@ptrCast(*const ITrigger, self), timelimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_get_StartBoundary(self: *const T, pStart: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).get_StartBoundary(@ptrCast(*const ITrigger, self), pStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_put_StartBoundary(self: *const T, start: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).put_StartBoundary(@ptrCast(*const ITrigger, self), start);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_get_EndBoundary(self: *const T, pEnd: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).get_EndBoundary(@ptrCast(*const ITrigger, self), pEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_put_EndBoundary(self: *const T, end: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).put_EndBoundary(@ptrCast(*const ITrigger, self), end);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_get_Enabled(self: *const T, pEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).get_Enabled(@ptrCast(*const ITrigger, self), pEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrigger_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrigger.VTable, self.vtable).put_Enabled(@ptrCast(*const ITrigger, self), enabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IIdleTrigger_Value = @import("../zig.zig").Guid.initString("d537d2b0-9fb3-4d34-9739-1ff5ce7b1ef3");
pub const IID_IIdleTrigger = &IID_IIdleTrigger_Value;
pub const IIdleTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ILogonTrigger_Value = @import("../zig.zig").Guid.initString("72dade38-fae4-4b3e-baf4-5d009af02b1c");
pub const IID_ILogonTrigger = &IID_ILogonTrigger_Value;
pub const ILogonTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Delay: fn(
            self: *const ILogonTrigger,
            pDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Delay: fn(
            self: *const ILogonTrigger,
            delay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserId: fn(
            self: *const ILogonTrigger,
            pUser: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserId: fn(
            self: *const ILogonTrigger,
            user: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILogonTrigger_get_Delay(self: *const T, pDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILogonTrigger.VTable, self.vtable).get_Delay(@ptrCast(*const ILogonTrigger, self), pDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILogonTrigger_put_Delay(self: *const T, delay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILogonTrigger.VTable, self.vtable).put_Delay(@ptrCast(*const ILogonTrigger, self), delay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILogonTrigger_get_UserId(self: *const T, pUser: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILogonTrigger.VTable, self.vtable).get_UserId(@ptrCast(*const ILogonTrigger, self), pUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILogonTrigger_put_UserId(self: *const T, user: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILogonTrigger.VTable, self.vtable).put_UserId(@ptrCast(*const ILogonTrigger, self), user);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISessionStateChangeTrigger_Value = @import("../zig.zig").Guid.initString("754da71b-4385-4475-9dd9-598294fa3641");
pub const IID_ISessionStateChangeTrigger = &IID_ISessionStateChangeTrigger_Value;
pub const ISessionStateChangeTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Delay: fn(
            self: *const ISessionStateChangeTrigger,
            pDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Delay: fn(
            self: *const ISessionStateChangeTrigger,
            delay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserId: fn(
            self: *const ISessionStateChangeTrigger,
            pUser: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserId: fn(
            self: *const ISessionStateChangeTrigger,
            user: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StateChange: fn(
            self: *const ISessionStateChangeTrigger,
            pType: ?*TASK_SESSION_STATE_CHANGE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StateChange: fn(
            self: *const ISessionStateChangeTrigger,
            type: TASK_SESSION_STATE_CHANGE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISessionStateChangeTrigger_get_Delay(self: *const T, pDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISessionStateChangeTrigger.VTable, self.vtable).get_Delay(@ptrCast(*const ISessionStateChangeTrigger, self), pDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISessionStateChangeTrigger_put_Delay(self: *const T, delay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISessionStateChangeTrigger.VTable, self.vtable).put_Delay(@ptrCast(*const ISessionStateChangeTrigger, self), delay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISessionStateChangeTrigger_get_UserId(self: *const T, pUser: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISessionStateChangeTrigger.VTable, self.vtable).get_UserId(@ptrCast(*const ISessionStateChangeTrigger, self), pUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISessionStateChangeTrigger_put_UserId(self: *const T, user: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISessionStateChangeTrigger.VTable, self.vtable).put_UserId(@ptrCast(*const ISessionStateChangeTrigger, self), user);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISessionStateChangeTrigger_get_StateChange(self: *const T, pType: ?*TASK_SESSION_STATE_CHANGE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISessionStateChangeTrigger.VTable, self.vtable).get_StateChange(@ptrCast(*const ISessionStateChangeTrigger, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISessionStateChangeTrigger_put_StateChange(self: *const T, type_: TASK_SESSION_STATE_CHANGE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISessionStateChangeTrigger.VTable, self.vtable).put_StateChange(@ptrCast(*const ISessionStateChangeTrigger, self), type_);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEventTrigger_Value = @import("../zig.zig").Guid.initString("d45b0167-9653-4eef-b94f-0732ca7af251");
pub const IID_IEventTrigger = &IID_IEventTrigger_Value;
pub const IEventTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Subscription: fn(
            self: *const IEventTrigger,
            pQuery: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Subscription: fn(
            self: *const IEventTrigger,
            query: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Delay: fn(
            self: *const IEventTrigger,
            pDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Delay: fn(
            self: *const IEventTrigger,
            delay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ValueQueries: fn(
            self: *const IEventTrigger,
            ppNamedXPaths: ?*?*ITaskNamedValueCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ValueQueries: fn(
            self: *const IEventTrigger,
            pNamedXPaths: ?*ITaskNamedValueCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTrigger_get_Subscription(self: *const T, pQuery: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTrigger.VTable, self.vtable).get_Subscription(@ptrCast(*const IEventTrigger, self), pQuery);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTrigger_put_Subscription(self: *const T, query: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTrigger.VTable, self.vtable).put_Subscription(@ptrCast(*const IEventTrigger, self), query);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTrigger_get_Delay(self: *const T, pDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTrigger.VTable, self.vtable).get_Delay(@ptrCast(*const IEventTrigger, self), pDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTrigger_put_Delay(self: *const T, delay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTrigger.VTable, self.vtable).put_Delay(@ptrCast(*const IEventTrigger, self), delay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTrigger_get_ValueQueries(self: *const T, ppNamedXPaths: ?*?*ITaskNamedValueCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTrigger.VTable, self.vtable).get_ValueQueries(@ptrCast(*const IEventTrigger, self), ppNamedXPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTrigger_put_ValueQueries(self: *const T, pNamedXPaths: ?*ITaskNamedValueCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTrigger.VTable, self.vtable).put_ValueQueries(@ptrCast(*const IEventTrigger, self), pNamedXPaths);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITimeTrigger_Value = @import("../zig.zig").Guid.initString("b45747e0-eba7-4276-9f29-85c5bb300006");
pub const IID_ITimeTrigger = &IID_ITimeTrigger_Value;
pub const ITimeTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RandomDelay: fn(
            self: *const ITimeTrigger,
            pRandomDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RandomDelay: fn(
            self: *const ITimeTrigger,
            randomDelay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimeTrigger_get_RandomDelay(self: *const T, pRandomDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITimeTrigger.VTable, self.vtable).get_RandomDelay(@ptrCast(*const ITimeTrigger, self), pRandomDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimeTrigger_put_RandomDelay(self: *const T, randomDelay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITimeTrigger.VTable, self.vtable).put_RandomDelay(@ptrCast(*const ITimeTrigger, self), randomDelay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDailyTrigger_Value = @import("../zig.zig").Guid.initString("126c5cd8-b288-41d5-8dbf-e491446adc5c");
pub const IID_IDailyTrigger = &IID_IDailyTrigger_Value;
pub const IDailyTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DaysInterval: fn(
            self: *const IDailyTrigger,
            pDays: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DaysInterval: fn(
            self: *const IDailyTrigger,
            days: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RandomDelay: fn(
            self: *const IDailyTrigger,
            pRandomDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RandomDelay: fn(
            self: *const IDailyTrigger,
            randomDelay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDailyTrigger_get_DaysInterval(self: *const T, pDays: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDailyTrigger.VTable, self.vtable).get_DaysInterval(@ptrCast(*const IDailyTrigger, self), pDays);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDailyTrigger_put_DaysInterval(self: *const T, days: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDailyTrigger.VTable, self.vtable).put_DaysInterval(@ptrCast(*const IDailyTrigger, self), days);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDailyTrigger_get_RandomDelay(self: *const T, pRandomDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDailyTrigger.VTable, self.vtable).get_RandomDelay(@ptrCast(*const IDailyTrigger, self), pRandomDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDailyTrigger_put_RandomDelay(self: *const T, randomDelay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDailyTrigger.VTable, self.vtable).put_RandomDelay(@ptrCast(*const IDailyTrigger, self), randomDelay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWeeklyTrigger_Value = @import("../zig.zig").Guid.initString("5038fc98-82ff-436d-8728-a512a57c9dc1");
pub const IID_IWeeklyTrigger = &IID_IWeeklyTrigger_Value;
pub const IWeeklyTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DaysOfWeek: fn(
            self: *const IWeeklyTrigger,
            pDays: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DaysOfWeek: fn(
            self: *const IWeeklyTrigger,
            days: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WeeksInterval: fn(
            self: *const IWeeklyTrigger,
            pWeeks: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WeeksInterval: fn(
            self: *const IWeeklyTrigger,
            weeks: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RandomDelay: fn(
            self: *const IWeeklyTrigger,
            pRandomDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RandomDelay: fn(
            self: *const IWeeklyTrigger,
            randomDelay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeeklyTrigger_get_DaysOfWeek(self: *const T, pDays: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeeklyTrigger.VTable, self.vtable).get_DaysOfWeek(@ptrCast(*const IWeeklyTrigger, self), pDays);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeeklyTrigger_put_DaysOfWeek(self: *const T, days: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeeklyTrigger.VTable, self.vtable).put_DaysOfWeek(@ptrCast(*const IWeeklyTrigger, self), days);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeeklyTrigger_get_WeeksInterval(self: *const T, pWeeks: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeeklyTrigger.VTable, self.vtable).get_WeeksInterval(@ptrCast(*const IWeeklyTrigger, self), pWeeks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeeklyTrigger_put_WeeksInterval(self: *const T, weeks: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeeklyTrigger.VTable, self.vtable).put_WeeksInterval(@ptrCast(*const IWeeklyTrigger, self), weeks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeeklyTrigger_get_RandomDelay(self: *const T, pRandomDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeeklyTrigger.VTable, self.vtable).get_RandomDelay(@ptrCast(*const IWeeklyTrigger, self), pRandomDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWeeklyTrigger_put_RandomDelay(self: *const T, randomDelay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWeeklyTrigger.VTable, self.vtable).put_RandomDelay(@ptrCast(*const IWeeklyTrigger, self), randomDelay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMonthlyTrigger_Value = @import("../zig.zig").Guid.initString("97c45ef1-6b02-4a1a-9c0e-1ebfba1500ac");
pub const IID_IMonthlyTrigger = &IID_IMonthlyTrigger_Value;
pub const IMonthlyTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DaysOfMonth: fn(
            self: *const IMonthlyTrigger,
            pDays: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DaysOfMonth: fn(
            self: *const IMonthlyTrigger,
            days: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MonthsOfYear: fn(
            self: *const IMonthlyTrigger,
            pMonths: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MonthsOfYear: fn(
            self: *const IMonthlyTrigger,
            months: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunOnLastDayOfMonth: fn(
            self: *const IMonthlyTrigger,
            pLastDay: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RunOnLastDayOfMonth: fn(
            self: *const IMonthlyTrigger,
            lastDay: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RandomDelay: fn(
            self: *const IMonthlyTrigger,
            pRandomDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RandomDelay: fn(
            self: *const IMonthlyTrigger,
            randomDelay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyTrigger_get_DaysOfMonth(self: *const T, pDays: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyTrigger.VTable, self.vtable).get_DaysOfMonth(@ptrCast(*const IMonthlyTrigger, self), pDays);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyTrigger_put_DaysOfMonth(self: *const T, days: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyTrigger.VTable, self.vtable).put_DaysOfMonth(@ptrCast(*const IMonthlyTrigger, self), days);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyTrigger_get_MonthsOfYear(self: *const T, pMonths: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyTrigger.VTable, self.vtable).get_MonthsOfYear(@ptrCast(*const IMonthlyTrigger, self), pMonths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyTrigger_put_MonthsOfYear(self: *const T, months: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyTrigger.VTable, self.vtable).put_MonthsOfYear(@ptrCast(*const IMonthlyTrigger, self), months);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyTrigger_get_RunOnLastDayOfMonth(self: *const T, pLastDay: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyTrigger.VTable, self.vtable).get_RunOnLastDayOfMonth(@ptrCast(*const IMonthlyTrigger, self), pLastDay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyTrigger_put_RunOnLastDayOfMonth(self: *const T, lastDay: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyTrigger.VTable, self.vtable).put_RunOnLastDayOfMonth(@ptrCast(*const IMonthlyTrigger, self), lastDay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyTrigger_get_RandomDelay(self: *const T, pRandomDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyTrigger.VTable, self.vtable).get_RandomDelay(@ptrCast(*const IMonthlyTrigger, self), pRandomDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyTrigger_put_RandomDelay(self: *const T, randomDelay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyTrigger.VTable, self.vtable).put_RandomDelay(@ptrCast(*const IMonthlyTrigger, self), randomDelay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMonthlyDOWTrigger_Value = @import("../zig.zig").Guid.initString("77d025a3-90fa-43aa-b52e-cda5499b946a");
pub const IID_IMonthlyDOWTrigger = &IID_IMonthlyDOWTrigger_Value;
pub const IMonthlyDOWTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DaysOfWeek: fn(
            self: *const IMonthlyDOWTrigger,
            pDays: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DaysOfWeek: fn(
            self: *const IMonthlyDOWTrigger,
            days: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WeeksOfMonth: fn(
            self: *const IMonthlyDOWTrigger,
            pWeeks: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WeeksOfMonth: fn(
            self: *const IMonthlyDOWTrigger,
            weeks: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MonthsOfYear: fn(
            self: *const IMonthlyDOWTrigger,
            pMonths: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MonthsOfYear: fn(
            self: *const IMonthlyDOWTrigger,
            months: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunOnLastWeekOfMonth: fn(
            self: *const IMonthlyDOWTrigger,
            pLastWeek: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RunOnLastWeekOfMonth: fn(
            self: *const IMonthlyDOWTrigger,
            lastWeek: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RandomDelay: fn(
            self: *const IMonthlyDOWTrigger,
            pRandomDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RandomDelay: fn(
            self: *const IMonthlyDOWTrigger,
            randomDelay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_get_DaysOfWeek(self: *const T, pDays: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).get_DaysOfWeek(@ptrCast(*const IMonthlyDOWTrigger, self), pDays);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_put_DaysOfWeek(self: *const T, days: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).put_DaysOfWeek(@ptrCast(*const IMonthlyDOWTrigger, self), days);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_get_WeeksOfMonth(self: *const T, pWeeks: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).get_WeeksOfMonth(@ptrCast(*const IMonthlyDOWTrigger, self), pWeeks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_put_WeeksOfMonth(self: *const T, weeks: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).put_WeeksOfMonth(@ptrCast(*const IMonthlyDOWTrigger, self), weeks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_get_MonthsOfYear(self: *const T, pMonths: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).get_MonthsOfYear(@ptrCast(*const IMonthlyDOWTrigger, self), pMonths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_put_MonthsOfYear(self: *const T, months: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).put_MonthsOfYear(@ptrCast(*const IMonthlyDOWTrigger, self), months);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_get_RunOnLastWeekOfMonth(self: *const T, pLastWeek: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).get_RunOnLastWeekOfMonth(@ptrCast(*const IMonthlyDOWTrigger, self), pLastWeek);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_put_RunOnLastWeekOfMonth(self: *const T, lastWeek: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).put_RunOnLastWeekOfMonth(@ptrCast(*const IMonthlyDOWTrigger, self), lastWeek);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_get_RandomDelay(self: *const T, pRandomDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).get_RandomDelay(@ptrCast(*const IMonthlyDOWTrigger, self), pRandomDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonthlyDOWTrigger_put_RandomDelay(self: *const T, randomDelay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonthlyDOWTrigger.VTable, self.vtable).put_RandomDelay(@ptrCast(*const IMonthlyDOWTrigger, self), randomDelay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBootTrigger_Value = @import("../zig.zig").Guid.initString("2a9c35da-d357-41f4-bbc1-207ac1b1f3cb");
pub const IID_IBootTrigger = &IID_IBootTrigger_Value;
pub const IBootTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Delay: fn(
            self: *const IBootTrigger,
            pDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Delay: fn(
            self: *const IBootTrigger,
            delay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootTrigger_get_Delay(self: *const T, pDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootTrigger.VTable, self.vtable).get_Delay(@ptrCast(*const IBootTrigger, self), pDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootTrigger_put_Delay(self: *const T, delay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBootTrigger.VTable, self.vtable).put_Delay(@ptrCast(*const IBootTrigger, self), delay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRegistrationTrigger_Value = @import("../zig.zig").Guid.initString("4c8fec3a-c218-4e0c-b23d-629024db91a2");
pub const IID_IRegistrationTrigger = &IID_IRegistrationTrigger_Value;
pub const IRegistrationTrigger = extern struct {
    pub const VTable = extern struct {
        base: ITrigger.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Delay: fn(
            self: *const IRegistrationTrigger,
            pDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Delay: fn(
            self: *const IRegistrationTrigger,
            delay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITrigger.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationTrigger_get_Delay(self: *const T, pDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationTrigger.VTable, self.vtable).get_Delay(@ptrCast(*const IRegistrationTrigger, self), pDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationTrigger_put_Delay(self: *const T, delay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationTrigger.VTable, self.vtable).put_Delay(@ptrCast(*const IRegistrationTrigger, self), delay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAction_Value = @import("../zig.zig").Guid.initString("bae54997-48b1-4cbe-9965-d6be263ebea4");
pub const IID_IAction = &IID_IAction_Value;
pub const IAction = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: fn(
            self: *const IAction,
            pId: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Id: fn(
            self: *const IAction,
            Id: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IAction,
            pType: ?*TASK_ACTION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAction_get_Id(self: *const T, pId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAction.VTable, self.vtable).get_Id(@ptrCast(*const IAction, self), pId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAction_put_Id(self: *const T, Id: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAction.VTable, self.vtable).put_Id(@ptrCast(*const IAction, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAction_get_Type(self: *const T, pType: ?*TASK_ACTION_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAction.VTable, self.vtable).get_Type(@ptrCast(*const IAction, self), pType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExecAction_Value = @import("../zig.zig").Guid.initString("4c3d624d-fd6b-49a3-b9b7-09cb3cd3f047");
pub const IID_IExecAction = &IID_IExecAction_Value;
pub const IExecAction = extern struct {
    pub const VTable = extern struct {
        base: IAction.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IExecAction,
            pPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Path: fn(
            self: *const IExecAction,
            path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Arguments: fn(
            self: *const IExecAction,
            pArgument: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Arguments: fn(
            self: *const IExecAction,
            argument: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WorkingDirectory: fn(
            self: *const IExecAction,
            pWorkingDirectory: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WorkingDirectory: fn(
            self: *const IExecAction,
            workingDirectory: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecAction_get_Path(self: *const T, pPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecAction.VTable, self.vtable).get_Path(@ptrCast(*const IExecAction, self), pPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecAction_put_Path(self: *const T, path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecAction.VTable, self.vtable).put_Path(@ptrCast(*const IExecAction, self), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecAction_get_Arguments(self: *const T, pArgument: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecAction.VTable, self.vtable).get_Arguments(@ptrCast(*const IExecAction, self), pArgument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecAction_put_Arguments(self: *const T, argument: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecAction.VTable, self.vtable).put_Arguments(@ptrCast(*const IExecAction, self), argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecAction_get_WorkingDirectory(self: *const T, pWorkingDirectory: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecAction.VTable, self.vtable).get_WorkingDirectory(@ptrCast(*const IExecAction, self), pWorkingDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecAction_put_WorkingDirectory(self: *const T, workingDirectory: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecAction.VTable, self.vtable).put_WorkingDirectory(@ptrCast(*const IExecAction, self), workingDirectory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IExecAction2_Value = @import("../zig.zig").Guid.initString("f2a82542-bda5-4e6b-9143-e2bf4f8987b6");
pub const IID_IExecAction2 = &IID_IExecAction2_Value;
pub const IExecAction2 = extern struct {
    pub const VTable = extern struct {
        base: IExecAction.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HideAppWindow: fn(
            self: *const IExecAction2,
            pHideAppWindow: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HideAppWindow: fn(
            self: *const IExecAction2,
            hideAppWindow: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IExecAction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecAction2_get_HideAppWindow(self: *const T, pHideAppWindow: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecAction2.VTable, self.vtable).get_HideAppWindow(@ptrCast(*const IExecAction2, self), pHideAppWindow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecAction2_put_HideAppWindow(self: *const T, hideAppWindow: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecAction2.VTable, self.vtable).put_HideAppWindow(@ptrCast(*const IExecAction2, self), hideAppWindow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShowMessageAction_Value = @import("../zig.zig").Guid.initString("505e9e68-af89-46b8-a30f-56162a83d537");
pub const IID_IShowMessageAction = &IID_IShowMessageAction_Value;
pub const IShowMessageAction = extern struct {
    pub const VTable = extern struct {
        base: IAction.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: fn(
            self: *const IShowMessageAction,
            pTitle: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Title: fn(
            self: *const IShowMessageAction,
            title: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MessageBody: fn(
            self: *const IShowMessageAction,
            pMessageBody: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MessageBody: fn(
            self: *const IShowMessageAction,
            messageBody: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShowMessageAction_get_Title(self: *const T, pTitle: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShowMessageAction.VTable, self.vtable).get_Title(@ptrCast(*const IShowMessageAction, self), pTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShowMessageAction_put_Title(self: *const T, title: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShowMessageAction.VTable, self.vtable).put_Title(@ptrCast(*const IShowMessageAction, self), title);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShowMessageAction_get_MessageBody(self: *const T, pMessageBody: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShowMessageAction.VTable, self.vtable).get_MessageBody(@ptrCast(*const IShowMessageAction, self), pMessageBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShowMessageAction_put_MessageBody(self: *const T, messageBody: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShowMessageAction.VTable, self.vtable).put_MessageBody(@ptrCast(*const IShowMessageAction, self), messageBody);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComHandlerAction_Value = @import("../zig.zig").Guid.initString("6d2fd252-75c5-4f66-90ba-2a7d8cc3039f");
pub const IID_IComHandlerAction = &IID_IComHandlerAction_Value;
pub const IComHandlerAction = extern struct {
    pub const VTable = extern struct {
        base: IAction.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassId: fn(
            self: *const IComHandlerAction,
            pClsid: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClassId: fn(
            self: *const IComHandlerAction,
            clsid: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: fn(
            self: *const IComHandlerAction,
            pData: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: fn(
            self: *const IComHandlerAction,
            data: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComHandlerAction_get_ClassId(self: *const T, pClsid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComHandlerAction.VTable, self.vtable).get_ClassId(@ptrCast(*const IComHandlerAction, self), pClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComHandlerAction_put_ClassId(self: *const T, clsid: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComHandlerAction.VTable, self.vtable).put_ClassId(@ptrCast(*const IComHandlerAction, self), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComHandlerAction_get_Data(self: *const T, pData: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComHandlerAction.VTable, self.vtable).get_Data(@ptrCast(*const IComHandlerAction, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComHandlerAction_put_Data(self: *const T, data: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComHandlerAction.VTable, self.vtable).put_Data(@ptrCast(*const IComHandlerAction, self), data);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEmailAction_Value = @import("../zig.zig").Guid.initString("10f62c64-7e16-4314-a0c2-0c3683f99d40");
pub const IID_IEmailAction = &IID_IEmailAction_Value;
pub const IEmailAction = extern struct {
    pub const VTable = extern struct {
        base: IAction.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Server: fn(
            self: *const IEmailAction,
            pServer: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Server: fn(
            self: *const IEmailAction,
            server: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Subject: fn(
            self: *const IEmailAction,
            pSubject: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Subject: fn(
            self: *const IEmailAction,
            subject: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_To: fn(
            self: *const IEmailAction,
            pTo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_To: fn(
            self: *const IEmailAction,
            to: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Cc: fn(
            self: *const IEmailAction,
            pCc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Cc: fn(
            self: *const IEmailAction,
            cc: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bcc: fn(
            self: *const IEmailAction,
            pBcc: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bcc: fn(
            self: *const IEmailAction,
            bcc: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReplyTo: fn(
            self: *const IEmailAction,
            pReplyTo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ReplyTo: fn(
            self: *const IEmailAction,
            replyTo: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_From: fn(
            self: *const IEmailAction,
            pFrom: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_From: fn(
            self: *const IEmailAction,
            from: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HeaderFields: fn(
            self: *const IEmailAction,
            ppHeaderFields: ?*?*ITaskNamedValueCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HeaderFields: fn(
            self: *const IEmailAction,
            pHeaderFields: ?*ITaskNamedValueCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Body: fn(
            self: *const IEmailAction,
            pBody: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Body: fn(
            self: *const IEmailAction,
            body: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Attachments: fn(
            self: *const IEmailAction,
            pAttachements: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Attachments: fn(
            self: *const IEmailAction,
            pAttachements: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_Server(self: *const T, pServer: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_Server(@ptrCast(*const IEmailAction, self), pServer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_Server(self: *const T, server: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_Server(@ptrCast(*const IEmailAction, self), server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_Subject(self: *const T, pSubject: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_Subject(@ptrCast(*const IEmailAction, self), pSubject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_Subject(self: *const T, subject: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_Subject(@ptrCast(*const IEmailAction, self), subject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_To(self: *const T, pTo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_To(@ptrCast(*const IEmailAction, self), pTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_To(self: *const T, to: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_To(@ptrCast(*const IEmailAction, self), to);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_Cc(self: *const T, pCc: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_Cc(@ptrCast(*const IEmailAction, self), pCc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_Cc(self: *const T, cc: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_Cc(@ptrCast(*const IEmailAction, self), cc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_Bcc(self: *const T, pBcc: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_Bcc(@ptrCast(*const IEmailAction, self), pBcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_Bcc(self: *const T, bcc: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_Bcc(@ptrCast(*const IEmailAction, self), bcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_ReplyTo(self: *const T, pReplyTo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_ReplyTo(@ptrCast(*const IEmailAction, self), pReplyTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_ReplyTo(self: *const T, replyTo: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_ReplyTo(@ptrCast(*const IEmailAction, self), replyTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_From(self: *const T, pFrom: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_From(@ptrCast(*const IEmailAction, self), pFrom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_From(self: *const T, from: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_From(@ptrCast(*const IEmailAction, self), from);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_HeaderFields(self: *const T, ppHeaderFields: ?*?*ITaskNamedValueCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_HeaderFields(@ptrCast(*const IEmailAction, self), ppHeaderFields);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_HeaderFields(self: *const T, pHeaderFields: ?*ITaskNamedValueCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_HeaderFields(@ptrCast(*const IEmailAction, self), pHeaderFields);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_Body(self: *const T, pBody: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_Body(@ptrCast(*const IEmailAction, self), pBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_Body(self: *const T, body: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_Body(@ptrCast(*const IEmailAction, self), body);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_get_Attachments(self: *const T, pAttachements: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).get_Attachments(@ptrCast(*const IEmailAction, self), pAttachements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmailAction_put_Attachments(self: *const T, pAttachements: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmailAction.VTable, self.vtable).put_Attachments(@ptrCast(*const IEmailAction, self), pAttachements);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITriggerCollection_Value = @import("../zig.zig").Guid.initString("85df5081-1b24-4f32-878a-d9d14df4cb77");
pub const IID_ITriggerCollection = &IID_ITriggerCollection_Value;
pub const ITriggerCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ITriggerCollection,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ITriggerCollection,
            index: i32,
            ppTrigger: ?*?*ITrigger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ITriggerCollection,
            ppEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: fn(
            self: *const ITriggerCollection,
            type: TASK_TRIGGER_TYPE2,
            ppTrigger: ?*?*ITrigger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ITriggerCollection,
            index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ITriggerCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITriggerCollection_get_Count(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITriggerCollection.VTable, self.vtable).get_Count(@ptrCast(*const ITriggerCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITriggerCollection_get_Item(self: *const T, index: i32, ppTrigger: ?*?*ITrigger) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITriggerCollection.VTable, self.vtable).get_Item(@ptrCast(*const ITriggerCollection, self), index, ppTrigger);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITriggerCollection_get__NewEnum(self: *const T, ppEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITriggerCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const ITriggerCollection, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITriggerCollection_Create(self: *const T, type_: TASK_TRIGGER_TYPE2, ppTrigger: ?*?*ITrigger) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITriggerCollection.VTable, self.vtable).Create(@ptrCast(*const ITriggerCollection, self), type_, ppTrigger);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITriggerCollection_Remove(self: *const T, index: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITriggerCollection.VTable, self.vtable).Remove(@ptrCast(*const ITriggerCollection, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITriggerCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITriggerCollection.VTable, self.vtable).Clear(@ptrCast(*const ITriggerCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IActionCollection_Value = @import("../zig.zig").Guid.initString("02820e19-7b98-4ed2-b2e8-fdccceff619b");
pub const IID_IActionCollection = &IID_IActionCollection_Value;
pub const IActionCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IActionCollection,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IActionCollection,
            index: i32,
            ppAction: ?*?*IAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IActionCollection,
            ppEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XmlText: fn(
            self: *const IActionCollection,
            pText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_XmlText: fn(
            self: *const IActionCollection,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: fn(
            self: *const IActionCollection,
            type: TASK_ACTION_TYPE,
            ppAction: ?*?*IAction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IActionCollection,
            index: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IActionCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Context: fn(
            self: *const IActionCollection,
            pContext: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Context: fn(
            self: *const IActionCollection,
            context: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_get_Count(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).get_Count(@ptrCast(*const IActionCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_get_Item(self: *const T, index: i32, ppAction: ?*?*IAction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).get_Item(@ptrCast(*const IActionCollection, self), index, ppAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_get__NewEnum(self: *const T, ppEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IActionCollection, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_get_XmlText(self: *const T, pText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).get_XmlText(@ptrCast(*const IActionCollection, self), pText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_put_XmlText(self: *const T, text: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).put_XmlText(@ptrCast(*const IActionCollection, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_Create(self: *const T, type_: TASK_ACTION_TYPE, ppAction: ?*?*IAction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).Create(@ptrCast(*const IActionCollection, self), type_, ppAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_Remove(self: *const T, index: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).Remove(@ptrCast(*const IActionCollection, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).Clear(@ptrCast(*const IActionCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_get_Context(self: *const T, pContext: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).get_Context(@ptrCast(*const IActionCollection, self), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionCollection_put_Context(self: *const T, context: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionCollection.VTable, self.vtable).put_Context(@ptrCast(*const IActionCollection, self), context);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPrincipal_Value = @import("../zig.zig").Guid.initString("d98d51e5-c9b4-496a-a9c1-18980261cf0f");
pub const IID_IPrincipal = &IID_IPrincipal_Value;
pub const IPrincipal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: fn(
            self: *const IPrincipal,
            pId: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Id: fn(
            self: *const IPrincipal,
            Id: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: fn(
            self: *const IPrincipal,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplayName: fn(
            self: *const IPrincipal,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserId: fn(
            self: *const IPrincipal,
            pUser: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserId: fn(
            self: *const IPrincipal,
            user: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogonType: fn(
            self: *const IPrincipal,
            pLogon: ?*TASK_LOGON_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LogonType: fn(
            self: *const IPrincipal,
            logon: TASK_LOGON_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GroupId: fn(
            self: *const IPrincipal,
            pGroup: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GroupId: fn(
            self: *const IPrincipal,
            group: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunLevel: fn(
            self: *const IPrincipal,
            pRunLevel: ?*TASK_RUNLEVEL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RunLevel: fn(
            self: *const IPrincipal,
            runLevel: TASK_RUNLEVEL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_get_Id(self: *const T, pId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).get_Id(@ptrCast(*const IPrincipal, self), pId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_put_Id(self: *const T, Id: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).put_Id(@ptrCast(*const IPrincipal, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_get_DisplayName(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).get_DisplayName(@ptrCast(*const IPrincipal, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_put_DisplayName(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).put_DisplayName(@ptrCast(*const IPrincipal, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_get_UserId(self: *const T, pUser: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).get_UserId(@ptrCast(*const IPrincipal, self), pUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_put_UserId(self: *const T, user: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).put_UserId(@ptrCast(*const IPrincipal, self), user);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_get_LogonType(self: *const T, pLogon: ?*TASK_LOGON_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).get_LogonType(@ptrCast(*const IPrincipal, self), pLogon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_put_LogonType(self: *const T, logon: TASK_LOGON_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).put_LogonType(@ptrCast(*const IPrincipal, self), logon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_get_GroupId(self: *const T, pGroup: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).get_GroupId(@ptrCast(*const IPrincipal, self), pGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_put_GroupId(self: *const T, group: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).put_GroupId(@ptrCast(*const IPrincipal, self), group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_get_RunLevel(self: *const T, pRunLevel: ?*TASK_RUNLEVEL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).get_RunLevel(@ptrCast(*const IPrincipal, self), pRunLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal_put_RunLevel(self: *const T, runLevel: TASK_RUNLEVEL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal.VTable, self.vtable).put_RunLevel(@ptrCast(*const IPrincipal, self), runLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPrincipal2_Value = @import("../zig.zig").Guid.initString("248919ae-e345-4a6d-8aeb-e0d3165c904e");
pub const IID_IPrincipal2 = &IID_IPrincipal2_Value;
pub const IPrincipal2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProcessTokenSidType: fn(
            self: *const IPrincipal2,
            pProcessTokenSidType: ?*TASK_PROCESSTOKENSID_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProcessTokenSidType: fn(
            self: *const IPrincipal2,
            processTokenSidType: TASK_PROCESSTOKENSID_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequiredPrivilegeCount: fn(
            self: *const IPrincipal2,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequiredPrivilege: fn(
            self: *const IPrincipal2,
            index: i32,
            pPrivilege: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRequiredPrivilege: fn(
            self: *const IPrincipal2,
            privilege: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal2_get_ProcessTokenSidType(self: *const T, pProcessTokenSidType: ?*TASK_PROCESSTOKENSID_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal2.VTable, self.vtable).get_ProcessTokenSidType(@ptrCast(*const IPrincipal2, self), pProcessTokenSidType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal2_put_ProcessTokenSidType(self: *const T, processTokenSidType: TASK_PROCESSTOKENSID_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal2.VTable, self.vtable).put_ProcessTokenSidType(@ptrCast(*const IPrincipal2, self), processTokenSidType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal2_get_RequiredPrivilegeCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal2.VTable, self.vtable).get_RequiredPrivilegeCount(@ptrCast(*const IPrincipal2, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal2_get_RequiredPrivilege(self: *const T, index: i32, pPrivilege: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal2.VTable, self.vtable).get_RequiredPrivilege(@ptrCast(*const IPrincipal2, self), index, pPrivilege);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrincipal2_AddRequiredPrivilege(self: *const T, privilege: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrincipal2.VTable, self.vtable).AddRequiredPrivilege(@ptrCast(*const IPrincipal2, self), privilege);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRegistrationInfo_Value = @import("../zig.zig").Guid.initString("416d8b73-cb41-4ea1-805c-9be9a5ac4a74");
pub const IID_IRegistrationInfo = &IID_IRegistrationInfo_Value;
pub const IRegistrationInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IRegistrationInfo,
            pDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IRegistrationInfo,
            description: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Author: fn(
            self: *const IRegistrationInfo,
            pAuthor: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Author: fn(
            self: *const IRegistrationInfo,
            author: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const IRegistrationInfo,
            pVersion: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Version: fn(
            self: *const IRegistrationInfo,
            version: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Date: fn(
            self: *const IRegistrationInfo,
            pDate: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Date: fn(
            self: *const IRegistrationInfo,
            date: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Documentation: fn(
            self: *const IRegistrationInfo,
            pDocumentation: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Documentation: fn(
            self: *const IRegistrationInfo,
            documentation: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XmlText: fn(
            self: *const IRegistrationInfo,
            pText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_XmlText: fn(
            self: *const IRegistrationInfo,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URI: fn(
            self: *const IRegistrationInfo,
            pUri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_URI: fn(
            self: *const IRegistrationInfo,
            uri: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SecurityDescriptor: fn(
            self: *const IRegistrationInfo,
            pSddl: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SecurityDescriptor: fn(
            self: *const IRegistrationInfo,
            sddl: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Source: fn(
            self: *const IRegistrationInfo,
            pSource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Source: fn(
            self: *const IRegistrationInfo,
            source: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_get_Description(self: *const T, pDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).get_Description(@ptrCast(*const IRegistrationInfo, self), pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_put_Description(self: *const T, description: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).put_Description(@ptrCast(*const IRegistrationInfo, self), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_get_Author(self: *const T, pAuthor: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).get_Author(@ptrCast(*const IRegistrationInfo, self), pAuthor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_put_Author(self: *const T, author: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).put_Author(@ptrCast(*const IRegistrationInfo, self), author);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_get_Version(self: *const T, pVersion: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).get_Version(@ptrCast(*const IRegistrationInfo, self), pVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_put_Version(self: *const T, version: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).put_Version(@ptrCast(*const IRegistrationInfo, self), version);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_get_Date(self: *const T, pDate: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).get_Date(@ptrCast(*const IRegistrationInfo, self), pDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_put_Date(self: *const T, date: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).put_Date(@ptrCast(*const IRegistrationInfo, self), date);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_get_Documentation(self: *const T, pDocumentation: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).get_Documentation(@ptrCast(*const IRegistrationInfo, self), pDocumentation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_put_Documentation(self: *const T, documentation: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).put_Documentation(@ptrCast(*const IRegistrationInfo, self), documentation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_get_XmlText(self: *const T, pText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).get_XmlText(@ptrCast(*const IRegistrationInfo, self), pText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_put_XmlText(self: *const T, text: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).put_XmlText(@ptrCast(*const IRegistrationInfo, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_get_URI(self: *const T, pUri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).get_URI(@ptrCast(*const IRegistrationInfo, self), pUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_put_URI(self: *const T, uri: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).put_URI(@ptrCast(*const IRegistrationInfo, self), uri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_get_SecurityDescriptor(self: *const T, pSddl: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).get_SecurityDescriptor(@ptrCast(*const IRegistrationInfo, self), pSddl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_put_SecurityDescriptor(self: *const T, sddl: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).put_SecurityDescriptor(@ptrCast(*const IRegistrationInfo, self), sddl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_get_Source(self: *const T, pSource: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).get_Source(@ptrCast(*const IRegistrationInfo, self), pSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegistrationInfo_put_Source(self: *const T, source: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegistrationInfo.VTable, self.vtable).put_Source(@ptrCast(*const IRegistrationInfo, self), source);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskDefinition_Value = @import("../zig.zig").Guid.initString("f5bc8fc5-536d-4f77-b852-fbc1356fdeb6");
pub const IID_ITaskDefinition = &IID_ITaskDefinition_Value;
pub const ITaskDefinition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegistrationInfo: fn(
            self: *const ITaskDefinition,
            ppRegistrationInfo: ?*?*IRegistrationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RegistrationInfo: fn(
            self: *const ITaskDefinition,
            pRegistrationInfo: ?*IRegistrationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Triggers: fn(
            self: *const ITaskDefinition,
            ppTriggers: ?*?*ITriggerCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Triggers: fn(
            self: *const ITaskDefinition,
            pTriggers: ?*ITriggerCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Settings: fn(
            self: *const ITaskDefinition,
            ppSettings: ?*?*ITaskSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Settings: fn(
            self: *const ITaskDefinition,
            pSettings: ?*ITaskSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: fn(
            self: *const ITaskDefinition,
            pData: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: fn(
            self: *const ITaskDefinition,
            data: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Principal: fn(
            self: *const ITaskDefinition,
            ppPrincipal: ?*?*IPrincipal,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Principal: fn(
            self: *const ITaskDefinition,
            pPrincipal: ?*IPrincipal,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Actions: fn(
            self: *const ITaskDefinition,
            ppActions: ?*?*IActionCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Actions: fn(
            self: *const ITaskDefinition,
            pActions: ?*IActionCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XmlText: fn(
            self: *const ITaskDefinition,
            pXml: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_XmlText: fn(
            self: *const ITaskDefinition,
            xml: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_get_RegistrationInfo(self: *const T, ppRegistrationInfo: ?*?*IRegistrationInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).get_RegistrationInfo(@ptrCast(*const ITaskDefinition, self), ppRegistrationInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_put_RegistrationInfo(self: *const T, pRegistrationInfo: ?*IRegistrationInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).put_RegistrationInfo(@ptrCast(*const ITaskDefinition, self), pRegistrationInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_get_Triggers(self: *const T, ppTriggers: ?*?*ITriggerCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).get_Triggers(@ptrCast(*const ITaskDefinition, self), ppTriggers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_put_Triggers(self: *const T, pTriggers: ?*ITriggerCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).put_Triggers(@ptrCast(*const ITaskDefinition, self), pTriggers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_get_Settings(self: *const T, ppSettings: ?*?*ITaskSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).get_Settings(@ptrCast(*const ITaskDefinition, self), ppSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_put_Settings(self: *const T, pSettings: ?*ITaskSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).put_Settings(@ptrCast(*const ITaskDefinition, self), pSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_get_Data(self: *const T, pData: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).get_Data(@ptrCast(*const ITaskDefinition, self), pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_put_Data(self: *const T, data: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).put_Data(@ptrCast(*const ITaskDefinition, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_get_Principal(self: *const T, ppPrincipal: ?*?*IPrincipal) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).get_Principal(@ptrCast(*const ITaskDefinition, self), ppPrincipal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_put_Principal(self: *const T, pPrincipal: ?*IPrincipal) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).put_Principal(@ptrCast(*const ITaskDefinition, self), pPrincipal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_get_Actions(self: *const T, ppActions: ?*?*IActionCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).get_Actions(@ptrCast(*const ITaskDefinition, self), ppActions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_put_Actions(self: *const T, pActions: ?*IActionCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).put_Actions(@ptrCast(*const ITaskDefinition, self), pActions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_get_XmlText(self: *const T, pXml: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).get_XmlText(@ptrCast(*const ITaskDefinition, self), pXml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskDefinition_put_XmlText(self: *const T, xml: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskDefinition.VTable, self.vtable).put_XmlText(@ptrCast(*const ITaskDefinition, self), xml);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskSettings_Value = @import("../zig.zig").Guid.initString("8fd4711d-2d02-4c8c-87e3-eff699de127e");
pub const IID_ITaskSettings = &IID_ITaskSettings_Value;
pub const ITaskSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowDemandStart: fn(
            self: *const ITaskSettings,
            pAllowDemandStart: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowDemandStart: fn(
            self: *const ITaskSettings,
            allowDemandStart: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RestartInterval: fn(
            self: *const ITaskSettings,
            pRestartInterval: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RestartInterval: fn(
            self: *const ITaskSettings,
            restartInterval: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RestartCount: fn(
            self: *const ITaskSettings,
            pRestartCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RestartCount: fn(
            self: *const ITaskSettings,
            restartCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MultipleInstances: fn(
            self: *const ITaskSettings,
            pPolicy: ?*TASK_INSTANCES_POLICY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MultipleInstances: fn(
            self: *const ITaskSettings,
            policy: TASK_INSTANCES_POLICY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopIfGoingOnBatteries: fn(
            self: *const ITaskSettings,
            pStopIfOnBatteries: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopIfGoingOnBatteries: fn(
            self: *const ITaskSettings,
            stopIfOnBatteries: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisallowStartIfOnBatteries: fn(
            self: *const ITaskSettings,
            pDisallowStart: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisallowStartIfOnBatteries: fn(
            self: *const ITaskSettings,
            disallowStart: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllowHardTerminate: fn(
            self: *const ITaskSettings,
            pAllowHardTerminate: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AllowHardTerminate: fn(
            self: *const ITaskSettings,
            allowHardTerminate: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartWhenAvailable: fn(
            self: *const ITaskSettings,
            pStartWhenAvailable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartWhenAvailable: fn(
            self: *const ITaskSettings,
            startWhenAvailable: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XmlText: fn(
            self: *const ITaskSettings,
            pText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_XmlText: fn(
            self: *const ITaskSettings,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunOnlyIfNetworkAvailable: fn(
            self: *const ITaskSettings,
            pRunOnlyIfNetworkAvailable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RunOnlyIfNetworkAvailable: fn(
            self: *const ITaskSettings,
            runOnlyIfNetworkAvailable: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExecutionTimeLimit: fn(
            self: *const ITaskSettings,
            pExecutionTimeLimit: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExecutionTimeLimit: fn(
            self: *const ITaskSettings,
            executionTimeLimit: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const ITaskSettings,
            pEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: fn(
            self: *const ITaskSettings,
            enabled: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeleteExpiredTaskAfter: fn(
            self: *const ITaskSettings,
            pExpirationDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DeleteExpiredTaskAfter: fn(
            self: *const ITaskSettings,
            expirationDelay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Priority: fn(
            self: *const ITaskSettings,
            pPriority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Priority: fn(
            self: *const ITaskSettings,
            priority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Compatibility: fn(
            self: *const ITaskSettings,
            pCompatLevel: ?*TASK_COMPATIBILITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Compatibility: fn(
            self: *const ITaskSettings,
            compatLevel: TASK_COMPATIBILITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hidden: fn(
            self: *const ITaskSettings,
            pHidden: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Hidden: fn(
            self: *const ITaskSettings,
            hidden: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IdleSettings: fn(
            self: *const ITaskSettings,
            ppIdleSettings: ?*?*IIdleSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IdleSettings: fn(
            self: *const ITaskSettings,
            pIdleSettings: ?*IIdleSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunOnlyIfIdle: fn(
            self: *const ITaskSettings,
            pRunOnlyIfIdle: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RunOnlyIfIdle: fn(
            self: *const ITaskSettings,
            runOnlyIfIdle: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WakeToRun: fn(
            self: *const ITaskSettings,
            pWake: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WakeToRun: fn(
            self: *const ITaskSettings,
            wake: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetworkSettings: fn(
            self: *const ITaskSettings,
            ppNetworkSettings: ?*?*INetworkSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NetworkSettings: fn(
            self: *const ITaskSettings,
            pNetworkSettings: ?*INetworkSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_AllowDemandStart(self: *const T, pAllowDemandStart: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_AllowDemandStart(@ptrCast(*const ITaskSettings, self), pAllowDemandStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_AllowDemandStart(self: *const T, allowDemandStart: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_AllowDemandStart(@ptrCast(*const ITaskSettings, self), allowDemandStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_RestartInterval(self: *const T, pRestartInterval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_RestartInterval(@ptrCast(*const ITaskSettings, self), pRestartInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_RestartInterval(self: *const T, restartInterval: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_RestartInterval(@ptrCast(*const ITaskSettings, self), restartInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_RestartCount(self: *const T, pRestartCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_RestartCount(@ptrCast(*const ITaskSettings, self), pRestartCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_RestartCount(self: *const T, restartCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_RestartCount(@ptrCast(*const ITaskSettings, self), restartCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_MultipleInstances(self: *const T, pPolicy: ?*TASK_INSTANCES_POLICY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_MultipleInstances(@ptrCast(*const ITaskSettings, self), pPolicy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_MultipleInstances(self: *const T, policy: TASK_INSTANCES_POLICY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_MultipleInstances(@ptrCast(*const ITaskSettings, self), policy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_StopIfGoingOnBatteries(self: *const T, pStopIfOnBatteries: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_StopIfGoingOnBatteries(@ptrCast(*const ITaskSettings, self), pStopIfOnBatteries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_StopIfGoingOnBatteries(self: *const T, stopIfOnBatteries: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_StopIfGoingOnBatteries(@ptrCast(*const ITaskSettings, self), stopIfOnBatteries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_DisallowStartIfOnBatteries(self: *const T, pDisallowStart: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_DisallowStartIfOnBatteries(@ptrCast(*const ITaskSettings, self), pDisallowStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_DisallowStartIfOnBatteries(self: *const T, disallowStart: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_DisallowStartIfOnBatteries(@ptrCast(*const ITaskSettings, self), disallowStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_AllowHardTerminate(self: *const T, pAllowHardTerminate: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_AllowHardTerminate(@ptrCast(*const ITaskSettings, self), pAllowHardTerminate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_AllowHardTerminate(self: *const T, allowHardTerminate: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_AllowHardTerminate(@ptrCast(*const ITaskSettings, self), allowHardTerminate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_StartWhenAvailable(self: *const T, pStartWhenAvailable: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_StartWhenAvailable(@ptrCast(*const ITaskSettings, self), pStartWhenAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_StartWhenAvailable(self: *const T, startWhenAvailable: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_StartWhenAvailable(@ptrCast(*const ITaskSettings, self), startWhenAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_XmlText(self: *const T, pText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_XmlText(@ptrCast(*const ITaskSettings, self), pText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_XmlText(self: *const T, text: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_XmlText(@ptrCast(*const ITaskSettings, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_RunOnlyIfNetworkAvailable(self: *const T, pRunOnlyIfNetworkAvailable: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_RunOnlyIfNetworkAvailable(@ptrCast(*const ITaskSettings, self), pRunOnlyIfNetworkAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_RunOnlyIfNetworkAvailable(self: *const T, runOnlyIfNetworkAvailable: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_RunOnlyIfNetworkAvailable(@ptrCast(*const ITaskSettings, self), runOnlyIfNetworkAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_ExecutionTimeLimit(self: *const T, pExecutionTimeLimit: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_ExecutionTimeLimit(@ptrCast(*const ITaskSettings, self), pExecutionTimeLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_ExecutionTimeLimit(self: *const T, executionTimeLimit: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_ExecutionTimeLimit(@ptrCast(*const ITaskSettings, self), executionTimeLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_Enabled(self: *const T, pEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_Enabled(@ptrCast(*const ITaskSettings, self), pEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_Enabled(self: *const T, enabled: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_Enabled(@ptrCast(*const ITaskSettings, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_DeleteExpiredTaskAfter(self: *const T, pExpirationDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_DeleteExpiredTaskAfter(@ptrCast(*const ITaskSettings, self), pExpirationDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_DeleteExpiredTaskAfter(self: *const T, expirationDelay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_DeleteExpiredTaskAfter(@ptrCast(*const ITaskSettings, self), expirationDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_Priority(self: *const T, pPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_Priority(@ptrCast(*const ITaskSettings, self), pPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_Priority(self: *const T, priority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_Priority(@ptrCast(*const ITaskSettings, self), priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_Compatibility(self: *const T, pCompatLevel: ?*TASK_COMPATIBILITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_Compatibility(@ptrCast(*const ITaskSettings, self), pCompatLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_Compatibility(self: *const T, compatLevel: TASK_COMPATIBILITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_Compatibility(@ptrCast(*const ITaskSettings, self), compatLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_Hidden(self: *const T, pHidden: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_Hidden(@ptrCast(*const ITaskSettings, self), pHidden);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_Hidden(self: *const T, hidden: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_Hidden(@ptrCast(*const ITaskSettings, self), hidden);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_IdleSettings(self: *const T, ppIdleSettings: ?*?*IIdleSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_IdleSettings(@ptrCast(*const ITaskSettings, self), ppIdleSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_IdleSettings(self: *const T, pIdleSettings: ?*IIdleSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_IdleSettings(@ptrCast(*const ITaskSettings, self), pIdleSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_RunOnlyIfIdle(self: *const T, pRunOnlyIfIdle: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_RunOnlyIfIdle(@ptrCast(*const ITaskSettings, self), pRunOnlyIfIdle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_RunOnlyIfIdle(self: *const T, runOnlyIfIdle: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_RunOnlyIfIdle(@ptrCast(*const ITaskSettings, self), runOnlyIfIdle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_WakeToRun(self: *const T, pWake: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_WakeToRun(@ptrCast(*const ITaskSettings, self), pWake);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_WakeToRun(self: *const T, wake: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_WakeToRun(@ptrCast(*const ITaskSettings, self), wake);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_get_NetworkSettings(self: *const T, ppNetworkSettings: ?*?*INetworkSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).get_NetworkSettings(@ptrCast(*const ITaskSettings, self), ppNetworkSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings_put_NetworkSettings(self: *const T, pNetworkSettings: ?*INetworkSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings.VTable, self.vtable).put_NetworkSettings(@ptrCast(*const ITaskSettings, self), pNetworkSettings);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ITaskSettings2_Value = @import("../zig.zig").Guid.initString("2c05c3f0-6eed-4c05-a15f-ed7d7a98a369");
pub const IID_ITaskSettings2 = &IID_ITaskSettings2_Value;
pub const ITaskSettings2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisallowStartOnRemoteAppSession: fn(
            self: *const ITaskSettings2,
            pDisallowStart: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisallowStartOnRemoteAppSession: fn(
            self: *const ITaskSettings2,
            disallowStart: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseUnifiedSchedulingEngine: fn(
            self: *const ITaskSettings2,
            pUseUnifiedEngine: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseUnifiedSchedulingEngine: fn(
            self: *const ITaskSettings2,
            useUnifiedEngine: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings2_get_DisallowStartOnRemoteAppSession(self: *const T, pDisallowStart: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings2.VTable, self.vtable).get_DisallowStartOnRemoteAppSession(@ptrCast(*const ITaskSettings2, self), pDisallowStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings2_put_DisallowStartOnRemoteAppSession(self: *const T, disallowStart: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings2.VTable, self.vtable).put_DisallowStartOnRemoteAppSession(@ptrCast(*const ITaskSettings2, self), disallowStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings2_get_UseUnifiedSchedulingEngine(self: *const T, pUseUnifiedEngine: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings2.VTable, self.vtable).get_UseUnifiedSchedulingEngine(@ptrCast(*const ITaskSettings2, self), pUseUnifiedEngine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings2_put_UseUnifiedSchedulingEngine(self: *const T, useUnifiedEngine: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings2.VTable, self.vtable).put_UseUnifiedSchedulingEngine(@ptrCast(*const ITaskSettings2, self), useUnifiedEngine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITaskSettings3_Value = @import("../zig.zig").Guid.initString("0ad9d0d7-0c7f-4ebb-9a5f-d1c648dca528");
pub const IID_ITaskSettings3 = &IID_ITaskSettings3_Value;
pub const ITaskSettings3 = extern struct {
    pub const VTable = extern struct {
        base: ITaskSettings.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisallowStartOnRemoteAppSession: fn(
            self: *const ITaskSettings3,
            pDisallowStart: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisallowStartOnRemoteAppSession: fn(
            self: *const ITaskSettings3,
            disallowStart: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseUnifiedSchedulingEngine: fn(
            self: *const ITaskSettings3,
            pUseUnifiedEngine: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseUnifiedSchedulingEngine: fn(
            self: *const ITaskSettings3,
            useUnifiedEngine: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaintenanceSettings: fn(
            self: *const ITaskSettings3,
            ppMaintenanceSettings: ?*?*IMaintenanceSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaintenanceSettings: fn(
            self: *const ITaskSettings3,
            pMaintenanceSettings: ?*IMaintenanceSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMaintenanceSettings: fn(
            self: *const ITaskSettings3,
            ppMaintenanceSettings: ?*?*IMaintenanceSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volatile: fn(
            self: *const ITaskSettings3,
            pVolatile: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volatile: fn(
            self: *const ITaskSettings3,
            Volatile: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITaskSettings.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings3_get_DisallowStartOnRemoteAppSession(self: *const T, pDisallowStart: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings3.VTable, self.vtable).get_DisallowStartOnRemoteAppSession(@ptrCast(*const ITaskSettings3, self), pDisallowStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings3_put_DisallowStartOnRemoteAppSession(self: *const T, disallowStart: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings3.VTable, self.vtable).put_DisallowStartOnRemoteAppSession(@ptrCast(*const ITaskSettings3, self), disallowStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings3_get_UseUnifiedSchedulingEngine(self: *const T, pUseUnifiedEngine: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings3.VTable, self.vtable).get_UseUnifiedSchedulingEngine(@ptrCast(*const ITaskSettings3, self), pUseUnifiedEngine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings3_put_UseUnifiedSchedulingEngine(self: *const T, useUnifiedEngine: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings3.VTable, self.vtable).put_UseUnifiedSchedulingEngine(@ptrCast(*const ITaskSettings3, self), useUnifiedEngine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings3_get_MaintenanceSettings(self: *const T, ppMaintenanceSettings: ?*?*IMaintenanceSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings3.VTable, self.vtable).get_MaintenanceSettings(@ptrCast(*const ITaskSettings3, self), ppMaintenanceSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings3_put_MaintenanceSettings(self: *const T, pMaintenanceSettings: ?*IMaintenanceSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings3.VTable, self.vtable).put_MaintenanceSettings(@ptrCast(*const ITaskSettings3, self), pMaintenanceSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings3_CreateMaintenanceSettings(self: *const T, ppMaintenanceSettings: ?*?*IMaintenanceSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings3.VTable, self.vtable).CreateMaintenanceSettings(@ptrCast(*const ITaskSettings3, self), ppMaintenanceSettings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings3_get_Volatile(self: *const T, pVolatile: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings3.VTable, self.vtable).get_Volatile(@ptrCast(*const ITaskSettings3, self), pVolatile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskSettings3_put_Volatile(self: *const T, Volatile: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskSettings3.VTable, self.vtable).put_Volatile(@ptrCast(*const ITaskSettings3, self), Volatile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMaintenanceSettings_Value = @import("../zig.zig").Guid.initString("a6024fa8-9652-4adb-a6bf-5cfcd877a7ba");
pub const IID_IMaintenanceSettings = &IID_IMaintenanceSettings_Value;
pub const IMaintenanceSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Period: fn(
            self: *const IMaintenanceSettings,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Period: fn(
            self: *const IMaintenanceSettings,
            target: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Deadline: fn(
            self: *const IMaintenanceSettings,
            value: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Deadline: fn(
            self: *const IMaintenanceSettings,
            target: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Exclusive: fn(
            self: *const IMaintenanceSettings,
            value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Exclusive: fn(
            self: *const IMaintenanceSettings,
            target: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMaintenanceSettings_put_Period(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMaintenanceSettings.VTable, self.vtable).put_Period(@ptrCast(*const IMaintenanceSettings, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMaintenanceSettings_get_Period(self: *const T, target: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMaintenanceSettings.VTable, self.vtable).get_Period(@ptrCast(*const IMaintenanceSettings, self), target);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMaintenanceSettings_put_Deadline(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMaintenanceSettings.VTable, self.vtable).put_Deadline(@ptrCast(*const IMaintenanceSettings, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMaintenanceSettings_get_Deadline(self: *const T, target: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMaintenanceSettings.VTable, self.vtable).get_Deadline(@ptrCast(*const IMaintenanceSettings, self), target);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMaintenanceSettings_put_Exclusive(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMaintenanceSettings.VTable, self.vtable).put_Exclusive(@ptrCast(*const IMaintenanceSettings, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMaintenanceSettings_get_Exclusive(self: *const T, target: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMaintenanceSettings.VTable, self.vtable).get_Exclusive(@ptrCast(*const IMaintenanceSettings, self), target);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRegisteredTaskCollection_Value = @import("../zig.zig").Guid.initString("86627eb4-42a7-41e4-a4d9-ac33a72f2d52");
pub const IID_IRegisteredTaskCollection = &IID_IRegisteredTaskCollection_Value;
pub const IRegisteredTaskCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IRegisteredTaskCollection,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IRegisteredTaskCollection,
            index: VARIANT,
            ppRegisteredTask: ?*?*IRegisteredTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IRegisteredTaskCollection,
            ppEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTaskCollection_get_Count(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTaskCollection.VTable, self.vtable).get_Count(@ptrCast(*const IRegisteredTaskCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTaskCollection_get_Item(self: *const T, index: VARIANT, ppRegisteredTask: ?*?*IRegisteredTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTaskCollection.VTable, self.vtable).get_Item(@ptrCast(*const IRegisteredTaskCollection, self), index, ppRegisteredTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisteredTaskCollection_get__NewEnum(self: *const T, ppEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisteredTaskCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const IRegisteredTaskCollection, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITaskFolder_Value = @import("../zig.zig").Guid.initString("8cfac062-a080-4c15-9a88-aa7c2af80dfc");
pub const IID_ITaskFolder = &IID_ITaskFolder_Value;
pub const ITaskFolder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const ITaskFolder,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const ITaskFolder,
            pPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolder: fn(
            self: *const ITaskFolder,
            path: ?BSTR,
            ppFolder: ?*?*ITaskFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolders: fn(
            self: *const ITaskFolder,
            flags: i32,
            ppFolders: ?*?*ITaskFolderCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFolder: fn(
            self: *const ITaskFolder,
            subFolderName: ?BSTR,
            sddl: VARIANT,
            ppFolder: ?*?*ITaskFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteFolder: fn(
            self: *const ITaskFolder,
            subFolderName: ?BSTR,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTask: fn(
            self: *const ITaskFolder,
            path: ?BSTR,
            ppTask: ?*?*IRegisteredTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTasks: fn(
            self: *const ITaskFolder,
            flags: i32,
            ppTasks: ?*?*IRegisteredTaskCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTask: fn(
            self: *const ITaskFolder,
            name: ?BSTR,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterTask: fn(
            self: *const ITaskFolder,
            path: ?BSTR,
            xmlText: ?BSTR,
            flags: i32,
            userId: VARIANT,
            password: VARIANT,
            logonType: TASK_LOGON_TYPE,
            sddl: VARIANT,
            ppTask: ?*?*IRegisteredTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterTaskDefinition: fn(
            self: *const ITaskFolder,
            path: ?BSTR,
            pDefinition: ?*ITaskDefinition,
            flags: i32,
            userId: VARIANT,
            password: VARIANT,
            logonType: TASK_LOGON_TYPE,
            sddl: VARIANT,
            ppTask: ?*?*IRegisteredTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityDescriptor: fn(
            self: *const ITaskFolder,
            securityInformation: i32,
            pSddl: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSecurityDescriptor: fn(
            self: *const ITaskFolder,
            sddl: ?BSTR,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_get_Name(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).get_Name(@ptrCast(*const ITaskFolder, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_get_Path(self: *const T, pPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).get_Path(@ptrCast(*const ITaskFolder, self), pPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_GetFolder(self: *const T, path: ?BSTR, ppFolder: ?*?*ITaskFolder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).GetFolder(@ptrCast(*const ITaskFolder, self), path, ppFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_GetFolders(self: *const T, flags: i32, ppFolders: ?*?*ITaskFolderCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).GetFolders(@ptrCast(*const ITaskFolder, self), flags, ppFolders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_CreateFolder(self: *const T, subFolderName: ?BSTR, sddl: VARIANT, ppFolder: ?*?*ITaskFolder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).CreateFolder(@ptrCast(*const ITaskFolder, self), subFolderName, sddl, ppFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_DeleteFolder(self: *const T, subFolderName: ?BSTR, flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).DeleteFolder(@ptrCast(*const ITaskFolder, self), subFolderName, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_GetTask(self: *const T, path: ?BSTR, ppTask: ?*?*IRegisteredTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).GetTask(@ptrCast(*const ITaskFolder, self), path, ppTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_GetTasks(self: *const T, flags: i32, ppTasks: ?*?*IRegisteredTaskCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).GetTasks(@ptrCast(*const ITaskFolder, self), flags, ppTasks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_DeleteTask(self: *const T, name: ?BSTR, flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).DeleteTask(@ptrCast(*const ITaskFolder, self), name, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_RegisterTask(self: *const T, path: ?BSTR, xmlText: ?BSTR, flags: i32, userId: VARIANT, password: VARIANT, logonType: TASK_LOGON_TYPE, sddl: VARIANT, ppTask: ?*?*IRegisteredTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).RegisterTask(@ptrCast(*const ITaskFolder, self), path, xmlText, flags, userId, password, logonType, sddl, ppTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_RegisterTaskDefinition(self: *const T, path: ?BSTR, pDefinition: ?*ITaskDefinition, flags: i32, userId: VARIANT, password: VARIANT, logonType: TASK_LOGON_TYPE, sddl: VARIANT, ppTask: ?*?*IRegisteredTask) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).RegisterTaskDefinition(@ptrCast(*const ITaskFolder, self), path, pDefinition, flags, userId, password, logonType, sddl, ppTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_GetSecurityDescriptor(self: *const T, securityInformation: i32, pSddl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).GetSecurityDescriptor(@ptrCast(*const ITaskFolder, self), securityInformation, pSddl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskFolder_SetSecurityDescriptor(self: *const T, sddl: ?BSTR, flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskFolder.VTable, self.vtable).SetSecurityDescriptor(@ptrCast(*const ITaskFolder, self), sddl, flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IIdleSettings_Value = @import("../zig.zig").Guid.initString("84594461-0053-4342-a8fd-088fabf11f32");
pub const IID_IIdleSettings = &IID_IIdleSettings_Value;
pub const IIdleSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IdleDuration: fn(
            self: *const IIdleSettings,
            pDelay: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IdleDuration: fn(
            self: *const IIdleSettings,
            delay: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WaitTimeout: fn(
            self: *const IIdleSettings,
            pTimeout: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WaitTimeout: fn(
            self: *const IIdleSettings,
            timeout: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopOnIdleEnd: fn(
            self: *const IIdleSettings,
            pStop: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopOnIdleEnd: fn(
            self: *const IIdleSettings,
            stop: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RestartOnIdle: fn(
            self: *const IIdleSettings,
            pRestart: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RestartOnIdle: fn(
            self: *const IIdleSettings,
            restart: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdleSettings_get_IdleDuration(self: *const T, pDelay: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdleSettings.VTable, self.vtable).get_IdleDuration(@ptrCast(*const IIdleSettings, self), pDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdleSettings_put_IdleDuration(self: *const T, delay: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdleSettings.VTable, self.vtable).put_IdleDuration(@ptrCast(*const IIdleSettings, self), delay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdleSettings_get_WaitTimeout(self: *const T, pTimeout: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdleSettings.VTable, self.vtable).get_WaitTimeout(@ptrCast(*const IIdleSettings, self), pTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdleSettings_put_WaitTimeout(self: *const T, timeout: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdleSettings.VTable, self.vtable).put_WaitTimeout(@ptrCast(*const IIdleSettings, self), timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdleSettings_get_StopOnIdleEnd(self: *const T, pStop: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdleSettings.VTable, self.vtable).get_StopOnIdleEnd(@ptrCast(*const IIdleSettings, self), pStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdleSettings_put_StopOnIdleEnd(self: *const T, stop: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdleSettings.VTable, self.vtable).put_StopOnIdleEnd(@ptrCast(*const IIdleSettings, self), stop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdleSettings_get_RestartOnIdle(self: *const T, pRestart: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdleSettings.VTable, self.vtable).get_RestartOnIdle(@ptrCast(*const IIdleSettings, self), pRestart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIdleSettings_put_RestartOnIdle(self: *const T, restart: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIdleSettings.VTable, self.vtable).put_RestartOnIdle(@ptrCast(*const IIdleSettings, self), restart);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INetworkSettings_Value = @import("../zig.zig").Guid.initString("9f7dea84-c30b-4245-80b6-00e9f646f1b4");
pub const IID_INetworkSettings = &IID_INetworkSettings_Value;
pub const INetworkSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const INetworkSettings,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const INetworkSettings,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Id: fn(
            self: *const INetworkSettings,
            pId: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Id: fn(
            self: *const INetworkSettings,
            id: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkSettings_get_Name(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkSettings.VTable, self.vtable).get_Name(@ptrCast(*const INetworkSettings, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkSettings_put_Name(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkSettings.VTable, self.vtable).put_Name(@ptrCast(*const INetworkSettings, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkSettings_get_Id(self: *const T, pId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkSettings.VTable, self.vtable).get_Id(@ptrCast(*const INetworkSettings, self), pId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkSettings_put_Id(self: *const T, id: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkSettings.VTable, self.vtable).put_Id(@ptrCast(*const INetworkSettings, self), id);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRepetitionPattern_Value = @import("../zig.zig").Guid.initString("7fb9acf1-26be-400e-85b5-294b9c75dfd6");
pub const IID_IRepetitionPattern = &IID_IRepetitionPattern_Value;
pub const IRepetitionPattern = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Interval: fn(
            self: *const IRepetitionPattern,
            pInterval: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Interval: fn(
            self: *const IRepetitionPattern,
            interval: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Duration: fn(
            self: *const IRepetitionPattern,
            pDuration: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Duration: fn(
            self: *const IRepetitionPattern,
            duration: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopAtDurationEnd: fn(
            self: *const IRepetitionPattern,
            pStop: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopAtDurationEnd: fn(
            self: *const IRepetitionPattern,
            stop: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRepetitionPattern_get_Interval(self: *const T, pInterval: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRepetitionPattern.VTable, self.vtable).get_Interval(@ptrCast(*const IRepetitionPattern, self), pInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRepetitionPattern_put_Interval(self: *const T, interval: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRepetitionPattern.VTable, self.vtable).put_Interval(@ptrCast(*const IRepetitionPattern, self), interval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRepetitionPattern_get_Duration(self: *const T, pDuration: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRepetitionPattern.VTable, self.vtable).get_Duration(@ptrCast(*const IRepetitionPattern, self), pDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRepetitionPattern_put_Duration(self: *const T, duration: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRepetitionPattern.VTable, self.vtable).put_Duration(@ptrCast(*const IRepetitionPattern, self), duration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRepetitionPattern_get_StopAtDurationEnd(self: *const T, pStop: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRepetitionPattern.VTable, self.vtable).get_StopAtDurationEnd(@ptrCast(*const IRepetitionPattern, self), pStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRepetitionPattern_put_StopAtDurationEnd(self: *const T, stop: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRepetitionPattern.VTable, self.vtable).put_StopAtDurationEnd(@ptrCast(*const IRepetitionPattern, self), stop);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (12)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HPROPSHEETPAGE = @import("../ui/controls.zig").HPROPSHEETPAGE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const PWSTR = @import("../foundation.zig").PWSTR;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
