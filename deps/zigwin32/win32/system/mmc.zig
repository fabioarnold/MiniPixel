//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (88)
//--------------------------------------------------------------------------------
pub const MMC_VER = @as(u32, 512);
pub const MMC_PROP_CHANGEAFFECTSUI = @as(u32, 1);
pub const MMC_PROP_MODIFIABLE = @as(u32, 2);
pub const MMC_PROP_REMOVABLE = @as(u32, 4);
pub const MMC_PROP_PERSIST = @as(u32, 8);
pub const MMCLV_AUTO = @as(i32, -1);
pub const MMCLV_NOPARAM = @as(i32, -2);
pub const MMCLV_NOICON = @as(i32, -1);
pub const MMCLV_VIEWSTYLE_ICON = @as(u32, 0);
pub const MMCLV_VIEWSTYLE_SMALLICON = @as(u32, 2);
pub const MMCLV_VIEWSTYLE_LIST = @as(u32, 3);
pub const MMCLV_VIEWSTYLE_REPORT = @as(u32, 1);
pub const MMCLV_VIEWSTYLE_FILTERED = @as(u32, 4);
pub const MMCLV_NOPTR = @as(u32, 0);
pub const MMCLV_UPDATE_NOINVALIDATEALL = @as(u32, 1);
pub const MMCLV_UPDATE_NOSCROLL = @as(u32, 2);
pub const MMC_IMAGECALLBACK = @as(i32, -1);
pub const RDI_STR = @as(u32, 2);
pub const RDI_IMAGE = @as(u32, 4);
pub const RDI_STATE = @as(u32, 8);
pub const RDI_PARAM = @as(u32, 16);
pub const RDI_INDEX = @as(u32, 32);
pub const RDI_INDENT = @as(u32, 64);
pub const MMC_VIEW_OPTIONS_NONE = @as(u32, 0);
pub const MMC_VIEW_OPTIONS_NOLISTVIEWS = @as(u32, 1);
pub const MMC_VIEW_OPTIONS_MULTISELECT = @as(u32, 2);
pub const MMC_VIEW_OPTIONS_OWNERDATALIST = @as(u32, 4);
pub const MMC_VIEW_OPTIONS_FILTERED = @as(u32, 8);
pub const MMC_VIEW_OPTIONS_CREATENEW = @as(u32, 16);
pub const MMC_VIEW_OPTIONS_USEFONTLINKING = @as(u32, 32);
pub const MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST = @as(u32, 64);
pub const MMC_VIEW_OPTIONS_LEXICAL_SORT = @as(u32, 128);
pub const MMC_PSO_NOAPPLYNOW = @as(u32, 1);
pub const MMC_PSO_HASHELP = @as(u32, 2);
pub const MMC_PSO_NEWWIZARDTYPE = @as(u32, 4);
pub const MMC_PSO_NO_PROPTITLE = @as(u32, 8);
pub const RFI_PARTIAL = @as(u32, 1);
pub const RFI_WRAP = @as(u32, 2);
pub const RSI_DESCENDING = @as(u32, 1);
pub const RSI_NOSORTICON = @as(u32, 2);
pub const SDI_STR = @as(u32, 2);
pub const SDI_IMAGE = @as(u32, 4);
pub const SDI_OPENIMAGE = @as(u32, 8);
pub const SDI_STATE = @as(u32, 16);
pub const SDI_PARAM = @as(u32, 32);
pub const SDI_CHILDREN = @as(u32, 64);
pub const SDI_PARENT = @as(u32, 0);
pub const SDI_PREVIOUS = @as(u32, 268435456);
pub const SDI_NEXT = @as(u32, 536870912);
pub const SDI_FIRST = @as(u32, 134217728);
pub const MMC_MULTI_SELECT_COOKIE = @as(i32, -2);
pub const MMC_WINDOW_COOKIE = @as(i32, -3);
pub const SPECIAL_COOKIE_MIN = @as(i32, -10);
pub const SPECIAL_COOKIE_MAX = @as(i32, -1);
pub const MMC_NW_OPTION_NONE = @as(u32, 0);
pub const MMC_NW_OPTION_NOSCOPEPANE = @as(u32, 1);
pub const MMC_NW_OPTION_NOTOOLBARS = @as(u32, 2);
pub const MMC_NW_OPTION_SHORTTITLE = @as(u32, 4);
pub const MMC_NW_OPTION_CUSTOMTITLE = @as(u32, 8);
pub const MMC_NW_OPTION_NOPERSIST = @as(u32, 16);
pub const MMC_NW_OPTION_NOACTIONPANE = @as(u32, 32);
pub const MMC_NODEID_SLOW_RETRIEVAL = @as(u32, 1);
pub const SPECIAL_DOBJ_MIN = @as(i32, -10);
pub const SPECIAL_DOBJ_MAX = @as(u32, 0);
pub const AUTO_WIDTH = @as(i32, -1);
pub const HIDE_COLUMN = @as(i32, -4);
pub const ILSIF_LEAVE_LARGE_ICON = @as(u32, 1073741824);
pub const ILSIF_LEAVE_SMALL_ICON = @as(u32, 536870912);
pub const HDI_HIDDEN = @as(u32, 1);
pub const RDCI_ScopeItem = @as(u32, 2147483648);
pub const RVTI_MISC_OPTIONS_NOLISTVIEWS = @as(u32, 1);
pub const RVTI_LIST_OPTIONS_NONE = @as(u32, 0);
pub const RVTI_LIST_OPTIONS_OWNERDATALIST = @as(u32, 2);
pub const RVTI_LIST_OPTIONS_MULTISELECT = @as(u32, 4);
pub const RVTI_LIST_OPTIONS_FILTERED = @as(u32, 8);
pub const RVTI_LIST_OPTIONS_USEFONTLINKING = @as(u32, 32);
pub const RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST = @as(u32, 64);
pub const RVTI_LIST_OPTIONS_LEXICAL_SORT = @as(u32, 128);
pub const RVTI_LIST_OPTIONS_ALLOWPASTE = @as(u32, 256);
pub const RVTI_HTML_OPTIONS_NONE = @as(u32, 0);
pub const RVTI_HTML_OPTIONS_NOLISTVIEW = @as(u32, 1);
pub const RVTI_OCX_OPTIONS_NONE = @as(u32, 0);
pub const RVTI_OCX_OPTIONS_NOLISTVIEW = @as(u32, 1);
pub const RVTI_OCX_OPTIONS_CACHE_OCX = @as(u32, 2);
pub const MMC_DEFAULT_OPERATION_COPY = @as(u32, 1);
pub const MMC_ITEM_OVERLAY_STATE_MASK = @as(u32, 3840);
pub const MMC_ITEM_OVERLAY_STATE_SHIFT = @as(u32, 8);
pub const MMC_ITEM_STATE_MASK = @as(u32, 255);

//--------------------------------------------------------------------------------
// Section: Types (127)
//--------------------------------------------------------------------------------
const CLSID_Application_Value = @import("../zig.zig").Guid.initString("49b2791a-b1ae-4c90-9b8e-e860ba07f889");
pub const CLSID_Application = &CLSID_Application_Value;

const CLSID_AppEventsDHTMLConnector_Value = @import("../zig.zig").Guid.initString("ade6444b-c91f-4e37-92a4-5bb430a33340");
pub const CLSID_AppEventsDHTMLConnector = &CLSID_AppEventsDHTMLConnector_Value;

pub const MMC_PROPERTY_ACTION = enum(i32) {
    DELETING = 1,
    CHANGING = 2,
    INITIALIZED = 3,
};
pub const MMC_PROPACT_DELETING = MMC_PROPERTY_ACTION.DELETING;
pub const MMC_PROPACT_CHANGING = MMC_PROPERTY_ACTION.CHANGING;
pub const MMC_PROPACT_INITIALIZED = MMC_PROPERTY_ACTION.INITIALIZED;

pub const MMC_SNAPIN_PROPERTY = extern struct {
    pszPropName: ?[*:0]const u16,
    varValue: VARIANT,
    eAction: MMC_PROPERTY_ACTION,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinProperties_Value = @import("../zig.zig").Guid.initString("f7889da9-4a02-4837-bf89-1a6f2a021010");
pub const IID_ISnapinProperties = &IID_ISnapinProperties_Value;
pub const ISnapinProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const ISnapinProperties,
            pProperties: ?*Properties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPropertyNames: fn(
            self: *const ISnapinProperties,
            pCallback: ?*ISnapinPropertiesCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PropertiesChanged: fn(
            self: *const ISnapinProperties,
            cProperties: i32,
            pProperties: [*]MMC_SNAPIN_PROPERTY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinProperties_Initialize(self: *const T, pProperties: ?*Properties) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinProperties.VTable, self.vtable).Initialize(@ptrCast(*const ISnapinProperties, self), pProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinProperties_QueryPropertyNames(self: *const T, pCallback: ?*ISnapinPropertiesCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinProperties.VTable, self.vtable).QueryPropertyNames(@ptrCast(*const ISnapinProperties, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinProperties_PropertiesChanged(self: *const T, cProperties: i32, pProperties: [*]MMC_SNAPIN_PROPERTY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinProperties.VTable, self.vtable).PropertiesChanged(@ptrCast(*const ISnapinProperties, self), cProperties, pProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinPropertiesCallback_Value = @import("../zig.zig").Guid.initString("a50fa2e5-7e61-45eb-a8d4-9a07b3e851a8");
pub const IID_ISnapinPropertiesCallback = &IID_ISnapinPropertiesCallback_Value;
pub const ISnapinPropertiesCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPropertyName: fn(
            self: *const ISnapinPropertiesCallback,
            pszPropName: ?[*:0]const u16,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinPropertiesCallback_AddPropertyName(self: *const T, pszPropName: ?[*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinPropertiesCallback.VTable, self.vtable).AddPropertyName(@ptrCast(*const ISnapinPropertiesCallback, self), pszPropName, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _DocumentMode = enum(i32) {
    Author = 0,
    User = 1,
    User_MDI = 2,
    User_SDI = 3,
};
pub const DocumentMode_Author = _DocumentMode.Author;
pub const DocumentMode_User = _DocumentMode.User;
pub const DocumentMode_User_MDI = _DocumentMode.User_MDI;
pub const DocumentMode_User_SDI = _DocumentMode.User_SDI;

pub const _ListViewMode = enum(i32) {
    Small_Icons = 0,
    Large_Icons = 1,
    List = 2,
    Detail = 3,
    Filtered = 4,
};
pub const ListMode_Small_Icons = _ListViewMode.Small_Icons;
pub const ListMode_Large_Icons = _ListViewMode.Large_Icons;
pub const ListMode_List = _ListViewMode.List;
pub const ListMode_Detail = _ListViewMode.Detail;
pub const ListMode_Filtered = _ListViewMode.Filtered;

pub const _ViewOptions = enum(i32) {
    Default = 0,
    ScopeTreeHidden = 1,
    NoToolBars = 2,
    NotPersistable = 4,
    ActionPaneHidden = 8,
};
pub const ViewOption_Default = _ViewOptions.Default;
pub const ViewOption_ScopeTreeHidden = _ViewOptions.ScopeTreeHidden;
pub const ViewOption_NoToolBars = _ViewOptions.NoToolBars;
pub const ViewOption_NotPersistable = _ViewOptions.NotPersistable;
pub const ViewOption_ActionPaneHidden = _ViewOptions.ActionPaneHidden;

pub const _ExportListOptions = enum(i32) {
    Default = 0,
    Unicode = 1,
    TabDelimited = 2,
    SelectedItemsOnly = 4,
};
pub const ExportListOptions_Default = _ExportListOptions.Default;
pub const ExportListOptions_Unicode = _ExportListOptions.Unicode;
pub const ExportListOptions_TabDelimited = _ExportListOptions.TabDelimited;
pub const ExportListOptions_SelectedItemsOnly = _ExportListOptions.SelectedItemsOnly;

const IID__Application_Value = @import("../zig.zig").Guid.initString("a3afb9cc-b653-4741-86ab-f0470ec1384c");
pub const IID__Application = &IID__Application_Value;
pub const _Application = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Help: fn(
            self: *const _Application,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Quit: fn(
            self: *const _Application,
        ) callconv(@import("std").os.windows.WINAPI) void,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Document: fn(
            self: *const _Application,
            Document: ?*?*Document,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const _Application,
            Filename: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Frame: fn(
            self: *const _Application,
            Frame: ?*?*Frame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: fn(
            self: *const _Application,
            Visible: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const _Application,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hide: fn(
            self: *const _Application,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserControl: fn(
            self: *const _Application,
            UserControl: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserControl: fn(
            self: *const _Application,
            UserControl: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VersionMajor: fn(
            self: *const _Application,
            VersionMajor: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VersionMinor: fn(
            self: *const _Application,
            VersionMinor: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Help(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const _Application.VTable, self.vtable).Help(@ptrCast(*const _Application, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Quit(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const _Application.VTable, self.vtable).Quit(@ptrCast(*const _Application, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_Document(self: *const T, _param_Document: ?*?*Document) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_Document(@ptrCast(*const _Application, self), _param_Document);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Load(self: *const T, Filename: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).Load(@ptrCast(*const _Application, self), Filename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_Frame(self: *const T, _param_Frame: ?*?*Frame) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_Frame(@ptrCast(*const _Application, self), _param_Frame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_Visible(self: *const T, Visible: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_Visible(@ptrCast(*const _Application, self), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Show(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).Show(@ptrCast(*const _Application, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Hide(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).Hide(@ptrCast(*const _Application, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_UserControl(self: *const T, UserControl: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_UserControl(@ptrCast(*const _Application, self), UserControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_put_UserControl(self: *const T, UserControl: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).put_UserControl(@ptrCast(*const _Application, self), UserControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_VersionMajor(self: *const T, VersionMajor: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_VersionMajor(@ptrCast(*const _Application, self), VersionMajor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_VersionMinor(self: *const T, VersionMinor: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_VersionMinor(@ptrCast(*const _Application, self), VersionMinor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID__AppEvents_Value = @import("../zig.zig").Guid.initString("de46cbdd-53f5-4635-af54-4fe71e923d3f");
pub const IID__AppEvents = &IID__AppEvents_Value;
pub const _AppEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OnQuit: fn(
            self: *const _AppEvents,
            Application: ?*_Application,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDocumentOpen: fn(
            self: *const _AppEvents,
            Document: ?*Document,
            New: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDocumentClose: fn(
            self: *const _AppEvents,
            Document: ?*Document,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSnapInAdded: fn(
            self: *const _AppEvents,
            Document: ?*Document,
            SnapIn: ?*SnapIn,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSnapInRemoved: fn(
            self: *const _AppEvents,
            Document: ?*Document,
            SnapIn: ?*SnapIn,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnNewView: fn(
            self: *const _AppEvents,
            View: ?*View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnViewClose: fn(
            self: *const _AppEvents,
            View: ?*View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnViewChange: fn(
            self: *const _AppEvents,
            View: ?*View,
            NewOwnerNode: ?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelectionChange: fn(
            self: *const _AppEvents,
            View: ?*View,
            NewNodes: ?*Nodes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnContextMenuExecuted: fn(
            self: *const _AppEvents,
            MenuItem: ?*MenuItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnToolbarButtonClicked: fn(
            self: *const _AppEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnListUpdated: fn(
            self: *const _AppEvents,
            View: ?*View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnQuit(self: *const T, Application: ?*_Application) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnQuit(@ptrCast(*const _AppEvents, self), Application);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnDocumentOpen(self: *const T, _param_Document: ?*Document, New: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnDocumentOpen(@ptrCast(*const _AppEvents, self), _param_Document, New);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnDocumentClose(self: *const T, _param_Document: ?*Document) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnDocumentClose(@ptrCast(*const _AppEvents, self), _param_Document);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnSnapInAdded(self: *const T, _param_Document: ?*Document, _param_SnapIn: ?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnSnapInAdded(@ptrCast(*const _AppEvents, self), _param_Document, _param_SnapIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnSnapInRemoved(self: *const T, _param_Document: ?*Document, _param_SnapIn: ?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnSnapInRemoved(@ptrCast(*const _AppEvents, self), _param_Document, _param_SnapIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnNewView(self: *const T, _param_View: ?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnNewView(@ptrCast(*const _AppEvents, self), _param_View);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnViewClose(self: *const T, _param_View: ?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnViewClose(@ptrCast(*const _AppEvents, self), _param_View);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnViewChange(self: *const T, _param_View: ?*View, NewOwnerNode: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnViewChange(@ptrCast(*const _AppEvents, self), _param_View, NewOwnerNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnSelectionChange(self: *const T, _param_View: ?*View, NewNodes: ?*Nodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnSelectionChange(@ptrCast(*const _AppEvents, self), _param_View, NewNodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnContextMenuExecuted(self: *const T, _param_MenuItem: ?*MenuItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnContextMenuExecuted(@ptrCast(*const _AppEvents, self), _param_MenuItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnToolbarButtonClicked(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnToolbarButtonClicked(@ptrCast(*const _AppEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnListUpdated(self: *const T, _param_View: ?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnListUpdated(@ptrCast(*const _AppEvents, self), _param_View);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AppEvents_Value = @import("../zig.zig").Guid.initString("fc7a4252-78ac-4532-8c5a-563cfe138863");
pub const IID_AppEvents = &IID_AppEvents_Value;
pub const AppEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID__EventConnector_Value = @import("../zig.zig").Guid.initString("c0bccd30-de44-4528-8403-a05a6a1cc8ea");
pub const IID__EventConnector = &IID__EventConnector_Value;
pub const _EventConnector = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ConnectTo: fn(
            self: *const _EventConnector,
            Application: ?*_Application,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const _EventConnector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _EventConnector_ConnectTo(self: *const T, Application: ?*_Application) callconv(.Inline) HRESULT {
            return @ptrCast(*const _EventConnector.VTable, self.vtable).ConnectTo(@ptrCast(*const _EventConnector, self), Application);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _EventConnector_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const _EventConnector.VTable, self.vtable).Disconnect(@ptrCast(*const _EventConnector, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Frame_Value = @import("../zig.zig").Guid.initString("e5e2d970-5bb3-4306-8804-b0968a31c8e6");
pub const IID_Frame = &IID_Frame_Value;
pub const Frame = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Maximize: fn(
            self: *const Frame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Minimize: fn(
            self: *const Frame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Restore: fn(
            self: *const Frame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: fn(
            self: *const Frame,
            Top: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: fn(
            self: *const Frame,
            top: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bottom: fn(
            self: *const Frame,
            Bottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bottom: fn(
            self: *const Frame,
            bottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: fn(
            self: *const Frame,
            Left: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: fn(
            self: *const Frame,
            left: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Right: fn(
            self: *const Frame,
            Right: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Right: fn(
            self: *const Frame,
            right: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_Maximize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).Maximize(@ptrCast(*const Frame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_Minimize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).Minimize(@ptrCast(*const Frame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_Restore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).Restore(@ptrCast(*const Frame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_get_Top(self: *const T, Top: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).get_Top(@ptrCast(*const Frame, self), Top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_put_Top(self: *const T, top: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).put_Top(@ptrCast(*const Frame, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_get_Bottom(self: *const T, Bottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).get_Bottom(@ptrCast(*const Frame, self), Bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_put_Bottom(self: *const T, bottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).put_Bottom(@ptrCast(*const Frame, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_get_Left(self: *const T, Left: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).get_Left(@ptrCast(*const Frame, self), Left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_put_Left(self: *const T, left: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).put_Left(@ptrCast(*const Frame, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_get_Right(self: *const T, Right: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).get_Right(@ptrCast(*const Frame, self), Right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_put_Right(self: *const T, right: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).put_Right(@ptrCast(*const Frame, self), right);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Node_Value = @import("../zig.zig").Guid.initString("f81ed800-7839-4447-945d-8e15da59ca55");
pub const IID_Node = &IID_Node_Value;
pub const Node = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const Node,
            Name: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Property: fn(
            self: *const Node,
            PropertyName: ?BSTR,
            PropertyValue: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bookmark: fn(
            self: *const Node,
            Bookmark: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsScopeNode: fn(
            self: *const Node,
            IsScopeNode: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Nodetype: fn(
            self: *const Node,
            Nodetype: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).get_Name(@ptrCast(*const Node, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_get_Property(self: *const T, PropertyName: ?BSTR, PropertyValue: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).get_Property(@ptrCast(*const Node, self), PropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_get_Bookmark(self: *const T, Bookmark: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).get_Bookmark(@ptrCast(*const Node, self), Bookmark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_IsScopeNode(self: *const T, IsScopeNode: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).IsScopeNode(@ptrCast(*const Node, self), IsScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_get_Nodetype(self: *const T, Nodetype: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).get_Nodetype(@ptrCast(*const Node, self), Nodetype);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ScopeNamespace_Value = @import("../zig.zig").Guid.initString("ebbb48dc-1a3b-4d86-b786-c21b28389012");
pub const IID_ScopeNamespace = &IID_ScopeNamespace_Value;
pub const ScopeNamespace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetParent: fn(
            self: *const ScopeNamespace,
            Node: ?*Node,
            Parent: ?*?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChild: fn(
            self: *const ScopeNamespace,
            Node: ?*Node,
            Child: ?*?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const ScopeNamespace,
            Node: ?*Node,
            Next: ?*?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRoot: fn(
            self: *const ScopeNamespace,
            Root: ?*?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Expand: fn(
            self: *const ScopeNamespace,
            Node: ?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_GetParent(self: *const T, _param_Node: ?*Node, Parent: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).GetParent(@ptrCast(*const ScopeNamespace, self), _param_Node, Parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_GetChild(self: *const T, _param_Node: ?*Node, Child: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).GetChild(@ptrCast(*const ScopeNamespace, self), _param_Node, Child);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_GetNext(self: *const T, _param_Node: ?*Node, Next: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).GetNext(@ptrCast(*const ScopeNamespace, self), _param_Node, Next);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_GetRoot(self: *const T, Root: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).GetRoot(@ptrCast(*const ScopeNamespace, self), Root);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_Expand(self: *const T, _param_Node: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).Expand(@ptrCast(*const ScopeNamespace, self), _param_Node);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Document_Value = @import("../zig.zig").Guid.initString("225120d6-1e0f-40a3-93fe-1079e6a8017b");
pub const IID_Document = &IID_Document_Value;
pub const Document = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Save: fn(
            self: *const Document,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAs: fn(
            self: *const Document,
            Filename: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const Document,
            SaveChanges: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Views: fn(
            self: *const Document,
            Views: ?*?*Views,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SnapIns: fn(
            self: *const Document,
            SnapIns: ?*?*SnapIns,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveView: fn(
            self: *const Document,
            View: ?*?*View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const Document,
            Name: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const Document,
            Name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Location: fn(
            self: *const Document,
            Location: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSaved: fn(
            self: *const Document,
            IsSaved: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: fn(
            self: *const Document,
            Mode: ?*_DocumentMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: fn(
            self: *const Document,
            Mode: _DocumentMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootNode: fn(
            self: *const Document,
            Node: ?*?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScopeNamespace: fn(
            self: *const Document,
            ScopeNamespace: ?*?*ScopeNamespace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProperties: fn(
            self: *const Document,
            Properties: ?*?*Properties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const Document,
            Application: ?*?*_Application,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_Save(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).Save(@ptrCast(*const Document, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_SaveAs(self: *const T, Filename: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).SaveAs(@ptrCast(*const Document, self), Filename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_Close(self: *const T, SaveChanges: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).Close(@ptrCast(*const Document, self), SaveChanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Views(self: *const T, _param_Views: ?*?*Views) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Views(@ptrCast(*const Document, self), _param_Views);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_SnapIns(self: *const T, _param_SnapIns: ?*?*SnapIns) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_SnapIns(@ptrCast(*const Document, self), _param_SnapIns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_ActiveView(self: *const T, _param_View: ?*?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_ActiveView(@ptrCast(*const Document, self), _param_View);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Name(@ptrCast(*const Document, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_put_Name(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).put_Name(@ptrCast(*const Document, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Location(self: *const T, Location: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Location(@ptrCast(*const Document, self), Location);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_IsSaved(self: *const T, IsSaved: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_IsSaved(@ptrCast(*const Document, self), IsSaved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Mode(self: *const T, Mode: ?*_DocumentMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Mode(@ptrCast(*const Document, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_put_Mode(self: *const T, Mode: _DocumentMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).put_Mode(@ptrCast(*const Document, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_RootNode(self: *const T, _param_Node: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_RootNode(@ptrCast(*const Document, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_ScopeNamespace(self: *const T, _param_ScopeNamespace: ?*?*ScopeNamespace) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_ScopeNamespace(@ptrCast(*const Document, self), _param_ScopeNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_CreateProperties(self: *const T, _param_Properties: ?*?*Properties) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).CreateProperties(@ptrCast(*const Document, self), _param_Properties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Application(self: *const T, Application: ?*?*_Application) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Application(@ptrCast(*const Document, self), Application);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_SnapIn_Value = @import("../zig.zig").Guid.initString("3be910f6-3459-49c6-a1bb-41e6be9df3ea");
pub const IID_SnapIn = &IID_SnapIn_Value;
pub const SnapIn = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const SnapIn,
            Name: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Vendor: fn(
            self: *const SnapIn,
            Vendor: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const SnapIn,
            Version: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Extensions: fn(
            self: *const SnapIn,
            Extensions: ?*?*Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SnapinCLSID: fn(
            self: *const SnapIn,
            SnapinCLSID: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Properties: fn(
            self: *const SnapIn,
            Properties: ?*?*Properties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableAllExtensions: fn(
            self: *const SnapIn,
            Enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Name(@ptrCast(*const SnapIn, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Vendor(self: *const T, Vendor: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Vendor(@ptrCast(*const SnapIn, self), Vendor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Version(self: *const T, Version: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Version(@ptrCast(*const SnapIn, self), Version);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Extensions(self: *const T, _param_Extensions: ?*?*Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Extensions(@ptrCast(*const SnapIn, self), _param_Extensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_SnapinCLSID(self: *const T, SnapinCLSID: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_SnapinCLSID(@ptrCast(*const SnapIn, self), SnapinCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Properties(self: *const T, _param_Properties: ?*?*Properties) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Properties(@ptrCast(*const SnapIn, self), _param_Properties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_EnableAllExtensions(self: *const T, Enable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).EnableAllExtensions(@ptrCast(*const SnapIn, self), Enable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_SnapIns_Value = @import("../zig.zig").Guid.initString("2ef3de1d-b12a-49d1-92c5-0b00798768f1");
pub const IID_SnapIns = &IID_SnapIns_Value;
pub const SnapIns = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const SnapIns,
            retval: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const SnapIns,
            Index: i32,
            SnapIn: ?*?*SnapIn,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const SnapIns,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const SnapIns,
            SnapinNameOrCLSID: ?BSTR,
            ParentSnapin: VARIANT,
            Properties: VARIANT,
            SnapIn: ?*?*SnapIn,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const SnapIns,
            SnapIn: ?*SnapIn,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).get__NewEnum(@ptrCast(*const SnapIns, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_Item(self: *const T, Index: i32, _param_SnapIn: ?*?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).Item(@ptrCast(*const SnapIns, self), Index, _param_SnapIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).get_Count(@ptrCast(*const SnapIns, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_Add(self: *const T, SnapinNameOrCLSID: ?BSTR, ParentSnapin: VARIANT, _param_Properties: VARIANT, _param_SnapIn: ?*?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).Add(@ptrCast(*const SnapIns, self), SnapinNameOrCLSID, ParentSnapin, _param_Properties, _param_SnapIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_Remove(self: *const T, _param_SnapIn: ?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).Remove(@ptrCast(*const SnapIns, self), _param_SnapIn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Extension_Value = @import("../zig.zig").Guid.initString("ad4d6ca6-912f-409b-a26e-7fd234aef542");
pub const IID_Extension = &IID_Extension_Value;
pub const Extension = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const Extension,
            Name: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Vendor: fn(
            self: *const Extension,
            Vendor: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const Extension,
            Version: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Extensions: fn(
            self: *const Extension,
            Extensions: ?*?*Extensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SnapinCLSID: fn(
            self: *const Extension,
            SnapinCLSID: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableAllExtensions: fn(
            self: *const Extension,
            Enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const Extension,
            Enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_Name(@ptrCast(*const Extension, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_Vendor(self: *const T, Vendor: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_Vendor(@ptrCast(*const Extension, self), Vendor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_Version(self: *const T, Version: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_Version(@ptrCast(*const Extension, self), Version);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_Extensions(self: *const T, _param_Extensions: ?*?*Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_Extensions(@ptrCast(*const Extension, self), _param_Extensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_SnapinCLSID(self: *const T, SnapinCLSID: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_SnapinCLSID(@ptrCast(*const Extension, self), SnapinCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_EnableAllExtensions(self: *const T, Enable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).EnableAllExtensions(@ptrCast(*const Extension, self), Enable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_Enable(self: *const T, Enable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).Enable(@ptrCast(*const Extension, self), Enable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Extensions_Value = @import("../zig.zig").Guid.initString("82dbea43-8ca4-44bc-a2ca-d18741059ec8");
pub const IID_Extensions = &IID_Extensions_Value;
pub const Extensions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const Extensions,
            retval: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const Extensions,
            Index: i32,
            Extension: ?*?*Extension,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const Extensions,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extensions_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extensions.VTable, self.vtable).get__NewEnum(@ptrCast(*const Extensions, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extensions_Item(self: *const T, Index: i32, _param_Extension: ?*?*Extension) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extensions.VTable, self.vtable).Item(@ptrCast(*const Extensions, self), Index, _param_Extension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extensions_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extensions.VTable, self.vtable).get_Count(@ptrCast(*const Extensions, self), Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Columns_Value = @import("../zig.zig").Guid.initString("383d4d97-fc44-478b-b139-6323dc48611c");
pub const IID_Columns = &IID_Columns_Value;
pub const Columns = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: fn(
            self: *const Columns,
            Index: i32,
            Column: ?*?*Column,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const Columns,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const Columns,
            retval: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Columns_Item(self: *const T, Index: i32, _param_Column: ?*?*Column) callconv(.Inline) HRESULT {
            return @ptrCast(*const Columns.VTable, self.vtable).Item(@ptrCast(*const Columns, self), Index, _param_Column);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Columns_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Columns.VTable, self.vtable).get_Count(@ptrCast(*const Columns, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Columns_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Columns.VTable, self.vtable).get__NewEnum(@ptrCast(*const Columns, self), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _ColumnSortOrder = enum(i32) {
    Ascending = 0,
    Descending = 1,
};
pub const SortOrder_Ascending = _ColumnSortOrder.Ascending;
pub const SortOrder_Descending = _ColumnSortOrder.Descending;

const IID_Column_Value = @import("../zig.zig").Guid.initString("fd1c5f63-2b16-4d06-9ab3-f45350b940ab");
pub const IID_Column = &IID_Column_Value;
pub const Column = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Name: fn(
            self: *const Column,
            Name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: fn(
            self: *const Column,
            Width: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: fn(
            self: *const Column,
            Width: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayPosition: fn(
            self: *const Column,
            DisplayPosition: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplayPosition: fn(
            self: *const Column,
            Index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hidden: fn(
            self: *const Column,
            Hidden: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Hidden: fn(
            self: *const Column,
            Hidden: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAsSortColumn: fn(
            self: *const Column,
            SortOrder: _ColumnSortOrder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSortColumn: fn(
            self: *const Column,
            IsSortColumn: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_Name(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).Name(@ptrCast(*const Column, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_get_Width(self: *const T, Width: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).get_Width(@ptrCast(*const Column, self), Width);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_put_Width(self: *const T, Width: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).put_Width(@ptrCast(*const Column, self), Width);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_get_DisplayPosition(self: *const T, DisplayPosition: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).get_DisplayPosition(@ptrCast(*const Column, self), DisplayPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_put_DisplayPosition(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).put_DisplayPosition(@ptrCast(*const Column, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_get_Hidden(self: *const T, Hidden: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).get_Hidden(@ptrCast(*const Column, self), Hidden);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_put_Hidden(self: *const T, Hidden: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).put_Hidden(@ptrCast(*const Column, self), Hidden);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_SetAsSortColumn(self: *const T, SortOrder: _ColumnSortOrder) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).SetAsSortColumn(@ptrCast(*const Column, self), SortOrder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_IsSortColumn(self: *const T, IsSortColumn: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).IsSortColumn(@ptrCast(*const Column, self), IsSortColumn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Views_Value = @import("../zig.zig").Guid.initString("d6b8c29d-a1ff-4d72-aab0-e381e9b9338d");
pub const IID_Views = &IID_Views_Value;
pub const Views = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: fn(
            self: *const Views,
            Index: i32,
            View: ?*?*View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const Views,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const Views,
            Node: ?*Node,
            viewOptions: _ViewOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const Views,
            retval: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Views_Item(self: *const T, Index: i32, _param_View: ?*?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const Views.VTable, self.vtable).Item(@ptrCast(*const Views, self), Index, _param_View);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Views_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Views.VTable, self.vtable).get_Count(@ptrCast(*const Views, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Views_Add(self: *const T, _param_Node: ?*Node, viewOptions: _ViewOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const Views.VTable, self.vtable).Add(@ptrCast(*const Views, self), _param_Node, viewOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Views_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Views.VTable, self.vtable).get__NewEnum(@ptrCast(*const Views, self), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_View_Value = @import("../zig.zig").Guid.initString("6efc2da2-b38c-457e-9abb-ed2d189b8c38");
pub const IID_View = &IID_View_Value;
pub const View = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveScopeNode: fn(
            self: *const View,
            Node: ?*?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ActiveScopeNode: fn(
            self: *const View,
            Node: ?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Selection: fn(
            self: *const View,
            Nodes: ?*?*Nodes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ListItems: fn(
            self: *const View,
            Nodes: ?*?*Nodes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SnapinScopeObject: fn(
            self: *const View,
            ScopeNode: VARIANT,
            ScopeNodeObject: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SnapinSelectionObject: fn(
            self: *const View,
            SelectionObject: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Is: fn(
            self: *const View,
            View: ?*View,
            TheSame: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Document: fn(
            self: *const View,
            Document: ?*?*Document,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAll: fn(
            self: *const View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const View,
            Node: ?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deselect: fn(
            self: *const View,
            Node: ?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSelected: fn(
            self: *const View,
            Node: ?*Node,
            IsSelected: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayScopeNodePropertySheet: fn(
            self: *const View,
            ScopeNode: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplaySelectionPropertySheet: fn(
            self: *const View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyScopeNode: fn(
            self: *const View,
            ScopeNode: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopySelection: fn(
            self: *const View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteScopeNode: fn(
            self: *const View,
            ScopeNode: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSelection: fn(
            self: *const View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenameScopeNode: fn(
            self: *const View,
            NewName: ?BSTR,
            ScopeNode: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenameSelectedItem: fn(
            self: *const View,
            NewName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScopeNodeContextMenu: fn(
            self: *const View,
            ScopeNode: VARIANT,
            ContextMenu: ?*?*ContextMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectionContextMenu: fn(
            self: *const View,
            ContextMenu: ?*?*ContextMenu,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RefreshScopeNode: fn(
            self: *const View,
            ScopeNode: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RefreshSelection: fn(
            self: *const View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteSelectionMenuItem: fn(
            self: *const View,
            MenuItemPath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteScopeNodeMenuItem: fn(
            self: *const View,
            MenuItemPath: ?BSTR,
            ScopeNode: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteShellCommand: fn(
            self: *const View,
            Command: ?BSTR,
            Directory: ?BSTR,
            Parameters: ?BSTR,
            WindowState: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Frame: fn(
            self: *const View,
            Frame: ?*?*Frame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScopeTreeVisible: fn(
            self: *const View,
            Visible: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ScopeTreeVisible: fn(
            self: *const View,
            Visible: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Back: fn(
            self: *const View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Forward: fn(
            self: *const View,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StatusBarText: fn(
            self: *const View,
            StatusBarText: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Memento: fn(
            self: *const View,
            Memento: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ViewMemento: fn(
            self: *const View,
            Memento: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Columns: fn(
            self: *const View,
            Columns: ?*?*Columns,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CellContents: fn(
            self: *const View,
            Node: ?*Node,
            Column: i32,
            CellContents: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExportList: fn(
            self: *const View,
            File: ?BSTR,
            exportoptions: _ExportListOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ListViewMode: fn(
            self: *const View,
            Mode: ?*_ListViewMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ListViewMode: fn(
            self: *const View,
            mode: _ListViewMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ControlObject: fn(
            self: *const View,
            Control: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ActiveScopeNode(self: *const T, _param_Node: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ActiveScopeNode(@ptrCast(*const View, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_put_ActiveScopeNode(self: *const T, _param_Node: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).put_ActiveScopeNode(@ptrCast(*const View, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Selection(self: *const T, _param_Nodes: ?*?*Nodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Selection(@ptrCast(*const View, self), _param_Nodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ListItems(self: *const T, _param_Nodes: ?*?*Nodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ListItems(@ptrCast(*const View, self), _param_Nodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_SnapinScopeObject(self: *const T, ScopeNode: VARIANT, ScopeNodeObject: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).SnapinScopeObject(@ptrCast(*const View, self), ScopeNode, ScopeNodeObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_SnapinSelectionObject(self: *const T, SelectionObject: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).SnapinSelectionObject(@ptrCast(*const View, self), SelectionObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Is(self: *const T, _param_View: ?*View, TheSame: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Is(@ptrCast(*const View, self), _param_View, TheSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Document(self: *const T, _param_Document: ?*?*Document) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Document(@ptrCast(*const View, self), _param_Document);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_SelectAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).SelectAll(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Select(self: *const T, _param_Node: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Select(@ptrCast(*const View, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Deselect(self: *const T, _param_Node: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Deselect(@ptrCast(*const View, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_IsSelected(self: *const T, _param_Node: ?*Node, IsSelected: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).IsSelected(@ptrCast(*const View, self), _param_Node, IsSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_DisplayScopeNodePropertySheet(self: *const T, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).DisplayScopeNodePropertySheet(@ptrCast(*const View, self), ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_DisplaySelectionPropertySheet(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).DisplaySelectionPropertySheet(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_CopyScopeNode(self: *const T, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).CopyScopeNode(@ptrCast(*const View, self), ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_CopySelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).CopySelection(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_DeleteScopeNode(self: *const T, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).DeleteScopeNode(@ptrCast(*const View, self), ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_DeleteSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).DeleteSelection(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_RenameScopeNode(self: *const T, NewName: ?BSTR, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).RenameScopeNode(@ptrCast(*const View, self), NewName, ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_RenameSelectedItem(self: *const T, NewName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).RenameSelectedItem(@ptrCast(*const View, self), NewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ScopeNodeContextMenu(self: *const T, ScopeNode: VARIANT, _param_ContextMenu: ?*?*ContextMenu) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ScopeNodeContextMenu(@ptrCast(*const View, self), ScopeNode, _param_ContextMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_SelectionContextMenu(self: *const T, _param_ContextMenu: ?*?*ContextMenu) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_SelectionContextMenu(@ptrCast(*const View, self), _param_ContextMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_RefreshScopeNode(self: *const T, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).RefreshScopeNode(@ptrCast(*const View, self), ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_RefreshSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).RefreshSelection(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ExecuteSelectionMenuItem(self: *const T, MenuItemPath: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ExecuteSelectionMenuItem(@ptrCast(*const View, self), MenuItemPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ExecuteScopeNodeMenuItem(self: *const T, MenuItemPath: ?BSTR, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ExecuteScopeNodeMenuItem(@ptrCast(*const View, self), MenuItemPath, ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ExecuteShellCommand(self: *const T, Command: ?BSTR, Directory: ?BSTR, Parameters: ?BSTR, WindowState: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ExecuteShellCommand(@ptrCast(*const View, self), Command, Directory, Parameters, WindowState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Frame(self: *const T, _param_Frame: ?*?*Frame) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Frame(@ptrCast(*const View, self), _param_Frame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Close(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ScopeTreeVisible(self: *const T, Visible: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ScopeTreeVisible(@ptrCast(*const View, self), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_put_ScopeTreeVisible(self: *const T, Visible: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).put_ScopeTreeVisible(@ptrCast(*const View, self), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Back(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Back(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Forward(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Forward(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_put_StatusBarText(self: *const T, StatusBarText: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).put_StatusBarText(@ptrCast(*const View, self), StatusBarText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Memento(self: *const T, Memento: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Memento(@ptrCast(*const View, self), Memento);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ViewMemento(self: *const T, Memento: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ViewMemento(@ptrCast(*const View, self), Memento);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Columns(self: *const T, _param_Columns: ?*?*Columns) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Columns(@ptrCast(*const View, self), _param_Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_CellContents(self: *const T, _param_Node: ?*Node, _param_Column: i32, CellContents: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_CellContents(@ptrCast(*const View, self), _param_Node, _param_Column, CellContents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ExportList(self: *const T, File: ?BSTR, exportoptions: _ExportListOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ExportList(@ptrCast(*const View, self), File, exportoptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ListViewMode(self: *const T, Mode: ?*_ListViewMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ListViewMode(@ptrCast(*const View, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_put_ListViewMode(self: *const T, mode: _ListViewMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).put_ListViewMode(@ptrCast(*const View, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ControlObject(self: *const T, Control: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ControlObject(@ptrCast(*const View, self), Control);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Nodes_Value = @import("../zig.zig").Guid.initString("313b01df-b22f-4d42-b1b8-483cdcf51d35");
pub const IID_Nodes = &IID_Nodes_Value;
pub const Nodes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const Nodes,
            retval: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const Nodes,
            Index: i32,
            Node: ?*?*Node,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const Nodes,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Nodes_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Nodes.VTable, self.vtable).get__NewEnum(@ptrCast(*const Nodes, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Nodes_Item(self: *const T, Index: i32, _param_Node: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const Nodes.VTable, self.vtable).Item(@ptrCast(*const Nodes, self), Index, _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Nodes_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Nodes.VTable, self.vtable).get_Count(@ptrCast(*const Nodes, self), Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ContextMenu_Value = @import("../zig.zig").Guid.initString("dab39ce0-25e6-4e07-8362-ba9c95706545");
pub const IID_ContextMenu = &IID_ContextMenu_Value;
pub const ContextMenu = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ContextMenu,
            retval: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ContextMenu,
            IndexOrPath: VARIANT,
            MenuItem: ?*?*MenuItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ContextMenu,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ContextMenu_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ContextMenu.VTable, self.vtable).get__NewEnum(@ptrCast(*const ContextMenu, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ContextMenu_get_Item(self: *const T, IndexOrPath: VARIANT, _param_MenuItem: ?*?*MenuItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ContextMenu.VTable, self.vtable).get_Item(@ptrCast(*const ContextMenu, self), IndexOrPath, _param_MenuItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ContextMenu_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ContextMenu.VTable, self.vtable).get_Count(@ptrCast(*const ContextMenu, self), Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_MenuItem_Value = @import("../zig.zig").Guid.initString("0178fad1-b361-4b27-96ad-67c57ebf2e1d");
pub const IID_MenuItem = &IID_MenuItem_Value;
pub const MenuItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: fn(
            self: *const MenuItem,
            DisplayName: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageIndependentName: fn(
            self: *const MenuItem,
            LanguageIndependentName: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const MenuItem,
            Path: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageIndependentPath: fn(
            self: *const MenuItem,
            LanguageIndependentPath: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const MenuItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: fn(
            self: *const MenuItem,
            Enabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_DisplayName(self: *const T, DisplayName: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_DisplayName(@ptrCast(*const MenuItem, self), DisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_LanguageIndependentName(self: *const T, LanguageIndependentName: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_LanguageIndependentName(@ptrCast(*const MenuItem, self), LanguageIndependentName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_Path(self: *const T, Path: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_Path(@ptrCast(*const MenuItem, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_LanguageIndependentPath(self: *const T, LanguageIndependentPath: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_LanguageIndependentPath(@ptrCast(*const MenuItem, self), LanguageIndependentPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_Execute(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).Execute(@ptrCast(*const MenuItem, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_Enabled(self: *const T, Enabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_Enabled(@ptrCast(*const MenuItem, self), Enabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Properties_Value = @import("../zig.zig").Guid.initString("2886abc2-a425-42b2-91c6-e25c0e04581c");
pub const IID_Properties = &IID_Properties_Value;
pub const Properties = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const Properties,
            retval: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const Properties,
            Name: ?BSTR,
            Property: ?*?*Property,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const Properties,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const Properties,
            Name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Properties_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Properties.VTable, self.vtable).get__NewEnum(@ptrCast(*const Properties, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Properties_Item(self: *const T, Name: ?BSTR, _param_Property: ?*?*Property) callconv(.Inline) HRESULT {
            return @ptrCast(*const Properties.VTable, self.vtable).Item(@ptrCast(*const Properties, self), Name, _param_Property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Properties_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Properties.VTable, self.vtable).get_Count(@ptrCast(*const Properties, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Properties_Remove(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Properties.VTable, self.vtable).Remove(@ptrCast(*const Properties, self), Name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Property_Value = @import("../zig.zig").Guid.initString("4600c3a5-e301-41d8-b6d0-ef2e4212e0ca");
pub const IID_Property = &IID_Property_Value;
pub const Property = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const Property,
            Value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: fn(
            self: *const Property,
            Value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const Property,
            Name: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Property_get_Value(self: *const T, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const Property.VTable, self.vtable).get_Value(@ptrCast(*const Property, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Property_put_Value(self: *const T, Value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const Property.VTable, self.vtable).put_Value(@ptrCast(*const Property, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Property_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Property.VTable, self.vtable).get_Name(@ptrCast(*const Property, self), Name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MMCVersionInfo_Value = @import("../zig.zig").Guid.initString("d6fedb1d-cf21-4bd9-af3b-c5468e9c6684");
pub const CLSID_MMCVersionInfo = &CLSID_MMCVersionInfo_Value;

const CLSID_ConsolePower_Value = @import("../zig.zig").Guid.initString("f0285374-dff1-11d3-b433-00c04f8ecd78");
pub const CLSID_ConsolePower = &CLSID_ConsolePower_Value;

pub const MMC_RESULT_VIEW_STYLE = enum(i32) {
    SINGLESEL = 1,
    SHOWSELALWAYS = 2,
    NOSORTHEADER = 4,
    ENSUREFOCUSVISIBLE = 8,
};
pub const MMC_SINGLESEL = MMC_RESULT_VIEW_STYLE.SINGLESEL;
pub const MMC_SHOWSELALWAYS = MMC_RESULT_VIEW_STYLE.SHOWSELALWAYS;
pub const MMC_NOSORTHEADER = MMC_RESULT_VIEW_STYLE.NOSORTHEADER;
pub const MMC_ENSUREFOCUSVISIBLE = MMC_RESULT_VIEW_STYLE.ENSUREFOCUSVISIBLE;

pub const MMC_CONTROL_TYPE = enum(i32) {
    TOOLBAR = 0,
    MENUBUTTON = 1,
    COMBOBOXBAR = 2,
};
pub const TOOLBAR = MMC_CONTROL_TYPE.TOOLBAR;
pub const MENUBUTTON = MMC_CONTROL_TYPE.MENUBUTTON;
pub const COMBOBOXBAR = MMC_CONTROL_TYPE.COMBOBOXBAR;

pub const MMC_CONSOLE_VERB = enum(i32) {
    NONE = 0,
    OPEN = 32768,
    COPY = 32769,
    PASTE = 32770,
    DELETE = 32771,
    PROPERTIES = 32772,
    RENAME = 32773,
    REFRESH = 32774,
    PRINT = 32775,
    CUT = 32776,
    MAX = 32777,
    // FIRST = 32768, this enum value conflicts with OPEN
    // LAST = 32776, this enum value conflicts with CUT
};
pub const MMC_VERB_NONE = MMC_CONSOLE_VERB.NONE;
pub const MMC_VERB_OPEN = MMC_CONSOLE_VERB.OPEN;
pub const MMC_VERB_COPY = MMC_CONSOLE_VERB.COPY;
pub const MMC_VERB_PASTE = MMC_CONSOLE_VERB.PASTE;
pub const MMC_VERB_DELETE = MMC_CONSOLE_VERB.DELETE;
pub const MMC_VERB_PROPERTIES = MMC_CONSOLE_VERB.PROPERTIES;
pub const MMC_VERB_RENAME = MMC_CONSOLE_VERB.RENAME;
pub const MMC_VERB_REFRESH = MMC_CONSOLE_VERB.REFRESH;
pub const MMC_VERB_PRINT = MMC_CONSOLE_VERB.PRINT;
pub const MMC_VERB_CUT = MMC_CONSOLE_VERB.CUT;
pub const MMC_VERB_MAX = MMC_CONSOLE_VERB.MAX;
pub const MMC_VERB_FIRST = MMC_CONSOLE_VERB.OPEN;
pub const MMC_VERB_LAST = MMC_CONSOLE_VERB.CUT;

pub const MMCBUTTON = extern struct {
    nBitmap: i32,
    idCommand: i32,
    fsState: u8,
    fsType: u8,
    lpButtonText: ?PWSTR,
    lpTooltipText: ?PWSTR,
};

pub const MMC_BUTTON_STATE = enum(i32) {
    ENABLED = 1,
    CHECKED = 2,
    HIDDEN = 4,
    INDETERMINATE = 8,
    BUTTONPRESSED = 16,
};
pub const ENABLED = MMC_BUTTON_STATE.ENABLED;
pub const CHECKED = MMC_BUTTON_STATE.CHECKED;
pub const HIDDEN = MMC_BUTTON_STATE.HIDDEN;
pub const INDETERMINATE = MMC_BUTTON_STATE.INDETERMINATE;
pub const BUTTONPRESSED = MMC_BUTTON_STATE.BUTTONPRESSED;

pub const RESULTDATAITEM = extern struct {
    mask: u32,
    bScopeItem: BOOL,
    itemID: isize,
    nIndex: i32,
    nCol: i32,
    str: ?PWSTR,
    nImage: i32,
    nState: u32,
    lParam: LPARAM,
    iIndent: i32,
};

pub const RESULTFINDINFO = extern struct {
    psz: ?PWSTR,
    nStart: i32,
    dwOptions: u32,
};

pub const SCOPEDATAITEM = extern struct {
    mask: u32,
    displayname: ?PWSTR,
    nImage: i32,
    nOpenImage: i32,
    nState: u32,
    cChildren: i32,
    lParam: LPARAM,
    relativeID: isize,
    ID: isize,
};

pub const MMC_SCOPE_ITEM_STATE = enum(i32) {
    NORMAL = 1,
    BOLD = 2,
    EXPANDEDONCE = 3,
};
pub const MMC_SCOPE_ITEM_STATE_NORMAL = MMC_SCOPE_ITEM_STATE.NORMAL;
pub const MMC_SCOPE_ITEM_STATE_BOLD = MMC_SCOPE_ITEM_STATE.BOLD;
pub const MMC_SCOPE_ITEM_STATE_EXPANDEDONCE = MMC_SCOPE_ITEM_STATE.EXPANDEDONCE;

pub const CONTEXTMENUITEM = extern struct {
    strName: ?PWSTR,
    strStatusBarText: ?PWSTR,
    lCommandID: i32,
    lInsertionPointID: i32,
    fFlags: i32,
    fSpecialFlags: i32,
};

pub const MMC_MENU_COMMAND_IDS = enum(i32) {
    T = -1,
};
pub const MMCC_STANDARD_VIEW_SELECT = MMC_MENU_COMMAND_IDS.T;

pub const MENUBUTTONDATA = extern struct {
    idCommand: i32,
    x: i32,
    y: i32,
};

pub const MMC_FILTER_TYPE = enum(i32) {
    STRING_FILTER = 0,
    INT_FILTER = 1,
    FILTER_NOVALUE = 32768,
};
pub const MMC_STRING_FILTER = MMC_FILTER_TYPE.STRING_FILTER;
pub const MMC_INT_FILTER = MMC_FILTER_TYPE.INT_FILTER;
pub const MMC_FILTER_NOVALUE = MMC_FILTER_TYPE.FILTER_NOVALUE;

pub const MMC_FILTERDATA = extern struct {
    pszText: ?PWSTR,
    cchTextMax: i32,
    lValue: i32,
};

pub const MMC_FILTER_CHANGE_CODE = enum(i32) {
    DISABLE = 0,
    ENABLE = 1,
    VALUE_CHANGE = 2,
};
pub const MFCC_DISABLE = MMC_FILTER_CHANGE_CODE.DISABLE;
pub const MFCC_ENABLE = MMC_FILTER_CHANGE_CODE.ENABLE;
pub const MFCC_VALUE_CHANGE = MMC_FILTER_CHANGE_CODE.VALUE_CHANGE;

pub const MMC_RESTORE_VIEW = extern struct {
    dwSize: u32,
    cookie: isize,
    pViewType: ?PWSTR,
    lViewOptions: i32,
};

pub const MMC_EXPANDSYNC_STRUCT = extern struct {
    bHandled: BOOL,
    bExpanding: BOOL,
    hItem: isize,
};

pub const MMC_VISIBLE_COLUMNS = extern struct {
    nVisibleColumns: i32,
    rgVisibleCols: [1]i32,
};

pub const MMC_NOTIFY_TYPE = enum(i32) {
    ACTIVATE = 32769,
    ADD_IMAGES = 32770,
    BTN_CLICK = 32771,
    CLICK = 32772,
    COLUMN_CLICK = 32773,
    CONTEXTMENU = 32774,
    CUTORMOVE = 32775,
    DBLCLICK = 32776,
    DELETE = 32777,
    DESELECT_ALL = 32778,
    EXPAND = 32779,
    HELP = 32780,
    MENU_BTNCLICK = 32781,
    MINIMIZED = 32782,
    PASTE = 32783,
    PROPERTY_CHANGE = 32784,
    QUERY_PASTE = 32785,
    REFRESH = 32786,
    REMOVE_CHILDREN = 32787,
    RENAME = 32788,
    SELECT = 32789,
    SHOW = 32790,
    VIEW_CHANGE = 32791,
    SNAPINHELP = 32792,
    CONTEXTHELP = 32793,
    INITOCX = 32794,
    FILTER_CHANGE = 32795,
    FILTERBTN_CLICK = 32796,
    RESTORE_VIEW = 32797,
    PRINT = 32798,
    PRELOAD = 32799,
    LISTPAD = 32800,
    EXPANDSYNC = 32801,
    COLUMNS_CHANGED = 32802,
    CANPASTE_OUTOFPROC = 32803,
};
pub const MMCN_ACTIVATE = MMC_NOTIFY_TYPE.ACTIVATE;
pub const MMCN_ADD_IMAGES = MMC_NOTIFY_TYPE.ADD_IMAGES;
pub const MMCN_BTN_CLICK = MMC_NOTIFY_TYPE.BTN_CLICK;
pub const MMCN_CLICK = MMC_NOTIFY_TYPE.CLICK;
pub const MMCN_COLUMN_CLICK = MMC_NOTIFY_TYPE.COLUMN_CLICK;
pub const MMCN_CONTEXTMENU = MMC_NOTIFY_TYPE.CONTEXTMENU;
pub const MMCN_CUTORMOVE = MMC_NOTIFY_TYPE.CUTORMOVE;
pub const MMCN_DBLCLICK = MMC_NOTIFY_TYPE.DBLCLICK;
pub const MMCN_DELETE = MMC_NOTIFY_TYPE.DELETE;
pub const MMCN_DESELECT_ALL = MMC_NOTIFY_TYPE.DESELECT_ALL;
pub const MMCN_EXPAND = MMC_NOTIFY_TYPE.EXPAND;
pub const MMCN_HELP = MMC_NOTIFY_TYPE.HELP;
pub const MMCN_MENU_BTNCLICK = MMC_NOTIFY_TYPE.MENU_BTNCLICK;
pub const MMCN_MINIMIZED = MMC_NOTIFY_TYPE.MINIMIZED;
pub const MMCN_PASTE = MMC_NOTIFY_TYPE.PASTE;
pub const MMCN_PROPERTY_CHANGE = MMC_NOTIFY_TYPE.PROPERTY_CHANGE;
pub const MMCN_QUERY_PASTE = MMC_NOTIFY_TYPE.QUERY_PASTE;
pub const MMCN_REFRESH = MMC_NOTIFY_TYPE.REFRESH;
pub const MMCN_REMOVE_CHILDREN = MMC_NOTIFY_TYPE.REMOVE_CHILDREN;
pub const MMCN_RENAME = MMC_NOTIFY_TYPE.RENAME;
pub const MMCN_SELECT = MMC_NOTIFY_TYPE.SELECT;
pub const MMCN_SHOW = MMC_NOTIFY_TYPE.SHOW;
pub const MMCN_VIEW_CHANGE = MMC_NOTIFY_TYPE.VIEW_CHANGE;
pub const MMCN_SNAPINHELP = MMC_NOTIFY_TYPE.SNAPINHELP;
pub const MMCN_CONTEXTHELP = MMC_NOTIFY_TYPE.CONTEXTHELP;
pub const MMCN_INITOCX = MMC_NOTIFY_TYPE.INITOCX;
pub const MMCN_FILTER_CHANGE = MMC_NOTIFY_TYPE.FILTER_CHANGE;
pub const MMCN_FILTERBTN_CLICK = MMC_NOTIFY_TYPE.FILTERBTN_CLICK;
pub const MMCN_RESTORE_VIEW = MMC_NOTIFY_TYPE.RESTORE_VIEW;
pub const MMCN_PRINT = MMC_NOTIFY_TYPE.PRINT;
pub const MMCN_PRELOAD = MMC_NOTIFY_TYPE.PRELOAD;
pub const MMCN_LISTPAD = MMC_NOTIFY_TYPE.LISTPAD;
pub const MMCN_EXPANDSYNC = MMC_NOTIFY_TYPE.EXPANDSYNC;
pub const MMCN_COLUMNS_CHANGED = MMC_NOTIFY_TYPE.COLUMNS_CHANGED;
pub const MMCN_CANPASTE_OUTOFPROC = MMC_NOTIFY_TYPE.CANPASTE_OUTOFPROC;

pub const DATA_OBJECT_TYPES = enum(i32) {
    SCOPE = 32768,
    RESULT = 32769,
    SNAPIN_MANAGER = 32770,
    UNINITIALIZED = 65535,
};
pub const CCT_SCOPE = DATA_OBJECT_TYPES.SCOPE;
pub const CCT_RESULT = DATA_OBJECT_TYPES.RESULT;
pub const CCT_SNAPIN_MANAGER = DATA_OBJECT_TYPES.SNAPIN_MANAGER;
pub const CCT_UNINITIALIZED = DATA_OBJECT_TYPES.UNINITIALIZED;

pub const SMMCDataObjects = extern struct {
    count: u32,
    lpDataObject: [1]?*IDataObject,
};

pub const SMMCObjectTypes = extern struct {
    count: u32,
    guid: [1]Guid,
};

pub const SNodeID = extern struct {
    cBytes: u32,
    id: [1]u8,
};

pub const SNodeID2 = extern struct {
    dwFlags: u32,
    cBytes: u32,
    id: [1]u8,
};

pub const SColumnSetID = extern struct {
    dwFlags: u32,
    cBytes: u32,
    id: [1]u8,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponentData_Value = @import("../zig.zig").Guid.initString("955ab28a-5218-11d0-a985-00c04fd8d565");
pub const IID_IComponentData = &IID_IComponentData_Value;
pub const IComponentData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IComponentData,
            pUnknown: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateComponent: fn(
            self: *const IComponentData,
            ppComponent: ?*?*IComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const IComponentData,
            lpDataObject: ?*IDataObject,
            event: MMC_NOTIFY_TYPE,
            arg: LPARAM,
            param3: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Destroy: fn(
            self: *const IComponentData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDataObject: fn(
            self: *const IComponentData,
            cookie: isize,
            type: DATA_OBJECT_TYPES,
            ppDataObject: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayInfo: fn(
            self: *const IComponentData,
            pScopeDataItem: ?*SCOPEDATAITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareObjects: fn(
            self: *const IComponentData,
            lpDataObjectA: ?*IDataObject,
            lpDataObjectB: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_Initialize(self: *const T, pUnknown: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).Initialize(@ptrCast(*const IComponentData, self), pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_CreateComponent(self: *const T, ppComponent: ?*?*IComponent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).CreateComponent(@ptrCast(*const IComponentData, self), ppComponent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_Notify(self: *const T, lpDataObject: ?*IDataObject, event: MMC_NOTIFY_TYPE, arg: LPARAM, param3: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).Notify(@ptrCast(*const IComponentData, self), lpDataObject, event, arg, param3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_Destroy(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).Destroy(@ptrCast(*const IComponentData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_QueryDataObject(self: *const T, cookie: isize, type_: DATA_OBJECT_TYPES, ppDataObject: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).QueryDataObject(@ptrCast(*const IComponentData, self), cookie, type_, ppDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_GetDisplayInfo(self: *const T, pScopeDataItem: ?*SCOPEDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).GetDisplayInfo(@ptrCast(*const IComponentData, self), pScopeDataItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_CompareObjects(self: *const T, lpDataObjectA: ?*IDataObject, lpDataObjectB: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).CompareObjects(@ptrCast(*const IComponentData, self), lpDataObjectA, lpDataObjectB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponent_Value = @import("../zig.zig").Guid.initString("43136eb2-d36c-11cf-adbc-00aa00a80033");
pub const IID_IComponent = &IID_IComponent_Value;
pub const IComponent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IComponent,
            lpConsole: ?*IConsole,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const IComponent,
            lpDataObject: ?*IDataObject,
            event: MMC_NOTIFY_TYPE,
            arg: LPARAM,
            param3: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Destroy: fn(
            self: *const IComponent,
            cookie: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDataObject: fn(
            self: *const IComponent,
            cookie: isize,
            type: DATA_OBJECT_TYPES,
            ppDataObject: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResultViewType: fn(
            self: *const IComponent,
            cookie: isize,
            ppViewType: ?*?PWSTR,
            pViewOptions: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayInfo: fn(
            self: *const IComponent,
            pResultDataItem: ?*RESULTDATAITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareObjects: fn(
            self: *const IComponent,
            lpDataObjectA: ?*IDataObject,
            lpDataObjectB: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_Initialize(self: *const T, lpConsole: ?*IConsole) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).Initialize(@ptrCast(*const IComponent, self), lpConsole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_Notify(self: *const T, lpDataObject: ?*IDataObject, event: MMC_NOTIFY_TYPE, arg: LPARAM, param3: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).Notify(@ptrCast(*const IComponent, self), lpDataObject, event, arg, param3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_Destroy(self: *const T, cookie: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).Destroy(@ptrCast(*const IComponent, self), cookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_QueryDataObject(self: *const T, cookie: isize, type_: DATA_OBJECT_TYPES, ppDataObject: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).QueryDataObject(@ptrCast(*const IComponent, self), cookie, type_, ppDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_GetResultViewType(self: *const T, cookie: isize, ppViewType: ?*?PWSTR, pViewOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).GetResultViewType(@ptrCast(*const IComponent, self), cookie, ppViewType, pViewOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_GetDisplayInfo(self: *const T, pResultDataItem: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).GetDisplayInfo(@ptrCast(*const IComponent, self), pResultDataItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_CompareObjects(self: *const T, lpDataObjectA: ?*IDataObject, lpDataObjectB: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).CompareObjects(@ptrCast(*const IComponent, self), lpDataObjectA, lpDataObjectB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultDataCompare_Value = @import("../zig.zig").Guid.initString("e8315a52-7a1a-11d0-a2d2-00c04fd909dd");
pub const IID_IResultDataCompare = &IID_IResultDataCompare_Value;
pub const IResultDataCompare = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Compare: fn(
            self: *const IResultDataCompare,
            lUserParam: LPARAM,
            cookieA: isize,
            cookieB: isize,
            pnResult: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultDataCompare_Compare(self: *const T, lUserParam: LPARAM, cookieA: isize, cookieB: isize, pnResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultDataCompare.VTable, self.vtable).Compare(@ptrCast(*const IResultDataCompare, self), lUserParam, cookieA, cookieB, pnResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultOwnerData_Value = @import("../zig.zig").Guid.initString("9cb396d8-ea83-11d0-aef1-00c04fb6dd2c");
pub const IID_IResultOwnerData = &IID_IResultOwnerData_Value;
pub const IResultOwnerData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindItem: fn(
            self: *const IResultOwnerData,
            pFindInfo: ?*RESULTFINDINFO,
            pnFoundIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CacheHint: fn(
            self: *const IResultOwnerData,
            nStartIndex: i32,
            nEndIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SortItems: fn(
            self: *const IResultOwnerData,
            nColumn: i32,
            dwSortOptions: u32,
            lUserParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultOwnerData_FindItem(self: *const T, pFindInfo: ?*RESULTFINDINFO, pnFoundIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultOwnerData.VTable, self.vtable).FindItem(@ptrCast(*const IResultOwnerData, self), pFindInfo, pnFoundIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultOwnerData_CacheHint(self: *const T, nStartIndex: i32, nEndIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultOwnerData.VTable, self.vtable).CacheHint(@ptrCast(*const IResultOwnerData, self), nStartIndex, nEndIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultOwnerData_SortItems(self: *const T, nColumn: i32, dwSortOptions: u32, lUserParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultOwnerData.VTable, self.vtable).SortItems(@ptrCast(*const IResultOwnerData, self), nColumn, dwSortOptions, lUserParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsole_Value = @import("../zig.zig").Guid.initString("43136eb1-d36c-11cf-adbc-00aa00a80033");
pub const IID_IConsole = &IID_IConsole_Value;
pub const IConsole = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHeader: fn(
            self: *const IConsole,
            pHeader: ?*IHeaderCtrl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetToolbar: fn(
            self: *const IConsole,
            pToolbar: ?*IToolbar,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryResultView: fn(
            self: *const IConsole,
            pUnknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryScopeImageList: fn(
            self: *const IConsole,
            ppImageList: ?*?*IImageList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryResultImageList: fn(
            self: *const IConsole,
            ppImageList: ?*?*IImageList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAllViews: fn(
            self: *const IConsole,
            lpDataObject: ?*IDataObject,
            data: LPARAM,
            hint: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MessageBox: fn(
            self: *const IConsole,
            lpszText: ?[*:0]const u16,
            lpszTitle: ?[*:0]const u16,
            fuStyle: u32,
            piRetval: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryConsoleVerb: fn(
            self: *const IConsole,
            ppConsoleVerb: ?*?*IConsoleVerb,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectScopeItem: fn(
            self: *const IConsole,
            hScopeItem: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainWindow: fn(
            self: *const IConsole,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewWindow: fn(
            self: *const IConsole,
            hScopeItem: isize,
            lOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_SetHeader(self: *const T, pHeader: ?*IHeaderCtrl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).SetHeader(@ptrCast(*const IConsole, self), pHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_SetToolbar(self: *const T, pToolbar: ?*IToolbar) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).SetToolbar(@ptrCast(*const IConsole, self), pToolbar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_QueryResultView(self: *const T, pUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).QueryResultView(@ptrCast(*const IConsole, self), pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_QueryScopeImageList(self: *const T, ppImageList: ?*?*IImageList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).QueryScopeImageList(@ptrCast(*const IConsole, self), ppImageList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_QueryResultImageList(self: *const T, ppImageList: ?*?*IImageList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).QueryResultImageList(@ptrCast(*const IConsole, self), ppImageList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_UpdateAllViews(self: *const T, lpDataObject: ?*IDataObject, data: LPARAM, hint: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).UpdateAllViews(@ptrCast(*const IConsole, self), lpDataObject, data, hint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_MessageBox(self: *const T, lpszText: ?[*:0]const u16, lpszTitle: ?[*:0]const u16, fuStyle: u32, piRetval: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).MessageBox(@ptrCast(*const IConsole, self), lpszText, lpszTitle, fuStyle, piRetval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_QueryConsoleVerb(self: *const T, ppConsoleVerb: ?*?*IConsoleVerb) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).QueryConsoleVerb(@ptrCast(*const IConsole, self), ppConsoleVerb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_SelectScopeItem(self: *const T, hScopeItem: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).SelectScopeItem(@ptrCast(*const IConsole, self), hScopeItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_GetMainWindow(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).GetMainWindow(@ptrCast(*const IConsole, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_NewWindow(self: *const T, hScopeItem: isize, lOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).NewWindow(@ptrCast(*const IConsole, self), hScopeItem, lOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IHeaderCtrl_Value = @import("../zig.zig").Guid.initString("43136eb3-d36c-11cf-adbc-00aa00a80033");
pub const IID_IHeaderCtrl = &IID_IHeaderCtrl_Value;
pub const IHeaderCtrl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertColumn: fn(
            self: *const IHeaderCtrl,
            nCol: i32,
            title: ?[*:0]const u16,
            nFormat: i32,
            nWidth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteColumn: fn(
            self: *const IHeaderCtrl,
            nCol: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumnText: fn(
            self: *const IHeaderCtrl,
            nCol: i32,
            title: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnText: fn(
            self: *const IHeaderCtrl,
            nCol: i32,
            pText: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumnWidth: fn(
            self: *const IHeaderCtrl,
            nCol: i32,
            nWidth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnWidth: fn(
            self: *const IHeaderCtrl,
            nCol: i32,
            pWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_InsertColumn(self: *const T, nCol: i32, title: ?[*:0]const u16, nFormat: i32, nWidth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).InsertColumn(@ptrCast(*const IHeaderCtrl, self), nCol, title, nFormat, nWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_DeleteColumn(self: *const T, nCol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).DeleteColumn(@ptrCast(*const IHeaderCtrl, self), nCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_SetColumnText(self: *const T, nCol: i32, title: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).SetColumnText(@ptrCast(*const IHeaderCtrl, self), nCol, title);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_GetColumnText(self: *const T, nCol: i32, pText: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).GetColumnText(@ptrCast(*const IHeaderCtrl, self), nCol, pText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_SetColumnWidth(self: *const T, nCol: i32, nWidth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).SetColumnWidth(@ptrCast(*const IHeaderCtrl, self), nCol, nWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_GetColumnWidth(self: *const T, nCol: i32, pWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).GetColumnWidth(@ptrCast(*const IHeaderCtrl, self), nCol, pWidth);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CCM_INSERTIONPOINTID = enum(i32) {
    MASK_SPECIAL = -65536,
    MASK_SHARED = -2147483648,
    MASK_CREATE_PRIMARY = 1073741824,
    MASK_ADD_PRIMARY = 536870912,
    MASK_ADD_3RDPARTY = 268435456,
    MASK_RESERVED = 268369920,
    MASK_FLAGINDEX = 31,
    PRIMARY_TOP = -1610612736,
    PRIMARY_NEW = -1610612735,
    PRIMARY_TASK = -1610612734,
    PRIMARY_VIEW = -1610612733,
    PRIMARY_HELP = -1610612732,
    @"3RDPARTY_NEW" = -1879048191,
    @"3RDPARTY_TASK" = -1879048190,
    // ROOT_MENU = -2147483648, this enum value conflicts with MASK_SHARED
};
pub const CCM_INSERTIONPOINTID_MASK_SPECIAL = CCM_INSERTIONPOINTID.MASK_SPECIAL;
pub const CCM_INSERTIONPOINTID_MASK_SHARED = CCM_INSERTIONPOINTID.MASK_SHARED;
pub const CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY = CCM_INSERTIONPOINTID.MASK_CREATE_PRIMARY;
pub const CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY = CCM_INSERTIONPOINTID.MASK_ADD_PRIMARY;
pub const CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY = CCM_INSERTIONPOINTID.MASK_ADD_3RDPARTY;
pub const CCM_INSERTIONPOINTID_MASK_RESERVED = CCM_INSERTIONPOINTID.MASK_RESERVED;
pub const CCM_INSERTIONPOINTID_MASK_FLAGINDEX = CCM_INSERTIONPOINTID.MASK_FLAGINDEX;
pub const CCM_INSERTIONPOINTID_PRIMARY_TOP = CCM_INSERTIONPOINTID.PRIMARY_TOP;
pub const CCM_INSERTIONPOINTID_PRIMARY_NEW = CCM_INSERTIONPOINTID.PRIMARY_NEW;
pub const CCM_INSERTIONPOINTID_PRIMARY_TASK = CCM_INSERTIONPOINTID.PRIMARY_TASK;
pub const CCM_INSERTIONPOINTID_PRIMARY_VIEW = CCM_INSERTIONPOINTID.PRIMARY_VIEW;
pub const CCM_INSERTIONPOINTID_PRIMARY_HELP = CCM_INSERTIONPOINTID.PRIMARY_HELP;
pub const CCM_INSERTIONPOINTID_3RDPARTY_NEW = CCM_INSERTIONPOINTID.@"3RDPARTY_NEW";
pub const CCM_INSERTIONPOINTID_3RDPARTY_TASK = CCM_INSERTIONPOINTID.@"3RDPARTY_TASK";
pub const CCM_INSERTIONPOINTID_ROOT_MENU = CCM_INSERTIONPOINTID.MASK_SHARED;

pub const CCM_INSERTIONALLOWED = enum(i32) {
    TOP = 1,
    NEW = 2,
    TASK = 4,
    VIEW = 8,
};
pub const CCM_INSERTIONALLOWED_TOP = CCM_INSERTIONALLOWED.TOP;
pub const CCM_INSERTIONALLOWED_NEW = CCM_INSERTIONALLOWED.NEW;
pub const CCM_INSERTIONALLOWED_TASK = CCM_INSERTIONALLOWED.TASK;
pub const CCM_INSERTIONALLOWED_VIEW = CCM_INSERTIONALLOWED.VIEW;

pub const CCM_COMMANDID_MASK_CONSTANTS = enum(u32) {
    D = 4294901760,
};
pub const CCM_COMMANDID_MASK_RESERVED = CCM_COMMANDID_MASK_CONSTANTS.D;

pub const CCM_SPECIAL = enum(i32) {
    SEPARATOR = 1,
    SUBMENU = 2,
    DEFAULT_ITEM = 4,
    INSERTION_POINT = 8,
    TESTONLY = 16,
};
pub const CCM_SPECIAL_SEPARATOR = CCM_SPECIAL.SEPARATOR;
pub const CCM_SPECIAL_SUBMENU = CCM_SPECIAL.SUBMENU;
pub const CCM_SPECIAL_DEFAULT_ITEM = CCM_SPECIAL.DEFAULT_ITEM;
pub const CCM_SPECIAL_INSERTION_POINT = CCM_SPECIAL.INSERTION_POINT;
pub const CCM_SPECIAL_TESTONLY = CCM_SPECIAL.TESTONLY;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IContextMenuCallback_Value = @import("../zig.zig").Guid.initString("43136eb7-d36c-11cf-adbc-00aa00a80033");
pub const IID_IContextMenuCallback = &IID_IContextMenuCallback_Value;
pub const IContextMenuCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddItem: fn(
            self: *const IContextMenuCallback,
            pItem: ?*CONTEXTMENUITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuCallback_AddItem(self: *const T, pItem: ?*CONTEXTMENUITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuCallback.VTable, self.vtable).AddItem(@ptrCast(*const IContextMenuCallback, self), pItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IContextMenuProvider_Value = @import("../zig.zig").Guid.initString("43136eb6-d36c-11cf-adbc-00aa00a80033");
pub const IID_IContextMenuProvider = &IID_IContextMenuProvider_Value;
pub const IContextMenuProvider = extern struct {
    pub const VTable = extern struct {
        base: IContextMenuCallback.VTable,
        EmptyMenuList: fn(
            self: *const IContextMenuProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPrimaryExtensionItems: fn(
            self: *const IContextMenuProvider,
            piExtension: ?*IUnknown,
            piDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddThirdPartyExtensionItems: fn(
            self: *const IContextMenuProvider,
            piDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowContextMenu: fn(
            self: *const IContextMenuProvider,
            hwndParent: ?HWND,
            xPos: i32,
            yPos: i32,
            plSelected: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IContextMenuCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuProvider_EmptyMenuList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuProvider.VTable, self.vtable).EmptyMenuList(@ptrCast(*const IContextMenuProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuProvider_AddPrimaryExtensionItems(self: *const T, piExtension: ?*IUnknown, piDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuProvider.VTable, self.vtable).AddPrimaryExtensionItems(@ptrCast(*const IContextMenuProvider, self), piExtension, piDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuProvider_AddThirdPartyExtensionItems(self: *const T, piDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuProvider.VTable, self.vtable).AddThirdPartyExtensionItems(@ptrCast(*const IContextMenuProvider, self), piDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuProvider_ShowContextMenu(self: *const T, hwndParent: ?HWND, xPos: i32, yPos: i32, plSelected: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuProvider.VTable, self.vtable).ShowContextMenu(@ptrCast(*const IContextMenuProvider, self), hwndParent, xPos, yPos, plSelected);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendContextMenu_Value = @import("../zig.zig").Guid.initString("4f3b7a4f-cfac-11cf-b8e3-00c04fd8d5b0");
pub const IID_IExtendContextMenu = &IID_IExtendContextMenu_Value;
pub const IExtendContextMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddMenuItems: fn(
            self: *const IExtendContextMenu,
            piDataObject: ?*IDataObject,
            piCallback: ?*IContextMenuCallback,
            pInsertionAllowed: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Command: fn(
            self: *const IExtendContextMenu,
            lCommandID: i32,
            piDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendContextMenu_AddMenuItems(self: *const T, piDataObject: ?*IDataObject, piCallback: ?*IContextMenuCallback, pInsertionAllowed: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendContextMenu.VTable, self.vtable).AddMenuItems(@ptrCast(*const IExtendContextMenu, self), piDataObject, piCallback, pInsertionAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendContextMenu_Command(self: *const T, lCommandID: i32, piDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendContextMenu.VTable, self.vtable).Command(@ptrCast(*const IExtendContextMenu, self), lCommandID, piDataObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IImageList_Value = @import("../zig.zig").Guid.initString("43136eb8-d36c-11cf-adbc-00aa00a80033");
pub const IID_IImageList = &IID_IImageList_Value;
pub const IImageList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ImageListSetIcon: fn(
            self: *const IImageList,
            pIcon: ?*isize,
            nLoc: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImageListSetStrip: fn(
            self: *const IImageList,
            pBMapSm: ?*isize,
            pBMapLg: ?*isize,
            nStartLoc: i32,
            cMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_ImageListSetIcon(self: *const T, pIcon: ?*isize, nLoc: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).ImageListSetIcon(@ptrCast(*const IImageList, self), pIcon, nLoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_ImageListSetStrip(self: *const T, pBMapSm: ?*isize, pBMapLg: ?*isize, nStartLoc: i32, cMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).ImageListSetStrip(@ptrCast(*const IImageList, self), pBMapSm, pBMapLg, nStartLoc, cMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultData_Value = @import("../zig.zig").Guid.initString("31da5fa0-e0eb-11cf-9f21-00aa003ca9f6");
pub const IID_IResultData = &IID_IResultData_Value;
pub const IResultData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertItem: fn(
            self: *const IResultData,
            item: ?*RESULTDATAITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteItem: fn(
            self: *const IResultData,
            itemID: isize,
            nCol: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindItemByLParam: fn(
            self: *const IResultData,
            lParam: LPARAM,
            pItemID: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAllRsltItems: fn(
            self: *const IResultData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItem: fn(
            self: *const IResultData,
            item: ?*RESULTDATAITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const IResultData,
            item: ?*RESULTDATAITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextItem: fn(
            self: *const IResultData,
            item: ?*RESULTDATAITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyItemState: fn(
            self: *const IResultData,
            nIndex: i32,
            itemID: isize,
            uAdd: u32,
            uRemove: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyViewStyle: fn(
            self: *const IResultData,
            add: MMC_RESULT_VIEW_STYLE,
            remove: MMC_RESULT_VIEW_STYLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetViewMode: fn(
            self: *const IResultData,
            lViewMode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewMode: fn(
            self: *const IResultData,
            lViewMode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateItem: fn(
            self: *const IResultData,
            itemID: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Sort: fn(
            self: *const IResultData,
            nColumn: i32,
            dwSortOptions: u32,
            lUserParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescBarText: fn(
            self: *const IResultData,
            DescText: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItemCount: fn(
            self: *const IResultData,
            nItemCount: i32,
            dwOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_InsertItem(self: *const T, item: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).InsertItem(@ptrCast(*const IResultData, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_DeleteItem(self: *const T, itemID: isize, nCol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).DeleteItem(@ptrCast(*const IResultData, self), itemID, nCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_FindItemByLParam(self: *const T, lParam: LPARAM, pItemID: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).FindItemByLParam(@ptrCast(*const IResultData, self), lParam, pItemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_DeleteAllRsltItems(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).DeleteAllRsltItems(@ptrCast(*const IResultData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_SetItem(self: *const T, item: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).SetItem(@ptrCast(*const IResultData, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_GetItem(self: *const T, item: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).GetItem(@ptrCast(*const IResultData, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_GetNextItem(self: *const T, item: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).GetNextItem(@ptrCast(*const IResultData, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_ModifyItemState(self: *const T, nIndex: i32, itemID: isize, uAdd: u32, uRemove: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).ModifyItemState(@ptrCast(*const IResultData, self), nIndex, itemID, uAdd, uRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_ModifyViewStyle(self: *const T, add: MMC_RESULT_VIEW_STYLE, remove: MMC_RESULT_VIEW_STYLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).ModifyViewStyle(@ptrCast(*const IResultData, self), add, remove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_SetViewMode(self: *const T, lViewMode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).SetViewMode(@ptrCast(*const IResultData, self), lViewMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_GetViewMode(self: *const T, lViewMode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).GetViewMode(@ptrCast(*const IResultData, self), lViewMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_UpdateItem(self: *const T, itemID: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).UpdateItem(@ptrCast(*const IResultData, self), itemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_Sort(self: *const T, nColumn: i32, dwSortOptions: u32, lUserParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).Sort(@ptrCast(*const IResultData, self), nColumn, dwSortOptions, lUserParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_SetDescBarText(self: *const T, DescText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).SetDescBarText(@ptrCast(*const IResultData, self), DescText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_SetItemCount(self: *const T, nItemCount: i32, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).SetItemCount(@ptrCast(*const IResultData, self), nItemCount, dwOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsoleNameSpace_Value = @import("../zig.zig").Guid.initString("bedeb620-f24d-11cf-8afc-00aa003ca9f6");
pub const IID_IConsoleNameSpace = &IID_IConsoleNameSpace_Value;
pub const IConsoleNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertItem: fn(
            self: *const IConsoleNameSpace,
            item: ?*SCOPEDATAITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteItem: fn(
            self: *const IConsoleNameSpace,
            hItem: isize,
            fDeleteThis: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItem: fn(
            self: *const IConsoleNameSpace,
            item: ?*SCOPEDATAITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const IConsoleNameSpace,
            item: ?*SCOPEDATAITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChildItem: fn(
            self: *const IConsoleNameSpace,
            item: isize,
            pItemChild: ?*isize,
            pCookie: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextItem: fn(
            self: *const IConsoleNameSpace,
            item: isize,
            pItemNext: ?*isize,
            pCookie: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentItem: fn(
            self: *const IConsoleNameSpace,
            item: isize,
            pItemParent: ?*isize,
            pCookie: ?*isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_InsertItem(self: *const T, item: ?*SCOPEDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).InsertItem(@ptrCast(*const IConsoleNameSpace, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_DeleteItem(self: *const T, hItem: isize, fDeleteThis: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).DeleteItem(@ptrCast(*const IConsoleNameSpace, self), hItem, fDeleteThis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_SetItem(self: *const T, item: ?*SCOPEDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).SetItem(@ptrCast(*const IConsoleNameSpace, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_GetItem(self: *const T, item: ?*SCOPEDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).GetItem(@ptrCast(*const IConsoleNameSpace, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_GetChildItem(self: *const T, item: isize, pItemChild: ?*isize, pCookie: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).GetChildItem(@ptrCast(*const IConsoleNameSpace, self), item, pItemChild, pCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_GetNextItem(self: *const T, item: isize, pItemNext: ?*isize, pCookie: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).GetNextItem(@ptrCast(*const IConsoleNameSpace, self), item, pItemNext, pCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_GetParentItem(self: *const T, item: isize, pItemParent: ?*isize, pCookie: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).GetParentItem(@ptrCast(*const IConsoleNameSpace, self), item, pItemParent, pCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsoleNameSpace2_Value = @import("../zig.zig").Guid.initString("255f18cc-65db-11d1-a7dc-00c04fd8d565");
pub const IID_IConsoleNameSpace2 = &IID_IConsoleNameSpace2_Value;
pub const IConsoleNameSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IConsoleNameSpace.VTable,
        Expand: fn(
            self: *const IConsoleNameSpace2,
            hItem: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: fn(
            self: *const IConsoleNameSpace2,
            hItem: isize,
            lpClsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConsoleNameSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace2_Expand(self: *const T, hItem: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace2.VTable, self.vtable).Expand(@ptrCast(*const IConsoleNameSpace2, self), hItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace2_AddExtension(self: *const T, hItem: isize, lpClsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace2.VTable, self.vtable).AddExtension(@ptrCast(*const IConsoleNameSpace2, self), hItem, lpClsid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPropertySheetCallback_Value = @import("../zig.zig").Guid.initString("85de64dd-ef21-11cf-a285-00c04fd8dbe6");
pub const IID_IPropertySheetCallback = &IID_IPropertySheetCallback_Value;
pub const IPropertySheetCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPage: fn(
            self: *const IPropertySheetCallback,
            hPage: ?HPROPSHEETPAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePage: fn(
            self: *const IPropertySheetCallback,
            hPage: ?HPROPSHEETPAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetCallback_AddPage(self: *const T, hPage: ?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetCallback.VTable, self.vtable).AddPage(@ptrCast(*const IPropertySheetCallback, self), hPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetCallback_RemovePage(self: *const T, hPage: ?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetCallback.VTable, self.vtable).RemovePage(@ptrCast(*const IPropertySheetCallback, self), hPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPropertySheetProvider_Value = @import("../zig.zig").Guid.initString("85de64de-ef21-11cf-a285-00c04fd8dbe6");
pub const IID_IPropertySheetProvider = &IID_IPropertySheetProvider_Value;
pub const IPropertySheetProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePropertySheet: fn(
            self: *const IPropertySheetProvider,
            title: ?[*:0]const u16,
            type: u8,
            cookie: isize,
            pIDataObjectm: ?*IDataObject,
            dwOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindPropertySheet: fn(
            self: *const IPropertySheetProvider,
            hItem: isize,
            lpComponent: ?*IComponent,
            lpDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPrimaryPages: fn(
            self: *const IPropertySheetProvider,
            lpUnknown: ?*IUnknown,
            bCreateHandle: BOOL,
            hNotifyWindow: ?HWND,
            bScopePane: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtensionPages: fn(
            self: *const IPropertySheetProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const IPropertySheetProvider,
            window: isize,
            page: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_CreatePropertySheet(self: *const T, title: ?[*:0]const u16, type_: u8, cookie: isize, pIDataObjectm: ?*IDataObject, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).CreatePropertySheet(@ptrCast(*const IPropertySheetProvider, self), title, type_, cookie, pIDataObjectm, dwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_FindPropertySheet(self: *const T, hItem: isize, lpComponent: ?*IComponent, lpDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).FindPropertySheet(@ptrCast(*const IPropertySheetProvider, self), hItem, lpComponent, lpDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_AddPrimaryPages(self: *const T, lpUnknown: ?*IUnknown, bCreateHandle: BOOL, hNotifyWindow: ?HWND, bScopePane: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).AddPrimaryPages(@ptrCast(*const IPropertySheetProvider, self), lpUnknown, bCreateHandle, hNotifyWindow, bScopePane);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_AddExtensionPages(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).AddExtensionPages(@ptrCast(*const IPropertySheetProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_Show(self: *const T, window: isize, page: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).Show(@ptrCast(*const IPropertySheetProvider, self), window, page);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendPropertySheet_Value = @import("../zig.zig").Guid.initString("85de64dc-ef21-11cf-a285-00c04fd8dbe6");
pub const IID_IExtendPropertySheet = &IID_IExtendPropertySheet_Value;
pub const IExtendPropertySheet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePropertyPages: fn(
            self: *const IExtendPropertySheet,
            lpProvider: ?*IPropertySheetCallback,
            handle: isize,
            lpIDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPagesFor: fn(
            self: *const IExtendPropertySheet,
            lpDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendPropertySheet_CreatePropertyPages(self: *const T, lpProvider: ?*IPropertySheetCallback, handle: isize, lpIDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendPropertySheet.VTable, self.vtable).CreatePropertyPages(@ptrCast(*const IExtendPropertySheet, self), lpProvider, handle, lpIDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendPropertySheet_QueryPagesFor(self: *const T, lpDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendPropertySheet.VTable, self.vtable).QueryPagesFor(@ptrCast(*const IExtendPropertySheet, self), lpDataObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IControlbar_Value = @import("../zig.zig").Guid.initString("69fb811e-6c1c-11d0-a2cb-00c04fd909dd");
pub const IID_IControlbar = &IID_IControlbar_Value;
pub const IControlbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IControlbar,
            nType: MMC_CONTROL_TYPE,
            pExtendControlbar: ?*IExtendControlbar,
            ppUnknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Attach: fn(
            self: *const IControlbar,
            nType: MMC_CONTROL_TYPE,
            lpUnknown: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const IControlbar,
            lpUnknown: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IControlbar_Create(self: *const T, nType: MMC_CONTROL_TYPE, pExtendControlbar: ?*IExtendControlbar, ppUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IControlbar.VTable, self.vtable).Create(@ptrCast(*const IControlbar, self), nType, pExtendControlbar, ppUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IControlbar_Attach(self: *const T, nType: MMC_CONTROL_TYPE, lpUnknown: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IControlbar.VTable, self.vtable).Attach(@ptrCast(*const IControlbar, self), nType, lpUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IControlbar_Detach(self: *const T, lpUnknown: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IControlbar.VTable, self.vtable).Detach(@ptrCast(*const IControlbar, self), lpUnknown);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendControlbar_Value = @import("../zig.zig").Guid.initString("49506520-6f40-11d0-a98b-00c04fd8d565");
pub const IID_IExtendControlbar = &IID_IExtendControlbar_Value;
pub const IExtendControlbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetControlbar: fn(
            self: *const IExtendControlbar,
            pControlbar: ?*IControlbar,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlbarNotify: fn(
            self: *const IExtendControlbar,
            event: MMC_NOTIFY_TYPE,
            arg: LPARAM,
            param2: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendControlbar_SetControlbar(self: *const T, pControlbar: ?*IControlbar) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendControlbar.VTable, self.vtable).SetControlbar(@ptrCast(*const IExtendControlbar, self), pControlbar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendControlbar_ControlbarNotify(self: *const T, event: MMC_NOTIFY_TYPE, arg: LPARAM, param2: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendControlbar.VTable, self.vtable).ControlbarNotify(@ptrCast(*const IExtendControlbar, self), event, arg, param2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IToolbar_Value = @import("../zig.zig").Guid.initString("43136eb9-d36c-11cf-adbc-00aa00a80033");
pub const IID_IToolbar = &IID_IToolbar_Value;
pub const IToolbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddBitmap: fn(
            self: *const IToolbar,
            nImages: i32,
            hbmp: ?HBITMAP,
            cxSize: i32,
            cySize: i32,
            crMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddButtons: fn(
            self: *const IToolbar,
            nButtons: i32,
            lpButtons: ?*MMCBUTTON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertButton: fn(
            self: *const IToolbar,
            nIndex: i32,
            lpButton: ?*MMCBUTTON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteButton: fn(
            self: *const IToolbar,
            nIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetButtonState: fn(
            self: *const IToolbar,
            idCommand: i32,
            nState: MMC_BUTTON_STATE,
            pState: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetButtonState: fn(
            self: *const IToolbar,
            idCommand: i32,
            nState: MMC_BUTTON_STATE,
            bState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_AddBitmap(self: *const T, nImages: i32, hbmp: ?HBITMAP, cxSize: i32, cySize: i32, crMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).AddBitmap(@ptrCast(*const IToolbar, self), nImages, hbmp, cxSize, cySize, crMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_AddButtons(self: *const T, nButtons: i32, lpButtons: ?*MMCBUTTON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).AddButtons(@ptrCast(*const IToolbar, self), nButtons, lpButtons);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_InsertButton(self: *const T, nIndex: i32, lpButton: ?*MMCBUTTON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).InsertButton(@ptrCast(*const IToolbar, self), nIndex, lpButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_DeleteButton(self: *const T, nIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).DeleteButton(@ptrCast(*const IToolbar, self), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_GetButtonState(self: *const T, idCommand: i32, nState: MMC_BUTTON_STATE, pState: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).GetButtonState(@ptrCast(*const IToolbar, self), idCommand, nState, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_SetButtonState(self: *const T, idCommand: i32, nState: MMC_BUTTON_STATE, bState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).SetButtonState(@ptrCast(*const IToolbar, self), idCommand, nState, bState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsoleVerb_Value = @import("../zig.zig").Guid.initString("e49f7a60-74af-11d0-a286-00c04fd8fe93");
pub const IID_IConsoleVerb = &IID_IConsoleVerb_Value;
pub const IConsoleVerb = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVerbState: fn(
            self: *const IConsoleVerb,
            eCmdID: MMC_CONSOLE_VERB,
            nState: MMC_BUTTON_STATE,
            pState: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVerbState: fn(
            self: *const IConsoleVerb,
            eCmdID: MMC_CONSOLE_VERB,
            nState: MMC_BUTTON_STATE,
            bState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultVerb: fn(
            self: *const IConsoleVerb,
            eCmdID: MMC_CONSOLE_VERB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultVerb: fn(
            self: *const IConsoleVerb,
            peCmdID: ?*MMC_CONSOLE_VERB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleVerb_GetVerbState(self: *const T, eCmdID: MMC_CONSOLE_VERB, nState: MMC_BUTTON_STATE, pState: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleVerb.VTable, self.vtable).GetVerbState(@ptrCast(*const IConsoleVerb, self), eCmdID, nState, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleVerb_SetVerbState(self: *const T, eCmdID: MMC_CONSOLE_VERB, nState: MMC_BUTTON_STATE, bState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleVerb.VTable, self.vtable).SetVerbState(@ptrCast(*const IConsoleVerb, self), eCmdID, nState, bState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleVerb_SetDefaultVerb(self: *const T, eCmdID: MMC_CONSOLE_VERB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleVerb.VTable, self.vtable).SetDefaultVerb(@ptrCast(*const IConsoleVerb, self), eCmdID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleVerb_GetDefaultVerb(self: *const T, peCmdID: ?*MMC_CONSOLE_VERB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleVerb.VTable, self.vtable).GetDefaultVerb(@ptrCast(*const IConsoleVerb, self), peCmdID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinAbout_Value = @import("../zig.zig").Guid.initString("1245208c-a151-11d0-a7d7-00c04fd909dd");
pub const IID_ISnapinAbout = &IID_ISnapinAbout_Value;
pub const ISnapinAbout = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSnapinDescription: fn(
            self: *const ISnapinAbout,
            lpDescription: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProvider: fn(
            self: *const ISnapinAbout,
            lpName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapinVersion: fn(
            self: *const ISnapinAbout,
            lpVersion: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapinImage: fn(
            self: *const ISnapinAbout,
            hAppIcon: ?*?HICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStaticFolderImage: fn(
            self: *const ISnapinAbout,
            hSmallImage: ?*?HBITMAP,
            hSmallImageOpen: ?*?HBITMAP,
            hLargeImage: ?*?HBITMAP,
            cMask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetSnapinDescription(self: *const T, lpDescription: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetSnapinDescription(@ptrCast(*const ISnapinAbout, self), lpDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetProvider(self: *const T, lpName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetProvider(@ptrCast(*const ISnapinAbout, self), lpName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetSnapinVersion(self: *const T, lpVersion: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetSnapinVersion(@ptrCast(*const ISnapinAbout, self), lpVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetSnapinImage(self: *const T, hAppIcon: ?*?HICON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetSnapinImage(@ptrCast(*const ISnapinAbout, self), hAppIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetStaticFolderImage(self: *const T, hSmallImage: ?*?HBITMAP, hSmallImageOpen: ?*?HBITMAP, hLargeImage: ?*?HBITMAP, cMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetStaticFolderImage(@ptrCast(*const ISnapinAbout, self), hSmallImage, hSmallImageOpen, hLargeImage, cMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMenuButton_Value = @import("../zig.zig").Guid.initString("951ed750-d080-11d0-b197-000000000000");
pub const IID_IMenuButton = &IID_IMenuButton_Value;
pub const IMenuButton = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddButton: fn(
            self: *const IMenuButton,
            idCommand: i32,
            lpButtonText: ?PWSTR,
            lpTooltipText: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetButton: fn(
            self: *const IMenuButton,
            idCommand: i32,
            lpButtonText: ?PWSTR,
            lpTooltipText: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetButtonState: fn(
            self: *const IMenuButton,
            idCommand: i32,
            nState: MMC_BUTTON_STATE,
            bState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuButton_AddButton(self: *const T, idCommand: i32, lpButtonText: ?PWSTR, lpTooltipText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuButton.VTable, self.vtable).AddButton(@ptrCast(*const IMenuButton, self), idCommand, lpButtonText, lpTooltipText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuButton_SetButton(self: *const T, idCommand: i32, lpButtonText: ?PWSTR, lpTooltipText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuButton.VTable, self.vtable).SetButton(@ptrCast(*const IMenuButton, self), idCommand, lpButtonText, lpTooltipText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuButton_SetButtonState(self: *const T, idCommand: i32, nState: MMC_BUTTON_STATE, bState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuButton.VTable, self.vtable).SetButtonState(@ptrCast(*const IMenuButton, self), idCommand, nState, bState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinHelp_Value = @import("../zig.zig").Guid.initString("a6b15ace-df59-11d0-a7dd-00c04fd909dd");
pub const IID_ISnapinHelp = &IID_ISnapinHelp_Value;
pub const ISnapinHelp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHelpTopic: fn(
            self: *const ISnapinHelp,
            lpCompiledHelpFile: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinHelp_GetHelpTopic(self: *const T, lpCompiledHelpFile: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinHelp.VTable, self.vtable).GetHelpTopic(@ptrCast(*const ISnapinHelp, self), lpCompiledHelpFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendPropertySheet2_Value = @import("../zig.zig").Guid.initString("b7a87232-4a51-11d1-a7ea-00c04fd909dd");
pub const IID_IExtendPropertySheet2 = &IID_IExtendPropertySheet2_Value;
pub const IExtendPropertySheet2 = extern struct {
    pub const VTable = extern struct {
        base: IExtendPropertySheet.VTable,
        GetWatermarks: fn(
            self: *const IExtendPropertySheet2,
            lpIDataObject: ?*IDataObject,
            lphWatermark: ?*?HBITMAP,
            lphHeader: ?*?HBITMAP,
            lphPalette: ?*?HPALETTE,
            bStretch: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IExtendPropertySheet.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendPropertySheet2_GetWatermarks(self: *const T, lpIDataObject: ?*IDataObject, lphWatermark: ?*?HBITMAP, lphHeader: ?*?HBITMAP, lphPalette: ?*?HPALETTE, bStretch: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendPropertySheet2.VTable, self.vtable).GetWatermarks(@ptrCast(*const IExtendPropertySheet2, self), lpIDataObject, lphWatermark, lphHeader, lphPalette, bStretch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IHeaderCtrl2_Value = @import("../zig.zig").Guid.initString("9757abb8-1b32-11d1-a7ce-00c04fd8d565");
pub const IID_IHeaderCtrl2 = &IID_IHeaderCtrl2_Value;
pub const IHeaderCtrl2 = extern struct {
    pub const VTable = extern struct {
        base: IHeaderCtrl.VTable,
        SetChangeTimeOut: fn(
            self: *const IHeaderCtrl2,
            uTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumnFilter: fn(
            self: *const IHeaderCtrl2,
            nColumn: u32,
            dwType: u32,
            pFilterData: ?*MMC_FILTERDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnFilter: fn(
            self: *const IHeaderCtrl2,
            nColumn: u32,
            pdwType: ?*u32,
            pFilterData: ?*MMC_FILTERDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHeaderCtrl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl2_SetChangeTimeOut(self: *const T, uTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl2.VTable, self.vtable).SetChangeTimeOut(@ptrCast(*const IHeaderCtrl2, self), uTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl2_SetColumnFilter(self: *const T, nColumn: u32, dwType: u32, pFilterData: ?*MMC_FILTERDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl2.VTable, self.vtable).SetColumnFilter(@ptrCast(*const IHeaderCtrl2, self), nColumn, dwType, pFilterData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl2_GetColumnFilter(self: *const T, nColumn: u32, pdwType: ?*u32, pFilterData: ?*MMC_FILTERDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl2.VTable, self.vtable).GetColumnFilter(@ptrCast(*const IHeaderCtrl2, self), nColumn, pdwType, pFilterData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinHelp2_Value = @import("../zig.zig").Guid.initString("4861a010-20f9-11d2-a510-00c04fb6dd2c");
pub const IID_ISnapinHelp2 = &IID_ISnapinHelp2_Value;
pub const ISnapinHelp2 = extern struct {
    pub const VTable = extern struct {
        base: ISnapinHelp.VTable,
        GetLinkedTopics: fn(
            self: *const ISnapinHelp2,
            lpCompiledHelpFiles: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISnapinHelp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinHelp2_GetLinkedTopics(self: *const T, lpCompiledHelpFiles: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinHelp2.VTable, self.vtable).GetLinkedTopics(@ptrCast(*const ISnapinHelp2, self), lpCompiledHelpFiles);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MMC_TASK_DISPLAY_TYPE = enum(i32) {
    UNINITIALIZED = 0,
    TYPE_SYMBOL = 1,
    TYPE_VANILLA_GIF = 2,
    TYPE_CHOCOLATE_GIF = 3,
    TYPE_BITMAP = 4,
};
pub const MMC_TASK_DISPLAY_UNINITIALIZED = MMC_TASK_DISPLAY_TYPE.UNINITIALIZED;
pub const MMC_TASK_DISPLAY_TYPE_SYMBOL = MMC_TASK_DISPLAY_TYPE.TYPE_SYMBOL;
pub const MMC_TASK_DISPLAY_TYPE_VANILLA_GIF = MMC_TASK_DISPLAY_TYPE.TYPE_VANILLA_GIF;
pub const MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF = MMC_TASK_DISPLAY_TYPE.TYPE_CHOCOLATE_GIF;
pub const MMC_TASK_DISPLAY_TYPE_BITMAP = MMC_TASK_DISPLAY_TYPE.TYPE_BITMAP;

pub const MMC_TASK_DISPLAY_SYMBOL = extern struct {
    szFontFamilyName: ?PWSTR,
    szURLtoEOT: ?PWSTR,
    szSymbolString: ?PWSTR,
};

pub const MMC_TASK_DISPLAY_BITMAP = extern struct {
    szMouseOverBitmap: ?PWSTR,
    szMouseOffBitmap: ?PWSTR,
};

pub const MMC_TASK_DISPLAY_OBJECT = extern struct {
    eDisplayType: MMC_TASK_DISPLAY_TYPE,
    Anonymous: extern union {
        uBitmap: MMC_TASK_DISPLAY_BITMAP,
        uSymbol: MMC_TASK_DISPLAY_SYMBOL,
    },
};

pub const MMC_ACTION_TYPE = enum(i32) {
    UNINITIALIZED = -1,
    ID = 0,
    LINK = 1,
    SCRIPT = 2,
};
pub const MMC_ACTION_UNINITIALIZED = MMC_ACTION_TYPE.UNINITIALIZED;
pub const MMC_ACTION_ID = MMC_ACTION_TYPE.ID;
pub const MMC_ACTION_LINK = MMC_ACTION_TYPE.LINK;
pub const MMC_ACTION_SCRIPT = MMC_ACTION_TYPE.SCRIPT;

pub const MMC_TASK = extern struct {
    sDisplayObject: MMC_TASK_DISPLAY_OBJECT,
    szText: ?PWSTR,
    szHelpString: ?PWSTR,
    eActionType: MMC_ACTION_TYPE,
    Anonymous: extern union {
        nCommandID: isize,
        szActionURL: ?PWSTR,
        szScript: ?PWSTR,
    },
};

pub const MMC_LISTPAD_INFO = extern struct {
    szTitle: ?PWSTR,
    szButtonText: ?PWSTR,
    nCommandID: isize,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumTASK_Value = @import("../zig.zig").Guid.initString("338698b1-5a02-11d1-9fec-00600832db4a");
pub const IID_IEnumTASK = &IID_IEnumTASK_Value;
pub const IEnumTASK = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumTASK,
            celt: u32,
            rgelt: [*]MMC_TASK,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTASK,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTASK,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumTASK,
            ppenum: ?*?*IEnumTASK,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTASK_Next(self: *const T, celt: u32, rgelt: [*]MMC_TASK, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTASK.VTable, self.vtable).Next(@ptrCast(*const IEnumTASK, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTASK_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTASK.VTable, self.vtable).Skip(@ptrCast(*const IEnumTASK, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTASK_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTASK.VTable, self.vtable).Reset(@ptrCast(*const IEnumTASK, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTASK_Clone(self: *const T, ppenum: ?*?*IEnumTASK) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTASK.VTable, self.vtable).Clone(@ptrCast(*const IEnumTASK, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendTaskPad_Value = @import("../zig.zig").Guid.initString("8dee6511-554d-11d1-9fea-00600832db4a");
pub const IID_IExtendTaskPad = &IID_IExtendTaskPad_Value;
pub const IExtendTaskPad = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TaskNotify: fn(
            self: *const IExtendTaskPad,
            pdo: ?*IDataObject,
            arg: ?*VARIANT,
            param2: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumTasks: fn(
            self: *const IExtendTaskPad,
            pdo: ?*IDataObject,
            szTaskGroup: ?PWSTR,
            ppEnumTASK: ?*?*IEnumTASK,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitle: fn(
            self: *const IExtendTaskPad,
            pszGroup: ?PWSTR,
            pszTitle: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptiveText: fn(
            self: *const IExtendTaskPad,
            pszGroup: ?PWSTR,
            pszDescriptiveText: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackground: fn(
            self: *const IExtendTaskPad,
            pszGroup: ?PWSTR,
            pTDO: ?*MMC_TASK_DISPLAY_OBJECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListPadInfo: fn(
            self: *const IExtendTaskPad,
            pszGroup: ?PWSTR,
            lpListPadInfo: ?*MMC_LISTPAD_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_TaskNotify(self: *const T, pdo: ?*IDataObject, arg: ?*VARIANT, param2: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).TaskNotify(@ptrCast(*const IExtendTaskPad, self), pdo, arg, param2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_EnumTasks(self: *const T, pdo: ?*IDataObject, szTaskGroup: ?PWSTR, ppEnumTASK: ?*?*IEnumTASK) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).EnumTasks(@ptrCast(*const IExtendTaskPad, self), pdo, szTaskGroup, ppEnumTASK);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_GetTitle(self: *const T, pszGroup: ?PWSTR, pszTitle: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).GetTitle(@ptrCast(*const IExtendTaskPad, self), pszGroup, pszTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_GetDescriptiveText(self: *const T, pszGroup: ?PWSTR, pszDescriptiveText: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).GetDescriptiveText(@ptrCast(*const IExtendTaskPad, self), pszGroup, pszDescriptiveText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_GetBackground(self: *const T, pszGroup: ?PWSTR, pTDO: ?*MMC_TASK_DISPLAY_OBJECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).GetBackground(@ptrCast(*const IExtendTaskPad, self), pszGroup, pTDO);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_GetListPadInfo(self: *const T, pszGroup: ?PWSTR, lpListPadInfo: ?*MMC_LISTPAD_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).GetListPadInfo(@ptrCast(*const IExtendTaskPad, self), pszGroup, lpListPadInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsole2_Value = @import("../zig.zig").Guid.initString("103d842a-aa63-11d1-a7e1-00c04fd8d565");
pub const IID_IConsole2 = &IID_IConsole2_Value;
pub const IConsole2 = extern struct {
    pub const VTable = extern struct {
        base: IConsole.VTable,
        Expand: fn(
            self: *const IConsole2,
            hItem: isize,
            bExpand: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsTaskpadViewPreferred: fn(
            self: *const IConsole2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatusText: fn(
            self: *const IConsole2,
            pszStatusText: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConsole.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole2_Expand(self: *const T, hItem: isize, bExpand: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole2.VTable, self.vtable).Expand(@ptrCast(*const IConsole2, self), hItem, bExpand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole2_IsTaskpadViewPreferred(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole2.VTable, self.vtable).IsTaskpadViewPreferred(@ptrCast(*const IConsole2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole2_SetStatusText(self: *const T, pszStatusText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole2.VTable, self.vtable).SetStatusText(@ptrCast(*const IConsole2, self), pszStatusText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDisplayHelp_Value = @import("../zig.zig").Guid.initString("cc593830-b926-11d1-8063-0000f875a9ce");
pub const IID_IDisplayHelp = &IID_IDisplayHelp_Value;
pub const IDisplayHelp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowTopic: fn(
            self: *const IDisplayHelp,
            pszHelpTopic: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayHelp_ShowTopic(self: *const T, pszHelpTopic: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayHelp.VTable, self.vtable).ShowTopic(@ptrCast(*const IDisplayHelp, self), pszHelpTopic);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRequiredExtensions_Value = @import("../zig.zig").Guid.initString("72782d7a-a4a0-11d1-af0f-00c04fb6dd2c");
pub const IID_IRequiredExtensions = &IID_IRequiredExtensions_Value;
pub const IRequiredExtensions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableAllExtensions: fn(
            self: *const IRequiredExtensions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstExtension: fn(
            self: *const IRequiredExtensions,
            pExtCLSID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextExtension: fn(
            self: *const IRequiredExtensions,
            pExtCLSID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRequiredExtensions_EnableAllExtensions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRequiredExtensions.VTable, self.vtable).EnableAllExtensions(@ptrCast(*const IRequiredExtensions, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRequiredExtensions_GetFirstExtension(self: *const T, pExtCLSID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRequiredExtensions.VTable, self.vtable).GetFirstExtension(@ptrCast(*const IRequiredExtensions, self), pExtCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRequiredExtensions_GetNextExtension(self: *const T, pExtCLSID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRequiredExtensions.VTable, self.vtable).GetNextExtension(@ptrCast(*const IRequiredExtensions, self), pExtCLSID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStringTable_Value = @import("../zig.zig").Guid.initString("de40b7a4-0f65-11d2-8e25-00c04f8ecd78");
pub const IID_IStringTable = &IID_IStringTable_Value;
pub const IStringTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddString: fn(
            self: *const IStringTable,
            pszAdd: ?[*:0]const u16,
            pStringID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: fn(
            self: *const IStringTable,
            StringID: u32,
            cchBuffer: u32,
            lpBuffer: [*:0]u16,
            pcchOut: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringLength: fn(
            self: *const IStringTable,
            StringID: u32,
            pcchString: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteString: fn(
            self: *const IStringTable,
            StringID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAllStrings: fn(
            self: *const IStringTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindString: fn(
            self: *const IStringTable,
            pszFind: ?[*:0]const u16,
            pStringID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enumerate: fn(
            self: *const IStringTable,
            ppEnum: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_AddString(self: *const T, pszAdd: ?[*:0]const u16, pStringID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).AddString(@ptrCast(*const IStringTable, self), pszAdd, pStringID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_GetString(self: *const T, StringID: u32, cchBuffer: u32, lpBuffer: [*:0]u16, pcchOut: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).GetString(@ptrCast(*const IStringTable, self), StringID, cchBuffer, lpBuffer, pcchOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_GetStringLength(self: *const T, StringID: u32, pcchString: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).GetStringLength(@ptrCast(*const IStringTable, self), StringID, pcchString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_DeleteString(self: *const T, StringID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).DeleteString(@ptrCast(*const IStringTable, self), StringID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_DeleteAllStrings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).DeleteAllStrings(@ptrCast(*const IStringTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_FindString(self: *const T, pszFind: ?[*:0]const u16, pStringID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).FindString(@ptrCast(*const IStringTable, self), pszFind, pStringID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_Enumerate(self: *const T, ppEnum: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).Enumerate(@ptrCast(*const IStringTable, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MMC_COLUMN_DATA = extern struct {
    nColIndex: i32,
    dwFlags: u32,
    nWidth: i32,
    ulReserved: usize,
};

pub const MMC_COLUMN_SET_DATA = extern struct {
    cbSize: i32,
    nNumCols: i32,
    pColData: ?*MMC_COLUMN_DATA,
};

pub const MMC_SORT_DATA = extern struct {
    nColIndex: i32,
    dwSortOptions: u32,
    ulReserved: usize,
};

pub const MMC_SORT_SET_DATA = extern struct {
    cbSize: i32,
    nNumItems: i32,
    pSortData: ?*MMC_SORT_DATA,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IColumnData_Value = @import("../zig.zig").Guid.initString("547c1354-024d-11d3-a707-00c04f8ef4cb");
pub const IID_IColumnData = &IID_IColumnData_Value;
pub const IColumnData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumnConfigData: fn(
            self: *const IColumnData,
            pColID: ?*SColumnSetID,
            pColSetData: ?*MMC_COLUMN_SET_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnConfigData: fn(
            self: *const IColumnData,
            pColID: ?*SColumnSetID,
            ppColSetData: ?*?*MMC_COLUMN_SET_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumnSortData: fn(
            self: *const IColumnData,
            pColID: ?*SColumnSetID,
            pColSortData: ?*MMC_SORT_SET_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnSortData: fn(
            self: *const IColumnData,
            pColID: ?*SColumnSetID,
            ppColSortData: ?*?*MMC_SORT_SET_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnData_SetColumnConfigData(self: *const T, pColID: ?*SColumnSetID, pColSetData: ?*MMC_COLUMN_SET_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnData.VTable, self.vtable).SetColumnConfigData(@ptrCast(*const IColumnData, self), pColID, pColSetData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnData_GetColumnConfigData(self: *const T, pColID: ?*SColumnSetID, ppColSetData: ?*?*MMC_COLUMN_SET_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnData.VTable, self.vtable).GetColumnConfigData(@ptrCast(*const IColumnData, self), pColID, ppColSetData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnData_SetColumnSortData(self: *const T, pColID: ?*SColumnSetID, pColSortData: ?*MMC_SORT_SET_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnData.VTable, self.vtable).SetColumnSortData(@ptrCast(*const IColumnData, self), pColID, pColSortData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnData_GetColumnSortData(self: *const T, pColID: ?*SColumnSetID, ppColSortData: ?*?*MMC_SORT_SET_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnData.VTable, self.vtable).GetColumnSortData(@ptrCast(*const IColumnData, self), pColID, ppColSortData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IconIdentifier = enum(i32) {
    None = 0,
    Error = 32513,
    Question = 32514,
    Warning = 32515,
    Information = 32516,
    // First = 32513, this enum value conflicts with Error
    // Last = 32516, this enum value conflicts with Information
};
pub const Icon_None = IconIdentifier.None;
pub const Icon_Error = IconIdentifier.Error;
pub const Icon_Question = IconIdentifier.Question;
pub const Icon_Warning = IconIdentifier.Warning;
pub const Icon_Information = IconIdentifier.Information;
pub const Icon_First = IconIdentifier.Error;
pub const Icon_Last = IconIdentifier.Information;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMessageView_Value = @import("../zig.zig").Guid.initString("80f94174-fccc-11d2-b991-00c04f8ecd78");
pub const IID_IMessageView = &IID_IMessageView_Value;
pub const IMessageView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTitleText: fn(
            self: *const IMessageView,
            pszTitleText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBodyText: fn(
            self: *const IMessageView,
            pszBodyText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIcon: fn(
            self: *const IMessageView,
            id: IconIdentifier,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IMessageView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageView_SetTitleText(self: *const T, pszTitleText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageView.VTable, self.vtable).SetTitleText(@ptrCast(*const IMessageView, self), pszTitleText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageView_SetBodyText(self: *const T, pszBodyText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageView.VTable, self.vtable).SetBodyText(@ptrCast(*const IMessageView, self), pszBodyText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageView_SetIcon(self: *const T, id: IconIdentifier) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageView.VTable, self.vtable).SetIcon(@ptrCast(*const IMessageView, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageView_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageView.VTable, self.vtable).Clear(@ptrCast(*const IMessageView, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RDITEMHDR = extern struct {
    dwFlags: u32,
    cookie: isize,
    lpReserved: LPARAM,
};

pub const RDCOMPARE = extern struct {
    cbSize: u32,
    dwFlags: u32,
    nColumn: i32,
    lUserParam: LPARAM,
    prdch1: ?*RDITEMHDR,
    prdch2: ?*RDITEMHDR,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultDataCompareEx_Value = @import("../zig.zig").Guid.initString("96933476-0251-11d3-aeb0-00c04f8ecd78");
pub const IID_IResultDataCompareEx = &IID_IResultDataCompareEx_Value;
pub const IResultDataCompareEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Compare: fn(
            self: *const IResultDataCompareEx,
            prdc: ?*RDCOMPARE,
            pnResult: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultDataCompareEx_Compare(self: *const T, prdc: ?*RDCOMPARE, pnResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultDataCompareEx.VTable, self.vtable).Compare(@ptrCast(*const IResultDataCompareEx, self), prdc, pnResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MMC_VIEW_TYPE = enum(i32) {
    LIST = 0,
    HTML = 1,
    OCX = 2,
};
pub const MMC_VIEW_TYPE_LIST = MMC_VIEW_TYPE.LIST;
pub const MMC_VIEW_TYPE_HTML = MMC_VIEW_TYPE.HTML;
pub const MMC_VIEW_TYPE_OCX = MMC_VIEW_TYPE.OCX;

pub const RESULT_VIEW_TYPE_INFO = extern struct {
    pstrPersistableViewDescription: ?PWSTR,
    eViewType: MMC_VIEW_TYPE,
    dwMiscOptions: u32,
    Anonymous: extern union {
        dwListOptions: u32,
        Anonymous1: extern struct {
            dwHTMLOptions: u32,
            pstrURL: ?PWSTR,
        },
        Anonymous2: extern struct {
            dwOCXOptions: u32,
            pUnkControl: ?*IUnknown,
        },
    },
};

pub const CONTEXTMENUITEM2 = extern struct {
    strName: ?PWSTR,
    strStatusBarText: ?PWSTR,
    lCommandID: i32,
    lInsertionPointID: i32,
    fFlags: i32,
    fSpecialFlags: i32,
    strLanguageIndependentName: ?PWSTR,
};

pub const MMC_EXT_VIEW_DATA = extern struct {
    viewID: Guid,
    pszURL: ?[*:0]const u16,
    pszViewTitle: ?[*:0]const u16,
    pszTooltipText: ?[*:0]const u16,
    bReplacesDefaultView: BOOL,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponentData2_Value = @import("../zig.zig").Guid.initString("cca0f2d2-82de-41b5-bf47-3b2076273d5c");
pub const IID_IComponentData2 = &IID_IComponentData2_Value;
pub const IComponentData2 = extern struct {
    pub const VTable = extern struct {
        base: IComponentData.VTable,
        QueryDispatch: fn(
            self: *const IComponentData2,
            cookie: isize,
            type: DATA_OBJECT_TYPES,
            ppDispatch: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponentData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData2_QueryDispatch(self: *const T, cookie: isize, type_: DATA_OBJECT_TYPES, ppDispatch: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData2.VTable, self.vtable).QueryDispatch(@ptrCast(*const IComponentData2, self), cookie, type_, ppDispatch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponent2_Value = @import("../zig.zig").Guid.initString("79a2d615-4a10-4ed4-8c65-8633f9335095");
pub const IID_IComponent2 = &IID_IComponent2_Value;
pub const IComponent2 = extern struct {
    pub const VTable = extern struct {
        base: IComponent.VTable,
        QueryDispatch: fn(
            self: *const IComponent2,
            cookie: isize,
            type: DATA_OBJECT_TYPES,
            ppDispatch: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResultViewType2: fn(
            self: *const IComponent2,
            cookie: isize,
            pResultViewType: ?*RESULT_VIEW_TYPE_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreResultView: fn(
            self: *const IComponent2,
            cookie: isize,
            pResultViewType: ?*RESULT_VIEW_TYPE_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent2_QueryDispatch(self: *const T, cookie: isize, type_: DATA_OBJECT_TYPES, ppDispatch: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent2.VTable, self.vtable).QueryDispatch(@ptrCast(*const IComponent2, self), cookie, type_, ppDispatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent2_GetResultViewType2(self: *const T, cookie: isize, pResultViewType: ?*RESULT_VIEW_TYPE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent2.VTable, self.vtable).GetResultViewType2(@ptrCast(*const IComponent2, self), cookie, pResultViewType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent2_RestoreResultView(self: *const T, cookie: isize, pResultViewType: ?*RESULT_VIEW_TYPE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent2.VTable, self.vtable).RestoreResultView(@ptrCast(*const IComponent2, self), cookie, pResultViewType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IContextMenuCallback2_Value = @import("../zig.zig").Guid.initString("e178bc0e-2ed0-4b5e-8097-42c9087e8b33");
pub const IID_IContextMenuCallback2 = &IID_IContextMenuCallback2_Value;
pub const IContextMenuCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddItem: fn(
            self: *const IContextMenuCallback2,
            pItem: ?*CONTEXTMENUITEM2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuCallback2_AddItem(self: *const T, pItem: ?*CONTEXTMENUITEM2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuCallback2.VTable, self.vtable).AddItem(@ptrCast(*const IContextMenuCallback2, self), pItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMCVersionInfo_Value = @import("../zig.zig").Guid.initString("a8d2c5fe-cdcb-4b9d-bde5-a27343ff54bc");
pub const IID_IMMCVersionInfo = &IID_IMMCVersionInfo_Value;
pub const IMMCVersionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMMCVersion: fn(
            self: *const IMMCVersionInfo,
            pVersionMajor: ?*i32,
            pVersionMinor: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMCVersionInfo_GetMMCVersion(self: *const T, pVersionMajor: ?*i32, pVersionMinor: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMCVersionInfo.VTable, self.vtable).GetMMCVersion(@ptrCast(*const IMMCVersionInfo, self), pVersionMajor, pVersionMinor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendView_Value = @import("../zig.zig").Guid.initString("89995cee-d2ed-4c0e-ae5e-df7e76f3fa53");
pub const IID_IExtendView = &IID_IExtendView_Value;
pub const IExtendView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetViews: fn(
            self: *const IExtendView,
            pDataObject: ?*IDataObject,
            pViewExtensionCallback: ?*IViewExtensionCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendView_GetViews(self: *const T, pDataObject: ?*IDataObject, pViewExtensionCallback: ?*IViewExtensionCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendView.VTable, self.vtable).GetViews(@ptrCast(*const IExtendView, self), pDataObject, pViewExtensionCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IViewExtensionCallback_Value = @import("../zig.zig").Guid.initString("34dd928a-7599-41e5-9f5e-d6bc3062c2da");
pub const IID_IViewExtensionCallback = &IID_IViewExtensionCallback_Value;
pub const IViewExtensionCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddView: fn(
            self: *const IViewExtensionCallback,
            pExtViewData: ?*MMC_EXT_VIEW_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewExtensionCallback_AddView(self: *const T, pExtViewData: ?*MMC_EXT_VIEW_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewExtensionCallback.VTable, self.vtable).AddView(@ptrCast(*const IViewExtensionCallback, self), pExtViewData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsolePower_Value = @import("../zig.zig").Guid.initString("1cfbdd0e-62ca-49ce-a3af-dbb2de61b068");
pub const IID_IConsolePower = &IID_IConsolePower_Value;
pub const IConsolePower = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetExecutionState: fn(
            self: *const IConsolePower,
            dwAdd: u32,
            dwRemove: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetIdleTimer: fn(
            self: *const IConsolePower,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsolePower_SetExecutionState(self: *const T, dwAdd: u32, dwRemove: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsolePower.VTable, self.vtable).SetExecutionState(@ptrCast(*const IConsolePower, self), dwAdd, dwRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsolePower_ResetIdleTimer(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsolePower.VTable, self.vtable).ResetIdleTimer(@ptrCast(*const IConsolePower, self), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsolePowerSink_Value = @import("../zig.zig").Guid.initString("3333759f-fe4f-4975-b143-fec0a5dd6d65");
pub const IID_IConsolePowerSink = &IID_IConsolePowerSink_Value;
pub const IConsolePowerSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPowerBroadcast: fn(
            self: *const IConsolePowerSink,
            nEvent: u32,
            lParam: LPARAM,
            plReturn: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsolePowerSink_OnPowerBroadcast(self: *const T, nEvent: u32, lParam: LPARAM, plReturn: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsolePowerSink.VTable, self.vtable).OnPowerBroadcast(@ptrCast(*const IConsolePowerSink, self), nEvent, lParam, plReturn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INodeProperties_Value = @import("../zig.zig").Guid.initString("15bc4d24-a522-4406-aa55-0749537a6865");
pub const IID_INodeProperties = &IID_INodeProperties_Value;
pub const INodeProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: fn(
            self: *const INodeProperties,
            pDataObject: ?*IDataObject,
            szPropertyName: ?BSTR,
            pbstrProperty: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INodeProperties_GetProperty(self: *const T, pDataObject: ?*IDataObject, szPropertyName: ?BSTR, pbstrProperty: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INodeProperties.VTable, self.vtable).GetProperty(@ptrCast(*const INodeProperties, self), pDataObject, szPropertyName, pbstrProperty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsole3_Value = @import("../zig.zig").Guid.initString("4f85efdb-d0e1-498c-8d4a-d010dfdd404f");
pub const IID_IConsole3 = &IID_IConsole3_Value;
pub const IConsole3 = extern struct {
    pub const VTable = extern struct {
        base: IConsole2.VTable,
        RenameScopeItem: fn(
            self: *const IConsole3,
            hScopeItem: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConsole2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole3_RenameScopeItem(self: *const T, hScopeItem: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole3.VTable, self.vtable).RenameScopeItem(@ptrCast(*const IConsole3, self), hScopeItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultData2_Value = @import("../zig.zig").Guid.initString("0f36e0eb-a7f1-4a81-be5a-9247f7de4b1b");
pub const IID_IResultData2 = &IID_IResultData2_Value;
pub const IResultData2 = extern struct {
    pub const VTable = extern struct {
        base: IResultData.VTable,
        RenameResultItem: fn(
            self: *const IResultData2,
            itemID: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IResultData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData2_RenameResultItem(self: *const T, itemID: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData2.VTable, self.vtable).RenameResultItem(@ptrCast(*const IResultData2, self), itemID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (17)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HPALETTE = @import("../graphics/gdi.zig").HPALETTE;
const HPROPSHEETPAGE = @import("../ui/controls.zig").HPROPSHEETPAGE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDataObject = @import("../system/com.zig").IDataObject;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumString = @import("../system/com.zig").IEnumString;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const PWSTR = @import("../foundation.zig").PWSTR;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
