//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (9)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationScriptEvents_Value = @import("../../../zig.zig").Guid.initString("7c3f6998-1567-4bba-b52b-48d32141d613");
pub const IID_IWebApplicationScriptEvents = &IID_IWebApplicationScriptEvents_Value;
pub const IWebApplicationScriptEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeforeScriptExecute: fn(
            self: *const IWebApplicationScriptEvents,
            htmlWindow: ?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScriptError: fn(
            self: *const IWebApplicationScriptEvents,
            htmlWindow: ?*IHTMLWindow2,
            scriptError: ?*IActiveScriptError,
            url: ?[*:0]const u16,
            errorHandled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationScriptEvents_BeforeScriptExecute(self: *const T, htmlWindow: ?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationScriptEvents.VTable, self.vtable).BeforeScriptExecute(@ptrCast(*const IWebApplicationScriptEvents, self), htmlWindow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationScriptEvents_ScriptError(self: *const T, htmlWindow: ?*IHTMLWindow2, scriptError: ?*IActiveScriptError, url: ?[*:0]const u16, errorHandled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationScriptEvents.VTable, self.vtable).ScriptError(@ptrCast(*const IWebApplicationScriptEvents, self), htmlWindow, scriptError, url, errorHandled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationNavigationEvents_Value = @import("../../../zig.zig").Guid.initString("c22615d2-d318-4da2-8422-1fcaf77b10e4");
pub const IID_IWebApplicationNavigationEvents = &IID_IWebApplicationNavigationEvents_Value;
pub const IWebApplicationNavigationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeforeNavigate: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: ?*IHTMLWindow2,
            url: ?[*:0]const u16,
            navigationFlags: u32,
            targetFrameName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateComplete: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: ?*IHTMLWindow2,
            url: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateError: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: ?*IHTMLWindow2,
            url: ?[*:0]const u16,
            targetFrameName: ?[*:0]const u16,
            statusCode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DocumentComplete: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: ?*IHTMLWindow2,
            url: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DownloadBegin: fn(
            self: *const IWebApplicationNavigationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DownloadComplete: fn(
            self: *const IWebApplicationNavigationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_BeforeNavigate(self: *const T, htmlWindow: ?*IHTMLWindow2, url: ?[*:0]const u16, navigationFlags: u32, targetFrameName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).BeforeNavigate(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url, navigationFlags, targetFrameName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_NavigateComplete(self: *const T, htmlWindow: ?*IHTMLWindow2, url: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).NavigateComplete(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_NavigateError(self: *const T, htmlWindow: ?*IHTMLWindow2, url: ?[*:0]const u16, targetFrameName: ?[*:0]const u16, statusCode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).NavigateError(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url, targetFrameName, statusCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_DocumentComplete(self: *const T, htmlWindow: ?*IHTMLWindow2, url: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).DocumentComplete(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_DownloadBegin(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).DownloadBegin(@ptrCast(*const IWebApplicationNavigationEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_DownloadComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).DownloadComplete(@ptrCast(*const IWebApplicationNavigationEvents, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationUIEvents_Value = @import("../../../zig.zig").Guid.initString("5b2b3f99-328c-41d5-a6f7-7483ed8e71dd");
pub const IID_IWebApplicationUIEvents = &IID_IWebApplicationUIEvents_Value;
pub const IWebApplicationUIEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SecurityProblem: fn(
            self: *const IWebApplicationUIEvents,
            securityProblem: u32,
            result: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationUIEvents_SecurityProblem(self: *const T, securityProblem: u32, result: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationUIEvents.VTable, self.vtable).SecurityProblem(@ptrCast(*const IWebApplicationUIEvents, self), securityProblem, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationUpdateEvents_Value = @import("../../../zig.zig").Guid.initString("3e59e6b7-c652-4daf-ad5e-16feb350cde3");
pub const IID_IWebApplicationUpdateEvents = &IID_IWebApplicationUpdateEvents_Value;
pub const IWebApplicationUpdateEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPaint: fn(
            self: *const IWebApplicationUpdateEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCssChanged: fn(
            self: *const IWebApplicationUpdateEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationUpdateEvents_OnPaint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationUpdateEvents.VTable, self.vtable).OnPaint(@ptrCast(*const IWebApplicationUpdateEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationUpdateEvents_OnCssChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationUpdateEvents.VTable, self.vtable).OnCssChanged(@ptrCast(*const IWebApplicationUpdateEvents, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationHost_Value = @import("../../../zig.zig").Guid.initString("cecbd2c3-a3a5-4749-9681-20e9161c6794");
pub const IID_IWebApplicationHost = &IID_IWebApplicationHost_Value;
pub const IWebApplicationHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWND: fn(
            self: *const IWebApplicationHost,
            hwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Document: fn(
            self: *const IWebApplicationHost,
            htmlDocument: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IWebApplicationHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IWebApplicationHost,
            interfaceId: ?*const Guid,
            callback: ?*IUnknown,
            cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IWebApplicationHost,
            cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_get_HWND(self: *const T, hwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).get_HWND(@ptrCast(*const IWebApplicationHost, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_get_Document(self: *const T, htmlDocument: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).get_Document(@ptrCast(*const IWebApplicationHost, self), htmlDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).Refresh(@ptrCast(*const IWebApplicationHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_Advise(self: *const T, interfaceId: ?*const Guid, callback: ?*IUnknown, cookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).Advise(@ptrCast(*const IWebApplicationHost, self), interfaceId, callback, cookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_Unadvise(self: *const T, cookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).Unadvise(@ptrCast(*const IWebApplicationHost, self), cookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationActivation_Value = @import("../../../zig.zig").Guid.initString("bcdcd0de-330e-481b-b843-4898a6a8ebac");
pub const IID_IWebApplicationActivation = &IID_IWebApplicationActivation_Value;
pub const IWebApplicationActivation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CancelPendingActivation: fn(
            self: *const IWebApplicationActivation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationActivation_CancelPendingActivation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationActivation.VTable, self.vtable).CancelPendingActivation(@ptrCast(*const IWebApplicationActivation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationAuthoringMode_Value = @import("../../../zig.zig").Guid.initString("720aea93-1964-4db0-b005-29eb9e2b18a9");
pub const IID_IWebApplicationAuthoringMode = &IID_IWebApplicationAuthoringMode_Value;
pub const IWebApplicationAuthoringMode = extern struct {
    pub const VTable = extern struct {
        base: IServiceProvider.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthoringClientBinary: fn(
            self: *const IWebApplicationAuthoringMode,
            designModeDllPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IServiceProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationAuthoringMode_get_AuthoringClientBinary(self: *const T, designModeDllPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationAuthoringMode.VTable, self.vtable).get_AuthoringClientBinary(@ptrCast(*const IWebApplicationAuthoringMode, self), designModeDllPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RegisterAuthoringClientFunctionType = fn(
    authoringModeObject: ?*IWebApplicationAuthoringMode,
    host: ?*IWebApplicationHost,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const UnregisterAuthoringClientFunctionType = fn(
    host: ?*IWebApplicationHost,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../../../zig.zig").Guid;
const BOOL = @import("../../../foundation.zig").BOOL;
const BSTR = @import("../../../foundation.zig").BSTR;
const HRESULT = @import("../../../foundation.zig").HRESULT;
const HWND = @import("../../../foundation.zig").HWND;
const IActiveScriptError = @import("../../../system/diagnostics/debug.zig").IActiveScriptError;
const IHTMLDocument2 = @import("../../../web/ms_html.zig").IHTMLDocument2;
const IHTMLWindow2 = @import("../../../web/ms_html.zig").IHTMLWindow2;
const IServiceProvider = @import("../../../system/com.zig").IServiceProvider;
const IUnknown = @import("../../../system/com.zig").IUnknown;
const PWSTR = @import("../../../foundation.zig").PWSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "RegisterAuthoringClientFunctionType")) { _ = RegisterAuthoringClientFunctionType; }
    if (@hasDecl(@This(), "UnregisterAuthoringClientFunctionType")) { _ = UnregisterAuthoringClientFunctionType; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
