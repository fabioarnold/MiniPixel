//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1)
//--------------------------------------------------------------------------------
pub const E_SURFACE_CONTENTS_LOST = @as(u32, 2150301728);

//--------------------------------------------------------------------------------
// Section: Types (19)
//--------------------------------------------------------------------------------
const IID_ISurfaceImageSourceNative_Value = @import("../../zig.zig").Guid.initString("f2e9edc1-d307-4525-9886-0fafaa44163c");
pub const IID_ISurfaceImageSourceNative = &IID_ISurfaceImageSourceNative_Value;
pub const ISurfaceImageSourceNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDevice: fn(
            self: *const ISurfaceImageSourceNative,
            device: ?*IDXGIDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDraw: fn(
            self: *const ISurfaceImageSourceNative,
            updateRect: RECT,
            surface: ?*?*IDXGISurface,
            offset: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndDraw: fn(
            self: *const ISurfaceImageSourceNative,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNative_SetDevice(self: *const T, device: ?*IDXGIDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNative.VTable, self.vtable).SetDevice(@ptrCast(*const ISurfaceImageSourceNative, self), device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNative_BeginDraw(self: *const T, updateRect: RECT, surface: ?*?*IDXGISurface, offset: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNative.VTable, self.vtable).BeginDraw(@ptrCast(*const ISurfaceImageSourceNative, self), updateRect, surface, offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNative_EndDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNative.VTable, self.vtable).EndDraw(@ptrCast(*const ISurfaceImageSourceNative, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVirtualSurfaceUpdatesCallbackNative_Value = @import("../../zig.zig").Guid.initString("dbf2e947-8e6c-4254-9eee-7738f71386c9");
pub const IID_IVirtualSurfaceUpdatesCallbackNative = &IID_IVirtualSurfaceUpdatesCallbackNative_Value;
pub const IVirtualSurfaceUpdatesCallbackNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdatesNeeded: fn(
            self: *const IVirtualSurfaceUpdatesCallbackNative,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceUpdatesCallbackNative_UpdatesNeeded(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceUpdatesCallbackNative.VTable, self.vtable).UpdatesNeeded(@ptrCast(*const IVirtualSurfaceUpdatesCallbackNative, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVirtualSurfaceImageSourceNative_Value = @import("../../zig.zig").Guid.initString("e9550983-360b-4f53-b391-afd695078691");
pub const IID_IVirtualSurfaceImageSourceNative = &IID_IVirtualSurfaceImageSourceNative_Value;
pub const IVirtualSurfaceImageSourceNative = extern struct {
    pub const VTable = extern struct {
        base: ISurfaceImageSourceNative.VTable,
        Invalidate: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            updateRect: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUpdateRectCount: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUpdateRects: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            updates: [*]RECT,
            count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVisibleBounds: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            bounds: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForUpdatesNeeded: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            callback: ?*IVirtualSurfaceUpdatesCallbackNative,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resize: fn(
            self: *const IVirtualSurfaceImageSourceNative,
            newWidth: i32,
            newHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISurfaceImageSourceNative.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_Invalidate(self: *const T, updateRect: RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).Invalidate(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), updateRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_GetUpdateRectCount(self: *const T, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).GetUpdateRectCount(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_GetUpdateRects(self: *const T, updates: [*]RECT, count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).GetUpdateRects(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), updates, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_GetVisibleBounds(self: *const T, bounds: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).GetVisibleBounds(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), bounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_RegisterForUpdatesNeeded(self: *const T, callback: ?*IVirtualSurfaceUpdatesCallbackNative) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).RegisterForUpdatesNeeded(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), callback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualSurfaceImageSourceNative_Resize(self: *const T, newWidth: i32, newHeight: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualSurfaceImageSourceNative.VTable, self.vtable).Resize(@ptrCast(*const IVirtualSurfaceImageSourceNative, self), newWidth, newHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISwapChainBackgroundPanelNative_Value = @import("../../zig.zig").Guid.initString("43bebd4e-add5-4035-8f85-5608d08e9dc9");
pub const IID_ISwapChainBackgroundPanelNative = &IID_ISwapChainBackgroundPanelNative_Value;
pub const ISwapChainBackgroundPanelNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSwapChain: fn(
            self: *const ISwapChainBackgroundPanelNative,
            swapChain: ?*IDXGISwapChain,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISwapChainBackgroundPanelNative_SetSwapChain(self: *const T, swapChain: ?*IDXGISwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISwapChainBackgroundPanelNative.VTable, self.vtable).SetSwapChain(@ptrCast(*const ISwapChainBackgroundPanelNative, self), swapChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfaceImageSourceManagerNative_Value = @import("../../zig.zig").Guid.initString("4c8798b7-1d88-4a0f-b59b-b93f600de8c8");
pub const IID_ISurfaceImageSourceManagerNative = &IID_ISurfaceImageSourceManagerNative_Value;
pub const ISurfaceImageSourceManagerNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FlushAllSurfacesWithDevice: fn(
            self: *const ISurfaceImageSourceManagerNative,
            device: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceManagerNative_FlushAllSurfacesWithDevice(self: *const T, device: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceManagerNative.VTable, self.vtable).FlushAllSurfacesWithDevice(@ptrCast(*const ISurfaceImageSourceManagerNative, self), device);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfaceImageSourceNativeWithD2D_Value = @import("../../zig.zig").Guid.initString("54298223-41e1-4a41-9c08-02e8256864a1");
pub const IID_ISurfaceImageSourceNativeWithD2D = &IID_ISurfaceImageSourceNativeWithD2D_Value;
pub const ISurfaceImageSourceNativeWithD2D = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDevice: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
            device: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDraw: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
            updateRect: ?*const RECT,
            iid: ?*const Guid,
            updateObject: ?*?*anyopaque,
            offset: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndDraw: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuspendDraw: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumeDraw: fn(
            self: *const ISurfaceImageSourceNativeWithD2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_SetDevice(self: *const T, device: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).SetDevice(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self), device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_BeginDraw(self: *const T, updateRect: ?*const RECT, iid: ?*const Guid, updateObject: ?*?*anyopaque, offset: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).BeginDraw(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self), updateRect, iid, updateObject, offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_EndDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).EndDraw(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_SuspendDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).SuspendDraw(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfaceImageSourceNativeWithD2D_ResumeDraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfaceImageSourceNativeWithD2D.VTable, self.vtable).ResumeDraw(@ptrCast(*const ISurfaceImageSourceNativeWithD2D, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISwapChainPanelNative_Value = @import("../../zig.zig").Guid.initString("f92f19d2-3ade-45a6-a20c-f6f1ea90554b");
pub const IID_ISwapChainPanelNative = &IID_ISwapChainPanelNative_Value;
pub const ISwapChainPanelNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSwapChain: fn(
            self: *const ISwapChainPanelNative,
            swapChain: ?*IDXGISwapChain,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISwapChainPanelNative_SetSwapChain(self: *const T, swapChain: ?*IDXGISwapChain) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISwapChainPanelNative.VTable, self.vtable).SetSwapChain(@ptrCast(*const ISwapChainPanelNative, self), swapChain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISwapChainPanelNative2_Value = @import("../../zig.zig").Guid.initString("d5a2f60c-37b2-44a2-937b-8d8eb9726821");
pub const IID_ISwapChainPanelNative2 = &IID_ISwapChainPanelNative2_Value;
pub const ISwapChainPanelNative2 = extern struct {
    pub const VTable = extern struct {
        base: ISwapChainPanelNative.VTable,
        SetSwapChainHandle: fn(
            self: *const ISwapChainPanelNative2,
            swapChainHandle: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISwapChainPanelNative.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISwapChainPanelNative2_SetSwapChainHandle(self: *const T, swapChainHandle: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISwapChainPanelNative2.VTable, self.vtable).SetSwapChainHandle(@ptrCast(*const ISwapChainPanelNative2, self), swapChainHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDesktopWindowXamlSourceNative_Value = @import("../../zig.zig").Guid.initString("3cbcf1bf-2f76-4e9c-96ab-e84b37972554");
pub const IID_IDesktopWindowXamlSourceNative = &IID_IDesktopWindowXamlSourceNative_Value;
pub const IDesktopWindowXamlSourceNative = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachToWindow: fn(
            self: *const IDesktopWindowXamlSourceNative,
            parentWnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowHandle: fn(
            self: *const IDesktopWindowXamlSourceNative,
            hWnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWindowXamlSourceNative_AttachToWindow(self: *const T, parentWnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWindowXamlSourceNative.VTable, self.vtable).AttachToWindow(@ptrCast(*const IDesktopWindowXamlSourceNative, self), parentWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWindowXamlSourceNative_get_WindowHandle(self: *const T, hWnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWindowXamlSourceNative.VTable, self.vtable).get_WindowHandle(@ptrCast(*const IDesktopWindowXamlSourceNative, self), hWnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDesktopWindowXamlSourceNative2_Value = @import("../../zig.zig").Guid.initString("e3dcd8c7-3057-4692-99c3-7b7720afda31");
pub const IID_IDesktopWindowXamlSourceNative2 = &IID_IDesktopWindowXamlSourceNative2_Value;
pub const IDesktopWindowXamlSourceNative2 = extern struct {
    pub const VTable = extern struct {
        base: IDesktopWindowXamlSourceNative.VTable,
        PreTranslateMessage: fn(
            self: *const IDesktopWindowXamlSourceNative2,
            message: ?*const MSG,
            result: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDesktopWindowXamlSourceNative.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWindowXamlSourceNative2_PreTranslateMessage(self: *const T, message: ?*const MSG, result: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWindowXamlSourceNative2.VTable, self.vtable).PreTranslateMessage(@ptrCast(*const IDesktopWindowXamlSourceNative2, self), message, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IReferenceTrackerTarget_Value = @import("../../zig.zig").Guid.initString("64bd43f8-bfee-4ec4-b7eb-2935158dae21");
pub const IID_IReferenceTrackerTarget = &IID_IReferenceTrackerTarget_Value;
pub const IReferenceTrackerTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefFromReferenceTracker: fn(
            self: *const IReferenceTrackerTarget,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        ReleaseFromReferenceTracker: fn(
            self: *const IReferenceTrackerTarget,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Peg: fn(
            self: *const IReferenceTrackerTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unpeg: fn(
            self: *const IReferenceTrackerTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerTarget_AddRefFromReferenceTracker(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IReferenceTrackerTarget.VTable, self.vtable).AddRefFromReferenceTracker(@ptrCast(*const IReferenceTrackerTarget, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerTarget_ReleaseFromReferenceTracker(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IReferenceTrackerTarget.VTable, self.vtable).ReleaseFromReferenceTracker(@ptrCast(*const IReferenceTrackerTarget, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerTarget_Peg(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerTarget.VTable, self.vtable).Peg(@ptrCast(*const IReferenceTrackerTarget, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerTarget_Unpeg(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerTarget.VTable, self.vtable).Unpeg(@ptrCast(*const IReferenceTrackerTarget, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IReferenceTracker_Value = @import("../../zig.zig").Guid.initString("11d3b13a-180e-4789-a8be-7712882893e6");
pub const IID_IReferenceTracker = &IID_IReferenceTracker_Value;
pub const IReferenceTracker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConnectFromTrackerSource: fn(
            self: *const IReferenceTracker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectFromTrackerSource: fn(
            self: *const IReferenceTracker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTrackerTargets: fn(
            self: *const IReferenceTracker,
            callback: ?*IFindReferenceTargetsCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReferenceTrackerManager: fn(
            self: *const IReferenceTracker,
            value: ?*?*IReferenceTrackerManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRefFromTrackerSource: fn(
            self: *const IReferenceTracker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseFromTrackerSource: fn(
            self: *const IReferenceTracker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PegFromTrackerSource: fn(
            self: *const IReferenceTracker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTracker_ConnectFromTrackerSource(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTracker.VTable, self.vtable).ConnectFromTrackerSource(@ptrCast(*const IReferenceTracker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTracker_DisconnectFromTrackerSource(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTracker.VTable, self.vtable).DisconnectFromTrackerSource(@ptrCast(*const IReferenceTracker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTracker_FindTrackerTargets(self: *const T, callback: ?*IFindReferenceTargetsCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTracker.VTable, self.vtable).FindTrackerTargets(@ptrCast(*const IReferenceTracker, self), callback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTracker_GetReferenceTrackerManager(self: *const T, value: ?*?*IReferenceTrackerManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTracker.VTable, self.vtable).GetReferenceTrackerManager(@ptrCast(*const IReferenceTracker, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTracker_AddRefFromTrackerSource(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTracker.VTable, self.vtable).AddRefFromTrackerSource(@ptrCast(*const IReferenceTracker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTracker_ReleaseFromTrackerSource(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTracker.VTable, self.vtable).ReleaseFromTrackerSource(@ptrCast(*const IReferenceTracker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTracker_PegFromTrackerSource(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTracker.VTable, self.vtable).PegFromTrackerSource(@ptrCast(*const IReferenceTracker, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IReferenceTrackerManager_Value = @import("../../zig.zig").Guid.initString("3cf184b4-7ccb-4dda-8455-7e6ce99a3298");
pub const IID_IReferenceTrackerManager = &IID_IReferenceTrackerManager_Value;
pub const IReferenceTrackerManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReferenceTrackingStarted: fn(
            self: *const IReferenceTrackerManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTrackerTargetsCompleted: fn(
            self: *const IReferenceTrackerManager,
            findFailed: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReferenceTrackingCompleted: fn(
            self: *const IReferenceTrackerManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReferenceTrackerHost: fn(
            self: *const IReferenceTrackerManager,
            value: ?*IReferenceTrackerHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerManager_ReferenceTrackingStarted(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerManager.VTable, self.vtable).ReferenceTrackingStarted(@ptrCast(*const IReferenceTrackerManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerManager_FindTrackerTargetsCompleted(self: *const T, findFailed: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerManager.VTable, self.vtable).FindTrackerTargetsCompleted(@ptrCast(*const IReferenceTrackerManager, self), findFailed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerManager_ReferenceTrackingCompleted(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerManager.VTable, self.vtable).ReferenceTrackingCompleted(@ptrCast(*const IReferenceTrackerManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerManager_SetReferenceTrackerHost(self: *const T, value: ?*IReferenceTrackerHost) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerManager.VTable, self.vtable).SetReferenceTrackerHost(@ptrCast(*const IReferenceTrackerManager, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFindReferenceTargetsCallback_Value = @import("../../zig.zig").Guid.initString("04b3486c-4687-4229-8d14-505ab584dd88");
pub const IID_IFindReferenceTargetsCallback = &IID_IFindReferenceTargetsCallback_Value;
pub const IFindReferenceTargetsCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FoundTrackerTarget: fn(
            self: *const IFindReferenceTargetsCallback,
            target: ?*IReferenceTrackerTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFindReferenceTargetsCallback_FoundTrackerTarget(self: *const T, target: ?*IReferenceTrackerTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFindReferenceTargetsCallback.VTable, self.vtable).FoundTrackerTarget(@ptrCast(*const IFindReferenceTargetsCallback, self), target);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const XAML_REFERENCETRACKER_DISCONNECT = enum(i32) {
    DEFAULT = 0,
    SUSPEND = 1,
};
pub const XAML_REFERENCETRACKER_DISCONNECT_DEFAULT = XAML_REFERENCETRACKER_DISCONNECT.DEFAULT;
pub const XAML_REFERENCETRACKER_DISCONNECT_SUSPEND = XAML_REFERENCETRACKER_DISCONNECT.SUSPEND;

const IID_IReferenceTrackerHost_Value = @import("../../zig.zig").Guid.initString("29a71c6a-3c42-4416-a39d-e2825a07a773");
pub const IID_IReferenceTrackerHost = &IID_IReferenceTrackerHost_Value;
pub const IReferenceTrackerHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DisconnectUnusedReferenceSources: fn(
            self: *const IReferenceTrackerHost,
            options: XAML_REFERENCETRACKER_DISCONNECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseDisconnectedReferenceSources: fn(
            self: *const IReferenceTrackerHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEndOfReferenceTrackingOnThread: fn(
            self: *const IReferenceTrackerHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrackerTarget: fn(
            self: *const IReferenceTrackerHost,
            unknown: ?*IUnknown,
            newReference: ?*?*IReferenceTrackerTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMemoryPressure: fn(
            self: *const IReferenceTrackerHost,
            bytesAllocated: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveMemoryPressure: fn(
            self: *const IReferenceTrackerHost,
            bytesAllocated: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerHost_DisconnectUnusedReferenceSources(self: *const T, options: XAML_REFERENCETRACKER_DISCONNECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerHost.VTable, self.vtable).DisconnectUnusedReferenceSources(@ptrCast(*const IReferenceTrackerHost, self), options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerHost_ReleaseDisconnectedReferenceSources(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerHost.VTable, self.vtable).ReleaseDisconnectedReferenceSources(@ptrCast(*const IReferenceTrackerHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerHost_NotifyEndOfReferenceTrackingOnThread(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerHost.VTable, self.vtable).NotifyEndOfReferenceTrackingOnThread(@ptrCast(*const IReferenceTrackerHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerHost_GetTrackerTarget(self: *const T, unknown: ?*IUnknown, newReference: ?*?*IReferenceTrackerTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerHost.VTable, self.vtable).GetTrackerTarget(@ptrCast(*const IReferenceTrackerHost, self), unknown, newReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerHost_AddMemoryPressure(self: *const T, bytesAllocated: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerHost.VTable, self.vtable).AddMemoryPressure(@ptrCast(*const IReferenceTrackerHost, self), bytesAllocated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReferenceTrackerHost_RemoveMemoryPressure(self: *const T, bytesAllocated: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReferenceTrackerHost.VTable, self.vtable).RemoveMemoryPressure(@ptrCast(*const IReferenceTrackerHost, self), bytesAllocated);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IReferenceTrackerExtension_Value = @import("../../zig.zig").Guid.initString("4e897caa-59d5-4613-8f8c-f7ebd1f399b0");
pub const IID_IReferenceTrackerExtension = &IID_IReferenceTrackerExtension_Value;
pub const IReferenceTrackerExtension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TrackerHandle__ = extern struct {
    unused: i32,
};

const IID_ITrackerOwner_Value = @import("../../zig.zig").Guid.initString("eb24c20b-9816-4ac7-8cff-36f67a118f4e");
pub const IID_ITrackerOwner = &IID_ITrackerOwner_Value;
pub const ITrackerOwner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTrackerHandle: fn(
            self: *const ITrackerOwner,
            returnValue: ?*?*TrackerHandle__,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTrackerHandle: fn(
            self: *const ITrackerOwner,
            handle: ?*TrackerHandle__,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrackerValue: fn(
            self: *const ITrackerOwner,
            handle: ?*TrackerHandle__,
            value: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TryGetSafeTrackerValue: fn(
            self: *const ITrackerOwner,
            handle: ?*TrackerHandle__,
            returnValue: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u8,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackerOwner_CreateTrackerHandle(self: *const T, returnValue: ?*?*TrackerHandle__) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrackerOwner.VTable, self.vtable).CreateTrackerHandle(@ptrCast(*const ITrackerOwner, self), returnValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackerOwner_DeleteTrackerHandle(self: *const T, handle: ?*TrackerHandle__) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrackerOwner.VTable, self.vtable).DeleteTrackerHandle(@ptrCast(*const ITrackerOwner, self), handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackerOwner_SetTrackerValue(self: *const T, handle: ?*TrackerHandle__, value: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrackerOwner.VTable, self.vtable).SetTrackerValue(@ptrCast(*const ITrackerOwner, self), handle, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackerOwner_TryGetSafeTrackerValue(self: *const T, handle: ?*TrackerHandle__, returnValue: ?*?*IUnknown) callconv(.Inline) u8 {
            return @ptrCast(*const ITrackerOwner.VTable, self.vtable).TryGetSafeTrackerValue(@ptrCast(*const ITrackerOwner, self), handle, returnValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (12)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IDXGIDevice = @import("../../graphics/dxgi.zig").IDXGIDevice;
const IDXGISurface = @import("../../graphics/dxgi.zig").IDXGISurface;
const IDXGISwapChain = @import("../../graphics/dxgi.zig").IDXGISwapChain;
const IUnknown = @import("../../system/com.zig").IUnknown;
const MSG = @import("../../ui/windows_and_messaging.zig").MSG;
const POINT = @import("../../foundation.zig").POINT;
const RECT = @import("../../foundation.zig").RECT;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
