//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (162)
//--------------------------------------------------------------------------------
pub const HKEY_CLASSES_ROOT = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483648));
pub const HKEY_CURRENT_USER = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483647));
pub const HKEY_LOCAL_MACHINE = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483646));
pub const HKEY_USERS = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483645));
pub const HKEY_PERFORMANCE_DATA = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483644));
pub const HKEY_PERFORMANCE_TEXT = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483568));
pub const HKEY_PERFORMANCE_NLSTEXT = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483552));
pub const HKEY_CURRENT_CONFIG = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483643));
pub const HKEY_DYN_DATA = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483642));
pub const HKEY_CURRENT_USER_LOCAL_SETTINGS = @import("../zig.zig").typedConst(HKEY, @as(i32, -2147483641));
pub const RRF_SUBKEY_WOW6464KEY = @as(u32, 65536);
pub const RRF_SUBKEY_WOW6432KEY = @as(u32, 131072);
pub const RRF_WOW64_MASK = @as(u32, 196608);
pub const RRF_NOEXPAND = @as(u32, 268435456);
pub const RRF_ZEROONFAILURE = @as(u32, 536870912);
pub const REG_PROCESS_APPKEY = @as(u32, 1);
pub const REG_USE_CURRENT_SECURITY_CONTEXT = @as(u32, 2);
pub const PROVIDER_KEEPS_VALUE_LENGTH = @as(u32, 1);
pub const REG_MUI_STRING_TRUNCATE = @as(u32, 1);
pub const REG_SECURE_CONNECTION = @as(u32, 1);
pub const REGSTR_MAX_VALUE_LENGTH = @as(u32, 256);
pub const IT_COMPACT = @as(u32, 0);
pub const IT_TYPICAL = @as(u32, 1);
pub const IT_PORTABLE = @as(u32, 2);
pub const IT_CUSTOM = @as(u32, 3);
pub const DRIVERSIGN_NONE = @as(u32, 0);
pub const DRIVERSIGN_WARNING = @as(u32, 1);
pub const DRIVERSIGN_BLOCKING = @as(u32, 2);
pub const DOSOPTGF_DEFCLEAN = @as(i32, 1);
pub const DOSOPTF_DEFAULT = @as(i32, 1);
pub const DOSOPTF_SUPPORTED = @as(i32, 2);
pub const DOSOPTF_ALWAYSUSE = @as(i32, 4);
pub const DOSOPTF_USESPMODE = @as(i32, 8);
pub const DOSOPTF_PROVIDESUMB = @as(i32, 16);
pub const DOSOPTF_NEEDSETUP = @as(i32, 32);
pub const DOSOPTF_INDOSSTART = @as(i32, 64);
pub const DOSOPTF_MULTIPLE = @as(i32, 128);
pub const SUF_FIRSTTIME = @as(i32, 1);
pub const SUF_EXPRESS = @as(i32, 2);
pub const SUF_BATCHINF = @as(i32, 4);
pub const SUF_CLEAN = @as(i32, 8);
pub const SUF_INSETUP = @as(i32, 16);
pub const SUF_NETSETUP = @as(i32, 32);
pub const SUF_NETHDBOOT = @as(i32, 64);
pub const SUF_NETRPLBOOT = @as(i32, 128);
pub const SUF_SBSCOPYOK = @as(i32, 256);
pub const VPDF_DISABLEPWRMGMT = @as(u32, 1);
pub const VPDF_FORCEAPM10MODE = @as(u32, 2);
pub const VPDF_SKIPINTELSLCHECK = @as(u32, 4);
pub const VPDF_DISABLEPWRSTATUSPOLL = @as(u32, 8);
pub const VPDF_DISABLERINGRESUME = @as(u32, 16);
pub const VPDF_SHOWMULTIBATT = @as(u32, 32);
pub const BIF_SHOWSIMILARDRIVERS = @as(u32, 1);
pub const BIF_RAWDEVICENEEDSDRIVER = @as(u32, 2);
pub const PCMCIA_OPT_HAVE_SOCKET = @as(i32, 1);
pub const PCMCIA_OPT_AUTOMEM = @as(i32, 4);
pub const PCMCIA_OPT_NO_SOUND = @as(i32, 8);
pub const PCMCIA_OPT_NO_AUDIO = @as(i32, 16);
pub const PCMCIA_OPT_NO_APMREMOVE = @as(i32, 32);
pub const PCMCIA_DEF_MEMBEGIN = @as(u32, 786432);
pub const PCMCIA_DEF_MEMEND = @as(u32, 16777215);
pub const PCMCIA_DEF_MEMLEN = @as(u32, 4096);
pub const PCMCIA_DEF_MIN_REGION = @as(u32, 65536);
pub const PCI_OPTIONS_USE_BIOS = @as(i32, 1);
pub const PCI_OPTIONS_USE_IRQ_STEERING = @as(i32, 2);
pub const AGP_FLAG_NO_1X_RATE = @as(i32, 1);
pub const AGP_FLAG_NO_2X_RATE = @as(i32, 2);
pub const AGP_FLAG_NO_4X_RATE = @as(i32, 4);
pub const AGP_FLAG_NO_8X_RATE = @as(i32, 8);
pub const AGP_FLAG_REVERSE_INITIALIZATION = @as(i32, 128);
pub const AGP_FLAG_NO_SBA_ENABLE = @as(i32, 256);
pub const AGP_FLAG_NO_FW_ENABLE = @as(i32, 512);
pub const AGP_FLAG_SPECIAL_TARGET = @as(i32, 1048575);
pub const AGP_FLAG_SPECIAL_RESERVE = @as(i32, 1015808);
pub const REGSTR_VAL_MAX_HCID_LEN = @as(u32, 1024);
pub const REGDF_NOTDETIO = @as(u32, 1);
pub const REGDF_NOTDETMEM = @as(u32, 2);
pub const REGDF_NOTDETIRQ = @as(u32, 4);
pub const REGDF_NOTDETDMA = @as(u32, 8);
pub const REGDF_NEEDFULLCONFIG = @as(u32, 16);
pub const REGDF_GENFORCEDCONFIG = @as(u32, 32);
pub const REGDF_NODETCONFIG = @as(u32, 32768);
pub const REGDF_CONFLICTIO = @as(u32, 65536);
pub const REGDF_CONFLICTMEM = @as(u32, 131072);
pub const REGDF_CONFLICTIRQ = @as(u32, 262144);
pub const REGDF_CONFLICTDMA = @as(u32, 524288);
pub const REGDF_MAPIRQ2TO9 = @as(u32, 1048576);
pub const REGDF_NOTVERIFIED = @as(u32, 2147483648);
pub const APMMENUSUSPEND_DISABLED = @as(u32, 0);
pub const APMMENUSUSPEND_ENABLED = @as(u32, 1);
pub const APMMENUSUSPEND_UNDOCKED = @as(u32, 2);
pub const APMMENUSUSPEND_NOCHANGE = @as(u32, 128);
pub const APMTIMEOUT_DISABLED = @as(u32, 0);
pub const CONFIGFLAG_DISABLED = @as(u32, 1);
pub const CONFIGFLAG_REMOVED = @as(u32, 2);
pub const CONFIGFLAG_MANUAL_INSTALL = @as(u32, 4);
pub const CONFIGFLAG_IGNORE_BOOT_LC = @as(u32, 8);
pub const CONFIGFLAG_NET_BOOT = @as(u32, 16);
pub const CONFIGFLAG_REINSTALL = @as(u32, 32);
pub const CONFIGFLAG_FAILEDINSTALL = @as(u32, 64);
pub const CONFIGFLAG_CANTSTOPACHILD = @as(u32, 128);
pub const CONFIGFLAG_OKREMOVEROM = @as(u32, 256);
pub const CONFIGFLAG_NOREMOVEEXIT = @as(u32, 512);
pub const CONFIGFLAG_FINISH_INSTALL = @as(u32, 1024);
pub const CONFIGFLAG_NEEDS_FORCED_CONFIG = @as(u32, 2048);
pub const CONFIGFLAG_NETBOOT_CARD = @as(u32, 4096);
pub const CONFIGFLAG_PARTIAL_LOG_CONF = @as(u32, 8192);
pub const CONFIGFLAG_SUPPRESS_SURPRISE = @as(u32, 16384);
pub const CONFIGFLAG_VERIFY_HARDWARE = @as(u32, 32768);
pub const CONFIGFLAG_FINISHINSTALL_UI = @as(u32, 65536);
pub const CONFIGFLAG_FINISHINSTALL_ACTION = @as(u32, 131072);
pub const CONFIGFLAG_BOOT_DEVICE = @as(u32, 262144);
pub const CONFIGFLAG_NEEDS_CLASS_CONFIG = @as(u32, 524288);
pub const CSCONFIGFLAG_BITS = @as(u32, 7);
pub const CSCONFIGFLAG_DISABLED = @as(u32, 1);
pub const CSCONFIGFLAG_DO_NOT_CREATE = @as(u32, 2);
pub const CSCONFIGFLAG_DO_NOT_START = @as(u32, 4);
pub const DMSTATEFLAG_APPLYTOALL = @as(u32, 1);
pub const NUM_RESOURCE_MAP = @as(u32, 256);
pub const MF_FLAGS_EVEN_IF_NO_RESOURCE = @as(u32, 1);
pub const MF_FLAGS_NO_CREATE_IF_NO_RESOURCE = @as(u32, 2);
pub const MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE = @as(u32, 4);
pub const MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED = @as(u32, 8);
pub const EISAFLAG_NO_IO_MERGE = @as(u32, 1);
pub const EISAFLAG_SLOT_IO_FIRST = @as(u32, 2);
pub const EISA_NO_MAX_FUNCTION = @as(u32, 255);
pub const NUM_EISA_RANGES = @as(u32, 4);
pub const PCIC_DEFAULT_IRQMASK = @as(u32, 20152);
pub const PCIC_DEFAULT_NUMSOCKETS = @as(u32, 0);
pub const DTRESULTOK = @as(u32, 0);
pub const DTRESULTFIX = @as(u32, 1);
pub const DTRESULTPROB = @as(u32, 2);
pub const DTRESULTPART = @as(u32, 3);
pub const PIR_OPTION_ENABLED = @as(u32, 1);
pub const PIR_OPTION_REGISTRY = @as(u32, 2);
pub const PIR_OPTION_MSSPEC = @as(u32, 4);
pub const PIR_OPTION_REALMODE = @as(u32, 8);
pub const PIR_OPTION_DEFAULT = @as(u32, 15);
pub const PIR_STATUS_ERROR = @as(u32, 0);
pub const PIR_STATUS_ENABLED = @as(u32, 1);
pub const PIR_STATUS_DISABLED = @as(u32, 2);
pub const PIR_STATUS_MAX = @as(u32, 3);
pub const PIR_STATUS_TABLE_REGISTRY = @as(u32, 0);
pub const PIR_STATUS_TABLE_MSSPEC = @as(u32, 1);
pub const PIR_STATUS_TABLE_REALMODE = @as(u32, 2);
pub const PIR_STATUS_TABLE_NONE = @as(u32, 3);
pub const PIR_STATUS_TABLE_ERROR = @as(u32, 4);
pub const PIR_STATUS_TABLE_BAD = @as(u32, 5);
pub const PIR_STATUS_TABLE_SUCCESS = @as(u32, 6);
pub const PIR_STATUS_TABLE_MAX = @as(u32, 7);
pub const PIR_STATUS_MINIPORT_NORMAL = @as(u32, 0);
pub const PIR_STATUS_MINIPORT_COMPATIBLE = @as(u32, 1);
pub const PIR_STATUS_MINIPORT_OVERRIDE = @as(u32, 2);
pub const PIR_STATUS_MINIPORT_NONE = @as(u32, 3);
pub const PIR_STATUS_MINIPORT_ERROR = @as(u32, 4);
pub const PIR_STATUS_MINIPORT_NOKEY = @as(u32, 5);
pub const PIR_STATUS_MINIPORT_SUCCESS = @as(u32, 6);
pub const PIR_STATUS_MINIPORT_INVALID = @as(u32, 7);
pub const PIR_STATUS_MINIPORT_MAX = @as(u32, 8);
pub const LASTGOOD_OPERATION = @as(u32, 255);
pub const LASTGOOD_OPERATION_NOPOSTPROC = @as(u32, 0);
pub const LASTGOOD_OPERATION_DELETE = @as(u32, 1);

//--------------------------------------------------------------------------------
// Section: Types (17)
//--------------------------------------------------------------------------------
pub const REG_VALUE_TYPE = enum(u32) {
    NONE = 0,
    SZ = 1,
    EXPAND_SZ = 2,
    BINARY = 3,
    DWORD = 4,
    // DWORD_LITTLE_ENDIAN = 4, this enum value conflicts with DWORD
    DWORD_BIG_ENDIAN = 5,
    LINK = 6,
    MULTI_SZ = 7,
    RESOURCE_LIST = 8,
    FULL_RESOURCE_DESCRIPTOR = 9,
    RESOURCE_REQUIREMENTS_LIST = 10,
    QWORD = 11,
    // QWORD_LITTLE_ENDIAN = 11, this enum value conflicts with QWORD
};
pub const REG_NONE = REG_VALUE_TYPE.NONE;
pub const REG_SZ = REG_VALUE_TYPE.SZ;
pub const REG_EXPAND_SZ = REG_VALUE_TYPE.EXPAND_SZ;
pub const REG_BINARY = REG_VALUE_TYPE.BINARY;
pub const REG_DWORD = REG_VALUE_TYPE.DWORD;
pub const REG_DWORD_LITTLE_ENDIAN = REG_VALUE_TYPE.DWORD;
pub const REG_DWORD_BIG_ENDIAN = REG_VALUE_TYPE.DWORD_BIG_ENDIAN;
pub const REG_LINK = REG_VALUE_TYPE.LINK;
pub const REG_MULTI_SZ = REG_VALUE_TYPE.MULTI_SZ;
pub const REG_RESOURCE_LIST = REG_VALUE_TYPE.RESOURCE_LIST;
pub const REG_FULL_RESOURCE_DESCRIPTOR = REG_VALUE_TYPE.FULL_RESOURCE_DESCRIPTOR;
pub const REG_RESOURCE_REQUIREMENTS_LIST = REG_VALUE_TYPE.RESOURCE_REQUIREMENTS_LIST;
pub const REG_QWORD = REG_VALUE_TYPE.QWORD;
pub const REG_QWORD_LITTLE_ENDIAN = REG_VALUE_TYPE.QWORD;

pub const REG_SAM_FLAGS = enum(u32) {
    QUERY_VALUE = 1,
    SET_VALUE = 2,
    CREATE_SUB_KEY = 4,
    ENUMERATE_SUB_KEYS = 8,
    NOTIFY = 16,
    CREATE_LINK = 32,
    WOW64_32KEY = 512,
    WOW64_64KEY = 256,
    WOW64_RES = 768,
    READ = 131097,
    WRITE = 131078,
    // EXECUTE = 131097, this enum value conflicts with READ
    ALL_ACCESS = 983103,
    _,
    pub fn initFlags(o: struct {
        QUERY_VALUE: u1 = 0,
        SET_VALUE: u1 = 0,
        CREATE_SUB_KEY: u1 = 0,
        ENUMERATE_SUB_KEYS: u1 = 0,
        NOTIFY: u1 = 0,
        CREATE_LINK: u1 = 0,
        WOW64_32KEY: u1 = 0,
        WOW64_64KEY: u1 = 0,
        WOW64_RES: u1 = 0,
        READ: u1 = 0,
        WRITE: u1 = 0,
        ALL_ACCESS: u1 = 0,
    }) REG_SAM_FLAGS {
        return @intToEnum(REG_SAM_FLAGS,
              (if (o.QUERY_VALUE == 1) @enumToInt(REG_SAM_FLAGS.QUERY_VALUE) else 0)
            | (if (o.SET_VALUE == 1) @enumToInt(REG_SAM_FLAGS.SET_VALUE) else 0)
            | (if (o.CREATE_SUB_KEY == 1) @enumToInt(REG_SAM_FLAGS.CREATE_SUB_KEY) else 0)
            | (if (o.ENUMERATE_SUB_KEYS == 1) @enumToInt(REG_SAM_FLAGS.ENUMERATE_SUB_KEYS) else 0)
            | (if (o.NOTIFY == 1) @enumToInt(REG_SAM_FLAGS.NOTIFY) else 0)
            | (if (o.CREATE_LINK == 1) @enumToInt(REG_SAM_FLAGS.CREATE_LINK) else 0)
            | (if (o.WOW64_32KEY == 1) @enumToInt(REG_SAM_FLAGS.WOW64_32KEY) else 0)
            | (if (o.WOW64_64KEY == 1) @enumToInt(REG_SAM_FLAGS.WOW64_64KEY) else 0)
            | (if (o.WOW64_RES == 1) @enumToInt(REG_SAM_FLAGS.WOW64_RES) else 0)
            | (if (o.READ == 1) @enumToInt(REG_SAM_FLAGS.READ) else 0)
            | (if (o.WRITE == 1) @enumToInt(REG_SAM_FLAGS.WRITE) else 0)
            | (if (o.ALL_ACCESS == 1) @enumToInt(REG_SAM_FLAGS.ALL_ACCESS) else 0)
        );
    }
};
pub const KEY_QUERY_VALUE = REG_SAM_FLAGS.QUERY_VALUE;
pub const KEY_SET_VALUE = REG_SAM_FLAGS.SET_VALUE;
pub const KEY_CREATE_SUB_KEY = REG_SAM_FLAGS.CREATE_SUB_KEY;
pub const KEY_ENUMERATE_SUB_KEYS = REG_SAM_FLAGS.ENUMERATE_SUB_KEYS;
pub const KEY_NOTIFY = REG_SAM_FLAGS.NOTIFY;
pub const KEY_CREATE_LINK = REG_SAM_FLAGS.CREATE_LINK;
pub const KEY_WOW64_32KEY = REG_SAM_FLAGS.WOW64_32KEY;
pub const KEY_WOW64_64KEY = REG_SAM_FLAGS.WOW64_64KEY;
pub const KEY_WOW64_RES = REG_SAM_FLAGS.WOW64_RES;
pub const KEY_READ = REG_SAM_FLAGS.READ;
pub const KEY_WRITE = REG_SAM_FLAGS.WRITE;
pub const KEY_EXECUTE = REG_SAM_FLAGS.READ;
pub const KEY_ALL_ACCESS = REG_SAM_FLAGS.ALL_ACCESS;

pub const REG_OPEN_CREATE_OPTIONS = enum(u32) {
    RESERVED = 0,
    // NON_VOLATILE = 0, this enum value conflicts with RESERVED
    VOLATILE = 1,
    CREATE_LINK = 2,
    BACKUP_RESTORE = 4,
    OPEN_LINK = 8,
    DONT_VIRTUALIZE = 16,
    _,
    pub fn initFlags(o: struct {
        RESERVED: u1 = 0,
        VOLATILE: u1 = 0,
        CREATE_LINK: u1 = 0,
        BACKUP_RESTORE: u1 = 0,
        OPEN_LINK: u1 = 0,
        DONT_VIRTUALIZE: u1 = 0,
    }) REG_OPEN_CREATE_OPTIONS {
        return @intToEnum(REG_OPEN_CREATE_OPTIONS,
              (if (o.RESERVED == 1) @enumToInt(REG_OPEN_CREATE_OPTIONS.RESERVED) else 0)
            | (if (o.VOLATILE == 1) @enumToInt(REG_OPEN_CREATE_OPTIONS.VOLATILE) else 0)
            | (if (o.CREATE_LINK == 1) @enumToInt(REG_OPEN_CREATE_OPTIONS.CREATE_LINK) else 0)
            | (if (o.BACKUP_RESTORE == 1) @enumToInt(REG_OPEN_CREATE_OPTIONS.BACKUP_RESTORE) else 0)
            | (if (o.OPEN_LINK == 1) @enumToInt(REG_OPEN_CREATE_OPTIONS.OPEN_LINK) else 0)
            | (if (o.DONT_VIRTUALIZE == 1) @enumToInt(REG_OPEN_CREATE_OPTIONS.DONT_VIRTUALIZE) else 0)
        );
    }
};
// TODO: enum 'REG_OPEN_CREATE_OPTIONS' has known issues with its value aliases

pub const REG_CREATE_KEY_DISPOSITION = enum(u32) {
    CREATED_NEW_KEY = 1,
    OPENED_EXISTING_KEY = 2,
};
pub const REG_CREATED_NEW_KEY = REG_CREATE_KEY_DISPOSITION.CREATED_NEW_KEY;
pub const REG_OPENED_EXISTING_KEY = REG_CREATE_KEY_DISPOSITION.OPENED_EXISTING_KEY;

pub const REG_SAVE_FORMAT = enum(u32) {
    STANDARD_FORMAT = 1,
    LATEST_FORMAT = 2,
    NO_COMPRESSION = 4,
};
pub const REG_STANDARD_FORMAT = REG_SAVE_FORMAT.STANDARD_FORMAT;
pub const REG_LATEST_FORMAT = REG_SAVE_FORMAT.LATEST_FORMAT;
pub const REG_NO_COMPRESSION = REG_SAVE_FORMAT.NO_COMPRESSION;

pub const REG_RESTORE_KEY_FLAGS = enum(i32) {
    FORCE_RESTORE = 8,
    WHOLE_HIVE_VOLATILE = 1,
};
pub const REG_FORCE_RESTORE = REG_RESTORE_KEY_FLAGS.FORCE_RESTORE;
pub const REG_WHOLE_HIVE_VOLATILE = REG_RESTORE_KEY_FLAGS.WHOLE_HIVE_VOLATILE;

pub const REG_NOTIFY_FILTER = enum(u32) {
    CHANGE_NAME = 1,
    CHANGE_ATTRIBUTES = 2,
    CHANGE_LAST_SET = 4,
    CHANGE_SECURITY = 8,
    THREAD_AGNOSTIC = 268435456,
    _,
    pub fn initFlags(o: struct {
        CHANGE_NAME: u1 = 0,
        CHANGE_ATTRIBUTES: u1 = 0,
        CHANGE_LAST_SET: u1 = 0,
        CHANGE_SECURITY: u1 = 0,
        THREAD_AGNOSTIC: u1 = 0,
    }) REG_NOTIFY_FILTER {
        return @intToEnum(REG_NOTIFY_FILTER,
              (if (o.CHANGE_NAME == 1) @enumToInt(REG_NOTIFY_FILTER.CHANGE_NAME) else 0)
            | (if (o.CHANGE_ATTRIBUTES == 1) @enumToInt(REG_NOTIFY_FILTER.CHANGE_ATTRIBUTES) else 0)
            | (if (o.CHANGE_LAST_SET == 1) @enumToInt(REG_NOTIFY_FILTER.CHANGE_LAST_SET) else 0)
            | (if (o.CHANGE_SECURITY == 1) @enumToInt(REG_NOTIFY_FILTER.CHANGE_SECURITY) else 0)
            | (if (o.THREAD_AGNOSTIC == 1) @enumToInt(REG_NOTIFY_FILTER.THREAD_AGNOSTIC) else 0)
        );
    }
};
pub const REG_NOTIFY_CHANGE_NAME = REG_NOTIFY_FILTER.CHANGE_NAME;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES = REG_NOTIFY_FILTER.CHANGE_ATTRIBUTES;
pub const REG_NOTIFY_CHANGE_LAST_SET = REG_NOTIFY_FILTER.CHANGE_LAST_SET;
pub const REG_NOTIFY_CHANGE_SECURITY = REG_NOTIFY_FILTER.CHANGE_SECURITY;
pub const REG_NOTIFY_THREAD_AGNOSTIC = REG_NOTIFY_FILTER.THREAD_AGNOSTIC;

pub const RRF_RT = enum(u32) {
    ANY = 65535,
    DWORD = 24,
    QWORD = 72,
    REG_BINARY = 8,
    REG_DWORD = 16,
    REG_EXPAND_SZ = 4,
    REG_MULTI_SZ = 32,
    REG_NONE = 1,
    REG_QWORD = 64,
    REG_SZ = 2,
    _,
    pub fn initFlags(o: struct {
        ANY: u1 = 0,
        DWORD: u1 = 0,
        QWORD: u1 = 0,
        REG_BINARY: u1 = 0,
        REG_DWORD: u1 = 0,
        REG_EXPAND_SZ: u1 = 0,
        REG_MULTI_SZ: u1 = 0,
        REG_NONE: u1 = 0,
        REG_QWORD: u1 = 0,
        REG_SZ: u1 = 0,
    }) RRF_RT {
        return @intToEnum(RRF_RT,
              (if (o.ANY == 1) @enumToInt(RRF_RT.ANY) else 0)
            | (if (o.DWORD == 1) @enumToInt(RRF_RT.DWORD) else 0)
            | (if (o.QWORD == 1) @enumToInt(RRF_RT.QWORD) else 0)
            | (if (o.REG_BINARY == 1) @enumToInt(RRF_RT.REG_BINARY) else 0)
            | (if (o.REG_DWORD == 1) @enumToInt(RRF_RT.REG_DWORD) else 0)
            | (if (o.REG_EXPAND_SZ == 1) @enumToInt(RRF_RT.REG_EXPAND_SZ) else 0)
            | (if (o.REG_MULTI_SZ == 1) @enumToInt(RRF_RT.REG_MULTI_SZ) else 0)
            | (if (o.REG_NONE == 1) @enumToInt(RRF_RT.REG_NONE) else 0)
            | (if (o.REG_QWORD == 1) @enumToInt(RRF_RT.REG_QWORD) else 0)
            | (if (o.REG_SZ == 1) @enumToInt(RRF_RT.REG_SZ) else 0)
        );
    }
};
pub const RRF_RT_ANY = RRF_RT.ANY;
pub const RRF_RT_DWORD = RRF_RT.DWORD;
pub const RRF_RT_QWORD = RRF_RT.QWORD;
pub const RRF_RT_REG_BINARY = RRF_RT.REG_BINARY;
pub const RRF_RT_REG_DWORD = RRF_RT.REG_DWORD;
pub const RRF_RT_REG_EXPAND_SZ = RRF_RT.REG_EXPAND_SZ;
pub const RRF_RT_REG_MULTI_SZ = RRF_RT.REG_MULTI_SZ;
pub const RRF_RT_REG_NONE = RRF_RT.REG_NONE;
pub const RRF_RT_REG_QWORD = RRF_RT.REG_QWORD;
pub const RRF_RT_REG_SZ = RRF_RT.REG_SZ;

// TODO: this type has a FreeFunc 'RegCloseKey', what can Zig do with this information?
pub const HKEY = *opaque{};

pub const val_context = extern struct {
    valuelen: i32,
    value_context: ?*anyopaque,
    val_buff_ptr: ?*anyopaque,
};

pub const pvalueA = extern struct {
    pv_valuename: ?PSTR,
    pv_valuelen: i32,
    pv_value_context: ?*anyopaque,
    pv_type: u32,
};

pub const pvalueW = extern struct {
    pv_valuename: ?PWSTR,
    pv_valuelen: i32,
    pv_value_context: ?*anyopaque,
    pv_type: u32,
};

pub const PQUERYHANDLER = fn(
    keycontext: ?*anyopaque,
    val_list: ?*val_context,
    num_vals: u32,
    outputbuffer: ?*anyopaque,
    total_outlen: ?*u32,
    input_blen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const provider_info = extern struct {
    pi_R0_1val: ?PQUERYHANDLER,
    pi_R0_allvals: ?PQUERYHANDLER,
    pi_R3_1val: ?PQUERYHANDLER,
    pi_R3_allvals: ?PQUERYHANDLER,
    pi_flags: u32,
    pi_key_context: ?*anyopaque,
};

pub const VALENTA = extern struct {
    ve_valuename: ?PSTR,
    ve_valuelen: u32,
    ve_valueptr: usize,
    ve_type: REG_VALUE_TYPE,
};

pub const VALENTW = extern struct {
    ve_valuename: ?PWSTR,
    ve_valuelen: u32,
    ve_valueptr: usize,
    ve_type: REG_VALUE_TYPE,
};

pub const DSKTLSYSTEMTIME = extern struct {
    wYear: u16,
    wMonth: u16,
    wDayOfWeek: u16,
    wDay: u16,
    wHour: u16,
    wMinute: u16,
    wSecond: u16,
    wMilliseconds: u16,
    wResult: u16,
};


//--------------------------------------------------------------------------------
// Section: Functions (83)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCloseKey(
    hKey: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOverridePredefKey(
    hKey: ?HKEY,
    hNewHKey: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenUserClassesRoot(
    hToken: ?HANDLE,
    dwOptions: u32,
    samDesired: u32,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenCurrentUser(
    samDesired: u32,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDisablePredefinedCache(
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDisablePredefinedCacheEx(
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegConnectRegistryA(
    lpMachineName: ?[*:0]const u8,
    hKey: ?HKEY,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegConnectRegistryW(
    lpMachineName: ?[*:0]const u16,
    hKey: ?HKEY,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegConnectRegistryExA(
    lpMachineName: ?[*:0]const u8,
    hKey: ?HKEY,
    Flags: u32,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegConnectRegistryExW(
    lpMachineName: ?[*:0]const u16,
    hKey: ?HKEY,
    Flags: u32,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCreateKeyA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCreateKeyW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCreateKeyExA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    Reserved: u32,
    lpClass: ?PSTR,
    dwOptions: REG_OPEN_CREATE_OPTIONS,
    samDesired: REG_SAM_FLAGS,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: ?*?HKEY,
    lpdwDisposition: ?*REG_CREATE_KEY_DISPOSITION,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegCreateKeyExW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    Reserved: u32,
    lpClass: ?PWSTR,
    dwOptions: REG_OPEN_CREATE_OPTIONS,
    samDesired: REG_SAM_FLAGS,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: ?*?HKEY,
    lpdwDisposition: ?*REG_CREATE_KEY_DISPOSITION,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegCreateKeyTransactedA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    Reserved: u32,
    lpClass: ?PSTR,
    dwOptions: REG_OPEN_CREATE_OPTIONS,
    samDesired: REG_SAM_FLAGS,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: ?*?HKEY,
    lpdwDisposition: ?*REG_CREATE_KEY_DISPOSITION,
    hTransaction: ?HANDLE,
    pExtendedParemeter: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegCreateKeyTransactedW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    Reserved: u32,
    lpClass: ?PWSTR,
    dwOptions: REG_OPEN_CREATE_OPTIONS,
    samDesired: REG_SAM_FLAGS,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: ?*?HKEY,
    lpdwDisposition: ?*REG_CREATE_KEY_DISPOSITION,
    hTransaction: ?HANDLE,
    pExtendedParemeter: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDeleteKeyA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDeleteKeyW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyExA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    samDesired: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyExW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    samDesired: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyTransactedA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    samDesired: u32,
    Reserved: u32,
    hTransaction: ?HANDLE,
    pExtendedParameter: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyTransactedW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    samDesired: u32,
    Reserved: u32,
    hTransaction: ?HANDLE,
    pExtendedParameter: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDisableReflectionKey(
    hBase: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegEnableReflectionKey(
    hBase: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegQueryReflectionKey(
    hBase: ?HKEY,
    bIsReflectionDisabled: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDeleteValueA(
    hKey: ?HKEY,
    lpValueName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegDeleteValueW(
    hKey: ?HKEY,
    lpValueName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumKeyA(
    hKey: ?HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u8,
    cchName: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumKeyW(
    hKey: ?HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u16,
    cchName: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumKeyExA(
    hKey: ?HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u8,
    lpcchName: ?*u32,
    lpReserved: ?*u32,
    lpClass: ?[*:0]u8,
    lpcchClass: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumKeyExW(
    hKey: ?HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u16,
    lpcchName: ?*u32,
    lpReserved: ?*u32,
    lpClass: ?[*:0]u16,
    lpcchClass: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumValueA(
    hKey: ?HKEY,
    dwIndex: u32,
    lpValueName: ?[*:0]u8,
    lpcchValueName: ?*u32,
    lpReserved: ?*u32,
    lpType: ?*u32,
    // TODO: what to do with BytesParamIndex 7?
    lpData: ?*u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegEnumValueW(
    hKey: ?HKEY,
    dwIndex: u32,
    lpValueName: ?[*:0]u16,
    lpcchValueName: ?*u32,
    lpReserved: ?*u32,
    lpType: ?*u32,
    // TODO: what to do with BytesParamIndex 7?
    lpData: ?*u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegFlushKey(
    hKey: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegGetKeySecurity(
    hKey: ?HKEY,
    SecurityInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    lpcbSecurityDescriptor: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegLoadKeyA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    lpFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegLoadKeyW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    lpFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegNotifyChangeKeyValue(
    hKey: ?HKEY,
    bWatchSubtree: BOOL,
    dwNotifyFilter: REG_NOTIFY_FILTER,
    hEvent: ?HANDLE,
    fAsynchronous: BOOL,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenKeyA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenKeyW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenKeyExA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    ulOptions: u32,
    samDesired: REG_SAM_FLAGS,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegOpenKeyExW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    ulOptions: u32,
    samDesired: REG_SAM_FLAGS,
    phkResult: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegOpenKeyTransactedA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    ulOptions: u32,
    samDesired: REG_SAM_FLAGS,
    phkResult: ?*?HKEY,
    hTransaction: ?HANDLE,
    pExtendedParemeter: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegOpenKeyTransactedW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    ulOptions: u32,
    samDesired: REG_SAM_FLAGS,
    phkResult: ?*?HKEY,
    hTransaction: ?HANDLE,
    pExtendedParemeter: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryInfoKeyA(
    hKey: ?HKEY,
    lpClass: ?[*:0]u8,
    lpcchClass: ?*u32,
    lpReserved: ?*u32,
    lpcSubKeys: ?*u32,
    lpcbMaxSubKeyLen: ?*u32,
    lpcbMaxClassLen: ?*u32,
    lpcValues: ?*u32,
    lpcbMaxValueNameLen: ?*u32,
    lpcbMaxValueLen: ?*u32,
    lpcbSecurityDescriptor: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryInfoKeyW(
    hKey: ?HKEY,
    lpClass: ?[*:0]u16,
    lpcchClass: ?*u32,
    lpReserved: ?*u32,
    lpcSubKeys: ?*u32,
    lpcbMaxSubKeyLen: ?*u32,
    lpcbMaxClassLen: ?*u32,
    lpcValues: ?*u32,
    lpcbMaxValueNameLen: ?*u32,
    lpcbMaxValueLen: ?*u32,
    lpcbSecurityDescriptor: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryValueA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    lpData: ?PSTR,
    lpcbData: ?*i32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryValueW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    lpData: ?PWSTR,
    lpcbData: ?*i32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryMultipleValuesA(
    hKey: ?HKEY,
    val_list: [*]VALENTA,
    num_vals: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpValueBuf: ?PSTR,
    ldwTotsize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryMultipleValuesW(
    hKey: ?HKEY,
    val_list: [*]VALENTW,
    num_vals: u32,
    // TODO: what to do with BytesParamIndex 4?
    lpValueBuf: ?PWSTR,
    ldwTotsize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryValueExA(
    hKey: ?HKEY,
    lpValueName: ?[*:0]const u8,
    lpReserved: ?*u32,
    lpType: ?*REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegQueryValueExW(
    hKey: ?HKEY,
    lpValueName: ?[*:0]const u16,
    lpReserved: ?*u32,
    lpType: ?*REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegReplaceKeyA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    lpNewFile: ?[*:0]const u8,
    lpOldFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegReplaceKeyW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    lpNewFile: ?[*:0]const u16,
    lpOldFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegRestoreKeyA(
    hKey: ?HKEY,
    lpFile: ?[*:0]const u8,
    dwFlags: REG_RESTORE_KEY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegRestoreKeyW(
    hKey: ?HKEY,
    lpFile: ?[*:0]const u16,
    dwFlags: REG_RESTORE_KEY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegRenameKey(
    hKey: ?HKEY,
    lpSubKeyName: ?[*:0]const u16,
    lpNewKeyName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSaveKeyA(
    hKey: ?HKEY,
    lpFile: ?[*:0]const u8,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSaveKeyW(
    hKey: ?HKEY,
    lpFile: ?[*:0]const u16,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegSetKeySecurity(
    hKey: ?HKEY,
    SecurityInformation: u32,
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSetValueA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    dwType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    lpData: ?[*:0]const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSetValueW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    dwType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 4?
    lpData: ?[*:0]const u16,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSetValueExA(
    hKey: ?HKEY,
    lpValueName: ?[*:0]const u8,
    Reserved: u32,
    dwType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegSetValueExW(
    hKey: ?HKEY,
    lpValueName: ?[*:0]const u16,
    Reserved: u32,
    dwType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegUnLoadKeyA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ADVAPI32" fn RegUnLoadKeyW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyValueA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    lpValueName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteKeyValueW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    lpValueName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegSetKeyValueA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    lpValueName: ?[*:0]const u8,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const anyopaque,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegSetKeyValueW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    lpValueName: ?[*:0]const u16,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const anyopaque,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteTreeA(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegDeleteTreeW(
    hKey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegCopyTreeA(
    hKeySrc: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    hKeyDest: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegGetValueA(
    hkey: ?HKEY,
    lpSubKey: ?[*:0]const u8,
    lpValue: ?[*:0]const u8,
    dwFlags: RRF_RT,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegGetValueW(
    hkey: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    lpValue: ?[*:0]const u16,
    dwFlags: RRF_RT,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegCopyTreeW(
    hKeySrc: ?HKEY,
    lpSubKey: ?[*:0]const u16,
    hKeyDest: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegLoadMUIStringA(
    hKey: ?HKEY,
    pszValue: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pszOutBuf: ?PSTR,
    cbOutBuf: u32,
    pcbData: ?*u32,
    Flags: u32,
    pszDirectory: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegLoadMUIStringW(
    hKey: ?HKEY,
    pszValue: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pszOutBuf: ?PWSTR,
    cbOutBuf: u32,
    pcbData: ?*u32,
    Flags: u32,
    pszDirectory: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegLoadAppKeyA(
    lpFile: ?[*:0]const u8,
    phkResult: ?*?HKEY,
    samDesired: u32,
    dwOptions: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegLoadAppKeyW(
    lpFile: ?[*:0]const u16,
    phkResult: ?*?HKEY,
    samDesired: u32,
    dwOptions: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegSaveKeyExA(
    hKey: ?HKEY,
    lpFile: ?[*:0]const u8,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    Flags: REG_SAVE_FORMAT,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RegSaveKeyExW(
    hKey: ?HKEY,
    lpFile: ?[*:0]const u16,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    Flags: REG_SAVE_FORMAT,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "api-ms-win-core-state-helpers-l1-1-0" fn GetRegistryValueWithFallbackW(
    hkeyPrimary: ?HKEY,
    pwszPrimarySubKey: ?[*:0]const u16,
    hkeyFallback: ?HKEY,
    pwszFallbackSubKey: ?[*:0]const u16,
    pwszValue: ?[*:0]const u16,
    dwFlags: u32,
    pdwType: ?*u32,
    pvData: ?*anyopaque,
    cbDataIn: u32,
    pcbDataOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (36)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const pvalue = thismodule.pvalueA;
        pub const VALENT = thismodule.VALENTA;
        pub const RegConnectRegistry = thismodule.RegConnectRegistryA;
        pub const RegConnectRegistryEx = thismodule.RegConnectRegistryExA;
        pub const RegCreateKey = thismodule.RegCreateKeyA;
        pub const RegCreateKeyEx = thismodule.RegCreateKeyExA;
        pub const RegCreateKeyTransacted = thismodule.RegCreateKeyTransactedA;
        pub const RegDeleteKey = thismodule.RegDeleteKeyA;
        pub const RegDeleteKeyEx = thismodule.RegDeleteKeyExA;
        pub const RegDeleteKeyTransacted = thismodule.RegDeleteKeyTransactedA;
        pub const RegDeleteValue = thismodule.RegDeleteValueA;
        pub const RegEnumKey = thismodule.RegEnumKeyA;
        pub const RegEnumKeyEx = thismodule.RegEnumKeyExA;
        pub const RegEnumValue = thismodule.RegEnumValueA;
        pub const RegLoadKey = thismodule.RegLoadKeyA;
        pub const RegOpenKey = thismodule.RegOpenKeyA;
        pub const RegOpenKeyEx = thismodule.RegOpenKeyExA;
        pub const RegOpenKeyTransacted = thismodule.RegOpenKeyTransactedA;
        pub const RegQueryInfoKey = thismodule.RegQueryInfoKeyA;
        pub const RegQueryValue = thismodule.RegQueryValueA;
        pub const RegQueryMultipleValues = thismodule.RegQueryMultipleValuesA;
        pub const RegQueryValueEx = thismodule.RegQueryValueExA;
        pub const RegReplaceKey = thismodule.RegReplaceKeyA;
        pub const RegRestoreKey = thismodule.RegRestoreKeyA;
        pub const RegSaveKey = thismodule.RegSaveKeyA;
        pub const RegSetValue = thismodule.RegSetValueA;
        pub const RegSetValueEx = thismodule.RegSetValueExA;
        pub const RegUnLoadKey = thismodule.RegUnLoadKeyA;
        pub const RegDeleteKeyValue = thismodule.RegDeleteKeyValueA;
        pub const RegSetKeyValue = thismodule.RegSetKeyValueA;
        pub const RegDeleteTree = thismodule.RegDeleteTreeA;
        pub const RegCopyTree = thismodule.RegCopyTreeA;
        pub const RegGetValue = thismodule.RegGetValueA;
        pub const RegLoadMUIString = thismodule.RegLoadMUIStringA;
        pub const RegLoadAppKey = thismodule.RegLoadAppKeyA;
        pub const RegSaveKeyEx = thismodule.RegSaveKeyExA;
    },
    .wide => struct {
        pub const pvalue = thismodule.pvalueW;
        pub const VALENT = thismodule.VALENTW;
        pub const RegConnectRegistry = thismodule.RegConnectRegistryW;
        pub const RegConnectRegistryEx = thismodule.RegConnectRegistryExW;
        pub const RegCreateKey = thismodule.RegCreateKeyW;
        pub const RegCreateKeyEx = thismodule.RegCreateKeyExW;
        pub const RegCreateKeyTransacted = thismodule.RegCreateKeyTransactedW;
        pub const RegDeleteKey = thismodule.RegDeleteKeyW;
        pub const RegDeleteKeyEx = thismodule.RegDeleteKeyExW;
        pub const RegDeleteKeyTransacted = thismodule.RegDeleteKeyTransactedW;
        pub const RegDeleteValue = thismodule.RegDeleteValueW;
        pub const RegEnumKey = thismodule.RegEnumKeyW;
        pub const RegEnumKeyEx = thismodule.RegEnumKeyExW;
        pub const RegEnumValue = thismodule.RegEnumValueW;
        pub const RegLoadKey = thismodule.RegLoadKeyW;
        pub const RegOpenKey = thismodule.RegOpenKeyW;
        pub const RegOpenKeyEx = thismodule.RegOpenKeyExW;
        pub const RegOpenKeyTransacted = thismodule.RegOpenKeyTransactedW;
        pub const RegQueryInfoKey = thismodule.RegQueryInfoKeyW;
        pub const RegQueryValue = thismodule.RegQueryValueW;
        pub const RegQueryMultipleValues = thismodule.RegQueryMultipleValuesW;
        pub const RegQueryValueEx = thismodule.RegQueryValueExW;
        pub const RegReplaceKey = thismodule.RegReplaceKeyW;
        pub const RegRestoreKey = thismodule.RegRestoreKeyW;
        pub const RegSaveKey = thismodule.RegSaveKeyW;
        pub const RegSetValue = thismodule.RegSetValueW;
        pub const RegSetValueEx = thismodule.RegSetValueExW;
        pub const RegUnLoadKey = thismodule.RegUnLoadKeyW;
        pub const RegDeleteKeyValue = thismodule.RegDeleteKeyValueW;
        pub const RegSetKeyValue = thismodule.RegSetKeyValueW;
        pub const RegDeleteTree = thismodule.RegDeleteTreeW;
        pub const RegCopyTree = thismodule.RegCopyTreeW;
        pub const RegGetValue = thismodule.RegGetValueW;
        pub const RegLoadMUIString = thismodule.RegLoadMUIStringW;
        pub const RegLoadAppKey = thismodule.RegLoadAppKeyW;
        pub const RegSaveKeyEx = thismodule.RegSaveKeyExW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const pvalue = *opaque{};
        pub const VALENT = *opaque{};
        pub const RegConnectRegistry = *opaque{};
        pub const RegConnectRegistryEx = *opaque{};
        pub const RegCreateKey = *opaque{};
        pub const RegCreateKeyEx = *opaque{};
        pub const RegCreateKeyTransacted = *opaque{};
        pub const RegDeleteKey = *opaque{};
        pub const RegDeleteKeyEx = *opaque{};
        pub const RegDeleteKeyTransacted = *opaque{};
        pub const RegDeleteValue = *opaque{};
        pub const RegEnumKey = *opaque{};
        pub const RegEnumKeyEx = *opaque{};
        pub const RegEnumValue = *opaque{};
        pub const RegLoadKey = *opaque{};
        pub const RegOpenKey = *opaque{};
        pub const RegOpenKeyEx = *opaque{};
        pub const RegOpenKeyTransacted = *opaque{};
        pub const RegQueryInfoKey = *opaque{};
        pub const RegQueryValue = *opaque{};
        pub const RegQueryMultipleValues = *opaque{};
        pub const RegQueryValueEx = *opaque{};
        pub const RegReplaceKey = *opaque{};
        pub const RegRestoreKey = *opaque{};
        pub const RegSaveKey = *opaque{};
        pub const RegSetValue = *opaque{};
        pub const RegSetValueEx = *opaque{};
        pub const RegUnLoadKey = *opaque{};
        pub const RegDeleteKeyValue = *opaque{};
        pub const RegSetKeyValue = *opaque{};
        pub const RegDeleteTree = *opaque{};
        pub const RegCopyTree = *opaque{};
        pub const RegGetValue = *opaque{};
        pub const RegLoadMUIString = *opaque{};
        pub const RegLoadAppKey = *opaque{};
        pub const RegSaveKeyEx = *opaque{};
    } else struct {
        pub const pvalue = @compileError("'pvalue' requires that UNICODE be set to true or false in the root module");
        pub const VALENT = @compileError("'VALENT' requires that UNICODE be set to true or false in the root module");
        pub const RegConnectRegistry = @compileError("'RegConnectRegistry' requires that UNICODE be set to true or false in the root module");
        pub const RegConnectRegistryEx = @compileError("'RegConnectRegistryEx' requires that UNICODE be set to true or false in the root module");
        pub const RegCreateKey = @compileError("'RegCreateKey' requires that UNICODE be set to true or false in the root module");
        pub const RegCreateKeyEx = @compileError("'RegCreateKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegCreateKeyTransacted = @compileError("'RegCreateKeyTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKey = @compileError("'RegDeleteKey' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKeyEx = @compileError("'RegDeleteKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKeyTransacted = @compileError("'RegDeleteKeyTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteValue = @compileError("'RegDeleteValue' requires that UNICODE be set to true or false in the root module");
        pub const RegEnumKey = @compileError("'RegEnumKey' requires that UNICODE be set to true or false in the root module");
        pub const RegEnumKeyEx = @compileError("'RegEnumKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegEnumValue = @compileError("'RegEnumValue' requires that UNICODE be set to true or false in the root module");
        pub const RegLoadKey = @compileError("'RegLoadKey' requires that UNICODE be set to true or false in the root module");
        pub const RegOpenKey = @compileError("'RegOpenKey' requires that UNICODE be set to true or false in the root module");
        pub const RegOpenKeyEx = @compileError("'RegOpenKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegOpenKeyTransacted = @compileError("'RegOpenKeyTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryInfoKey = @compileError("'RegQueryInfoKey' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryValue = @compileError("'RegQueryValue' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryMultipleValues = @compileError("'RegQueryMultipleValues' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryValueEx = @compileError("'RegQueryValueEx' requires that UNICODE be set to true or false in the root module");
        pub const RegReplaceKey = @compileError("'RegReplaceKey' requires that UNICODE be set to true or false in the root module");
        pub const RegRestoreKey = @compileError("'RegRestoreKey' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveKey = @compileError("'RegSaveKey' requires that UNICODE be set to true or false in the root module");
        pub const RegSetValue = @compileError("'RegSetValue' requires that UNICODE be set to true or false in the root module");
        pub const RegSetValueEx = @compileError("'RegSetValueEx' requires that UNICODE be set to true or false in the root module");
        pub const RegUnLoadKey = @compileError("'RegUnLoadKey' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKeyValue = @compileError("'RegDeleteKeyValue' requires that UNICODE be set to true or false in the root module");
        pub const RegSetKeyValue = @compileError("'RegSetKeyValue' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteTree = @compileError("'RegDeleteTree' requires that UNICODE be set to true or false in the root module");
        pub const RegCopyTree = @compileError("'RegCopyTree' requires that UNICODE be set to true or false in the root module");
        pub const RegGetValue = @compileError("'RegGetValue' requires that UNICODE be set to true or false in the root module");
        pub const RegLoadMUIString = @compileError("'RegLoadMUIString' requires that UNICODE be set to true or false in the root module");
        pub const RegLoadAppKey = @compileError("'RegLoadAppKey' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveKeyEx = @compileError("'RegSaveKeyEx' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const BOOL = @import("../foundation.zig").BOOL;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const LSTATUS = @import("../foundation.zig").LSTATUS;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;
const SECURITY_DESCRIPTOR = @import("../security.zig").SECURITY_DESCRIPTOR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PQUERYHANDLER")) { _ = PQUERYHANDLER; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
