//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1503)
//--------------------------------------------------------------------------------
pub const CERT_COMPARE_SHIFT = @as(i32, 16);
pub const BCRYPT_OBJECT_ALIGNMENT = @as(u32, 16);
pub const KDF_HASH_ALGORITHM = @as(u32, 0);
pub const KDF_SECRET_PREPEND = @as(u32, 1);
pub const KDF_SECRET_APPEND = @as(u32, 2);
pub const KDF_HMAC_KEY = @as(u32, 3);
pub const KDF_TLS_PRF_LABEL = @as(u32, 4);
pub const KDF_TLS_PRF_SEED = @as(u32, 5);
pub const KDF_SECRET_HANDLE = @as(u32, 6);
pub const KDF_TLS_PRF_PROTOCOL = @as(u32, 7);
pub const KDF_ALGORITHMID = @as(u32, 8);
pub const KDF_PARTYUINFO = @as(u32, 9);
pub const KDF_PARTYVINFO = @as(u32, 10);
pub const KDF_SUPPPUBINFO = @as(u32, 11);
pub const KDF_SUPPPRIVINFO = @as(u32, 12);
pub const KDF_LABEL = @as(u32, 13);
pub const KDF_CONTEXT = @as(u32, 14);
pub const KDF_SALT = @as(u32, 15);
pub const KDF_ITERATION_COUNT = @as(u32, 16);
pub const KDF_GENERIC_PARAMETER = @as(u32, 17);
pub const KDF_KEYBITLENGTH = @as(u32, 18);
pub const KDF_HKDF_SALT = @as(u32, 19);
pub const KDF_HKDF_INFO = @as(u32, 20);
pub const KDF_USE_SECRET_AS_HMAC_KEY_FLAG = @as(u32, 1);
pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION = @as(u32, 1);
pub const BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = @as(u32, 1);
pub const BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG = @as(u32, 2);
pub const BCRYPT_SUPPORTED_PAD_ROUTER = @as(u32, 1);
pub const BCRYPT_SUPPORTED_PAD_PKCS1_ENC = @as(u32, 2);
pub const BCRYPT_SUPPORTED_PAD_PKCS1_SIG = @as(u32, 4);
pub const BCRYPT_SUPPORTED_PAD_OAEP = @as(u32, 8);
pub const BCRYPT_SUPPORTED_PAD_PSS = @as(u32, 16);
pub const BCRYPT_BLOCK_PADDING = @as(u32, 1);
pub const BCRYPT_GENERATE_IV = @as(u32, 32);
pub const BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID = @as(u32, 16);
pub const BCRYPTBUFFER_VERSION = @as(u32, 0);
pub const BCRYPT_ECDH_PUBLIC_P256_MAGIC = @as(u32, 827016005);
pub const BCRYPT_ECDH_PRIVATE_P256_MAGIC = @as(u32, 843793221);
pub const BCRYPT_ECDH_PUBLIC_P384_MAGIC = @as(u32, 860570437);
pub const BCRYPT_ECDH_PRIVATE_P384_MAGIC = @as(u32, 877347653);
pub const BCRYPT_ECDH_PUBLIC_P521_MAGIC = @as(u32, 894124869);
pub const BCRYPT_ECDH_PRIVATE_P521_MAGIC = @as(u32, 910902085);
pub const BCRYPT_ECDH_PUBLIC_GENERIC_MAGIC = @as(u32, 1347109701);
pub const BCRYPT_ECDH_PRIVATE_GENERIC_MAGIC = @as(u32, 1447772997);
pub const BCRYPT_ECDSA_PUBLIC_P256_MAGIC = @as(u32, 827540293);
pub const BCRYPT_ECDSA_PRIVATE_P256_MAGIC = @as(u32, 844317509);
pub const BCRYPT_ECDSA_PUBLIC_P384_MAGIC = @as(u32, 861094725);
pub const BCRYPT_ECDSA_PRIVATE_P384_MAGIC = @as(u32, 877871941);
pub const BCRYPT_ECDSA_PUBLIC_P521_MAGIC = @as(u32, 894649157);
pub const BCRYPT_ECDSA_PRIVATE_P521_MAGIC = @as(u32, 911426373);
pub const BCRYPT_ECDSA_PUBLIC_GENERIC_MAGIC = @as(u32, 1346650949);
pub const BCRYPT_ECDSA_PRIVATE_GENERIC_MAGIC = @as(u32, 1447314245);
pub const BCRYPT_ECC_FULLKEY_BLOB_V1 = @as(u32, 1);
pub const BCRYPT_DH_PARAMETERS_MAGIC = @as(u32, 1297107012);
pub const BCRYPT_DSA_PUBLIC_MAGIC_V2 = @as(u32, 843206724);
pub const BCRYPT_DSA_PRIVATE_MAGIC_V2 = @as(u32, 844517444);
pub const BCRYPT_KEY_DATA_BLOB_MAGIC = @as(u32, 1296188491);
pub const BCRYPT_KEY_DATA_BLOB_VERSION1 = @as(u32, 1);
pub const BCRYPT_DSA_PARAMETERS_MAGIC = @as(u32, 1297109828);
pub const BCRYPT_DSA_PARAMETERS_MAGIC_V2 = @as(u32, 843927620);
pub const BCRYPT_ECC_PARAMETERS_MAGIC = @as(u32, 1346585413);
pub const BCRYPT_KEY_DERIVATION_INTERFACE = @as(u32, 7);
pub const BCRYPT_MD2_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 1));
pub const BCRYPT_MD4_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 17));
pub const BCRYPT_MD5_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 33));
pub const BCRYPT_SHA1_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 49));
pub const BCRYPT_SHA256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 65));
pub const BCRYPT_SHA384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 81));
pub const BCRYPT_SHA512_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 97));
pub const BCRYPT_RC4_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 113));
pub const BCRYPT_RNG_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 129));
pub const BCRYPT_HMAC_MD5_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 145));
pub const BCRYPT_HMAC_SHA1_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 161));
pub const BCRYPT_HMAC_SHA256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 177));
pub const BCRYPT_HMAC_SHA384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 193));
pub const BCRYPT_HMAC_SHA512_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 209));
pub const BCRYPT_RSA_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 225));
pub const BCRYPT_ECDSA_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 241));
pub const BCRYPT_AES_CMAC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 257));
pub const BCRYPT_AES_GMAC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 273));
pub const BCRYPT_HMAC_MD2_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 289));
pub const BCRYPT_HMAC_MD4_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 305));
pub const BCRYPT_3DES_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 321));
pub const BCRYPT_3DES_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 337));
pub const BCRYPT_3DES_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 353));
pub const BCRYPT_3DES_112_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 369));
pub const BCRYPT_3DES_112_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 385));
pub const BCRYPT_3DES_112_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 401));
pub const BCRYPT_AES_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 417));
pub const BCRYPT_AES_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 433));
pub const BCRYPT_AES_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 449));
pub const BCRYPT_AES_CCM_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 465));
pub const BCRYPT_AES_GCM_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 481));
pub const BCRYPT_DES_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 497));
pub const BCRYPT_DES_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 513));
pub const BCRYPT_DES_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 529));
pub const BCRYPT_DESX_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 545));
pub const BCRYPT_DESX_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 561));
pub const BCRYPT_DESX_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 577));
pub const BCRYPT_RC2_CBC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 593));
pub const BCRYPT_RC2_ECB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 609));
pub const BCRYPT_RC2_CFB_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 625));
pub const BCRYPT_DH_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 641));
pub const BCRYPT_ECDH_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 657));
pub const BCRYPT_ECDH_P256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 673));
pub const BCRYPT_ECDH_P384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 689));
pub const BCRYPT_ECDH_P521_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 705));
pub const BCRYPT_DSA_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 721));
pub const BCRYPT_ECDSA_P256_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 737));
pub const BCRYPT_ECDSA_P384_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 753));
pub const BCRYPT_ECDSA_P521_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 769));
pub const BCRYPT_RSA_SIGN_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 785));
pub const BCRYPT_CAPI_KDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 801));
pub const BCRYPT_PBKDF2_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 817));
pub const BCRYPT_SP800108_CTR_HMAC_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 833));
pub const BCRYPT_SP80056A_CONCAT_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 849));
pub const BCRYPT_TLS1_1_KDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 865));
pub const BCRYPT_TLS1_2_KDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 881));
pub const BCRYPT_XTS_AES_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 897));
pub const BCRYPT_HKDF_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 913));
pub const BCRYPT_CHACHA20_POLY1305_ALG_HANDLE = @import("../zig.zig").typedConst(BCRYPT_ALG_HANDLE, @as(u32, 929));
pub const BCRYPT_CAPI_AES_FLAG = @as(u32, 16);
pub const BCRYPT_MULTI_FLAG = @as(u32, 64);
pub const BCRYPT_TLS_CBC_HMAC_VERIFY_FLAG = @as(u32, 4);
pub const BCRYPT_BUFFERS_LOCKED_FLAG = @as(u32, 64);
pub const BCRYPT_EXTENDED_KEYSIZE = @as(u32, 128);
pub const BCRYPT_ENABLE_INCOMPATIBLE_FIPS_CHECKS = @as(u32, 256);
pub const BCRYPT_KEY_DERIVATION_OPERATION = @as(u32, 64);
pub const BCRYPT_PUBLIC_KEY_FLAG = @as(u32, 1);
pub const BCRYPT_PRIVATE_KEY_FLAG = @as(u32, 2);
pub const BCRYPT_NO_KEY_VALIDATION = @as(u32, 8);
pub const BCRYPT_KEY_VALIDATION_RANGE = @as(u32, 16);
pub const BCRYPT_KEY_VALIDATION_RANGE_AND_ORDER = @as(u32, 24);
pub const BCRYPT_KEY_VALIDATION_REGENERATE = @as(u32, 32);
pub const BCRYPT_RNG_USE_ENTROPY_IN_BUFFER = @as(u32, 1);
pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG = @as(u32, 2);
pub const BCRYPT_HASH_INTERFACE_MAJORVERSION_2 = @as(u32, 2);
pub const CRYPT_OVERWRITE = @as(u32, 1);
pub const CRYPT_PRIORITY_TOP = @as(u32, 0);
pub const CRYPT_PRIORITY_BOTTOM = @as(u32, 4294967295);
pub const CRYPT_XML_BLOB_MAX = @as(u32, 2147483640);
pub const CRYPT_XML_ID_MAX = @as(u32, 256);
pub const CRYPT_XML_SIGNATURES_MAX = @as(u32, 16);
pub const CRYPT_XML_TRANSFORM_MAX = @as(u32, 16);
pub const CRYPT_XML_SIGNATURE_VALUE_MAX = @as(u32, 2048);
pub const CRYPT_XML_DIGEST_VALUE_MAX = @as(u32, 128);
pub const CRYPT_XML_OBJECTS_MAX = @as(u32, 256);
pub const CRYPT_XML_REFERENCES_MAX = @as(u32, 32760);
pub const CRYPT_XML_E_BASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885376));
pub const CRYPT_XML_E_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885375));
pub const CRYPT_XML_E_TOO_MANY_TRANSFORMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885374));
pub const CRYPT_XML_E_ENCODING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885373));
pub const CRYPT_XML_E_ALGORITHM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885372));
pub const CRYPT_XML_E_TRANSFORM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885371));
pub const CRYPT_XML_E_HANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885370));
pub const CRYPT_XML_E_OPERATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885369));
pub const CRYPT_XML_E_UNRESOLVED_REFERENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885368));
pub const CRYPT_XML_E_INVALID_DIGEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885367));
pub const CRYPT_XML_E_INVALID_SIGNATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885366));
pub const CRYPT_XML_E_HASH_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885365));
pub const CRYPT_XML_E_SIGN_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885364));
pub const CRYPT_XML_E_VERIFY_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885363));
pub const CRYPT_XML_E_TOO_MANY_SIGNATURES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885362));
pub const CRYPT_XML_E_INVALID_KEYVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885361));
pub const CRYPT_XML_E_UNEXPECTED_XML = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885360));
pub const CRYPT_XML_E_SIGNER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885359));
pub const CRYPT_XML_E_NON_UNIQUE_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885358));
pub const CRYPT_XML_E_LAST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2146885358));
pub const CRYPT_XML_FLAG_ALWAYS_RETURN_ENCODED_OBJECT = @as(u32, 1073741824);
pub const CRYPT_XML_FLAG_ENFORCE_ID_NCNAME_FORMAT = @as(u32, 536870912);
pub const CRYPT_XML_FLAG_ENFORCE_ID_NAME_FORMAT = @as(u32, 134217728);
pub const CRYPT_XML_FLAG_ECDSA_DSIG11 = @as(u32, 67108864);
pub const CRYPT_XML_STATUS_NO_ERROR = @as(u32, 0);
pub const CRYPT_XML_FLAG_ADD_OBJECT_CREATE_COPY = @as(u32, 1);
pub const CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT = @as(u32, 1);
pub const CRYPT_XML_DIGEST_REFERENCE_DATA_TRANSFORMED = @as(u32, 1);
pub const CRYPT_XML_GROUP_ID_HASH = @as(u32, 1);
pub const CRYPT_XML_GROUP_ID_SIGN = @as(u32, 2);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_URI = @as(u32, 1);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_NAME = @as(u32, 2);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_ALGID = @as(u32, 3);
pub const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_SIGN_ALGID = @as(u32, 4);
pub const CRYPTPROTECT_PROMPT_ON_UNPROTECT = @as(u32, 1);
pub const CRYPTPROTECT_PROMPT_ON_PROTECT = @as(u32, 2);
pub const CRYPTPROTECT_PROMPT_RESERVED = @as(u32, 4);
pub const CRYPTPROTECT_PROMPT_STRONG = @as(u32, 8);
pub const CRYPTPROTECT_PROMPT_REQUIRE_STRONG = @as(u32, 16);
pub const CRYPTPROTECT_UI_FORBIDDEN = @as(u32, 1);
pub const CRYPTPROTECT_LOCAL_MACHINE = @as(u32, 4);
pub const CRYPTPROTECT_CRED_SYNC = @as(u32, 8);
pub const CRYPTPROTECT_AUDIT = @as(u32, 16);
pub const CRYPTPROTECT_NO_RECOVERY = @as(u32, 32);
pub const CRYPTPROTECT_VERIFY_PROTECTION = @as(u32, 64);
pub const CRYPTPROTECT_CRED_REGENERATE = @as(u32, 128);
pub const CRYPTPROTECT_FIRST_RESERVED_FLAGVAL = @as(u32, 268435455);
pub const CRYPTPROTECT_LAST_RESERVED_FLAGVAL = @as(u32, 4294967295);
pub const CRYPTPROTECTMEMORY_BLOCK_SIZE = @as(u32, 16);
pub const CRYPTPROTECTMEMORY_SAME_PROCESS = @as(u32, 0);
pub const CRYPTPROTECTMEMORY_CROSS_PROCESS = @as(u32, 1);
pub const CRYPTPROTECTMEMORY_SAME_LOGON = @as(u32, 2);
pub const NCRYPT_MAX_KEY_NAME_LENGTH = @as(u32, 512);
pub const NCRYPT_MAX_ALG_ID_LENGTH = @as(u32, 512);
pub const NCRYPT_KEY_DERIVATION_INTERFACE = @as(u32, 7);
pub const NCRYPT_KEY_PROTECTION_INTERFACE = @as(u32, 65540);
pub const NCRYPTBUFFER_VERSION = @as(u32, 0);
pub const NCRYPTBUFFER_EMPTY = @as(u32, 0);
pub const NCRYPTBUFFER_DATA = @as(u32, 1);
pub const NCRYPTBUFFER_PROTECTION_DESCRIPTOR_STRING = @as(u32, 3);
pub const NCRYPTBUFFER_PROTECTION_FLAGS = @as(u32, 4);
pub const NCRYPTBUFFER_SSL_CLIENT_RANDOM = @as(u32, 20);
pub const NCRYPTBUFFER_SSL_SERVER_RANDOM = @as(u32, 21);
pub const NCRYPTBUFFER_SSL_HIGHEST_VERSION = @as(u32, 22);
pub const NCRYPTBUFFER_SSL_CLEAR_KEY = @as(u32, 23);
pub const NCRYPTBUFFER_SSL_KEY_ARG_DATA = @as(u32, 24);
pub const NCRYPTBUFFER_SSL_SESSION_HASH = @as(u32, 25);
pub const NCRYPTBUFFER_PKCS_OID = @as(u32, 40);
pub const NCRYPTBUFFER_PKCS_ALG_OID = @as(u32, 41);
pub const NCRYPTBUFFER_PKCS_ALG_PARAM = @as(u32, 42);
pub const NCRYPTBUFFER_PKCS_ALG_ID = @as(u32, 43);
pub const NCRYPTBUFFER_PKCS_ATTRS = @as(u32, 44);
pub const NCRYPTBUFFER_PKCS_KEY_NAME = @as(u32, 45);
pub const NCRYPTBUFFER_PKCS_SECRET = @as(u32, 46);
pub const NCRYPTBUFFER_CERT_BLOB = @as(u32, 47);
pub const NCRYPTBUFFER_CLAIM_IDBINDING_NONCE = @as(u32, 48);
pub const NCRYPTBUFFER_CLAIM_KEYATTESTATION_NONCE = @as(u32, 49);
pub const NCRYPTBUFFER_KEY_PROPERTY_FLAGS = @as(u32, 50);
pub const NCRYPTBUFFER_ATTESTATIONSTATEMENT_BLOB = @as(u32, 51);
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_TYPE = @as(u32, 52);
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_CHALLENGE_REQUIRED = @as(u32, 53);
pub const NCRYPTBUFFER_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = @as(u32, 54);
pub const NCRYPTBUFFER_ECC_CURVE_NAME = @as(u32, 60);
pub const NCRYPTBUFFER_ECC_PARAMETERS = @as(u32, 61);
pub const NCRYPTBUFFER_TPM_SEAL_PASSWORD = @as(u32, 70);
pub const NCRYPTBUFFER_TPM_SEAL_POLICYINFO = @as(u32, 71);
pub const NCRYPTBUFFER_TPM_SEAL_TICKET = @as(u32, 72);
pub const NCRYPTBUFFER_TPM_SEAL_NO_DA_PROTECTION = @as(u32, 73);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_PCR_MASK = @as(u32, 80);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_NONCE = @as(u32, 81);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_STATIC_CREATE = @as(u32, 82);
pub const NCRYPT_CIPHER_NO_PADDING_FLAG = @as(u32, 0);
pub const NCRYPT_CIPHER_BLOCK_PADDING_FLAG = @as(u32, 1);
pub const NCRYPT_CIPHER_OTHER_PADDING_FLAG = @as(u32, 2);
pub const NCRYPT_PLATFORM_ATTEST_MAGIC = @as(u32, 1146110288);
pub const NCRYPT_KEY_ATTEST_MAGIC = @as(u32, 1146110283);
pub const NCRYPT_CLAIM_AUTHORITY_ONLY = @as(u32, 1);
pub const NCRYPT_CLAIM_SUBJECT_ONLY = @as(u32, 2);
pub const NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY = @as(u32, 258);
pub const NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT = @as(u32, 3);
pub const NCRYPT_CLAIM_VSM_KEY_ATTESTATION_STATEMENT = @as(u32, 4);
pub const NCRYPT_CLAIM_UNKNOWN = @as(u32, 4096);
pub const NCRYPT_CLAIM_PLATFORM = @as(u32, 65536);
pub const NCRYPT_ISOLATED_KEY_FLAG_CREATED_IN_ISOLATION = @as(u32, 1);
pub const NCRYPT_ISOLATED_KEY_FLAG_IMPORT_ONLY = @as(u32, 2);
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0 = @as(u32, 0);
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_V0 = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_V0 = @as(u32, 0);
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0 = @as(u32, 0);
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0 = @as(u32, 0);
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_CURRENT_VERSION = @as(u32, 0);
pub const NCRYPT_PAD_CIPHER_FLAG = @as(u32, 16);
pub const NCRYPT_ATTESTATION_FLAG = @as(u32, 32);
pub const NCRYPT_SEALING_FLAG = @as(u32, 256);
pub const NCRYPT_DO_NOT_FINALIZE_FLAG = @as(u32, 1024);
pub const NCRYPT_EXPORT_LEGACY_FLAG = @as(u32, 2048);
pub const NCRYPT_IGNORE_DEVICE_STATE_FLAG = @as(u32, 4096);
pub const NCRYPT_TREAT_NIST_AS_GENERIC_ECC_FLAG = @as(u32, 8192);
pub const NCRYPT_NO_CACHED_PASSWORD = @as(u32, 16384);
pub const NCRYPT_PROTECT_TO_LOCAL_SYSTEM = @as(u32, 32768);
pub const NCRYPT_PREFER_VIRTUAL_ISOLATION_FLAG = @as(u32, 65536);
pub const NCRYPT_USE_VIRTUAL_ISOLATION_FLAG = @as(u32, 131072);
pub const NCRYPT_USE_PER_BOOT_KEY_FLAG = @as(u32, 262144);
pub const NCRYPT_KEY_DERIVATION_OPERATION = @as(u32, 64);
pub const NCRYPT_AUTHORITY_KEY_FLAG = @as(u32, 256);
pub const IFX_RSA_KEYGEN_VUL_NOT_AFFECTED = @as(u32, 0);
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_1 = @as(u32, 1);
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_2 = @as(u32, 2);
pub const NCRYPT_TPM_PSS_SALT_SIZE_UNKNOWN = @as(u32, 0);
pub const NCRYPT_TPM_PSS_SALT_SIZE_MAXIMUM = @as(u32, 1);
pub const NCRYPT_TPM_PSS_SALT_SIZE_HASHSIZE = @as(u32, 2);
pub const NCRYPT_TPM_PAD_PSS_IGNORE_SALT = @as(u32, 32);
pub const NCRYPT_TPM12_PROVIDER = @as(u32, 65536);
pub const NCRYPT_PCP_SIGNATURE_KEY = @as(u32, 1);
pub const NCRYPT_PCP_ENCRYPTION_KEY = @as(u32, 2);
pub const NCRYPT_PCP_STORAGE_KEY = @as(u32, 4);
pub const NCRYPT_PCP_IDENTITY_KEY = @as(u32, 8);
pub const NCRYPT_PCP_HMACVERIFICATION_KEY = @as(u32, 16);
pub const NCRYPT_MAX_PROPERTY_NAME = @as(u32, 64);
pub const NCRYPT_MAX_PROPERTY_DATA = @as(u32, 1048576);
pub const NCRYPT_ALLOW_EXPORT_FLAG = @as(u32, 1);
pub const NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG = @as(u32, 2);
pub const NCRYPT_ALLOW_ARCHIVING_FLAG = @as(u32, 4);
pub const NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG = @as(u32, 8);
pub const NCRYPT_IMPL_HARDWARE_FLAG = @as(u32, 1);
pub const NCRYPT_IMPL_SOFTWARE_FLAG = @as(u32, 2);
pub const NCRYPT_IMPL_REMOVABLE_FLAG = @as(u32, 8);
pub const NCRYPT_IMPL_HARDWARE_RNG_FLAG = @as(u32, 16);
pub const NCRYPT_IMPL_VIRTUAL_ISOLATION_FLAG = @as(u32, 32);
pub const NCRYPT_ALLOW_DECRYPT_FLAG = @as(u32, 1);
pub const NCRYPT_ALLOW_SIGNING_FLAG = @as(u32, 2);
pub const NCRYPT_ALLOW_KEY_AGREEMENT_FLAG = @as(u32, 4);
pub const NCRYPT_ALLOW_KEY_IMPORT_FLAG = @as(u32, 8);
pub const NCRYPT_ALLOW_ALL_USAGES = @as(u32, 16777215);
pub const NCRYPT_UI_PROTECT_KEY_FLAG = @as(u32, 1);
pub const NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG = @as(u32, 2);
pub const NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG = @as(u32, 4);
pub const NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG = @as(u32, 8);
pub const NCRYPT_PIN_CACHE_DISABLE_DPL_FLAG = @as(u32, 1);
pub const NCRYPT_PIN_CACHE_REQUIRE_GESTURE_FLAG = @as(u32, 1);
pub const NCRYPT_PIN_CACHE_APPLICATION_TICKET_BYTE_LENGTH = @as(u32, 90);
pub const NCRYPT_PIN_CACHE_CLEAR_FOR_CALLING_PROCESS_OPTION = @as(u32, 1);
pub const NCRYPT_KEY_ACCESS_POLICY_VERSION = @as(u32, 1);
pub const NCRYPT_ALLOW_SILENT_KEY_ACCESS = @as(u32, 1);
pub const NCRYPT_CIPHER_KEY_BLOB_MAGIC = @as(u32, 1380470851);
pub const NCRYPT_KDF_KEY_BLOB_MAGIC = @as(u32, 826688587);
pub const NCRYPT_PROTECTED_KEY_BLOB_MAGIC = @as(u32, 1263817296);
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_MAGIC = @as(u32, 1297371211);
pub const NCRYPT_NAMED_DESCRIPTOR_FLAG = @as(u32, 1);
pub const NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING = @as(u32, 1);
pub const ALG_CLASS_ANY = @as(u32, 0);
pub const ALG_CLASS_SIGNATURE = @as(u32, 8192);
pub const ALG_CLASS_MSG_ENCRYPT = @as(u32, 16384);
pub const ALG_CLASS_DATA_ENCRYPT = @as(u32, 24576);
pub const ALG_CLASS_HASH = @as(u32, 32768);
pub const ALG_CLASS_KEY_EXCHANGE = @as(u32, 40960);
pub const ALG_CLASS_ALL = @as(u32, 57344);
pub const ALG_TYPE_ANY = @as(u32, 0);
pub const ALG_TYPE_DSS = @as(u32, 512);
pub const ALG_TYPE_RSA = @as(u32, 1024);
pub const ALG_TYPE_BLOCK = @as(u32, 1536);
pub const ALG_TYPE_STREAM = @as(u32, 2048);
pub const ALG_TYPE_DH = @as(u32, 2560);
pub const ALG_TYPE_SECURECHANNEL = @as(u32, 3072);
pub const ALG_TYPE_ECDH = @as(u32, 3584);
pub const ALG_TYPE_THIRDPARTY = @as(u32, 4096);
pub const ALG_SID_ANY = @as(u32, 0);
pub const ALG_SID_THIRDPARTY_ANY = @as(u32, 0);
pub const ALG_SID_RSA_ANY = @as(u32, 0);
pub const ALG_SID_RSA_PKCS = @as(u32, 1);
pub const ALG_SID_RSA_MSATWORK = @as(u32, 2);
pub const ALG_SID_RSA_ENTRUST = @as(u32, 3);
pub const ALG_SID_RSA_PGP = @as(u32, 4);
pub const ALG_SID_DSS_ANY = @as(u32, 0);
pub const ALG_SID_DSS_PKCS = @as(u32, 1);
pub const ALG_SID_DSS_DMS = @as(u32, 2);
pub const ALG_SID_ECDSA = @as(u32, 3);
pub const ALG_SID_DES = @as(u32, 1);
pub const ALG_SID_3DES = @as(u32, 3);
pub const ALG_SID_DESX = @as(u32, 4);
pub const ALG_SID_IDEA = @as(u32, 5);
pub const ALG_SID_CAST = @as(u32, 6);
pub const ALG_SID_SAFERSK64 = @as(u32, 7);
pub const ALG_SID_SAFERSK128 = @as(u32, 8);
pub const ALG_SID_3DES_112 = @as(u32, 9);
pub const ALG_SID_CYLINK_MEK = @as(u32, 12);
pub const ALG_SID_RC5 = @as(u32, 13);
pub const ALG_SID_AES_128 = @as(u32, 14);
pub const ALG_SID_AES_192 = @as(u32, 15);
pub const ALG_SID_AES_256 = @as(u32, 16);
pub const ALG_SID_AES = @as(u32, 17);
pub const ALG_SID_SKIPJACK = @as(u32, 10);
pub const ALG_SID_TEK = @as(u32, 11);
pub const CRYPT_MODE_CBCI = @as(u32, 6);
pub const CRYPT_MODE_CFBP = @as(u32, 7);
pub const CRYPT_MODE_OFBP = @as(u32, 8);
pub const CRYPT_MODE_CBCOFM = @as(u32, 9);
pub const CRYPT_MODE_CBCOFMI = @as(u32, 10);
pub const ALG_SID_RC2 = @as(u32, 2);
pub const ALG_SID_RC4 = @as(u32, 1);
pub const ALG_SID_SEAL = @as(u32, 2);
pub const ALG_SID_DH_SANDF = @as(u32, 1);
pub const ALG_SID_DH_EPHEM = @as(u32, 2);
pub const ALG_SID_AGREED_KEY_ANY = @as(u32, 3);
pub const ALG_SID_KEA = @as(u32, 4);
pub const ALG_SID_ECDH = @as(u32, 5);
pub const ALG_SID_ECDH_EPHEM = @as(u32, 6);
pub const ALG_SID_MD2 = @as(u32, 1);
pub const ALG_SID_MD4 = @as(u32, 2);
pub const ALG_SID_MD5 = @as(u32, 3);
pub const ALG_SID_SHA = @as(u32, 4);
pub const ALG_SID_SHA1 = @as(u32, 4);
pub const ALG_SID_MAC = @as(u32, 5);
pub const ALG_SID_RIPEMD = @as(u32, 6);
pub const ALG_SID_RIPEMD160 = @as(u32, 7);
pub const ALG_SID_SSL3SHAMD5 = @as(u32, 8);
pub const ALG_SID_HMAC = @as(u32, 9);
pub const ALG_SID_TLS1PRF = @as(u32, 10);
pub const ALG_SID_HASH_REPLACE_OWF = @as(u32, 11);
pub const ALG_SID_SHA_256 = @as(u32, 12);
pub const ALG_SID_SHA_384 = @as(u32, 13);
pub const ALG_SID_SHA_512 = @as(u32, 14);
pub const ALG_SID_SSL3_MASTER = @as(u32, 1);
pub const ALG_SID_SCHANNEL_MASTER_HASH = @as(u32, 2);
pub const ALG_SID_SCHANNEL_MAC_KEY = @as(u32, 3);
pub const ALG_SID_PCT1_MASTER = @as(u32, 4);
pub const ALG_SID_SSL2_MASTER = @as(u32, 5);
pub const ALG_SID_TLS1_MASTER = @as(u32, 6);
pub const ALG_SID_SCHANNEL_ENC_KEY = @as(u32, 7);
pub const ALG_SID_ECMQV = @as(u32, 1);
pub const ALG_SID_EXAMPLE = @as(u32, 80);
pub const SIGNATURE_RESOURCE_NUMBER = @as(u32, 666);
pub const CRYPT_VERIFYCONTEXT = @as(u32, 4026531840);
pub const CRYPT_NEWKEYSET = @as(u32, 8);
pub const CRYPT_DELETEKEYSET = @as(u32, 16);
pub const CRYPT_SILENT = @as(u32, 64);
pub const CRYPT_DEFAULT_CONTAINER_OPTIONAL = @as(u32, 128);
pub const CRYPT_UPDATE_KEY = @as(u32, 8);
pub const CRYPT_USER_PROTECTED_STRONG = @as(u32, 1048576);
pub const RSA1024BIT_KEY = @as(u32, 67108864);
pub const CRYPT_SERVER = @as(u32, 1024);
pub const KEY_LENGTH_MASK = @as(u32, 4294901760);
pub const CRYPT_DECRYPT_RSA_NO_PADDING_CHECK = @as(u32, 32);
pub const CRYPT_SECRETDIGEST = @as(u32, 1);
pub const CRYPT_OWF_REPL_LM_HASH = @as(u32, 1);
pub const CRYPT_LITTLE_ENDIAN = @as(u32, 1);
pub const CRYPT_NOHASHOID = @as(u32, 1);
pub const CRYPT_TYPE2_FORMAT = @as(u32, 2);
pub const CRYPT_X931_FORMAT = @as(u32, 4);
pub const CRYPT_MACHINE_DEFAULT = @as(u32, 1);
pub const CRYPT_USER_DEFAULT = @as(u32, 2);
pub const CRYPT_DELETE_DEFAULT = @as(u32, 4);
pub const SIMPLEBLOB = @as(u32, 1);
pub const PUBLICKEYBLOB = @as(u32, 6);
pub const PRIVATEKEYBLOB = @as(u32, 7);
pub const PLAINTEXTKEYBLOB = @as(u32, 8);
pub const OPAQUEKEYBLOB = @as(u32, 9);
pub const PUBLICKEYBLOBEX = @as(u32, 10);
pub const SYMMETRICWRAPKEYBLOB = @as(u32, 11);
pub const KEYSTATEBLOB = @as(u32, 12);
pub const CRYPT_USERDATA = @as(u32, 1);
pub const KP_IV = @as(u32, 1);
pub const KP_PADDING = @as(u32, 3);
pub const KP_MODE = @as(u32, 4);
pub const KP_MODE_BITS = @as(u32, 5);
pub const KP_P = @as(u32, 11);
pub const KP_G = @as(u32, 12);
pub const KP_Q = @as(u32, 13);
pub const KP_X = @as(u32, 14);
pub const KP_Y = @as(u32, 15);
pub const KP_RA = @as(u32, 16);
pub const KP_RB = @as(u32, 17);
pub const KP_INFO = @as(u32, 18);
pub const KP_EFFECTIVE_KEYLEN = @as(u32, 19);
pub const KP_SCHANNEL_ALG = @as(u32, 20);
pub const KP_CLIENT_RANDOM = @as(u32, 21);
pub const KP_SERVER_RANDOM = @as(u32, 22);
pub const KP_RP = @as(u32, 23);
pub const KP_PRECOMP_MD5 = @as(u32, 24);
pub const KP_PRECOMP_SHA = @as(u32, 25);
pub const KP_CLEAR_KEY = @as(u32, 27);
pub const KP_PUB_EX_LEN = @as(u32, 28);
pub const KP_PUB_EX_VAL = @as(u32, 29);
pub const KP_KEYVAL = @as(u32, 30);
pub const KP_ADMIN_PIN = @as(u32, 31);
pub const KP_KEYEXCHANGE_PIN = @as(u32, 32);
pub const KP_SIGNATURE_PIN = @as(u32, 33);
pub const KP_PREHASH = @as(u32, 34);
pub const KP_ROUNDS = @as(u32, 35);
pub const KP_OAEP_PARAMS = @as(u32, 36);
pub const KP_CMS_KEY_INFO = @as(u32, 37);
pub const KP_CMS_DH_KEY_INFO = @as(u32, 38);
pub const KP_PUB_PARAMS = @as(u32, 39);
pub const KP_VERIFY_PARAMS = @as(u32, 40);
pub const KP_HIGHEST_VERSION = @as(u32, 41);
pub const KP_PIN_ID = @as(u32, 43);
pub const KP_PIN_INFO = @as(u32, 44);
pub const PKCS5_PADDING = @as(u32, 1);
pub const RANDOM_PADDING = @as(u32, 2);
pub const ZERO_PADDING = @as(u32, 3);
pub const CRYPT_MODE_CBC = @as(u32, 1);
pub const CRYPT_MODE_ECB = @as(u32, 2);
pub const CRYPT_MODE_OFB = @as(u32, 3);
pub const CRYPT_MODE_CFB = @as(u32, 4);
pub const CRYPT_MODE_CTS = @as(u32, 5);
pub const CRYPT_ENCRYPT = @as(u32, 1);
pub const CRYPT_DECRYPT = @as(u32, 2);
pub const CRYPT_EXPORT = @as(u32, 4);
pub const CRYPT_READ = @as(u32, 8);
pub const CRYPT_WRITE = @as(u32, 16);
pub const CRYPT_MAC = @as(u32, 32);
pub const CRYPT_EXPORT_KEY = @as(u32, 64);
pub const CRYPT_IMPORT_KEY = @as(u32, 128);
pub const CRYPT_ARCHIVE = @as(u32, 256);
pub const HP_ALGID = @as(u32, 1);
pub const HP_HASHSIZE = @as(u32, 4);
pub const HP_TLS1PRF_LABEL = @as(u32, 6);
pub const HP_TLS1PRF_SEED = @as(u32, 7);
pub const CRYPT_FAILED = @as(u32, 0);
pub const CRYPT_SUCCEED = @as(u32, 1);
pub const PP_ENUMALGS = @as(u32, 1);
pub const PP_ENUMCONTAINERS = @as(u32, 2);
pub const PP_IMPTYPE = @as(u32, 3);
pub const PP_NAME = @as(u32, 4);
pub const PP_VERSION = @as(u32, 5);
pub const PP_CONTAINER = @as(u32, 6);
pub const PP_CHANGE_PASSWORD = @as(u32, 7);
pub const PP_CERTCHAIN = @as(u32, 9);
pub const PP_KEY_TYPE_SUBTYPE = @as(u32, 10);
pub const PP_PROVTYPE = @as(u32, 16);
pub const PP_KEYSTORAGE = @as(u32, 17);
pub const PP_APPLI_CERT = @as(u32, 18);
pub const PP_SYM_KEYSIZE = @as(u32, 19);
pub const PP_SESSION_KEYSIZE = @as(u32, 20);
pub const PP_ENUMALGS_EX = @as(u32, 22);
pub const PP_ENUMMANDROOTS = @as(u32, 25);
pub const PP_ENUMELECTROOTS = @as(u32, 26);
pub const PP_KEYSET_TYPE = @as(u32, 27);
pub const PP_ADMIN_PIN = @as(u32, 31);
pub const PP_SIG_KEYSIZE_INC = @as(u32, 34);
pub const PP_KEYX_KEYSIZE_INC = @as(u32, 35);
pub const PP_UNIQUE_CONTAINER = @as(u32, 36);
pub const PP_SGC_INFO = @as(u32, 37);
pub const PP_KEYSPEC = @as(u32, 39);
pub const PP_ENUMEX_SIGNING_PROT = @as(u32, 40);
pub const PP_CRYPT_COUNT_KEY_USE = @as(u32, 41);
pub const PP_SMARTCARD_GUID = @as(u32, 45);
pub const PP_SMARTCARD_READER_ICON = @as(u32, 47);
pub const CRYPT_FIRST = @as(u32, 1);
pub const CRYPT_NEXT = @as(u32, 2);
pub const CRYPT_SGC_ENUM = @as(u32, 4);
pub const CRYPT_IMPL_HARDWARE = @as(u32, 1);
pub const CRYPT_IMPL_SOFTWARE = @as(u32, 2);
pub const CRYPT_IMPL_MIXED = @as(u32, 3);
pub const CRYPT_IMPL_UNKNOWN = @as(u32, 4);
pub const CRYPT_IMPL_REMOVABLE = @as(u32, 8);
pub const CRYPT_SEC_DESCR = @as(u32, 1);
pub const CRYPT_PSTORE = @as(u32, 2);
pub const CRYPT_UI_PROMPT = @as(u32, 4);
pub const CRYPT_FLAG_PCT1 = @as(u32, 1);
pub const CRYPT_FLAG_SSL2 = @as(u32, 2);
pub const CRYPT_FLAG_SSL3 = @as(u32, 4);
pub const CRYPT_FLAG_TLS1 = @as(u32, 8);
pub const CRYPT_FLAG_IPSEC = @as(u32, 16);
pub const CRYPT_FLAG_SIGNING = @as(u32, 32);
pub const CRYPT_SGC = @as(u32, 1);
pub const CRYPT_FASTSGC = @as(u32, 2);
pub const PP_CONTEXT_INFO = @as(u32, 11);
pub const PP_DISMISS_PIN_UI_SEC = @as(u32, 49);
pub const PROV_RSA_FULL = @as(u32, 1);
pub const PROV_RSA_SIG = @as(u32, 2);
pub const PROV_DSS = @as(u32, 3);
pub const PROV_FORTEZZA = @as(u32, 4);
pub const PROV_MS_EXCHANGE = @as(u32, 5);
pub const PROV_SSL = @as(u32, 6);
pub const PROV_RSA_SCHANNEL = @as(u32, 12);
pub const PROV_DSS_DH = @as(u32, 13);
pub const PROV_EC_ECDSA_SIG = @as(u32, 14);
pub const PROV_EC_ECNRA_SIG = @as(u32, 15);
pub const PROV_EC_ECDSA_FULL = @as(u32, 16);
pub const PROV_EC_ECNRA_FULL = @as(u32, 17);
pub const PROV_DH_SCHANNEL = @as(u32, 18);
pub const PROV_SPYRUS_LYNKS = @as(u32, 20);
pub const PROV_RNG = @as(u32, 21);
pub const PROV_INTEL_SEC = @as(u32, 22);
pub const PROV_REPLACE_OWF = @as(u32, 23);
pub const PROV_RSA_AES = @as(u32, 24);
pub const PROV_STT_MER = @as(u32, 7);
pub const PROV_STT_ACQ = @as(u32, 8);
pub const PROV_STT_BRND = @as(u32, 9);
pub const PROV_STT_ROOT = @as(u32, 10);
pub const PROV_STT_ISS = @as(u32, 11);
pub const MAXUIDLEN = @as(u32, 64);
pub const CUR_BLOB_VERSION = @as(u32, 2);
pub const SCHANNEL_MAC_KEY = @as(u32, 0);
pub const SCHANNEL_ENC_KEY = @as(u32, 1);
pub const INTERNATIONAL_USAGE = @as(u32, 1);
pub const CERT_RDN_TYPE_MASK = @as(u32, 255);
pub const CERT_RDN_FLAGS_MASK = @as(u32, 4278190080);
pub const CERT_RDN_ENABLE_T61_UNICODE_FLAG = @as(u32, 2147483648);
pub const CERT_RDN_ENABLE_UTF8_UNICODE_FLAG = @as(u32, 536870912);
pub const CERT_RDN_FORCE_UTF8_UNICODE_FLAG = @as(u32, 268435456);
pub const CERT_RDN_DISABLE_CHECK_TYPE_FLAG = @as(u32, 1073741824);
pub const CERT_RDN_DISABLE_IE4_UTF8_FLAG = @as(u32, 16777216);
pub const CERT_RDN_ENABLE_PUNYCODE_FLAG = @as(u32, 33554432);
pub const CRYPT_ECC_PRIVATE_KEY_INFO_v1 = @as(u32, 1);
pub const CERT_V1 = @as(u32, 0);
pub const CERT_V2 = @as(u32, 1);
pub const CERT_V3 = @as(u32, 2);
pub const CERT_INFO_VERSION_FLAG = @as(u32, 1);
pub const CERT_INFO_SERIAL_NUMBER_FLAG = @as(u32, 2);
pub const CERT_INFO_SIGNATURE_ALGORITHM_FLAG = @as(u32, 3);
pub const CERT_INFO_ISSUER_FLAG = @as(u32, 4);
pub const CERT_INFO_NOT_BEFORE_FLAG = @as(u32, 5);
pub const CERT_INFO_NOT_AFTER_FLAG = @as(u32, 6);
pub const CERT_INFO_SUBJECT_FLAG = @as(u32, 7);
pub const CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG = @as(u32, 8);
pub const CERT_INFO_ISSUER_UNIQUE_ID_FLAG = @as(u32, 9);
pub const CERT_INFO_SUBJECT_UNIQUE_ID_FLAG = @as(u32, 10);
pub const CERT_INFO_EXTENSION_FLAG = @as(u32, 11);
pub const CRL_V1 = @as(u32, 0);
pub const CRL_V2 = @as(u32, 1);
pub const CERT_BUNDLE_CERTIFICATE = @as(u32, 0);
pub const CERT_BUNDLE_CRL = @as(u32, 1);
pub const CERT_REQUEST_V1 = @as(u32, 0);
pub const CERT_KEYGEN_REQUEST_V1 = @as(u32, 0);
pub const CTL_V1 = @as(u32, 0);
pub const CERT_ENCODING_TYPE_MASK = @as(u32, 65535);
pub const CMSG_ENCODING_TYPE_MASK = @as(u32, 4294901760);
pub const CRYPT_ASN_ENCODING = @as(u32, 1);
pub const CRYPT_NDR_ENCODING = @as(u32, 2);
pub const X509_NDR_ENCODING = @as(u32, 2);
pub const PKCS_7_NDR_ENCODING = @as(u32, 131072);
pub const CRYPT_FORMAT_STR_MULTI_LINE = @as(u32, 1);
pub const CRYPT_FORMAT_STR_NO_HEX = @as(u32, 16);
pub const CRYPT_FORMAT_SIMPLE = @as(u32, 1);
pub const CRYPT_FORMAT_X509 = @as(u32, 2);
pub const CRYPT_FORMAT_OID = @as(u32, 4);
pub const CRYPT_FORMAT_RDN_SEMICOLON = @as(u32, 256);
pub const CRYPT_FORMAT_RDN_CRLF = @as(u32, 512);
pub const CRYPT_FORMAT_RDN_UNQUOTE = @as(u32, 1024);
pub const CRYPT_FORMAT_RDN_REVERSE = @as(u32, 2048);
pub const CRYPT_FORMAT_COMMA = @as(u32, 4096);
pub const CRYPT_FORMAT_SEMICOLON = @as(u32, 256);
pub const CRYPT_FORMAT_CRLF = @as(u32, 512);
pub const CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = @as(u32, 8);
pub const CRYPT_UNICODE_NAME_ENCODE_FORCE_UTF8_UNICODE_FLAG = @as(u32, 268435456);
pub const CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 65536);
pub const CRYPT_ENCODE_ENABLE_UTF8PERCENT_FLAG = @as(u32, 262144);
pub const CRYPT_DECODE_NOCOPY_FLAG = @as(u32, 1);
pub const CRYPT_DECODE_TO_BE_SIGNED_FLAG = @as(u32, 2);
pub const CRYPT_DECODE_SHARE_OID_STRING_FLAG = @as(u32, 4);
pub const CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = @as(u32, 8);
pub const CRYPT_DECODE_ALLOC_FLAG = @as(u32, 32768);
pub const CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG = @as(u32, 16777216);
pub const CRYPT_DECODE_ENABLE_PUNYCODE_FLAG = @as(u32, 33554432);
pub const CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG = @as(u32, 67108864);
pub const CRYPT_ENCODE_DECODE_NONE = @as(u32, 0);
pub const SITE_PIN_RULES_ALL_SUBDOMAINS_FLAG = @as(u32, 1);
pub const CERT_ROOT_PROGRAM_FLAG_OU = @as(u32, 16);
pub const CERT_ROOT_PROGRAM_FLAG_ADDRESS = @as(u32, 8);
pub const CERT_UNICODE_RDN_ERR_INDEX_MASK = @as(u32, 1023);
pub const CERT_UNICODE_RDN_ERR_INDEX_SHIFT = @as(u32, 22);
pub const CERT_UNICODE_ATTR_ERR_INDEX_MASK = @as(u32, 63);
pub const CERT_UNICODE_ATTR_ERR_INDEX_SHIFT = @as(u32, 16);
pub const CERT_UNICODE_VALUE_ERR_INDEX_MASK = @as(u32, 65535);
pub const CERT_UNICODE_VALUE_ERR_INDEX_SHIFT = @as(u32, 0);
pub const CERT_DIGITAL_SIGNATURE_KEY_USAGE = @as(u32, 128);
pub const CERT_NON_REPUDIATION_KEY_USAGE = @as(u32, 64);
pub const CERT_KEY_ENCIPHERMENT_KEY_USAGE = @as(u32, 32);
pub const CERT_DATA_ENCIPHERMENT_KEY_USAGE = @as(u32, 16);
pub const CERT_KEY_AGREEMENT_KEY_USAGE = @as(u32, 8);
pub const CERT_KEY_CERT_SIGN_KEY_USAGE = @as(u32, 4);
pub const CERT_OFFLINE_CRL_SIGN_KEY_USAGE = @as(u32, 2);
pub const CERT_CRL_SIGN_KEY_USAGE = @as(u32, 2);
pub const CERT_ENCIPHER_ONLY_KEY_USAGE = @as(u32, 1);
pub const CERT_DECIPHER_ONLY_KEY_USAGE = @as(u32, 128);
pub const CERT_ALT_NAME_X400_ADDRESS = @as(u32, 4);
pub const CERT_ALT_NAME_EDI_PARTY_NAME = @as(u32, 6);
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK = @as(u32, 255);
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT = @as(u32, 16);
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_MASK = @as(u32, 65535);
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT = @as(u32, 0);
pub const CERT_CA_SUBJECT_FLAG = @as(u32, 128);
pub const CERT_END_ENTITY_SUBJECT_FLAG = @as(u32, 64);
pub const CRL_REASON_PRIVILEGE_WITHDRAWN = @as(u32, 9);
pub const CRL_REASON_AA_COMPROMISE = @as(u32, 10);
pub const CRL_DIST_POINT_NO_NAME = @as(u32, 0);
pub const CRL_DIST_POINT_FULL_NAME = @as(u32, 1);
pub const CRL_DIST_POINT_ISSUER_RDN_NAME = @as(u32, 2);
pub const CRL_REASON_UNUSED_FLAG = @as(u32, 128);
pub const CRL_REASON_KEY_COMPROMISE_FLAG = @as(u32, 64);
pub const CRL_REASON_CA_COMPROMISE_FLAG = @as(u32, 32);
pub const CRL_REASON_AFFILIATION_CHANGED_FLAG = @as(u32, 16);
pub const CRL_REASON_SUPERSEDED_FLAG = @as(u32, 8);
pub const CRL_REASON_CESSATION_OF_OPERATION_FLAG = @as(u32, 4);
pub const CRL_REASON_CERTIFICATE_HOLD_FLAG = @as(u32, 2);
pub const CRL_REASON_PRIVILEGE_WITHDRAWN_FLAG = @as(u32, 1);
pub const CRL_REASON_AA_COMPROMISE_FLAG = @as(u32, 128);
pub const CRL_DIST_POINT_ERR_INDEX_MASK = @as(u32, 127);
pub const CRL_DIST_POINT_ERR_INDEX_SHIFT = @as(u32, 24);
pub const CRL_DIST_POINT_ERR_CRL_ISSUER_BIT = @as(i32, -2147483648);
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_MASK = @as(u32, 255);
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT = @as(u32, 24);
pub const CERT_EXCLUDED_SUBTREE_BIT = @as(i32, -2147483648);
pub const SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 1);
pub const CERT_DSS_R_LEN = @as(u32, 20);
pub const CERT_DSS_S_LEN = @as(u32, 20);
pub const CRYPT_X942_COUNTER_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_X942_KEY_LENGTH_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH = @as(u32, 4);
pub const CRYPT_RC2_40BIT_VERSION = @as(u32, 160);
pub const CRYPT_RC2_56BIT_VERSION = @as(u32, 52);
pub const CRYPT_RC2_64BIT_VERSION = @as(u32, 120);
pub const CRYPT_RC2_128BIT_VERSION = @as(u32, 58);
pub const PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC = @as(u32, 1);
pub const NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE = @as(u32, 128);
pub const NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE = @as(u32, 64);
pub const NETSCAPE_SMIME_CERT_TYPE = @as(u32, 32);
pub const NETSCAPE_SIGN_CERT_TYPE = @as(u32, 16);
pub const NETSCAPE_SSL_CA_CERT_TYPE = @as(u32, 4);
pub const NETSCAPE_SMIME_CA_CERT_TYPE = @as(u32, 2);
pub const NETSCAPE_SIGN_CA_CERT_TYPE = @as(u32, 1);
pub const CMC_TAGGED_CERT_REQUEST_CHOICE = @as(u32, 1);
pub const CMC_OTHER_INFO_NO_CHOICE = @as(u32, 0);
pub const CMC_OTHER_INFO_FAIL_CHOICE = @as(u32, 1);
pub const CMC_OTHER_INFO_PEND_CHOICE = @as(u32, 2);
pub const CMC_STATUS_SUCCESS = @as(u32, 0);
pub const CMC_STATUS_FAILED = @as(u32, 2);
pub const CMC_STATUS_PENDING = @as(u32, 3);
pub const CMC_STATUS_NO_SUPPORT = @as(u32, 4);
pub const CMC_STATUS_CONFIRM_REQUIRED = @as(u32, 5);
pub const CMC_FAIL_BAD_ALG = @as(u32, 0);
pub const CMC_FAIL_BAD_MESSAGE_CHECK = @as(u32, 1);
pub const CMC_FAIL_BAD_REQUEST = @as(u32, 2);
pub const CMC_FAIL_BAD_TIME = @as(u32, 3);
pub const CMC_FAIL_BAD_CERT_ID = @as(u32, 4);
pub const CMC_FAIL_UNSUPORTED_EXT = @as(u32, 5);
pub const CMC_FAIL_MUST_ARCHIVE_KEYS = @as(u32, 6);
pub const CMC_FAIL_BAD_IDENTITY = @as(u32, 7);
pub const CMC_FAIL_POP_REQUIRED = @as(u32, 8);
pub const CMC_FAIL_POP_FAILED = @as(u32, 9);
pub const CMC_FAIL_NO_KEY_REUSE = @as(u32, 10);
pub const CMC_FAIL_INTERNAL_CA_ERROR = @as(u32, 11);
pub const CMC_FAIL_TRY_LATER = @as(u32, 12);
pub const CERT_BIOMETRIC_PICTURE_TYPE = @as(u32, 0);
pub const CERT_BIOMETRIC_SIGNATURE_TYPE = @as(u32, 1);
pub const OCSP_REQUEST_V1 = @as(u32, 0);
pub const OCSP_SUCCESSFUL_RESPONSE = @as(u32, 0);
pub const OCSP_MALFORMED_REQUEST_RESPONSE = @as(u32, 1);
pub const OCSP_INTERNAL_ERROR_RESPONSE = @as(u32, 2);
pub const OCSP_TRY_LATER_RESPONSE = @as(u32, 3);
pub const OCSP_SIG_REQUIRED_RESPONSE = @as(u32, 5);
pub const OCSP_UNAUTHORIZED_RESPONSE = @as(u32, 6);
pub const OCSP_BASIC_GOOD_CERT_STATUS = @as(u32, 0);
pub const OCSP_BASIC_REVOKED_CERT_STATUS = @as(u32, 1);
pub const OCSP_BASIC_UNKNOWN_CERT_STATUS = @as(u32, 2);
pub const OCSP_BASIC_RESPONSE_V1 = @as(u32, 0);
pub const OCSP_BASIC_BY_NAME_RESPONDER_ID = @as(u32, 1);
pub const OCSP_BASIC_BY_KEY_RESPONDER_ID = @as(u32, 2);
pub const CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG = @as(u32, 1);
pub const CRYPT_GET_INSTALLED_OID_FUNC_FLAG = @as(u32, 1);
pub const CRYPT_REGISTER_FIRST_INDEX = @as(u32, 0);
pub const CRYPT_REGISTER_LAST_INDEX = @as(u32, 4294967295);
pub const CRYPT_MATCH_ANY_ENCODING_TYPE = @as(u32, 4294967295);
pub const CALG_OID_INFO_CNG_ONLY = @as(u32, 4294967295);
pub const CALG_OID_INFO_PARAMETERS = @as(u32, 4294967294);
pub const CRYPT_HASH_ALG_OID_GROUP_ID = @as(u32, 1);
pub const CRYPT_ENCRYPT_ALG_OID_GROUP_ID = @as(u32, 2);
pub const CRYPT_PUBKEY_ALG_OID_GROUP_ID = @as(u32, 3);
pub const CRYPT_SIGN_ALG_OID_GROUP_ID = @as(u32, 4);
pub const CRYPT_RDN_ATTR_OID_GROUP_ID = @as(u32, 5);
pub const CRYPT_EXT_OR_ATTR_OID_GROUP_ID = @as(u32, 6);
pub const CRYPT_ENHKEY_USAGE_OID_GROUP_ID = @as(u32, 7);
pub const CRYPT_POLICY_OID_GROUP_ID = @as(u32, 8);
pub const CRYPT_TEMPLATE_OID_GROUP_ID = @as(u32, 9);
pub const CRYPT_KDF_OID_GROUP_ID = @as(u32, 10);
pub const CRYPT_LAST_OID_GROUP_ID = @as(u32, 10);
pub const CRYPT_FIRST_ALG_OID_GROUP_ID = @as(u32, 1);
pub const CRYPT_LAST_ALG_OID_GROUP_ID = @as(u32, 4);
pub const CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG = @as(u32, 1);
pub const CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG = @as(u32, 2);
pub const CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG = @as(u32, 4);
pub const CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG = @as(u32, 2147483648);
pub const CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG = @as(u32, 1073741824);
pub const CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG = @as(u32, 536870912);
pub const CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG = @as(u32, 268435456);
pub const CRYPT_OID_INFO_OID_KEY = @as(u32, 1);
pub const CRYPT_OID_INFO_NAME_KEY = @as(u32, 2);
pub const CRYPT_OID_INFO_ALGID_KEY = @as(u32, 3);
pub const CRYPT_OID_INFO_SIGN_KEY = @as(u32, 4);
pub const CRYPT_OID_INFO_CNG_ALGID_KEY = @as(u32, 5);
pub const CRYPT_OID_INFO_CNG_SIGN_KEY = @as(u32, 6);
pub const CRYPT_OID_INFO_OID_KEY_FLAGS_MASK = @as(u32, 4294901760);
pub const CRYPT_OID_DISABLE_SEARCH_DS_FLAG = @as(u32, 2147483648);
pub const CRYPT_OID_PREFER_CNG_ALGID_FLAG = @as(u32, 1073741824);
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK = @as(u32, 268369920);
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT = @as(u32, 16);
pub const CRYPT_INSTALL_OID_INFO_BEFORE_FLAG = @as(u32, 1);
pub const CRYPT_LOCALIZED_NAME_ENCODING_TYPE = @as(u32, 0);
pub const CERT_STRONG_SIGN_SERIALIZED_INFO_CHOICE = @as(u32, 1);
pub const CERT_STRONG_SIGN_OID_INFO_CHOICE = @as(u32, 2);
pub const CMSG_ENCRYPTED = @as(u32, 6);
pub const CMSG_MAIL_LIST_HANDLE_KEY_CHOICE = @as(u32, 1);
pub const CMSG_KEY_TRANS_RECIPIENT = @as(u32, 1);
pub const CMSG_KEY_AGREE_RECIPIENT = @as(u32, 2);
pub const CMSG_MAIL_LIST_RECIPIENT = @as(u32, 3);
pub const CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG = @as(u32, 2147483648);
pub const CMSG_RC4_NO_SALT_FLAG = @as(u32, 1073741824);
pub const CMSG_INDEFINITE_LENGTH = @as(u32, 4294967295);
pub const CMSG_BARE_CONTENT_FLAG = @as(u32, 1);
pub const CMSG_LENGTH_ONLY_FLAG = @as(u32, 2);
pub const CMSG_DETACHED_FLAG = @as(u32, 4);
pub const CMSG_AUTHENTICATED_ATTRIBUTES_FLAG = @as(u32, 8);
pub const CMSG_CONTENTS_OCTETS_FLAG = @as(u32, 16);
pub const CMSG_MAX_LENGTH_FLAG = @as(u32, 32);
pub const CMSG_CMS_ENCAPSULATED_CONTENT_FLAG = @as(u32, 64);
pub const CMSG_SIGNED_DATA_NO_SIGN_FLAG = @as(u32, 128);
pub const CMSG_CRYPT_RELEASE_CONTEXT_FLAG = @as(u32, 32768);
pub const CMSG_TYPE_PARAM = @as(u32, 1);
pub const CMSG_CONTENT_PARAM = @as(u32, 2);
pub const CMSG_BARE_CONTENT_PARAM = @as(u32, 3);
pub const CMSG_INNER_CONTENT_TYPE_PARAM = @as(u32, 4);
pub const CMSG_SIGNER_COUNT_PARAM = @as(u32, 5);
pub const CMSG_SIGNER_INFO_PARAM = @as(u32, 6);
pub const CMSG_SIGNER_CERT_INFO_PARAM = @as(u32, 7);
pub const CMSG_SIGNER_HASH_ALGORITHM_PARAM = @as(u32, 8);
pub const CMSG_SIGNER_AUTH_ATTR_PARAM = @as(u32, 9);
pub const CMSG_SIGNER_UNAUTH_ATTR_PARAM = @as(u32, 10);
pub const CMSG_CERT_COUNT_PARAM = @as(u32, 11);
pub const CMSG_CERT_PARAM = @as(u32, 12);
pub const CMSG_CRL_COUNT_PARAM = @as(u32, 13);
pub const CMSG_CRL_PARAM = @as(u32, 14);
pub const CMSG_ENVELOPE_ALGORITHM_PARAM = @as(u32, 15);
pub const CMSG_RECIPIENT_COUNT_PARAM = @as(u32, 17);
pub const CMSG_RECIPIENT_INDEX_PARAM = @as(u32, 18);
pub const CMSG_RECIPIENT_INFO_PARAM = @as(u32, 19);
pub const CMSG_HASH_ALGORITHM_PARAM = @as(u32, 20);
pub const CMSG_HASH_DATA_PARAM = @as(u32, 21);
pub const CMSG_COMPUTED_HASH_PARAM = @as(u32, 22);
pub const CMSG_ENCRYPT_PARAM = @as(u32, 26);
pub const CMSG_ENCRYPTED_DIGEST = @as(u32, 27);
pub const CMSG_ENCODED_SIGNER = @as(u32, 28);
pub const CMSG_ENCODED_MESSAGE = @as(u32, 29);
pub const CMSG_VERSION_PARAM = @as(u32, 30);
pub const CMSG_ATTR_CERT_COUNT_PARAM = @as(u32, 31);
pub const CMSG_ATTR_CERT_PARAM = @as(u32, 32);
pub const CMSG_CMS_RECIPIENT_COUNT_PARAM = @as(u32, 33);
pub const CMSG_CMS_RECIPIENT_INDEX_PARAM = @as(u32, 34);
pub const CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM = @as(u32, 35);
pub const CMSG_CMS_RECIPIENT_INFO_PARAM = @as(u32, 36);
pub const CMSG_UNPROTECTED_ATTR_PARAM = @as(u32, 37);
pub const CMSG_SIGNER_CERT_ID_PARAM = @as(u32, 38);
pub const CMSG_CMS_SIGNER_INFO_PARAM = @as(u32, 39);
pub const CMSG_SIGNED_DATA_V1 = @as(u32, 1);
pub const CMSG_SIGNED_DATA_V3 = @as(u32, 3);
pub const CMSG_SIGNED_DATA_PKCS_1_5_VERSION = @as(u32, 1);
pub const CMSG_SIGNED_DATA_CMS_VERSION = @as(u32, 3);
pub const CMSG_SIGNER_INFO_V1 = @as(u32, 1);
pub const CMSG_SIGNER_INFO_V3 = @as(u32, 3);
pub const CMSG_SIGNER_INFO_PKCS_1_5_VERSION = @as(u32, 1);
pub const CMSG_SIGNER_INFO_CMS_VERSION = @as(u32, 3);
pub const CMSG_HASHED_DATA_V0 = @as(u32, 0);
pub const CMSG_HASHED_DATA_V2 = @as(u32, 2);
pub const CMSG_HASHED_DATA_PKCS_1_5_VERSION = @as(u32, 0);
pub const CMSG_HASHED_DATA_CMS_VERSION = @as(u32, 2);
pub const CMSG_ENVELOPED_DATA_V0 = @as(u32, 0);
pub const CMSG_ENVELOPED_DATA_V2 = @as(u32, 2);
pub const CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION = @as(u32, 0);
pub const CMSG_ENVELOPED_DATA_CMS_VERSION = @as(u32, 2);
pub const CMSG_ENVELOPED_RECIPIENT_V0 = @as(u32, 0);
pub const CMSG_ENVELOPED_RECIPIENT_V2 = @as(u32, 2);
pub const CMSG_ENVELOPED_RECIPIENT_V3 = @as(u32, 3);
pub const CMSG_ENVELOPED_RECIPIENT_V4 = @as(u32, 4);
pub const CMSG_KEY_TRANS_PKCS_1_5_VERSION = @as(u32, 0);
pub const CMSG_KEY_TRANS_CMS_VERSION = @as(u32, 2);
pub const CMSG_KEY_AGREE_VERSION = @as(u32, 3);
pub const CMSG_MAIL_LIST_VERSION = @as(u32, 4);
pub const CMSG_CTRL_VERIFY_SIGNATURE = @as(u32, 1);
pub const CMSG_CTRL_DECRYPT = @as(u32, 2);
pub const CMSG_CTRL_VERIFY_HASH = @as(u32, 5);
pub const CMSG_CTRL_ADD_SIGNER = @as(u32, 6);
pub const CMSG_CTRL_DEL_SIGNER = @as(u32, 7);
pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR = @as(u32, 8);
pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR = @as(u32, 9);
pub const CMSG_CTRL_ADD_CERT = @as(u32, 10);
pub const CMSG_CTRL_DEL_CERT = @as(u32, 11);
pub const CMSG_CTRL_ADD_CRL = @as(u32, 12);
pub const CMSG_CTRL_DEL_CRL = @as(u32, 13);
pub const CMSG_CTRL_ADD_ATTR_CERT = @as(u32, 14);
pub const CMSG_CTRL_DEL_ATTR_CERT = @as(u32, 15);
pub const CMSG_CTRL_KEY_TRANS_DECRYPT = @as(u32, 16);
pub const CMSG_CTRL_KEY_AGREE_DECRYPT = @as(u32, 17);
pub const CMSG_CTRL_MAIL_LIST_DECRYPT = @as(u32, 18);
pub const CMSG_CTRL_VERIFY_SIGNATURE_EX = @as(u32, 19);
pub const CMSG_CTRL_ADD_CMS_SIGNER_INFO = @as(u32, 20);
pub const CMSG_CTRL_ENABLE_STRONG_SIGNATURE = @as(u32, 21);
pub const CMSG_VERIFY_SIGNER_PUBKEY = @as(u32, 1);
pub const CMSG_VERIFY_SIGNER_CERT = @as(u32, 2);
pub const CMSG_VERIFY_SIGNER_CHAIN = @as(u32, 3);
pub const CMSG_VERIFY_SIGNER_NULL = @as(u32, 4);
pub const CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG = @as(u32, 32768);
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG = @as(u32, 2);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG = @as(u32, 4);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG = @as(u32, 8);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG = @as(u32, 16);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 32);
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG = @as(u32, 1);
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG = @as(u32, 2);
pub const CERT_KEY_PROV_HANDLE_PROP_ID = @as(u32, 1);
pub const CERT_KEY_PROV_INFO_PROP_ID = @as(u32, 2);
pub const CERT_SHA1_HASH_PROP_ID = @as(u32, 3);
pub const CERT_MD5_HASH_PROP_ID = @as(u32, 4);
pub const CERT_HASH_PROP_ID = @as(u32, 3);
pub const CERT_KEY_CONTEXT_PROP_ID = @as(u32, 5);
pub const CERT_KEY_SPEC_PROP_ID = @as(u32, 6);
pub const CERT_IE30_RESERVED_PROP_ID = @as(u32, 7);
pub const CERT_PUBKEY_HASH_RESERVED_PROP_ID = @as(u32, 8);
pub const CERT_ENHKEY_USAGE_PROP_ID = @as(u32, 9);
pub const CERT_CTL_USAGE_PROP_ID = @as(u32, 9);
pub const CERT_NEXT_UPDATE_LOCATION_PROP_ID = @as(u32, 10);
pub const CERT_FRIENDLY_NAME_PROP_ID = @as(u32, 11);
pub const CERT_PVK_FILE_PROP_ID = @as(u32, 12);
pub const CERT_DESCRIPTION_PROP_ID = @as(u32, 13);
pub const CERT_ACCESS_STATE_PROP_ID = @as(u32, 14);
pub const CERT_SIGNATURE_HASH_PROP_ID = @as(u32, 15);
pub const CERT_SMART_CARD_DATA_PROP_ID = @as(u32, 16);
pub const CERT_EFS_PROP_ID = @as(u32, 17);
pub const CERT_FORTEZZA_DATA_PROP_ID = @as(u32, 18);
pub const CERT_ARCHIVED_PROP_ID = @as(u32, 19);
pub const CERT_KEY_IDENTIFIER_PROP_ID = @as(u32, 20);
pub const CERT_AUTO_ENROLL_PROP_ID = @as(u32, 21);
pub const CERT_PUBKEY_ALG_PARA_PROP_ID = @as(u32, 22);
pub const CERT_CROSS_CERT_DIST_POINTS_PROP_ID = @as(u32, 23);
pub const CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = @as(u32, 24);
pub const CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = @as(u32, 25);
pub const CERT_ENROLLMENT_PROP_ID = @as(u32, 26);
pub const CERT_DATE_STAMP_PROP_ID = @as(u32, 27);
pub const CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = @as(u32, 28);
pub const CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = @as(u32, 29);
pub const CERT_EXTENDED_ERROR_INFO_PROP_ID = @as(u32, 30);
pub const CERT_RENEWAL_PROP_ID = @as(u32, 64);
pub const CERT_ARCHIVED_KEY_HASH_PROP_ID = @as(u32, 65);
pub const CERT_AUTO_ENROLL_RETRY_PROP_ID = @as(u32, 66);
pub const CERT_AIA_URL_RETRIEVED_PROP_ID = @as(u32, 67);
pub const CERT_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 68);
pub const CERT_BACKED_UP_PROP_ID = @as(u32, 69);
pub const CERT_OCSP_RESPONSE_PROP_ID = @as(u32, 70);
pub const CERT_REQUEST_ORIGINATOR_PROP_ID = @as(u32, 71);
pub const CERT_SOURCE_LOCATION_PROP_ID = @as(u32, 72);
pub const CERT_SOURCE_URL_PROP_ID = @as(u32, 73);
pub const CERT_NEW_KEY_PROP_ID = @as(u32, 74);
pub const CERT_OCSP_CACHE_PREFIX_PROP_ID = @as(u32, 75);
pub const CERT_SMART_CARD_ROOT_INFO_PROP_ID = @as(u32, 76);
pub const CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID = @as(u32, 77);
pub const CERT_NCRYPT_KEY_HANDLE_PROP_ID = @as(u32, 78);
pub const CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID = @as(u32, 79);
pub const CERT_SUBJECT_INFO_ACCESS_PROP_ID = @as(u32, 80);
pub const CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 81);
pub const CERT_CA_DISABLE_CRL_PROP_ID = @as(u32, 82);
pub const CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID = @as(u32, 83);
pub const CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID = @as(u32, 84);
pub const CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = @as(u32, 85);
pub const CERT_SUBJECT_DISABLE_CRL_PROP_ID = @as(u32, 86);
pub const CERT_CEP_PROP_ID = @as(u32, 87);
pub const CERT_SIGN_HASH_CNG_ALG_PROP_ID = @as(u32, 89);
pub const CERT_SCARD_PIN_ID_PROP_ID = @as(u32, 90);
pub const CERT_SCARD_PIN_INFO_PROP_ID = @as(u32, 91);
pub const CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID = @as(u32, 92);
pub const CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = @as(u32, 93);
pub const CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID = @as(u32, 94);
pub const CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID = @as(u32, 95);
pub const CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = @as(u32, 96);
pub const CERT_NO_EXPIRE_NOTIFICATION_PROP_ID = @as(u32, 97);
pub const CERT_AUTH_ROOT_SHA256_HASH_PROP_ID = @as(u32, 98);
pub const CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID = @as(u32, 99);
pub const CERT_HCRYPTPROV_TRANSFER_PROP_ID = @as(u32, 100);
pub const CERT_SMART_CARD_READER_PROP_ID = @as(u32, 101);
pub const CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID = @as(u32, 102);
pub const CERT_KEY_REPAIR_ATTEMPTED_PROP_ID = @as(u32, 103);
pub const CERT_DISALLOWED_FILETIME_PROP_ID = @as(u32, 104);
pub const CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID = @as(u32, 105);
pub const CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID = @as(u32, 106);
pub const CERT_SHA256_HASH_PROP_ID = @as(u32, 107);
pub const CERT_SCEP_SERVER_CERTS_PROP_ID = @as(u32, 108);
pub const CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID = @as(u32, 109);
pub const CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID = @as(u32, 110);
pub const CERT_SCEP_CA_CERT_PROP_ID = @as(u32, 111);
pub const CERT_SCEP_SIGNER_CERT_PROP_ID = @as(u32, 112);
pub const CERT_SCEP_NONCE_PROP_ID = @as(u32, 113);
pub const CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID = @as(u32, 114);
pub const CERT_SCEP_FLAGS_PROP_ID = @as(u32, 115);
pub const CERT_SCEP_GUID_PROP_ID = @as(u32, 116);
pub const CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID = @as(u32, 117);
pub const CERT_ISOLATED_KEY_PROP_ID = @as(u32, 118);
pub const CERT_SERIAL_CHAIN_PROP_ID = @as(u32, 119);
pub const CERT_KEY_CLASSIFICATION_PROP_ID = @as(u32, 120);
pub const CERT_OCSP_MUST_STAPLE_PROP_ID = @as(u32, 121);
pub const CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID = @as(u32, 122);
pub const CERT_NONCOMPLIANT_ROOT_URL_PROP_ID = @as(u32, 123);
pub const CERT_PIN_SHA256_HASH_PROP_ID = @as(u32, 124);
pub const CERT_CLR_DELETE_KEY_PROP_ID = @as(u32, 125);
pub const CERT_NOT_BEFORE_FILETIME_PROP_ID = @as(u32, 126);
pub const CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID = @as(u32, 127);
pub const CERT_FIRST_RESERVED_PROP_ID = @as(u32, 128);
pub const CERT_LAST_RESERVED_PROP_ID = @as(u32, 32767);
pub const CERT_FIRST_USER_PROP_ID = @as(u32, 32768);
pub const CERT_LAST_USER_PROP_ID = @as(u32, 65535);
pub const CERT_ACCESS_STATE_WRITE_PERSIST_FLAG = @as(u32, 1);
pub const CERT_ACCESS_STATE_SYSTEM_STORE_FLAG = @as(u32, 2);
pub const CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG = @as(u32, 4);
pub const CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG = @as(u32, 8);
pub const CERT_ACCESS_STATE_SHARED_USER_FLAG = @as(u32, 16);
pub const CERT_STORE_SIGNATURE_FLAG = @as(u32, 1);
pub const CERT_STORE_TIME_VALIDITY_FLAG = @as(u32, 2);
pub const CERT_STORE_REVOCATION_FLAG = @as(u32, 4);
pub const CERT_STORE_NO_CRL_FLAG = @as(u32, 65536);
pub const CERT_STORE_NO_ISSUER_FLAG = @as(u32, 131072);
pub const CERT_STORE_BASE_CRL_FLAG = @as(u32, 256);
pub const CERT_STORE_DELTA_CRL_FLAG = @as(u32, 512);
pub const CERT_STORE_UNSAFE_PHYSICAL_FLAG = @as(u32, 32);
pub const CERT_STORE_SHARE_STORE_FLAG = @as(u32, 64);
pub const CERT_STORE_MANIFOLD_FLAG = @as(u32, 256);
pub const CERT_SYSTEM_STORE_MASK = @as(u32, 4294901760);
pub const CERT_SYSTEM_STORE_UNPROTECTED_FLAG = @as(u32, 1073741824);
pub const CERT_SYSTEM_STORE_DEFER_READ_FLAG = @as(u32, 536870912);
pub const CERT_SYSTEM_STORE_LOCATION_SHIFT = @as(u32, 16);
pub const CERT_SYSTEM_STORE_CURRENT_USER_ID = @as(u32, 1);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = @as(u32, 2);
pub const CERT_SYSTEM_STORE_CURRENT_SERVICE_ID = @as(u32, 4);
pub const CERT_SYSTEM_STORE_SERVICES_ID = @as(u32, 5);
pub const CERT_SYSTEM_STORE_USERS_ID = @as(u32, 6);
pub const CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID = @as(u32, 7);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID = @as(u32, 8);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID = @as(u32, 9);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS_ID = @as(u32, 10);
pub const CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG = @as(u32, 1);
pub const CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG = @as(u32, 2);
pub const CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG = @as(u32, 4);
pub const CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG = @as(u32, 8);
pub const CERT_PROT_ROOT_ONLY_LM_GPT_FLAG = @as(u32, 8);
pub const CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG = @as(u32, 16);
pub const CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG = @as(u32, 32);
pub const CERT_PROT_ROOT_DISABLE_PEER_TRUST = @as(u32, 65536);
pub const CERT_TRUST_PUB_ALLOW_TRUST_MASK = @as(u32, 3);
pub const CERT_TRUST_PUB_ALLOW_END_USER_TRUST = @as(u32, 0);
pub const CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST = @as(u32, 1);
pub const CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST = @as(u32, 2);
pub const CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG = @as(u32, 256);
pub const CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG = @as(u32, 512);
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG = @as(u32, 1);
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG = @as(u32, 2);
pub const CERT_AUTO_UPDATE_DISABLE_RANDOM_QUERY_STRING_FLAG = @as(u32, 4);
pub const CERT_REGISTRY_STORE_REMOTE_FLAG = @as(u32, 65536);
pub const CERT_REGISTRY_STORE_SERIALIZED_FLAG = @as(u32, 131072);
pub const CERT_REGISTRY_STORE_CLIENT_GPT_FLAG = @as(u32, 2147483648);
pub const CERT_REGISTRY_STORE_LM_GPT_FLAG = @as(u32, 16777216);
pub const CERT_REGISTRY_STORE_ROAMING_FLAG = @as(u32, 262144);
pub const CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG = @as(u32, 524288);
pub const CERT_REGISTRY_STORE_EXTERNAL_FLAG = @as(u32, 1048576);
pub const CERT_FILE_STORE_COMMIT_ENABLE_FLAG = @as(u32, 65536);
pub const CERT_LDAP_STORE_SIGN_FLAG = @as(u32, 65536);
pub const CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG = @as(u32, 131072);
pub const CERT_LDAP_STORE_OPENED_FLAG = @as(u32, 262144);
pub const CERT_LDAP_STORE_UNBIND_FLAG = @as(u32, 524288);
pub const CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG = @as(u32, 32);
pub const CERT_STORE_PROV_SHARED_USER_FLAG = @as(u32, 64);
pub const CERT_STORE_PROV_CLOSE_FUNC = @as(u32, 0);
pub const CERT_STORE_PROV_READ_CERT_FUNC = @as(u32, 1);
pub const CERT_STORE_PROV_WRITE_CERT_FUNC = @as(u32, 2);
pub const CERT_STORE_PROV_DELETE_CERT_FUNC = @as(u32, 3);
pub const CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC = @as(u32, 4);
pub const CERT_STORE_PROV_READ_CRL_FUNC = @as(u32, 5);
pub const CERT_STORE_PROV_WRITE_CRL_FUNC = @as(u32, 6);
pub const CERT_STORE_PROV_DELETE_CRL_FUNC = @as(u32, 7);
pub const CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC = @as(u32, 8);
pub const CERT_STORE_PROV_READ_CTL_FUNC = @as(u32, 9);
pub const CERT_STORE_PROV_WRITE_CTL_FUNC = @as(u32, 10);
pub const CERT_STORE_PROV_DELETE_CTL_FUNC = @as(u32, 11);
pub const CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC = @as(u32, 12);
pub const CERT_STORE_PROV_CONTROL_FUNC = @as(u32, 13);
pub const CERT_STORE_PROV_FIND_CERT_FUNC = @as(u32, 14);
pub const CERT_STORE_PROV_FREE_FIND_CERT_FUNC = @as(u32, 15);
pub const CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC = @as(u32, 16);
pub const CERT_STORE_PROV_FIND_CRL_FUNC = @as(u32, 17);
pub const CERT_STORE_PROV_FREE_FIND_CRL_FUNC = @as(u32, 18);
pub const CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC = @as(u32, 19);
pub const CERT_STORE_PROV_FIND_CTL_FUNC = @as(u32, 20);
pub const CERT_STORE_PROV_FREE_FIND_CTL_FUNC = @as(u32, 21);
pub const CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC = @as(u32, 22);
pub const CERT_STORE_PROV_WRITE_ADD_FLAG = @as(u32, 1);
pub const CERT_STORE_SAVE_AS_PKCS12 = @as(u32, 3);
pub const CERT_CLOSE_STORE_FORCE_FLAG = @as(u32, 1);
pub const CERT_CLOSE_STORE_CHECK_FLAG = @as(u32, 2);
pub const CERT_COMPARE_MASK = @as(u32, 65535);
pub const CERT_COMPARE_ANY = @as(u32, 0);
pub const CERT_COMPARE_SHA1_HASH = @as(u32, 1);
pub const CERT_COMPARE_NAME = @as(u32, 2);
pub const CERT_COMPARE_ATTR = @as(u32, 3);
pub const CERT_COMPARE_MD5_HASH = @as(u32, 4);
pub const CERT_COMPARE_PROPERTY = @as(u32, 5);
pub const CERT_COMPARE_PUBLIC_KEY = @as(u32, 6);
pub const CERT_COMPARE_HASH = @as(u32, 1);
pub const CERT_COMPARE_NAME_STR_A = @as(u32, 7);
pub const CERT_COMPARE_NAME_STR_W = @as(u32, 8);
pub const CERT_COMPARE_KEY_SPEC = @as(u32, 9);
pub const CERT_COMPARE_ENHKEY_USAGE = @as(u32, 10);
pub const CERT_COMPARE_CTL_USAGE = @as(u32, 10);
pub const CERT_COMPARE_SUBJECT_CERT = @as(u32, 11);
pub const CERT_COMPARE_ISSUER_OF = @as(u32, 12);
pub const CERT_COMPARE_EXISTING = @as(u32, 13);
pub const CERT_COMPARE_SIGNATURE_HASH = @as(u32, 14);
pub const CERT_COMPARE_KEY_IDENTIFIER = @as(u32, 15);
pub const CERT_COMPARE_CERT_ID = @as(u32, 16);
pub const CERT_COMPARE_CROSS_CERT_DIST_POINTS = @as(u32, 17);
pub const CERT_COMPARE_PUBKEY_MD5_HASH = @as(u32, 18);
pub const CERT_COMPARE_SUBJECT_INFO_ACCESS = @as(u32, 19);
pub const CERT_COMPARE_HASH_STR = @as(u32, 20);
pub const CERT_COMPARE_HAS_PRIVATE_KEY = @as(u32, 21);
pub const CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG = @as(u32, 2147483648);
pub const CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG = @as(u32, 1073741824);
pub const CTL_ENTRY_FROM_PROP_CHAIN_FLAG = @as(u32, 1);
pub const CRL_FIND_ANY = @as(u32, 0);
pub const CRL_FIND_ISSUED_BY = @as(u32, 1);
pub const CRL_FIND_EXISTING = @as(u32, 2);
pub const CRL_FIND_ISSUED_FOR = @as(u32, 3);
pub const CRL_FIND_ISSUED_BY_AKI_FLAG = @as(u32, 1);
pub const CRL_FIND_ISSUED_BY_SIGNATURE_FLAG = @as(u32, 2);
pub const CRL_FIND_ISSUED_BY_DELTA_FLAG = @as(u32, 4);
pub const CRL_FIND_ISSUED_BY_BASE_FLAG = @as(u32, 8);
pub const CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG = @as(u32, 16);
pub const CERT_STORE_ADD_NEW = @as(u32, 1);
pub const CERT_STORE_ADD_USE_EXISTING = @as(u32, 2);
pub const CERT_STORE_ADD_REPLACE_EXISTING = @as(u32, 3);
pub const CERT_STORE_ADD_ALWAYS = @as(u32, 4);
pub const CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = @as(u32, 5);
pub const CERT_STORE_ADD_NEWER = @as(u32, 6);
pub const CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES = @as(u32, 7);
pub const CERT_STORE_CERTIFICATE_CONTEXT = @as(u32, 1);
pub const CERT_STORE_CRL_CONTEXT = @as(u32, 2);
pub const CERT_STORE_CTL_CONTEXT = @as(u32, 3);
pub const CTL_ANY_SUBJECT_TYPE = @as(u32, 1);
pub const CTL_CERT_SUBJECT_TYPE = @as(u32, 2);
pub const CTL_FIND_NO_LIST_ID_CBDATA = @as(u32, 4294967295);
pub const CERT_STORE_CTRL_RESYNC = @as(u32, 1);
pub const CERT_STORE_CTRL_NOTIFY_CHANGE = @as(u32, 2);
pub const CERT_STORE_CTRL_COMMIT = @as(u32, 3);
pub const CERT_STORE_CTRL_AUTO_RESYNC = @as(u32, 4);
pub const CERT_STORE_CTRL_CANCEL_NOTIFY = @as(u32, 5);
pub const CERT_STORE_LOCALIZED_NAME_PROP_ID = @as(u32, 4096);
pub const CERT_CREATE_CONTEXT_NOCOPY_FLAG = @as(u32, 1);
pub const CERT_CREATE_CONTEXT_SORTED_FLAG = @as(u32, 2);
pub const CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG = @as(u32, 4);
pub const CERT_CREATE_CONTEXT_NO_ENTRY_FLAG = @as(u32, 8);
pub const CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG = @as(u32, 1);
pub const CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG = @as(u32, 2);
pub const CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG = @as(u32, 4);
pub const CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG = @as(u32, 8);
pub const CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG = @as(u32, 1);
pub const CMSG_TRUSTED_SIGNER_FLAG = @as(u32, 1);
pub const CMSG_SIGNER_ONLY_FLAG = @as(u32, 2);
pub const CMSG_USE_SIGNER_INDEX_FLAG = @as(u32, 4);
pub const CMSG_CMS_ENCAPSULATED_CTL_FLAG = @as(u32, 32768);
pub const CMSG_ENCODE_SORTED_CTL_FLAG = @as(u32, 1);
pub const CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = @as(u32, 2);
pub const CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG = @as(u32, 1);
pub const CERT_VERIFY_TRUSTED_SIGNERS_FLAG = @as(u32, 2);
pub const CERT_VERIFY_NO_TIME_CHECK_FLAG = @as(u32, 4);
pub const CERT_VERIFY_ALLOW_MORE_USAGE_FLAG = @as(u32, 8);
pub const CERT_VERIFY_UPDATED_CTL_FLAG = @as(u32, 1);
pub const CERT_CONTEXT_REVOCATION_TYPE = @as(u32, 1);
pub const CERT_VERIFY_REV_CHAIN_FLAG = @as(u32, 1);
pub const CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION = @as(u32, 2);
pub const CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG = @as(u32, 4);
pub const CERT_VERIFY_REV_SERVER_OCSP_FLAG = @as(u32, 8);
pub const CERT_VERIFY_REV_NO_OCSP_FAILOVER_TO_CRL_FLAG = @as(u32, 16);
pub const CERT_VERIFY_REV_SERVER_OCSP_WIRE_ONLY_FLAG = @as(u32, 32);
pub const CERT_UNICODE_IS_RDN_ATTRS_FLAG = @as(u32, 1);
pub const CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB = @as(u32, 1);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL = @as(u32, 3);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE = @as(u32, 4);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY = @as(u32, 1);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT = @as(u32, 2);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN = @as(u32, 3);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL = @as(u32, 4);
pub const CRYPT_VERIFY_CERT_SIGN_CHECK_WEAK_HASH_FLAG = @as(u32, 8);
pub const CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG = @as(u32, 128);
pub const CRYPT_ACQUIRE_NCRYPT_KEY_FLAGS_MASK = @as(u32, 458752);
pub const CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG = @as(u32, 65536);
pub const CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG = @as(u32, 131072);
pub const CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG = @as(u32, 262144);
pub const CRYPT_DELETE_KEYSET = @as(u32, 16);
pub const CERT_XML_NAME_STR = @as(u32, 4);
pub const CERT_NAME_STR_SEMICOLON_FLAG = @as(u32, 1073741824);
pub const CERT_NAME_STR_NO_PLUS_FLAG = @as(u32, 536870912);
pub const CERT_NAME_STR_NO_QUOTING_FLAG = @as(u32, 268435456);
pub const CERT_NAME_STR_CRLF_FLAG = @as(u32, 134217728);
pub const CERT_NAME_STR_COMMA_FLAG = @as(u32, 67108864);
pub const CERT_NAME_STR_REVERSE_FLAG = @as(u32, 33554432);
pub const CERT_NAME_STR_FORWARD_FLAG = @as(u32, 16777216);
pub const CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG = @as(u32, 65536);
pub const CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG = @as(u32, 131072);
pub const CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG = @as(u32, 262144);
pub const CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG = @as(u32, 524288);
pub const CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG = @as(u32, 1048576);
pub const CERT_NAME_STR_ENABLE_PUNYCODE_FLAG = @as(u32, 2097152);
pub const CERT_NAME_EMAIL_TYPE = @as(u32, 1);
pub const CERT_NAME_RDN_TYPE = @as(u32, 2);
pub const CERT_NAME_ATTR_TYPE = @as(u32, 3);
pub const CERT_NAME_SIMPLE_DISPLAY_TYPE = @as(u32, 4);
pub const CERT_NAME_FRIENDLY_DISPLAY_TYPE = @as(u32, 5);
pub const CERT_NAME_DNS_TYPE = @as(u32, 6);
pub const CERT_NAME_URL_TYPE = @as(u32, 7);
pub const CERT_NAME_UPN_TYPE = @as(u32, 8);
pub const CERT_NAME_ISSUER_FLAG = @as(u32, 1);
pub const CERT_NAME_DISABLE_IE4_UTF8_FLAG = @as(u32, 65536);
pub const CERT_NAME_SEARCH_ALL_NAMES_FLAG = @as(u32, 2);
pub const CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG = @as(u32, 1);
pub const CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG = @as(u32, 2);
pub const CRYPT_MESSAGE_KEYID_SIGNER_FLAG = @as(u32, 4);
pub const CRYPT_MESSAGE_SILENT_KEYSET_FLAG = @as(u32, 64);
pub const CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG = @as(u32, 4);
pub const CRYPT_RETRIEVE_MULTIPLE_OBJECTS = @as(u32, 1);
pub const CRYPT_CACHE_ONLY_RETRIEVAL = @as(u32, 2);
pub const CRYPT_WIRE_ONLY_RETRIEVAL = @as(u32, 4);
pub const CRYPT_DONT_CACHE_RESULT = @as(u32, 8);
pub const CRYPT_ASYNC_RETRIEVAL = @as(u32, 16);
pub const CRYPT_STICKY_CACHE_RETRIEVAL = @as(u32, 4096);
pub const CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL = @as(u32, 8192);
pub const CRYPT_OFFLINE_CHECK_RETRIEVAL = @as(u32, 16384);
pub const CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE = @as(u32, 32768);
pub const CRYPT_LDAP_SIGN_RETRIEVAL = @as(u32, 65536);
pub const CRYPT_NO_AUTH_RETRIEVAL = @as(u32, 131072);
pub const CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL = @as(u32, 262144);
pub const CRYPT_AIA_RETRIEVAL = @as(u32, 524288);
pub const CRYPT_HTTP_POST_RETRIEVAL = @as(u32, 1048576);
pub const CRYPT_PROXY_CACHE_RETRIEVAL = @as(u32, 2097152);
pub const CRYPT_NOT_MODIFIED_RETRIEVAL = @as(u32, 4194304);
pub const CRYPT_ENABLE_SSL_REVOCATION_RETRIEVAL = @as(u32, 8388608);
pub const CRYPT_RANDOM_QUERY_STRING_RETRIEVAL = @as(u32, 67108864);
pub const CRYPT_ENABLE_FILE_RETRIEVAL = @as(u32, 134217728);
pub const CRYPT_CREATE_NEW_FLUSH_ENTRY = @as(u32, 268435456);
pub const CRYPT_VERIFY_CONTEXT_SIGNATURE = @as(u32, 32);
pub const CRYPT_VERIFY_DATA_HASH = @as(u32, 64);
pub const CRYPT_KEEP_TIME_VALID = @as(u32, 128);
pub const CRYPT_DONT_VERIFY_SIGNATURE = @as(u32, 256);
pub const CRYPT_DONT_CHECK_TIME_VALIDITY = @as(u32, 512);
pub const CRYPT_CHECK_FRESHNESS_TIME_VALIDITY = @as(u32, 1024);
pub const CRYPT_ACCUMULATIVE_TIMEOUT = @as(u32, 2048);
pub const CRYPT_OCSP_ONLY_RETRIEVAL = @as(u32, 16777216);
pub const CRYPT_NO_OCSP_FAILOVER_TO_CRL_RETRIEVAL = @as(u32, 33554432);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_NONE = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_BLOB = @as(u32, 1);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_CRL = @as(u32, 2);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_OCSP = @as(u32, 3);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB = @as(u32, 5);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_DISALLOWED_CERT_CAB = @as(u32, 6);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_PIN_RULES_CAB = @as(u32, 7);
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_DISABLE_FLUSH = @as(u32, 4294967295);
pub const CRYPTNET_URL_CACHE_RESPONSE_NONE = @as(u32, 0);
pub const CRYPTNET_URL_CACHE_RESPONSE_HTTP = @as(u32, 1);
pub const CRYPTNET_URL_CACHE_RESPONSE_VALIDATED = @as(u32, 32768);
pub const CRYPT_RETRIEVE_MAX_ERROR_CONTENT_LENGTH = @as(u32, 4096);
pub const CRYPT_KEYID_MACHINE_FLAG = @as(u32, 32);
pub const CRYPT_KEYID_ALLOC_FLAG = @as(u32, 32768);
pub const CRYPT_KEYID_DELETE_FLAG = @as(u32, 16);
pub const CRYPT_KEYID_SET_NEW_FLAG = @as(u32, 8192);
pub const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT = @as(u32, 5);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT = @as(u32, 3);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT = @as(u32, 100000);
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT = @as(u32, 10);
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DEFAULT = @as(u32, 5);
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_ENABLE_MD2_MD4_FLAG = @as(u32, 1);
pub const CERT_CHAIN_ENABLE_WEAK_RSA_ROOT_FLAG = @as(u32, 2);
pub const CERT_CHAIN_ENABLE_WEAK_LOGGING_FLAG = @as(u32, 4);
pub const CERT_CHAIN_ENABLE_ONLY_WEAK_LOGGING_FLAG = @as(u32, 8);
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DEFAULT = @as(u32, 1023);
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_MIN_PUB_KEY_BIT_LENGTH_DISABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_ENABLE_WEAK_SETTINGS_FLAG = @as(u32, 2147483648);
pub const CERT_CHAIN_DISABLE_ECC_PARA_FLAG = @as(u32, 16);
pub const CERT_CHAIN_DISABLE_ALL_EKU_WEAK_FLAG = @as(u32, 65536);
pub const CERT_CHAIN_ENABLE_ALL_EKU_HYGIENE_FLAG = @as(u32, 131072);
pub const CERT_CHAIN_DISABLE_OPT_IN_SERVER_AUTH_WEAK_FLAG = @as(u32, 262144);
pub const CERT_CHAIN_DISABLE_SERVER_AUTH_WEAK_FLAG = @as(u32, 1048576);
pub const CERT_CHAIN_ENABLE_SERVER_AUTH_HYGIENE_FLAG = @as(u32, 2097152);
pub const CERT_CHAIN_DISABLE_CODE_SIGNING_WEAK_FLAG = @as(u32, 4194304);
pub const CERT_CHAIN_DISABLE_MOTW_CODE_SIGNING_WEAK_FLAG = @as(u32, 8388608);
pub const CERT_CHAIN_ENABLE_CODE_SIGNING_HYGIENE_FLAG = @as(u32, 16777216);
pub const CERT_CHAIN_ENABLE_MOTW_CODE_SIGNING_HYGIENE_FLAG = @as(u32, 33554432);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_WEAK_FLAG = @as(u32, 67108864);
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_WEAK_FLAG = @as(u32, 134217728);
pub const CERT_CHAIN_ENABLE_TIMESTAMP_HYGIENE_FLAG = @as(u32, 268435456);
pub const CERT_CHAIN_ENABLE_MOTW_TIMESTAMP_HYGIENE_FLAG = @as(u32, 536870912);
pub const CERT_CHAIN_MOTW_IGNORE_AFTER_TIME_WEAK_FLAG = @as(u32, 1073741824);
pub const CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAG = @as(u32, 4096);
pub const CERT_CHAIN_DISABLE_MOTW_FILE_HASH_WEAK_FLAG = @as(u32, 8192);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAG = @as(u32, 16384);
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_HASH_WEAK_FLAG = @as(u32, 32768);
pub const CERT_CHAIN_OPT_IN_WEAK_FLAGS = @as(u32, 262144);
pub const CERT_CHAIN_AUTO_CURRENT_USER = @as(u32, 1);
pub const CERT_CHAIN_AUTO_LOCAL_MACHINE = @as(u32, 2);
pub const CERT_CHAIN_AUTO_IMPERSONATED = @as(u32, 3);
pub const CERT_CHAIN_AUTO_PROCESS_INFO = @as(u32, 4);
pub const CERT_CHAIN_AUTO_PINRULE_INFO = @as(u32, 5);
pub const CERT_CHAIN_AUTO_NETWORK_INFO = @as(u32, 6);
pub const CERT_CHAIN_AUTO_SERIAL_LOCAL_MACHINE = @as(u32, 7);
pub const CERT_CHAIN_AUTO_HPKP_RULE_INFO = @as(u32, 8);
pub const CERT_CHAIN_AUTO_FLUSH_DISABLE_FLAG = @as(u32, 1);
pub const CERT_CHAIN_AUTO_LOG_CREATE_FLAG = @as(u32, 2);
pub const CERT_CHAIN_AUTO_LOG_FREE_FLAG = @as(u32, 4);
pub const CERT_CHAIN_AUTO_LOG_FLUSH_FLAG = @as(u32, 8);
pub const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_DEFAULT = @as(u32, 5);
pub const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_DEFAULT = @as(u32, 500);
pub const CRYPTNET_OCSP_AFTER_CRL_DISABLE = @as(u32, 4294967295);
pub const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 10);
pub const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 20);
pub const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = @as(u32, 10);
pub const CRYPTNET_PRE_FETCH_TRIGGER_DISABLE = @as(u32, 4294967295);
pub const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_DEFAULT = @as(u32, 60);
pub const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_DEFAULT = @as(u32, 50);
pub const CRYPTNET_CRL_BEFORE_OCSP_ENABLE = @as(u32, 4294967295);
pub const CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL = @as(u32, 2);
pub const CERT_CHAIN_OPTION_ENABLE_SIA_URL_RETRIEVAL = @as(u32, 4);
pub const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT = @as(u32, 12);
pub const CERT_CHAIN_CACHE_END_CERT = @as(u32, 1);
pub const CERT_CHAIN_THREAD_STORE_SYNC = @as(u32, 2);
pub const CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL = @as(u32, 4);
pub const CERT_CHAIN_USE_LOCAL_MACHINE_STORE = @as(u32, 8);
pub const CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE = @as(u32, 16);
pub const CERT_CHAIN_ENABLE_SHARE_STORE = @as(u32, 32);
pub const CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG = @as(u32, 1);
pub const CERT_TRUST_NO_ERROR = @as(u32, 0);
pub const CERT_TRUST_IS_NOT_TIME_VALID = @as(u32, 1);
pub const CERT_TRUST_IS_NOT_TIME_NESTED = @as(u32, 2);
pub const CERT_TRUST_IS_REVOKED = @as(u32, 4);
pub const CERT_TRUST_IS_NOT_SIGNATURE_VALID = @as(u32, 8);
pub const CERT_TRUST_IS_NOT_VALID_FOR_USAGE = @as(u32, 16);
pub const CERT_TRUST_IS_UNTRUSTED_ROOT = @as(u32, 32);
pub const CERT_TRUST_REVOCATION_STATUS_UNKNOWN = @as(u32, 64);
pub const CERT_TRUST_IS_CYCLIC = @as(u32, 128);
pub const CERT_TRUST_INVALID_EXTENSION = @as(u32, 256);
pub const CERT_TRUST_INVALID_POLICY_CONSTRAINTS = @as(u32, 512);
pub const CERT_TRUST_INVALID_BASIC_CONSTRAINTS = @as(u32, 1024);
pub const CERT_TRUST_INVALID_NAME_CONSTRAINTS = @as(u32, 2048);
pub const CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = @as(u32, 4096);
pub const CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT = @as(u32, 8192);
pub const CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = @as(u32, 16384);
pub const CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT = @as(u32, 32768);
pub const CERT_TRUST_IS_OFFLINE_REVOCATION = @as(u32, 16777216);
pub const CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY = @as(u32, 33554432);
pub const CERT_TRUST_IS_EXPLICIT_DISTRUST = @as(u32, 67108864);
pub const CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT = @as(u32, 134217728);
pub const CERT_TRUST_HAS_WEAK_SIGNATURE = @as(u32, 1048576);
pub const CERT_TRUST_HAS_WEAK_HYGIENE = @as(u32, 2097152);
pub const CERT_TRUST_IS_PARTIAL_CHAIN = @as(u32, 65536);
pub const CERT_TRUST_CTL_IS_NOT_TIME_VALID = @as(u32, 131072);
pub const CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID = @as(u32, 262144);
pub const CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE = @as(u32, 524288);
pub const CERT_TRUST_HAS_EXACT_MATCH_ISSUER = @as(u32, 1);
pub const CERT_TRUST_HAS_KEY_MATCH_ISSUER = @as(u32, 2);
pub const CERT_TRUST_HAS_NAME_MATCH_ISSUER = @as(u32, 4);
pub const CERT_TRUST_IS_SELF_SIGNED = @as(u32, 8);
pub const CERT_TRUST_AUTO_UPDATE_CA_REVOCATION = @as(u32, 16);
pub const CERT_TRUST_AUTO_UPDATE_END_REVOCATION = @as(u32, 32);
pub const CERT_TRUST_NO_OCSP_FAILOVER_TO_CRL = @as(u32, 64);
pub const CERT_TRUST_IS_KEY_ROLLOVER = @as(u32, 128);
pub const CERT_TRUST_SSL_HANDSHAKE_OCSP = @as(u32, 262144);
pub const CERT_TRUST_SSL_TIME_VALID_OCSP = @as(u32, 524288);
pub const CERT_TRUST_SSL_RECONNECT_OCSP = @as(u32, 1048576);
pub const CERT_TRUST_HAS_PREFERRED_ISSUER = @as(u32, 256);
pub const CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY = @as(u32, 512);
pub const CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS = @as(u32, 1024);
pub const CERT_TRUST_IS_PEER_TRUSTED = @as(u32, 2048);
pub const CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED = @as(u32, 4096);
pub const CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE = @as(u32, 8192);
pub const CERT_TRUST_IS_CA_TRUSTED = @as(u32, 16384);
pub const CERT_TRUST_HAS_AUTO_UPDATE_WEAK_SIGNATURE = @as(u32, 32768);
pub const CERT_TRUST_HAS_ALLOW_WEAK_SIGNATURE = @as(u32, 131072);
pub const CERT_TRUST_IS_COMPLEX_CHAIN = @as(u32, 65536);
pub const CERT_TRUST_SSL_TIME_VALID = @as(u32, 16777216);
pub const CERT_TRUST_NO_TIME_CHECK = @as(u32, 33554432);
pub const USAGE_MATCH_TYPE_AND = @as(u32, 0);
pub const USAGE_MATCH_TYPE_OR = @as(u32, 1);
pub const CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG = @as(u32, 1);
pub const CERT_CHAIN_REVOCATION_CHECK_END_CERT = @as(u32, 268435456);
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN = @as(u32, 536870912);
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = @as(u32, 1073741824);
pub const CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY = @as(u32, 2147483648);
pub const CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT = @as(u32, 134217728);
pub const CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT = @as(u32, 67108864);
pub const CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING = @as(u32, 64);
pub const CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS = @as(u32, 128);
pub const CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE = @as(u32, 256);
pub const CERT_CHAIN_TIMESTAMP_TIME = @as(u32, 512);
pub const CERT_CHAIN_ENABLE_PEER_TRUST = @as(u32, 1024);
pub const CERT_CHAIN_DISABLE_MY_PEER_TRUST = @as(u32, 2048);
pub const CERT_CHAIN_DISABLE_MD2_MD4 = @as(u32, 4096);
pub const CERT_CHAIN_DISABLE_AIA = @as(u32, 8192);
pub const CERT_CHAIN_HAS_MOTW = @as(u32, 16384);
pub const CERT_CHAIN_ONLY_ADDITIONAL_AND_AUTH_ROOT = @as(u32, 32768);
pub const CERT_CHAIN_OPT_IN_WEAK_SIGNATURE = @as(u32, 65536);
pub const CERT_CHAIN_FIND_BY_ISSUER = @as(u32, 1);
pub const CERT_CHAIN_POLICY_IGNORE_WEAK_SIGNATURE_FLAG = @as(u32, 134217728);
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG = @as(u32, 2147483648);
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG = @as(u32, 1073741824);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG = @as(u32, 65536);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG = @as(u32, 131072);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG = @as(u32, 262144);
pub const SSL_F12_ERROR_TEXT_LENGTH = @as(u32, 256);
pub const CERT_CHAIN_POLICY_SSL_F12_SUCCESS_LEVEL = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_F12_WARNING_LEVEL = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_F12_ERROR_LEVEL = @as(u32, 2);
pub const CERT_CHAIN_POLICY_SSL_F12_NONE_CATEGORY = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_F12_WEAK_CRYPTO_CATEGORY = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_F12_ROOT_PROGRAM_CATEGORY = @as(u32, 2);
pub const SSL_HPKP_PKP_HEADER_INDEX = @as(u32, 0);
pub const SSL_HPKP_PKP_RO_HEADER_INDEX = @as(u32, 1);
pub const SSL_HPKP_HEADER_COUNT = @as(u32, 2);
pub const SSL_KEY_PIN_ERROR_TEXT_LENGTH = @as(u32, 512);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_ERROR = @as(i32, -2);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_ERROR = @as(i32, -1);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_SUCCESS = @as(u32, 0);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_WARNING = @as(u32, 1);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_WARNING = @as(u32, 2);
pub const CRYPT_STRING_BASE64URI = @as(u32, 13);
pub const CRYPT_STRING_ENCODEMASK = @as(u32, 255);
pub const CRYPT_STRING_RESERVED100 = @as(u32, 256);
pub const CRYPT_STRING_RESERVED200 = @as(u32, 512);
pub const CRYPT_STRING_PERCENTESCAPE = @as(u32, 134217728);
pub const CRYPT_STRING_HASHDATA = @as(u32, 268435456);
pub const CRYPT_STRING_NOCRLF = @as(u32, 1073741824);
pub const CRYPT_STRING_NOCR = @as(u32, 2147483648);
pub const PKCS12_IMPORT_SILENT = @as(u32, 64);
pub const PKCS12_ONLY_CERTIFICATES = @as(u32, 1024);
pub const PKCS12_ONLY_NOT_ENCRYPTED_CERTIFICATES = @as(u32, 2048);
pub const PKCS12_VIRTUAL_ISOLATION_KEY = @as(u32, 65536);
pub const PKCS12_IMPORT_RESERVED_MASK = @as(u32, 4294901760);
pub const PKCS12_ONLY_CERTIFICATES_PROVIDER_TYPE = @as(u32, 0);
pub const REPORT_NO_PRIVATE_KEY = @as(u32, 1);
pub const REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY = @as(u32, 2);
pub const EXPORT_PRIVATE_KEYS = @as(u32, 4);
pub const PKCS12_PROTECT_TO_DOMAIN_SIDS = @as(u32, 32);
pub const PKCS12_EXPORT_SILENT = @as(u32, 64);
pub const PKCS12_EXPORT_PBES2_PARAMS = @as(u32, 128);
pub const PKCS12_DISABLE_ENCRYPT_CERTIFICATES = @as(u32, 256);
pub const PKCS12_ENCRYPT_CERTIFICATES = @as(u32, 512);
pub const PKCS12_EXPORT_ECC_CURVE_PARAMETERS = @as(u32, 4096);
pub const PKCS12_EXPORT_ECC_CURVE_OID = @as(u32, 8192);
pub const PKCS12_EXPORT_RESERVED_MASK = @as(u32, 4294901760);
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_READ_FLAG = @as(u32, 1);
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_WRITE_FLAG = @as(u32, 2);
pub const CERT_SERVER_OCSP_RESPONSE_ASYNC_FLAG = @as(u32, 1);
pub const CERT_SELECT_MAX_PARA = @as(u32, 500);
pub const CERT_SELECT_BY_ISSUER_DISPLAYNAME = @as(u32, 12);
pub const CERT_SELECT_BY_FRIENDLYNAME = @as(u32, 13);
pub const CERT_SELECT_BY_THUMBPRINT = @as(u32, 14);
pub const CERT_SELECT_ALLOW_EXPIRED = @as(u32, 1);
pub const CERT_SELECT_TRUSTED_ROOT = @as(u32, 2);
pub const CERT_SELECT_DISALLOW_SELFSIGNED = @as(u32, 4);
pub const CERT_SELECT_HAS_PRIVATE_KEY = @as(u32, 8);
pub const CERT_SELECT_HAS_KEY_FOR_SIGNATURE = @as(u32, 16);
pub const CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE = @as(u32, 32);
pub const CERT_SELECT_HARDWARE_ONLY = @as(u32, 64);
pub const CERT_SELECT_ALLOW_DUPLICATES = @as(u32, 128);
pub const CERT_SELECT_IGNORE_AUTOSELECT = @as(u32, 256);
pub const TIMESTAMP_FAILURE_BAD_ALG = @as(u32, 0);
pub const TIMESTAMP_FAILURE_BAD_REQUEST = @as(u32, 2);
pub const TIMESTAMP_FAILURE_BAD_FORMAT = @as(u32, 5);
pub const TIMESTAMP_FAILURE_TIME_NOT_AVAILABLE = @as(u32, 14);
pub const TIMESTAMP_FAILURE_POLICY_NOT_SUPPORTED = @as(u32, 15);
pub const TIMESTAMP_FAILURE_EXTENSION_NOT_SUPPORTED = @as(u32, 16);
pub const TIMESTAMP_FAILURE_INFO_NOT_AVAILABLE = @as(u32, 17);
pub const TIMESTAMP_FAILURE_SYSTEM_FAILURE = @as(u32, 25);
pub const TIMESTAMP_DONT_HASH_DATA = @as(u32, 1);
pub const TIMESTAMP_VERIFY_CONTEXT_SIGNATURE = @as(u32, 32);
pub const TIMESTAMP_NO_AUTH_RETRIEVAL = @as(u32, 131072);
pub const CRYPT_OBJECT_LOCATOR_SPN_NAME_TYPE = @as(u32, 1);
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_NAME_TYPE = @as(u32, 32);
pub const CRYPT_OBJECT_LOCATOR_FIRST_RESERVED_USER_NAME_TYPE = @as(u32, 33);
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_USER_NAME_TYPE = @as(u32, 65535);
pub const CERT_FILE_HASH_USE_TYPE = @as(u32, 1);
pub const CERT_TIMESTAMP_HASH_USE_TYPE = @as(u32, 2);
pub const RECIPIENTPOLICYV1 = @as(u32, 1);
pub const RECIPIENTPOLICYV2 = @as(u32, 2);
pub const E_ICARD_COMMUNICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413888));
pub const E_ICARD_DATA_ACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413887));
pub const E_ICARD_EXPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413886));
pub const E_ICARD_IDENTITY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413885));
pub const E_ICARD_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413884));
pub const E_ICARD_ARGUMENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413883));
pub const E_ICARD_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413882));
pub const E_ICARD_INFORMATIONCARD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413881));
pub const E_ICARD_STOREKEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413880));
pub const E_ICARD_LOGOVALIDATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413879));
pub const E_ICARD_PASSWORDVALIDATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413878));
pub const E_ICARD_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413877));
pub const E_ICARD_PROCESSDIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413876));
pub const E_ICARD_SERVICEBUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413875));
pub const E_ICARD_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413874));
pub const E_ICARD_SHUTTINGDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413873));
pub const E_ICARD_TOKENCREATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413872));
pub const E_ICARD_TRUSTEXCHANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413871));
pub const E_ICARD_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413870));
pub const E_ICARD_USERCANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413869));
pub const E_ICARD_STORE_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413868));
pub const E_ICARD_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413867));
pub const E_ICARD_UI_INITIALIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413862));
pub const E_ICARD_REFRESH_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413760));
pub const E_ICARD_MISSING_APPLIESTO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413759));
pub const E_ICARD_INVALID_PROOF_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413758));
pub const E_ICARD_UNKNOWN_REFERENCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413757));
pub const E_ICARD_FAILED_REQUIRED_CLAIMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1073413756));
pub const AUDIT_CARD_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070016));
pub const AUDIT_CARD_DELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070017));
pub const AUDIT_CARD_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070018));
pub const AUDIT_STORE_IMPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070019));
pub const AUDIT_STORE_EXPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070020));
pub const AUDIT_STORE_DELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070021));
pub const AUDIT_SERVICE_IDLE_STOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074070022));

//--------------------------------------------------------------------------------
// Section: Types (574)
//--------------------------------------------------------------------------------
pub const BCRYPT_OPERATION = enum(u32) {
    CIPHER_OPERATION = 1,
    HASH_OPERATION = 2,
    ASYMMETRIC_ENCRYPTION_OPERATION = 4,
    SECRET_AGREEMENT_OPERATION = 8,
    SIGNATURE_OPERATION = 16,
    RNG_OPERATION = 32,
    _,
    pub fn initFlags(o: struct {
        CIPHER_OPERATION: u1 = 0,
        HASH_OPERATION: u1 = 0,
        ASYMMETRIC_ENCRYPTION_OPERATION: u1 = 0,
        SECRET_AGREEMENT_OPERATION: u1 = 0,
        SIGNATURE_OPERATION: u1 = 0,
        RNG_OPERATION: u1 = 0,
    }) BCRYPT_OPERATION {
        return @intToEnum(BCRYPT_OPERATION,
              (if (o.CIPHER_OPERATION == 1) @enumToInt(BCRYPT_OPERATION.CIPHER_OPERATION) else 0)
            | (if (o.HASH_OPERATION == 1) @enumToInt(BCRYPT_OPERATION.HASH_OPERATION) else 0)
            | (if (o.ASYMMETRIC_ENCRYPTION_OPERATION == 1) @enumToInt(BCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION) else 0)
            | (if (o.SECRET_AGREEMENT_OPERATION == 1) @enumToInt(BCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION) else 0)
            | (if (o.SIGNATURE_OPERATION == 1) @enumToInt(BCRYPT_OPERATION.SIGNATURE_OPERATION) else 0)
            | (if (o.RNG_OPERATION == 1) @enumToInt(BCRYPT_OPERATION.RNG_OPERATION) else 0)
        );
    }
};
pub const BCRYPT_CIPHER_OPERATION = BCRYPT_OPERATION.CIPHER_OPERATION;
pub const BCRYPT_HASH_OPERATION = BCRYPT_OPERATION.HASH_OPERATION;
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = BCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION;
pub const BCRYPT_SECRET_AGREEMENT_OPERATION = BCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION;
pub const BCRYPT_SIGNATURE_OPERATION = BCRYPT_OPERATION.SIGNATURE_OPERATION;
pub const BCRYPT_RNG_OPERATION = BCRYPT_OPERATION.RNG_OPERATION;

pub const NCRYPT_OPERATION = enum(u32) {
    CIPHER_OPERATION = 1,
    HASH_OPERATION = 2,
    ASYMMETRIC_ENCRYPTION_OPERATION = 4,
    SECRET_AGREEMENT_OPERATION = 8,
    SIGNATURE_OPERATION = 16,
    _,
    pub fn initFlags(o: struct {
        CIPHER_OPERATION: u1 = 0,
        HASH_OPERATION: u1 = 0,
        ASYMMETRIC_ENCRYPTION_OPERATION: u1 = 0,
        SECRET_AGREEMENT_OPERATION: u1 = 0,
        SIGNATURE_OPERATION: u1 = 0,
    }) NCRYPT_OPERATION {
        return @intToEnum(NCRYPT_OPERATION,
              (if (o.CIPHER_OPERATION == 1) @enumToInt(NCRYPT_OPERATION.CIPHER_OPERATION) else 0)
            | (if (o.HASH_OPERATION == 1) @enumToInt(NCRYPT_OPERATION.HASH_OPERATION) else 0)
            | (if (o.ASYMMETRIC_ENCRYPTION_OPERATION == 1) @enumToInt(NCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION) else 0)
            | (if (o.SECRET_AGREEMENT_OPERATION == 1) @enumToInt(NCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION) else 0)
            | (if (o.SIGNATURE_OPERATION == 1) @enumToInt(NCRYPT_OPERATION.SIGNATURE_OPERATION) else 0)
        );
    }
};
pub const NCRYPT_CIPHER_OPERATION = NCRYPT_OPERATION.CIPHER_OPERATION;
pub const NCRYPT_HASH_OPERATION = NCRYPT_OPERATION.HASH_OPERATION;
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = NCRYPT_OPERATION.ASYMMETRIC_ENCRYPTION_OPERATION;
pub const NCRYPT_SECRET_AGREEMENT_OPERATION = NCRYPT_OPERATION.SECRET_AGREEMENT_OPERATION;
pub const NCRYPT_SIGNATURE_OPERATION = NCRYPT_OPERATION.SIGNATURE_OPERATION;

pub const CERT_FIND_FLAGS = enum(u32) {
    ANY = 0,
    CERT_ID = 1048576,
    CTL_USAGE = 655360,
    // ENHKEY_USAGE = 655360, this enum value conflicts with CTL_USAGE
    EXISTING = 851968,
    HASH = 65536,
    HAS_PRIVATE_KEY = 1376256,
    ISSUER_ATTR = 196612,
    ISSUER_NAME = 131076,
    ISSUER_OF = 786432,
    ISSUER_STR = 524292,
    KEY_IDENTIFIER = 983040,
    KEY_SPEC = 589824,
    MD5_HASH = 262144,
    PROPERTY = 327680,
    PUBLIC_KEY = 393216,
    // SHA1_HASH = 65536, this enum value conflicts with HASH
    SIGNATURE_HASH = 917504,
    SUBJECT_ATTR = 196615,
    SUBJECT_CERT = 720896,
    SUBJECT_NAME = 131079,
    SUBJECT_STR = 524295,
    CROSS_CERT_DIST_POINTS = 1114112,
    PUBKEY_MD5_HASH = 1179648,
    SUBJECT_STR_A = 458759,
    // SUBJECT_STR_W = 524295, this enum value conflicts with SUBJECT_STR
    ISSUER_STR_A = 458756,
    // ISSUER_STR_W = 524292, this enum value conflicts with ISSUER_STR
    SUBJECT_INFO_ACCESS = 1245184,
    HASH_STR = 1310720,
    OPTIONAL_ENHKEY_USAGE_FLAG = 1,
    EXT_ONLY_ENHKEY_USAGE_FLAG = 2,
    PROP_ONLY_ENHKEY_USAGE_FLAG = 4,
    NO_ENHKEY_USAGE_FLAG = 8,
    OR_ENHKEY_USAGE_FLAG = 16,
    VALID_ENHKEY_USAGE_FLAG = 32,
    // OPTIONAL_CTL_USAGE_FLAG = 1, this enum value conflicts with OPTIONAL_ENHKEY_USAGE_FLAG
    // EXT_ONLY_CTL_USAGE_FLAG = 2, this enum value conflicts with EXT_ONLY_ENHKEY_USAGE_FLAG
    // PROP_ONLY_CTL_USAGE_FLAG = 4, this enum value conflicts with PROP_ONLY_ENHKEY_USAGE_FLAG
    // NO_CTL_USAGE_FLAG = 8, this enum value conflicts with NO_ENHKEY_USAGE_FLAG
    // OR_CTL_USAGE_FLAG = 16, this enum value conflicts with OR_ENHKEY_USAGE_FLAG
    // VALID_CTL_USAGE_FLAG = 32, this enum value conflicts with VALID_ENHKEY_USAGE_FLAG
    _,
    pub fn initFlags(o: struct {
        ANY: u1 = 0,
        CERT_ID: u1 = 0,
        CTL_USAGE: u1 = 0,
        EXISTING: u1 = 0,
        HASH: u1 = 0,
        HAS_PRIVATE_KEY: u1 = 0,
        ISSUER_ATTR: u1 = 0,
        ISSUER_NAME: u1 = 0,
        ISSUER_OF: u1 = 0,
        ISSUER_STR: u1 = 0,
        KEY_IDENTIFIER: u1 = 0,
        KEY_SPEC: u1 = 0,
        MD5_HASH: u1 = 0,
        PROPERTY: u1 = 0,
        PUBLIC_KEY: u1 = 0,
        SIGNATURE_HASH: u1 = 0,
        SUBJECT_ATTR: u1 = 0,
        SUBJECT_CERT: u1 = 0,
        SUBJECT_NAME: u1 = 0,
        SUBJECT_STR: u1 = 0,
        CROSS_CERT_DIST_POINTS: u1 = 0,
        PUBKEY_MD5_HASH: u1 = 0,
        SUBJECT_STR_A: u1 = 0,
        ISSUER_STR_A: u1 = 0,
        SUBJECT_INFO_ACCESS: u1 = 0,
        HASH_STR: u1 = 0,
        OPTIONAL_ENHKEY_USAGE_FLAG: u1 = 0,
        EXT_ONLY_ENHKEY_USAGE_FLAG: u1 = 0,
        PROP_ONLY_ENHKEY_USAGE_FLAG: u1 = 0,
        NO_ENHKEY_USAGE_FLAG: u1 = 0,
        OR_ENHKEY_USAGE_FLAG: u1 = 0,
        VALID_ENHKEY_USAGE_FLAG: u1 = 0,
    }) CERT_FIND_FLAGS {
        return @intToEnum(CERT_FIND_FLAGS,
              (if (o.ANY == 1) @enumToInt(CERT_FIND_FLAGS.ANY) else 0)
            | (if (o.CERT_ID == 1) @enumToInt(CERT_FIND_FLAGS.CERT_ID) else 0)
            | (if (o.CTL_USAGE == 1) @enumToInt(CERT_FIND_FLAGS.CTL_USAGE) else 0)
            | (if (o.EXISTING == 1) @enumToInt(CERT_FIND_FLAGS.EXISTING) else 0)
            | (if (o.HASH == 1) @enumToInt(CERT_FIND_FLAGS.HASH) else 0)
            | (if (o.HAS_PRIVATE_KEY == 1) @enumToInt(CERT_FIND_FLAGS.HAS_PRIVATE_KEY) else 0)
            | (if (o.ISSUER_ATTR == 1) @enumToInt(CERT_FIND_FLAGS.ISSUER_ATTR) else 0)
            | (if (o.ISSUER_NAME == 1) @enumToInt(CERT_FIND_FLAGS.ISSUER_NAME) else 0)
            | (if (o.ISSUER_OF == 1) @enumToInt(CERT_FIND_FLAGS.ISSUER_OF) else 0)
            | (if (o.ISSUER_STR == 1) @enumToInt(CERT_FIND_FLAGS.ISSUER_STR) else 0)
            | (if (o.KEY_IDENTIFIER == 1) @enumToInt(CERT_FIND_FLAGS.KEY_IDENTIFIER) else 0)
            | (if (o.KEY_SPEC == 1) @enumToInt(CERT_FIND_FLAGS.KEY_SPEC) else 0)
            | (if (o.MD5_HASH == 1) @enumToInt(CERT_FIND_FLAGS.MD5_HASH) else 0)
            | (if (o.PROPERTY == 1) @enumToInt(CERT_FIND_FLAGS.PROPERTY) else 0)
            | (if (o.PUBLIC_KEY == 1) @enumToInt(CERT_FIND_FLAGS.PUBLIC_KEY) else 0)
            | (if (o.SIGNATURE_HASH == 1) @enumToInt(CERT_FIND_FLAGS.SIGNATURE_HASH) else 0)
            | (if (o.SUBJECT_ATTR == 1) @enumToInt(CERT_FIND_FLAGS.SUBJECT_ATTR) else 0)
            | (if (o.SUBJECT_CERT == 1) @enumToInt(CERT_FIND_FLAGS.SUBJECT_CERT) else 0)
            | (if (o.SUBJECT_NAME == 1) @enumToInt(CERT_FIND_FLAGS.SUBJECT_NAME) else 0)
            | (if (o.SUBJECT_STR == 1) @enumToInt(CERT_FIND_FLAGS.SUBJECT_STR) else 0)
            | (if (o.CROSS_CERT_DIST_POINTS == 1) @enumToInt(CERT_FIND_FLAGS.CROSS_CERT_DIST_POINTS) else 0)
            | (if (o.PUBKEY_MD5_HASH == 1) @enumToInt(CERT_FIND_FLAGS.PUBKEY_MD5_HASH) else 0)
            | (if (o.SUBJECT_STR_A == 1) @enumToInt(CERT_FIND_FLAGS.SUBJECT_STR_A) else 0)
            | (if (o.ISSUER_STR_A == 1) @enumToInt(CERT_FIND_FLAGS.ISSUER_STR_A) else 0)
            | (if (o.SUBJECT_INFO_ACCESS == 1) @enumToInt(CERT_FIND_FLAGS.SUBJECT_INFO_ACCESS) else 0)
            | (if (o.HASH_STR == 1) @enumToInt(CERT_FIND_FLAGS.HASH_STR) else 0)
            | (if (o.OPTIONAL_ENHKEY_USAGE_FLAG == 1) @enumToInt(CERT_FIND_FLAGS.OPTIONAL_ENHKEY_USAGE_FLAG) else 0)
            | (if (o.EXT_ONLY_ENHKEY_USAGE_FLAG == 1) @enumToInt(CERT_FIND_FLAGS.EXT_ONLY_ENHKEY_USAGE_FLAG) else 0)
            | (if (o.PROP_ONLY_ENHKEY_USAGE_FLAG == 1) @enumToInt(CERT_FIND_FLAGS.PROP_ONLY_ENHKEY_USAGE_FLAG) else 0)
            | (if (o.NO_ENHKEY_USAGE_FLAG == 1) @enumToInt(CERT_FIND_FLAGS.NO_ENHKEY_USAGE_FLAG) else 0)
            | (if (o.OR_ENHKEY_USAGE_FLAG == 1) @enumToInt(CERT_FIND_FLAGS.OR_ENHKEY_USAGE_FLAG) else 0)
            | (if (o.VALID_ENHKEY_USAGE_FLAG == 1) @enumToInt(CERT_FIND_FLAGS.VALID_ENHKEY_USAGE_FLAG) else 0)
        );
    }
};
pub const CERT_FIND_ANY = CERT_FIND_FLAGS.ANY;
pub const CERT_FIND_CERT_ID = CERT_FIND_FLAGS.CERT_ID;
pub const CERT_FIND_CTL_USAGE = CERT_FIND_FLAGS.CTL_USAGE;
pub const CERT_FIND_ENHKEY_USAGE = CERT_FIND_FLAGS.CTL_USAGE;
pub const CERT_FIND_EXISTING = CERT_FIND_FLAGS.EXISTING;
pub const CERT_FIND_HASH = CERT_FIND_FLAGS.HASH;
pub const CERT_FIND_HAS_PRIVATE_KEY = CERT_FIND_FLAGS.HAS_PRIVATE_KEY;
pub const CERT_FIND_ISSUER_ATTR = CERT_FIND_FLAGS.ISSUER_ATTR;
pub const CERT_FIND_ISSUER_NAME = CERT_FIND_FLAGS.ISSUER_NAME;
pub const CERT_FIND_ISSUER_OF = CERT_FIND_FLAGS.ISSUER_OF;
pub const CERT_FIND_ISSUER_STR = CERT_FIND_FLAGS.ISSUER_STR;
pub const CERT_FIND_KEY_IDENTIFIER = CERT_FIND_FLAGS.KEY_IDENTIFIER;
pub const CERT_FIND_KEY_SPEC = CERT_FIND_FLAGS.KEY_SPEC;
pub const CERT_FIND_MD5_HASH = CERT_FIND_FLAGS.MD5_HASH;
pub const CERT_FIND_PROPERTY = CERT_FIND_FLAGS.PROPERTY;
pub const CERT_FIND_PUBLIC_KEY = CERT_FIND_FLAGS.PUBLIC_KEY;
pub const CERT_FIND_SHA1_HASH = CERT_FIND_FLAGS.HASH;
pub const CERT_FIND_SIGNATURE_HASH = CERT_FIND_FLAGS.SIGNATURE_HASH;
pub const CERT_FIND_SUBJECT_ATTR = CERT_FIND_FLAGS.SUBJECT_ATTR;
pub const CERT_FIND_SUBJECT_CERT = CERT_FIND_FLAGS.SUBJECT_CERT;
pub const CERT_FIND_SUBJECT_NAME = CERT_FIND_FLAGS.SUBJECT_NAME;
pub const CERT_FIND_SUBJECT_STR = CERT_FIND_FLAGS.SUBJECT_STR;
pub const CERT_FIND_CROSS_CERT_DIST_POINTS = CERT_FIND_FLAGS.CROSS_CERT_DIST_POINTS;
pub const CERT_FIND_PUBKEY_MD5_HASH = CERT_FIND_FLAGS.PUBKEY_MD5_HASH;
pub const CERT_FIND_SUBJECT_STR_A = CERT_FIND_FLAGS.SUBJECT_STR_A;
pub const CERT_FIND_SUBJECT_STR_W = CERT_FIND_FLAGS.SUBJECT_STR;
pub const CERT_FIND_ISSUER_STR_A = CERT_FIND_FLAGS.ISSUER_STR_A;
pub const CERT_FIND_ISSUER_STR_W = CERT_FIND_FLAGS.ISSUER_STR;
pub const CERT_FIND_SUBJECT_INFO_ACCESS = CERT_FIND_FLAGS.SUBJECT_INFO_ACCESS;
pub const CERT_FIND_HASH_STR = CERT_FIND_FLAGS.HASH_STR;
pub const CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.OPTIONAL_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.EXT_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.PROP_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_NO_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.NO_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_OR_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.OR_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_VALID_ENHKEY_USAGE_FLAG = CERT_FIND_FLAGS.VALID_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_OPTIONAL_CTL_USAGE_FLAG = CERT_FIND_FLAGS.OPTIONAL_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG = CERT_FIND_FLAGS.EXT_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG = CERT_FIND_FLAGS.PROP_ONLY_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_NO_CTL_USAGE_FLAG = CERT_FIND_FLAGS.NO_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_OR_CTL_USAGE_FLAG = CERT_FIND_FLAGS.OR_ENHKEY_USAGE_FLAG;
pub const CERT_FIND_VALID_CTL_USAGE_FLAG = CERT_FIND_FLAGS.VALID_ENHKEY_USAGE_FLAG;

pub const CERT_QUERY_OBJECT_TYPE = enum(u32) {
    FILE = 1,
    BLOB = 2,
};
pub const CERT_QUERY_OBJECT_FILE = CERT_QUERY_OBJECT_TYPE.FILE;
pub const CERT_QUERY_OBJECT_BLOB = CERT_QUERY_OBJECT_TYPE.BLOB;

pub const CERT_QUERY_CONTENT_TYPE = enum(u32) {
    CERT = 1,
    CTL = 2,
    CRL = 3,
    SERIALIZED_STORE = 4,
    SERIALIZED_CERT = 5,
    SERIALIZED_CTL = 6,
    SERIALIZED_CRL = 7,
    PKCS7_SIGNED = 8,
    PKCS7_UNSIGNED = 9,
    PKCS7_SIGNED_EMBED = 10,
    PKCS10 = 11,
    PFX = 12,
    CERT_PAIR = 13,
    PFX_AND_LOAD = 14,
};
pub const CERT_QUERY_CONTENT_CERT = CERT_QUERY_CONTENT_TYPE.CERT;
pub const CERT_QUERY_CONTENT_CTL = CERT_QUERY_CONTENT_TYPE.CTL;
pub const CERT_QUERY_CONTENT_CRL = CERT_QUERY_CONTENT_TYPE.CRL;
pub const CERT_QUERY_CONTENT_SERIALIZED_STORE = CERT_QUERY_CONTENT_TYPE.SERIALIZED_STORE;
pub const CERT_QUERY_CONTENT_SERIALIZED_CERT = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CERT;
pub const CERT_QUERY_CONTENT_SERIALIZED_CTL = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CTL;
pub const CERT_QUERY_CONTENT_SERIALIZED_CRL = CERT_QUERY_CONTENT_TYPE.SERIALIZED_CRL;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED = CERT_QUERY_CONTENT_TYPE.PKCS7_SIGNED;
pub const CERT_QUERY_CONTENT_PKCS7_UNSIGNED = CERT_QUERY_CONTENT_TYPE.PKCS7_UNSIGNED;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED = CERT_QUERY_CONTENT_TYPE.PKCS7_SIGNED_EMBED;
pub const CERT_QUERY_CONTENT_PKCS10 = CERT_QUERY_CONTENT_TYPE.PKCS10;
pub const CERT_QUERY_CONTENT_PFX = CERT_QUERY_CONTENT_TYPE.PFX;
pub const CERT_QUERY_CONTENT_CERT_PAIR = CERT_QUERY_CONTENT_TYPE.CERT_PAIR;
pub const CERT_QUERY_CONTENT_PFX_AND_LOAD = CERT_QUERY_CONTENT_TYPE.PFX_AND_LOAD;

pub const CERT_QUERY_CONTENT_TYPE_FLAGS = enum(u32) {
    CERT = 2,
    CTL = 4,
    CRL = 8,
    SERIALIZED_STORE = 16,
    SERIALIZED_CERT = 32,
    SERIALIZED_CTL = 64,
    SERIALIZED_CRL = 128,
    PKCS7_SIGNED = 256,
    PKCS7_UNSIGNED = 512,
    PKCS7_SIGNED_EMBED = 1024,
    PKCS10 = 2048,
    PFX = 4096,
    CERT_PAIR = 8192,
    PFX_AND_LOAD = 16384,
    ALL = 16382,
    ALL_ISSUER_CERT = 818,
};
pub const CERT_QUERY_CONTENT_FLAG_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.CERT;
pub const CERT_QUERY_CONTENT_FLAG_CTL = CERT_QUERY_CONTENT_TYPE_FLAGS.CTL;
pub const CERT_QUERY_CONTENT_FLAG_CRL = CERT_QUERY_CONTENT_TYPE_FLAGS.CRL;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_STORE;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CERT;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CTL;
pub const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL = CERT_QUERY_CONTENT_TYPE_FLAGS.SERIALIZED_CRL;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_SIGNED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_UNSIGNED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS7_SIGNED_EMBED;
pub const CERT_QUERY_CONTENT_FLAG_PKCS10 = CERT_QUERY_CONTENT_TYPE_FLAGS.PKCS10;
pub const CERT_QUERY_CONTENT_FLAG_PFX = CERT_QUERY_CONTENT_TYPE_FLAGS.PFX;
pub const CERT_QUERY_CONTENT_FLAG_CERT_PAIR = CERT_QUERY_CONTENT_TYPE_FLAGS.CERT_PAIR;
pub const CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD = CERT_QUERY_CONTENT_TYPE_FLAGS.PFX_AND_LOAD;
pub const CERT_QUERY_CONTENT_FLAG_ALL = CERT_QUERY_CONTENT_TYPE_FLAGS.ALL;
pub const CERT_QUERY_CONTENT_FLAG_ALL_ISSUER_CERT = CERT_QUERY_CONTENT_TYPE_FLAGS.ALL_ISSUER_CERT;

pub const CERT_QUERY_FORMAT_TYPE = enum(u32) {
    BINARY = 1,
    BASE64_ENCODED = 2,
    ASN_ASCII_HEX_ENCODED = 3,
};
pub const CERT_QUERY_FORMAT_BINARY = CERT_QUERY_FORMAT_TYPE.BINARY;
pub const CERT_QUERY_FORMAT_BASE64_ENCODED = CERT_QUERY_FORMAT_TYPE.BASE64_ENCODED;
pub const CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED = CERT_QUERY_FORMAT_TYPE.ASN_ASCII_HEX_ENCODED;

pub const CERT_QUERY_FORMAT_TYPE_FLAGS = enum(u32) {
    BINARY = 2,
    BASE64_ENCODED = 4,
    ASN_ASCII_HEX_ENCODED = 8,
    ALL = 14,
};
pub const CERT_QUERY_FORMAT_FLAG_BINARY = CERT_QUERY_FORMAT_TYPE_FLAGS.BINARY;
pub const CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED = CERT_QUERY_FORMAT_TYPE_FLAGS.BASE64_ENCODED;
pub const CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED = CERT_QUERY_FORMAT_TYPE_FLAGS.ASN_ASCII_HEX_ENCODED;
pub const CERT_QUERY_FORMAT_FLAG_ALL = CERT_QUERY_FORMAT_TYPE_FLAGS.ALL;

pub const CERT_QUERY_ENCODING_TYPE = enum(u32) {
    X509_ASN_ENCODING = 1,
    PKCS_7_ASN_ENCODING = 65536,
};
pub const X509_ASN_ENCODING = CERT_QUERY_ENCODING_TYPE.X509_ASN_ENCODING;
pub const PKCS_7_ASN_ENCODING = CERT_QUERY_ENCODING_TYPE.PKCS_7_ASN_ENCODING;

pub const CERT_RDN_ATTR_VALUE_TYPE = enum(u32) {
    ANY_TYPE = 0,
    NUMERIC_STRING = 3,
    PRINTABLE_STRING = 4,
    T61_STRING = 5,
    VIDEOTEX_STRING = 6,
    IA5_STRING = 7,
    GRAPHIC_STRING = 8,
    ISO646_STRING = 9,
    GENERAL_STRING = 10,
    INT4_STRING = 11,
    UNICODE_STRING = 12,
    // BMP_STRING = 12, this enum value conflicts with UNICODE_STRING
    ENCODED_BLOB = 1,
    OCTET_STRING = 2,
    // TELETEX_STRING = 5, this enum value conflicts with T61_STRING
    // UNIVERSAL_STRING = 11, this enum value conflicts with INT4_STRING
    UTF8_STRING = 13,
    // VISIBLE_STRING = 9, this enum value conflicts with ISO646_STRING
};
pub const CERT_RDN_ANY_TYPE = CERT_RDN_ATTR_VALUE_TYPE.ANY_TYPE;
pub const CERT_RDN_NUMERIC_STRING = CERT_RDN_ATTR_VALUE_TYPE.NUMERIC_STRING;
pub const CERT_RDN_PRINTABLE_STRING = CERT_RDN_ATTR_VALUE_TYPE.PRINTABLE_STRING;
pub const CERT_RDN_T61_STRING = CERT_RDN_ATTR_VALUE_TYPE.T61_STRING;
pub const CERT_RDN_VIDEOTEX_STRING = CERT_RDN_ATTR_VALUE_TYPE.VIDEOTEX_STRING;
pub const CERT_RDN_IA5_STRING = CERT_RDN_ATTR_VALUE_TYPE.IA5_STRING;
pub const CERT_RDN_GRAPHIC_STRING = CERT_RDN_ATTR_VALUE_TYPE.GRAPHIC_STRING;
pub const CERT_RDN_ISO646_STRING = CERT_RDN_ATTR_VALUE_TYPE.ISO646_STRING;
pub const CERT_RDN_GENERAL_STRING = CERT_RDN_ATTR_VALUE_TYPE.GENERAL_STRING;
pub const CERT_RDN_INT4_STRING = CERT_RDN_ATTR_VALUE_TYPE.INT4_STRING;
pub const CERT_RDN_UNICODE_STRING = CERT_RDN_ATTR_VALUE_TYPE.UNICODE_STRING;
pub const CERT_RDN_BMP_STRING = CERT_RDN_ATTR_VALUE_TYPE.UNICODE_STRING;
pub const CERT_RDN_ENCODED_BLOB = CERT_RDN_ATTR_VALUE_TYPE.ENCODED_BLOB;
pub const CERT_RDN_OCTET_STRING = CERT_RDN_ATTR_VALUE_TYPE.OCTET_STRING;
pub const CERT_RDN_TELETEX_STRING = CERT_RDN_ATTR_VALUE_TYPE.T61_STRING;
pub const CERT_RDN_UNIVERSAL_STRING = CERT_RDN_ATTR_VALUE_TYPE.INT4_STRING;
pub const CERT_RDN_UTF8_STRING = CERT_RDN_ATTR_VALUE_TYPE.UTF8_STRING;
pub const CERT_RDN_VISIBLE_STRING = CERT_RDN_ATTR_VALUE_TYPE.ISO646_STRING;

pub const CERT_STRING_TYPE = enum(u32) {
    SIMPLE_NAME_STR = 1,
    OID_NAME_STR = 2,
    X500_NAME_STR = 3,
};
pub const CERT_SIMPLE_NAME_STR = CERT_STRING_TYPE.SIMPLE_NAME_STR;
pub const CERT_OID_NAME_STR = CERT_STRING_TYPE.OID_NAME_STR;
pub const CERT_X500_NAME_STR = CERT_STRING_TYPE.X500_NAME_STR;

pub const BCRYPT_TABLE = enum(u32) {
    LOCAL = 1,
    DOMAIN = 2,
};
pub const CRYPT_LOCAL = BCRYPT_TABLE.LOCAL;
pub const CRYPT_DOMAIN = BCRYPT_TABLE.DOMAIN;

pub const CERT_KEY_SPEC = enum(u32) {
    AT_KEYEXCHANGE = 1,
    AT_SIGNATURE = 2,
    CERT_NCRYPT_KEY_SPEC = 4294967295,
};
pub const AT_KEYEXCHANGE = CERT_KEY_SPEC.AT_KEYEXCHANGE;
pub const AT_SIGNATURE = CERT_KEY_SPEC.AT_SIGNATURE;
pub const CERT_NCRYPT_KEY_SPEC = CERT_KEY_SPEC.CERT_NCRYPT_KEY_SPEC;

pub const BCRYPT_INTERFACE = enum(u32) {
    BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = 3,
    BCRYPT_CIPHER_INTERFACE = 1,
    BCRYPT_HASH_INTERFACE = 2,
    BCRYPT_RNG_INTERFACE = 6,
    BCRYPT_SECRET_AGREEMENT_INTERFACE = 4,
    BCRYPT_SIGNATURE_INTERFACE = 5,
    NCRYPT_KEY_STORAGE_INTERFACE = 65537,
    NCRYPT_SCHANNEL_INTERFACE = 65538,
    NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = 65539,
};
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = BCRYPT_INTERFACE.BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const BCRYPT_CIPHER_INTERFACE = BCRYPT_INTERFACE.BCRYPT_CIPHER_INTERFACE;
pub const BCRYPT_HASH_INTERFACE = BCRYPT_INTERFACE.BCRYPT_HASH_INTERFACE;
pub const BCRYPT_RNG_INTERFACE = BCRYPT_INTERFACE.BCRYPT_RNG_INTERFACE;
pub const BCRYPT_SECRET_AGREEMENT_INTERFACE = BCRYPT_INTERFACE.BCRYPT_SECRET_AGREEMENT_INTERFACE;
pub const BCRYPT_SIGNATURE_INTERFACE = BCRYPT_INTERFACE.BCRYPT_SIGNATURE_INTERFACE;
pub const NCRYPT_KEY_STORAGE_INTERFACE = BCRYPT_INTERFACE.NCRYPT_KEY_STORAGE_INTERFACE;
pub const NCRYPT_SCHANNEL_INTERFACE = BCRYPT_INTERFACE.NCRYPT_SCHANNEL_INTERFACE;
pub const NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = BCRYPT_INTERFACE.NCRYPT_SCHANNEL_SIGNATURE_INTERFACE;

pub const NCRYPT_FLAGS = enum(u32) {
    BCRYPT_PAD_NONE = 1,
    BCRYPT_PAD_OAEP = 4,
    BCRYPT_PAD_PKCS1 = 2,
    BCRYPT_PAD_PSS = 8,
    NCRYPT_SILENT_FLAG = 64,
    // NCRYPT_NO_PADDING_FLAG = 1, this enum value conflicts with BCRYPT_PAD_NONE
    // NCRYPT_PAD_OAEP_FLAG = 4, this enum value conflicts with BCRYPT_PAD_OAEP
    // NCRYPT_PAD_PKCS1_FLAG = 2, this enum value conflicts with BCRYPT_PAD_PKCS1
    // NCRYPT_REGISTER_NOTIFY_FLAG = 1, this enum value conflicts with BCRYPT_PAD_NONE
    // NCRYPT_UNREGISTER_NOTIFY_FLAG = 2, this enum value conflicts with BCRYPT_PAD_PKCS1
    NCRYPT_MACHINE_KEY_FLAG = 32,
    // NCRYPT_UNPROTECT_NO_DECRYPT = 1, this enum value conflicts with BCRYPT_PAD_NONE
    NCRYPT_OVERWRITE_KEY_FLAG = 128,
    // NCRYPT_NO_KEY_VALIDATION = 8, this enum value conflicts with BCRYPT_PAD_PSS
    NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = 512,
    // NCRYPT_PAD_PSS_FLAG = 8, this enum value conflicts with BCRYPT_PAD_PSS
    NCRYPT_PERSIST_FLAG = 2147483648,
    NCRYPT_PERSIST_ONLY_FLAG = 1073741824,
    _,
    pub fn initFlags(o: struct {
        BCRYPT_PAD_NONE: u1 = 0,
        BCRYPT_PAD_OAEP: u1 = 0,
        BCRYPT_PAD_PKCS1: u1 = 0,
        BCRYPT_PAD_PSS: u1 = 0,
        NCRYPT_SILENT_FLAG: u1 = 0,
        NCRYPT_MACHINE_KEY_FLAG: u1 = 0,
        NCRYPT_OVERWRITE_KEY_FLAG: u1 = 0,
        NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG: u1 = 0,
        NCRYPT_PERSIST_FLAG: u1 = 0,
        NCRYPT_PERSIST_ONLY_FLAG: u1 = 0,
    }) NCRYPT_FLAGS {
        return @intToEnum(NCRYPT_FLAGS,
              (if (o.BCRYPT_PAD_NONE == 1) @enumToInt(NCRYPT_FLAGS.BCRYPT_PAD_NONE) else 0)
            | (if (o.BCRYPT_PAD_OAEP == 1) @enumToInt(NCRYPT_FLAGS.BCRYPT_PAD_OAEP) else 0)
            | (if (o.BCRYPT_PAD_PKCS1 == 1) @enumToInt(NCRYPT_FLAGS.BCRYPT_PAD_PKCS1) else 0)
            | (if (o.BCRYPT_PAD_PSS == 1) @enumToInt(NCRYPT_FLAGS.BCRYPT_PAD_PSS) else 0)
            | (if (o.NCRYPT_SILENT_FLAG == 1) @enumToInt(NCRYPT_FLAGS.NCRYPT_SILENT_FLAG) else 0)
            | (if (o.NCRYPT_MACHINE_KEY_FLAG == 1) @enumToInt(NCRYPT_FLAGS.NCRYPT_MACHINE_KEY_FLAG) else 0)
            | (if (o.NCRYPT_OVERWRITE_KEY_FLAG == 1) @enumToInt(NCRYPT_FLAGS.NCRYPT_OVERWRITE_KEY_FLAG) else 0)
            | (if (o.NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG == 1) @enumToInt(NCRYPT_FLAGS.NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG) else 0)
            | (if (o.NCRYPT_PERSIST_FLAG == 1) @enumToInt(NCRYPT_FLAGS.NCRYPT_PERSIST_FLAG) else 0)
            | (if (o.NCRYPT_PERSIST_ONLY_FLAG == 1) @enumToInt(NCRYPT_FLAGS.NCRYPT_PERSIST_ONLY_FLAG) else 0)
        );
    }
};
pub const BCRYPT_PAD_NONE = NCRYPT_FLAGS.BCRYPT_PAD_NONE;
pub const BCRYPT_PAD_OAEP = NCRYPT_FLAGS.BCRYPT_PAD_OAEP;
pub const BCRYPT_PAD_PKCS1 = NCRYPT_FLAGS.BCRYPT_PAD_PKCS1;
pub const BCRYPT_PAD_PSS = NCRYPT_FLAGS.BCRYPT_PAD_PSS;
pub const NCRYPT_SILENT_FLAG = NCRYPT_FLAGS.NCRYPT_SILENT_FLAG;
pub const NCRYPT_NO_PADDING_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_NONE;
pub const NCRYPT_PAD_OAEP_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_OAEP;
pub const NCRYPT_PAD_PKCS1_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_PKCS1;
pub const NCRYPT_REGISTER_NOTIFY_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_NONE;
pub const NCRYPT_UNREGISTER_NOTIFY_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_PKCS1;
pub const NCRYPT_MACHINE_KEY_FLAG = NCRYPT_FLAGS.NCRYPT_MACHINE_KEY_FLAG;
pub const NCRYPT_UNPROTECT_NO_DECRYPT = NCRYPT_FLAGS.BCRYPT_PAD_NONE;
pub const NCRYPT_OVERWRITE_KEY_FLAG = NCRYPT_FLAGS.NCRYPT_OVERWRITE_KEY_FLAG;
pub const NCRYPT_NO_KEY_VALIDATION = NCRYPT_FLAGS.BCRYPT_PAD_PSS;
pub const NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = NCRYPT_FLAGS.NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG;
pub const NCRYPT_PAD_PSS_FLAG = NCRYPT_FLAGS.BCRYPT_PAD_PSS;
pub const NCRYPT_PERSIST_FLAG = NCRYPT_FLAGS.NCRYPT_PERSIST_FLAG;
pub const NCRYPT_PERSIST_ONLY_FLAG = NCRYPT_FLAGS.NCRYPT_PERSIST_ONLY_FLAG;

pub const CRYPT_STRING = enum(u32) {
    BASE64HEADER = 0,
    BASE64 = 1,
    BINARY = 2,
    BASE64REQUESTHEADER = 3,
    HEX = 4,
    HEXASCII = 5,
    BASE64X509CRLHEADER = 9,
    HEXADDR = 10,
    HEXASCIIADDR = 11,
    HEXRAW = 12,
    STRICT = 536870912,
    BASE64_ANY = 6,
    ANY = 7,
    HEX_ANY = 8,
};
pub const CRYPT_STRING_BASE64HEADER = CRYPT_STRING.BASE64HEADER;
pub const CRYPT_STRING_BASE64 = CRYPT_STRING.BASE64;
pub const CRYPT_STRING_BINARY = CRYPT_STRING.BINARY;
pub const CRYPT_STRING_BASE64REQUESTHEADER = CRYPT_STRING.BASE64REQUESTHEADER;
pub const CRYPT_STRING_HEX = CRYPT_STRING.HEX;
pub const CRYPT_STRING_HEXASCII = CRYPT_STRING.HEXASCII;
pub const CRYPT_STRING_BASE64X509CRLHEADER = CRYPT_STRING.BASE64X509CRLHEADER;
pub const CRYPT_STRING_HEXADDR = CRYPT_STRING.HEXADDR;
pub const CRYPT_STRING_HEXASCIIADDR = CRYPT_STRING.HEXASCIIADDR;
pub const CRYPT_STRING_HEXRAW = CRYPT_STRING.HEXRAW;
pub const CRYPT_STRING_STRICT = CRYPT_STRING.STRICT;
pub const CRYPT_STRING_BASE64_ANY = CRYPT_STRING.BASE64_ANY;
pub const CRYPT_STRING_ANY = CRYPT_STRING.ANY;
pub const CRYPT_STRING_HEX_ANY = CRYPT_STRING.HEX_ANY;

pub const CRYPT_IMPORT_PUBLIC_KEY_FLAGS = enum(u32) {
    SIGN_KEY_FLAG = 2147483648,
    ENCRYPT_KEY_FLAG = 1073741824,
    _,
    pub fn initFlags(o: struct {
        SIGN_KEY_FLAG: u1 = 0,
        ENCRYPT_KEY_FLAG: u1 = 0,
    }) CRYPT_IMPORT_PUBLIC_KEY_FLAGS {
        return @intToEnum(CRYPT_IMPORT_PUBLIC_KEY_FLAGS,
              (if (o.SIGN_KEY_FLAG == 1) @enumToInt(CRYPT_IMPORT_PUBLIC_KEY_FLAGS.SIGN_KEY_FLAG) else 0)
            | (if (o.ENCRYPT_KEY_FLAG == 1) @enumToInt(CRYPT_IMPORT_PUBLIC_KEY_FLAGS.ENCRYPT_KEY_FLAG) else 0)
        );
    }
};
pub const CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG = CRYPT_IMPORT_PUBLIC_KEY_FLAGS.SIGN_KEY_FLAG;
pub const CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG = CRYPT_IMPORT_PUBLIC_KEY_FLAGS.ENCRYPT_KEY_FLAG;

pub const CRYPT_XML_FLAGS = enum(u32) {
    FLAG_DISABLE_EXTENSIONS = 268435456,
    FLAG_NO_SERIALIZE = 2147483648,
    SIGN_ADD_KEYVALUE = 1,
};
pub const CRYPT_XML_FLAG_DISABLE_EXTENSIONS = CRYPT_XML_FLAGS.FLAG_DISABLE_EXTENSIONS;
pub const CRYPT_XML_FLAG_NO_SERIALIZE = CRYPT_XML_FLAGS.FLAG_NO_SERIALIZE;
pub const CRYPT_XML_SIGN_ADD_KEYVALUE = CRYPT_XML_FLAGS.SIGN_ADD_KEYVALUE;

pub const CRYPT_ENCODE_OBJECT_FLAGS = enum(u32) {
    ENCODE_ALLOC_FLAG = 32768,
    ENCODE_ENABLE_PUNYCODE_FLAG = 131072,
    UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG = 1073741824,
    UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG = 2147483648,
    UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG = 536870912,
    _,
    pub fn initFlags(o: struct {
        ENCODE_ALLOC_FLAG: u1 = 0,
        ENCODE_ENABLE_PUNYCODE_FLAG: u1 = 0,
        UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG: u1 = 0,
        UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG: u1 = 0,
        UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG: u1 = 0,
    }) CRYPT_ENCODE_OBJECT_FLAGS {
        return @intToEnum(CRYPT_ENCODE_OBJECT_FLAGS,
              (if (o.ENCODE_ALLOC_FLAG == 1) @enumToInt(CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ALLOC_FLAG) else 0)
            | (if (o.ENCODE_ENABLE_PUNYCODE_FLAG == 1) @enumToInt(CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ENABLE_PUNYCODE_FLAG) else 0)
            | (if (o.UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG == 1) @enumToInt(CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG) else 0)
            | (if (o.UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG == 1) @enumToInt(CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG) else 0)
            | (if (o.UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG == 1) @enumToInt(CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG) else 0)
        );
    }
};
pub const CRYPT_ENCODE_ALLOC_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ALLOC_FLAG;
pub const CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.ENCODE_ENABLE_PUNYCODE_FLAG;
pub const CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG;
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG;
pub const CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG = CRYPT_ENCODE_OBJECT_FLAGS.UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG;

pub const CRYPT_OBJECT_LOCATOR_RELEASE_REASON = enum(u32) {
    SYSTEM_SHUTDOWN = 1,
    SERVICE_STOP = 2,
    PROCESS_EXIT = 3,
    DLL_UNLOAD = 4,
};
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SYSTEM_SHUTDOWN = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.SYSTEM_SHUTDOWN;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SERVICE_STOP = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.SERVICE_STOP;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_PROCESS_EXIT = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.PROCESS_EXIT;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_DLL_UNLOAD = CRYPT_OBJECT_LOCATOR_RELEASE_REASON.DLL_UNLOAD;

pub const CRYPT_ACQUIRE_FLAGS = enum(u32) {
    CACHE_FLAG = 1,
    COMPARE_KEY_FLAG = 4,
    NO_HEALING = 8,
    SILENT_FLAG = 64,
    USE_PROV_INFO_FLAG = 2,
    _,
    pub fn initFlags(o: struct {
        CACHE_FLAG: u1 = 0,
        COMPARE_KEY_FLAG: u1 = 0,
        NO_HEALING: u1 = 0,
        SILENT_FLAG: u1 = 0,
        USE_PROV_INFO_FLAG: u1 = 0,
    }) CRYPT_ACQUIRE_FLAGS {
        return @intToEnum(CRYPT_ACQUIRE_FLAGS,
              (if (o.CACHE_FLAG == 1) @enumToInt(CRYPT_ACQUIRE_FLAGS.CACHE_FLAG) else 0)
            | (if (o.COMPARE_KEY_FLAG == 1) @enumToInt(CRYPT_ACQUIRE_FLAGS.COMPARE_KEY_FLAG) else 0)
            | (if (o.NO_HEALING == 1) @enumToInt(CRYPT_ACQUIRE_FLAGS.NO_HEALING) else 0)
            | (if (o.SILENT_FLAG == 1) @enumToInt(CRYPT_ACQUIRE_FLAGS.SILENT_FLAG) else 0)
            | (if (o.USE_PROV_INFO_FLAG == 1) @enumToInt(CRYPT_ACQUIRE_FLAGS.USE_PROV_INFO_FLAG) else 0)
        );
    }
};
pub const CRYPT_ACQUIRE_CACHE_FLAG = CRYPT_ACQUIRE_FLAGS.CACHE_FLAG;
pub const CRYPT_ACQUIRE_COMPARE_KEY_FLAG = CRYPT_ACQUIRE_FLAGS.COMPARE_KEY_FLAG;
pub const CRYPT_ACQUIRE_NO_HEALING = CRYPT_ACQUIRE_FLAGS.NO_HEALING;
pub const CRYPT_ACQUIRE_SILENT_FLAG = CRYPT_ACQUIRE_FLAGS.SILENT_FLAG;
pub const CRYPT_ACQUIRE_USE_PROV_INFO_FLAG = CRYPT_ACQUIRE_FLAGS.USE_PROV_INFO_FLAG;

pub const CRYPT_GET_URL_FLAGS = enum(u32) {
    PROPERTY = 1,
    EXTENSION = 2,
    UNAUTH_ATTRIBUTE = 4,
    AUTH_ATTRIBUTE = 8,
    _,
    pub fn initFlags(o: struct {
        PROPERTY: u1 = 0,
        EXTENSION: u1 = 0,
        UNAUTH_ATTRIBUTE: u1 = 0,
        AUTH_ATTRIBUTE: u1 = 0,
    }) CRYPT_GET_URL_FLAGS {
        return @intToEnum(CRYPT_GET_URL_FLAGS,
              (if (o.PROPERTY == 1) @enumToInt(CRYPT_GET_URL_FLAGS.PROPERTY) else 0)
            | (if (o.EXTENSION == 1) @enumToInt(CRYPT_GET_URL_FLAGS.EXTENSION) else 0)
            | (if (o.UNAUTH_ATTRIBUTE == 1) @enumToInt(CRYPT_GET_URL_FLAGS.UNAUTH_ATTRIBUTE) else 0)
            | (if (o.AUTH_ATTRIBUTE == 1) @enumToInt(CRYPT_GET_URL_FLAGS.AUTH_ATTRIBUTE) else 0)
        );
    }
};
pub const CRYPT_GET_URL_FROM_PROPERTY = CRYPT_GET_URL_FLAGS.PROPERTY;
pub const CRYPT_GET_URL_FROM_EXTENSION = CRYPT_GET_URL_FLAGS.EXTENSION;
pub const CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE = CRYPT_GET_URL_FLAGS.UNAUTH_ATTRIBUTE;
pub const CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE = CRYPT_GET_URL_FLAGS.AUTH_ATTRIBUTE;

pub const CERT_STORE_SAVE_AS = enum(u32) {
    PKCS7 = 2,
    STORE = 1,
};
pub const CERT_STORE_SAVE_AS_PKCS7 = CERT_STORE_SAVE_AS.PKCS7;
pub const CERT_STORE_SAVE_AS_STORE = CERT_STORE_SAVE_AS.STORE;

pub const BCRYPT_QUERY_PROVIDER_MODE = enum(u32) {
    ANY = 4,
    UM = 1,
    KM = 2,
    MM = 3,
};
pub const CRYPT_ANY = BCRYPT_QUERY_PROVIDER_MODE.ANY;
pub const CRYPT_UM = BCRYPT_QUERY_PROVIDER_MODE.UM;
pub const CRYPT_KM = BCRYPT_QUERY_PROVIDER_MODE.KM;
pub const CRYPT_MM = BCRYPT_QUERY_PROVIDER_MODE.MM;

pub const CERT_FIND_CHAIN_IN_STORE_FLAGS = enum(u32) {
    COMPARE_KEY_FLAG = 1,
    COMPLEX_CHAIN_FLAG = 2,
    CACHE_ONLY_FLAG = 32768,
    CACHE_ONLY_URL_FLAG = 4,
    LOCAL_MACHINE_FLAG = 8,
    NO_KEY_FLAG = 16384,
    _,
    pub fn initFlags(o: struct {
        COMPARE_KEY_FLAG: u1 = 0,
        COMPLEX_CHAIN_FLAG: u1 = 0,
        CACHE_ONLY_FLAG: u1 = 0,
        CACHE_ONLY_URL_FLAG: u1 = 0,
        LOCAL_MACHINE_FLAG: u1 = 0,
        NO_KEY_FLAG: u1 = 0,
    }) CERT_FIND_CHAIN_IN_STORE_FLAGS {
        return @intToEnum(CERT_FIND_CHAIN_IN_STORE_FLAGS,
              (if (o.COMPARE_KEY_FLAG == 1) @enumToInt(CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPARE_KEY_FLAG) else 0)
            | (if (o.COMPLEX_CHAIN_FLAG == 1) @enumToInt(CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPLEX_CHAIN_FLAG) else 0)
            | (if (o.CACHE_ONLY_FLAG == 1) @enumToInt(CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_FLAG) else 0)
            | (if (o.CACHE_ONLY_URL_FLAG == 1) @enumToInt(CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_URL_FLAG) else 0)
            | (if (o.LOCAL_MACHINE_FLAG == 1) @enumToInt(CERT_FIND_CHAIN_IN_STORE_FLAGS.LOCAL_MACHINE_FLAG) else 0)
            | (if (o.NO_KEY_FLAG == 1) @enumToInt(CERT_FIND_CHAIN_IN_STORE_FLAGS.NO_KEY_FLAG) else 0)
        );
    }
};
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPARE_KEY_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.COMPLEX_CHAIN_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.CACHE_ONLY_URL_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.LOCAL_MACHINE_FLAG;
pub const CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG = CERT_FIND_CHAIN_IN_STORE_FLAGS.NO_KEY_FLAG;

pub const CERT_CONTROL_STORE_FLAGS = enum(u32) {
    COMMIT_FORCE_FLAG = 1,
    COMMIT_CLEAR_FLAG = 2,
    // INHIBIT_DUPLICATE_HANDLE_FLAG = 1, this enum value conflicts with COMMIT_FORCE_FLAG
};
pub const CERT_STORE_CTRL_COMMIT_FORCE_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_FORCE_FLAG;
pub const CERT_STORE_CTRL_COMMIT_CLEAR_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_CLEAR_FLAG;
pub const CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG = CERT_CONTROL_STORE_FLAGS.COMMIT_FORCE_FLAG;

pub const BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS = enum(u32) {
    ALG_HANDLE_HMAC_FLAG = 8,
    PROV_DISPATCH = 1,
    HASH_REUSABLE_FLAG = 32,
    _,
    pub fn initFlags(o: struct {
        ALG_HANDLE_HMAC_FLAG: u1 = 0,
        PROV_DISPATCH: u1 = 0,
        HASH_REUSABLE_FLAG: u1 = 0,
    }) BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS {
        return @intToEnum(BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS,
              (if (o.ALG_HANDLE_HMAC_FLAG == 1) @enumToInt(BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.ALG_HANDLE_HMAC_FLAG) else 0)
            | (if (o.PROV_DISPATCH == 1) @enumToInt(BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.PROV_DISPATCH) else 0)
            | (if (o.HASH_REUSABLE_FLAG == 1) @enumToInt(BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.HASH_REUSABLE_FLAG) else 0)
        );
    }
};
pub const BCRYPT_ALG_HANDLE_HMAC_FLAG = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.ALG_HANDLE_HMAC_FLAG;
pub const BCRYPT_PROV_DISPATCH = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.PROV_DISPATCH;
pub const BCRYPT_HASH_REUSABLE_FLAG = BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS.HASH_REUSABLE_FLAG;

pub const CERT_STORE_SAVE_TO = enum(u32) {
    FILE = 1,
    FILENAME = 4,
    FILENAME_A = 3,
    // FILENAME_W = 4, this enum value conflicts with FILENAME
    MEMORY = 2,
};
pub const CERT_STORE_SAVE_TO_FILE = CERT_STORE_SAVE_TO.FILE;
pub const CERT_STORE_SAVE_TO_FILENAME = CERT_STORE_SAVE_TO.FILENAME;
pub const CERT_STORE_SAVE_TO_FILENAME_A = CERT_STORE_SAVE_TO.FILENAME_A;
pub const CERT_STORE_SAVE_TO_FILENAME_W = CERT_STORE_SAVE_TO.FILENAME;
pub const CERT_STORE_SAVE_TO_MEMORY = CERT_STORE_SAVE_TO.MEMORY;

pub const CRYPT_SET_PROV_PARAM_ID = enum(u32) {
    CLIENT_HWND = 1,
    DELETEKEY = 24,
    KEYEXCHANGE_ALG = 14,
    KEYEXCHANGE_PIN = 32,
    KEYEXCHANGE_KEYSIZE = 12,
    KEYSET_SEC_DESCR = 8,
    PIN_PROMPT_STRING = 44,
    ROOT_CERTSTORE = 46,
    SIGNATURE_ALG = 15,
    SIGNATURE_PIN = 33,
    SIGNATURE_KEYSIZE = 13,
    UI_PROMPT = 21,
    USE_HARDWARE_RNG = 38,
    USER_CERTSTORE = 42,
    SECURE_KEYEXCHANGE_PIN = 47,
    SECURE_SIGNATURE_PIN = 48,
    SMARTCARD_READER = 43,
};
pub const PP_CLIENT_HWND = CRYPT_SET_PROV_PARAM_ID.CLIENT_HWND;
pub const PP_DELETEKEY = CRYPT_SET_PROV_PARAM_ID.DELETEKEY;
pub const PP_KEYEXCHANGE_ALG = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_ALG;
pub const PP_KEYEXCHANGE_PIN = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_PIN;
pub const PP_KEYEXCHANGE_KEYSIZE = CRYPT_SET_PROV_PARAM_ID.KEYEXCHANGE_KEYSIZE;
pub const PP_KEYSET_SEC_DESCR = CRYPT_SET_PROV_PARAM_ID.KEYSET_SEC_DESCR;
pub const PP_PIN_PROMPT_STRING = CRYPT_SET_PROV_PARAM_ID.PIN_PROMPT_STRING;
pub const PP_ROOT_CERTSTORE = CRYPT_SET_PROV_PARAM_ID.ROOT_CERTSTORE;
pub const PP_SIGNATURE_ALG = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_ALG;
pub const PP_SIGNATURE_PIN = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_PIN;
pub const PP_SIGNATURE_KEYSIZE = CRYPT_SET_PROV_PARAM_ID.SIGNATURE_KEYSIZE;
pub const PP_UI_PROMPT = CRYPT_SET_PROV_PARAM_ID.UI_PROMPT;
pub const PP_USE_HARDWARE_RNG = CRYPT_SET_PROV_PARAM_ID.USE_HARDWARE_RNG;
pub const PP_USER_CERTSTORE = CRYPT_SET_PROV_PARAM_ID.USER_CERTSTORE;
pub const PP_SECURE_KEYEXCHANGE_PIN = CRYPT_SET_PROV_PARAM_ID.SECURE_KEYEXCHANGE_PIN;
pub const PP_SECURE_SIGNATURE_PIN = CRYPT_SET_PROV_PARAM_ID.SECURE_SIGNATURE_PIN;
pub const PP_SMARTCARD_READER = CRYPT_SET_PROV_PARAM_ID.SMARTCARD_READER;

pub const CRYPT_KEY_PARAM_ID = enum(u32) {
    ALGID = 7,
    CERTIFICATE = 26,
    PERMISSIONS = 6,
    SALT = 2,
    SALT_EX = 10,
    BLOCKLEN = 8,
    GET_USE_COUNT = 42,
    KEYLEN = 9,
};
pub const KP_ALGID = CRYPT_KEY_PARAM_ID.ALGID;
pub const KP_CERTIFICATE = CRYPT_KEY_PARAM_ID.CERTIFICATE;
pub const KP_PERMISSIONS = CRYPT_KEY_PARAM_ID.PERMISSIONS;
pub const KP_SALT = CRYPT_KEY_PARAM_ID.SALT;
pub const KP_SALT_EX = CRYPT_KEY_PARAM_ID.SALT_EX;
pub const KP_BLOCKLEN = CRYPT_KEY_PARAM_ID.BLOCKLEN;
pub const KP_GET_USE_COUNT = CRYPT_KEY_PARAM_ID.GET_USE_COUNT;
pub const KP_KEYLEN = CRYPT_KEY_PARAM_ID.KEYLEN;

pub const CRYPT_KEY_FLAGS = enum(u32) {
    CRYPT_EXPORTABLE = 1,
    CRYPT_USER_PROTECTED = 2,
    CRYPT_ARCHIVABLE = 16384,
    CRYPT_CREATE_IV = 512,
    CRYPT_CREATE_SALT = 4,
    CRYPT_DATA_KEY = 2048,
    CRYPT_FORCE_KEY_PROTECTION_HIGH = 32768,
    CRYPT_KEK = 1024,
    CRYPT_INITIATOR = 64,
    CRYPT_NO_SALT = 16,
    CRYPT_ONLINE = 128,
    // CRYPT_PREGEN = 64, this enum value conflicts with CRYPT_INITIATOR
    // CRYPT_RECIPIENT = 16, this enum value conflicts with CRYPT_NO_SALT
    CRYPT_SF = 256,
    CRYPT_SGCKEY = 8192,
    CRYPT_VOLATILE = 4096,
    CRYPT_MACHINE_KEYSET = 32,
    // CRYPT_USER_KEYSET = 4096, this enum value conflicts with CRYPT_VOLATILE
    // PKCS12_PREFER_CNG_KSP = 256, this enum value conflicts with CRYPT_SF
    // PKCS12_ALWAYS_CNG_KSP = 512, this enum value conflicts with CRYPT_CREATE_IV
    // PKCS12_ALLOW_OVERWRITE_KEY = 16384, this enum value conflicts with CRYPT_ARCHIVABLE
    // PKCS12_NO_PERSIST_KEY = 32768, this enum value conflicts with CRYPT_FORCE_KEY_PROTECTION_HIGH
    // PKCS12_INCLUDE_EXTENDED_PROPERTIES = 16, this enum value conflicts with CRYPT_NO_SALT
    // CRYPT_OAEP = 64, this enum value conflicts with CRYPT_INITIATOR
    // CRYPT_BLOB_VER3 = 128, this enum value conflicts with CRYPT_ONLINE
    // CRYPT_DESTROYKEY = 4, this enum value conflicts with CRYPT_CREATE_SALT
    // CRYPT_SSL2_FALLBACK = 2, this enum value conflicts with CRYPT_USER_PROTECTED
    // CRYPT_Y_ONLY = 1, this enum value conflicts with CRYPT_EXPORTABLE
    // CRYPT_IPSEC_HMAC_KEY = 256, this enum value conflicts with CRYPT_SF
    // CERT_SET_KEY_PROV_HANDLE_PROP_ID = 1, this enum value conflicts with CRYPT_EXPORTABLE
    // CERT_SET_KEY_CONTEXT_PROP_ID = 1, this enum value conflicts with CRYPT_EXPORTABLE
    _,
    pub fn initFlags(o: struct {
        CRYPT_EXPORTABLE: u1 = 0,
        CRYPT_USER_PROTECTED: u1 = 0,
        CRYPT_ARCHIVABLE: u1 = 0,
        CRYPT_CREATE_IV: u1 = 0,
        CRYPT_CREATE_SALT: u1 = 0,
        CRYPT_DATA_KEY: u1 = 0,
        CRYPT_FORCE_KEY_PROTECTION_HIGH: u1 = 0,
        CRYPT_KEK: u1 = 0,
        CRYPT_INITIATOR: u1 = 0,
        CRYPT_NO_SALT: u1 = 0,
        CRYPT_ONLINE: u1 = 0,
        CRYPT_SF: u1 = 0,
        CRYPT_SGCKEY: u1 = 0,
        CRYPT_VOLATILE: u1 = 0,
        CRYPT_MACHINE_KEYSET: u1 = 0,
    }) CRYPT_KEY_FLAGS {
        return @intToEnum(CRYPT_KEY_FLAGS,
              (if (o.CRYPT_EXPORTABLE == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE) else 0)
            | (if (o.CRYPT_USER_PROTECTED == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_USER_PROTECTED) else 0)
            | (if (o.CRYPT_ARCHIVABLE == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_ARCHIVABLE) else 0)
            | (if (o.CRYPT_CREATE_IV == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_CREATE_IV) else 0)
            | (if (o.CRYPT_CREATE_SALT == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_CREATE_SALT) else 0)
            | (if (o.CRYPT_DATA_KEY == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_DATA_KEY) else 0)
            | (if (o.CRYPT_FORCE_KEY_PROTECTION_HIGH == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_FORCE_KEY_PROTECTION_HIGH) else 0)
            | (if (o.CRYPT_KEK == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_KEK) else 0)
            | (if (o.CRYPT_INITIATOR == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_INITIATOR) else 0)
            | (if (o.CRYPT_NO_SALT == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_NO_SALT) else 0)
            | (if (o.CRYPT_ONLINE == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_ONLINE) else 0)
            | (if (o.CRYPT_SF == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_SF) else 0)
            | (if (o.CRYPT_SGCKEY == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_SGCKEY) else 0)
            | (if (o.CRYPT_VOLATILE == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_VOLATILE) else 0)
            | (if (o.CRYPT_MACHINE_KEYSET == 1) @enumToInt(CRYPT_KEY_FLAGS.CRYPT_MACHINE_KEYSET) else 0)
        );
    }
};
pub const CRYPT_EXPORTABLE = CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE;
pub const CRYPT_USER_PROTECTED = CRYPT_KEY_FLAGS.CRYPT_USER_PROTECTED;
pub const CRYPT_ARCHIVABLE = CRYPT_KEY_FLAGS.CRYPT_ARCHIVABLE;
pub const CRYPT_CREATE_IV = CRYPT_KEY_FLAGS.CRYPT_CREATE_IV;
pub const CRYPT_CREATE_SALT = CRYPT_KEY_FLAGS.CRYPT_CREATE_SALT;
pub const CRYPT_DATA_KEY = CRYPT_KEY_FLAGS.CRYPT_DATA_KEY;
pub const CRYPT_FORCE_KEY_PROTECTION_HIGH = CRYPT_KEY_FLAGS.CRYPT_FORCE_KEY_PROTECTION_HIGH;
pub const CRYPT_KEK = CRYPT_KEY_FLAGS.CRYPT_KEK;
pub const CRYPT_INITIATOR = CRYPT_KEY_FLAGS.CRYPT_INITIATOR;
pub const CRYPT_NO_SALT = CRYPT_KEY_FLAGS.CRYPT_NO_SALT;
pub const CRYPT_ONLINE = CRYPT_KEY_FLAGS.CRYPT_ONLINE;
pub const CRYPT_PREGEN = CRYPT_KEY_FLAGS.CRYPT_INITIATOR;
pub const CRYPT_RECIPIENT = CRYPT_KEY_FLAGS.CRYPT_NO_SALT;
pub const CRYPT_SF = CRYPT_KEY_FLAGS.CRYPT_SF;
pub const CRYPT_SGCKEY = CRYPT_KEY_FLAGS.CRYPT_SGCKEY;
pub const CRYPT_VOLATILE = CRYPT_KEY_FLAGS.CRYPT_VOLATILE;
pub const CRYPT_MACHINE_KEYSET = CRYPT_KEY_FLAGS.CRYPT_MACHINE_KEYSET;
pub const CRYPT_USER_KEYSET = CRYPT_KEY_FLAGS.CRYPT_VOLATILE;
pub const PKCS12_PREFER_CNG_KSP = CRYPT_KEY_FLAGS.CRYPT_SF;
pub const PKCS12_ALWAYS_CNG_KSP = CRYPT_KEY_FLAGS.CRYPT_CREATE_IV;
pub const PKCS12_ALLOW_OVERWRITE_KEY = CRYPT_KEY_FLAGS.CRYPT_ARCHIVABLE;
pub const PKCS12_NO_PERSIST_KEY = CRYPT_KEY_FLAGS.CRYPT_FORCE_KEY_PROTECTION_HIGH;
pub const PKCS12_INCLUDE_EXTENDED_PROPERTIES = CRYPT_KEY_FLAGS.CRYPT_NO_SALT;
pub const CRYPT_OAEP = CRYPT_KEY_FLAGS.CRYPT_INITIATOR;
pub const CRYPT_BLOB_VER3 = CRYPT_KEY_FLAGS.CRYPT_ONLINE;
pub const CRYPT_DESTROYKEY = CRYPT_KEY_FLAGS.CRYPT_CREATE_SALT;
pub const CRYPT_SSL2_FALLBACK = CRYPT_KEY_FLAGS.CRYPT_USER_PROTECTED;
pub const CRYPT_Y_ONLY = CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE;
pub const CRYPT_IPSEC_HMAC_KEY = CRYPT_KEY_FLAGS.CRYPT_SF;
pub const CERT_SET_KEY_PROV_HANDLE_PROP_ID = CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE;
pub const CERT_SET_KEY_CONTEXT_PROP_ID = CRYPT_KEY_FLAGS.CRYPT_EXPORTABLE;

pub const CRYPT_MSG_TYPE = enum(u32) {
    DATA = 1,
    SIGNED = 2,
    ENVELOPED = 3,
    SIGNED_AND_ENVELOPED = 4,
    HASHED = 5,
};
pub const CMSG_DATA = CRYPT_MSG_TYPE.DATA;
pub const CMSG_SIGNED = CRYPT_MSG_TYPE.SIGNED;
pub const CMSG_ENVELOPED = CRYPT_MSG_TYPE.ENVELOPED;
pub const CMSG_SIGNED_AND_ENVELOPED = CRYPT_MSG_TYPE.SIGNED_AND_ENVELOPED;
pub const CMSG_HASHED = CRYPT_MSG_TYPE.HASHED;

pub const CERT_OPEN_STORE_FLAGS = enum(u32) {
    BACKUP_RESTORE_FLAG = 2048,
    CREATE_NEW_FLAG = 8192,
    DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 4,
    DELETE_FLAG = 16,
    ENUM_ARCHIVED_FLAG = 512,
    MAXIMUM_ALLOWED_FLAG = 4096,
    NO_CRYPT_RELEASE_FLAG = 1,
    OPEN_EXISTING_FLAG = 16384,
    READONLY_FLAG = 32768,
    SET_LOCALIZED_NAME_FLAG = 2,
    SHARE_CONTEXT_FLAG = 128,
    UPDATE_KEYID_FLAG = 1024,
};
pub const CERT_STORE_BACKUP_RESTORE_FLAG = CERT_OPEN_STORE_FLAGS.BACKUP_RESTORE_FLAG;
pub const CERT_STORE_CREATE_NEW_FLAG = CERT_OPEN_STORE_FLAGS.CREATE_NEW_FLAG;
pub const CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = CERT_OPEN_STORE_FLAGS.DEFER_CLOSE_UNTIL_LAST_FREE_FLAG;
pub const CERT_STORE_DELETE_FLAG = CERT_OPEN_STORE_FLAGS.DELETE_FLAG;
pub const CERT_STORE_ENUM_ARCHIVED_FLAG = CERT_OPEN_STORE_FLAGS.ENUM_ARCHIVED_FLAG;
pub const CERT_STORE_MAXIMUM_ALLOWED_FLAG = CERT_OPEN_STORE_FLAGS.MAXIMUM_ALLOWED_FLAG;
pub const CERT_STORE_NO_CRYPT_RELEASE_FLAG = CERT_OPEN_STORE_FLAGS.NO_CRYPT_RELEASE_FLAG;
pub const CERT_STORE_OPEN_EXISTING_FLAG = CERT_OPEN_STORE_FLAGS.OPEN_EXISTING_FLAG;
pub const CERT_STORE_READONLY_FLAG = CERT_OPEN_STORE_FLAGS.READONLY_FLAG;
pub const CERT_STORE_SET_LOCALIZED_NAME_FLAG = CERT_OPEN_STORE_FLAGS.SET_LOCALIZED_NAME_FLAG;
pub const CERT_STORE_SHARE_CONTEXT_FLAG = CERT_OPEN_STORE_FLAGS.SHARE_CONTEXT_FLAG;
pub const CERT_STORE_UPDATE_KEYID_FLAG = CERT_OPEN_STORE_FLAGS.UPDATE_KEYID_FLAG;

pub const CRYPT_DEFAULT_CONTEXT_FLAGS = enum(u32) {
    AUTO_RELEASE_FLAG = 1,
    PROCESS_FLAG = 2,
    _,
    pub fn initFlags(o: struct {
        AUTO_RELEASE_FLAG: u1 = 0,
        PROCESS_FLAG: u1 = 0,
    }) CRYPT_DEFAULT_CONTEXT_FLAGS {
        return @intToEnum(CRYPT_DEFAULT_CONTEXT_FLAGS,
              (if (o.AUTO_RELEASE_FLAG == 1) @enumToInt(CRYPT_DEFAULT_CONTEXT_FLAGS.AUTO_RELEASE_FLAG) else 0)
            | (if (o.PROCESS_FLAG == 1) @enumToInt(CRYPT_DEFAULT_CONTEXT_FLAGS.PROCESS_FLAG) else 0)
        );
    }
};
pub const CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG = CRYPT_DEFAULT_CONTEXT_FLAGS.AUTO_RELEASE_FLAG;
pub const CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG = CRYPT_DEFAULT_CONTEXT_FLAGS.PROCESS_FLAG;

pub const CRYPT_VERIFY_CERT_FLAGS = enum(u32) {
    DISABLE_MD2_MD4_FLAG = 1,
    SET_STRONG_PROPERTIES_FLAG = 2,
    RETURN_STRONG_PROPERTIES_FLAG = 4,
};
pub const CRYPT_VERIFY_CERT_SIGN_DISABLE_MD2_MD4_FLAG = CRYPT_VERIFY_CERT_FLAGS.DISABLE_MD2_MD4_FLAG;
pub const CRYPT_VERIFY_CERT_SIGN_SET_STRONG_PROPERTIES_FLAG = CRYPT_VERIFY_CERT_FLAGS.SET_STRONG_PROPERTIES_FLAG;
pub const CRYPT_VERIFY_CERT_SIGN_RETURN_STRONG_PROPERTIES_FLAG = CRYPT_VERIFY_CERT_FLAGS.RETURN_STRONG_PROPERTIES_FLAG;

pub const CRYPT_SET_HASH_PARAM = enum(u32) {
    MAC_INFO = 5,
    ASHVAL = 2,
};
pub const HP_HMAC_INFO = CRYPT_SET_HASH_PARAM.MAC_INFO;
pub const HP_HASHVAL = CRYPT_SET_HASH_PARAM.ASHVAL;

pub const CERT_SYSTEM_STORE_FLAGS = enum(u32) {
    LOCATION_MASK = 16711680,
    RELOCATE_FLAG = 2147483648,
};
pub const CERT_SYSTEM_STORE_LOCATION_MASK = CERT_SYSTEM_STORE_FLAGS.LOCATION_MASK;
pub const CERT_SYSTEM_STORE_RELOCATE_FLAG = CERT_SYSTEM_STORE_FLAGS.RELOCATE_FLAG;

pub const CERT_CREATE_SELFSIGN_FLAGS = enum(u32) {
    KEY_INFO = 2,
    SIGN = 1,
    _,
    pub fn initFlags(o: struct {
        KEY_INFO: u1 = 0,
        SIGN: u1 = 0,
    }) CERT_CREATE_SELFSIGN_FLAGS {
        return @intToEnum(CERT_CREATE_SELFSIGN_FLAGS,
              (if (o.KEY_INFO == 1) @enumToInt(CERT_CREATE_SELFSIGN_FLAGS.KEY_INFO) else 0)
            | (if (o.SIGN == 1) @enumToInt(CERT_CREATE_SELFSIGN_FLAGS.SIGN) else 0)
        );
    }
};
pub const CERT_CREATE_SELFSIGN_NO_KEY_INFO = CERT_CREATE_SELFSIGN_FLAGS.KEY_INFO;
pub const CERT_CREATE_SELFSIGN_NO_SIGN = CERT_CREATE_SELFSIGN_FLAGS.SIGN;

pub const CRYPT_DEFAULT_CONTEXT_TYPE = enum(u32) {
    CERT_SIGN_OID = 1,
    MULTI_CERT_SIGN_OID = 2,
};
pub const CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID = CRYPT_DEFAULT_CONTEXT_TYPE.CERT_SIGN_OID;
pub const CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID = CRYPT_DEFAULT_CONTEXT_TYPE.MULTI_CERT_SIGN_OID;

pub const BCRYPT_RESOLVE_PROVIDERS_FLAGS = enum(u32) {
    FUNCTIONS = 1,
    PROVIDERS = 2,
    _,
    pub fn initFlags(o: struct {
        FUNCTIONS: u1 = 0,
        PROVIDERS: u1 = 0,
    }) BCRYPT_RESOLVE_PROVIDERS_FLAGS {
        return @intToEnum(BCRYPT_RESOLVE_PROVIDERS_FLAGS,
              (if (o.FUNCTIONS == 1) @enumToInt(BCRYPT_RESOLVE_PROVIDERS_FLAGS.FUNCTIONS) else 0)
            | (if (o.PROVIDERS == 1) @enumToInt(BCRYPT_RESOLVE_PROVIDERS_FLAGS.PROVIDERS) else 0)
        );
    }
};
pub const CRYPT_ALL_FUNCTIONS = BCRYPT_RESOLVE_PROVIDERS_FLAGS.FUNCTIONS;
pub const CRYPT_ALL_PROVIDERS = BCRYPT_RESOLVE_PROVIDERS_FLAGS.PROVIDERS;

pub const CERT_FIND_TYPE = enum(u32) {
    ANY = 0,
    SHA1_HASH = 1,
    MD5_HASH = 2,
    USAGE = 3,
    // SAME_USAGE_FLAG = 1, this enum value conflicts with SHA1_HASH
    EXISTING = 5,
    SUBJECT = 4,
};
pub const CTL_FIND_ANY = CERT_FIND_TYPE.ANY;
pub const CTL_FIND_SHA1_HASH = CERT_FIND_TYPE.SHA1_HASH;
pub const CTL_FIND_MD5_HASH = CERT_FIND_TYPE.MD5_HASH;
pub const CTL_FIND_USAGE = CERT_FIND_TYPE.USAGE;
pub const CTL_FIND_SAME_USAGE_FLAG = CERT_FIND_TYPE.SHA1_HASH;
pub const CTL_FIND_EXISTING = CERT_FIND_TYPE.EXISTING;
pub const CTL_FIND_SUBJECT = CERT_FIND_TYPE.SUBJECT;

pub const CRYPT_FIND_FLAGS = enum(u32) {
    USER_KEYSET_FLAG = 1,
    MACHINE_KEYSET_FLAG = 2,
    SILENT_KEYSET_FLAG = 64,
};
pub const CRYPT_FIND_USER_KEYSET_FLAG = CRYPT_FIND_FLAGS.USER_KEYSET_FLAG;
pub const CRYPT_FIND_MACHINE_KEYSET_FLAG = CRYPT_FIND_FLAGS.MACHINE_KEYSET_FLAG;
pub const CRYPT_FIND_SILENT_KEYSET_FLAG = CRYPT_FIND_FLAGS.SILENT_KEYSET_FLAG;

pub const CRYPT_IMAGE_REF_FLAGS = enum(u32) {
    MIN_DEPENDENCIES = 1,
    PROCESS_ISOLATE = 65536,
    _,
    pub fn initFlags(o: struct {
        MIN_DEPENDENCIES: u1 = 0,
        PROCESS_ISOLATE: u1 = 0,
    }) CRYPT_IMAGE_REF_FLAGS {
        return @intToEnum(CRYPT_IMAGE_REF_FLAGS,
              (if (o.MIN_DEPENDENCIES == 1) @enumToInt(CRYPT_IMAGE_REF_FLAGS.MIN_DEPENDENCIES) else 0)
            | (if (o.PROCESS_ISOLATE == 1) @enumToInt(CRYPT_IMAGE_REF_FLAGS.PROCESS_ISOLATE) else 0)
        );
    }
};
pub const CRYPT_MIN_DEPENDENCIES = CRYPT_IMAGE_REF_FLAGS.MIN_DEPENDENCIES;
pub const CRYPT_PROCESS_ISOLATE = CRYPT_IMAGE_REF_FLAGS.PROCESS_ISOLATE;

pub const CERT_REVOCATION_STATUS_REASON = enum(u32) {
    UNSPECIFIED = 0,
    KEY_COMPROMISE = 1,
    CA_COMPROMISE = 2,
    AFFILIATION_CHANGED = 3,
    SUPERSEDED = 4,
    CESSATION_OF_OPERATION = 5,
    CERTIFICATE_HOLD = 6,
    REMOVE_FROM_CRL = 8,
};
pub const CRL_REASON_UNSPECIFIED = CERT_REVOCATION_STATUS_REASON.UNSPECIFIED;
pub const CRL_REASON_KEY_COMPROMISE = CERT_REVOCATION_STATUS_REASON.KEY_COMPROMISE;
pub const CRL_REASON_CA_COMPROMISE = CERT_REVOCATION_STATUS_REASON.CA_COMPROMISE;
pub const CRL_REASON_AFFILIATION_CHANGED = CERT_REVOCATION_STATUS_REASON.AFFILIATION_CHANGED;
pub const CRL_REASON_SUPERSEDED = CERT_REVOCATION_STATUS_REASON.SUPERSEDED;
pub const CRL_REASON_CESSATION_OF_OPERATION = CERT_REVOCATION_STATUS_REASON.CESSATION_OF_OPERATION;
pub const CRL_REASON_CERTIFICATE_HOLD = CERT_REVOCATION_STATUS_REASON.CERTIFICATE_HOLD;
pub const CRL_REASON_REMOVE_FROM_CRL = CERT_REVOCATION_STATUS_REASON.REMOVE_FROM_CRL;

pub const CERT_ROOT_PROGRAM_FLAGS = enum(u32) {
    LSC = 64,
    ORG = 128,
    SUBJECT_LOGO = 32,
    _,
    pub fn initFlags(o: struct {
        LSC: u1 = 0,
        ORG: u1 = 0,
        SUBJECT_LOGO: u1 = 0,
    }) CERT_ROOT_PROGRAM_FLAGS {
        return @intToEnum(CERT_ROOT_PROGRAM_FLAGS,
              (if (o.LSC == 1) @enumToInt(CERT_ROOT_PROGRAM_FLAGS.LSC) else 0)
            | (if (o.ORG == 1) @enumToInt(CERT_ROOT_PROGRAM_FLAGS.ORG) else 0)
            | (if (o.SUBJECT_LOGO == 1) @enumToInt(CERT_ROOT_PROGRAM_FLAGS.SUBJECT_LOGO) else 0)
        );
    }
};
pub const CERT_ROOT_PROGRAM_FLAG_LSC = CERT_ROOT_PROGRAM_FLAGS.LSC;
pub const CERT_ROOT_PROGRAM_FLAG_ORG = CERT_ROOT_PROGRAM_FLAGS.ORG;
pub const CERT_ROOT_PROGRAM_FLAG_SUBJECT_LOGO = CERT_ROOT_PROGRAM_FLAGS.SUBJECT_LOGO;

pub const CRYPT_XML_KEY_VALUE_TYPE = enum(u32) {
    DSA = 1,
    RSA = 2,
    ECDSA = 3,
    CUSTOM = 4,
};
pub const CRYPT_XML_KEY_VALUE_TYPE_DSA = CRYPT_XML_KEY_VALUE_TYPE.DSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_RSA = CRYPT_XML_KEY_VALUE_TYPE.RSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_ECDSA = CRYPT_XML_KEY_VALUE_TYPE.ECDSA;
pub const CRYPT_XML_KEY_VALUE_TYPE_CUSTOM = CRYPT_XML_KEY_VALUE_TYPE.CUSTOM;

pub const CERT_LOGOTYPE_CHOICE = enum(u32) {
    NO_IMAGE_RESOLUTION_CHOICE = 0,
    BITS_IMAGE_RESOLUTION_CHOICE = 1,
    TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = 2,
};
pub const CERT_LOGOTYPE_NO_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.NO_IMAGE_RESOLUTION_CHOICE;
pub const CERT_LOGOTYPE_BITS_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.BITS_IMAGE_RESOLUTION_CHOICE;
pub const CERT_LOGOTYPE_TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = CERT_LOGOTYPE_CHOICE.TABLE_SIZE_IMAGE_RESOLUTION_CHOICE;

pub const CMSG_KEY_AGREE_OPTION = enum(u32) {
    EPHEMERAL_KEY_CHOICE = 1,
    STATIC_KEY_CHOICE = 2,
};
pub const CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE = CMSG_KEY_AGREE_OPTION.EPHEMERAL_KEY_CHOICE;
pub const CMSG_KEY_AGREE_STATIC_KEY_CHOICE = CMSG_KEY_AGREE_OPTION.STATIC_KEY_CHOICE;

pub const CERT_LOGOTYPE_OPTION = enum(u32) {
    DIRECT_INFO_CHOICE = 1,
    INDIRECT_INFO_CHOICE = 2,
};
pub const CERT_LOGOTYPE_DIRECT_INFO_CHOICE = CERT_LOGOTYPE_OPTION.DIRECT_INFO_CHOICE;
pub const CERT_LOGOTYPE_INDIRECT_INFO_CHOICE = CERT_LOGOTYPE_OPTION.INDIRECT_INFO_CHOICE;

pub const CERT_STORE_PROV_FLAGS = enum(u32) {
    EXTERNAL_FLAG = 1,
    DELETED_FLAG = 2,
    NO_PERSIST_FLAG = 4,
    SYSTEM_STORE_FLAG = 8,
    LM_SYSTEM_STORE_FLAG = 16,
    _,
    pub fn initFlags(o: struct {
        EXTERNAL_FLAG: u1 = 0,
        DELETED_FLAG: u1 = 0,
        NO_PERSIST_FLAG: u1 = 0,
        SYSTEM_STORE_FLAG: u1 = 0,
        LM_SYSTEM_STORE_FLAG: u1 = 0,
    }) CERT_STORE_PROV_FLAGS {
        return @intToEnum(CERT_STORE_PROV_FLAGS,
              (if (o.EXTERNAL_FLAG == 1) @enumToInt(CERT_STORE_PROV_FLAGS.EXTERNAL_FLAG) else 0)
            | (if (o.DELETED_FLAG == 1) @enumToInt(CERT_STORE_PROV_FLAGS.DELETED_FLAG) else 0)
            | (if (o.NO_PERSIST_FLAG == 1) @enumToInt(CERT_STORE_PROV_FLAGS.NO_PERSIST_FLAG) else 0)
            | (if (o.SYSTEM_STORE_FLAG == 1) @enumToInt(CERT_STORE_PROV_FLAGS.SYSTEM_STORE_FLAG) else 0)
            | (if (o.LM_SYSTEM_STORE_FLAG == 1) @enumToInt(CERT_STORE_PROV_FLAGS.LM_SYSTEM_STORE_FLAG) else 0)
        );
    }
};
pub const CERT_STORE_PROV_EXTERNAL_FLAG = CERT_STORE_PROV_FLAGS.EXTERNAL_FLAG;
pub const CERT_STORE_PROV_DELETED_FLAG = CERT_STORE_PROV_FLAGS.DELETED_FLAG;
pub const CERT_STORE_PROV_NO_PERSIST_FLAG = CERT_STORE_PROV_FLAGS.NO_PERSIST_FLAG;
pub const CERT_STORE_PROV_SYSTEM_STORE_FLAG = CERT_STORE_PROV_FLAGS.SYSTEM_STORE_FLAG;
pub const CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG = CERT_STORE_PROV_FLAGS.LM_SYSTEM_STORE_FLAG;

pub const CMSG_KEY_AGREE_ORIGINATOR = enum(u32) {
    CERT = 1,
    PUBLIC_KEY = 2,
};
pub const CMSG_KEY_AGREE_ORIGINATOR_CERT = CMSG_KEY_AGREE_ORIGINATOR.CERT;
pub const CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY = CMSG_KEY_AGREE_ORIGINATOR.PUBLIC_KEY;

pub const CRYPT_CONTEXT_CONFIG_FLAGS = enum(u32) {
    EXCLUSIVE = 1,
    OVERRIDE = 65536,
    _,
    pub fn initFlags(o: struct {
        EXCLUSIVE: u1 = 0,
        OVERRIDE: u1 = 0,
    }) CRYPT_CONTEXT_CONFIG_FLAGS {
        return @intToEnum(CRYPT_CONTEXT_CONFIG_FLAGS,
              (if (o.EXCLUSIVE == 1) @enumToInt(CRYPT_CONTEXT_CONFIG_FLAGS.EXCLUSIVE) else 0)
            | (if (o.OVERRIDE == 1) @enumToInt(CRYPT_CONTEXT_CONFIG_FLAGS.OVERRIDE) else 0)
        );
    }
};
pub const CRYPT_EXCLUSIVE = CRYPT_CONTEXT_CONFIG_FLAGS.EXCLUSIVE;
pub const CRYPT_OVERRIDE = CRYPT_CONTEXT_CONFIG_FLAGS.OVERRIDE;

pub const BCRYPT_DSA_MAGIC = enum(u32) {
    UBLIC_MAGIC = 1112560452,
    RIVATE_MAGIC = 1448104772,
};
pub const BCRYPT_DSA_PUBLIC_MAGIC = BCRYPT_DSA_MAGIC.UBLIC_MAGIC;
pub const BCRYPT_DSA_PRIVATE_MAGIC = BCRYPT_DSA_MAGIC.RIVATE_MAGIC;

pub const CRYPT_XML_X509DATA_TYPE = enum(u32) {
    ISSUER_SERIAL = 1,
    SKI = 2,
    SUBJECT_NAME = 3,
    CERTIFICATE = 4,
    CRL = 5,
    CUSTOM = 6,
};
pub const CRYPT_XML_X509DATA_TYPE_ISSUER_SERIAL = CRYPT_XML_X509DATA_TYPE.ISSUER_SERIAL;
pub const CRYPT_XML_X509DATA_TYPE_SKI = CRYPT_XML_X509DATA_TYPE.SKI;
pub const CRYPT_XML_X509DATA_TYPE_SUBJECT_NAME = CRYPT_XML_X509DATA_TYPE.SUBJECT_NAME;
pub const CRYPT_XML_X509DATA_TYPE_CERTIFICATE = CRYPT_XML_X509DATA_TYPE.CERTIFICATE;
pub const CRYPT_XML_X509DATA_TYPE_CRL = CRYPT_XML_X509DATA_TYPE.CRL;
pub const CRYPT_XML_X509DATA_TYPE_CUSTOM = CRYPT_XML_X509DATA_TYPE.CUSTOM;

pub const CERT_BIOMETRIC_DATA_TYPE = enum(u32) {
    PREDEFINED_DATA_CHOICE = 1,
    OID_DATA_CHOICE = 2,
};
pub const CERT_BIOMETRIC_PREDEFINED_DATA_CHOICE = CERT_BIOMETRIC_DATA_TYPE.PREDEFINED_DATA_CHOICE;
pub const CERT_BIOMETRIC_OID_DATA_CHOICE = CERT_BIOMETRIC_DATA_TYPE.OID_DATA_CHOICE;

pub const CERT_CHAIN_POLICY_FLAGS = enum(u32) {
    IGNORE_NOT_TIME_VALID_FLAG = 1,
    IGNORE_CTL_NOT_TIME_VALID_FLAG = 2,
    IGNORE_NOT_TIME_NESTED_FLAG = 4,
    IGNORE_ALL_NOT_TIME_VALID_FLAGS = 7,
    IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 8,
    ALLOW_UNKNOWN_CA_FLAG = 16,
    IGNORE_WRONG_USAGE_FLAG = 32,
    IGNORE_INVALID_NAME_FLAG = 64,
    IGNORE_INVALID_POLICY_FLAG = 128,
    IGNORE_END_REV_UNKNOWN_FLAG = 256,
    IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = 512,
    IGNORE_CA_REV_UNKNOWN_FLAG = 1024,
    IGNORE_ROOT_REV_UNKNOWN_FLAG = 2048,
    IGNORE_ALL_REV_UNKNOWN_FLAGS = 3840,
    ALLOW_TESTROOT_FLAG = 32768,
    TRUST_TESTROOT_FLAG = 16384,
    IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = 8192,
    IGNORE_PEER_TRUST_FLAG = 4096,
};
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_TIME_VALID_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CTL_NOT_TIME_VALID_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_TIME_NESTED_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS = CERT_CHAIN_POLICY_FLAGS.IGNORE_ALL_NOT_TIME_VALID_FLAGS;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG;
pub const CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = CERT_CHAIN_POLICY_FLAGS.ALLOW_UNKNOWN_CA_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_WRONG_USAGE_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_NAME_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_INVALID_POLICY_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_END_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_CA_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_ROOT_REV_UNKNOWN_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = CERT_CHAIN_POLICY_FLAGS.IGNORE_ALL_REV_UNKNOWN_FLAGS;
pub const CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = CERT_CHAIN_POLICY_FLAGS.ALLOW_TESTROOT_FLAG;
pub const CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = CERT_CHAIN_POLICY_FLAGS.TRUST_TESTROOT_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG;
pub const CERT_CHAIN_POLICY_IGNORE_PEER_TRUST_FLAG = CERT_CHAIN_POLICY_FLAGS.IGNORE_PEER_TRUST_FLAG;

pub const CERT_STRONG_SIGN_FLAGS = enum(u32) {
    CRL_CHECK = 1,
    OCSP_CHECK = 2,
    _,
    pub fn initFlags(o: struct {
        CRL_CHECK: u1 = 0,
        OCSP_CHECK: u1 = 0,
    }) CERT_STRONG_SIGN_FLAGS {
        return @intToEnum(CERT_STRONG_SIGN_FLAGS,
              (if (o.CRL_CHECK == 1) @enumToInt(CERT_STRONG_SIGN_FLAGS.CRL_CHECK) else 0)
            | (if (o.OCSP_CHECK == 1) @enumToInt(CERT_STRONG_SIGN_FLAGS.OCSP_CHECK) else 0)
        );
    }
};
pub const CERT_STRONG_SIGN_ENABLE_CRL_CHECK = CERT_STRONG_SIGN_FLAGS.CRL_CHECK;
pub const CERT_STRONG_SIGN_ENABLE_OCSP_CHECK = CERT_STRONG_SIGN_FLAGS.OCSP_CHECK;

pub const CERT_LOGOTYPE_IMAGE_INFO_TYPE = enum(u32) {
    GRAY_SCALE_IMAGE_INFO_CHOICE = 1,
    COLOR_IMAGE_INFO_CHOICE = 2,
};
pub const CERT_LOGOTYPE_GRAY_SCALE_IMAGE_INFO_CHOICE = CERT_LOGOTYPE_IMAGE_INFO_TYPE.GRAY_SCALE_IMAGE_INFO_CHOICE;
pub const CERT_LOGOTYPE_COLOR_IMAGE_INFO_CHOICE = CERT_LOGOTYPE_IMAGE_INFO_TYPE.COLOR_IMAGE_INFO_CHOICE;

pub const CRYPT_XML_STATUS_INFO_STATUS = enum(u32) {
    INTERNAL_REFERENCE = 1,
    KEY_AVAILABLE = 2,
    DIGESTING = 4,
    DIGEST_VALID = 8,
    SIGNATURE_VALID = 65536,
    OPENED_TO_ENCODE = 2147483648,
};
pub const CRYPT_XML_STATUS_INTERNAL_REFERENCE = CRYPT_XML_STATUS_INFO_STATUS.INTERNAL_REFERENCE;
pub const CRYPT_XML_STATUS_KEY_AVAILABLE = CRYPT_XML_STATUS_INFO_STATUS.KEY_AVAILABLE;
pub const CRYPT_XML_STATUS_DIGESTING = CRYPT_XML_STATUS_INFO_STATUS.DIGESTING;
pub const CRYPT_XML_STATUS_DIGEST_VALID = CRYPT_XML_STATUS_INFO_STATUS.DIGEST_VALID;
pub const CRYPT_XML_STATUS_SIGNATURE_VALID = CRYPT_XML_STATUS_INFO_STATUS.SIGNATURE_VALID;
pub const CRYPT_XML_STATUS_OPENED_TO_ENCODE = CRYPT_XML_STATUS_INFO_STATUS.OPENED_TO_ENCODE;

pub const CRYPT_XML_TRANSFORM_FLAGS = enum(u32) {
    ON_STREAM = 1,
    ON_NODESET = 2,
    URI_QUERY_STRING = 3,
    _,
    pub fn initFlags(o: struct {
        ON_STREAM: u1 = 0,
        ON_NODESET: u1 = 0,
        URI_QUERY_STRING: u1 = 0,
    }) CRYPT_XML_TRANSFORM_FLAGS {
        return @intToEnum(CRYPT_XML_TRANSFORM_FLAGS,
              (if (o.ON_STREAM == 1) @enumToInt(CRYPT_XML_TRANSFORM_FLAGS.ON_STREAM) else 0)
            | (if (o.ON_NODESET == 1) @enumToInt(CRYPT_XML_TRANSFORM_FLAGS.ON_NODESET) else 0)
            | (if (o.URI_QUERY_STRING == 1) @enumToInt(CRYPT_XML_TRANSFORM_FLAGS.URI_QUERY_STRING) else 0)
        );
    }
};
pub const CRYPT_XML_TRANSFORM_ON_STREAM = CRYPT_XML_TRANSFORM_FLAGS.ON_STREAM;
pub const CRYPT_XML_TRANSFORM_ON_NODESET = CRYPT_XML_TRANSFORM_FLAGS.ON_NODESET;
pub const CRYPT_XML_TRANSFORM_URI_QUERY_STRING = CRYPT_XML_TRANSFORM_FLAGS.URI_QUERY_STRING;

pub const CRYPT_XML_GROUP_ID = enum(u32) {
    HASH_________ = 1,
    SIGN_________ = 2,
};
pub const CRYPT_XML_GROUP_ID_HASH_________ = CRYPT_XML_GROUP_ID.HASH_________;
pub const CRYPT_XML_GROUP_ID_SIGN_________ = CRYPT_XML_GROUP_ID.SIGN_________;

pub const CERT_SELECT_CRITERIA_TYPE = enum(u32) {
    ENHKEY_USAGE = 1,
    KEY_USAGE = 2,
    POLICY_OID = 3,
    PROV_NAME = 4,
    EXTENSION = 5,
    SUBJECT_HOST_NAME = 6,
    ISSUER_ATTR = 7,
    SUBJECT_ATTR = 8,
    ISSUER_NAME = 9,
    PUBLIC_KEY = 10,
    TLS_SIGNATURES = 11,
};
pub const CERT_SELECT_BY_ENHKEY_USAGE = CERT_SELECT_CRITERIA_TYPE.ENHKEY_USAGE;
pub const CERT_SELECT_BY_KEY_USAGE = CERT_SELECT_CRITERIA_TYPE.KEY_USAGE;
pub const CERT_SELECT_BY_POLICY_OID = CERT_SELECT_CRITERIA_TYPE.POLICY_OID;
pub const CERT_SELECT_BY_PROV_NAME = CERT_SELECT_CRITERIA_TYPE.PROV_NAME;
pub const CERT_SELECT_BY_EXTENSION = CERT_SELECT_CRITERIA_TYPE.EXTENSION;
pub const CERT_SELECT_BY_SUBJECT_HOST_NAME = CERT_SELECT_CRITERIA_TYPE.SUBJECT_HOST_NAME;
pub const CERT_SELECT_BY_ISSUER_ATTR = CERT_SELECT_CRITERIA_TYPE.ISSUER_ATTR;
pub const CERT_SELECT_BY_SUBJECT_ATTR = CERT_SELECT_CRITERIA_TYPE.SUBJECT_ATTR;
pub const CERT_SELECT_BY_ISSUER_NAME = CERT_SELECT_CRITERIA_TYPE.ISSUER_NAME;
pub const CERT_SELECT_BY_PUBLIC_KEY = CERT_SELECT_CRITERIA_TYPE.PUBLIC_KEY;
pub const CERT_SELECT_BY_TLS_SIGNATURES = CERT_SELECT_CRITERIA_TYPE.TLS_SIGNATURES;

pub const BCRYPT_RSAKEY_BLOB_MAGIC = enum(u32) {
    PUBLIC_MAGIC = 826364754,
    PRIVATE_MAGIC = 843141970,
    FULLPRIVATE_MAGIC = 859919186,
};
pub const BCRYPT_RSAPUBLIC_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.PUBLIC_MAGIC;
pub const BCRYPT_RSAPRIVATE_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.PRIVATE_MAGIC;
pub const BCRYPT_RSAFULLPRIVATE_MAGIC = BCRYPT_RSAKEY_BLOB_MAGIC.FULLPRIVATE_MAGIC;

pub const CRYPT_XML_KEYINFO_TYPE = enum(u32) {
    KEYNAME = 1,
    KEYVALUE = 2,
    RETRIEVAL = 3,
    X509DATA = 4,
    CUSTOM = 5,
};
pub const CRYPT_XML_KEYINFO_TYPE_KEYNAME = CRYPT_XML_KEYINFO_TYPE.KEYNAME;
pub const CRYPT_XML_KEYINFO_TYPE_KEYVALUE = CRYPT_XML_KEYINFO_TYPE.KEYVALUE;
pub const CRYPT_XML_KEYINFO_TYPE_RETRIEVAL = CRYPT_XML_KEYINFO_TYPE.RETRIEVAL;
pub const CRYPT_XML_KEYINFO_TYPE_X509DATA = CRYPT_XML_KEYINFO_TYPE.X509DATA;
pub const CRYPT_XML_KEYINFO_TYPE_CUSTOM = CRYPT_XML_KEYINFO_TYPE.CUSTOM;

pub const CRYPT_TIMESTAMP_VERSION = enum(u32) {
    N = 1,
};
pub const TIMESTAMP_VERSION = CRYPT_TIMESTAMP_VERSION.N;

pub const CERT_ID_OPTION = enum(u32) {
    ISSUER_SERIAL_NUMBER = 1,
    KEY_IDENTIFIER = 2,
    SHA1_HASH = 3,
};
pub const CERT_ID_ISSUER_SERIAL_NUMBER = CERT_ID_OPTION.ISSUER_SERIAL_NUMBER;
pub const CERT_ID_KEY_IDENTIFIER = CERT_ID_OPTION.KEY_IDENTIFIER;
pub const CERT_ID_SHA1_HASH = CERT_ID_OPTION.SHA1_HASH;

pub const HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE = enum(u32) {
    CLIENT = 1,
    SERVER = 2,
};
pub const AUTHTYPE_CLIENT = HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE.CLIENT;
pub const AUTHTYPE_SERVER = HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE.SERVER;

pub const BCRYPT_DH_KEY_BLOB_MAGIC = enum(u32) {
    UBLIC_MAGIC = 1112557636,
    RIVATE_MAGIC = 1448101956,
};
pub const BCRYPT_DH_PUBLIC_MAGIC = BCRYPT_DH_KEY_BLOB_MAGIC.UBLIC_MAGIC;
pub const BCRYPT_DH_PRIVATE_MAGIC = BCRYPT_DH_KEY_BLOB_MAGIC.RIVATE_MAGIC;

pub const CRYPT_XML_STATUS_ERROR_STATUS = enum(u32) {
    NOT_RESOLVED = 1,
    DIGEST_INVALID = 2,
    NOT_SUPPORTED_ALGORITHM = 5,
    NOT_SUPPORTED_TRANSFORM = 8,
    SIGNATURE_INVALID = 65536,
    KEYINFO_NOT_PARSED = 131072,
};
pub const CRYPT_XML_STATUS_ERROR_NOT_RESOLVED = CRYPT_XML_STATUS_ERROR_STATUS.NOT_RESOLVED;
pub const CRYPT_XML_STATUS_ERROR_DIGEST_INVALID = CRYPT_XML_STATUS_ERROR_STATUS.DIGEST_INVALID;
pub const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_ALGORITHM = CRYPT_XML_STATUS_ERROR_STATUS.NOT_SUPPORTED_ALGORITHM;
pub const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_TRANSFORM = CRYPT_XML_STATUS_ERROR_STATUS.NOT_SUPPORTED_TRANSFORM;
pub const CRYPT_XML_STATUS_ERROR_SIGNATURE_INVALID = CRYPT_XML_STATUS_ERROR_STATUS.SIGNATURE_INVALID;
pub const CRYPT_XML_STATUS_ERROR_KEYINFO_NOT_PARSED = CRYPT_XML_STATUS_ERROR_STATUS.KEYINFO_NOT_PARSED;

pub const CRYPT_TIMESTAMP_RESPONSE_STATUS = enum(u32) {
    GRANTED = 0,
    GRANTED_WITH_MODS = 1,
    REJECTED = 2,
    WAITING = 3,
    REVOCATION_WARNING = 4,
    REVOKED = 5,
};
pub const TIMESTAMP_STATUS_GRANTED = CRYPT_TIMESTAMP_RESPONSE_STATUS.GRANTED;
pub const TIMESTAMP_STATUS_GRANTED_WITH_MODS = CRYPT_TIMESTAMP_RESPONSE_STATUS.GRANTED_WITH_MODS;
pub const TIMESTAMP_STATUS_REJECTED = CRYPT_TIMESTAMP_RESPONSE_STATUS.REJECTED;
pub const TIMESTAMP_STATUS_WAITING = CRYPT_TIMESTAMP_RESPONSE_STATUS.WAITING;
pub const TIMESTAMP_STATUS_REVOCATION_WARNING = CRYPT_TIMESTAMP_RESPONSE_STATUS.REVOCATION_WARNING;
pub const TIMESTAMP_STATUS_REVOKED = CRYPT_TIMESTAMP_RESPONSE_STATUS.REVOKED;

pub const NCRYPT_ALGORITHM_NAME_CLASS = enum(u32) {
    ASYMMETRIC_ENCRYPTION_INTERFACE = 3,
    SECRET_AGREEMENT_INTERFACE = 4,
    SIGNATURE_INTERFACE = 5,
};
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const NCRYPT_SECRET_AGREEMENT_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.SECRET_AGREEMENT_INTERFACE;
pub const NCRYPT_SIGNATURE_INTERFACE = NCRYPT_ALGORITHM_NAME_CLASS.SIGNATURE_INTERFACE;

// TODO: this type has a FreeFunc 'CryptCloseAsyncHandle', what can Zig do with this information?
pub const HCRYPTASYNC = *opaque{};

// TODO: this type has a FreeFunc 'CertFreeCertificateChainEngine', what can Zig do with this information?
pub const HCERTCHAINENGINE = *opaque{};

// TODO: this type has a FreeFunc 'BCryptCloseAlgorithmProvider', what can Zig do with this information?
pub const BCRYPT_ALG_HANDLE = isize;

// TODO: this type has a FreeFunc 'BCryptDestroyKey', what can Zig do with this information?
pub const BCRYPT_KEY_HANDLE = isize;

pub const CMS_KEY_INFO = extern struct {
    dwVersion: u32,
    Algid: u32,
    pbOID: ?*u8,
    cbOID: u32,
};

pub const HMAC_Info = extern struct {
    HashAlgid: u32,
    pbInnerString: ?*u8,
    cbInnerString: u32,
    pbOuterString: ?*u8,
    cbOuterString: u32,
};

pub const SCHANNEL_ALG = extern struct {
    dwUse: u32,
    Algid: u32,
    cBits: u32,
    dwFlags: u32,
    dwReserved: u32,
};

pub const PROV_ENUMALGS = extern struct {
    aiAlgid: u32,
    dwBitLen: u32,
    dwNameLen: u32,
    szName: [20]CHAR,
};

pub const PROV_ENUMALGS_EX = extern struct {
    aiAlgid: u32,
    dwDefaultLen: u32,
    dwMinLen: u32,
    dwMaxLen: u32,
    dwProtocols: u32,
    dwNameLen: u32,
    szName: [20]CHAR,
    dwLongNameLen: u32,
    szLongName: [40]CHAR,
};

pub const PUBLICKEYSTRUC = extern struct {
    bType: u8,
    bVersion: u8,
    reserved: u16,
    aiKeyAlg: u32,
};

pub const RSAPUBKEY = extern struct {
    magic: u32,
    bitlen: u32,
    pubexp: u32,
};

pub const PUBKEY = extern struct {
    magic: u32,
    bitlen: u32,
};

pub const DSSSEED = extern struct {
    counter: u32,
    seed: [20]u8,
};

pub const PUBKEYVER3 = extern struct {
    magic: u32,
    bitlenP: u32,
    bitlenQ: u32,
    bitlenJ: u32,
    DSSSeed: DSSSEED,
};

pub const PRIVKEYVER3 = extern struct {
    magic: u32,
    bitlenP: u32,
    bitlenQ: u32,
    bitlenJ: u32,
    bitlenX: u32,
    DSSSeed: DSSSEED,
};

pub const KEY_TYPE_SUBTYPE = extern struct {
    dwKeySpec: u32,
    Type: Guid,
    Subtype: Guid,
};

pub const CERT_FORTEZZA_DATA_PROP = extern struct {
    SerialNumber: [8]u8,
    CertIndex: i32,
    CertLabel: [36]u8,
};

pub const CRYPT_RC4_KEY_STATE = extern struct {
    Key: [16]u8,
    SBox: [256]u8,
    i: u8,
    j: u8,
};

pub const CRYPT_DES_KEY_STATE = extern struct {
    Key: [8]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};

pub const CRYPT_3DES_KEY_STATE = extern struct {
    Key: [24]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};

pub const CRYPT_AES_128_KEY_STATE = extern struct {
    Key: [16]u8,
    IV: [16]u8,
    EncryptionState: [176]u8,
    DecryptionState: [176]u8,
    Feedback: [16]u8,
};

pub const CRYPT_AES_256_KEY_STATE = extern struct {
    Key: [32]u8,
    IV: [16]u8,
    EncryptionState: [240]u8,
    DecryptionState: [240]u8,
    Feedback: [16]u8,
};

pub const CRYPTOAPI_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};

pub const CMS_DH_KEY_INFO = extern struct {
    dwVersion: u32,
    Algid: u32,
    pszContentEncObjId: ?PSTR,
    PubInfo: CRYPTOAPI_BLOB,
    pReserved: ?*anyopaque,
};

pub const BCRYPT_KEY_LENGTHS_STRUCT = extern struct {
    dwMinLength: u32,
    dwMaxLength: u32,
    dwIncrement: u32,
};

pub const BCRYPT_OID = extern struct {
    cbOID: u32,
    pbOID: ?*u8,
};

pub const BCRYPT_OID_LIST = extern struct {
    dwOIDCount: u32,
    pOIDs: ?*BCRYPT_OID,
};

pub const BCRYPT_PKCS1_PADDING_INFO = extern struct {
    pszAlgId: ?[*:0]const u16,
};

pub const BCRYPT_PSS_PADDING_INFO = extern struct {
    pszAlgId: ?[*:0]const u16,
    cbSalt: u32,
};

pub const BCRYPT_OAEP_PADDING_INFO = extern struct {
    pszAlgId: ?[*:0]const u16,
    pbLabel: ?*u8,
    cbLabel: u32,
};

pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = extern struct {
    cbSize: u32,
    dwInfoVersion: u32,
    pbNonce: ?*u8,
    cbNonce: u32,
    pbAuthData: ?*u8,
    cbAuthData: u32,
    pbTag: ?*u8,
    cbTag: u32,
    pbMacContext: ?*u8,
    cbMacContext: u32,
    cbAAD: u32,
    cbData: u64,
    dwFlags: u32,
};

pub const BCryptBuffer = extern struct {
    cbBuffer: u32,
    BufferType: u32,
    pvBuffer: ?*anyopaque,
};

pub const BCryptBufferDesc = extern struct {
    ulVersion: u32,
    cBuffers: u32,
    pBuffers: ?*BCryptBuffer,
};

pub const BCRYPT_KEY_BLOB = extern struct {
    Magic: u32,
};

pub const BCRYPT_RSAKEY_BLOB = extern struct {
    Magic: BCRYPT_RSAKEY_BLOB_MAGIC,
    BitLength: u32,
    cbPublicExp: u32,
    cbModulus: u32,
    cbPrime1: u32,
    cbPrime2: u32,
};

pub const BCRYPT_ECCKEY_BLOB = extern struct {
    dwMagic: u32,
    cbKey: u32,
};

pub const SSL_ECCKEY_BLOB = extern struct {
    dwCurveType: u32,
    cbKey: u32,
};

pub const ECC_CURVE_TYPE_ENUM = enum(i32) {
    SHORT_WEIERSTRASS_CURVE = 1,
    TWISTED_EDWARDS_CURVE = 2,
    MONTGOMERY_CURVE = 3,
};
pub const BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = ECC_CURVE_TYPE_ENUM.SHORT_WEIERSTRASS_CURVE;
pub const BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = ECC_CURVE_TYPE_ENUM.TWISTED_EDWARDS_CURVE;
pub const BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = ECC_CURVE_TYPE_ENUM.MONTGOMERY_CURVE;

pub const ECC_CURVE_ALG_ID_ENUM = enum(i32) {
    D = 0,
};
pub const BCRYPT_NO_CURVE_GENERATION_ALG_ID = ECC_CURVE_ALG_ID_ENUM.D;

pub const BCRYPT_ECCFULLKEY_BLOB = extern struct {
    dwMagic: u32,
    dwVersion: u32,
    dwCurveType: ECC_CURVE_TYPE_ENUM,
    dwCurveGenerationAlgId: ECC_CURVE_ALG_ID_ENUM,
    cbFieldLength: u32,
    cbSubgroupOrder: u32,
    cbCofactor: u32,
    cbSeed: u32,
};

pub const BCRYPT_DH_KEY_BLOB = extern struct {
    dwMagic: BCRYPT_DH_KEY_BLOB_MAGIC,
    cbKey: u32,
};

pub const BCRYPT_DH_PARAMETER_HEADER = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
};

pub const BCRYPT_DSA_KEY_BLOB = extern struct {
    dwMagic: BCRYPT_DSA_MAGIC,
    cbKey: u32,
    Count: [4]u8,
    Seed: [20]u8,
    q: [20]u8,
};

pub const HASHALGORITHM_ENUM = enum(i32) {
    @"1" = 0,
    @"256" = 1,
    @"512" = 2,
};
pub const DSA_HASH_ALGORITHM_SHA1 = HASHALGORITHM_ENUM.@"1";
pub const DSA_HASH_ALGORITHM_SHA256 = HASHALGORITHM_ENUM.@"256";
pub const DSA_HASH_ALGORITHM_SHA512 = HASHALGORITHM_ENUM.@"512";

pub const DSAFIPSVERSION_ENUM = enum(i32) {
    @"2" = 0,
    @"3" = 1,
};
pub const DSA_FIPS186_2 = DSAFIPSVERSION_ENUM.@"2";
pub const DSA_FIPS186_3 = DSAFIPSVERSION_ENUM.@"3";

pub const BCRYPT_DSA_KEY_BLOB_V2 = extern struct {
    dwMagic: BCRYPT_DSA_MAGIC,
    cbKey: u32,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: u32,
    cbGroupSize: u32,
    Count: [4]u8,
};

pub const BCRYPT_KEY_DATA_BLOB_HEADER = extern struct {
    dwMagic: u32,
    dwVersion: u32,
    cbKeyData: u32,
};

pub const BCRYPT_DSA_PARAMETER_HEADER = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
    Count: [4]u8,
    Seed: [20]u8,
    q: [20]u8,
};

pub const BCRYPT_DSA_PARAMETER_HEADER_V2 = extern struct {
    cbLength: u32,
    dwMagic: u32,
    cbKeyLength: u32,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: u32,
    cbGroupSize: u32,
    Count: [4]u8,
};

pub const BCRYPT_ECC_CURVE_NAMES = extern struct {
    dwEccCurveNames: u32,
    pEccCurveNames: ?*?PWSTR,
};

pub const BCRYPT_HASH_OPERATION_TYPE = enum(i32) {
    HASH_DATA = 1,
    FINISH_HASH = 2,
};
pub const BCRYPT_HASH_OPERATION_HASH_DATA = BCRYPT_HASH_OPERATION_TYPE.HASH_DATA;
pub const BCRYPT_HASH_OPERATION_FINISH_HASH = BCRYPT_HASH_OPERATION_TYPE.FINISH_HASH;

pub const BCRYPT_MULTI_HASH_OPERATION = extern struct {
    iHash: u32,
    hashOperation: BCRYPT_HASH_OPERATION_TYPE,
    pbBuffer: ?*u8,
    cbBuffer: u32,
};

pub const BCRYPT_MULTI_OPERATION_TYPE = enum(i32) {
    H = 1,
};
pub const BCRYPT_OPERATION_TYPE_HASH = BCRYPT_MULTI_OPERATION_TYPE.H;

pub const BCRYPT_MULTI_OBJECT_LENGTH_STRUCT = extern struct {
    cbPerObject: u32,
    cbPerElement: u32,
};

pub const BCRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszName: ?PWSTR,
    dwClass: u32,
    dwFlags: u32,
};

pub const BCRYPT_PROVIDER_NAME = extern struct {
    pszProviderName: ?PWSTR,
};

pub const BCRYPT_INTERFACE_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
};

pub const CRYPT_INTERFACE_REG = extern struct {
    dwInterface: BCRYPT_INTERFACE,
    dwFlags: BCRYPT_TABLE,
    cFunctions: u32,
    rgpszFunctions: ?*?PWSTR,
};

pub const CRYPT_IMAGE_REG = extern struct {
    pszImage: ?PWSTR,
    cInterfaces: u32,
    rgpInterfaces: ?*?*CRYPT_INTERFACE_REG,
};

pub const CRYPT_PROVIDER_REG = extern struct {
    cAliases: u32,
    rgpszAliases: ?*?PWSTR,
    pUM: ?*CRYPT_IMAGE_REG,
    pKM: ?*CRYPT_IMAGE_REG,
};

pub const CRYPT_PROVIDERS = extern struct {
    cProviders: u32,
    rgpszProviders: ?*?PWSTR,
};

pub const CRYPT_CONTEXT_CONFIG = extern struct {
    dwFlags: CRYPT_CONTEXT_CONFIG_FLAGS,
    dwReserved: u32,
};

pub const CRYPT_CONTEXT_FUNCTION_CONFIG = extern struct {
    dwFlags: u32,
    dwReserved: u32,
};

pub const CRYPT_CONTEXTS = extern struct {
    cContexts: u32,
    rgpszContexts: ?*?PWSTR,
};

pub const CRYPT_CONTEXT_FUNCTIONS = extern struct {
    cFunctions: u32,
    rgpszFunctions: ?*?PWSTR,
};

pub const CRYPT_CONTEXT_FUNCTION_PROVIDERS = extern struct {
    cProviders: u32,
    rgpszProviders: ?*?PWSTR,
};

pub const CRYPT_PROPERTY_REF = extern struct {
    pszProperty: ?PWSTR,
    cbValue: u32,
    pbValue: ?*u8,
};

pub const CRYPT_IMAGE_REF = extern struct {
    pszImage: ?PWSTR,
    dwFlags: CRYPT_IMAGE_REF_FLAGS,
};

pub const CRYPT_PROVIDER_REF = extern struct {
    dwInterface: u32,
    pszFunction: ?PWSTR,
    pszProvider: ?PWSTR,
    cProperties: u32,
    rgpProperties: ?*?*CRYPT_PROPERTY_REF,
    pUM: ?*CRYPT_IMAGE_REF,
    pKM: ?*CRYPT_IMAGE_REF,
};

pub const CRYPT_PROVIDER_REFS = extern struct {
    cProviders: u32,
    rgpProviders: ?*?*CRYPT_PROVIDER_REF,
};

pub const PFN_NCRYPT_ALLOC = fn(
    cbSize: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const PFN_NCRYPT_FREE = fn(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NCRYPT_ALLOC_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: ?PFN_NCRYPT_ALLOC,
    pfnFree: ?PFN_NCRYPT_FREE,
};

pub const NCRYPT_CIPHER_PADDING_INFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pbIV: ?*u8,
    cbIV: u32,
    pbOtherInfo: ?*u8,
    cbOtherInfo: u32,
};

pub const NCRYPT_PLATFORM_ATTEST_PADDING_INFO = extern struct {
    magic: u32,
    pcrMask: u32,
};

pub const NCRYPT_KEY_ATTEST_PADDING_INFO = extern struct {
    magic: u32,
    pbKeyBlob: ?*u8,
    cbKeyBlob: u32,
    pbKeyAuth: ?*u8,
    cbKeyAuth: u32,
};

pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = extern struct {
    Version: u32,
    Flags: u32,
    cbPublicKeyBlob: u32,
};

pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    cbSignature: u32,
    cbReport: u32,
    cbAttributes: u32,
};

pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = extern struct {
    Version: u32,
    TrustletId: u64,
    MinSvn: u32,
    FlagsMask: u32,
    FlagsExpected: u32,
    _bitfield: u32,
};

pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER = extern struct {
    Version: u32,
    KeyUsage: u32,
    _bitfield: u32,
    cbAlgName: u32,
    cbNonce: u32,
    cbAuthTag: u32,
    cbWrappingKey: u32,
    cbIsolatedKey: u32,
};

pub const NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = extern struct {
    Header: NCRYPT_EXPORTED_ISOLATED_KEY_HEADER,
};

pub const __NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    HeaderSize: u32,
    cbCertifyInfo: u32,
    cbSignature: u32,
    cbTpmPublic: u32,
};

pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = extern struct {
    Magic: u32,
    Version: u32,
    pcrAlg: u32,
    cbSignature: u32,
    cbQuote: u32,
    cbPcrs: u32,
};

pub const NCryptAlgorithmName = extern struct {
    pszName: ?PWSTR,
    dwClass: NCRYPT_ALGORITHM_NAME_CLASS,
    dwAlgOperations: NCRYPT_OPERATION,
    dwFlags: u32,
};

pub const NCryptKeyName = extern struct {
    pszName: ?PWSTR,
    pszAlgid: ?PWSTR,
    dwLegacyKeySpec: CERT_KEY_SPEC,
    dwFlags: u32,
};

pub const NCryptProviderName = extern struct {
    pszName: ?PWSTR,
    pszComment: ?PWSTR,
};

pub const NCRYPT_UI_POLICY = extern struct {
    dwVersion: u32,
    dwFlags: u32,
    pszCreationTitle: ?[*:0]const u16,
    pszFriendlyName: ?[*:0]const u16,
    pszDescription: ?[*:0]const u16,
};

pub const NCRYPT_KEY_ACCESS_POLICY_BLOB = extern struct {
    dwVersion: u32,
    dwPolicyFlags: u32,
    cbUserSid: u32,
    cbApplicationSid: u32,
};

pub const NCRYPT_SUPPORTED_LENGTHS = extern struct {
    dwMinLength: u32,
    dwMaxLength: u32,
    dwIncrement: u32,
    dwDefaultLength: u32,
};

pub const NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO = extern struct {
    dwVersion: u32,
    iExpiration: i32,
    pabNonce: [32]u8,
    pabPolicyRef: [32]u8,
    pabHMAC: [32]u8,
};

pub const NCRYPT_PCP_TPM_FW_VERSION_INFO = extern struct {
    major1: u16,
    major2: u16,
    minor1: u16,
    minor2: u16,
};

pub const NCRYPT_PCP_RAW_POLICYDIGEST = extern struct {
    dwVersion: u32,
    cbDigest: u32,
};

pub const NCRYPT_KEY_BLOB_HEADER = extern struct {
    cbSize: u32,
    dwMagic: u32,
    cbAlgName: u32,
    cbKeyData: u32,
};

pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = extern struct {
    magic: u32,
    cbHeader: u32,
    cbPublic: u32,
    cbPrivate: u32,
    cbName: u32,
};

pub const CRYPT_BIT_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
    cUnusedBits: u32,
};

pub const CRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszObjId: ?PSTR,
    Parameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_OBJID_TABLE = extern struct {
    dwAlgId: u32,
    pszObjId: ?[*:0]const u8,
};

pub const CRYPT_HASH_INFO = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPTOAPI_BLOB,
};

pub const CERT_EXTENSION = extern struct {
    pszObjId: ?PSTR,
    fCritical: BOOL,
    Value: CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTE_TYPE_VALUE = extern struct {
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTE = extern struct {
    pszObjId: ?PSTR,
    cValue: u32,
    rgValue: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_ATTRIBUTES = extern struct {
    cAttr: u32,
    rgAttr: ?*CRYPT_ATTRIBUTE,
};

pub const CERT_RDN_ATTR = extern struct {
    pszObjId: ?PSTR,
    dwValueType: CERT_RDN_ATTR_VALUE_TYPE,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_RDN = extern struct {
    cRDNAttr: u32,
    rgRDNAttr: ?*CERT_RDN_ATTR,
};

pub const CERT_NAME_INFO = extern struct {
    cRDN: u32,
    rgRDN: ?*CERT_RDN,
};

pub const CERT_NAME_VALUE = extern struct {
    dwValueType: u32,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_PUBLIC_KEY_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PublicKey: CRYPT_BIT_BLOB,
};

pub const CRYPT_ECC_PRIVATE_KEY_INFO = extern struct {
    dwVersion: u32,
    PrivateKey: CRYPTOAPI_BLOB,
    szCurveOid: ?PSTR,
    PublicKey: CRYPT_BIT_BLOB,
};

pub const CRYPT_PRIVATE_KEY_INFO = extern struct {
    Version: u32,
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PrivateKey: CRYPTOAPI_BLOB,
    pAttributes: ?*CRYPT_ATTRIBUTES,
};

pub const CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = extern struct {
    EncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedPrivateKey: CRYPTOAPI_BLOB,
};

pub const PCRYPT_DECRYPT_PRIVATE_KEY_FUNC = fn(
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedPrivateKey: CRYPTOAPI_BLOB,
    // TODO: what to do with BytesParamIndex 3?
    pbClearTextKey: ?*u8,
    pcbClearTextKey: ?*u32,
    pVoidDecryptFunc: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC = fn(
    pAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pClearTextPrivateKey: ?*CRYPTOAPI_BLOB,
    // TODO: what to do with BytesParamIndex 3?
    pbEncryptedKey: ?*u8,
    pcbEncryptedKey: ?*u32,
    pVoidEncryptFunc: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PCRYPT_RESOLVE_HCRYPTPROV_FUNC = fn(
    pPrivateKeyInfo: ?*CRYPT_PRIVATE_KEY_INFO,
    phCryptProv: ?*usize,
    pVoidResolveFunc: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PKCS8_IMPORT_PARAMS = extern struct {
    PrivateKey: CRYPTOAPI_BLOB,
    pResolvehCryptProvFunc: ?PCRYPT_RESOLVE_HCRYPTPROV_FUNC,
    pVoidResolveFunc: ?*anyopaque,
    pDecryptPrivateKeyFunc: ?PCRYPT_DECRYPT_PRIVATE_KEY_FUNC,
    pVoidDecryptFunc: ?*anyopaque,
};

pub const CRYPT_PKCS8_EXPORT_PARAMS = extern struct {
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: ?PSTR,
    pEncryptPrivateKeyFunc: ?PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC,
    pVoidEncryptFunc: ?*anyopaque,
};

pub const CERT_INFO = extern struct {
    dwVersion: u32,
    SerialNumber: CRYPTOAPI_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CRYPTOAPI_BLOB,
    NotBefore: FILETIME,
    NotAfter: FILETIME,
    Subject: CRYPTOAPI_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    IssuerUniqueId: CRYPT_BIT_BLOB,
    SubjectUniqueId: CRYPT_BIT_BLOB,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRL_ENTRY = extern struct {
    SerialNumber: CRYPTOAPI_BLOB,
    RevocationDate: FILETIME,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRL_INFO = extern struct {
    dwVersion: u32,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CRYPTOAPI_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cCRLEntry: u32,
    rgCRLEntry: ?*CRL_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CERT_OR_CRL_BLOB = extern struct {
    dwChoice: u32,
    cbEncoded: u32,
    pbEncoded: ?*u8,
};

pub const CERT_OR_CRL_BUNDLE = extern struct {
    cItem: u32,
    rgItem: ?*CERT_OR_CRL_BLOB,
};

pub const CERT_REQUEST_INFO = extern struct {
    dwVersion: u32,
    Subject: CRYPTOAPI_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CERT_KEYGEN_REQUEST_INFO = extern struct {
    dwVersion: u32,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    pwszChallengeString: ?PWSTR,
};

pub const CERT_SIGNED_CONTENT_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
};

pub const CTL_USAGE = extern struct {
    cUsageIdentifier: u32,
    rgpszUsageIdentifier: ?*?PSTR,
};

pub const CTL_ENTRY = extern struct {
    SubjectIdentifier: CRYPTOAPI_BLOB,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CTL_INFO = extern struct {
    dwVersion: u32,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPTOAPI_BLOB,
    SequenceNumber: CRYPTOAPI_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cCTLEntry: u32,
    rgCTLEntry: ?*CTL_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRYPT_TIME_STAMP_REQUEST_INFO = extern struct {
    pszTimeStampAlgorithm: ?PSTR,
    pszContentType: ?PSTR,
    Content: CRYPTOAPI_BLOB,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CRYPT_ENROLLMENT_NAME_VALUE_PAIR = extern struct {
    pwszName: ?PWSTR,
    pwszValue: ?PWSTR,
};

pub const CRYPT_CSP_PROVIDER = extern struct {
    dwKeySpec: u32,
    pwszProviderName: ?PWSTR,
    Signature: CRYPT_BIT_BLOB,
};

pub const PFN_CRYPT_ALLOC = fn(
    cbSize: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const PFN_CRYPT_FREE = fn(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_ENCODE_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: ?PFN_CRYPT_ALLOC,
    pfnFree: ?PFN_CRYPT_FREE,
};

pub const CRYPT_DECODE_PARA = extern struct {
    cbSize: u32,
    pfnAlloc: ?PFN_CRYPT_ALLOC,
    pfnFree: ?PFN_CRYPT_FREE,
};

pub const CERT_EXTENSIONS = extern struct {
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CERT_AUTHORITY_KEY_ID_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    CertIssuer: CRYPTOAPI_BLOB,
    CertSerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_PRIVATE_KEY_VALIDITY = extern struct {
    NotBefore: FILETIME,
    NotAfter: FILETIME,
};

pub const CERT_KEY_ATTRIBUTES_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    pPrivateKeyUsagePeriod: ?*CERT_PRIVATE_KEY_VALIDITY,
};

pub const CERT_POLICY_ID = extern struct {
    cCertPolicyElementId: u32,
    rgpszCertPolicyElementId: ?*?PSTR,
};

pub const CERT_KEY_USAGE_RESTRICTION_INFO = extern struct {
    cCertPolicyId: u32,
    rgCertPolicyId: ?*CERT_POLICY_ID,
    RestrictedKeyUsage: CRYPT_BIT_BLOB,
};

pub const CERT_OTHER_NAME = extern struct {
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CERT_ALT_NAME_ENTRY = extern struct {
    dwAltNameChoice: u32,
    Anonymous: extern union {
        pOtherName: ?*CERT_OTHER_NAME,
        pwszRfc822Name: ?PWSTR,
        pwszDNSName: ?PWSTR,
        DirectoryName: CRYPTOAPI_BLOB,
        pwszURL: ?PWSTR,
        IPAddress: CRYPTOAPI_BLOB,
        pszRegisteredID: ?PSTR,
    },
};

pub const CERT_ALT_NAME_INFO = extern struct {
    cAltEntry: u32,
    rgAltEntry: ?*CERT_ALT_NAME_ENTRY,
};

pub const CERT_BASIC_CONSTRAINTS_INFO = extern struct {
    SubjectType: CRYPT_BIT_BLOB,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: u32,
    cSubtreesConstraint: u32,
    rgSubtreesConstraint: ?*CRYPTOAPI_BLOB,
};

pub const CERT_BASIC_CONSTRAINTS2_INFO = extern struct {
    fCA: BOOL,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: u32,
};

pub const CERT_POLICY_QUALIFIER_INFO = extern struct {
    pszPolicyQualifierId: ?PSTR,
    Qualifier: CRYPTOAPI_BLOB,
};

pub const CERT_POLICY_INFO = extern struct {
    pszPolicyIdentifier: ?PSTR,
    cPolicyQualifier: u32,
    rgPolicyQualifier: ?*CERT_POLICY_QUALIFIER_INFO,
};

pub const CERT_POLICIES_INFO = extern struct {
    cPolicyInfo: u32,
    rgPolicyInfo: ?*CERT_POLICY_INFO,
};

pub const CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = extern struct {
    pszOrganization: ?PSTR,
    cNoticeNumbers: u32,
    rgNoticeNumbers: ?*i32,
};

pub const CERT_POLICY_QUALIFIER_USER_NOTICE = extern struct {
    pNoticeReference: ?*CERT_POLICY_QUALIFIER_NOTICE_REFERENCE,
    pszDisplayText: ?PWSTR,
};

pub const CPS_URLS = extern struct {
    pszURL: ?PWSTR,
    pAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pDigest: ?*CRYPTOAPI_BLOB,
};

pub const CERT_POLICY95_QUALIFIER1 = extern struct {
    pszPracticesReference: ?PWSTR,
    pszNoticeIdentifier: ?PSTR,
    pszNSINoticeIdentifier: ?PSTR,
    cCPSURLs: u32,
    rgCPSURLs: ?*CPS_URLS,
};

pub const CERT_POLICY_MAPPING = extern struct {
    pszIssuerDomainPolicy: ?PSTR,
    pszSubjectDomainPolicy: ?PSTR,
};

pub const CERT_POLICY_MAPPINGS_INFO = extern struct {
    cPolicyMapping: u32,
    rgPolicyMapping: ?*CERT_POLICY_MAPPING,
};

pub const CERT_POLICY_CONSTRAINTS_INFO = extern struct {
    fRequireExplicitPolicy: BOOL,
    dwRequireExplicitPolicySkipCerts: u32,
    fInhibitPolicyMapping: BOOL,
    dwInhibitPolicyMappingSkipCerts: u32,
};

pub const CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = extern struct {
    pszObjId: ?PSTR,
    cValue: u32,
    rgValue: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_CONTENT_INFO = extern struct {
    pszObjId: ?PSTR,
    Content: CRYPTOAPI_BLOB,
};

pub const CRYPT_SEQUENCE_OF_ANY = extern struct {
    cValue: u32,
    rgValue: ?*CRYPTOAPI_BLOB,
};

pub const CERT_AUTHORITY_KEY_ID2_INFO = extern struct {
    KeyId: CRYPTOAPI_BLOB,
    AuthorityCertIssuer: CERT_ALT_NAME_INFO,
    AuthorityCertSerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_ACCESS_DESCRIPTION = extern struct {
    pszAccessMethod: ?PSTR,
    AccessLocation: CERT_ALT_NAME_ENTRY,
};

pub const CERT_AUTHORITY_INFO_ACCESS = extern struct {
    cAccDescr: u32,
    rgAccDescr: ?*CERT_ACCESS_DESCRIPTION,
};

pub const CRL_DIST_POINT_NAME = extern struct {
    dwDistPointNameChoice: u32,
    Anonymous: extern union {
        FullName: CERT_ALT_NAME_INFO,
    },
};

pub const CRL_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    ReasonFlags: CRYPT_BIT_BLOB,
    CRLIssuer: CERT_ALT_NAME_INFO,
};

pub const CRL_DIST_POINTS_INFO = extern struct {
    cDistPoint: u32,
    rgDistPoint: ?*CRL_DIST_POINT,
};

pub const CROSS_CERT_DIST_POINTS_INFO = extern struct {
    dwSyncDeltaTime: u32,
    cDistPoint: u32,
    rgDistPoint: ?*CERT_ALT_NAME_INFO,
};

pub const CERT_PAIR = extern struct {
    Forward: CRYPTOAPI_BLOB,
    Reverse: CRYPTOAPI_BLOB,
};

pub const CRL_ISSUING_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    fOnlyContainsUserCerts: BOOL,
    fOnlyContainsCACerts: BOOL,
    OnlySomeReasonFlags: CRYPT_BIT_BLOB,
    fIndirectCRL: BOOL,
};

pub const CERT_GENERAL_SUBTREE = extern struct {
    Base: CERT_ALT_NAME_ENTRY,
    dwMinimum: u32,
    fMaximum: BOOL,
    dwMaximum: u32,
};

pub const CERT_NAME_CONSTRAINTS_INFO = extern struct {
    cPermittedSubtree: u32,
    rgPermittedSubtree: ?*CERT_GENERAL_SUBTREE,
    cExcludedSubtree: u32,
    rgExcludedSubtree: ?*CERT_GENERAL_SUBTREE,
};

pub const CERT_DSS_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    q: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
};

pub const CERT_DH_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
};

pub const CERT_ECC_SIGNATURE = extern struct {
    r: CRYPTOAPI_BLOB,
    s: CRYPTOAPI_BLOB,
};

pub const CERT_X942_DH_VALIDATION_PARAMS = extern struct {
    seed: CRYPT_BIT_BLOB,
    pgenCounter: u32,
};

pub const CERT_X942_DH_PARAMETERS = extern struct {
    p: CRYPTOAPI_BLOB,
    g: CRYPTOAPI_BLOB,
    q: CRYPTOAPI_BLOB,
    j: CRYPTOAPI_BLOB,
    pValidationParams: ?*CERT_X942_DH_VALIDATION_PARAMS,
};

pub const CRYPT_X942_OTHER_INFO = extern struct {
    pszContentEncryptionObjId: ?PSTR,
    rgbCounter: [4]u8,
    rgbKeyLength: [4]u8,
    PubInfo: CRYPTOAPI_BLOB,
};

pub const CRYPT_ECC_CMS_SHARED_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EntityUInfo: CRYPTOAPI_BLOB,
    rgbSuppPubInfo: [4]u8,
};

pub const CRYPT_RC2_CBC_PARAMETERS = extern struct {
    dwVersion: u32,
    fIV: BOOL,
    rgbIV: [8]u8,
};

pub const CRYPT_SMIME_CAPABILITY = extern struct {
    pszObjId: ?PSTR,
    Parameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_SMIME_CAPABILITIES = extern struct {
    cCapability: u32,
    rgCapability: ?*CRYPT_SMIME_CAPABILITY,
};

pub const CERT_QC_STATEMENT = extern struct {
    pszStatementId: ?PSTR,
    StatementInfo: CRYPTOAPI_BLOB,
};

pub const CERT_QC_STATEMENTS_EXT_INFO = extern struct {
    cStatement: u32,
    rgStatement: ?*CERT_QC_STATEMENT,
};

pub const CRYPT_MASK_GEN_ALGORITHM = extern struct {
    pszObjId: ?PSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
};

pub const CRYPT_RSA_SSA_PSS_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    dwSaltLength: u32,
    dwTrailerField: u32,
};

pub const CRYPT_PSOURCE_ALGORITHM = extern struct {
    pszObjId: ?PSTR,
    EncodingParameters: CRYPTOAPI_BLOB,
};

pub const CRYPT_RSAES_OAEP_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    PSourceAlgorithm: CRYPT_PSOURCE_ALGORITHM,
};

pub const CMC_TAGGED_ATTRIBUTE = extern struct {
    dwBodyPartID: u32,
    Attribute: CRYPT_ATTRIBUTE,
};

pub const CMC_TAGGED_CERT_REQUEST = extern struct {
    dwBodyPartID: u32,
    SignedCertRequest: CRYPTOAPI_BLOB,
};

pub const CMC_TAGGED_REQUEST = extern struct {
    dwTaggedRequestChoice: u32,
    Anonymous: extern union {
        pTaggedCertRequest: ?*CMC_TAGGED_CERT_REQUEST,
    },
};

pub const CMC_TAGGED_CONTENT_INFO = extern struct {
    dwBodyPartID: u32,
    EncodedContentInfo: CRYPTOAPI_BLOB,
};

pub const CMC_TAGGED_OTHER_MSG = extern struct {
    dwBodyPartID: u32,
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const CMC_DATA_INFO = extern struct {
    cTaggedAttribute: u32,
    rgTaggedAttribute: ?*CMC_TAGGED_ATTRIBUTE,
    cTaggedRequest: u32,
    rgTaggedRequest: ?*CMC_TAGGED_REQUEST,
    cTaggedContentInfo: u32,
    rgTaggedContentInfo: ?*CMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: u32,
    rgTaggedOtherMsg: ?*CMC_TAGGED_OTHER_MSG,
};

pub const CMC_RESPONSE_INFO = extern struct {
    cTaggedAttribute: u32,
    rgTaggedAttribute: ?*CMC_TAGGED_ATTRIBUTE,
    cTaggedContentInfo: u32,
    rgTaggedContentInfo: ?*CMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: u32,
    rgTaggedOtherMsg: ?*CMC_TAGGED_OTHER_MSG,
};

pub const CMC_PEND_INFO = extern struct {
    PendToken: CRYPTOAPI_BLOB,
    PendTime: FILETIME,
};

pub const CMC_STATUS_INFO = extern struct {
    dwStatus: u32,
    cBodyList: u32,
    rgdwBodyList: ?*u32,
    pwszStatusString: ?PWSTR,
    dwOtherInfoChoice: u32,
    Anonymous: extern union {
        dwFailInfo: u32,
        pPendInfo: ?*CMC_PEND_INFO,
    },
};

pub const CMC_ADD_EXTENSIONS_INFO = extern struct {
    dwCmcDataReference: u32,
    cCertReference: u32,
    rgdwCertReference: ?*u32,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CMC_ADD_ATTRIBUTES_INFO = extern struct {
    dwCmcDataReference: u32,
    cCertReference: u32,
    rgdwCertReference: ?*u32,
    cAttribute: u32,
    rgAttribute: ?*CRYPT_ATTRIBUTE,
};

pub const CERT_TEMPLATE_EXT = extern struct {
    pszObjId: ?PSTR,
    dwMajorVersion: u32,
    fMinorVersion: BOOL,
    dwMinorVersion: u32,
};

pub const CERT_HASHED_URL = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPTOAPI_BLOB,
    pwszUrl: ?PWSTR,
};

pub const CERT_LOGOTYPE_DETAILS = extern struct {
    pwszMimeType: ?PWSTR,
    cHashedUrl: u32,
    rgHashedUrl: ?*CERT_HASHED_URL,
};

pub const CERT_LOGOTYPE_REFERENCE = extern struct {
    cHashedUrl: u32,
    rgHashedUrl: ?*CERT_HASHED_URL,
};

pub const CERT_LOGOTYPE_IMAGE_INFO = extern struct {
    dwLogotypeImageInfoChoice: CERT_LOGOTYPE_IMAGE_INFO_TYPE,
    dwFileSize: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwLogotypeImageResolutionChoice: CERT_LOGOTYPE_CHOICE,
    Anonymous: extern union {
        dwNumBits: u32,
        dwTableSize: u32,
    },
    pwszLanguage: ?PWSTR,
};

pub const CERT_LOGOTYPE_IMAGE = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeImageInfo: ?*CERT_LOGOTYPE_IMAGE_INFO,
};

pub const CERT_LOGOTYPE_AUDIO_INFO = extern struct {
    dwFileSize: u32,
    dwPlayTime: u32,
    dwChannels: u32,
    dwSampleRate: u32,
    pwszLanguage: ?PWSTR,
};

pub const CERT_LOGOTYPE_AUDIO = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeAudioInfo: ?*CERT_LOGOTYPE_AUDIO_INFO,
};

pub const CERT_LOGOTYPE_DATA = extern struct {
    cLogotypeImage: u32,
    rgLogotypeImage: ?*CERT_LOGOTYPE_IMAGE,
    cLogotypeAudio: u32,
    rgLogotypeAudio: ?*CERT_LOGOTYPE_AUDIO,
};

pub const CERT_LOGOTYPE_INFO = extern struct {
    dwLogotypeInfoChoice: CERT_LOGOTYPE_OPTION,
    Anonymous: extern union {
        pLogotypeDirectInfo: ?*CERT_LOGOTYPE_DATA,
        pLogotypeIndirectInfo: ?*CERT_LOGOTYPE_REFERENCE,
    },
};

pub const CERT_OTHER_LOGOTYPE_INFO = extern struct {
    pszObjId: ?PSTR,
    LogotypeInfo: CERT_LOGOTYPE_INFO,
};

pub const CERT_LOGOTYPE_EXT_INFO = extern struct {
    cCommunityLogo: u32,
    rgCommunityLogo: ?*CERT_LOGOTYPE_INFO,
    pIssuerLogo: ?*CERT_LOGOTYPE_INFO,
    pSubjectLogo: ?*CERT_LOGOTYPE_INFO,
    cOtherLogo: u32,
    rgOtherLogo: ?*CERT_OTHER_LOGOTYPE_INFO,
};

pub const CERT_BIOMETRIC_DATA = extern struct {
    dwTypeOfBiometricDataChoice: CERT_BIOMETRIC_DATA_TYPE,
    Anonymous: extern union {
        dwPredefined: u32,
        pszObjId: ?PSTR,
    },
    HashedUrl: CERT_HASHED_URL,
};

pub const CERT_BIOMETRIC_EXT_INFO = extern struct {
    cBiometricData: u32,
    rgBiometricData: ?*CERT_BIOMETRIC_DATA,
};

pub const OCSP_SIGNATURE_INFO = extern struct {
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
    cCertEncoded: u32,
    rgCertEncoded: ?*CRYPTOAPI_BLOB,
};

pub const OCSP_SIGNED_REQUEST_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    pOptionalSignatureInfo: ?*OCSP_SIGNATURE_INFO,
};

pub const OCSP_CERT_ID = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IssuerNameHash: CRYPTOAPI_BLOB,
    IssuerKeyHash: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
};

pub const OCSP_REQUEST_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const OCSP_REQUEST_INFO = extern struct {
    dwVersion: u32,
    pRequestorName: ?*CERT_ALT_NAME_ENTRY,
    cRequestEntry: u32,
    rgRequestEntry: ?*OCSP_REQUEST_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const OCSP_RESPONSE_INFO = extern struct {
    dwStatus: u32,
    pszObjId: ?PSTR,
    Value: CRYPTOAPI_BLOB,
};

pub const OCSP_BASIC_SIGNED_RESPONSE_INFO = extern struct {
    ToBeSigned: CRYPTOAPI_BLOB,
    SignatureInfo: OCSP_SIGNATURE_INFO,
};

pub const OCSP_BASIC_REVOKED_INFO = extern struct {
    RevocationDate: FILETIME,
    dwCrlReasonCode: CERT_REVOCATION_STATUS_REASON,
};

pub const OCSP_BASIC_RESPONSE_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    dwCertStatus: u32,
    Anonymous: extern union {
        pRevokedInfo: ?*OCSP_BASIC_REVOKED_INFO,
    },
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const OCSP_BASIC_RESPONSE_INFO = extern struct {
    dwVersion: u32,
    dwResponderIdChoice: u32,
    Anonymous: extern union {
        ByNameResponderId: CRYPTOAPI_BLOB,
        ByKeyResponderId: CRYPTOAPI_BLOB,
    },
    ProducedAt: FILETIME,
    cResponseEntry: u32,
    rgResponseEntry: ?*OCSP_BASIC_RESPONSE_ENTRY,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CERT_SUPPORTED_ALGORITHM_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    IntendedCertPolicies: CERT_POLICIES_INFO,
};

pub const CERT_TPM_SPECIFICATION_INFO = extern struct {
    pwszFamily: ?PWSTR,
    dwLevel: u32,
    dwRevision: u32,
};

pub const CRYPT_OID_FUNC_ENTRY = extern struct {
    pszOID: ?[*:0]const u8,
    pvFuncAddr: ?*anyopaque,
};

pub const PFN_CRYPT_ENUM_OID_FUNC = fn(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    cValue: u32,
    rgdwValueType: [*]const u32,
    rgpwszValueName: [*]const ?[*:0]const u16,
    rgpbValueData: [*]const ?*const u8,
    rgcbValueData: [*]const u32,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_OID_INFO = extern struct {
    cbSize: u32,
    pszOID: ?[*:0]const u8,
    pwszName: ?[*:0]const u16,
    dwGroupId: u32,
    Anonymous: extern union {
        dwValue: u32,
        Algid: u32,
        dwLength: u32,
    },
    ExtraInfo: CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_ENUM_OID_INFO = fn(
    pInfo: ?*CRYPT_OID_INFO,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_STRONG_SIGN_SERIALIZED_INFO = extern struct {
    dwFlags: CERT_STRONG_SIGN_FLAGS,
    pwszCNGSignHashAlgids: ?PWSTR,
    pwszCNGPubKeyMinBitLengths: ?PWSTR,
};

pub const CERT_STRONG_SIGN_PARA = extern struct {
    cbSize: u32,
    dwInfoChoice: u32,
    Anonymous: extern union {
        pvInfo: ?*anyopaque,
        pSerializedInfo: ?*CERT_STRONG_SIGN_SERIALIZED_INFO,
        pszOID: ?PSTR,
    },
};

pub const CERT_ISSUER_SERIAL_NUMBER = extern struct {
    Issuer: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
};

pub const CERT_ID = extern struct {
    dwIdChoice: CERT_ID_OPTION,
    Anonymous: extern union {
        IssuerSerialNumber: CERT_ISSUER_SERIAL_NUMBER,
        KeyId: CRYPTOAPI_BLOB,
        HashId: CRYPTOAPI_BLOB,
    },
};

pub const CMSG_SIGNER_ENCODE_INFO = extern struct {
    cbSize: u32,
    pCertInfo: ?*CERT_INFO,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: usize,
    },
    dwKeySpec: u32,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
    cAuthAttr: u32,
    rgAuthAttr: ?*CRYPT_ATTRIBUTE,
    cUnauthAttr: u32,
    rgUnauthAttr: ?*CRYPT_ATTRIBUTE,
};

pub const CMSG_SIGNED_ENCODE_INFO = extern struct {
    cbSize: u32,
    cSigners: u32,
    rgSigners: ?*CMSG_SIGNER_ENCODE_INFO,
    cCertEncoded: u32,
    rgCertEncoded: ?*CRYPTOAPI_BLOB,
    cCrlEncoded: u32,
    rgCrlEncoded: ?*CRYPTOAPI_BLOB,
};

pub const CMSG_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
    cRecipients: u32,
    rgpRecipients: ?*?*CERT_INFO,
};

pub const CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*anyopaque,
    hCryptProv: usize,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
};

pub const CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = extern struct {
    cbSize: u32,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*anyopaque,
    KeyWrapAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyWrapAuxInfo: ?*anyopaque,
    hCryptProv: usize,
    dwKeySpec: u32,
    dwKeyChoice: CMSG_KEY_AGREE_OPTION,
    Anonymous: extern union {
        pEphemeralAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
        pSenderId: ?*CERT_ID,
    },
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    cRecipientEncryptedKeys: u32,
    rgpRecipientEncryptedKeys: ?*?*CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO,
};

pub const CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*anyopaque,
    hCryptProv: usize,
    dwKeyChoice: u32,
    Anonymous: extern union {
        hKeyEncryptionKey: usize,
        pvKeyEncryptionKey: ?*anyopaque,
    },
    KeyId: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_RECIPIENT_ENCODE_INFO = extern struct {
    dwRecipientChoice: u32,
    Anonymous: extern union {
        pKeyTrans: ?*CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
        pKeyAgree: ?*CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
        pMailList: ?*CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
    },
};

pub const CMSG_RC2_AUX_INFO = extern struct {
    cbSize: u32,
    dwBitLen: u32,
};

pub const CMSG_SP3_COMPATIBLE_AUX_INFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const CMSG_RC4_AUX_INFO = extern struct {
    cbSize: u32,
    dwBitLen: u32,
};

pub const CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: u32,
    SignedInfo: CMSG_SIGNED_ENCODE_INFO,
    EnvelopedInfo: CMSG_ENVELOPED_ENCODE_INFO,
};

pub const CMSG_HASHED_ENCODE_INFO = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
};

pub const CMSG_ENCRYPTED_ENCODE_INFO = extern struct {
    cbSize: u32,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
};

pub const PFN_CMSG_STREAM_OUTPUT = fn(
    pvArg: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*u8,
    cbData: u32,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_STREAM_INFO = extern struct {
    cbContent: u32,
    pfnStreamOutput: ?PFN_CMSG_STREAM_OUTPUT,
    pvArg: ?*anyopaque,
};

pub const CMSG_SIGNER_INFO = extern struct {
    dwVersion: u32,
    Issuer: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPTOAPI_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};

pub const CMSG_CMS_SIGNER_INFO = extern struct {
    dwVersion: u32,
    SignerId: CERT_ID,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPTOAPI_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};

pub const CMSG_KEY_TRANS_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    RecipientId: CERT_ID,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
};

pub const CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = extern struct {
    RecipientId: CERT_ID,
    EncryptedKey: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_KEY_AGREE_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR,
    Anonymous: extern union {
        OriginatorCertId: CERT_ID,
        OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    },
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cRecipientEncryptedKeys: u32,
    rgpRecipientEncryptedKeys: ?*?*CMSG_RECIPIENT_ENCRYPTED_KEY_INFO,
};

pub const CMSG_MAIL_LIST_RECIPIENT_INFO = extern struct {
    dwVersion: u32,
    KeyId: CRYPTOAPI_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    Date: FILETIME,
    pOtherAttr: ?*CRYPT_ATTRIBUTE_TYPE_VALUE,
};

pub const CMSG_CMS_RECIPIENT_INFO = extern struct {
    dwRecipientChoice: u32,
    Anonymous: extern union {
        pKeyTrans: ?*CMSG_KEY_TRANS_RECIPIENT_INFO,
        pKeyAgree: ?*CMSG_KEY_AGREE_RECIPIENT_INFO,
        pMailList: ?*CMSG_MAIL_LIST_RECIPIENT_INFO,
    },
};

pub const CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    dwSignerIndex: u32,
    dwSignerType: u32,
    pvSigner: ?*anyopaque,
};

pub const CMSG_CTRL_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: usize,
    },
    dwKeySpec: u32,
    dwRecipientIndex: u32,
};

pub const CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: usize,
    },
    dwKeySpec: u32,
    pKeyTrans: ?*CMSG_KEY_TRANS_RECIPIENT_INFO,
    dwRecipientIndex: u32,
};

pub const CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: usize,
    },
    dwKeySpec: u32,
    pKeyAgree: ?*CMSG_KEY_AGREE_RECIPIENT_INFO,
    dwRecipientIndex: u32,
    dwRecipientEncryptedKeyIndex: u32,
    OriginatorPublicKey: CRYPT_BIT_BLOB,
};

pub const CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    pMailList: ?*CMSG_MAIL_LIST_RECIPIENT_INFO,
    dwRecipientIndex: u32,
    dwKeyChoice: u32,
    Anonymous: extern union {
        hKeyEncryptionKey: usize,
        pvKeyEncryptionKey: ?*anyopaque,
    },
};

pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: u32,
    dwSignerIndex: u32,
    blob: CRYPTOAPI_BLOB,
};

pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: u32,
    dwSignerIndex: u32,
    dwUnauthAttrIndex: u32,
};

pub const PFN_CMSG_ALLOC = fn(
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub const PFN_CMSG_FREE = fn(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CMSG_GEN_ENCRYPT_KEY = fn(
    phCryptProv: ?*usize,
    paiEncrypt: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptAuxInfo: ?*anyopaque,
    pPublicKeyInfo: ?*CERT_PUBLIC_KEY_INFO,
    pfnAlloc: ?PFN_CMSG_ALLOC,
    phEncryptKey: ?*usize,
    ppbEncryptParameters: ?*?*u8,
    pcbEncryptParameters: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_EXPORT_ENCRYPT_KEY = fn(
    hCryptProv: usize,
    hEncryptKey: usize,
    pPublicKeyInfo: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 4?
    pbData: ?*u8,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_ENCRYPT_KEY = fn(
    hCryptProv: usize,
    dwKeySpec: u32,
    paiEncrypt: ?*CRYPT_ALGORITHM_IDENTIFIER,
    paiPubKey: ?*CRYPT_ALGORITHM_IDENTIFIER,
    // TODO: what to do with BytesParamIndex 5?
    pbEncodedKey: ?*u8,
    cbEncodedKey: u32,
    phEncryptKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_CONTENT_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    hCryptProv: usize,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
    cRecipients: u32,
    rgCmsRecipients: ?*CMSG_RECIPIENT_ENCODE_INFO,
    pfnAlloc: ?PFN_CMSG_ALLOC,
    pfnFree: ?PFN_CMSG_FREE,
    dwEncryptFlags: u32,
    Anonymous: extern union {
        hContentEncryptKey: usize,
        hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    },
    dwFlags: u32,
    fCNG: BOOL,
    pbCNGContentEncryptKeyObject: ?*u8,
    pbContentEncryptKey: ?*u8,
    cbContentEncryptKey: u32,
};

pub const PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY = fn(
    pContentEncryptInfo: ?*CMSG_CONTENT_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_KEY_TRANS_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_KEY_TRANS = fn(
    pContentEncryptInfo: ?*CMSG_CONTENT_ENCRYPT_INFO,
    pKeyTransEncodeInfo: ?*CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
    pKeyTransEncryptInfo: ?*CMSG_KEY_TRANS_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    EncryptedKey: CRYPTOAPI_BLOB,
};

pub const CMSG_KEY_AGREE_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    UserKeyingMaterial: CRYPTOAPI_BLOB,
    dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR,
    Anonymous: extern union {
        OriginatorCertId: CERT_ID,
        OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    },
    cKeyAgreeKeyEncryptInfo: u32,
    rgpKeyAgreeKeyEncryptInfo: ?*?*CMSG_KEY_AGREE_KEY_ENCRYPT_INFO,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_KEY_AGREE = fn(
    pContentEncryptInfo: ?*CMSG_CONTENT_ENCRYPT_INFO,
    pKeyAgreeEncodeInfo: ?*CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
    pKeyAgreeEncryptInfo: ?*CMSG_KEY_AGREE_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_MAIL_LIST_ENCRYPT_INFO = extern struct {
    cbSize: u32,
    dwRecipientIndex: u32,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPTOAPI_BLOB,
    dwFlags: u32,
};

pub const PFN_CMSG_EXPORT_MAIL_LIST = fn(
    pContentEncryptInfo: ?*CMSG_CONTENT_ENCRYPT_INFO,
    pMailListEncodeInfo: ?*CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
    pMailListEncryptInfo: ?*CMSG_MAIL_LIST_ENCRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_KEY_TRANS = fn(
    pContentEncryptionAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pKeyTransDecryptPara: ?*CMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    phContentEncryptKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_KEY_AGREE = fn(
    pContentEncryptionAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pKeyAgreeDecryptPara: ?*CMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    phContentEncryptKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_IMPORT_MAIL_LIST = fn(
    pContentEncryptionAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pMailListDecryptPara: ?*CMSG_CTRL_MAIL_LIST_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    phContentEncryptKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CMSG_CNG_CONTENT_DECRYPT_INFO = extern struct {
    cbSize: u32,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pfnAlloc: ?PFN_CMSG_ALLOC,
    pfnFree: ?PFN_CMSG_FREE,
    hNCryptKey: usize,
    pbContentEncryptKey: ?*u8,
    cbContentEncryptKey: u32,
    hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    pbCNGContentEncryptKeyObject: ?*u8,
};

pub const PFN_CMSG_CNG_IMPORT_KEY_TRANS = fn(
    pCNGContentDecryptInfo: ?*CMSG_CNG_CONTENT_DECRYPT_INFO,
    pKeyTransDecryptPara: ?*CMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_CNG_IMPORT_KEY_AGREE = fn(
    pCNGContentDecryptInfo: ?*CMSG_CNG_CONTENT_DECRYPT_INFO,
    pKeyAgreeDecryptPara: ?*CMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY = fn(
    pCNGContentDecryptInfo: ?*CMSG_CNG_CONTENT_DECRYPT_INFO,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CONTEXT = extern struct {
    dwCertEncodingType: u32,
    pbCertEncoded: ?*u8,
    cbCertEncoded: u32,
    pCertInfo: ?*CERT_INFO,
    hCertStore: ?*anyopaque,
};

pub const CRL_CONTEXT = extern struct {
    dwCertEncodingType: u32,
    pbCrlEncoded: ?*u8,
    cbCrlEncoded: u32,
    pCrlInfo: ?*CRL_INFO,
    hCertStore: ?*anyopaque,
};

pub const CTL_CONTEXT = extern struct {
    dwMsgAndCertEncodingType: u32,
    pbCtlEncoded: ?*u8,
    cbCtlEncoded: u32,
    pCtlInfo: ?*CTL_INFO,
    hCertStore: ?*anyopaque,
    hCryptMsg: ?*anyopaque,
    pbCtlContent: ?*u8,
    cbCtlContent: u32,
};

pub const CertKeyType = enum(u32) {
    Other = 0,
    VirtualSmartCard = 1,
    PhysicalSmartCard = 2,
    Passport = 3,
    PassportRemote = 4,
    PassportSmartCard = 5,
    Hardware = 6,
    Software = 7,
    SelfSigned = 8,
};
pub const KeyTypeOther = CertKeyType.Other;
pub const KeyTypeVirtualSmartCard = CertKeyType.VirtualSmartCard;
pub const KeyTypePhysicalSmartCard = CertKeyType.PhysicalSmartCard;
pub const KeyTypePassport = CertKeyType.Passport;
pub const KeyTypePassportRemote = CertKeyType.PassportRemote;
pub const KeyTypePassportSmartCard = CertKeyType.PassportSmartCard;
pub const KeyTypeHardware = CertKeyType.Hardware;
pub const KeyTypeSoftware = CertKeyType.Software;
pub const KeyTypeSelfSigned = CertKeyType.SelfSigned;

pub const CRYPT_KEY_PROV_PARAM = extern struct {
    dwParam: u32,
    pbData: ?*u8,
    cbData: u32,
    dwFlags: u32,
};

pub const CRYPT_KEY_PROV_INFO = extern struct {
    pwszContainerName: ?PWSTR,
    pwszProvName: ?PWSTR,
    dwProvType: u32,
    dwFlags: CRYPT_KEY_FLAGS,
    cProvParam: u32,
    rgProvParam: ?*CRYPT_KEY_PROV_PARAM,
    dwKeySpec: u32,
};

pub const CERT_KEY_CONTEXT = extern struct {
    cbSize: u32,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: usize,
    },
    dwKeySpec: u32,
};

pub const ROOT_INFO_LUID = extern struct {
    LowPart: u32,
    HighPart: i32,
};

pub const CRYPT_SMART_CARD_ROOT_INFO = extern struct {
    rgbCardID: [16]u8,
    luid: ROOT_INFO_LUID,
};

pub const CERT_SYSTEM_STORE_RELOCATE_PARA = extern struct {
    Anonymous1: extern union {
        hKeyBase: ?HKEY,
        pvBase: ?*anyopaque,
    },
    Anonymous2: extern union {
        pvSystemStore: ?*anyopaque,
        pszSystemStore: ?[*:0]const u8,
        pwszSystemStore: ?[*:0]const u16,
    },
};

pub const CERT_REGISTRY_STORE_CLIENT_GPT_PARA = extern struct {
    hKeyBase: ?HKEY,
    pwszRegPath: ?PWSTR,
};

pub const CERT_REGISTRY_STORE_ROAMING_PARA = extern struct {
    hKey: ?HKEY,
    pwszStoreDirectory: ?PWSTR,
};

pub const CERT_LDAP_STORE_OPENED_PARA = extern struct {
    pvLdapSessionHandle: ?*anyopaque,
    pwszLdapUrl: ?[*:0]const u16,
};

pub const CERT_STORE_PROV_INFO = extern struct {
    cbSize: u32,
    cStoreProvFunc: u32,
    rgpvStoreProvFunc: ?*?*anyopaque,
    hStoreProv: ?*anyopaque,
    dwStoreProvFlags: CERT_STORE_PROV_FLAGS,
    hStoreProvFuncAddr2: ?*anyopaque,
};

pub const PFN_CERT_DLL_OPEN_STORE_PROV_FUNC = fn(
    lpszStoreProvider: ?[*:0]const u8,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    hCryptProv: usize,
    dwFlags: CERT_OPEN_STORE_FLAGS,
    pvPara: ?*const anyopaque,
    hCertStore: ?*anyopaque,
    pStoreProvInfo: ?*CERT_STORE_PROV_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_CLOSE = fn(
    hStoreProv: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CERT_STORE_PROV_READ_CERT = fn(
    hStoreProv: ?*anyopaque,
    pStoreCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
    ppProvCertContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CERT = fn(
    hStoreProv: ?*anyopaque,
    pCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CERT = fn(
    hStoreProv: ?*anyopaque,
    pCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CERT_PROPERTY = fn(
    hStoreProv: ?*anyopaque,
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_READ_CRL = fn(
    hStoreProv: ?*anyopaque,
    pStoreCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
    ppProvCrlContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CRL = fn(
    hStoreProv: ?*anyopaque,
    pCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CRL = fn(
    hStoreProv: ?*anyopaque,
    pCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CRL_PROPERTY = fn(
    hStoreProv: ?*anyopaque,
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_READ_CTL = fn(
    hStoreProv: ?*anyopaque,
    pStoreCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
    ppProvCtlContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_WRITE_CTL = fn(
    hStoreProv: ?*anyopaque,
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_DELETE_CTL = fn(
    hStoreProv: ?*anyopaque,
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_SET_CTL_PROPERTY = fn(
    hStoreProv: ?*anyopaque,
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_CONTROL = fn(
    hStoreProv: ?*anyopaque,
    dwFlags: u32,
    dwCtrlType: u32,
    pvCtrlPara: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_STORE_PROV_FIND_INFO = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: u32,
    pvFindPara: ?*const anyopaque,
};

pub const PFN_CERT_STORE_PROV_FIND_CERT = fn(
    hStoreProv: ?*anyopaque,
    pFindInfo: ?*CERT_STORE_PROV_FIND_INFO,
    pPrevCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
    ppvStoreProvFindInfo: ?*?*anyopaque,
    ppProvCertContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CERT = fn(
    hStoreProv: ?*anyopaque,
    pCertContext: ?*const CERT_CONTEXT,
    pvStoreProvFindInfo: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CERT_PROPERTY = fn(
    hStoreProv: ?*anyopaque,
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FIND_CRL = fn(
    hStoreProv: ?*anyopaque,
    pFindInfo: ?*CERT_STORE_PROV_FIND_INFO,
    pPrevCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
    ppvStoreProvFindInfo: ?*?*anyopaque,
    ppProvCrlContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CRL = fn(
    hStoreProv: ?*anyopaque,
    pCrlContext: ?*CRL_CONTEXT,
    pvStoreProvFindInfo: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CRL_PROPERTY = fn(
    hStoreProv: ?*anyopaque,
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FIND_CTL = fn(
    hStoreProv: ?*anyopaque,
    pFindInfo: ?*CERT_STORE_PROV_FIND_INFO,
    pPrevCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
    ppvStoreProvFindInfo: ?*?*anyopaque,
    ppProvCtlContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_FREE_FIND_CTL = fn(
    hStoreProv: ?*anyopaque,
    pCtlContext: ?*CTL_CONTEXT,
    pvStoreProvFindInfo: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_STORE_PROV_GET_CTL_PROPERTY = fn(
    hStoreProv: ?*anyopaque,
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRL_FIND_ISSUED_FOR_PARA = extern struct {
    pSubjectCert: ?*const CERT_CONTEXT,
    pIssuerCert: ?*const CERT_CONTEXT,
};

pub const CTL_ANY_SUBJECT_INFO = extern struct {
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    SubjectIdentifier: CRYPTOAPI_BLOB,
};

pub const CTL_FIND_USAGE_PARA = extern struct {
    cbSize: u32,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPTOAPI_BLOB,
    pSigner: ?*CERT_INFO,
};

pub const CTL_FIND_SUBJECT_PARA = extern struct {
    cbSize: u32,
    pUsagePara: ?*CTL_FIND_USAGE_PARA,
    dwSubjectType: u32,
    pvSubject: ?*anyopaque,
};

pub const PFN_CERT_CREATE_CONTEXT_SORT_FUNC = fn(
    cbTotalEncoded: u32,
    cbRemainEncoded: u32,
    cEntry: u32,
    pvSort: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CREATE_CONTEXT_PARA = extern struct {
    cbSize: u32,
    pfnFree: ?PFN_CRYPT_FREE,
    pvFree: ?*anyopaque,
    pfnSort: ?PFN_CERT_CREATE_CONTEXT_SORT_FUNC,
    pvSort: ?*anyopaque,
};

pub const CERT_SYSTEM_STORE_INFO = extern struct {
    cbSize: u32,
};

pub const CERT_PHYSICAL_STORE_INFO = extern struct {
    cbSize: u32,
    pszOpenStoreProvider: ?PSTR,
    dwOpenEncodingType: u32,
    dwOpenFlags: u32,
    OpenParameters: CRYPTOAPI_BLOB,
    dwFlags: u32,
    dwPriority: u32,
};

pub const PFN_CERT_ENUM_SYSTEM_STORE_LOCATION = fn(
    pwszStoreLocation: ?[*:0]const u16,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_ENUM_SYSTEM_STORE = fn(
    pvSystemStore: ?*const anyopaque,
    dwFlags: CERT_SYSTEM_STORE_FLAGS,
    pStoreInfo: ?*CERT_SYSTEM_STORE_INFO,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_ENUM_PHYSICAL_STORE = fn(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pwszStoreName: ?[*:0]const u16,
    pStoreInfo: ?*CERT_PHYSICAL_STORE_INFO,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CTL_VERIFY_USAGE_PARA = extern struct {
    cbSize: u32,
    ListIdentifier: CRYPTOAPI_BLOB,
    cCtlStore: u32,
    rghCtlStore: ?*?*anyopaque,
    cSignerStore: u32,
    rghSignerStore: ?*?*anyopaque,
};

pub const CTL_VERIFY_USAGE_STATUS = extern struct {
    cbSize: u32,
    dwError: u32,
    dwFlags: u32,
    ppCtl: ?*?*CTL_CONTEXT,
    dwCtlEntryIndex: u32,
    ppSigner: ?*?*CERT_CONTEXT,
    dwSignerIndex: u32,
};

pub const CERT_REVOCATION_CRL_INFO = extern struct {
    cbSize: u32,
    pBaseCrlContext: ?*CRL_CONTEXT,
    pDeltaCrlContext: ?*CRL_CONTEXT,
    pCrlEntry: ?*CRL_ENTRY,
    fDeltaCrlEntry: BOOL,
};

pub const CERT_REVOCATION_PARA = extern struct {
    cbSize: u32,
    pIssuerCert: ?*const CERT_CONTEXT,
    cCertStore: u32,
    rgCertStore: ?*?*anyopaque,
    hCrlStore: ?*anyopaque,
    pftTimeToUse: ?*FILETIME,
};

pub const CERT_REVOCATION_STATUS = extern struct {
    cbSize: u32,
    dwIndex: u32,
    dwError: u32,
    dwReason: CERT_REVOCATION_STATUS_REASON,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: u32,
};

pub const CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = extern struct {
    CertSignHashCNGAlgPropData: CRYPTOAPI_BLOB,
    CertIssuerPubKeyBitLengthPropData: CRYPTOAPI_BLOB,
};

pub const CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = extern struct {
    cCNGHashAlgid: u32,
    rgpwszCNGHashAlgid: ?*?PWSTR,
    dwWeakIndex: u32,
};

pub const PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = fn(
    dwCertEncodingType: u32,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    ppvDecodedSignPara: ?*?*anyopaque,
    ppwszCNGHashAlgid: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC = fn(
    hKey: usize,
    dwCertEncodingType: u32,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pvDecodedSignPara: ?*anyopaque,
    pwszCNGPubKeyAlgid: ?[*:0]const u16,
    pwszCNGHashAlgid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 7?
    pbComputedHash: ?*u8,
    cbComputedHash: u32,
    // TODO: what to do with BytesParamIndex 9?
    pbSignature: ?*u8,
    pcbSignature: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC = fn(
    dwCertEncodingType: u32,
    pPubKeyInfo: ?*CERT_PUBLIC_KEY_INFO,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pvDecodedSignPara: ?*anyopaque,
    pwszCNGPubKeyAlgid: ?[*:0]const u16,
    pwszCNGHashAlgid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 7?
    pbComputedHash: ?*u8,
    cbComputedHash: u32,
    // TODO: what to do with BytesParamIndex 9?
    pbSignature: ?*u8,
    cbSignature: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = extern struct {
    cOID: u32,
    rgpszOID: ?*?PSTR,
};

pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = fn(
    hNCryptKey: usize,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = fn(
    hBCryptKey: BCRYPT_KEY_HANDLE,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = fn(
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    phKey: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_IMPORT_PRIV_KEY_FUNC = fn(
    hCryptProv: usize,
    pPrivateKeyInfo: ?*CRYPT_PRIVATE_KEY_INFO,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_EXPORT_PRIV_KEY_FUNC = fn(
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pPrivateKeyInfo: ?*CRYPT_PRIVATE_KEY_INFO,
    pcbPrivateKeyInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_GET_SIGNER_CERTIFICATE = fn(
    pvGetArg: ?*anyopaque,
    dwCertEncodingType: u32,
    pSignerId: ?*CERT_INFO,
    hMsgCertStore: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

pub const CRYPT_SIGN_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    pSigningCert: ?*const CERT_CONTEXT,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
    cMsgCert: u32,
    rgpMsgCert: ?*?*CERT_CONTEXT,
    cMsgCrl: u32,
    rgpMsgCrl: ?*?*CRL_CONTEXT,
    cAuthAttr: u32,
    rgAuthAttr: ?*CRYPT_ATTRIBUTE,
    cUnauthAttr: u32,
    rgUnauthAttr: ?*CRYPT_ATTRIBUTE,
    dwFlags: u32,
    dwInnerContentType: u32,
};

pub const CRYPT_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    hCryptProv: usize,
    pfnGetSignerCertificate: ?PFN_CRYPT_GET_SIGNER_CERTIFICATE,
    pvGetArg: ?*anyopaque,
};

pub const CRYPT_ENCRYPT_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: usize,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*anyopaque,
    dwFlags: u32,
    dwInnerContentType: u32,
};

pub const CRYPT_DECRYPT_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: u32,
    cCertStore: u32,
    rghCertStore: ?*?*anyopaque,
};

pub const CRYPT_HASH_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: usize,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
};

pub const CRYPT_KEY_SIGN_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgAndCertEncodingType: CERT_QUERY_ENCODING_TYPE,
    Anonymous: extern union {
        hCryptProv: usize,
        hNCryptKey: usize,
    },
    dwKeySpec: CERT_KEY_SPEC,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*anyopaque,
    PubKeyAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
};

pub const CRYPT_KEY_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: u32,
    dwMsgEncodingType: u32,
    hCryptProv: usize,
};

pub const CERT_CHAIN = extern struct {
    cCerts: u32,
    certs: ?*CRYPTOAPI_BLOB,
    keyLocatorInfo: CRYPT_KEY_PROV_INFO,
};

pub const PFN_CRYPT_ASYNC_PARAM_FREE_FUNC = fn(
    pszParamOid: ?PSTR,
    pvParam: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_BLOB_ARRAY = extern struct {
    cBlob: u32,
    rgBlob: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_CREDENTIALS = extern struct {
    cbSize: u32,
    pszCredentialsOid: ?[*:0]const u8,
    pvCredentials: ?*anyopaque,
};

pub const CRYPT_PASSWORD_CREDENTIALSA = extern struct {
    cbSize: u32,
    pszUsername: ?PSTR,
    pszPassword: ?PSTR,
};

pub const CRYPT_PASSWORD_CREDENTIALSW = extern struct {
    cbSize: u32,
    pszUsername: ?PWSTR,
    pszPassword: ?PWSTR,
};

pub const PFN_FREE_ENCODED_OBJECT_FUNC = fn(
    pszObjectOid: ?[*:0]const u8,
    pObject: ?*CRYPT_BLOB_ARRAY,
    pvFreeContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPTNET_URL_CACHE_PRE_FETCH_INFO = extern struct {
    cbSize: u32,
    dwObjectType: u32,
    dwError: u32,
    dwReserved: u32,
    ThisUpdateTime: FILETIME,
    NextUpdateTime: FILETIME,
    PublishTime: FILETIME,
};

pub const CRYPTNET_URL_CACHE_FLUSH_INFO = extern struct {
    cbSize: u32,
    dwExemptSeconds: u32,
    ExpireTime: FILETIME,
};

pub const CRYPTNET_URL_CACHE_RESPONSE_INFO = extern struct {
    cbSize: u32,
    wResponseType: u16,
    wResponseFlags: u16,
    LastModifiedTime: FILETIME,
    dwMaxAge: u32,
    pwszETag: ?[*:0]const u16,
    dwProxyId: u32,
};

pub const CRYPT_RETRIEVE_AUX_INFO = extern struct {
    cbSize: u32,
    pLastSyncTime: ?*FILETIME,
    dwMaxUrlRetrievalByteCount: u32,
    pPreFetchInfo: ?*CRYPTNET_URL_CACHE_PRE_FETCH_INFO,
    pFlushInfo: ?*CRYPTNET_URL_CACHE_FLUSH_INFO,
    ppResponseInfo: ?*?*CRYPTNET_URL_CACHE_RESPONSE_INFO,
    pwszCacheFileNamePrefix: ?PWSTR,
    pftCacheResync: ?*FILETIME,
    fProxyCacheRetrieval: BOOL,
    dwHttpStatusCode: u32,
    ppwszErrorResponseHeaders: ?*?PWSTR,
    ppErrorContentBlob: ?*?*CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_CANCEL_RETRIEVAL = fn(
    dwFlags: u32,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC = fn(
    pvCompletion: ?*anyopaque,
    dwCompletionCode: u32,
    pszUrl: ?[*:0]const u8,
    pszObjectOid: ?PSTR,
    pvObject: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_ASYNC_RETRIEVAL_COMPLETION = extern struct {
    pfnCompletion: ?PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC,
    pvCompletion: ?*anyopaque,
};

pub const PFN_CANCEL_ASYNC_RETRIEVAL_FUNC = fn(
    hAsyncRetrieve: ?HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_URL_ARRAY = extern struct {
    cUrl: u32,
    rgwszUrl: ?*?PWSTR,
};

pub const CRYPT_URL_INFO = extern struct {
    cbSize: u32,
    dwSyncDeltaTime: u32,
    cGroup: u32,
    rgcGroupEntry: ?*u32,
};

pub const CERT_CRL_CONTEXT_PAIR = extern struct {
    pCertContext: ?*const CERT_CONTEXT,
    pCrlContext: ?*CRL_CONTEXT,
};

pub const CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = extern struct {
    cbSize: u32,
    iDeltaCrlIndicator: i32,
    pftCacheResync: ?*FILETIME,
    pLastSyncTime: ?*FILETIME,
    pMaxAgeTime: ?*FILETIME,
    pChainPara: ?*CERT_REVOCATION_CHAIN_PARA,
    pDeltaCrlIndicator: ?*CRYPTOAPI_BLOB,
};

pub const PFN_CRYPT_ENUM_KEYID_PROP = fn(
    pKeyIdentifier: ?*const CRYPTOAPI_BLOB,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
    cProp: u32,
    rgdwPropId: [*]u32,
    rgpvData: [*]?*anyopaque,
    rgcbData: [*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CHAIN_ENGINE_CONFIG = extern struct {
    cbSize: u32,
    hRestrictedRoot: ?*anyopaque,
    hRestrictedTrust: ?*anyopaque,
    hRestrictedOther: ?*anyopaque,
    cAdditionalStore: u32,
    rghAdditionalStore: ?*?*anyopaque,
    dwFlags: u32,
    dwUrlRetrievalTimeout: u32,
    MaximumCachedCertificates: u32,
    CycleDetectionModulus: u32,
    hExclusiveRoot: ?*anyopaque,
    hExclusiveTrustedPeople: ?*anyopaque,
    dwExclusiveFlags: u32,
};

pub const CERT_TRUST_STATUS = extern struct {
    dwErrorStatus: u32,
    dwInfoStatus: u32,
};

pub const CERT_REVOCATION_INFO = extern struct {
    cbSize: u32,
    dwRevocationResult: u32,
    pszRevocationOid: ?[*:0]const u8,
    pvOidSpecificInfo: ?*anyopaque,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: u32,
    pCrlInfo: ?*CERT_REVOCATION_CRL_INFO,
};

pub const CERT_TRUST_LIST_INFO = extern struct {
    cbSize: u32,
    pCtlEntry: ?*CTL_ENTRY,
    pCtlContext: ?*CTL_CONTEXT,
};

pub const CERT_CHAIN_ELEMENT = extern struct {
    cbSize: u32,
    pCertContext: ?*const CERT_CONTEXT,
    TrustStatus: CERT_TRUST_STATUS,
    pRevocationInfo: ?*CERT_REVOCATION_INFO,
    pIssuanceUsage: ?*CTL_USAGE,
    pApplicationUsage: ?*CTL_USAGE,
    pwszExtendedErrorInfo: ?[*:0]const u16,
};

pub const CERT_SIMPLE_CHAIN = extern struct {
    cbSize: u32,
    TrustStatus: CERT_TRUST_STATUS,
    cElement: u32,
    rgpElement: ?*?*CERT_CHAIN_ELEMENT,
    pTrustListInfo: ?*CERT_TRUST_LIST_INFO,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: u32,
};

pub const CERT_CHAIN_CONTEXT = extern struct {
    cbSize: u32,
    TrustStatus: CERT_TRUST_STATUS,
    cChain: u32,
    rgpChain: ?*?*CERT_SIMPLE_CHAIN,
    cLowerQualityChainContext: u32,
    rgpLowerQualityChainContext: ?*?*CERT_CHAIN_CONTEXT,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: u32,
    dwCreateFlags: u32,
    ChainId: Guid,
};

pub const CERT_USAGE_MATCH = extern struct {
    dwType: u32,
    Usage: CTL_USAGE,
};

pub const CTL_USAGE_MATCH = extern struct {
    dwType: u32,
    Usage: CTL_USAGE,
};

pub const CERT_CHAIN_PARA = extern struct {
    cbSize: u32,
    RequestedUsage: CERT_USAGE_MATCH,
};

pub const CERT_REVOCATION_CHAIN_PARA = extern struct {
    cbSize: u32,
    hChainEngine: ?HCERTCHAINENGINE,
    hAdditionalStore: ?*anyopaque,
    dwChainFlags: u32,
    dwUrlRetrievalTimeout: u32,
    pftCurrentTime: ?*FILETIME,
    pftCacheResync: ?*FILETIME,
    cbMaxUrlRetrievalByteCount: u32,
};

pub const CRL_REVOCATION_INFO = extern struct {
    pCrlEntry: ?*CRL_ENTRY,
    pCrlContext: ?*CRL_CONTEXT,
    pCrlIssuerChain: ?*CERT_CHAIN_CONTEXT,
};

pub const PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK = fn(
    pCert: ?*const CERT_CONTEXT,
    pvFindArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CERT_CHAIN_FIND_BY_ISSUER_PARA = extern struct {
    cbSize: u32,
    pszUsageIdentifier: ?[*:0]const u8,
    dwKeySpec: u32,
    dwAcquirePrivateKeyFlags: u32,
    cIssuer: u32,
    rgIssuer: ?*CRYPTOAPI_BLOB,
    pfnFindCallback: ?PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK,
    pvFindArg: ?*anyopaque,
};

pub const CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwFlags: CERT_CHAIN_POLICY_FLAGS,
    pvExtraPolicyPara: ?*anyopaque,
};

pub const CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwError: u32,
    lChainIndex: i32,
    lElementIndex: i32,
    pvExtraPolicyStatus: ?*anyopaque,
};

pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRegPolicySettings: u32,
    pSignerInfo: ?*CMSG_SIGNER_INFO,
};

pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    fCommercial: BOOL,
};

pub const AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRegPolicySettings: u32,
    fCommercial: BOOL,
};

pub const HTTPSPolicyCallbackData = extern struct {
    Anonymous: extern union {
        cbStruct: u32,
        cbSize: u32,
    },
    dwAuthType: HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE,
    fdwChecks: u32,
    pwszServerName: ?PWSTR,
};

pub const EV_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwRootProgramQualifierFlags: CERT_ROOT_PROGRAM_FLAGS,
};

pub const EV_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwQualifiers: u32,
    dwIssuanceUsageIndex: u32,
};

pub const SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    dwErrorLevel: u32,
    dwErrorCategory: u32,
    dwReserved: u32,
    wszErrorText: [256]u16,
};

pub const SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwReserved: u32,
    pwszServerName: ?PWSTR,
    rgpszHpkpValue: [2]?PSTR,
};

pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: u32,
    dwReserved: u32,
    pwszServerName: ?[*:0]const u16,
};

pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: u32,
    lError: i32,
    wszErrorText: [512]u16,
};

pub const CRYPT_PKCS12_PBE_PARAMS = extern struct {
    iIterations: i32,
    cbSalt: u32,
};

pub const PKCS12_PBES2_EXPORT_PARAMS = extern struct {
    dwSize: u32,
    hNcryptDescriptor: ?*anyopaque,
    pwszPbes2Alg: ?PWSTR,
};

pub const CERT_SERVER_OCSP_RESPONSE_CONTEXT = extern struct {
    cbSize: u32,
    pbEncodedOcspResponse: ?*u8,
    cbEncodedOcspResponse: u32,
};

pub const PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK = fn(
    pChainContext: ?*CERT_CHAIN_CONTEXT,
    pServerOcspResponseContext: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
    pNewCrlContext: ?*CRL_CONTEXT,
    pPrevCrlContext: ?*CRL_CONTEXT,
    pvArg: ?*anyopaque,
    dwWriteOcspFileError: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pcbUsedSize: ?*u32,
    pwszOcspDirectory: ?PWSTR,
    pfnUpdateCallback: ?PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK,
    pvUpdateCallbackArg: ?*anyopaque,
};

pub const CERT_SELECT_CHAIN_PARA = extern struct {
    hChainEngine: ?HCERTCHAINENGINE,
    pTime: ?*FILETIME,
    hAdditionalStore: ?*anyopaque,
    pChainPara: ?*CERT_CHAIN_PARA,
    dwFlags: u32,
};

pub const CERT_SELECT_CRITERIA = extern struct {
    dwType: CERT_SELECT_CRITERIA_TYPE,
    cPara: u32,
    ppPara: ?*?*anyopaque,
};

pub const CRYPT_TIMESTAMP_REQUEST = extern struct {
    dwVersion: CRYPT_TIMESTAMP_VERSION,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPTOAPI_BLOB,
    pszTSAPolicyId: ?PSTR,
    Nonce: CRYPTOAPI_BLOB,
    fCertReq: BOOL,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRYPT_TIMESTAMP_RESPONSE = extern struct {
    dwStatus: CRYPT_TIMESTAMP_RESPONSE_STATUS,
    cFreeText: u32,
    rgFreeText: ?*?PWSTR,
    FailureInfo: CRYPT_BIT_BLOB,
    ContentInfo: CRYPTOAPI_BLOB,
};

pub const CRYPT_TIMESTAMP_ACCURACY = extern struct {
    dwSeconds: u32,
    dwMillis: u32,
    dwMicros: u32,
};

pub const CRYPT_TIMESTAMP_INFO = extern struct {
    dwVersion: u32,
    pszTSAPolicyId: ?PSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPTOAPI_BLOB,
    SerialNumber: CRYPTOAPI_BLOB,
    ftTime: FILETIME,
    pvAccuracy: ?*CRYPT_TIMESTAMP_ACCURACY,
    fOrdering: BOOL,
    Nonce: CRYPTOAPI_BLOB,
    Tsa: CRYPTOAPI_BLOB,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const CRYPT_TIMESTAMP_CONTEXT = extern struct {
    cbEncoded: u32,
    pbEncoded: ?*u8,
    pTimeStamp: ?*CRYPT_TIMESTAMP_INFO,
};

pub const CRYPT_TIMESTAMP_PARA = extern struct {
    pszTSAPolicyId: ?[*:0]const u8,
    fRequestCerts: BOOL,
    Nonce: CRYPTOAPI_BLOB,
    cExtension: u32,
    rgExtension: ?*CERT_EXTENSION,
};

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH = fn(
    pContext: ?*anyopaque,
    rgIdentifierOrNameList: [*]?*CRYPTOAPI_BLOB,
    dwIdentifierOrNameListCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET = fn(
    pPluginContext: ?*anyopaque,
    pIdentifier: ?*CRYPTOAPI_BLOB,
    dwNameType: u32,
    pNameBlob: ?*CRYPTOAPI_BLOB,
    ppbContent: ?*?*u8,
    pcbContent: ?*u32,
    ppwszPassword: ?*?PWSTR,
    ppIdentifier: ?*?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE = fn(
    dwReason: CRYPT_OBJECT_LOCATOR_RELEASE_REASON,
    pPluginContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD = fn(
    pPluginContext: ?*anyopaque,
    pwszPassword: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE = fn(
    pPluginContext: ?*anyopaque,
    pbData: ?*u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER = fn(
    pPluginContext: ?*anyopaque,
    pIdentifier: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = extern struct {
    cbSize: u32,
    pfnGet: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET,
    pfnRelease: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE,
    pfnFreePassword: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD,
    pfnFree: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE,
    pfnFreeIdentifier: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER,
};

pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE = fn(
    pfnFlush: ?PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH,
    pContext: ?*anyopaque,
    pdwExpectedObjectCount: ?*u32,
    ppFuncTable: ?*?*CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE,
    ppPluginContext: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CERT_IS_WEAK_HASH = fn(
    dwHashUseType: u32,
    pwszCNGHashAlgid: ?[*:0]const u16,
    dwChainFlags: u32,
    pSignerChainContext: ?*CERT_CHAIN_CONTEXT,
    pTimeStamp: ?*FILETIME,
    pwszFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPTPROTECT_PROMPTSTRUCT = extern struct {
    cbSize: u32,
    dwPromptFlags: u32,
    hwndApp: ?HWND,
    szPrompt: ?[*:0]const u16,
};

pub const PFNCryptStreamOutputCallback = fn(
    pvCallbackCtxt: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: usize,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NCRYPT_PROTECT_STREAM_INFO = extern struct {
    pfnStreamOutput: ?PFNCryptStreamOutputCallback,
    pvCallbackCtxt: ?*anyopaque,
};

pub const PFNCryptStreamOutputCallbackEx = fn(
    pvCallbackCtxt: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: usize,
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NCRYPT_PROTECT_STREAM_INFO_EX = extern struct {
    pfnStreamOutput: ?PFNCryptStreamOutputCallbackEx,
    pvCallbackCtxt: ?*anyopaque,
};

pub const CRYPT_XML_CHARSET = enum(i32) {
    AUTO = 0,
    UTF8 = 1,
    UTF16LE = 2,
    UTF16BE = 3,
};
pub const CRYPT_XML_CHARSET_AUTO = CRYPT_XML_CHARSET.AUTO;
pub const CRYPT_XML_CHARSET_UTF8 = CRYPT_XML_CHARSET.UTF8;
pub const CRYPT_XML_CHARSET_UTF16LE = CRYPT_XML_CHARSET.UTF16LE;
pub const CRYPT_XML_CHARSET_UTF16BE = CRYPT_XML_CHARSET.UTF16BE;

pub const CRYPT_XML_BLOB = extern struct {
    dwCharset: CRYPT_XML_CHARSET,
    cbData: u32,
    pbData: ?*u8,
};

pub const CRYPT_XML_DATA_BLOB = extern struct {
    cbData: u32,
    pbData: ?*u8,
};

pub const CRYPT_XML_PROPERTY_ID = enum(i32) {
    MAX_HEAP_SIZE = 1,
    SIGNATURE_LOCATION = 2,
    MAX_SIGNATURES = 3,
    DOC_DECLARATION = 4,
    XML_OUTPUT_CHARSET = 5,
};
pub const CRYPT_XML_PROPERTY_MAX_HEAP_SIZE = CRYPT_XML_PROPERTY_ID.MAX_HEAP_SIZE;
pub const CRYPT_XML_PROPERTY_SIGNATURE_LOCATION = CRYPT_XML_PROPERTY_ID.SIGNATURE_LOCATION;
pub const CRYPT_XML_PROPERTY_MAX_SIGNATURES = CRYPT_XML_PROPERTY_ID.MAX_SIGNATURES;
pub const CRYPT_XML_PROPERTY_DOC_DECLARATION = CRYPT_XML_PROPERTY_ID.DOC_DECLARATION;
pub const CRYPT_XML_PROPERTY_XML_OUTPUT_CHARSET = CRYPT_XML_PROPERTY_ID.XML_OUTPUT_CHARSET;

pub const CRYPT_XML_PROPERTY = extern struct {
    dwPropId: CRYPT_XML_PROPERTY_ID,
    pvValue: ?*const anyopaque,
    cbValue: u32,
};

pub const PFN_CRYPT_XML_WRITE_CALLBACK = fn(
    pvCallbackState: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_CRYPT_XML_DATA_PROVIDER_READ = fn(
    pvCallbackState: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*u8,
    cbData: u32,
    pcbRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_CRYPT_XML_DATA_PROVIDER_CLOSE = fn(
    pvCallbackState: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_DATA_PROVIDER = extern struct {
    pvCallbackState: ?*anyopaque,
    cbBufferSize: u32,
    pfnRead: ?PFN_CRYPT_XML_DATA_PROVIDER_READ,
    pfnClose: ?PFN_CRYPT_XML_DATA_PROVIDER_CLOSE,
};

pub const PFN_CRYPT_XML_CREATE_TRANSFORM = fn(
    pTransform: ?*const CRYPT_XML_ALGORITHM,
    pProviderIn: ?*CRYPT_XML_DATA_PROVIDER,
    pProviderOut: ?*CRYPT_XML_DATA_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_STATUS = extern struct {
    cbSize: u32,
    dwErrorStatus: CRYPT_XML_STATUS_ERROR_STATUS,
    dwInfoStatus: CRYPT_XML_STATUS_INFO_STATUS,
};

pub const CRYPT_XML_ALGORITHM = extern struct {
    cbSize: u32,
    wszAlgorithm: ?[*:0]const u16,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_TRANSFORM_INFO = extern struct {
    cbSize: u32,
    wszAlgorithm: ?[*:0]const u16,
    cbBufferSize: u32,
    dwFlags: CRYPT_XML_TRANSFORM_FLAGS,
    pfnCreateTransform: ?PFN_CRYPT_XML_CREATE_TRANSFORM,
};

pub const CRYPT_XML_TRANSFORM_CHAIN_CONFIG = extern struct {
    cbSize: u32,
    cTransformInfo: u32,
    rgpTransformInfo: ?*?*CRYPT_XML_TRANSFORM_INFO,
};

pub const CRYPT_XML_KEY_DSA_KEY_VALUE = extern struct {
    P: CRYPT_XML_DATA_BLOB,
    Q: CRYPT_XML_DATA_BLOB,
    G: CRYPT_XML_DATA_BLOB,
    Y: CRYPT_XML_DATA_BLOB,
    J: CRYPT_XML_DATA_BLOB,
    Seed: CRYPT_XML_DATA_BLOB,
    Counter: CRYPT_XML_DATA_BLOB,
};

pub const CRYPT_XML_KEY_ECDSA_KEY_VALUE = extern struct {
    wszNamedCurve: ?[*:0]const u16,
    X: CRYPT_XML_DATA_BLOB,
    Y: CRYPT_XML_DATA_BLOB,
    ExplicitPara: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_KEY_RSA_KEY_VALUE = extern struct {
    Modulus: CRYPT_XML_DATA_BLOB,
    Exponent: CRYPT_XML_DATA_BLOB,
};

pub const CRYPT_XML_KEY_VALUE = extern struct {
    dwType: CRYPT_XML_KEY_VALUE_TYPE,
    Anonymous: extern union {
        DSAKeyValue: CRYPT_XML_KEY_DSA_KEY_VALUE,
        RSAKeyValue: CRYPT_XML_KEY_RSA_KEY_VALUE,
        ECDSAKeyValue: CRYPT_XML_KEY_ECDSA_KEY_VALUE,
        Custom: CRYPT_XML_BLOB,
    },
};

pub const CRYPT_XML_ISSUER_SERIAL = extern struct {
    wszIssuer: ?[*:0]const u16,
    wszSerial: ?[*:0]const u16,
};

pub const CRYPT_XML_X509DATA_ITEM = extern struct {
    dwType: CRYPT_XML_X509DATA_TYPE,
    Anonymous: extern union {
        IssuerSerial: CRYPT_XML_ISSUER_SERIAL,
        SKI: CRYPT_XML_DATA_BLOB,
        wszSubjectName: ?[*:0]const u16,
        Certificate: CRYPT_XML_DATA_BLOB,
        CRL: CRYPT_XML_DATA_BLOB,
        Custom: CRYPT_XML_BLOB,
    },
};

pub const CRYPT_XML_X509DATA = extern struct {
    cX509Data: u32,
    rgX509Data: ?*CRYPT_XML_X509DATA_ITEM,
};

pub const CRYPT_XML_KEY_INFO_ITEM = extern struct {
    dwType: CRYPT_XML_KEYINFO_TYPE,
    Anonymous: extern union {
        wszKeyName: ?[*:0]const u16,
        KeyValue: CRYPT_XML_KEY_VALUE,
        RetrievalMethod: CRYPT_XML_BLOB,
        X509Data: CRYPT_XML_X509DATA,
        Custom: CRYPT_XML_BLOB,
    },
};

pub const CRYPT_XML_KEY_INFO = extern struct {
    cbSize: u32,
    wszId: ?[*:0]const u16,
    cKeyInfo: u32,
    rgKeyInfo: ?*CRYPT_XML_KEY_INFO_ITEM,
    hVerifyKey: BCRYPT_KEY_HANDLE,
};

pub const CRYPT_XML_REFERENCE = extern struct {
    cbSize: u32,
    hReference: ?*anyopaque,
    wszId: ?[*:0]const u16,
    wszUri: ?[*:0]const u16,
    wszType: ?[*:0]const u16,
    DigestMethod: CRYPT_XML_ALGORITHM,
    DigestValue: CRYPTOAPI_BLOB,
    cTransform: u32,
    rgTransform: ?*CRYPT_XML_ALGORITHM,
};

pub const CRYPT_XML_REFERENCES = extern struct {
    cReference: u32,
    rgpReference: ?*?*CRYPT_XML_REFERENCE,
};

pub const CRYPT_XML_SIGNED_INFO = extern struct {
    cbSize: u32,
    wszId: ?[*:0]const u16,
    Canonicalization: CRYPT_XML_ALGORITHM,
    SignatureMethod: CRYPT_XML_ALGORITHM,
    cReference: u32,
    rgpReference: ?*?*CRYPT_XML_REFERENCE,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_OBJECT = extern struct {
    cbSize: u32,
    hObject: ?*anyopaque,
    wszId: ?[*:0]const u16,
    wszMimeType: ?[*:0]const u16,
    wszEncoding: ?[*:0]const u16,
    Manifest: CRYPT_XML_REFERENCES,
    Encoded: CRYPT_XML_BLOB,
};

pub const CRYPT_XML_SIGNATURE = extern struct {
    cbSize: u32,
    hSignature: ?*anyopaque,
    wszId: ?[*:0]const u16,
    SignedInfo: CRYPT_XML_SIGNED_INFO,
    SignatureValue: CRYPTOAPI_BLOB,
    pKeyInfo: ?*CRYPT_XML_KEY_INFO,
    cObject: u32,
    rgpObject: ?*?*CRYPT_XML_OBJECT,
};

pub const CRYPT_XML_DOC_CTXT = extern struct {
    cbSize: u32,
    hDocCtxt: ?*anyopaque,
    pTransformsConfig: ?*CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    cSignature: u32,
    rgpSignature: ?*?*CRYPT_XML_SIGNATURE,
};

pub const CRYPT_XML_KEYINFO_PARAM = extern struct {
    wszId: ?[*:0]const u16,
    wszKeyName: ?[*:0]const u16,
    SKI: CRYPTOAPI_BLOB,
    wszSubjectName: ?[*:0]const u16,
    cCertificate: u32,
    rgCertificate: ?*CRYPTOAPI_BLOB,
    cCRL: u32,
    rgCRL: ?*CRYPTOAPI_BLOB,
};

pub const CRYPT_XML_KEYINFO_SPEC = enum(i32) {
    NONE = 0,
    ENCODED = 1,
    PARAM = 2,
};
pub const CRYPT_XML_KEYINFO_SPEC_NONE = CRYPT_XML_KEYINFO_SPEC.NONE;
pub const CRYPT_XML_KEYINFO_SPEC_ENCODED = CRYPT_XML_KEYINFO_SPEC.ENCODED;
pub const CRYPT_XML_KEYINFO_SPEC_PARAM = CRYPT_XML_KEYINFO_SPEC.PARAM;

pub const CRYPT_XML_ALGORITHM_INFO = extern struct {
    cbSize: u32,
    wszAlgorithmURI: ?PWSTR,
    wszName: ?PWSTR,
    dwGroupId: CRYPT_XML_GROUP_ID,
    wszCNGAlgid: ?PWSTR,
    wszCNGExtraAlgid: ?PWSTR,
    dwSignFlags: u32,
    dwVerifyFlags: u32,
    pvPaddingInfo: ?*anyopaque,
    pvExtraInfo: ?*anyopaque,
};

pub const PFN_CRYPT_XML_ENUM_ALG_INFO = fn(
    pInfo: ?*const CRYPT_XML_ALGORITHM_INFO,
    pvArg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CryptXmlDllGetInterface = fn(
    dwFlags: u32,
    pMethod: ?*const CRYPT_XML_ALGORITHM_INFO,
    pInterface: ?*CRYPT_XML_CRYPTOGRAPHIC_INTERFACE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllEncodeAlgorithm = fn(
    pAlgInfo: ?*const CRYPT_XML_ALGORITHM_INFO,
    dwCharset: CRYPT_XML_CHARSET,
    pvCallbackState: ?*anyopaque,
    pfnWrite: ?PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCreateDigest = fn(
    pDigestMethod: ?*const CRYPT_XML_ALGORITHM,
    pcbSize: ?*u32,
    phDigest: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllDigestData = fn(
    hDigest: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllFinalizeDigest = fn(
    hDigest: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbDigest: ?*u8,
    cbDigest: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCloseDigest = fn(
    hDigest: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllSignData = fn(
    pSignatureMethod: ?*const CRYPT_XML_ALGORITHM,
    hCryptProvOrNCryptKey: usize,
    dwKeySpec: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbInput: ?*const u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllVerifySignature = fn(
    pSignatureMethod: ?*const CRYPT_XML_ALGORITHM,
    hKey: BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: ?*const u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*const u8,
    cbSignature: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllGetAlgorithmInfo = fn(
    pXmlAlgorithm: ?*const CRYPT_XML_ALGORITHM,
    ppAlgInfo: ?*?*CRYPT_XML_ALGORITHM_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CRYPT_XML_CRYPTOGRAPHIC_INTERFACE = extern struct {
    cbSize: u32,
    fpCryptXmlEncodeAlgorithm: ?CryptXmlDllEncodeAlgorithm,
    fpCryptXmlCreateDigest: ?CryptXmlDllCreateDigest,
    fpCryptXmlDigestData: ?CryptXmlDllDigestData,
    fpCryptXmlFinalizeDigest: ?CryptXmlDllFinalizeDigest,
    fpCryptXmlCloseDigest: ?CryptXmlDllCloseDigest,
    fpCryptXmlSignData: ?CryptXmlDllSignData,
    fpCryptXmlVerifySignature: ?CryptXmlDllVerifySignature,
    fpCryptXmlGetAlgorithmInfo: ?CryptXmlDllGetAlgorithmInfo,
};

pub const CryptXmlDllEncodeKeyValue = fn(
    hKey: usize,
    dwCharset: CRYPT_XML_CHARSET,
    pvCallbackState: ?*anyopaque,
    pfnWrite: ?PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CryptXmlDllCreateKey = fn(
    pEncoded: ?*const CRYPT_XML_BLOB,
    phKey: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const HandleType = enum(i32) {
    Asymmetric = 1,
    Symmetric = 2,
    Transform = 3,
    Hash = 4,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const PaddingMode = enum(i32) {
    None = 1,
    PKCS7 = 2,
    Zeros = 3,
    ANSIX923 = 4,
    ISO10126 = 5,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const Direction = enum(i32) {
    Encrypt = 1,
    Decrypt = 2,
};
pub const DirectionEncrypt = Direction.Encrypt;
pub const DirectionDecrypt = Direction.Decrypt;

pub const INFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS = extern struct {
    keySize: i32,
    keyExchangeAlgorithm: ?PWSTR,
    signatureAlgorithm: ?PWSTR,
};

pub const INFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS = extern struct {
    keySize: i32,
    blockSize: i32,
    feedbackSize: i32,
};

pub const INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS = extern struct {
    inputBlockSize: i32,
    outputBlockSize: i32,
    canTransformMultipleBlocks: BOOL,
    canReuseTransform: BOOL,
};

pub const INFORMATIONCARD_HASH_CRYPTO_PARAMETERS = extern struct {
    hashSize: i32,
    transform: INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS,
};

pub const INFORMATIONCARD_CRYPTO_HANDLE = extern struct {
    type: HandleType,
    expiration: i64,
    cryptoParameters: ?*anyopaque,
};

pub const GENERIC_XML_TOKEN = packed struct {
    createDate: FILETIME,
    expiryDate: FILETIME,
    xmlToken: ?PWSTR,
    internalTokenReference: ?PWSTR,
    externalTokenReference: ?PWSTR,
};

pub const POLICY_ELEMENT = extern struct {
    targetEndpointAddress: ?[*:0]const u16,
    issuerEndpointAddress: ?[*:0]const u16,
    issuedTokenParameters: ?[*:0]const u16,
    privacyNoticeLink: ?[*:0]const u16,
    privacyNoticeVersion: u32,
    useManagedPresentation: BOOL,
};

pub const ENDPOINTADDRESS = extern struct {
    serviceUrl: ?[*:0]const u16,
    policyUrl: ?[*:0]const u16,
    rawCertificate: CRYPTOAPI_BLOB,
};

pub const ENDPOINTADDRESS2 = extern struct {
    serviceUrl: ?[*:0]const u16,
    policyUrl: ?[*:0]const u16,
    identityType: u32,
    identityBytes: ?*anyopaque,
};

pub const CERTIFICATE_CHAIN_BLOB = extern struct {
    certCount: u32,
    rawCertificates: ?*CRYPTOAPI_BLOB,
};

pub const CLAIMLIST = extern struct {
    count: u32,
    claims: ?*?PWSTR,
};

pub const RECIPIENTPOLICY = extern struct {
    recipient: ENDPOINTADDRESS,
    issuer: ENDPOINTADDRESS,
    tokenType: ?[*:0]const u16,
    requiredClaims: CLAIMLIST,
    optionalClaims: CLAIMLIST,
    privacyUrl: ?[*:0]const u16,
    privacyVersion: u32,
};

pub const RECIPIENTPOLICY2 = extern struct {
    recipient: ENDPOINTADDRESS2,
    issuer: ENDPOINTADDRESS2,
    tokenType: ?[*:0]const u16,
    requiredClaims: CLAIMLIST,
    optionalClaims: CLAIMLIST,
    privacyUrl: ?[*:0]const u16,
    privacyVersion: u32,
};

const CLSID_CCertSrvSetupKeyInformation_Value = @import("../zig.zig").Guid.initString("38373906-5433-4633-b0fb-29b7e78262e1");
pub const CLSID_CCertSrvSetupKeyInformation = &CLSID_CCertSrvSetupKeyInformation_Value;

const CLSID_CCertSrvSetup_Value = @import("../zig.zig").Guid.initString("961f180f-f55c-413d-a9b3-7d2af4d8e42f");
pub const CLSID_CCertSrvSetup = &CLSID_CCertSrvSetup_Value;

const CLSID_CMSCEPSetup_Value = @import("../zig.zig").Guid.initString("aa4f5c02-8e7c-49c4-94fa-67a5cc5eadb4");
pub const CLSID_CMSCEPSetup = &CLSID_CMSCEPSetup_Value;

const CLSID_CCertificateEnrollmentServerSetup_Value = @import("../zig.zig").Guid.initString("9902f3bc-88af-4cf8-ae62-7140531552b6");
pub const CLSID_CCertificateEnrollmentServerSetup = &CLSID_CCertificateEnrollmentServerSetup_Value;

const CLSID_CCertificateEnrollmentPolicyServerSetup_Value = @import("../zig.zig").Guid.initString("afe2fa32-41b1-459d-a5de-49add8a72182");
pub const CLSID_CCertificateEnrollmentPolicyServerSetup = &CLSID_CCertificateEnrollmentPolicyServerSetup_Value;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformation_Value = @import("../zig.zig").Guid.initString("6ba73778-36da-4c39-8a85-bcfa7d000793");
pub const IID_ICertSrvSetupKeyInformation = &IID_ICertSrvSetupKeyInformation_Value;
pub const ICertSrvSetupKeyInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderName: fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Length: fn(
            self: *const ICertSrvSetupKeyInformation,
            lVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Existing: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Existing: fn(
            self: *const ICertSrvSetupKeyInformation,
            bVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainerName: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ContainerName: fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExistingCACertificate: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExistingCACertificate: fn(
            self: *const ICertSrvSetupKeyInformation,
            varVal: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_ProviderName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_ProviderName(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_ProviderName(self: *const T, bstrVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_ProviderName(@ptrCast(*const ICertSrvSetupKeyInformation, self), bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_Length(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_Length(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_Length(self: *const T, lVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_Length(@ptrCast(*const ICertSrvSetupKeyInformation, self), lVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_Existing(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_Existing(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_Existing(self: *const T, bVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_Existing(@ptrCast(*const ICertSrvSetupKeyInformation, self), bVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_ContainerName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_ContainerName(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_ContainerName(self: *const T, bstrVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_ContainerName(@ptrCast(*const ICertSrvSetupKeyInformation, self), bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_HashAlgorithm(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_HashAlgorithm(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_HashAlgorithm(self: *const T, bstrVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_HashAlgorithm(@ptrCast(*const ICertSrvSetupKeyInformation, self), bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_ExistingCACertificate(self: *const T, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_ExistingCACertificate(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_ExistingCACertificate(self: *const T, varVal: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_ExistingCACertificate(@ptrCast(*const ICertSrvSetupKeyInformation, self), varVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformationCollection_Value = @import("../zig.zig").Guid.initString("e65c8b00-e58f-41f9-a9ec-a28d7427c844");
pub const IID_ICertSrvSetupKeyInformationCollection = &IID_ICertSrvSetupKeyInformationCollection_Value;
pub const ICertSrvSetupKeyInformationCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            ppVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            Index: i32,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            pIKeyInformation: ?*ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_get__NewEnum(self: *const T, ppVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_get_Item(self: *const T, Index: i32, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).get_Item(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_get_Count(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).get_Count(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_Add(self: *const T, pIKeyInformation: ?*ICertSrvSetupKeyInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).Add(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), pIKeyInformation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CASetupProperty = enum(i32) {
    INVALID = -1,
    CATYPE = 0,
    CAKEYINFORMATION = 1,
    INTERACTIVE = 2,
    CANAME = 3,
    CADSSUFFIX = 4,
    VALIDITYPERIOD = 5,
    VALIDITYPERIODUNIT = 6,
    EXPIRATIONDATE = 7,
    PRESERVEDATABASE = 8,
    DATABASEDIRECTORY = 9,
    LOGDIRECTORY = 10,
    SHAREDFOLDER = 11,
    PARENTCAMACHINE = 12,
    PARENTCANAME = 13,
    REQUESTFILE = 14,
    WEBCAMACHINE = 15,
    WEBCANAME = 16,
};
pub const ENUM_SETUPPROP_INVALID = CASetupProperty.INVALID;
pub const ENUM_SETUPPROP_CATYPE = CASetupProperty.CATYPE;
pub const ENUM_SETUPPROP_CAKEYINFORMATION = CASetupProperty.CAKEYINFORMATION;
pub const ENUM_SETUPPROP_INTERACTIVE = CASetupProperty.INTERACTIVE;
pub const ENUM_SETUPPROP_CANAME = CASetupProperty.CANAME;
pub const ENUM_SETUPPROP_CADSSUFFIX = CASetupProperty.CADSSUFFIX;
pub const ENUM_SETUPPROP_VALIDITYPERIOD = CASetupProperty.VALIDITYPERIOD;
pub const ENUM_SETUPPROP_VALIDITYPERIODUNIT = CASetupProperty.VALIDITYPERIODUNIT;
pub const ENUM_SETUPPROP_EXPIRATIONDATE = CASetupProperty.EXPIRATIONDATE;
pub const ENUM_SETUPPROP_PRESERVEDATABASE = CASetupProperty.PRESERVEDATABASE;
pub const ENUM_SETUPPROP_DATABASEDIRECTORY = CASetupProperty.DATABASEDIRECTORY;
pub const ENUM_SETUPPROP_LOGDIRECTORY = CASetupProperty.LOGDIRECTORY;
pub const ENUM_SETUPPROP_SHAREDFOLDER = CASetupProperty.SHAREDFOLDER;
pub const ENUM_SETUPPROP_PARENTCAMACHINE = CASetupProperty.PARENTCAMACHINE;
pub const ENUM_SETUPPROP_PARENTCANAME = CASetupProperty.PARENTCANAME;
pub const ENUM_SETUPPROP_REQUESTFILE = CASetupProperty.REQUESTFILE;
pub const ENUM_SETUPPROP_WEBCAMACHINE = CASetupProperty.WEBCAMACHINE;
pub const ENUM_SETUPPROP_WEBCANAME = CASetupProperty.WEBCANAME;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetup_Value = @import("../zig.zig").Guid.initString("b760a1bb-4784-44c0-8f12-555f0780ff25");
pub const IID_ICertSrvSetup = &IID_ICertSrvSetup_Value;
pub const ICertSrvSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorId: fn(
            self: *const ICertSrvSetup,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorString: fn(
            self: *const ICertSrvSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: fn(
            self: *const ICertSrvSetup,
            bServer: i16,
            bClient: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASetupProperty: fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCASetupProperty: fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPropertyEditable: fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pbEditable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedCATypes: fn(
            self: *const ICertSrvSetup,
            pCATypes: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: fn(
            self: *const ICertSrvSetup,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: fn(
            self: *const ICertSrvSetup,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashAlgorithmList: fn(
            self: *const ICertSrvSetup,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateKeyContainerList: fn(
            self: *const ICertSrvSetup,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExistingCACertificates: fn(
            self: *const ICertSrvSetup,
            ppVal: ?*?*ICertSrvSetupKeyInformationCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CAImportPFX: fn(
            self: *const ICertSrvSetup,
            bstrFileName: ?BSTR,
            bstrPasswd: ?BSTR,
            bOverwriteExistingKey: i16,
            ppVal: ?*?*ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCADistinguishedName: fn(
            self: *const ICertSrvSetup,
            bstrCADN: ?BSTR,
            bIgnoreUnicode: i16,
            bOverwriteExistingKey: i16,
            bOverwriteExistingCAInDS: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDatabaseInformation: fn(
            self: *const ICertSrvSetup,
            bstrDBDirectory: ?BSTR,
            bstrLogDirectory: ?BSTR,
            bstrSharedFolder: ?BSTR,
            bForceOverwrite: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParentCAInformation: fn(
            self: *const ICertSrvSetup,
            bstrCAConfiguration: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWebCAInformation: fn(
            self: *const ICertSrvSetup,
            bstrCAConfiguration: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: fn(
            self: *const ICertSrvSetup,
            bClientOnly: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: fn(
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_get_CAErrorId(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).get_CAErrorId(@ptrCast(*const ICertSrvSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_get_CAErrorString(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).get_CAErrorString(@ptrCast(*const ICertSrvSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_InitializeDefaults(self: *const T, bServer: i16, bClient: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).InitializeDefaults(@ptrCast(*const ICertSrvSetup, self), bServer, bClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetCASetupProperty(self: *const T, propertyId: CASetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetCASetupProperty(@ptrCast(*const ICertSrvSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetCASetupProperty(self: *const T, propertyId: CASetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetCASetupProperty(@ptrCast(*const ICertSrvSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_IsPropertyEditable(self: *const T, propertyId: CASetupProperty, pbEditable: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).IsPropertyEditable(@ptrCast(*const ICertSrvSetup, self), propertyId, pbEditable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetSupportedCATypes(self: *const T, pCATypes: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetSupportedCATypes(@ptrCast(*const ICertSrvSetup, self), pCATypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetProviderNameList(self: *const T, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetProviderNameList(@ptrCast(*const ICertSrvSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetKeyLengthList(self: *const T, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetKeyLengthList(@ptrCast(*const ICertSrvSetup, self), bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetHashAlgorithmList(self: *const T, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetHashAlgorithmList(@ptrCast(*const ICertSrvSetup, self), bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetPrivateKeyContainerList(self: *const T, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetPrivateKeyContainerList(@ptrCast(*const ICertSrvSetup, self), bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetExistingCACertificates(self: *const T, ppVal: ?*?*ICertSrvSetupKeyInformationCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetExistingCACertificates(@ptrCast(*const ICertSrvSetup, self), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_CAImportPFX(self: *const T, bstrFileName: ?BSTR, bstrPasswd: ?BSTR, bOverwriteExistingKey: i16, ppVal: ?*?*ICertSrvSetupKeyInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).CAImportPFX(@ptrCast(*const ICertSrvSetup, self), bstrFileName, bstrPasswd, bOverwriteExistingKey, ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetCADistinguishedName(self: *const T, bstrCADN: ?BSTR, bIgnoreUnicode: i16, bOverwriteExistingKey: i16, bOverwriteExistingCAInDS: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetCADistinguishedName(@ptrCast(*const ICertSrvSetup, self), bstrCADN, bIgnoreUnicode, bOverwriteExistingKey, bOverwriteExistingCAInDS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetDatabaseInformation(self: *const T, bstrDBDirectory: ?BSTR, bstrLogDirectory: ?BSTR, bstrSharedFolder: ?BSTR, bForceOverwrite: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetDatabaseInformation(@ptrCast(*const ICertSrvSetup, self), bstrDBDirectory, bstrLogDirectory, bstrSharedFolder, bForceOverwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetParentCAInformation(self: *const T, bstrCAConfiguration: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetParentCAInformation(@ptrCast(*const ICertSrvSetup, self), bstrCAConfiguration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetWebCAInformation(self: *const T, bstrCAConfiguration: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetWebCAInformation(@ptrCast(*const ICertSrvSetup, self), bstrCAConfiguration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).Install(@ptrCast(*const ICertSrvSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_PreUnInstall(self: *const T, bClientOnly: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).PreUnInstall(@ptrCast(*const ICertSrvSetup, self), bClientOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_PostUnInstall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).PostUnInstall(@ptrCast(*const ICertSrvSetup, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MSCEPSetupProperty = enum(i32) {
    USELOCALSYSTEM = 0,
    USECHALLENGE = 1,
    RANAME_CN = 2,
    RANAME_EMAIL = 3,
    RANAME_COMPANY = 4,
    RANAME_DEPT = 5,
    RANAME_CITY = 6,
    RANAME_STATE = 7,
    RANAME_COUNTRY = 8,
    SIGNINGKEYINFORMATION = 9,
    EXCHANGEKEYINFORMATION = 10,
    CAINFORMATION = 11,
    MSCEPURL = 12,
    CHALLENGEURL = 13,
};
pub const ENUM_CEPSETUPPROP_USELOCALSYSTEM = MSCEPSetupProperty.USELOCALSYSTEM;
pub const ENUM_CEPSETUPPROP_USECHALLENGE = MSCEPSetupProperty.USECHALLENGE;
pub const ENUM_CEPSETUPPROP_RANAME_CN = MSCEPSetupProperty.RANAME_CN;
pub const ENUM_CEPSETUPPROP_RANAME_EMAIL = MSCEPSetupProperty.RANAME_EMAIL;
pub const ENUM_CEPSETUPPROP_RANAME_COMPANY = MSCEPSetupProperty.RANAME_COMPANY;
pub const ENUM_CEPSETUPPROP_RANAME_DEPT = MSCEPSetupProperty.RANAME_DEPT;
pub const ENUM_CEPSETUPPROP_RANAME_CITY = MSCEPSetupProperty.RANAME_CITY;
pub const ENUM_CEPSETUPPROP_RANAME_STATE = MSCEPSetupProperty.RANAME_STATE;
pub const ENUM_CEPSETUPPROP_RANAME_COUNTRY = MSCEPSetupProperty.RANAME_COUNTRY;
pub const ENUM_CEPSETUPPROP_SIGNINGKEYINFORMATION = MSCEPSetupProperty.SIGNINGKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_EXCHANGEKEYINFORMATION = MSCEPSetupProperty.EXCHANGEKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_CAINFORMATION = MSCEPSetupProperty.CAINFORMATION;
pub const ENUM_CEPSETUPPROP_MSCEPURL = MSCEPSetupProperty.MSCEPURL;
pub const ENUM_CEPSETUPPROP_CHALLENGEURL = MSCEPSetupProperty.CHALLENGEURL;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IMSCEPSetup_Value = @import("../zig.zig").Guid.initString("4f7761bb-9f3b-4592-9ee0-9a73259c313e");
pub const IID_IMSCEPSetup = &IID_IMSCEPSetup_Value;
pub const IMSCEPSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorId: fn(
            self: *const IMSCEPSetup,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorString: fn(
            self: *const IMSCEPSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMSCEPSetupProperty: fn(
            self: *const IMSCEPSetup,
            propertyId: MSCEPSetupProperty,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMSCEPSetupProperty: fn(
            self: *const IMSCEPSetup,
            propertyId: MSCEPSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAccountInformation: fn(
            self: *const IMSCEPSetup,
            bstrUserName: ?BSTR,
            bstrPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMSCEPStoreEmpty: fn(
            self: *const IMSCEPSetup,
            pbEmpty: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: fn(
            self: *const IMSCEPSetup,
            bExchange: i16,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: fn(
            self: *const IMSCEPSetup,
            bExchange: i16,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_get_MSCEPErrorId(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).get_MSCEPErrorId(@ptrCast(*const IMSCEPSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_get_MSCEPErrorString(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).get_MSCEPErrorString(@ptrCast(*const IMSCEPSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_InitializeDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).InitializeDefaults(@ptrCast(*const IMSCEPSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_GetMSCEPSetupProperty(self: *const T, propertyId: MSCEPSetupProperty, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).GetMSCEPSetupProperty(@ptrCast(*const IMSCEPSetup, self), propertyId, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_SetMSCEPSetupProperty(self: *const T, propertyId: MSCEPSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).SetMSCEPSetupProperty(@ptrCast(*const IMSCEPSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_SetAccountInformation(self: *const T, bstrUserName: ?BSTR, bstrPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).SetAccountInformation(@ptrCast(*const IMSCEPSetup, self), bstrUserName, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_IsMSCEPStoreEmpty(self: *const T, pbEmpty: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).IsMSCEPStoreEmpty(@ptrCast(*const IMSCEPSetup, self), pbEmpty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_GetProviderNameList(self: *const T, bExchange: i16, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).GetProviderNameList(@ptrCast(*const IMSCEPSetup, self), bExchange, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_GetKeyLengthList(self: *const T, bExchange: i16, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).GetKeyLengthList(@ptrCast(*const IMSCEPSetup, self), bExchange, bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).Install(@ptrCast(*const IMSCEPSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_PreUnInstall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).PreUnInstall(@ptrCast(*const IMSCEPSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_PostUnInstall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).PostUnInstall(@ptrCast(*const IMSCEPSetup, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CESSetupProperty = enum(i32) {
    USE_IISAPPPOOLIDENTITY = 0,
    CACONFIG = 1,
    AUTHENTICATION = 2,
    SSLCERTHASH = 3,
    URL = 4,
    RENEWALONLY = 5,
    ALLOW_KEYBASED_RENEWAL = 6,
};
pub const ENUM_CESSETUPPROP_USE_IISAPPPOOLIDENTITY = CESSetupProperty.USE_IISAPPPOOLIDENTITY;
pub const ENUM_CESSETUPPROP_CACONFIG = CESSetupProperty.CACONFIG;
pub const ENUM_CESSETUPPROP_AUTHENTICATION = CESSetupProperty.AUTHENTICATION;
pub const ENUM_CESSETUPPROP_SSLCERTHASH = CESSetupProperty.SSLCERTHASH;
pub const ENUM_CESSETUPPROP_URL = CESSetupProperty.URL;
pub const ENUM_CESSETUPPROP_RENEWALONLY = CESSetupProperty.RENEWALONLY;
pub const ENUM_CESSETUPPROP_ALLOW_KEYBASED_RENEWAL = CESSetupProperty.ALLOW_KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentServerSetup_Value = @import("../zig.zig").Guid.initString("70027fdb-9dd9-4921-8944-b35cb31bd2ec");
pub const IID_ICertificateEnrollmentServerSetup = &IID_ICertificateEnrollmentServerSetup_Value;
pub const ICertificateEnrollmentServerSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: fn(
            self: *const ICertificateEnrollmentServerSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: fn(
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ICertificateEnrollmentServerSetup,
            propertyId: CESSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ICertificateEnrollmentServerSetup,
            propertyId: CESSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationPoolCredentials: fn(
            self: *const ICertificateEnrollmentServerSetup,
            bstrUsername: ?BSTR,
            bstrPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: fn(
            self: *const ICertificateEnrollmentServerSetup,
            pCAConfig: ?*VARIANT,
            pAuthentication: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_get_ErrorString(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).get_ErrorString(@ptrCast(*const ICertificateEnrollmentServerSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_InitializeInstallDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).InitializeInstallDefaults(@ptrCast(*const ICertificateEnrollmentServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_GetProperty(self: *const T, propertyId: CESSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).GetProperty(@ptrCast(*const ICertificateEnrollmentServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_SetProperty(self: *const T, propertyId: CESSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).SetProperty(@ptrCast(*const ICertificateEnrollmentServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_SetApplicationPoolCredentials(self: *const T, bstrUsername: ?BSTR, bstrPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).SetApplicationPoolCredentials(@ptrCast(*const ICertificateEnrollmentServerSetup, self), bstrUsername, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).Install(@ptrCast(*const ICertificateEnrollmentServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_UnInstall(self: *const T, pCAConfig: ?*VARIANT, pAuthentication: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).UnInstall(@ptrCast(*const ICertificateEnrollmentServerSetup, self), pCAConfig, pAuthentication);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CEPSetupProperty = enum(i32) {
    AUTHENTICATION = 0,
    SSLCERTHASH = 1,
    URL = 2,
    KEYBASED_RENEWAL = 3,
};
pub const ENUM_CEPSETUPPROP_AUTHENTICATION = CEPSetupProperty.AUTHENTICATION;
pub const ENUM_CEPSETUPPROP_SSLCERTHASH = CEPSetupProperty.SSLCERTHASH;
pub const ENUM_CEPSETUPPROP_URL = CEPSetupProperty.URL;
pub const ENUM_CEPSETUPPROP_KEYBASED_RENEWAL = CEPSetupProperty.KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentPolicyServerSetup_Value = @import("../zig.zig").Guid.initString("859252cc-238c-4a88-b8fd-a37e7d04e68b");
pub const IID_ICertificateEnrollmentPolicyServerSetup = &IID_ICertificateEnrollmentPolicyServerSetup_Value;
pub const ICertificateEnrollmentPolicyServerSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            propertyId: CEPSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            propertyId: CEPSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            pAuthKeyBasedRenewal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_get_ErrorString(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).get_ErrorString(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_InitializeInstallDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).InitializeInstallDefaults(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_GetProperty(self: *const T, propertyId: CEPSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).GetProperty(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_SetProperty(self: *const T, propertyId: CEPSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).SetProperty(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).Install(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_UnInstall(self: *const T, pAuthKeyBasedRenewal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).UnInstall(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), pAuthKeyBasedRenewal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (397)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptAcquireContextA(
    phProv: ?*usize,
    szContainer: ?[*:0]const u8,
    szProvider: ?[*:0]const u8,
    dwProvType: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptAcquireContextW(
    phProv: ?*usize,
    szContainer: ?[*:0]const u16,
    szProvider: ?[*:0]const u16,
    dwProvType: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptReleaseContext(
    hProv: usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGenKey(
    hProv: usize,
    Algid: u32,
    dwFlags: CRYPT_KEY_FLAGS,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDeriveKey(
    hProv: usize,
    Algid: u32,
    hBaseData: usize,
    dwFlags: u32,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDestroyKey(
    hKey: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetKeyParam(
    hKey: usize,
    dwParam: CRYPT_KEY_PARAM_ID,
    pbData: ?*const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetKeyParam(
    hKey: usize,
    dwParam: CRYPT_KEY_PARAM_ID,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetHashParam(
    hHash: usize,
    dwParam: CRYPT_SET_HASH_PARAM,
    pbData: ?*const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetHashParam(
    hHash: usize,
    dwParam: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProvParam(
    hProv: usize,
    dwParam: CRYPT_SET_PROV_PARAM_ID,
    pbData: ?*const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetProvParam(
    hProv: usize,
    dwParam: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGenRandom(
    hProv: usize,
    dwLen: u32,
    // TODO: what to do with BytesParamIndex 1?
    pbBuffer: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetUserKey(
    hProv: usize,
    dwKeySpec: u32,
    phUserKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptExportKey(
    hKey: usize,
    hExpKey: usize,
    dwBlobType: u32,
    dwFlags: CRYPT_KEY_FLAGS,
    // TODO: what to do with BytesParamIndex 5?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptImportKey(
    hProv: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    dwDataLen: u32,
    hPubKey: usize,
    dwFlags: CRYPT_KEY_FLAGS,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEncrypt(
    hKey: usize,
    hHash: usize,
    Final: BOOL,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDecrypt(
    hKey: usize,
    hHash: usize,
    Final: BOOL,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbData: ?*u8,
    pdwDataLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptCreateHash(
    hProv: usize,
    Algid: u32,
    hKey: usize,
    dwFlags: u32,
    phHash: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptHashData(
    hHash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    dwDataLen: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptHashSessionKey(
    hHash: usize,
    hKey: usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDestroyHash(
    hHash: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSignHashA(
    hHash: usize,
    dwKeySpec: u32,
    szDescription: ?[*:0]const u8,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    pdwSigLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSignHashW(
    hHash: usize,
    dwKeySpec: u32,
    szDescription: ?[*:0]const u16,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    pdwSigLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptVerifySignatureA(
    hHash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbSignature: ?*const u8,
    dwSigLen: u32,
    hPubKey: usize,
    szDescription: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptVerifySignatureW(
    hHash: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbSignature: ?*const u8,
    dwSigLen: u32,
    hPubKey: usize,
    szDescription: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProviderA(
    pszProvName: ?[*:0]const u8,
    dwProvType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProviderW(
    pszProvName: ?[*:0]const u16,
    dwProvType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProviderExA(
    pszProvName: ?[*:0]const u8,
    dwProvType: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptSetProviderExW(
    pszProvName: ?[*:0]const u16,
    dwProvType: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetDefaultProviderA(
    dwProvType: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pszProvName: ?PSTR,
    pcbProvName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptGetDefaultProviderW(
    dwProvType: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pszProvName: ?PWSTR,
    pcbProvName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEnumProviderTypesA(
    dwIndex: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    pdwProvType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    szTypeName: ?PSTR,
    pcbTypeName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEnumProviderTypesW(
    dwIndex: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    pdwProvType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    szTypeName: ?PWSTR,
    pcbTypeName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEnumProvidersA(
    dwIndex: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    pdwProvType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    szProvName: ?PSTR,
    pcbProvName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptEnumProvidersW(
    dwIndex: u32,
    pdwReserved: ?*u32,
    dwFlags: u32,
    pdwProvType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    szProvName: ?PWSTR,
    pcbProvName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptContextAddRef(
    hProv: usize,
    pdwReserved: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDuplicateKey(
    hKey: usize,
    pdwReserved: ?*u32,
    dwFlags: u32,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CryptDuplicateHash(
    hHash: usize,
    pdwReserved: ?*u32,
    dwFlags: u32,
    phHash: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptOpenAlgorithmProvider(
    phAlgorithm: ?*BCRYPT_ALG_HANDLE,
    pszAlgId: ?[*:0]const u16,
    pszImplementation: ?[*:0]const u16,
    dwFlags: BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumAlgorithms(
    dwAlgOperations: BCRYPT_OPERATION,
    pAlgCount: ?*u32,
    ppAlgList: ?*?*BCRYPT_ALGORITHM_IDENTIFIER,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumProviders(
    pszAlgId: ?[*:0]const u16,
    pImplCount: ?*u32,
    ppImplList: ?*?*BCRYPT_PROVIDER_NAME,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGetProperty(
    hObject: ?*anyopaque,
    pszProperty: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSetProperty(
    hObject: ?*anyopaque,
    pszProperty: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCloseAlgorithmProvider(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFreeBuffer(
    pvBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenerateSymmetricKey(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    phKey: ?*BCRYPT_KEY_HANDLE,
    pbKeyObject: ?*u8,
    cbKeyObject: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSecret: ?*u8,
    cbSecret: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenerateKeyPair(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    phKey: ?*BCRYPT_KEY_HANDLE,
    dwLength: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEncrypt(
    hKey: BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbIV: ?*u8,
    cbIV: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDecrypt(
    hKey: BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbIV: ?*u8,
    cbIV: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptExportKey(
    hKey: BCRYPT_KEY_HANDLE,
    hExportKey: BCRYPT_KEY_HANDLE,
    pszBlobType: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptImportKey(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    hImportKey: BCRYPT_KEY_HANDLE,
    pszBlobType: ?[*:0]const u16,
    phKey: ?*BCRYPT_KEY_HANDLE,
    pbKeyObject: ?*u8,
    cbKeyObject: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptImportKeyPair(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    hImportKey: BCRYPT_KEY_HANDLE,
    pszBlobType: ?[*:0]const u16,
    phKey: ?*BCRYPT_KEY_HANDLE,
    // TODO: what to do with BytesParamIndex 5?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDuplicateKey(
    hKey: BCRYPT_KEY_HANDLE,
    phNewKey: ?*BCRYPT_KEY_HANDLE,
    pbKeyObject: ?*u8,
    cbKeyObject: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFinalizeKeyPair(
    hKey: BCRYPT_KEY_HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroyKey(
    hKey: BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroySecret(
    hSecret: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSignHash(
    hKey: BCRYPT_KEY_HANDLE,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: ?*u8,
    cbInput: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptVerifySignature(
    hKey: BCRYPT_KEY_HANDLE,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pbHash: ?*u8,
    cbHash: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    cbSignature: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSecretAgreement(
    hPrivKey: BCRYPT_KEY_HANDLE,
    hPubKey: BCRYPT_KEY_HANDLE,
    phAgreedSecret: ?*?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDeriveKey(
    hSharedSecret: ?*anyopaque,
    pwszKDF: ?[*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 4?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "bcrypt" fn BCryptKeyDerivation(
    hKey: BCRYPT_KEY_HANDLE,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 3?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCreateHash(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    phHash: ?*?*anyopaque,
    pbHashObject: ?*u8,
    cbHashObject: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSecret: ?*u8,
    cbSecret: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptHashData(
    hHash: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptFinishHash(
    hHash: ?*anyopaque,
    pbOutput: ?*u8,
    cbOutput: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.1'
pub extern "bcrypt" fn BCryptCreateMultiHash(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    phHash: ?*?*anyopaque,
    nHashes: u32,
    pbHashObject: ?*u8,
    cbHashObject: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbSecret: ?*u8,
    cbSecret: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.1'
pub extern "bcrypt" fn BCryptProcessMultiOperations(
    hObject: ?*anyopaque,
    operationType: BCRYPT_MULTI_OPERATION_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    pOperations: ?*anyopaque,
    cbOperations: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDuplicateHash(
    hHash: ?*anyopaque,
    phNewHash: ?*?*anyopaque,
    pbHashObject: ?*u8,
    cbHashObject: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDestroyHash(
    hHash: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "bcrypt" fn BCryptHash(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbSecret: ?*u8,
    cbSecret: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbInput: ?*u8,
    cbInput: u32,
    pbOutput: ?*u8,
    cbOutput: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGenRandom(
    hAlgorithm: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbBuffer: ?*u8,
    cbBuffer: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "bcrypt" fn BCryptDeriveKeyCapi(
    hHash: ?*anyopaque,
    hTargetAlg: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 3?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.1'
pub extern "bcrypt" fn BCryptDeriveKeyPBKDF2(
    hPrf: BCRYPT_ALG_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbPassword: ?*u8,
    cbPassword: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbSalt: ?*u8,
    cbSalt: u32,
    cIterations: u64,
    // TODO: what to do with BytesParamIndex 7?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryProviderRegistration(
    pszProvider: ?[*:0]const u16,
    dwMode: BCRYPT_QUERY_PROVIDER_MODE,
    dwInterface: BCRYPT_INTERFACE,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppBuffer: ?*?*CRYPT_PROVIDER_REG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumRegisteredProviders(
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    ppBuffer: ?*?*CRYPT_PROVIDERS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptCreateContext(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    pConfig: ?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptDeleteContext(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContexts(
    dwTable: BCRYPT_TABLE,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    ppBuffer: ?*?*CRYPT_CONTEXTS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptConfigureContext(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    pConfig: ?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextConfiguration(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    ppBuffer: ?*?*CRYPT_CONTEXT_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptAddContextFunction(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    dwPosition: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptRemoveContextFunction(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContextFunctions(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppBuffer: ?*?*CRYPT_CONTEXT_FUNCTIONS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptConfigureContextFunction(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pConfig: ?*CRYPT_CONTEXT_FUNCTION_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextFunctionConfiguration(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppBuffer: ?*?*CRYPT_CONTEXT_FUNCTION_CONFIG,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptEnumContextFunctionProviders(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppBuffer: ?*?*CRYPT_CONTEXT_FUNCTION_PROVIDERS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptSetContextFunctionProperty(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pszProperty: ?[*:0]const u16,
    cbValue: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbValue: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptQueryContextFunctionProperty(
    dwTable: BCRYPT_TABLE,
    pszContext: ?[*:0]const u16,
    dwInterface: BCRYPT_INTERFACE,
    pszFunction: ?[*:0]const u16,
    pszProperty: ?[*:0]const u16,
    pcbValue: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    ppbValue: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptRegisterConfigChangeNotify(
    phEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptUnregisterConfigChangeNotify(
    hEvent: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptResolveProviders(
    pszContext: ?[*:0]const u16,
    dwInterface: u32,
    pszFunction: ?[*:0]const u16,
    pszProvider: ?[*:0]const u16,
    dwMode: BCRYPT_QUERY_PROVIDER_MODE,
    dwFlags: BCRYPT_RESOLVE_PROVIDERS_FLAGS,
    pcbBuffer: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    ppBuffer: ?*?*CRYPT_PROVIDER_REFS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "bcrypt" fn BCryptGetFipsAlgorithmMode(
    pfEnabled: ?*u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptOpenStorageProvider(
    phProvider: ?*usize,
    pszProviderName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumAlgorithms(
    hProvider: usize,
    dwAlgOperations: NCRYPT_OPERATION,
    pdwAlgCount: ?*u32,
    ppAlgList: ?*?*NCryptAlgorithmName,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptIsAlgSupported(
    hProvider: usize,
    pszAlgId: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumKeys(
    hProvider: usize,
    pszScope: ?[*:0]const u16,
    ppKeyName: ?*?*NCryptKeyName,
    ppEnumState: ?*?*anyopaque,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEnumStorageProviders(
    pdwProviderCount: ?*u32,
    ppProviderList: ?*?*NCryptProviderName,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFreeBuffer(
    pvInput: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
// This function from dll 'ncrypt' is being skipped because it has some sort of issue
pub fn NCryptOpenKey() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptCreatePersistedKey(
    hProvider: usize,
    phKey: ?*usize,
    pszAlgId: ?[*:0]const u16,
    pszKeyName: ?[*:0]const u16,
    dwLegacyKeySpec: CERT_KEY_SPEC,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptGetProperty(
    hObject: usize,
    pszProperty: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: OBJECT_SECURITY_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSetProperty(
    hObject: usize,
    pszProperty: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pbInput: ?*u8,
    cbInput: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFinalizeKey(
    hKey: usize,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptEncrypt(
    hKey: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDecrypt(
    hKey: usize,
    // TODO: what to do with BytesParamIndex 2?
    pbInput: ?*u8,
    cbInput: u32,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptImportKey(
    hProvider: usize,
    hImportKey: usize,
    pszBlobType: ?[*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    phKey: ?*usize,
    // TODO: what to do with BytesParamIndex 6?
    pbData: ?*u8,
    cbData: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptExportKey(
    hKey: usize,
    hExportKey: usize,
    pszBlobType: ?[*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pbOutput: ?*u8,
    cbOutput: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSignHash(
    hKey: usize,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pbHashValue: ?*u8,
    cbHashValue: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    cbSignature: u32,
    pcbResult: ?*u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptVerifySignature(
    hKey: usize,
    pPaddingInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    pbHashValue: ?*u8,
    cbHashValue: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignature: ?*u8,
    cbSignature: u32,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDeleteKey(
    hKey: usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptFreeObject(
    hObject: usize,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptIsKeyHandle(
    hKey: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
// This function from dll 'ncrypt' is being skipped because it has some sort of issue
pub fn NCryptTranslateHandle() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptNotifyChangeKey(
    hProvider: usize,
    phEvent: ?*?HANDLE,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptSecretAgreement(
    hPrivKey: usize,
    hPubKey: usize,
    phAgreedSecret: ?*usize,
    dwFlags: NCRYPT_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ncrypt" fn NCryptDeriveKey(
    hSharedSecret: usize,
    pwszKDF: ?[*:0]const u16,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 4?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptKeyDerivation(
    hKey: usize,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 3?
    pbDerivedKey: ?*u8,
    cbDerivedKey: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ncrypt" fn NCryptCreateClaim(
    hSubjectKey: usize,
    hAuthorityKey: usize,
    dwClaimType: u32,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pbClaimBlob: ?*u8,
    cbClaimBlob: u32,
    pcbResult: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "ncrypt" fn NCryptVerifyClaim(
    hSubjectKey: usize,
    hAuthorityKey: usize,
    dwClaimType: u32,
    pParameterList: ?*BCryptBufferDesc,
    // TODO: what to do with BytesParamIndex 5?
    pbClaimBlob: ?*u8,
    cbClaimBlob: u32,
    pOutput: ?*BCryptBufferDesc,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFormatObject(
    dwCertEncodingType: u32,
    dwFormatType: u32,
    dwFormatStrType: u32,
    pFormatStruct: ?*anyopaque,
    lpszStructType: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 6?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 8?
    pbFormat: ?*anyopaque,
    pcbFormat: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEncodeObjectEx(
    dwCertEncodingType: CERT_QUERY_ENCODING_TYPE,
    lpszStructType: ?[*:0]const u8,
    pvStructInfo: ?*const anyopaque,
    dwFlags: CRYPT_ENCODE_OBJECT_FLAGS,
    pEncodePara: ?*CRYPT_ENCODE_PARA,
    pvEncoded: ?*anyopaque,
    pcbEncoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEncodeObject(
    dwCertEncodingType: u32,
    lpszStructType: ?[*:0]const u8,
    pvStructInfo: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 4?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecodeObjectEx(
    dwCertEncodingType: u32,
    lpszStructType: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    dwFlags: u32,
    pDecodePara: ?*CRYPT_DECODE_PARA,
    pvStructInfo: ?*anyopaque,
    pcbStructInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecodeObject(
    dwCertEncodingType: u32,
    lpszStructType: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pvStructInfo: ?*anyopaque,
    pcbStructInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptInstallOIDFunctionAddress(
    hModule: ?HINSTANCE,
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    cFuncEntry: u32,
    rgFuncEntry: [*]const CRYPT_OID_FUNC_ENTRY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptInitOIDFunctionSet(
    pszFuncName: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetOIDFunctionAddress(
    hFuncSet: ?*anyopaque,
    dwEncodingType: u32,
    pszOID: ?[*:0]const u8,
    dwFlags: u32,
    ppvFuncAddr: ?*?*anyopaque,
    phFuncAddr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetDefaultOIDDllList(
    hFuncSet: ?*anyopaque,
    dwEncodingType: u32,
    pwszDllList: ?[*:0]u16,
    pcchDllList: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetDefaultOIDFunctionAddress(
    hFuncSet: ?*anyopaque,
    dwEncodingType: u32,
    pwszDll: ?[*:0]const u16,
    dwFlags: u32,
    ppvFuncAddr: ?*?*anyopaque,
    phFuncAddr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFreeOIDFunctionAddress(
    hFuncAddr: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptRegisterOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    pwszDll: ?[*:0]const u16,
    pszOverrideFuncName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUnregisterOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptRegisterDefaultOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    dwIndex: u32,
    pwszDll: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUnregisterDefaultOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pwszDll: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSetOIDFunctionValue(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    pwszValueName: ?[*:0]const u16,
    dwValueType: REG_VALUE_TYPE,
    // TODO: what to do with BytesParamIndex 6?
    pbValueData: ?*const u8,
    cbValueData: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetOIDFunctionValue(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    pwszValueName: ?[*:0]const u16,
    pdwValueType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pbValueData: ?*u8,
    pcbValueData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEnumOIDFunction(
    dwEncodingType: u32,
    pszFuncName: ?[*:0]const u8,
    pszOID: ?[*:0]const u8,
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnumOIDFunc: ?PFN_CRYPT_ENUM_OID_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFindOIDInfo(
    dwKeyType: u32,
    pvKey: ?*anyopaque,
    dwGroupId: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_OID_INFO;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptRegisterOIDInfo(
    pInfo: ?*CRYPT_OID_INFO,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUnregisterOIDInfo(
    pInfo: ?*CRYPT_OID_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEnumOIDInfo(
    dwGroupId: u32,
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnumOIDInfo: ?PFN_CRYPT_ENUM_OID_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFindLocalizedName(
    pwszCryptName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgOpenToEncode(
    dwMsgEncodingType: u32,
    dwFlags: u32,
    dwMsgType: CRYPT_MSG_TYPE,
    pvMsgEncodeInfo: ?*const anyopaque,
    pszInnerContentObjID: ?PSTR,
    pStreamInfo: ?*CMSG_STREAM_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgCalculateEncodedLength(
    dwMsgEncodingType: u32,
    dwFlags: u32,
    dwMsgType: u32,
    pvMsgEncodeInfo: ?*const anyopaque,
    pszInnerContentObjID: ?PSTR,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgOpenToDecode(
    dwMsgEncodingType: u32,
    dwFlags: u32,
    dwMsgType: u32,
    hCryptProv: usize,
    pRecipientInfo: ?*CERT_INFO,
    pStreamInfo: ?*CMSG_STREAM_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgDuplicate(
    hCryptMsg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgClose(
    hCryptMsg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgUpdate(
    hCryptMsg: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: u32,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgGetParam(
    hCryptMsg: ?*anyopaque,
    dwParamType: u32,
    dwIndex: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgControl(
    hCryptMsg: ?*anyopaque,
    dwFlags: u32,
    dwCtrlType: u32,
    pvCtrlPara: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgVerifyCountersignatureEncoded(
    hCryptProv: usize,
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbSignerInfo: ?*u8,
    cbSignerInfo: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignerInfoCountersignature: ?*u8,
    cbSignerInfoCountersignature: u32,
    pciCountersigner: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgVerifyCountersignatureEncodedEx(
    hCryptProv: usize,
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbSignerInfo: ?*u8,
    cbSignerInfo: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbSignerInfoCountersignature: ?*u8,
    cbSignerInfoCountersignature: u32,
    dwSignerType: u32,
    pvSigner: ?*anyopaque,
    dwFlags: u32,
    pvExtra: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgCountersign(
    hCryptMsg: ?*anyopaque,
    dwIndex: u32,
    cCountersigners: u32,
    rgCountersigners: [*]CMSG_SIGNER_ENCODE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgCountersignEncoded(
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbSignerInfo: ?*u8,
    cbSignerInfo: u32,
    cCountersigners: u32,
    rgCountersigners: [*]CMSG_SIGNER_ENCODE_INFO,
    // TODO: what to do with BytesParamIndex 6?
    pbCountersignature: ?*u8,
    pcbCountersignature: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertOpenStore(
    lpszStoreProvider: ?[*:0]const u8,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    hCryptProv: usize,
    dwFlags: CERT_OPEN_STORE_FLAGS,
    pvPara: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateStore(
    hCertStore: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSaveStore(
    hCertStore: ?*anyopaque,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    dwSaveAs: CERT_STORE_SAVE_AS,
    dwSaveTo: CERT_STORE_SAVE_TO,
    pvSaveToPara: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCloseStore(
    hCertStore: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetSubjectCertificateFromStore(
    hCertStore: ?*anyopaque,
    dwCertEncodingType: u32,
    pCertId: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCertificatesInStore(
    hCertStore: ?*anyopaque,
    pPrevCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindCertificateInStore(
    hCertStore: ?*anyopaque,
    dwCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: CERT_FIND_FLAGS,
    pvFindPara: ?*const anyopaque,
    pPrevCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetIssuerCertificateFromStore(
    hCertStore: ?*anyopaque,
    pSubjectContext: ?*const CERT_CONTEXT,
    pPrevIssuerContext: ?*const CERT_CONTEXT,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifySubjectCertificateContext(
    pSubject: ?*const CERT_CONTEXT,
    pIssuer: ?*const CERT_CONTEXT,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateCertificateContext(
    pCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCertificateContext(
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCertEncoded: ?*const u8,
    cbCertEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCertificateContext(
    pCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetCertificateContextProperty(
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCertificateContextProperty(
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCertificateContextProperties(
    pCertContext: ?*const CERT_CONTEXT,
    dwPropId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCTLEntryFromCertificateContextProperties(
    pCertContext: ?*const CERT_CONTEXT,
    cOptAttr: u32,
    rgOptAttr: ?[*]CRYPT_ATTRIBUTE,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pCtlEntry: ?*CTL_ENTRY,
    pcbCtlEntry: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetCertificateContextPropertiesFromCTLEntry(
    pCertContext: ?*const CERT_CONTEXT,
    pCtlEntry: ?*CTL_ENTRY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCRLFromStore(
    hCertStore: ?*anyopaque,
    pIssuerContext: ?*const CERT_CONTEXT,
    pPrevCrlContext: ?*CRL_CONTEXT,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCRLsInStore(
    hCertStore: ?*anyopaque,
    pPrevCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindCRLInStore(
    hCertStore: ?*anyopaque,
    dwCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: u32,
    pvFindPara: ?*const anyopaque,
    pPrevCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateCRLContext(
    pCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCRLContext(
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCrlEncoded: ?*const u8,
    cbCrlEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCRLContext(
    pCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetCRLContextProperty(
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCRLContextProperty(
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCRLContextProperties(
    pCrlContext: ?*CRL_CONTEXT,
    dwPropId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindCertificateInCRL(
    pCert: ?*const CERT_CONTEXT,
    pCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    ppCrlEntry: ?*?*CRL_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertIsValidCRLForCertificate(
    pCert: ?*const CERT_CONTEXT,
    pCrl: ?*CRL_CONTEXT,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCertificateToStore(
    hCertStore: ?*anyopaque,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbCertEncoded: ?*const u8,
    cbCertEncoded: u32,
    dwAddDisposition: u32,
    ppCertContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCertificateContextToStore(
    hCertStore: ?*anyopaque,
    pCertContext: ?*const CERT_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddSerializedElementToStore(
    hCertStore: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbElement: ?*const u8,
    cbElement: u32,
    dwAddDisposition: u32,
    dwFlags: u32,
    dwContextTypeFlags: u32,
    pdwContextType: ?*u32,
    ppvContext: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDeleteCertificateFromStore(
    pCertContext: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCRLToStore(
    hCertStore: ?*anyopaque,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbCrlEncoded: ?*const u8,
    cbCrlEncoded: u32,
    dwAddDisposition: u32,
    ppCrlContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCRLContextToStore(
    hCertStore: ?*anyopaque,
    pCrlContext: ?*CRL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDeleteCRLFromStore(
    pCrlContext: ?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSerializeCertificateStoreElement(
    pCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbElement: ?*u8,
    pcbElement: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSerializeCRLStoreElement(
    pCrlContext: ?*CRL_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbElement: ?*u8,
    pcbElement: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateCTLContext(
    pCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCTLContext(
    dwMsgAndCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCtlEncoded: ?*const u8,
    cbCtlEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCTLContext(
    pCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetCTLContextProperty(
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCTLContextProperty(
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCTLContextProperties(
    pCtlContext: ?*CTL_CONTEXT,
    dwPropId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumCTLsInStore(
    hCertStore: ?*anyopaque,
    pPrevCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindSubjectInCTL(
    dwEncodingType: u32,
    dwSubjectType: u32,
    pvSubject: ?*anyopaque,
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_ENTRY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindCTLInStore(
    hCertStore: ?*anyopaque,
    dwMsgAndCertEncodingType: u32,
    dwFindFlags: u32,
    dwFindType: CERT_FIND_TYPE,
    pvFindPara: ?*const anyopaque,
    pPrevCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CTL_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCTLToStore(
    hCertStore: ?*anyopaque,
    dwMsgAndCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbCtlEncoded: ?*const u8,
    cbCtlEncoded: u32,
    dwAddDisposition: u32,
    ppCtlContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCTLContextToStore(
    hCertStore: ?*anyopaque,
    pCtlContext: ?*CTL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSerializeCTLStoreElement(
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbElement: ?*u8,
    pcbElement: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDeleteCTLFromStore(
    pCtlContext: ?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCertificateLinkToStore(
    hCertStore: ?*anyopaque,
    pCertContext: ?*const CERT_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCRLLinkToStore(
    hCertStore: ?*anyopaque,
    pCrlContext: ?*CRL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CRL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddCTLLinkToStore(
    hCertStore: ?*anyopaque,
    pCtlContext: ?*CTL_CONTEXT,
    dwAddDisposition: u32,
    ppStoreContext: ?*?*CTL_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddStoreToCollection(
    hCollectionStore: ?*anyopaque,
    hSiblingStore: ?*anyopaque,
    dwUpdateFlags: u32,
    dwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRemoveStoreFromCollection(
    hCollectionStore: ?*anyopaque,
    hSiblingStore: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertControlStore(
    hCertStore: ?*anyopaque,
    dwFlags: CERT_CONTROL_STORE_FLAGS,
    dwCtrlType: u32,
    pvCtrlPara: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetStoreProperty(
    hCertStore: ?*anyopaque,
    dwPropId: u32,
    dwFlags: u32,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetStoreProperty(
    hCertStore: ?*anyopaque,
    dwPropId: u32,
    // TODO: what to do with BytesParamIndex 3?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateContext(
    dwContextType: u32,
    dwEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    dwFlags: u32,
    pCreatePara: ?*CERT_CREATE_CONTEXT_PARA,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRegisterSystemStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pStoreInfo: ?*CERT_SYSTEM_STORE_INFO,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRegisterPhysicalStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pwszStoreName: ?[*:0]const u16,
    pStoreInfo: ?*CERT_PHYSICAL_STORE_INFO,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertUnregisterSystemStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertUnregisterPhysicalStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pwszStoreName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumSystemStoreLocation(
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnum: ?PFN_CERT_ENUM_SYSTEM_STORE_LOCATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumSystemStore(
    dwFlags: u32,
    pvSystemStoreLocationPara: ?*anyopaque,
    pvArg: ?*anyopaque,
    pfnEnum: ?PFN_CERT_ENUM_SYSTEM_STORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumPhysicalStore(
    pvSystemStore: ?*const anyopaque,
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnum: ?PFN_CERT_ENUM_PHYSICAL_STORE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetEnhancedKeyUsage(
    pCertContext: ?*const CERT_CONTEXT,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pUsage: ?*CTL_USAGE,
    pcbUsage: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertSetEnhancedKeyUsage(
    pCertContext: ?*const CERT_CONTEXT,
    pUsage: ?*CTL_USAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEnhancedKeyUsageIdentifier(
    pCertContext: ?*const CERT_CONTEXT,
    pszUsageIdentifier: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRemoveEnhancedKeyUsageIdentifier(
    pCertContext: ?*const CERT_CONTEXT,
    pszUsageIdentifier: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetValidUsages(
    cCerts: u32,
    rghCerts: [*]?*CERT_CONTEXT,
    cNumOIDs: ?*i32,
    // TODO: what to do with BytesParamIndex 4?
    rghOIDs: ?*?PSTR,
    pcbOIDs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgGetAndVerifySigner(
    hCryptMsg: ?*anyopaque,
    cSignerStore: u32,
    rghSignerStore: ?[*]?*anyopaque,
    dwFlags: u32,
    ppSigner: ?*?*CERT_CONTEXT,
    pdwSignerIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgSignCTL(
    dwMsgEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbCtlContent: ?*u8,
    cbCtlContent: u32,
    pSignInfo: ?*CMSG_SIGNED_ENCODE_INFO,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMsgEncodeAndSignCTL(
    dwMsgEncodingType: u32,
    pCtlInfo: ?*CTL_INFO,
    pSignInfo: ?*CMSG_SIGNED_ENCODE_INFO,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindSubjectInSortedCTL(
    pSubjectIdentifier: ?*CRYPTOAPI_BLOB,
    pCtlContext: ?*CTL_CONTEXT,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    pEncodedAttributes: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertEnumSubjectInSortedCTL(
    pCtlContext: ?*CTL_CONTEXT,
    ppvNextSubject: ?*?*anyopaque,
    pSubjectIdentifier: ?*CRYPTOAPI_BLOB,
    pEncodedAttributes: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyCTLUsage(
    dwEncodingType: u32,
    dwSubjectType: u32,
    pvSubject: ?*anyopaque,
    pSubjectUsage: ?*CTL_USAGE,
    dwFlags: u32,
    pVerifyUsagePara: ?*CTL_VERIFY_USAGE_PARA,
    pVerifyUsageStatus: ?*CTL_VERIFY_USAGE_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyRevocation(
    dwEncodingType: u32,
    dwRevType: u32,
    cContext: u32,
    rgpvContext: [*]?*anyopaque,
    dwFlags: u32,
    pRevPara: ?*CERT_REVOCATION_PARA,
    pRevStatus: ?*CERT_REVOCATION_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCompareIntegerBlob(
    pInt1: ?*CRYPTOAPI_BLOB,
    pInt2: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCompareCertificate(
    dwCertEncodingType: u32,
    pCertId1: ?*CERT_INFO,
    pCertId2: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCompareCertificateName(
    dwCertEncodingType: u32,
    pCertName1: ?*CRYPTOAPI_BLOB,
    pCertName2: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertIsRDNAttrsInCertificateName(
    dwCertEncodingType: u32,
    dwFlags: u32,
    pCertName: ?*CRYPTOAPI_BLOB,
    pRDN: ?*CERT_RDN,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertComparePublicKeyInfo(
    dwCertEncodingType: u32,
    pPublicKey1: ?*CERT_PUBLIC_KEY_INFO,
    pPublicKey2: ?*CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetPublicKeyLength(
    dwCertEncodingType: u32,
    pPublicKey: ?*CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyCertificateSignature(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    pPublicKey: ?*CERT_PUBLIC_KEY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyCertificateSignatureEx(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    dwSubjectType: u32,
    pvSubject: ?*anyopaque,
    dwIssuerType: u32,
    pvIssuer: ?*anyopaque,
    dwFlags: CRYPT_VERIFY_CERT_FLAGS,
    pvExtra: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "CRYPT32" fn CertIsStrongHashToSign(
    pStrongSignPara: ?*CERT_STRONG_SIGN_PARA,
    pwszCNGHashAlgid: ?[*:0]const u16,
    pSigningCert: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptHashToBeSigned(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptHashCertificate(
    hCryptProv: usize,
    Algid: u32,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptHashCertificate2(
    pwszCNGHashAlgid: ?[*:0]const u16,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 4?
    pbEncoded: ?*const u8,
    cbEncoded: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSignCertificate(
    hCryptProvOrNCryptKey: usize,
    dwKeySpec: u32,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncodedToBeSigned: ?*const u8,
    cbEncodedToBeSigned: u32,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 8?
    pbSignature: ?*u8,
    pcbSignature: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
// This function from dll 'CRYPT32' is being skipped because it has some sort of issue
pub fn CryptSignAndEncodeCertificate() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyTimeValidity(
    pTimeToVerify: ?*FILETIME,
    pCertInfo: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyCRLTimeValidity(
    pTimeToVerify: ?*FILETIME,
    pCrlInfo: ?*CRL_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyValidityNesting(
    pSubjectInfo: ?*CERT_INFO,
    pIssuerInfo: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyCRLRevocation(
    dwCertEncodingType: u32,
    pCertId: ?*CERT_INFO,
    cCrlInfo: u32,
    rgpCrlInfo: [*]?*CRL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAlgIdToOID(
    dwAlgId: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertOIDToAlgId(
    pszObjId: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindExtension(
    pszObjId: ?[*:0]const u8,
    cExtensions: u32,
    rgExtensions: [*]CERT_EXTENSION,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_EXTENSION;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindAttribute(
    pszObjId: ?[*:0]const u8,
    cAttr: u32,
    rgAttr: [*]CRYPT_ATTRIBUTE,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_ATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindRDNAttr(
    pszObjId: ?[*:0]const u8,
    pName: ?*CERT_NAME_INFO,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_RDN_ATTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetIntendedKeyUsage(
    dwCertEncodingType: u32,
    pCertInfo: ?*CERT_INFO,
    pbKeyUsage: ?*u8,
    cbKeyUsage: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptInstallDefaultContext(
    hCryptProv: usize,
    dwDefaultType: CRYPT_DEFAULT_CONTEXT_TYPE,
    pvDefaultPara: ?*const anyopaque,
    dwFlags: CRYPT_DEFAULT_CONTEXT_FLAGS,
    pvReserved: ?*anyopaque,
    phDefaultContext: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUninstallDefaultContext(
    hDefaultContext: ?*anyopaque,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptExportPublicKeyInfo(
    hCryptProvOrNCryptKey: usize,
    dwKeySpec: u32,
    dwCertEncodingType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptExportPublicKeyInfoEx(
    hCryptProvOrNCryptKey: usize,
    dwKeySpec: u32,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 7?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CryptExportPublicKeyInfoFromBCryptKeyHandle(
    hBCryptKey: BCRYPT_KEY_HANDLE,
    dwCertEncodingType: u32,
    pszPublicKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    pcbInfo: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptImportPublicKeyInfo(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptImportPublicKeyInfoEx(
    hCryptProv: usize,
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    aiKeyAlg: u32,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    phKey: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptImportPublicKeyInfoEx2(
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    dwFlags: CRYPT_IMPORT_PUBLIC_KEY_FLAGS,
    pvAuxInfo: ?*anyopaque,
    phKey: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptAcquireCertificatePrivateKey(
    pCert: ?*const CERT_CONTEXT,
    dwFlags: CRYPT_ACQUIRE_FLAGS,
    pvParameters: ?*anyopaque,
    phCryptProvOrNCryptKey: ?*usize,
    pdwKeySpec: ?*CERT_KEY_SPEC,
    pfCallerFreeProvOrNCryptKey: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptFindCertificateKeyProvInfo(
    pCert: ?*const CERT_CONTEXT,
    dwFlags: CRYPT_FIND_FLAGS,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptImportPKCS8(
    sPrivateKeyAndParams: CRYPT_PKCS8_IMPORT_PARAMS,
    dwFlags: CRYPT_KEY_FLAGS,
    phCryptProv: ?*usize,
    pvAuxInfo: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptExportPKCS8(
    hCryptProv: usize,
    dwKeySpec: u32,
    pszPrivateKeyObjId: ?PSTR,
    dwFlags: u32,
    pvAuxInfo: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pbPrivateKeyBlob: ?*u8,
    pcbPrivateKeyBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptHashPublicKeyInfo(
    hCryptProv: usize,
    Algid: u32,
    dwFlags: u32,
    dwCertEncodingType: u32,
    pInfo: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRDNValueToStrA(
    dwValueType: u32,
    pValue: ?*CRYPTOAPI_BLOB,
    psz: ?[*:0]u8,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertRDNValueToStrW(
    dwValueType: u32,
    pValue: ?*CRYPTOAPI_BLOB,
    psz: ?[*:0]u16,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertNameToStrA(
    dwCertEncodingType: u32,
    pName: ?*CRYPTOAPI_BLOB,
    dwStrType: CERT_STRING_TYPE,
    psz: ?[*:0]u8,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertNameToStrW(
    dwCertEncodingType: u32,
    pName: ?*CRYPTOAPI_BLOB,
    dwStrType: CERT_STRING_TYPE,
    psz: ?[*:0]u16,
    csz: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertStrToNameA(
    dwCertEncodingType: u32,
    pszX500: ?[*:0]const u8,
    dwStrType: CERT_STRING_TYPE,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
    ppszError: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertStrToNameW(
    dwCertEncodingType: u32,
    pszX500: ?[*:0]const u16,
    dwStrType: CERT_STRING_TYPE,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 5?
    pbEncoded: ?*u8,
    pcbEncoded: ?*u32,
    ppszError: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetNameStringA(
    pCertContext: ?*const CERT_CONTEXT,
    dwType: u32,
    dwFlags: u32,
    pvTypePara: ?*anyopaque,
    pszNameString: ?[*:0]u8,
    cchNameString: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetNameStringW(
    pCertContext: ?*const CERT_CONTEXT,
    dwType: u32,
    dwFlags: u32,
    pvTypePara: ?*anyopaque,
    pszNameString: ?[*:0]u16,
    cchNameString: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSignMessage(
    pSignPara: ?*CRYPT_SIGN_MESSAGE_PARA,
    fDetachedSignature: BOOL,
    cToBeSigned: u32,
    rgpbToBeSigned: ?[*]const ?*const u8,
    rgcbToBeSigned: [*]u32,
    // TODO: what to do with BytesParamIndex 6?
    pbSignedBlob: ?*u8,
    pcbSignedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyMessageSignature(
    pVerifyPara: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbSignedBlob: ?*const u8,
    cbSignedBlob: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbDecoded: ?*u8,
    pcbDecoded: ?*u32,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetMessageSignerCount(
    dwMsgEncodingType: u32,
    // TODO: what to do with BytesParamIndex 2?
    pbSignedBlob: ?*const u8,
    cbSignedBlob: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetMessageCertificates(
    dwMsgAndCertEncodingType: u32,
    hCryptProv: usize,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbSignedBlob: ?*const u8,
    cbSignedBlob: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyDetachedMessageSignature(
    pVerifyPara: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbDetachedSignBlob: ?*const u8,
    cbDetachedSignBlob: u32,
    cToBeSigned: u32,
    rgpbToBeSigned: [*]const ?*const u8,
    rgcbToBeSigned: [*]u32,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEncryptMessage(
    pEncryptPara: ?*CRYPT_ENCRYPT_MESSAGE_PARA,
    cRecipientCert: u32,
    rgpRecipientCert: [*]?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pbToBeEncrypted: ?*const u8,
    cbToBeEncrypted: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbEncryptedBlob: ?*u8,
    pcbEncryptedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecryptMessage(
    pDecryptPara: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbEncryptedBlob: ?*const u8,
    cbEncryptedBlob: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbDecrypted: ?*u8,
    pcbDecrypted: ?*u32,
    ppXchgCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSignAndEncryptMessage(
    pSignPara: ?*CRYPT_SIGN_MESSAGE_PARA,
    pEncryptPara: ?*CRYPT_ENCRYPT_MESSAGE_PARA,
    cRecipientCert: u32,
    rgpRecipientCert: [*]?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 5?
    pbToBeSignedAndEncrypted: ?*const u8,
    cbToBeSignedAndEncrypted: u32,
    // TODO: what to do with BytesParamIndex 7?
    pbSignedAndEncryptedBlob: ?*u8,
    pcbSignedAndEncryptedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecryptAndVerifyMessageSignature(
    pDecryptPara: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    pVerifyPara: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncryptedBlob: ?*const u8,
    cbEncryptedBlob: u32,
    // TODO: what to do with BytesParamIndex 6?
    pbDecrypted: ?*u8,
    pcbDecrypted: ?*u32,
    ppXchgCert: ?*?*CERT_CONTEXT,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptDecodeMessage(
    dwMsgTypeFlags: u32,
    pDecryptPara: ?*CRYPT_DECRYPT_MESSAGE_PARA,
    pVerifyPara: ?*CRYPT_VERIFY_MESSAGE_PARA,
    dwSignerIndex: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbEncodedBlob: ?*const u8,
    cbEncodedBlob: u32,
    dwPrevInnerContentType: u32,
    pdwMsgType: ?*u32,
    pdwInnerContentType: ?*u32,
    // TODO: what to do with BytesParamIndex 10?
    pbDecoded: ?*u8,
    pcbDecoded: ?*u32,
    ppXchgCert: ?*?*CERT_CONTEXT,
    ppSignerCert: ?*?*CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptHashMessage(
    pHashPara: ?*CRYPT_HASH_MESSAGE_PARA,
    fDetachedHash: BOOL,
    cToBeHashed: u32,
    rgpbToBeHashed: [*]const ?*const u8,
    rgcbToBeHashed: [*]u32,
    // TODO: what to do with BytesParamIndex 6?
    pbHashedBlob: ?*u8,
    pcbHashedBlob: ?*u32,
    // TODO: what to do with BytesParamIndex 8?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyMessageHash(
    pHashPara: ?*CRYPT_HASH_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbHashedBlob: ?*u8,
    cbHashedBlob: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbToBeHashed: ?*u8,
    pcbToBeHashed: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyDetachedMessageHash(
    pHashPara: ?*CRYPT_HASH_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbDetachedHashBlob: ?*u8,
    cbDetachedHashBlob: u32,
    cToBeHashed: u32,
    rgpbToBeHashed: [*]const ?*const u8,
    rgcbToBeHashed: [*]u32,
    // TODO: what to do with BytesParamIndex 7?
    pbComputedHash: ?*u8,
    pcbComputedHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSignMessageWithKey(
    pSignPara: ?*CRYPT_KEY_SIGN_MESSAGE_PARA,
    // TODO: what to do with BytesParamIndex 2?
    pbToBeSigned: ?*const u8,
    cbToBeSigned: u32,
    // TODO: what to do with BytesParamIndex 4?
    pbSignedBlob: ?*u8,
    pcbSignedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptVerifyMessageSignatureWithKey(
    pVerifyPara: ?*CRYPT_KEY_VERIFY_MESSAGE_PARA,
    pPublicKeyInfo: ?*CERT_PUBLIC_KEY_INFO,
    // TODO: what to do with BytesParamIndex 3?
    pbSignedBlob: ?*const u8,
    cbSignedBlob: u32,
    // TODO: what to do with BytesParamIndex 5?
    pbDecoded: ?*u8,
    pcbDecoded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertOpenSystemStoreA(
    hProv: usize,
    szSubsystemProtocol: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertOpenSystemStoreW(
    hProv: usize,
    szSubsystemProtocol: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCertificateToSystemStoreA(
    szCertStoreName: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    pbCertEncoded: ?*const u8,
    cbCertEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertAddEncodedCertificateToSystemStoreW(
    szCertStoreName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    pbCertEncoded: ?*const u8,
    cbCertEncoded: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINTRUST" fn FindCertsByIssuer(
    // TODO: what to do with BytesParamIndex 1?
    pCertChains: ?*CERT_CHAIN,
    pcbCertChains: ?*u32,
    pcCertChains: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pbEncodedIssuerName: ?*u8,
    cbEncodedIssuerName: u32,
    pwszPurpose: ?[*:0]const u16,
    dwKeySpec: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptQueryObject(
    dwObjectType: CERT_QUERY_OBJECT_TYPE,
    pvObject: ?*const anyopaque,
    dwExpectedContentTypeFlags: CERT_QUERY_CONTENT_TYPE_FLAGS,
    dwExpectedFormatTypeFlags: CERT_QUERY_FORMAT_TYPE_FLAGS,
    dwFlags: u32,
    pdwMsgAndCertEncodingType: ?*CERT_QUERY_ENCODING_TYPE,
    pdwContentType: ?*CERT_QUERY_CONTENT_TYPE,
    pdwFormatType: ?*CERT_QUERY_FORMAT_TYPE,
    phCertStore: ?*?*anyopaque,
    phMsg: ?*?*anyopaque,
    ppvContext: ?*const ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMemAlloc(
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMemRealloc(
    pv: ?*anyopaque,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptMemFree(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "CRYPT32" fn CryptCreateAsyncHandle(
    dwFlags: u32,
    phAsync: ?*?HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPT32" fn CryptSetAsyncParam(
    hAsync: ?HCRYPTASYNC,
    pszParamOid: ?PSTR,
    pvParam: ?*anyopaque,
    pfnFree: ?PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPT32" fn CryptGetAsyncParam(
    hAsync: ?HCRYPTASYNC,
    pszParamOid: ?PSTR,
    ppvParam: ?*?*anyopaque,
    ppfnFree: ?*?PFN_CRYPT_ASYNC_PARAM_FREE_FUNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPT32" fn CryptCloseAsyncHandle(
    hAsync: ?HCRYPTASYNC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTNET" fn CryptRetrieveObjectByUrlA(
    pszUrl: ?[*:0]const u8,
    pszObjectOid: ?[*:0]const u8,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    ppvObject: ?*?*anyopaque,
    hAsyncRetrieve: ?HCRYPTASYNC,
    pCredentials: ?*CRYPT_CREDENTIALS,
    pvVerify: ?*anyopaque,
    pAuxInfo: ?*CRYPT_RETRIEVE_AUX_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTNET" fn CryptRetrieveObjectByUrlW(
    pszUrl: ?[*:0]const u16,
    pszObjectOid: ?[*:0]const u8,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    ppvObject: ?*?*anyopaque,
    hAsyncRetrieve: ?HCRYPTASYNC,
    pCredentials: ?*CRYPT_CREDENTIALS,
    pvVerify: ?*anyopaque,
    pAuxInfo: ?*CRYPT_RETRIEVE_AUX_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPTNET" fn CryptInstallCancelRetrieval(
    pfnCancel: ?PFN_CRYPT_CANCEL_RETRIEVAL,
    pvArg: ?*const anyopaque,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPTNET" fn CryptUninstallCancelRetrieval(
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPTNET" fn CryptGetObjectUrl(
    pszUrlOid: ?[*:0]const u8,
    pvPara: ?*anyopaque,
    dwFlags: CRYPT_GET_URL_FLAGS,
    // TODO: what to do with BytesParamIndex 4?
    pUrlArray: ?*CRYPT_URL_ARRAY,
    pcbUrlArray: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pUrlInfo: ?*CRYPT_URL_INFO,
    pcbUrlInfo: ?*u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateSelfSignCertificate(
    hCryptProvOrNCryptKey: usize,
    pSubjectIssuerBlob: ?*CRYPTOAPI_BLOB,
    dwFlags: CERT_CREATE_SELFSIGN_FLAGS,
    pKeyProvInfo: ?*CRYPT_KEY_PROV_INFO,
    pSignatureAlgorithm: ?*CRYPT_ALGORITHM_IDENTIFIER,
    pStartTime: ?*SYSTEMTIME,
    pEndTime: ?*SYSTEMTIME,
    pExtensions: ?*CERT_EXTENSIONS,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptGetKeyIdentifierProperty(
    pKeyIdentifier: ?*const CRYPTOAPI_BLOB,
    dwPropId: u32,
    dwFlags: u32,
    pwszComputerName: ?[*:0]const u16,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSetKeyIdentifierProperty(
    pKeyIdentifier: ?*const CRYPTOAPI_BLOB,
    dwPropId: u32,
    dwFlags: u32,
    pwszComputerName: ?[*:0]const u16,
    pvReserved: ?*anyopaque,
    pvData: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptEnumKeyIdentifierProperties(
    pKeyIdentifier: ?*const CRYPTOAPI_BLOB,
    dwPropId: u32,
    dwFlags: u32,
    pwszComputerName: ?[*:0]const u16,
    pvReserved: ?*anyopaque,
    pvArg: ?*anyopaque,
    pfnEnum: ?PFN_CRYPT_ENUM_KEYID_PROP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptCreateKeyIdentifierFromCSP(
    dwCertEncodingType: u32,
    pszPubKeyOID: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pPubKeyStruc: ?*const PUBLICKEYSTRUC,
    cbPubKeyStruc: u32,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 7?
    pbHash: ?*u8,
    pcbHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertCreateCertificateChainEngine(
    pConfig: ?*CERT_CHAIN_ENGINE_CONFIG,
    phChainEngine: ?*?HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCertificateChainEngine(
    hChainEngine: ?HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "CRYPT32" fn CertResyncCertificateChainEngine(
    hChainEngine: ?HCERTCHAINENGINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertGetCertificateChain(
    hChainEngine: ?HCERTCHAINENGINE,
    pCertContext: ?*const CERT_CONTEXT,
    pTime: ?*FILETIME,
    hAdditionalStore: ?*anyopaque,
    pChainPara: ?*CERT_CHAIN_PARA,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    ppChainContext: ?*?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFreeCertificateChain(
    pChainContext: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertDuplicateCertificateChain(
    pChainContext: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CHAIN_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertFindChainInStore(
    hCertStore: ?*anyopaque,
    dwCertEncodingType: u32,
    dwFindFlags: CERT_FIND_CHAIN_IN_STORE_FLAGS,
    dwFindType: u32,
    pvFindPara: ?*const anyopaque,
    pPrevChainContext: ?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_CHAIN_CONTEXT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CertVerifyCertificateChainPolicy(
    pszPolicyOID: ?[*:0]const u8,
    pChainContext: ?*CERT_CHAIN_CONTEXT,
    pPolicyPara: ?*CERT_CHAIN_POLICY_PARA,
    pPolicyStatus: ?*CERT_CHAIN_POLICY_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptStringToBinaryA(
    pszString: [*:0]const u8,
    cchString: u32,
    dwFlags: CRYPT_STRING,
    // TODO: what to do with BytesParamIndex 4?
    pbBinary: ?*u8,
    pcbBinary: ?*u32,
    pdwSkip: ?*u32,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptStringToBinaryW(
    pszString: [*:0]const u16,
    cchString: u32,
    dwFlags: CRYPT_STRING,
    // TODO: what to do with BytesParamIndex 4?
    pbBinary: ?*u8,
    pcbBinary: ?*u32,
    pdwSkip: ?*u32,
    pdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptBinaryToStringA(
    // TODO: what to do with BytesParamIndex 1?
    pbBinary: ?*const u8,
    cbBinary: u32,
    dwFlags: CRYPT_STRING,
    pszString: ?[*:0]u8,
    pcchString: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptBinaryToStringW(
    // TODO: what to do with BytesParamIndex 1?
    pbBinary: ?*const u8,
    cbBinary: u32,
    dwFlags: CRYPT_STRING,
    pszString: ?[*:0]u16,
    pcchString: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXImportCertStore(
    pPFX: ?*CRYPTOAPI_BLOB,
    szPassword: ?[*:0]const u16,
    dwFlags: CRYPT_KEY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXIsPFXBlob(
    pPFX: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXVerifyPassword(
    pPFX: ?*CRYPTOAPI_BLOB,
    szPassword: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXExportCertStoreEx(
    hStore: ?*anyopaque,
    pPFX: ?*CRYPTOAPI_BLOB,
    szPassword: ?[*:0]const u16,
    pvPara: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn PFXExportCertStore(
    hStore: ?*anyopaque,
    pPFX: ?*CRYPTOAPI_BLOB,
    szPassword: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertOpenServerOcspResponse(
    pChainContext: ?*CERT_CHAIN_CONTEXT,
    dwFlags: u32,
    pOpenPara: ?*CERT_SERVER_OCSP_RESPONSE_OPEN_PARA,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertAddRefServerOcspResponse(
    hServerOcspResponse: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertCloseServerOcspResponse(
    hServerOcspResponse: ?*anyopaque,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertGetServerOcspResponseContext(
    hServerOcspResponse: ?*anyopaque,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertAddRefServerOcspResponseContext(
    pServerOcspResponseContext: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertFreeServerOcspResponseContext(
    pServerOcspResponseContext: ?*CERT_SERVER_OCSP_RESPONSE_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CertRetrieveLogoOrBiometricInfo(
    pCertContext: ?*const CERT_CONTEXT,
    lpszLogoOrBiometricType: ?[*:0]const u8,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
    ppbData: ?*?*u8,
    pcbData: ?*u32,
    ppwszMimeType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CertSelectCertificateChains(
    pSelectionContext: ?*const Guid,
    dwFlags: u32,
    pChainParameters: ?*CERT_SELECT_CHAIN_PARA,
    cCriteria: u32,
    rgpCriteria: ?[*]CERT_SELECT_CRITERIA,
    hStore: ?*anyopaque,
    pcSelection: ?*u32,
    pprgpSelection: ?*?*?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CertFreeCertificateChainList(
    prgpSelection: ?*?*CERT_CHAIN_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CryptRetrieveTimeStamp(
    wszUrl: ?[*:0]const u16,
    dwRetrievalFlags: u32,
    dwTimeout: u32,
    pszHashId: ?[*:0]const u8,
    pPara: ?*const CRYPT_TIMESTAMP_PARA,
    // TODO: what to do with BytesParamIndex 6?
    pbData: ?*const u8,
    cbData: u32,
    ppTsContext: ?*?*CRYPT_TIMESTAMP_CONTEXT,
    ppTsSigner: ?*?*CERT_CONTEXT,
    phStore: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPT32" fn CryptVerifyTimeStampSignature(
    // TODO: what to do with BytesParamIndex 1?
    pbTSContentInfo: ?*const u8,
    cbTSContentInfo: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*const u8,
    cbData: u32,
    hAdditionalStore: ?*anyopaque,
    ppTsContext: ?*?*CRYPT_TIMESTAMP_CONTEXT,
    ppTsSigner: ?*?*CERT_CONTEXT,
    phStore: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "CRYPT32" fn CertIsWeakHash(
    dwHashUseType: u32,
    pwszCNGHashAlgid: ?[*:0]const u16,
    dwChainFlags: u32,
    pSignerChainContext: ?*CERT_CHAIN_CONTEXT,
    pTimeStamp: ?*FILETIME,
    pwszFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptProtectData(
    pDataIn: ?*CRYPTOAPI_BLOB,
    szDataDescr: ?[*:0]const u16,
    pOptionalEntropy: ?*CRYPTOAPI_BLOB,
    pvReserved: ?*anyopaque,
    pPromptStruct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dwFlags: u32,
    pDataOut: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUnprotectData(
    pDataIn: ?*CRYPTOAPI_BLOB,
    ppszDataDescr: ?*?PWSTR,
    pOptionalEntropy: ?*CRYPTOAPI_BLOB,
    pvReserved: ?*anyopaque,
    pPromptStruct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dwFlags: u32,
    pDataOut: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptUpdateProtectedState(
    pOldSid: ?PSID,
    pwszOldPassword: ?[*:0]const u16,
    dwFlags: u32,
    pdwSuccessCount: ?*u32,
    pdwFailureCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptProtectMemory(
    pDataIn: ?*anyopaque,
    cbDataIn: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptUnprotectMemory(
    pDataIn: ?*anyopaque,
    cbDataIn: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptRegisterProtectionDescriptorName(
    pwszName: ?[*:0]const u16,
    pwszDescriptorString: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptQueryProtectionDescriptorName(
    pwszName: ?[*:0]const u16,
    pwszDescriptorString: ?[*:0]u16,
    pcDescriptorString: ?*usize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptCreateProtectionDescriptor(
    pwszDescriptorString: ?[*:0]const u16,
    dwFlags: u32,
    phDescriptor: ?*NCRYPT_DESCRIPTOR_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptCloseProtectionDescriptor(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptGetProtectionDescriptorInfo(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    pMemPara: ?*const NCRYPT_ALLOC_PARA,
    dwInfoType: u32,
    ppvInfo: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptProtectSecret(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    dwFlags: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbData: ?*const u8,
    cbData: u32,
    pMemPara: ?*const NCRYPT_ALLOC_PARA,
    hWnd: ?HWND,
    ppbProtectedBlob: ?*?*u8,
    pcbProtectedBlob: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptUnprotectSecret(
    phDescriptor: ?*NCRYPT_DESCRIPTOR_HANDLE,
    dwFlags: NCRYPT_FLAGS,
    // TODO: what to do with BytesParamIndex 3?
    pbProtectedBlob: ?*const u8,
    cbProtectedBlob: u32,
    pMemPara: ?*const NCRYPT_ALLOC_PARA,
    hWnd: ?HWND,
    ppbData: ?*?*u8,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamOpenToProtect(
    hDescriptor: NCRYPT_DESCRIPTOR_HANDLE,
    dwFlags: u32,
    hWnd: ?HWND,
    pStreamInfo: ?*NCRYPT_PROTECT_STREAM_INFO,
    phStream: ?*NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamOpenToUnprotect(
    pStreamInfo: ?*NCRYPT_PROTECT_STREAM_INFO,
    dwFlags: u32,
    hWnd: ?HWND,
    phStream: ?*NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ncrypt" fn NCryptStreamOpenToUnprotectEx(
    pStreamInfo: ?*NCRYPT_PROTECT_STREAM_INFO_EX,
    dwFlags: u32,
    hWnd: ?HWND,
    phStream: ?*NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamUpdate(
    hStream: NCRYPT_STREAM_HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    pbData: ?*const u8,
    cbData: usize,
    fFinal: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ncrypt" fn NCryptStreamClose(
    hStream: NCRYPT_STREAM_HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlClose(
    hCryptXml: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetTransforms(
    ppConfig: ?*const ?*CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlOpenToEncode(
    pConfig: ?*const CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    dwFlags: CRYPT_XML_FLAGS,
    wszId: ?[*:0]const u16,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pEncoded: ?*const CRYPT_XML_BLOB,
    phSignature: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlOpenToDecode(
    pConfig: ?*const CRYPT_XML_TRANSFORM_CHAIN_CONFIG,
    dwFlags: CRYPT_XML_FLAGS,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pEncoded: ?*const CRYPT_XML_BLOB,
    phCryptXml: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlAddObject(
    hSignatureOrObject: ?*anyopaque,
    dwFlags: u32,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pEncoded: ?*const CRYPT_XML_BLOB,
    ppObject: ?*const ?*CRYPT_XML_OBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlCreateReference(
    hCryptXml: ?*anyopaque,
    dwFlags: u32,
    wszId: ?[*:0]const u16,
    wszURI: ?[*:0]const u16,
    wszType: ?[*:0]const u16,
    pDigestMethod: ?*const CRYPT_XML_ALGORITHM,
    cTransform: u32,
    rgTransform: ?[*]const CRYPT_XML_ALGORITHM,
    phReference: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlDigestReference(
    hReference: ?*anyopaque,
    dwFlags: u32,
    pDataProviderIn: ?*CRYPT_XML_DATA_PROVIDER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlSetHMACSecret(
    hSignature: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 2?
    pbSecret: ?*const u8,
    cbSecret: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlSign(
    hSignature: ?*anyopaque,
    hKey: usize,
    dwKeySpec: CERT_KEY_SPEC,
    dwFlags: CRYPT_XML_FLAGS,
    dwKeyInfoSpec: CRYPT_XML_KEYINFO_SPEC,
    pvKeyInfoSpec: ?*const anyopaque,
    pSignatureMethod: ?*const CRYPT_XML_ALGORITHM,
    pCanonicalization: ?*const CRYPT_XML_ALGORITHM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlImportPublicKey(
    dwFlags: CRYPT_XML_FLAGS,
    pKeyValue: ?*const CRYPT_XML_KEY_VALUE,
    phKey: ?*BCRYPT_KEY_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlVerifySignature(
    hSignature: ?*anyopaque,
    hKey: BCRYPT_KEY_HANDLE,
    dwFlags: CRYPT_XML_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetDocContext(
    hCryptXml: ?*anyopaque,
    ppStruct: ?*const ?*CRYPT_XML_DOC_CTXT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetSignature(
    hCryptXml: ?*anyopaque,
    ppStruct: ?*const ?*CRYPT_XML_SIGNATURE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetReference(
    hCryptXml: ?*anyopaque,
    ppStruct: ?*const ?*CRYPT_XML_REFERENCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetStatus(
    hCryptXml: ?*anyopaque,
    pStatus: ?*CRYPT_XML_STATUS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlEncode(
    hCryptXml: ?*anyopaque,
    dwCharset: CRYPT_XML_CHARSET,
    rgProperty: ?[*]const CRYPT_XML_PROPERTY,
    cProperty: u32,
    pvCallbackState: ?*anyopaque,
    pfnWrite: ?PFN_CRYPT_XML_WRITE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "CRYPTXML" fn CryptXmlGetAlgorithmInfo(
    pXmlAlgorithm: ?*const CRYPT_XML_ALGORITHM,
    dwFlags: CRYPT_XML_FLAGS,
    ppAlgInfo: ?*?*CRYPT_XML_ALGORITHM_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "CRYPTXML" fn CryptXmlFindAlgorithmInfo(
    dwFindByType: u32,
    pvFindBy: ?*const anyopaque,
    dwGroupId: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_XML_ALGORITHM_INFO;

pub extern "CRYPTXML" fn CryptXmlEnumAlgorithmInfo(
    dwGroupId: u32,
    dwFlags: u32,
    pvArg: ?*anyopaque,
    pfnEnumAlgInfo: ?PFN_CRYPT_XML_ENUM_ALG_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetToken(
    cPolicyChain: u32,
    pPolicyChain: [*]POLICY_ELEMENT,
    securityToken: ?*?*GENERIC_XML_TOKEN,
    phProofTokenCrypto: ?*?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn ManageCardSpace(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn ImportInformationCard(
    fileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn Encrypt(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    fOAEP: BOOL,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 2?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn Decrypt(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    fOAEP: BOOL,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 2?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn SignHash(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbHash: u32,
    // TODO: what to do with BytesParamIndex 1?
    pHash: ?*u8,
    hashAlgOid: ?[*:0]const u16,
    pcbSig: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    ppSig: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn VerifyHash(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbHash: u32,
    // TODO: what to do with BytesParamIndex 1?
    pHash: ?*u8,
    hashAlgOid: ?[*:0]const u16,
    cbSig: u32,
    // TODO: what to do with BytesParamIndex 4?
    pSig: ?*u8,
    pfVerified: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetCryptoTransform(
    hSymmetricCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    mode: u32,
    padding: PaddingMode,
    feedbackSize: u32,
    direction: Direction,
    cbIV: u32,
    // TODO: what to do with BytesParamIndex 5?
    pIV: ?*u8,
    pphTransform: ?*?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetKeyedHash(
    hSymmetricCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    pphHash: ?*?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn TransformBlock(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 1?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn TransformFinalBlock(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 1?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn HashCore(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 1?
    pInData: ?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn HashFinal(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbInData: u32,
    // TODO: what to do with BytesParamIndex 1?
    pInData: ?*u8,
    pcbOutData: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    ppOutData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn FreeToken(
    pAllocMemory: ?*GENERIC_XML_TOKEN,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "infocardapi" fn CloseCryptoHandle(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GenerateDerivedKey(
    hCrypto: ?*INFORMATIONCARD_CRYPTO_HANDLE,
    cbLabel: u32,
    // TODO: what to do with BytesParamIndex 1?
    pLabel: ?*u8,
    cbNonce: u32,
    // TODO: what to do with BytesParamIndex 3?
    pNonce: ?*u8,
    derivedKeyLength: u32,
    offset: u32,
    algId: ?[*:0]const u16,
    pcbKey: ?*u32,
    // TODO: what to do with BytesParamIndex 8?
    ppKey: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "infocardapi" fn GetBrowserToken(
    dwParamType: u32,
    pParam: ?*anyopaque,
    pcbToken: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    ppToken: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (18)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const CRYPT_PASSWORD_CREDENTIALS = thismodule.CRYPT_PASSWORD_CREDENTIALSA;
        pub const CryptAcquireContext = thismodule.CryptAcquireContextA;
        pub const CryptSignHash = thismodule.CryptSignHashA;
        pub const CryptVerifySignature = thismodule.CryptVerifySignatureA;
        pub const CryptSetProvider = thismodule.CryptSetProviderA;
        pub const CryptSetProviderEx = thismodule.CryptSetProviderExA;
        pub const CryptGetDefaultProvider = thismodule.CryptGetDefaultProviderA;
        pub const CryptEnumProviderTypes = thismodule.CryptEnumProviderTypesA;
        pub const CryptEnumProviders = thismodule.CryptEnumProvidersA;
        pub const CertRDNValueToStr = thismodule.CertRDNValueToStrA;
        pub const CertNameToStr = thismodule.CertNameToStrA;
        pub const CertStrToName = thismodule.CertStrToNameA;
        pub const CertGetNameString = thismodule.CertGetNameStringA;
        pub const CertOpenSystemStore = thismodule.CertOpenSystemStoreA;
        pub const CertAddEncodedCertificateToSystemStore = thismodule.CertAddEncodedCertificateToSystemStoreA;
        pub const CryptRetrieveObjectByUrl = thismodule.CryptRetrieveObjectByUrlA;
        pub const CryptStringToBinary = thismodule.CryptStringToBinaryA;
        pub const CryptBinaryToString = thismodule.CryptBinaryToStringA;
    },
    .wide => struct {
        pub const CRYPT_PASSWORD_CREDENTIALS = thismodule.CRYPT_PASSWORD_CREDENTIALSW;
        pub const CryptAcquireContext = thismodule.CryptAcquireContextW;
        pub const CryptSignHash = thismodule.CryptSignHashW;
        pub const CryptVerifySignature = thismodule.CryptVerifySignatureW;
        pub const CryptSetProvider = thismodule.CryptSetProviderW;
        pub const CryptSetProviderEx = thismodule.CryptSetProviderExW;
        pub const CryptGetDefaultProvider = thismodule.CryptGetDefaultProviderW;
        pub const CryptEnumProviderTypes = thismodule.CryptEnumProviderTypesW;
        pub const CryptEnumProviders = thismodule.CryptEnumProvidersW;
        pub const CertRDNValueToStr = thismodule.CertRDNValueToStrW;
        pub const CertNameToStr = thismodule.CertNameToStrW;
        pub const CertStrToName = thismodule.CertStrToNameW;
        pub const CertGetNameString = thismodule.CertGetNameStringW;
        pub const CertOpenSystemStore = thismodule.CertOpenSystemStoreW;
        pub const CertAddEncodedCertificateToSystemStore = thismodule.CertAddEncodedCertificateToSystemStoreW;
        pub const CryptRetrieveObjectByUrl = thismodule.CryptRetrieveObjectByUrlW;
        pub const CryptStringToBinary = thismodule.CryptStringToBinaryW;
        pub const CryptBinaryToString = thismodule.CryptBinaryToStringW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const CRYPT_PASSWORD_CREDENTIALS = *opaque{};
        pub const CryptAcquireContext = *opaque{};
        pub const CryptSignHash = *opaque{};
        pub const CryptVerifySignature = *opaque{};
        pub const CryptSetProvider = *opaque{};
        pub const CryptSetProviderEx = *opaque{};
        pub const CryptGetDefaultProvider = *opaque{};
        pub const CryptEnumProviderTypes = *opaque{};
        pub const CryptEnumProviders = *opaque{};
        pub const CertRDNValueToStr = *opaque{};
        pub const CertNameToStr = *opaque{};
        pub const CertStrToName = *opaque{};
        pub const CertGetNameString = *opaque{};
        pub const CertOpenSystemStore = *opaque{};
        pub const CertAddEncodedCertificateToSystemStore = *opaque{};
        pub const CryptRetrieveObjectByUrl = *opaque{};
        pub const CryptStringToBinary = *opaque{};
        pub const CryptBinaryToString = *opaque{};
    } else struct {
        pub const CRYPT_PASSWORD_CREDENTIALS = @compileError("'CRYPT_PASSWORD_CREDENTIALS' requires that UNICODE be set to true or false in the root module");
        pub const CryptAcquireContext = @compileError("'CryptAcquireContext' requires that UNICODE be set to true or false in the root module");
        pub const CryptSignHash = @compileError("'CryptSignHash' requires that UNICODE be set to true or false in the root module");
        pub const CryptVerifySignature = @compileError("'CryptVerifySignature' requires that UNICODE be set to true or false in the root module");
        pub const CryptSetProvider = @compileError("'CryptSetProvider' requires that UNICODE be set to true or false in the root module");
        pub const CryptSetProviderEx = @compileError("'CryptSetProviderEx' requires that UNICODE be set to true or false in the root module");
        pub const CryptGetDefaultProvider = @compileError("'CryptGetDefaultProvider' requires that UNICODE be set to true or false in the root module");
        pub const CryptEnumProviderTypes = @compileError("'CryptEnumProviderTypes' requires that UNICODE be set to true or false in the root module");
        pub const CryptEnumProviders = @compileError("'CryptEnumProviders' requires that UNICODE be set to true or false in the root module");
        pub const CertRDNValueToStr = @compileError("'CertRDNValueToStr' requires that UNICODE be set to true or false in the root module");
        pub const CertNameToStr = @compileError("'CertNameToStr' requires that UNICODE be set to true or false in the root module");
        pub const CertStrToName = @compileError("'CertStrToName' requires that UNICODE be set to true or false in the root module");
        pub const CertGetNameString = @compileError("'CertGetNameString' requires that UNICODE be set to true or false in the root module");
        pub const CertOpenSystemStore = @compileError("'CertOpenSystemStore' requires that UNICODE be set to true or false in the root module");
        pub const CertAddEncodedCertificateToSystemStore = @compileError("'CertAddEncodedCertificateToSystemStore' requires that UNICODE be set to true or false in the root module");
        pub const CryptRetrieveObjectByUrl = @compileError("'CryptRetrieveObjectByUrl' requires that UNICODE be set to true or false in the root module");
        pub const CryptStringToBinary = @compileError("'CryptStringToBinary' requires that UNICODE be set to true or false in the root module");
        pub const CryptBinaryToString = @compileError("'CryptBinaryToString' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (22)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const NCRYPT_DESCRIPTOR_HANDLE = @import("../security.zig").NCRYPT_DESCRIPTOR_HANDLE;
const NCRYPT_STREAM_HANDLE = @import("../security.zig").NCRYPT_STREAM_HANDLE;
const NTSTATUS = @import("../foundation.zig").NTSTATUS;
const OBJECT_SECURITY_INFORMATION = @import("../security.zig").OBJECT_SECURITY_INFORMATION;
const PSID = @import("../foundation.zig").PSID;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const REG_VALUE_TYPE = @import("../system/registry.zig").REG_VALUE_TYPE;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFN_NCRYPT_ALLOC")) { _ = PFN_NCRYPT_ALLOC; }
    if (@hasDecl(@This(), "PFN_NCRYPT_FREE")) { _ = PFN_NCRYPT_FREE; }
    if (@hasDecl(@This(), "PCRYPT_DECRYPT_PRIVATE_KEY_FUNC")) { _ = PCRYPT_DECRYPT_PRIVATE_KEY_FUNC; }
    if (@hasDecl(@This(), "PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC")) { _ = PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC; }
    if (@hasDecl(@This(), "PCRYPT_RESOLVE_HCRYPTPROV_FUNC")) { _ = PCRYPT_RESOLVE_HCRYPTPROV_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_ALLOC")) { _ = PFN_CRYPT_ALLOC; }
    if (@hasDecl(@This(), "PFN_CRYPT_FREE")) { _ = PFN_CRYPT_FREE; }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_OID_FUNC")) { _ = PFN_CRYPT_ENUM_OID_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_OID_INFO")) { _ = PFN_CRYPT_ENUM_OID_INFO; }
    if (@hasDecl(@This(), "PFN_CMSG_STREAM_OUTPUT")) { _ = PFN_CMSG_STREAM_OUTPUT; }
    if (@hasDecl(@This(), "PFN_CMSG_ALLOC")) { _ = PFN_CMSG_ALLOC; }
    if (@hasDecl(@This(), "PFN_CMSG_FREE")) { _ = PFN_CMSG_FREE; }
    if (@hasDecl(@This(), "PFN_CMSG_GEN_ENCRYPT_KEY")) { _ = PFN_CMSG_GEN_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_ENCRYPT_KEY")) { _ = PFN_CMSG_EXPORT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_ENCRYPT_KEY")) { _ = PFN_CMSG_IMPORT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY")) { _ = PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_KEY_TRANS")) { _ = PFN_CMSG_EXPORT_KEY_TRANS; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_KEY_AGREE")) { _ = PFN_CMSG_EXPORT_KEY_AGREE; }
    if (@hasDecl(@This(), "PFN_CMSG_EXPORT_MAIL_LIST")) { _ = PFN_CMSG_EXPORT_MAIL_LIST; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_KEY_TRANS")) { _ = PFN_CMSG_IMPORT_KEY_TRANS; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_KEY_AGREE")) { _ = PFN_CMSG_IMPORT_KEY_AGREE; }
    if (@hasDecl(@This(), "PFN_CMSG_IMPORT_MAIL_LIST")) { _ = PFN_CMSG_IMPORT_MAIL_LIST; }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_KEY_TRANS")) { _ = PFN_CMSG_CNG_IMPORT_KEY_TRANS; }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_KEY_AGREE")) { _ = PFN_CMSG_CNG_IMPORT_KEY_AGREE; }
    if (@hasDecl(@This(), "PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY")) { _ = PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY; }
    if (@hasDecl(@This(), "PFN_CERT_DLL_OPEN_STORE_PROV_FUNC")) { _ = PFN_CERT_DLL_OPEN_STORE_PROV_FUNC; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_CLOSE")) { _ = PFN_CERT_STORE_PROV_CLOSE; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CERT")) { _ = PFN_CERT_STORE_PROV_READ_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CERT")) { _ = PFN_CERT_STORE_PROV_WRITE_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CERT")) { _ = PFN_CERT_STORE_PROV_DELETE_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CERT_PROPERTY")) { _ = PFN_CERT_STORE_PROV_SET_CERT_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CRL")) { _ = PFN_CERT_STORE_PROV_READ_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CRL")) { _ = PFN_CERT_STORE_PROV_WRITE_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CRL")) { _ = PFN_CERT_STORE_PROV_DELETE_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CRL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_SET_CRL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_READ_CTL")) { _ = PFN_CERT_STORE_PROV_READ_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_WRITE_CTL")) { _ = PFN_CERT_STORE_PROV_WRITE_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_DELETE_CTL")) { _ = PFN_CERT_STORE_PROV_DELETE_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_SET_CTL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_SET_CTL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_CONTROL")) { _ = PFN_CERT_STORE_PROV_CONTROL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CERT")) { _ = PFN_CERT_STORE_PROV_FIND_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CERT")) { _ = PFN_CERT_STORE_PROV_FREE_FIND_CERT; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CERT_PROPERTY")) { _ = PFN_CERT_STORE_PROV_GET_CERT_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CRL")) { _ = PFN_CERT_STORE_PROV_FIND_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CRL")) { _ = PFN_CERT_STORE_PROV_FREE_FIND_CRL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CRL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_GET_CRL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FIND_CTL")) { _ = PFN_CERT_STORE_PROV_FIND_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_FREE_FIND_CTL")) { _ = PFN_CERT_STORE_PROV_FREE_FIND_CTL; }
    if (@hasDecl(@This(), "PFN_CERT_STORE_PROV_GET_CTL_PROPERTY")) { _ = PFN_CERT_STORE_PROV_GET_CTL_PROPERTY; }
    if (@hasDecl(@This(), "PFN_CERT_CREATE_CONTEXT_SORT_FUNC")) { _ = PFN_CERT_CREATE_CONTEXT_SORT_FUNC; }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_SYSTEM_STORE_LOCATION")) { _ = PFN_CERT_ENUM_SYSTEM_STORE_LOCATION; }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_SYSTEM_STORE")) { _ = PFN_CERT_ENUM_SYSTEM_STORE; }
    if (@hasDecl(@This(), "PFN_CERT_ENUM_PHYSICAL_STORE")) { _ = PFN_CERT_ENUM_PHYSICAL_STORE; }
    if (@hasDecl(@This(), "PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC")) { _ = PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC")) { _ = PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC")) { _ = PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC")) { _ = PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC")) { _ = PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC; }
    if (@hasDecl(@This(), "PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC")) { _ = PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC; }
    if (@hasDecl(@This(), "PFN_IMPORT_PRIV_KEY_FUNC")) { _ = PFN_IMPORT_PRIV_KEY_FUNC; }
    if (@hasDecl(@This(), "PFN_EXPORT_PRIV_KEY_FUNC")) { _ = PFN_EXPORT_PRIV_KEY_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_GET_SIGNER_CERTIFICATE")) { _ = PFN_CRYPT_GET_SIGNER_CERTIFICATE; }
    if (@hasDecl(@This(), "PFN_CRYPT_ASYNC_PARAM_FREE_FUNC")) { _ = PFN_CRYPT_ASYNC_PARAM_FREE_FUNC; }
    if (@hasDecl(@This(), "PFN_FREE_ENCODED_OBJECT_FUNC")) { _ = PFN_FREE_ENCODED_OBJECT_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_CANCEL_RETRIEVAL")) { _ = PFN_CRYPT_CANCEL_RETRIEVAL; }
    if (@hasDecl(@This(), "PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC")) { _ = PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC; }
    if (@hasDecl(@This(), "PFN_CANCEL_ASYNC_RETRIEVAL_FUNC")) { _ = PFN_CANCEL_ASYNC_RETRIEVAL_FUNC; }
    if (@hasDecl(@This(), "PFN_CRYPT_ENUM_KEYID_PROP")) { _ = PFN_CRYPT_ENUM_KEYID_PROP; }
    if (@hasDecl(@This(), "PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK")) { _ = PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK")) { _ = PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER; }
    if (@hasDecl(@This(), "PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE")) { _ = PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE; }
    if (@hasDecl(@This(), "PFN_CERT_IS_WEAK_HASH")) { _ = PFN_CERT_IS_WEAK_HASH; }
    if (@hasDecl(@This(), "PFNCryptStreamOutputCallback")) { _ = PFNCryptStreamOutputCallback; }
    if (@hasDecl(@This(), "PFNCryptStreamOutputCallbackEx")) { _ = PFNCryptStreamOutputCallbackEx; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_WRITE_CALLBACK")) { _ = PFN_CRYPT_XML_WRITE_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_DATA_PROVIDER_READ")) { _ = PFN_CRYPT_XML_DATA_PROVIDER_READ; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_DATA_PROVIDER_CLOSE")) { _ = PFN_CRYPT_XML_DATA_PROVIDER_CLOSE; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_CREATE_TRANSFORM")) { _ = PFN_CRYPT_XML_CREATE_TRANSFORM; }
    if (@hasDecl(@This(), "PFN_CRYPT_XML_ENUM_ALG_INFO")) { _ = PFN_CRYPT_XML_ENUM_ALG_INFO; }
    if (@hasDecl(@This(), "CryptXmlDllGetInterface")) { _ = CryptXmlDllGetInterface; }
    if (@hasDecl(@This(), "CryptXmlDllEncodeAlgorithm")) { _ = CryptXmlDllEncodeAlgorithm; }
    if (@hasDecl(@This(), "CryptXmlDllCreateDigest")) { _ = CryptXmlDllCreateDigest; }
    if (@hasDecl(@This(), "CryptXmlDllDigestData")) { _ = CryptXmlDllDigestData; }
    if (@hasDecl(@This(), "CryptXmlDllFinalizeDigest")) { _ = CryptXmlDllFinalizeDigest; }
    if (@hasDecl(@This(), "CryptXmlDllCloseDigest")) { _ = CryptXmlDllCloseDigest; }
    if (@hasDecl(@This(), "CryptXmlDllSignData")) { _ = CryptXmlDllSignData; }
    if (@hasDecl(@This(), "CryptXmlDllVerifySignature")) { _ = CryptXmlDllVerifySignature; }
    if (@hasDecl(@This(), "CryptXmlDllGetAlgorithmInfo")) { _ = CryptXmlDllGetAlgorithmInfo; }
    if (@hasDecl(@This(), "CryptXmlDllEncodeKeyValue")) { _ = CryptXmlDllEncodeKeyValue; }
    if (@hasDecl(@This(), "CryptXmlDllCreateKey")) { _ = CryptXmlDllCreateKey; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (4)
//--------------------------------------------------------------------------------
pub const catalog = @import("cryptography/catalog.zig");
pub const certificates = @import("cryptography/certificates.zig");
pub const sip = @import("cryptography/sip.zig");
pub const ui = @import("cryptography/ui.zig");
