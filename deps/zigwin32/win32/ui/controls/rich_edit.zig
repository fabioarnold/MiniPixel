//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (452)
//--------------------------------------------------------------------------------
pub const WM_CONTEXTMENU = @as(u32, 123);
pub const WM_UNICHAR = @as(u32, 265);
pub const WM_PRINTCLIENT = @as(u32, 792);
pub const EM_CANPASTE = @as(u32, 1074);
pub const EM_DISPLAYBAND = @as(u32, 1075);
pub const EM_EXGETSEL = @as(u32, 1076);
pub const EM_EXLIMITTEXT = @as(u32, 1077);
pub const EM_EXLINEFROMCHAR = @as(u32, 1078);
pub const EM_EXSETSEL = @as(u32, 1079);
pub const EM_FINDTEXT = @as(u32, 1080);
pub const EM_FORMATRANGE = @as(u32, 1081);
pub const EM_GETCHARFORMAT = @as(u32, 1082);
pub const EM_GETEVENTMASK = @as(u32, 1083);
pub const EM_GETOLEINTERFACE = @as(u32, 1084);
pub const EM_GETPARAFORMAT = @as(u32, 1085);
pub const EM_GETSELTEXT = @as(u32, 1086);
pub const EM_HIDESELECTION = @as(u32, 1087);
pub const EM_PASTESPECIAL = @as(u32, 1088);
pub const EM_REQUESTRESIZE = @as(u32, 1089);
pub const EM_SELECTIONTYPE = @as(u32, 1090);
pub const EM_SETBKGNDCOLOR = @as(u32, 1091);
pub const EM_SETCHARFORMAT = @as(u32, 1092);
pub const EM_SETEVENTMASK = @as(u32, 1093);
pub const EM_SETOLECALLBACK = @as(u32, 1094);
pub const EM_SETPARAFORMAT = @as(u32, 1095);
pub const EM_SETTARGETDEVICE = @as(u32, 1096);
pub const EM_STREAMIN = @as(u32, 1097);
pub const EM_STREAMOUT = @as(u32, 1098);
pub const EM_GETTEXTRANGE = @as(u32, 1099);
pub const EM_FINDWORDBREAK = @as(u32, 1100);
pub const EM_SETOPTIONS = @as(u32, 1101);
pub const EM_GETOPTIONS = @as(u32, 1102);
pub const EM_FINDTEXTEX = @as(u32, 1103);
pub const EM_GETWORDBREAKPROCEX = @as(u32, 1104);
pub const EM_SETWORDBREAKPROCEX = @as(u32, 1105);
pub const EM_SETUNDOLIMIT = @as(u32, 1106);
pub const EM_REDO = @as(u32, 1108);
pub const EM_CANREDO = @as(u32, 1109);
pub const EM_GETUNDONAME = @as(u32, 1110);
pub const EM_GETREDONAME = @as(u32, 1111);
pub const EM_STOPGROUPTYPING = @as(u32, 1112);
pub const EM_SETTEXTMODE = @as(u32, 1113);
pub const EM_GETTEXTMODE = @as(u32, 1114);
pub const EM_AUTOURLDETECT = @as(u32, 1115);
pub const AURL_ENABLEURL = @as(u32, 1);
pub const AURL_ENABLEEMAILADDR = @as(u32, 2);
pub const AURL_ENABLETELNO = @as(u32, 4);
pub const AURL_ENABLEEAURLS = @as(u32, 8);
pub const AURL_ENABLEDRIVELETTERS = @as(u32, 16);
pub const AURL_DISABLEMIXEDLGC = @as(u32, 32);
pub const EM_GETAUTOURLDETECT = @as(u32, 1116);
pub const EM_SETPALETTE = @as(u32, 1117);
pub const EM_GETTEXTEX = @as(u32, 1118);
pub const EM_GETTEXTLENGTHEX = @as(u32, 1119);
pub const EM_SHOWSCROLLBAR = @as(u32, 1120);
pub const EM_SETTEXTEX = @as(u32, 1121);
pub const EM_SETPUNCTUATION = @as(u32, 1124);
pub const EM_GETPUNCTUATION = @as(u32, 1125);
pub const EM_SETWORDWRAPMODE = @as(u32, 1126);
pub const EM_GETWORDWRAPMODE = @as(u32, 1127);
pub const EM_SETIMECOLOR = @as(u32, 1128);
pub const EM_GETIMECOLOR = @as(u32, 1129);
pub const EM_SETIMEOPTIONS = @as(u32, 1130);
pub const EM_GETIMEOPTIONS = @as(u32, 1131);
pub const EM_CONVPOSITION = @as(u32, 1132);
pub const EM_SETLANGOPTIONS = @as(u32, 1144);
pub const EM_GETLANGOPTIONS = @as(u32, 1145);
pub const EM_GETIMECOMPMODE = @as(u32, 1146);
pub const EM_FINDTEXTW = @as(u32, 1147);
pub const EM_FINDTEXTEXW = @as(u32, 1148);
pub const EM_RECONVERSION = @as(u32, 1149);
pub const EM_SETIMEMODEBIAS = @as(u32, 1150);
pub const EM_GETIMEMODEBIAS = @as(u32, 1151);
pub const EM_SETBIDIOPTIONS = @as(u32, 1224);
pub const EM_GETBIDIOPTIONS = @as(u32, 1225);
pub const EM_SETTYPOGRAPHYOPTIONS = @as(u32, 1226);
pub const EM_GETTYPOGRAPHYOPTIONS = @as(u32, 1227);
pub const EM_SETEDITSTYLE = @as(u32, 1228);
pub const EM_GETEDITSTYLE = @as(u32, 1229);
pub const SES_EMULATESYSEDIT = @as(u32, 1);
pub const SES_BEEPONMAXTEXT = @as(u32, 2);
pub const SES_EXTENDBACKCOLOR = @as(u32, 4);
pub const SES_MAPCPS = @as(u32, 8);
pub const SES_HYPERLINKTOOLTIPS = @as(u32, 8);
pub const SES_EMULATE10 = @as(u32, 16);
pub const SES_DEFAULTLATINLIGA = @as(u32, 16);
pub const SES_USECRLF = @as(u32, 32);
pub const SES_NOFOCUSLINKNOTIFY = @as(u32, 32);
pub const SES_USEAIMM = @as(u32, 64);
pub const SES_NOIME = @as(u32, 128);
pub const SES_ALLOWBEEPS = @as(u32, 256);
pub const SES_UPPERCASE = @as(u32, 512);
pub const SES_LOWERCASE = @as(u32, 1024);
pub const SES_NOINPUTSEQUENCECHK = @as(u32, 2048);
pub const SES_BIDI = @as(u32, 4096);
pub const SES_SCROLLONKILLFOCUS = @as(u32, 8192);
pub const SES_XLTCRCRLFTOCR = @as(u32, 16384);
pub const SES_DRAFTMODE = @as(u32, 32768);
pub const SES_USECTF = @as(u32, 65536);
pub const SES_HIDEGRIDLINES = @as(u32, 131072);
pub const SES_USEATFONT = @as(u32, 262144);
pub const SES_CUSTOMLOOK = @as(u32, 524288);
pub const SES_LBSCROLLNOTIFY = @as(u32, 1048576);
pub const SES_CTFALLOWEMBED = @as(u32, 2097152);
pub const SES_CTFALLOWSMARTTAG = @as(u32, 4194304);
pub const SES_CTFALLOWPROOFING = @as(u32, 8388608);
pub const SES_LOGICALCARET = @as(u32, 16777216);
pub const SES_WORDDRAGDROP = @as(u32, 33554432);
pub const SES_SMARTDRAGDROP = @as(u32, 67108864);
pub const SES_MULTISELECT = @as(u32, 134217728);
pub const SES_CTFNOLOCK = @as(u32, 268435456);
pub const SES_NOEALINEHEIGHTADJUST = @as(u32, 536870912);
pub const SES_MAX = @as(u32, 536870912);
pub const IMF_AUTOKEYBOARD = @as(u32, 1);
pub const IMF_AUTOFONT = @as(u32, 2);
pub const IMF_IMECANCELCOMPLETE = @as(u32, 4);
pub const IMF_IMEALWAYSSENDNOTIFY = @as(u32, 8);
pub const IMF_AUTOFONTSIZEADJUST = @as(u32, 16);
pub const IMF_UIFONTS = @as(u32, 32);
pub const IMF_NOIMPLICITLANG = @as(u32, 64);
pub const IMF_DUALFONT = @as(u32, 128);
pub const IMF_NOKBDLIDFIXUP = @as(u32, 512);
pub const IMF_NORTFFONTSUBSTITUTE = @as(u32, 1024);
pub const IMF_SPELLCHECKING = @as(u32, 2048);
pub const IMF_TKBPREDICTION = @as(u32, 4096);
pub const IMF_IMEUIINTEGRATION = @as(u32, 8192);
pub const ICM_NOTOPEN = @as(u32, 0);
pub const ICM_LEVEL3 = @as(u32, 1);
pub const ICM_LEVEL2 = @as(u32, 2);
pub const ICM_LEVEL2_5 = @as(u32, 3);
pub const ICM_LEVEL2_SUI = @as(u32, 4);
pub const ICM_CTF = @as(u32, 5);
pub const TO_ADVANCEDTYPOGRAPHY = @as(u32, 1);
pub const TO_SIMPLELINEBREAK = @as(u32, 2);
pub const TO_DISABLECUSTOMTEXTOUT = @as(u32, 4);
pub const TO_ADVANCEDLAYOUT = @as(u32, 8);
pub const EM_OUTLINE = @as(u32, 1244);
pub const EM_GETSCROLLPOS = @as(u32, 1245);
pub const EM_SETSCROLLPOS = @as(u32, 1246);
pub const EM_SETFONTSIZE = @as(u32, 1247);
pub const EM_GETZOOM = @as(u32, 1248);
pub const EM_SETZOOM = @as(u32, 1249);
pub const EM_GETVIEWKIND = @as(u32, 1250);
pub const EM_SETVIEWKIND = @as(u32, 1251);
pub const EM_GETPAGE = @as(u32, 1252);
pub const EM_SETPAGE = @as(u32, 1253);
pub const EM_GETHYPHENATEINFO = @as(u32, 1254);
pub const EM_SETHYPHENATEINFO = @as(u32, 1255);
pub const EM_GETPAGEROTATE = @as(u32, 1259);
pub const EM_SETPAGEROTATE = @as(u32, 1260);
pub const EM_GETCTFMODEBIAS = @as(u32, 1261);
pub const EM_SETCTFMODEBIAS = @as(u32, 1262);
pub const EM_GETCTFOPENSTATUS = @as(u32, 1264);
pub const EM_SETCTFOPENSTATUS = @as(u32, 1265);
pub const EM_GETIMECOMPTEXT = @as(u32, 1266);
pub const EM_ISIME = @as(u32, 1267);
pub const EM_GETIMEPROPERTY = @as(u32, 1268);
pub const EM_GETQUERYRTFOBJ = @as(u32, 1293);
pub const EM_SETQUERYRTFOBJ = @as(u32, 1294);
pub const EPR_0 = @as(u32, 0);
pub const EPR_270 = @as(u32, 1);
pub const EPR_180 = @as(u32, 2);
pub const EPR_90 = @as(u32, 3);
pub const EPR_SE = @as(u32, 5);
pub const CTFMODEBIAS_DEFAULT = @as(u32, 0);
pub const CTFMODEBIAS_FILENAME = @as(u32, 1);
pub const CTFMODEBIAS_NAME = @as(u32, 2);
pub const CTFMODEBIAS_READING = @as(u32, 3);
pub const CTFMODEBIAS_DATETIME = @as(u32, 4);
pub const CTFMODEBIAS_CONVERSATION = @as(u32, 5);
pub const CTFMODEBIAS_NUMERIC = @as(u32, 6);
pub const CTFMODEBIAS_HIRAGANA = @as(u32, 7);
pub const CTFMODEBIAS_KATAKANA = @as(u32, 8);
pub const CTFMODEBIAS_HANGUL = @as(u32, 9);
pub const CTFMODEBIAS_HALFWIDTHKATAKANA = @as(u32, 10);
pub const CTFMODEBIAS_FULLWIDTHALPHANUMERIC = @as(u32, 11);
pub const CTFMODEBIAS_HALFWIDTHALPHANUMERIC = @as(u32, 12);
pub const IMF_SMODE_PLAURALCLAUSE = @as(u32, 1);
pub const IMF_SMODE_NONE = @as(u32, 2);
pub const EMO_EXIT = @as(u32, 0);
pub const EMO_ENTER = @as(u32, 1);
pub const EMO_PROMOTE = @as(u32, 2);
pub const EMO_EXPAND = @as(u32, 3);
pub const EMO_MOVESELECTION = @as(u32, 4);
pub const EMO_GETVIEWMODE = @as(u32, 5);
pub const EMO_EXPANDSELECTION = @as(u32, 0);
pub const EMO_EXPANDDOCUMENT = @as(u32, 1);
pub const VM_NORMAL = @as(u32, 4);
pub const VM_OUTLINE = @as(u32, 2);
pub const VM_PAGE = @as(u32, 9);
pub const EM_INSERTTABLE = @as(u32, 1256);
pub const EM_GETAUTOCORRECTPROC = @as(u32, 1257);
pub const EM_SETAUTOCORRECTPROC = @as(u32, 1258);
pub const EM_CALLAUTOCORRECTPROC = @as(u32, 1279);
pub const ATP_NOCHANGE = @as(u32, 0);
pub const ATP_CHANGE = @as(u32, 1);
pub const ATP_NODELIMITER = @as(u32, 2);
pub const ATP_REPLACEALLTEXT = @as(u32, 4);
pub const EM_GETTABLEPARMS = @as(u32, 1289);
pub const EM_SETEDITSTYLEEX = @as(u32, 1299);
pub const EM_GETEDITSTYLEEX = @as(u32, 1300);
pub const SES_EX_NOTABLE = @as(u32, 4);
pub const SES_EX_NOMATH = @as(u32, 64);
pub const SES_EX_HANDLEFRIENDLYURL = @as(u32, 256);
pub const SES_EX_NOTHEMING = @as(u32, 524288);
pub const SES_EX_NOACETATESELECTION = @as(u32, 1048576);
pub const SES_EX_USESINGLELINE = @as(u32, 2097152);
pub const SES_EX_MULTITOUCH = @as(u32, 134217728);
pub const SES_EX_HIDETEMPFORMAT = @as(u32, 268435456);
pub const SES_EX_USEMOUSEWPARAM = @as(u32, 536870912);
pub const EM_GETSTORYTYPE = @as(u32, 1314);
pub const EM_SETSTORYTYPE = @as(u32, 1315);
pub const EM_GETELLIPSISMODE = @as(u32, 1329);
pub const EM_SETELLIPSISMODE = @as(u32, 1330);
pub const ELLIPSIS_MASK = @as(u32, 3);
pub const ELLIPSIS_NONE = @as(u32, 0);
pub const ELLIPSIS_END = @as(u32, 1);
pub const ELLIPSIS_WORD = @as(u32, 3);
pub const EM_SETTABLEPARMS = @as(u32, 1331);
pub const EM_GETTOUCHOPTIONS = @as(u32, 1334);
pub const EM_SETTOUCHOPTIONS = @as(u32, 1335);
pub const EM_INSERTIMAGE = @as(u32, 1338);
pub const EM_SETUIANAME = @as(u32, 1344);
pub const EM_GETELLIPSISSTATE = @as(u32, 1346);
pub const RTO_SHOWHANDLES = @as(u32, 1);
pub const RTO_DISABLEHANDLES = @as(u32, 2);
pub const RTO_READINGMODE = @as(u32, 3);
pub const EN_MSGFILTER = @as(u32, 1792);
pub const EN_REQUESTRESIZE = @as(u32, 1793);
pub const EN_SELCHANGE = @as(u32, 1794);
pub const EN_DROPFILES = @as(u32, 1795);
pub const EN_PROTECTED = @as(u32, 1796);
pub const EN_CORRECTTEXT = @as(u32, 1797);
pub const EN_STOPNOUNDO = @as(u32, 1798);
pub const EN_IMECHANGE = @as(u32, 1799);
pub const EN_SAVECLIPBOARD = @as(u32, 1800);
pub const EN_OLEOPFAILED = @as(u32, 1801);
pub const EN_OBJECTPOSITIONS = @as(u32, 1802);
pub const EN_LINK = @as(u32, 1803);
pub const EN_DRAGDROPDONE = @as(u32, 1804);
pub const EN_PARAGRAPHEXPANDED = @as(u32, 1805);
pub const EN_PAGECHANGE = @as(u32, 1806);
pub const EN_LOWFIRTF = @as(u32, 1807);
pub const EN_ALIGNLTR = @as(u32, 1808);
pub const EN_ALIGNRTL = @as(u32, 1809);
pub const EN_CLIPFORMAT = @as(u32, 1810);
pub const EN_STARTCOMPOSITION = @as(u32, 1811);
pub const EN_ENDCOMPOSITION = @as(u32, 1812);
pub const ENM_NONE = @as(u32, 0);
pub const ENM_CHANGE = @as(u32, 1);
pub const ENM_UPDATE = @as(u32, 2);
pub const ENM_SCROLL = @as(u32, 4);
pub const ENM_SCROLLEVENTS = @as(u32, 8);
pub const ENM_DRAGDROPDONE = @as(u32, 16);
pub const ENM_PARAGRAPHEXPANDED = @as(u32, 32);
pub const ENM_PAGECHANGE = @as(u32, 64);
pub const ENM_CLIPFORMAT = @as(u32, 128);
pub const ENM_KEYEVENTS = @as(u32, 65536);
pub const ENM_MOUSEEVENTS = @as(u32, 131072);
pub const ENM_REQUESTRESIZE = @as(u32, 262144);
pub const ENM_SELCHANGE = @as(u32, 524288);
pub const ENM_DROPFILES = @as(u32, 1048576);
pub const ENM_PROTECTED = @as(u32, 2097152);
pub const ENM_CORRECTTEXT = @as(u32, 4194304);
pub const ENM_IMECHANGE = @as(u32, 8388608);
pub const ENM_LANGCHANGE = @as(u32, 16777216);
pub const ENM_OBJECTPOSITIONS = @as(u32, 33554432);
pub const ENM_LINK = @as(u32, 67108864);
pub const ENM_LOWFIRTF = @as(u32, 134217728);
pub const ENM_STARTCOMPOSITION = @as(u32, 268435456);
pub const ENM_ENDCOMPOSITION = @as(u32, 536870912);
pub const ENM_GROUPTYPINGCHANGE = @as(u32, 1073741824);
pub const ENM_HIDELINKTOOLTIP = @as(u32, 2147483648);
pub const ES_SAVESEL = @as(u32, 32768);
pub const ES_SUNKEN = @as(u32, 16384);
pub const ES_DISABLENOSCROLL = @as(u32, 8192);
pub const ES_SELECTIONBAR = @as(u32, 16777216);
pub const ES_NOOLEDRAGDROP = @as(u32, 8);
pub const ES_EX_NOCALLOLEINIT = @as(u32, 0);
pub const ES_VERTICAL = @as(u32, 4194304);
pub const ES_NOIME = @as(u32, 524288);
pub const ES_SELFIME = @as(u32, 262144);
pub const ECO_AUTOWORDSELECTION = @as(u32, 1);
pub const ECO_AUTOVSCROLL = @as(u32, 64);
pub const ECO_AUTOHSCROLL = @as(u32, 128);
pub const ECO_NOHIDESEL = @as(u32, 256);
pub const ECO_READONLY = @as(u32, 2048);
pub const ECO_WANTRETURN = @as(u32, 4096);
pub const ECO_SAVESEL = @as(u32, 32768);
pub const ECO_SELECTIONBAR = @as(u32, 16777216);
pub const ECO_VERTICAL = @as(u32, 4194304);
pub const ECOOP_SET = @as(u32, 1);
pub const ECOOP_OR = @as(u32, 2);
pub const ECOOP_AND = @as(u32, 3);
pub const ECOOP_XOR = @as(u32, 4);
pub const WB_MOVEWORDPREV = @as(u32, 4);
pub const WB_MOVEWORDNEXT = @as(u32, 5);
pub const WB_PREVBREAK = @as(u32, 6);
pub const WB_NEXTBREAK = @as(u32, 7);
pub const PC_FOLLOWING = @as(u32, 1);
pub const PC_LEADING = @as(u32, 2);
pub const PC_OVERFLOW = @as(u32, 3);
pub const PC_DELIMITER = @as(u32, 4);
pub const WBF_WORDWRAP = @as(u32, 16);
pub const WBF_WORDBREAK = @as(u32, 32);
pub const WBF_OVERFLOW = @as(u32, 64);
pub const WBF_LEVEL1 = @as(u32, 128);
pub const WBF_LEVEL2 = @as(u32, 256);
pub const WBF_CUSTOM = @as(u32, 512);
pub const IMF_FORCENONE = @as(u32, 1);
pub const IMF_FORCEENABLE = @as(u32, 2);
pub const IMF_FORCEDISABLE = @as(u32, 4);
pub const IMF_CLOSESTATUSWINDOW = @as(u32, 8);
pub const IMF_VERTICAL = @as(u32, 32);
pub const IMF_FORCEACTIVE = @as(u32, 64);
pub const IMF_FORCEINACTIVE = @as(u32, 128);
pub const IMF_FORCEREMEMBER = @as(u32, 256);
pub const IMF_MULTIPLEEDIT = @as(u32, 1024);
pub const SCF_SELECTION = @as(u32, 1);
pub const SCF_WORD = @as(u32, 2);
pub const SCF_DEFAULT = @as(u32, 0);
pub const SCF_ALL = @as(u32, 4);
pub const SCF_USEUIRULES = @as(u32, 8);
pub const SCF_ASSOCIATEFONT = @as(u32, 16);
pub const SCF_NOKBUPDATE = @as(u32, 32);
pub const SCF_ASSOCIATEFONT2 = @as(u32, 64);
pub const SCF_SMARTFONT = @as(u32, 128);
pub const SCF_CHARREPFROMLCID = @as(u32, 256);
pub const SPF_DONTSETDEFAULT = @as(u32, 2);
pub const SPF_SETDEFAULT = @as(u32, 4);
pub const SF_TEXT = @as(u32, 1);
pub const SF_RTF = @as(u32, 2);
pub const SF_RTFNOOBJS = @as(u32, 3);
pub const SF_TEXTIZED = @as(u32, 4);
pub const SF_UNICODE = @as(u32, 16);
pub const SF_USECODEPAGE = @as(u32, 32);
pub const SF_NCRFORNONASCII = @as(u32, 64);
pub const SFF_WRITEXTRAPAR = @as(u32, 128);
pub const SFF_SELECTION = @as(u32, 32768);
pub const SFF_PLAINRTF = @as(u32, 16384);
pub const SFF_PERSISTVIEWSCALE = @as(u32, 8192);
pub const SFF_KEEPDOCINFO = @as(u32, 4096);
pub const SFF_PWD = @as(u32, 2048);
pub const SF_RTFVAL = @as(u32, 1792);
pub const MAX_TAB_STOPS = @as(u32, 32);
pub const MAX_TABLE_CELLS = @as(u32, 63);
pub const PFM_SPACEBEFORE = @as(u32, 64);
pub const PFM_SPACEAFTER = @as(u32, 128);
pub const PFM_LINESPACING = @as(u32, 256);
pub const PFM_STYLE = @as(u32, 1024);
pub const PFM_BORDER = @as(u32, 2048);
pub const PFM_SHADING = @as(u32, 4096);
pub const PFM_NUMBERINGSTYLE = @as(u32, 8192);
pub const PFM_NUMBERINGTAB = @as(u32, 16384);
pub const PFM_NUMBERINGSTART = @as(u32, 32768);
pub const PFM_KEEP = @as(u32, 131072);
pub const PFM_KEEPNEXT = @as(u32, 262144);
pub const PFM_PAGEBREAKBEFORE = @as(u32, 524288);
pub const PFM_NOLINENUMBER = @as(u32, 1048576);
pub const PFM_NOWIDOWCONTROL = @as(u32, 2097152);
pub const PFM_DONOTHYPHEN = @as(u32, 4194304);
pub const PFM_SIDEBYSIDE = @as(u32, 8388608);
pub const PFM_COLLAPSED = @as(u32, 16777216);
pub const PFM_OUTLINELEVEL = @as(u32, 33554432);
pub const PFM_BOX = @as(u32, 67108864);
pub const PFM_RESERVED2 = @as(u32, 134217728);
pub const PFM_TABLEROWDELIMITER = @as(u32, 268435456);
pub const PFM_TEXTWRAPPINGBREAK = @as(u32, 536870912);
pub const PFM_TABLE = @as(u32, 1073741824);
pub const PFN_BULLET = @as(u32, 1);
pub const PFN_ARABIC = @as(u32, 2);
pub const PFN_LCLETTER = @as(u32, 3);
pub const PFN_UCLETTER = @as(u32, 4);
pub const PFN_LCROMAN = @as(u32, 5);
pub const PFN_UCROMAN = @as(u32, 6);
pub const PFA_JUSTIFY = @as(u32, 4);
pub const PFA_FULL_INTERWORD = @as(u32, 4);
pub const WM_NOTIFY = @as(u32, 78);
pub const GCMF_GRIPPER = @as(u32, 1);
pub const GCMF_SPELLING = @as(u32, 2);
pub const GCMF_TOUCHMENU = @as(u32, 16384);
pub const GCMF_MOUSEMENU = @as(u32, 8192);
pub const OLEOP_DOVERB = @as(u32, 1);
pub const ST_DEFAULT = @as(u32, 0);
pub const ST_KEEPUNDO = @as(u32, 1);
pub const ST_SELECTION = @as(u32, 2);
pub const ST_NEWCHARS = @as(u32, 4);
pub const ST_UNICODE = @as(u32, 8);
pub const BOM_DEFPARADIR = @as(u32, 1);
pub const BOM_PLAINTEXT = @as(u32, 2);
pub const BOM_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOM_CONTEXTREADING = @as(u32, 8);
pub const BOM_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOM_LEGACYBIDICLASS = @as(u32, 64);
pub const BOM_UNICODEBIDI = @as(u32, 128);
pub const BOE_RTLDIR = @as(u32, 1);
pub const BOE_PLAINTEXT = @as(u32, 2);
pub const BOE_NEUTRALOVERRIDE = @as(u32, 4);
pub const BOE_CONTEXTREADING = @as(u32, 8);
pub const BOE_CONTEXTALIGNMENT = @as(u32, 16);
pub const BOE_FORCERECALC = @as(u32, 32);
pub const BOE_LEGACYBIDICLASS = @as(u32, 64);
pub const BOE_UNICODEBIDI = @as(u32, 128);
pub const FR_MATCHDIAC = @as(u32, 536870912);
pub const FR_MATCHKASHIDA = @as(u32, 1073741824);
pub const FR_MATCHALEFHAMZA = @as(u32, 2147483648);
pub const PFA_FULL_NEWSPAPER = @as(u32, 5);
pub const PFA_FULL_INTERLETTER = @as(u32, 6);
pub const PFA_FULL_SCALED = @as(u32, 7);
pub const PFA_FULL_GLYPHS = @as(u32, 8);
pub const AURL_ENABLEEA = @as(u32, 1);
pub const GCM_TOUCHMENU = @as(u32, 16384);
pub const GCM_MOUSEMENU = @as(u32, 8192);
pub const S_MSG_KEY_IGNORED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const TXTBIT_RICHTEXT = @as(u32, 1);
pub const TXTBIT_MULTILINE = @as(u32, 2);
pub const TXTBIT_READONLY = @as(u32, 4);
pub const TXTBIT_SHOWACCELERATOR = @as(u32, 8);
pub const TXTBIT_USEPASSWORD = @as(u32, 16);
pub const TXTBIT_HIDESELECTION = @as(u32, 32);
pub const TXTBIT_SAVESELECTION = @as(u32, 64);
pub const TXTBIT_AUTOWORDSEL = @as(u32, 128);
pub const TXTBIT_VERTICAL = @as(u32, 256);
pub const TXTBIT_SELBARCHANGE = @as(u32, 512);
pub const TXTBIT_WORDWRAP = @as(u32, 1024);
pub const TXTBIT_ALLOWBEEP = @as(u32, 2048);
pub const TXTBIT_DISABLEDRAG = @as(u32, 4096);
pub const TXTBIT_VIEWINSETCHANGE = @as(u32, 8192);
pub const TXTBIT_BACKSTYLECHANGE = @as(u32, 16384);
pub const TXTBIT_MAXLENGTHCHANGE = @as(u32, 32768);
pub const TXTBIT_SCROLLBARCHANGE = @as(u32, 65536);
pub const TXTBIT_CHARFORMATCHANGE = @as(u32, 131072);
pub const TXTBIT_PARAFORMATCHANGE = @as(u32, 262144);
pub const TXTBIT_EXTENTCHANGE = @as(u32, 524288);
pub const TXTBIT_CLIENTRECTCHANGE = @as(u32, 1048576);
pub const TXTBIT_USECURRENTBKG = @as(u32, 2097152);
pub const TXTBIT_NOTHREADREFCOUNT = @as(u32, 4194304);
pub const TXTBIT_SHOWPASSWORD = @as(u32, 8388608);
pub const TXTBIT_D2DDWRITE = @as(u32, 16777216);
pub const TXTBIT_D2DSIMPLETYPOGRAPHY = @as(u32, 33554432);
pub const TXTBIT_D2DPIXELSNAPPED = @as(u32, 67108864);
pub const TXTBIT_D2DSUBPIXELLINES = @as(u32, 134217728);
pub const TXTBIT_FLASHLASTPASSWORDCHAR = @as(u32, 268435456);
pub const TXTBIT_ADVANCEDINPUT = @as(u32, 536870912);
pub const TXES_ISDIALOG = @as(u32, 1);
pub const REO_NULL = @as(i32, 0);
pub const REO_READWRITEMASK = @as(i32, 2047);
pub const RECO_PASTE = @as(i32, 0);
pub const RECO_DROP = @as(i32, 1);
pub const RECO_COPY = @as(i32, 2);
pub const RECO_CUT = @as(i32, 3);
pub const RECO_DRAG = @as(i32, 4);

//--------------------------------------------------------------------------------
// Section: Types (101)
//--------------------------------------------------------------------------------
pub const CFM_MASK = enum(u32) {
    SUBSCRIPT = 196608,
    // SUPERSCRIPT = 196608, this enum value conflicts with SUBSCRIPT
    EFFECTS = 1073741887,
    ALL = 4160749631,
    BOLD = 1,
    CHARSET = 134217728,
    COLOR = 1073741824,
    FACE = 536870912,
    ITALIC = 2,
    OFFSET = 268435456,
    PROTECTED = 16,
    SIZE = 2147483648,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    LINK = 32,
    SMALLCAPS = 64,
    ALLCAPS = 128,
    HIDDEN = 256,
    OUTLINE = 512,
    SHADOW = 1024,
    EMBOSS = 2048,
    IMPRINT = 4096,
    DISABLED = 8192,
    REVISED = 16384,
    REVAUTHOR = 32768,
    ANIMATION = 262144,
    STYLE = 524288,
    KERNING = 1048576,
    SPACING = 2097152,
    WEIGHT = 4194304,
    UNDERLINETYPE = 8388608,
    COOKIE = 16777216,
    LCID = 33554432,
    BACKCOLOR = 67108864,
    EFFECTS2 = 1141080063,
    ALL2 = 4294967295,
    // FONTBOUND = 1048576, this enum value conflicts with KERNING
    // LINKPROTECTED = 8388608, this enum value conflicts with UNDERLINETYPE
    // EXTENDED = 33554432, this enum value conflicts with LCID
    // MATHNOBUILDUP = 134217728, this enum value conflicts with CHARSET
    // MATH = 268435456, this enum value conflicts with OFFSET
    // MATHORDINARY = 536870912, this enum value conflicts with FACE
    ALLEFFECTS = 2115207167,
    _,
    pub fn initFlags(o: struct {
        SUBSCRIPT: u1 = 0,
        EFFECTS: u1 = 0,
        ALL: u1 = 0,
        BOLD: u1 = 0,
        CHARSET: u1 = 0,
        COLOR: u1 = 0,
        FACE: u1 = 0,
        ITALIC: u1 = 0,
        OFFSET: u1 = 0,
        PROTECTED: u1 = 0,
        SIZE: u1 = 0,
        STRIKEOUT: u1 = 0,
        UNDERLINE: u1 = 0,
        LINK: u1 = 0,
        SMALLCAPS: u1 = 0,
        ALLCAPS: u1 = 0,
        HIDDEN: u1 = 0,
        OUTLINE: u1 = 0,
        SHADOW: u1 = 0,
        EMBOSS: u1 = 0,
        IMPRINT: u1 = 0,
        DISABLED: u1 = 0,
        REVISED: u1 = 0,
        REVAUTHOR: u1 = 0,
        ANIMATION: u1 = 0,
        STYLE: u1 = 0,
        KERNING: u1 = 0,
        SPACING: u1 = 0,
        WEIGHT: u1 = 0,
        UNDERLINETYPE: u1 = 0,
        COOKIE: u1 = 0,
        LCID: u1 = 0,
        BACKCOLOR: u1 = 0,
        EFFECTS2: u1 = 0,
        ALL2: u1 = 0,
        ALLEFFECTS: u1 = 0,
    }) CFM_MASK {
        return @intToEnum(CFM_MASK,
              (if (o.SUBSCRIPT == 1) @enumToInt(CFM_MASK.SUBSCRIPT) else 0)
            | (if (o.EFFECTS == 1) @enumToInt(CFM_MASK.EFFECTS) else 0)
            | (if (o.ALL == 1) @enumToInt(CFM_MASK.ALL) else 0)
            | (if (o.BOLD == 1) @enumToInt(CFM_MASK.BOLD) else 0)
            | (if (o.CHARSET == 1) @enumToInt(CFM_MASK.CHARSET) else 0)
            | (if (o.COLOR == 1) @enumToInt(CFM_MASK.COLOR) else 0)
            | (if (o.FACE == 1) @enumToInt(CFM_MASK.FACE) else 0)
            | (if (o.ITALIC == 1) @enumToInt(CFM_MASK.ITALIC) else 0)
            | (if (o.OFFSET == 1) @enumToInt(CFM_MASK.OFFSET) else 0)
            | (if (o.PROTECTED == 1) @enumToInt(CFM_MASK.PROTECTED) else 0)
            | (if (o.SIZE == 1) @enumToInt(CFM_MASK.SIZE) else 0)
            | (if (o.STRIKEOUT == 1) @enumToInt(CFM_MASK.STRIKEOUT) else 0)
            | (if (o.UNDERLINE == 1) @enumToInt(CFM_MASK.UNDERLINE) else 0)
            | (if (o.LINK == 1) @enumToInt(CFM_MASK.LINK) else 0)
            | (if (o.SMALLCAPS == 1) @enumToInt(CFM_MASK.SMALLCAPS) else 0)
            | (if (o.ALLCAPS == 1) @enumToInt(CFM_MASK.ALLCAPS) else 0)
            | (if (o.HIDDEN == 1) @enumToInt(CFM_MASK.HIDDEN) else 0)
            | (if (o.OUTLINE == 1) @enumToInt(CFM_MASK.OUTLINE) else 0)
            | (if (o.SHADOW == 1) @enumToInt(CFM_MASK.SHADOW) else 0)
            | (if (o.EMBOSS == 1) @enumToInt(CFM_MASK.EMBOSS) else 0)
            | (if (o.IMPRINT == 1) @enumToInt(CFM_MASK.IMPRINT) else 0)
            | (if (o.DISABLED == 1) @enumToInt(CFM_MASK.DISABLED) else 0)
            | (if (o.REVISED == 1) @enumToInt(CFM_MASK.REVISED) else 0)
            | (if (o.REVAUTHOR == 1) @enumToInt(CFM_MASK.REVAUTHOR) else 0)
            | (if (o.ANIMATION == 1) @enumToInt(CFM_MASK.ANIMATION) else 0)
            | (if (o.STYLE == 1) @enumToInt(CFM_MASK.STYLE) else 0)
            | (if (o.KERNING == 1) @enumToInt(CFM_MASK.KERNING) else 0)
            | (if (o.SPACING == 1) @enumToInt(CFM_MASK.SPACING) else 0)
            | (if (o.WEIGHT == 1) @enumToInt(CFM_MASK.WEIGHT) else 0)
            | (if (o.UNDERLINETYPE == 1) @enumToInt(CFM_MASK.UNDERLINETYPE) else 0)
            | (if (o.COOKIE == 1) @enumToInt(CFM_MASK.COOKIE) else 0)
            | (if (o.LCID == 1) @enumToInt(CFM_MASK.LCID) else 0)
            | (if (o.BACKCOLOR == 1) @enumToInt(CFM_MASK.BACKCOLOR) else 0)
            | (if (o.EFFECTS2 == 1) @enumToInt(CFM_MASK.EFFECTS2) else 0)
            | (if (o.ALL2 == 1) @enumToInt(CFM_MASK.ALL2) else 0)
            | (if (o.ALLEFFECTS == 1) @enumToInt(CFM_MASK.ALLEFFECTS) else 0)
        );
    }
};
pub const CFM_SUBSCRIPT = CFM_MASK.SUBSCRIPT;
pub const CFM_SUPERSCRIPT = CFM_MASK.SUBSCRIPT;
pub const CFM_EFFECTS = CFM_MASK.EFFECTS;
pub const CFM_ALL = CFM_MASK.ALL;
pub const CFM_BOLD = CFM_MASK.BOLD;
pub const CFM_CHARSET = CFM_MASK.CHARSET;
pub const CFM_COLOR = CFM_MASK.COLOR;
pub const CFM_FACE = CFM_MASK.FACE;
pub const CFM_ITALIC = CFM_MASK.ITALIC;
pub const CFM_OFFSET = CFM_MASK.OFFSET;
pub const CFM_PROTECTED = CFM_MASK.PROTECTED;
pub const CFM_SIZE = CFM_MASK.SIZE;
pub const CFM_STRIKEOUT = CFM_MASK.STRIKEOUT;
pub const CFM_UNDERLINE = CFM_MASK.UNDERLINE;
pub const CFM_LINK = CFM_MASK.LINK;
pub const CFM_SMALLCAPS = CFM_MASK.SMALLCAPS;
pub const CFM_ALLCAPS = CFM_MASK.ALLCAPS;
pub const CFM_HIDDEN = CFM_MASK.HIDDEN;
pub const CFM_OUTLINE = CFM_MASK.OUTLINE;
pub const CFM_SHADOW = CFM_MASK.SHADOW;
pub const CFM_EMBOSS = CFM_MASK.EMBOSS;
pub const CFM_IMPRINT = CFM_MASK.IMPRINT;
pub const CFM_DISABLED = CFM_MASK.DISABLED;
pub const CFM_REVISED = CFM_MASK.REVISED;
pub const CFM_REVAUTHOR = CFM_MASK.REVAUTHOR;
pub const CFM_ANIMATION = CFM_MASK.ANIMATION;
pub const CFM_STYLE = CFM_MASK.STYLE;
pub const CFM_KERNING = CFM_MASK.KERNING;
pub const CFM_SPACING = CFM_MASK.SPACING;
pub const CFM_WEIGHT = CFM_MASK.WEIGHT;
pub const CFM_UNDERLINETYPE = CFM_MASK.UNDERLINETYPE;
pub const CFM_COOKIE = CFM_MASK.COOKIE;
pub const CFM_LCID = CFM_MASK.LCID;
pub const CFM_BACKCOLOR = CFM_MASK.BACKCOLOR;
pub const CFM_EFFECTS2 = CFM_MASK.EFFECTS2;
pub const CFM_ALL2 = CFM_MASK.ALL2;
pub const CFM_FONTBOUND = CFM_MASK.KERNING;
pub const CFM_LINKPROTECTED = CFM_MASK.UNDERLINETYPE;
pub const CFM_EXTENDED = CFM_MASK.LCID;
pub const CFM_MATHNOBUILDUP = CFM_MASK.CHARSET;
pub const CFM_MATH = CFM_MASK.OFFSET;
pub const CFM_MATHORDINARY = CFM_MASK.FACE;
pub const CFM_ALLEFFECTS = CFM_MASK.ALLEFFECTS;

pub const CFE_EFFECTS = enum(u32) {
    ALLCAPS = 128,
    AUTOBACKCOLOR = 67108864,
    DISABLED = 8192,
    EMBOSS = 2048,
    HIDDEN = 256,
    IMPRINT = 4096,
    OUTLINE = 512,
    REVISED = 16384,
    SHADOW = 1024,
    SMALLCAPS = 64,
    AUTOCOLOR = 1073741824,
    BOLD = 1,
    ITALIC = 2,
    STRIKEOUT = 8,
    UNDERLINE = 4,
    PROTECTED = 16,
    LINK = 32,
    SUBSCRIPT = 65536,
    SUPERSCRIPT = 131072,
    FONTBOUND = 1048576,
    LINKPROTECTED = 8388608,
    EXTENDED = 33554432,
    MATHNOBUILDUP = 134217728,
    MATH = 268435456,
    MATHORDINARY = 536870912,
    _,
    pub fn initFlags(o: struct {
        ALLCAPS: u1 = 0,
        AUTOBACKCOLOR: u1 = 0,
        DISABLED: u1 = 0,
        EMBOSS: u1 = 0,
        HIDDEN: u1 = 0,
        IMPRINT: u1 = 0,
        OUTLINE: u1 = 0,
        REVISED: u1 = 0,
        SHADOW: u1 = 0,
        SMALLCAPS: u1 = 0,
        AUTOCOLOR: u1 = 0,
        BOLD: u1 = 0,
        ITALIC: u1 = 0,
        STRIKEOUT: u1 = 0,
        UNDERLINE: u1 = 0,
        PROTECTED: u1 = 0,
        LINK: u1 = 0,
        SUBSCRIPT: u1 = 0,
        SUPERSCRIPT: u1 = 0,
        FONTBOUND: u1 = 0,
        LINKPROTECTED: u1 = 0,
        EXTENDED: u1 = 0,
        MATHNOBUILDUP: u1 = 0,
        MATH: u1 = 0,
        MATHORDINARY: u1 = 0,
    }) CFE_EFFECTS {
        return @intToEnum(CFE_EFFECTS,
              (if (o.ALLCAPS == 1) @enumToInt(CFE_EFFECTS.ALLCAPS) else 0)
            | (if (o.AUTOBACKCOLOR == 1) @enumToInt(CFE_EFFECTS.AUTOBACKCOLOR) else 0)
            | (if (o.DISABLED == 1) @enumToInt(CFE_EFFECTS.DISABLED) else 0)
            | (if (o.EMBOSS == 1) @enumToInt(CFE_EFFECTS.EMBOSS) else 0)
            | (if (o.HIDDEN == 1) @enumToInt(CFE_EFFECTS.HIDDEN) else 0)
            | (if (o.IMPRINT == 1) @enumToInt(CFE_EFFECTS.IMPRINT) else 0)
            | (if (o.OUTLINE == 1) @enumToInt(CFE_EFFECTS.OUTLINE) else 0)
            | (if (o.REVISED == 1) @enumToInt(CFE_EFFECTS.REVISED) else 0)
            | (if (o.SHADOW == 1) @enumToInt(CFE_EFFECTS.SHADOW) else 0)
            | (if (o.SMALLCAPS == 1) @enumToInt(CFE_EFFECTS.SMALLCAPS) else 0)
            | (if (o.AUTOCOLOR == 1) @enumToInt(CFE_EFFECTS.AUTOCOLOR) else 0)
            | (if (o.BOLD == 1) @enumToInt(CFE_EFFECTS.BOLD) else 0)
            | (if (o.ITALIC == 1) @enumToInt(CFE_EFFECTS.ITALIC) else 0)
            | (if (o.STRIKEOUT == 1) @enumToInt(CFE_EFFECTS.STRIKEOUT) else 0)
            | (if (o.UNDERLINE == 1) @enumToInt(CFE_EFFECTS.UNDERLINE) else 0)
            | (if (o.PROTECTED == 1) @enumToInt(CFE_EFFECTS.PROTECTED) else 0)
            | (if (o.LINK == 1) @enumToInt(CFE_EFFECTS.LINK) else 0)
            | (if (o.SUBSCRIPT == 1) @enumToInt(CFE_EFFECTS.SUBSCRIPT) else 0)
            | (if (o.SUPERSCRIPT == 1) @enumToInt(CFE_EFFECTS.SUPERSCRIPT) else 0)
            | (if (o.FONTBOUND == 1) @enumToInt(CFE_EFFECTS.FONTBOUND) else 0)
            | (if (o.LINKPROTECTED == 1) @enumToInt(CFE_EFFECTS.LINKPROTECTED) else 0)
            | (if (o.EXTENDED == 1) @enumToInt(CFE_EFFECTS.EXTENDED) else 0)
            | (if (o.MATHNOBUILDUP == 1) @enumToInt(CFE_EFFECTS.MATHNOBUILDUP) else 0)
            | (if (o.MATH == 1) @enumToInt(CFE_EFFECTS.MATH) else 0)
            | (if (o.MATHORDINARY == 1) @enumToInt(CFE_EFFECTS.MATHORDINARY) else 0)
        );
    }
};
// TODO: enum 'CFE_EFFECTS' has known issues with its value aliases

pub const PARAFORMAT_MASK = enum(u32) {
    ALIGNMENT = 8,
    NUMBERING = 32,
    OFFSET = 4,
    OFFSETINDENT = 2147483648,
    RIGHTINDENT = 2,
    RTLPARA = 65536,
    STARTINDENT = 1,
    TABSTOPS = 16,
    _,
    pub fn initFlags(o: struct {
        ALIGNMENT: u1 = 0,
        NUMBERING: u1 = 0,
        OFFSET: u1 = 0,
        OFFSETINDENT: u1 = 0,
        RIGHTINDENT: u1 = 0,
        RTLPARA: u1 = 0,
        STARTINDENT: u1 = 0,
        TABSTOPS: u1 = 0,
    }) PARAFORMAT_MASK {
        return @intToEnum(PARAFORMAT_MASK,
              (if (o.ALIGNMENT == 1) @enumToInt(PARAFORMAT_MASK.ALIGNMENT) else 0)
            | (if (o.NUMBERING == 1) @enumToInt(PARAFORMAT_MASK.NUMBERING) else 0)
            | (if (o.OFFSET == 1) @enumToInt(PARAFORMAT_MASK.OFFSET) else 0)
            | (if (o.OFFSETINDENT == 1) @enumToInt(PARAFORMAT_MASK.OFFSETINDENT) else 0)
            | (if (o.RIGHTINDENT == 1) @enumToInt(PARAFORMAT_MASK.RIGHTINDENT) else 0)
            | (if (o.RTLPARA == 1) @enumToInt(PARAFORMAT_MASK.RTLPARA) else 0)
            | (if (o.STARTINDENT == 1) @enumToInt(PARAFORMAT_MASK.STARTINDENT) else 0)
            | (if (o.TABSTOPS == 1) @enumToInt(PARAFORMAT_MASK.TABSTOPS) else 0)
        );
    }
};
pub const PFM_ALIGNMENT = PARAFORMAT_MASK.ALIGNMENT;
pub const PFM_NUMBERING = PARAFORMAT_MASK.NUMBERING;
pub const PFM_OFFSET = PARAFORMAT_MASK.OFFSET;
pub const PFM_OFFSETINDENT = PARAFORMAT_MASK.OFFSETINDENT;
pub const PFM_RIGHTINDENT = PARAFORMAT_MASK.RIGHTINDENT;
pub const PFM_RTLPARA = PARAFORMAT_MASK.RTLPARA;
pub const PFM_STARTINDENT = PARAFORMAT_MASK.STARTINDENT;
pub const PFM_TABSTOPS = PARAFORMAT_MASK.TABSTOPS;

pub const RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE = enum(u16) {
    SEL_EMPTY = 0,
    SEL_TEXT = 1,
    SEL_OBJECT = 2,
    SEL_MULTICHAR = 4,
    SEL_MULTIOBJECT = 8,
    GCM_RIGHTMOUSEDROP = 32768,
    _,
    pub fn initFlags(o: struct {
        SEL_EMPTY: u1 = 0,
        SEL_TEXT: u1 = 0,
        SEL_OBJECT: u1 = 0,
        SEL_MULTICHAR: u1 = 0,
        SEL_MULTIOBJECT: u1 = 0,
        GCM_RIGHTMOUSEDROP: u1 = 0,
    }) RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE {
        return @intToEnum(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
              (if (o.SEL_EMPTY == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_EMPTY) else 0)
            | (if (o.SEL_TEXT == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_TEXT) else 0)
            | (if (o.SEL_OBJECT == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_OBJECT) else 0)
            | (if (o.SEL_MULTICHAR == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTICHAR) else 0)
            | (if (o.SEL_MULTIOBJECT == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTIOBJECT) else 0)
            | (if (o.GCM_RIGHTMOUSEDROP == 1) @enumToInt(RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.GCM_RIGHTMOUSEDROP) else 0)
        );
    }
};
pub const SEL_EMPTY = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_EMPTY;
pub const SEL_TEXT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_TEXT;
pub const SEL_OBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_OBJECT;
pub const SEL_MULTICHAR = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTICHAR;
pub const SEL_MULTIOBJECT = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.SEL_MULTIOBJECT;
pub const GCM_RIGHTMOUSEDROP = RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE.GCM_RIGHTMOUSEDROP;

pub const RICH_EDIT_GET_OBJECT_FLAGS = enum(u32) {
    POLEOBJ = 1,
    PSTG = 2,
    POLESITE = 4,
    NO_INTERFACES = 0,
    ALL_INTERFACES = 7,
    _,
    pub fn initFlags(o: struct {
        POLEOBJ: u1 = 0,
        PSTG: u1 = 0,
        POLESITE: u1 = 0,
        NO_INTERFACES: u1 = 0,
        ALL_INTERFACES: u1 = 0,
    }) RICH_EDIT_GET_OBJECT_FLAGS {
        return @intToEnum(RICH_EDIT_GET_OBJECT_FLAGS,
              (if (o.POLEOBJ == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.POLEOBJ) else 0)
            | (if (o.PSTG == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.PSTG) else 0)
            | (if (o.POLESITE == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.POLESITE) else 0)
            | (if (o.NO_INTERFACES == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.NO_INTERFACES) else 0)
            | (if (o.ALL_INTERFACES == 1) @enumToInt(RICH_EDIT_GET_OBJECT_FLAGS.ALL_INTERFACES) else 0)
        );
    }
};
pub const REO_GETOBJ_POLEOBJ = RICH_EDIT_GET_OBJECT_FLAGS.POLEOBJ;
pub const REO_GETOBJ_PSTG = RICH_EDIT_GET_OBJECT_FLAGS.PSTG;
pub const REO_GETOBJ_POLESITE = RICH_EDIT_GET_OBJECT_FLAGS.POLESITE;
pub const REO_GETOBJ_NO_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.NO_INTERFACES;
pub const REO_GETOBJ_ALL_INTERFACES = RICH_EDIT_GET_OBJECT_FLAGS.ALL_INTERFACES;

pub const PARAFORMAT_BORDERS = enum(u16) {
    LEFT = 1,
    RIGHT = 2,
    TOP = 4,
    BOTTOM = 8,
    INSIDE = 16,
    OUTSIDE = 32,
    AUTOCOLOR = 64,
    _,
    pub fn initFlags(o: struct {
        LEFT: u1 = 0,
        RIGHT: u1 = 0,
        TOP: u1 = 0,
        BOTTOM: u1 = 0,
        INSIDE: u1 = 0,
        OUTSIDE: u1 = 0,
        AUTOCOLOR: u1 = 0,
    }) PARAFORMAT_BORDERS {
        return @intToEnum(PARAFORMAT_BORDERS,
              (if (o.LEFT == 1) @enumToInt(PARAFORMAT_BORDERS.LEFT) else 0)
            | (if (o.RIGHT == 1) @enumToInt(PARAFORMAT_BORDERS.RIGHT) else 0)
            | (if (o.TOP == 1) @enumToInt(PARAFORMAT_BORDERS.TOP) else 0)
            | (if (o.BOTTOM == 1) @enumToInt(PARAFORMAT_BORDERS.BOTTOM) else 0)
            | (if (o.INSIDE == 1) @enumToInt(PARAFORMAT_BORDERS.INSIDE) else 0)
            | (if (o.OUTSIDE == 1) @enumToInt(PARAFORMAT_BORDERS.OUTSIDE) else 0)
            | (if (o.AUTOCOLOR == 1) @enumToInt(PARAFORMAT_BORDERS.AUTOCOLOR) else 0)
        );
    }
};
pub const PARAFORMAT_BORDERS_LEFT = PARAFORMAT_BORDERS.LEFT;
pub const PARAFORMAT_BORDERS_RIGHT = PARAFORMAT_BORDERS.RIGHT;
pub const PARAFORMAT_BORDERS_TOP = PARAFORMAT_BORDERS.TOP;
pub const PARAFORMAT_BORDERS_BOTTOM = PARAFORMAT_BORDERS.BOTTOM;
pub const PARAFORMAT_BORDERS_INSIDE = PARAFORMAT_BORDERS.INSIDE;
pub const PARAFORMAT_BORDERS_OUTSIDE = PARAFORMAT_BORDERS.OUTSIDE;
pub const PARAFORMAT_BORDERS_AUTOCOLOR = PARAFORMAT_BORDERS.AUTOCOLOR;

pub const PARAFORMAT_SHADING_STYLE = enum(u16) {
    NONE = 0,
    DARK_HORIZ = 1,
    DARK_VERT = 2,
    DARK_DOWN_DIAG = 3,
    DARK_UP_DIAG = 4,
    DARK_GRID = 5,
    DARK_TRELLIS = 6,
    LIGHT_HORZ = 7,
    LIGHT_VERT = 8,
    LIGHT_DOWN_DIAG = 9,
    LIGHT_UP_DIAG = 10,
    LIGHT_GRID = 11,
    LIGHT_TRELLIS = 12,
};
pub const PARAFORMAT_SHADING_STYLE_NONE = PARAFORMAT_SHADING_STYLE.NONE;
pub const PARAFORMAT_SHADING_STYLE_DARK_HORIZ = PARAFORMAT_SHADING_STYLE.DARK_HORIZ;
pub const PARAFORMAT_SHADING_STYLE_DARK_VERT = PARAFORMAT_SHADING_STYLE.DARK_VERT;
pub const PARAFORMAT_SHADING_STYLE_DARK_DOWN_DIAG = PARAFORMAT_SHADING_STYLE.DARK_DOWN_DIAG;
pub const PARAFORMAT_SHADING_STYLE_DARK_UP_DIAG = PARAFORMAT_SHADING_STYLE.DARK_UP_DIAG;
pub const PARAFORMAT_SHADING_STYLE_DARK_GRID = PARAFORMAT_SHADING_STYLE.DARK_GRID;
pub const PARAFORMAT_SHADING_STYLE_DARK_TRELLIS = PARAFORMAT_SHADING_STYLE.DARK_TRELLIS;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_HORZ = PARAFORMAT_SHADING_STYLE.LIGHT_HORZ;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_VERT = PARAFORMAT_SHADING_STYLE.LIGHT_VERT;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_DOWN_DIAG = PARAFORMAT_SHADING_STYLE.LIGHT_DOWN_DIAG;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_UP_DIAG = PARAFORMAT_SHADING_STYLE.LIGHT_UP_DIAG;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_GRID = PARAFORMAT_SHADING_STYLE.LIGHT_GRID;
pub const PARAFORMAT_SHADING_STYLE_LIGHT_TRELLIS = PARAFORMAT_SHADING_STYLE.LIGHT_TRELLIS;

pub const GETTEXTEX_FLAGS = enum(u32) {
    DEFAULT = 0,
    NOHIDDENTEXT = 8,
    RAWTEXT = 4,
    SELECTION = 2,
    USECRLF = 1,
};
pub const GT_DEFAULT = GETTEXTEX_FLAGS.DEFAULT;
pub const GT_NOHIDDENTEXT = GETTEXTEX_FLAGS.NOHIDDENTEXT;
pub const GT_RAWTEXT = GETTEXTEX_FLAGS.RAWTEXT;
pub const GT_SELECTION = GETTEXTEX_FLAGS.SELECTION;
pub const GT_USECRLF = GETTEXTEX_FLAGS.USECRLF;

pub const ENDCOMPOSITIONNOTIFY_CODE = enum(u32) {
    ENDCOMPOSITION = 1,
    NEWTEXT = 2,
};
pub const ECN_ENDCOMPOSITION = ENDCOMPOSITIONNOTIFY_CODE.ENDCOMPOSITION;
pub const ECN_NEWTEXT = ENDCOMPOSITIONNOTIFY_CODE.NEWTEXT;

pub const IMECOMPTEXT_FLAGS = enum(u32) {
    R = 1,
};
pub const ICT_RESULTREADSTR = IMECOMPTEXT_FLAGS.R;

pub const GETTEXTLENGTHEX_FLAGS = enum(u32) {
    DEFAULT = 0,
    USECRLF = 1,
    PRECISE = 2,
    CLOSE = 4,
    NUMCHARS = 8,
    NUMBYTES = 16,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        USECRLF: u1 = 0,
        PRECISE: u1 = 0,
        CLOSE: u1 = 0,
        NUMCHARS: u1 = 0,
        NUMBYTES: u1 = 0,
    }) GETTEXTLENGTHEX_FLAGS {
        return @intToEnum(GETTEXTLENGTHEX_FLAGS,
              (if (o.DEFAULT == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.DEFAULT) else 0)
            | (if (o.USECRLF == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.USECRLF) else 0)
            | (if (o.PRECISE == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.PRECISE) else 0)
            | (if (o.CLOSE == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.CLOSE) else 0)
            | (if (o.NUMCHARS == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.NUMCHARS) else 0)
            | (if (o.NUMBYTES == 1) @enumToInt(GETTEXTLENGTHEX_FLAGS.NUMBYTES) else 0)
        );
    }
};
pub const GTL_DEFAULT = GETTEXTLENGTHEX_FLAGS.DEFAULT;
pub const GTL_USECRLF = GETTEXTLENGTHEX_FLAGS.USECRLF;
pub const GTL_PRECISE = GETTEXTLENGTHEX_FLAGS.PRECISE;
pub const GTL_CLOSE = GETTEXTLENGTHEX_FLAGS.CLOSE;
pub const GTL_NUMCHARS = GETTEXTLENGTHEX_FLAGS.NUMCHARS;
pub const GTL_NUMBYTES = GETTEXTLENGTHEX_FLAGS.NUMBYTES;

pub const REOBJECT_FLAGS = enum(u32) {
    ALIGNTORIGHT = 256,
    BELOWBASELINE = 2,
    BLANK = 16,
    CANROTATE = 128,
    DONTNEEDPALETTE = 32,
    DYNAMICSIZE = 8,
    GETMETAFILE = 4194304,
    HILITED = 16777216,
    INPLACEACTIVE = 33554432,
    INVERTEDSELECT = 4,
    LINK = 2147483648,
    LINKAVAILABLE = 8388608,
    OPEN = 67108864,
    OWNERDRAWSELECT = 64,
    RESIZABLE = 1,
    SELECTED = 134217728,
    STATIC = 1073741824,
    USEASBACKGROUND = 1024,
    WRAPTEXTAROUND = 512,
    _,
    pub fn initFlags(o: struct {
        ALIGNTORIGHT: u1 = 0,
        BELOWBASELINE: u1 = 0,
        BLANK: u1 = 0,
        CANROTATE: u1 = 0,
        DONTNEEDPALETTE: u1 = 0,
        DYNAMICSIZE: u1 = 0,
        GETMETAFILE: u1 = 0,
        HILITED: u1 = 0,
        INPLACEACTIVE: u1 = 0,
        INVERTEDSELECT: u1 = 0,
        LINK: u1 = 0,
        LINKAVAILABLE: u1 = 0,
        OPEN: u1 = 0,
        OWNERDRAWSELECT: u1 = 0,
        RESIZABLE: u1 = 0,
        SELECTED: u1 = 0,
        STATIC: u1 = 0,
        USEASBACKGROUND: u1 = 0,
        WRAPTEXTAROUND: u1 = 0,
    }) REOBJECT_FLAGS {
        return @intToEnum(REOBJECT_FLAGS,
              (if (o.ALIGNTORIGHT == 1) @enumToInt(REOBJECT_FLAGS.ALIGNTORIGHT) else 0)
            | (if (o.BELOWBASELINE == 1) @enumToInt(REOBJECT_FLAGS.BELOWBASELINE) else 0)
            | (if (o.BLANK == 1) @enumToInt(REOBJECT_FLAGS.BLANK) else 0)
            | (if (o.CANROTATE == 1) @enumToInt(REOBJECT_FLAGS.CANROTATE) else 0)
            | (if (o.DONTNEEDPALETTE == 1) @enumToInt(REOBJECT_FLAGS.DONTNEEDPALETTE) else 0)
            | (if (o.DYNAMICSIZE == 1) @enumToInt(REOBJECT_FLAGS.DYNAMICSIZE) else 0)
            | (if (o.GETMETAFILE == 1) @enumToInt(REOBJECT_FLAGS.GETMETAFILE) else 0)
            | (if (o.HILITED == 1) @enumToInt(REOBJECT_FLAGS.HILITED) else 0)
            | (if (o.INPLACEACTIVE == 1) @enumToInt(REOBJECT_FLAGS.INPLACEACTIVE) else 0)
            | (if (o.INVERTEDSELECT == 1) @enumToInt(REOBJECT_FLAGS.INVERTEDSELECT) else 0)
            | (if (o.LINK == 1) @enumToInt(REOBJECT_FLAGS.LINK) else 0)
            | (if (o.LINKAVAILABLE == 1) @enumToInt(REOBJECT_FLAGS.LINKAVAILABLE) else 0)
            | (if (o.OPEN == 1) @enumToInt(REOBJECT_FLAGS.OPEN) else 0)
            | (if (o.OWNERDRAWSELECT == 1) @enumToInt(REOBJECT_FLAGS.OWNERDRAWSELECT) else 0)
            | (if (o.RESIZABLE == 1) @enumToInt(REOBJECT_FLAGS.RESIZABLE) else 0)
            | (if (o.SELECTED == 1) @enumToInt(REOBJECT_FLAGS.SELECTED) else 0)
            | (if (o.STATIC == 1) @enumToInt(REOBJECT_FLAGS.STATIC) else 0)
            | (if (o.USEASBACKGROUND == 1) @enumToInt(REOBJECT_FLAGS.USEASBACKGROUND) else 0)
            | (if (o.WRAPTEXTAROUND == 1) @enumToInt(REOBJECT_FLAGS.WRAPTEXTAROUND) else 0)
        );
    }
};
pub const REO_ALIGNTORIGHT = REOBJECT_FLAGS.ALIGNTORIGHT;
pub const REO_BELOWBASELINE = REOBJECT_FLAGS.BELOWBASELINE;
pub const REO_BLANK = REOBJECT_FLAGS.BLANK;
pub const REO_CANROTATE = REOBJECT_FLAGS.CANROTATE;
pub const REO_DONTNEEDPALETTE = REOBJECT_FLAGS.DONTNEEDPALETTE;
pub const REO_DYNAMICSIZE = REOBJECT_FLAGS.DYNAMICSIZE;
pub const REO_GETMETAFILE = REOBJECT_FLAGS.GETMETAFILE;
pub const REO_HILITED = REOBJECT_FLAGS.HILITED;
pub const REO_INPLACEACTIVE = REOBJECT_FLAGS.INPLACEACTIVE;
pub const REO_INVERTEDSELECT = REOBJECT_FLAGS.INVERTEDSELECT;
pub const REO_LINK = REOBJECT_FLAGS.LINK;
pub const REO_LINKAVAILABLE = REOBJECT_FLAGS.LINKAVAILABLE;
pub const REO_OPEN = REOBJECT_FLAGS.OPEN;
pub const REO_OWNERDRAWSELECT = REOBJECT_FLAGS.OWNERDRAWSELECT;
pub const REO_RESIZABLE = REOBJECT_FLAGS.RESIZABLE;
pub const REO_SELECTED = REOBJECT_FLAGS.SELECTED;
pub const REO_STATIC = REOBJECT_FLAGS.STATIC;
pub const REO_USEASBACKGROUND = REOBJECT_FLAGS.USEASBACKGROUND;
pub const REO_WRAPTEXTAROUND = REOBJECT_FLAGS.WRAPTEXTAROUND;

pub const PARAFORMAT_NUMBERING_STYLE = enum(u16) {
    PAREN = 0,
    PARENS = 256,
    PERIOD = 512,
    PLAIN = 768,
    NONUMBER = 1024,
    NEWNUMBER = 32768,
};
pub const PFNS_PAREN = PARAFORMAT_NUMBERING_STYLE.PAREN;
pub const PFNS_PARENS = PARAFORMAT_NUMBERING_STYLE.PARENS;
pub const PFNS_PERIOD = PARAFORMAT_NUMBERING_STYLE.PERIOD;
pub const PFNS_PLAIN = PARAFORMAT_NUMBERING_STYLE.PLAIN;
pub const PFNS_NONUMBER = PARAFORMAT_NUMBERING_STYLE.NONUMBER;
pub const PFNS_NEWNUMBER = PARAFORMAT_NUMBERING_STYLE.NEWNUMBER;

pub const PARAFORMAT_ALIGNMENT = enum(u16) {
    CENTER = 3,
    LEFT = 1,
    RIGHT = 2,
};
pub const PFA_CENTER = PARAFORMAT_ALIGNMENT.CENTER;
pub const PFA_LEFT = PARAFORMAT_ALIGNMENT.LEFT;
pub const PFA_RIGHT = PARAFORMAT_ALIGNMENT.RIGHT;

pub const TEXTMODE = enum(i32) {
    PLAINTEXT = 1,
    RICHTEXT = 2,
    SINGLELEVELUNDO = 4,
    MULTILEVELUNDO = 8,
    SINGLECODEPAGE = 16,
    MULTICODEPAGE = 32,
};
pub const TM_PLAINTEXT = TEXTMODE.PLAINTEXT;
pub const TM_RICHTEXT = TEXTMODE.RICHTEXT;
pub const TM_SINGLELEVELUNDO = TEXTMODE.SINGLELEVELUNDO;
pub const TM_MULTILEVELUNDO = TEXTMODE.MULTILEVELUNDO;
pub const TM_SINGLECODEPAGE = TEXTMODE.SINGLECODEPAGE;
pub const TM_MULTICODEPAGE = TEXTMODE.MULTICODEPAGE;

pub const IMECOMPTEXT = extern struct {
    cb: i32,
    flags: IMECOMPTEXT_FLAGS,
};

pub const TABLEROWPARMS = extern struct {
    cbRow: u8,
    cbCell: u8,
    cCell: u8,
    cRow: u8,
    dxCellMargin: i32,
    dxIndent: i32,
    dyHeight: i32,
    _bitfield: u32,
    cpStartRow: i32,
    bTableLevel: u8,
    iCell: u8,
};

pub const TABLECELLPARMS = extern struct {
    dxWidth: i32,
    _bitfield: u16,
    wShading: u16,
    dxBrdrLeft: i16,
    dyBrdrTop: i16,
    dxBrdrRight: i16,
    dyBrdrBottom: i16,
    crBrdrLeft: u32,
    crBrdrTop: u32,
    crBrdrRight: u32,
    crBrdrBottom: u32,
    crBackPat: u32,
    crForePat: u32,
};

pub const AutoCorrectProc = fn(
    langid: u16,
    pszBefore: ?[*:0]const u16,
    pszAfter: ?PWSTR,
    cchAfter: i32,
    pcchReplaced: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const RICHEDIT_IMAGE_PARAMETERS = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    xWidth: i32,
    yHeight: i32,
    Ascent: i32,
    Type: TEXT_ALIGN_OPTIONS,
    pwszAlternateText: ?[*:0]const u16,
    pIStream: ?*IStream,
};

pub const ENDCOMPOSITIONNOTIFY = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    dwCode: ENDCOMPOSITIONNOTIFY_CODE,
};

pub const EDITWORDBREAKPROCEX = fn(
    pchText: ?PSTR,
    cchText: i32,
    bCharSet: u8,
    action: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CHARFORMATA = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]CHAR,
};

pub const CHARFORMATW = extern struct {
    cbSize: u32,
    dwMask: CFM_MASK,
    dwEffects: CFE_EFFECTS,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]u16,
};

pub const CHARFORMAT2W = extern struct {
    __AnonymousBase_richedit_L711_C23: CHARFORMATW,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: extern union {
        dwReserved: u32,
        dwCookie: u32,
    },
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
};

pub const CHARFORMAT2A = extern struct {
    __AnonymousBase_richedit_L736_C23: CHARFORMATA,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: extern union {
        dwReserved: u32,
        dwCookie: u32,
    },
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
};

pub const CHARRANGE = extern struct {
    cpMin: i32,
    cpMax: i32,
};

pub const TEXTRANGEA = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    chrg: CHARRANGE,
    lpstrText: ?PSTR,
};

pub const TEXTRANGEW = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    chrg: CHARRANGE,
    lpstrText: ?PWSTR,
};

pub const EDITSTREAMCALLBACK = fn(
    dwCookie: usize,
    pbBuff: ?*u8,
    cb: i32,
    pcb: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const EDITSTREAM = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    dwCookie: usize,
    dwError: u32,
    pfnCallback: ?EDITSTREAMCALLBACK,
};

pub const FINDTEXTA = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    chrg: CHARRANGE,
    lpstrText: ?[*:0]const u8,
};

pub const FINDTEXTW = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    chrg: CHARRANGE,
    lpstrText: ?[*:0]const u16,
};

pub const FINDTEXTEXA = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    chrg: CHARRANGE,
    lpstrText: ?[*:0]const u8,
    chrgText: CHARRANGE,
};

pub const FINDTEXTEXW = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    chrg: CHARRANGE,
    lpstrText: ?[*:0]const u16,
    chrgText: CHARRANGE,
};

pub const FORMATRANGE = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    hdc: ?HDC,
    hdcTarget: ?HDC,
    rc: RECT,
    rcPage: RECT,
    chrg: CHARRANGE,
};

pub const PARAFORMAT = extern struct {
    cbSize: u32,
    dwMask: PARAFORMAT_MASK,
    wNumbering: u16,
    Anonymous: extern union {
        wReserved: u16,
        wEffects: u16,
    },
    dxStartIndent: i32,
    dxRightIndent: i32,
    dxOffset: i32,
    wAlignment: PARAFORMAT_ALIGNMENT,
    cTabCount: i16,
    rgxTabs: [32]u32,
};

pub const PARAFORMAT2 = extern struct {
    __AnonymousBase_richedit_L1149_C22: PARAFORMAT,
    dySpaceBefore: i32,
    dySpaceAfter: i32,
    dyLineSpacing: i32,
    sStyle: i16,
    bLineSpacingRule: u8,
    bOutlineLevel: u8,
    wShadingWeight: u16,
    wShadingStyle: PARAFORMAT_SHADING_STYLE,
    wNumberingStart: u16,
    wNumberingStyle: PARAFORMAT_NUMBERING_STYLE,
    wNumberingTab: u16,
    wBorderSpace: u16,
    wBorderWidth: u16,
    wBorders: PARAFORMAT_BORDERS,
};

pub const MSGFILTER = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};

pub const REQRESIZE = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    rc: RECT,
};

pub const SELCHANGE = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
};

pub const _grouptypingchange = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    fGroupTyping: BOOL,
};

pub const CLIPBOARDFORMAT = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    cf: u16,
};

pub const GETCONTEXTMENUEX = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    chrg: CHARRANGE,
    dwFlags: u32,
    pt: POINT,
    pvReserved: ?*anyopaque,
};

pub const ENDROPFILES = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    hDrop: ?HANDLE,
    cp: i32,
    fProtected: BOOL,
};

pub const ENPROTECTED = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};

pub const ENSAVECLIPBOARD = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    cObjectCount: i32,
    cch: i32,
};

pub const ENOLEOPFAILED = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    iob: i32,
    lOper: i32,
    hr: HRESULT,
};

pub const OBJECTPOSITIONS = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    cObjectCount: i32,
    pcpPositions: ?*i32,
};

pub const ENLINK = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};

pub const ENLOWFIRTF = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    szControl: ?PSTR,
};

pub const ENCORRECTTEXT = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
};

pub const PUNCTUATION = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    iSize: u32,
    szPunctuation: ?PSTR,
};

pub const COMPCOLOR = extern struct {
    crText: u32,
    crBackground: u32,
    dwEffects: u32,
};

pub const REPASTESPECIAL = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    dwAspect: DVASPECT,
    dwParam: usize,
};

pub const UNDONAMEID = enum(i32) {
    UNKNOWN = 0,
    TYPING = 1,
    DELETE = 2,
    DRAGDROP = 3,
    CUT = 4,
    PASTE = 5,
    AUTOTABLE = 6,
};
pub const UID_UNKNOWN = UNDONAMEID.UNKNOWN;
pub const UID_TYPING = UNDONAMEID.TYPING;
pub const UID_DELETE = UNDONAMEID.DELETE;
pub const UID_DRAGDROP = UNDONAMEID.DRAGDROP;
pub const UID_CUT = UNDONAMEID.CUT;
pub const UID_PASTE = UNDONAMEID.PASTE;
pub const UID_AUTOTABLE = UNDONAMEID.AUTOTABLE;

pub const SETTEXTEX = extern struct {
    flags: u32,
    codepage: u32,
};

pub const GETTEXTEX = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    cb: u32,
    flags: GETTEXTEX_FLAGS,
    codepage: u32,
    lpDefaultChar: ?[*:0]const u8,
    lpUsedDefChar: ?*i32,
};

pub const GETTEXTLENGTHEX = extern struct {
    flags: GETTEXTLENGTHEX_FLAGS,
    codepage: u32,
};

pub const BIDIOPTIONS = extern struct {
    cbSize: u32,
    wMask: u16,
    wEffects: u16,
};

pub const KHYPH = enum(i32) {
    Nil = 0,
    Normal = 1,
    AddBefore = 2,
    ChangeBefore = 3,
    DeleteBefore = 4,
    ChangeAfter = 5,
    DelAndChange = 6,
};
pub const khyphNil = KHYPH.Nil;
pub const khyphNormal = KHYPH.Normal;
pub const khyphAddBefore = KHYPH.AddBefore;
pub const khyphChangeBefore = KHYPH.ChangeBefore;
pub const khyphDeleteBefore = KHYPH.DeleteBefore;
pub const khyphChangeAfter = KHYPH.ChangeAfter;
pub const khyphDelAndChange = KHYPH.DelAndChange;

pub const hyphresult = extern struct {
    khyph: KHYPH,
    ichHyph: i32,
    chHyph: u16,
};

pub const HYPHENATEINFO = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    cbSize: i16,
    dxHyphenateZone: i16,
    pfnHyphenate: isize,
};

pub const TXTBACKSTYLE = enum(i32) {
    TRANSPARENT = 0,
    OPAQUE = 1,
};
pub const TXTBACK_TRANSPARENT = TXTBACKSTYLE.TRANSPARENT;
pub const TXTBACK_OPAQUE = TXTBACKSTYLE.OPAQUE;

pub const TXTHITRESULT = enum(i32) {
    NOHIT = 0,
    TRANSPARENT = 1,
    CLOSE = 2,
    HIT = 3,
};
pub const TXTHITRESULT_NOHIT = TXTHITRESULT.NOHIT;
pub const TXTHITRESULT_TRANSPARENT = TXTHITRESULT.TRANSPARENT;
pub const TXTHITRESULT_CLOSE = TXTHITRESULT.CLOSE;
pub const TXTHITRESULT_HIT = TXTHITRESULT.HIT;

pub const TXTNATURALSIZE = enum(i32) {
    FITTOCONTENT2 = 0,
    FITTOCONTENT = 1,
    ROUNDTOLINE = 2,
    FITTOCONTENT3 = 3,
    FITTOCONTENTWSP = 4,
    INCLUDELASTLINE = 1073741824,
    EMU = -2147483648,
};
pub const TXTNS_FITTOCONTENT2 = TXTNATURALSIZE.FITTOCONTENT2;
pub const TXTNS_FITTOCONTENT = TXTNATURALSIZE.FITTOCONTENT;
pub const TXTNS_ROUNDTOLINE = TXTNATURALSIZE.ROUNDTOLINE;
pub const TXTNS_FITTOCONTENT3 = TXTNATURALSIZE.FITTOCONTENT3;
pub const TXTNS_FITTOCONTENTWSP = TXTNATURALSIZE.FITTOCONTENTWSP;
pub const TXTNS_INCLUDELASTLINE = TXTNATURALSIZE.INCLUDELASTLINE;
pub const TXTNS_EMU = TXTNATURALSIZE.EMU;

pub const TXTVIEW = enum(i32) {
    ACTIVE = 0,
    INACTIVE = -1,
};
pub const TXTVIEW_ACTIVE = TXTVIEW.ACTIVE;
pub const TXTVIEW_INACTIVE = TXTVIEW.INACTIVE;

pub const CHANGETYPE = enum(i32) {
    GENERIC = 0,
    TEXTCHANGED = 1,
    NEWUNDO = 2,
    NEWREDO = 4,
};
pub const CN_GENERIC = CHANGETYPE.GENERIC;
pub const CN_TEXTCHANGED = CHANGETYPE.TEXTCHANGED;
pub const CN_NEWUNDO = CHANGETYPE.NEWUNDO;
pub const CN_NEWREDO = CHANGETYPE.NEWREDO;

pub const CHANGENOTIFY = extern struct {
    dwChangeType: CHANGETYPE,
    pvCookieData: ?*anyopaque,
};

pub const ITextServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxSendMessage: fn(
            self: *const ITextServices,
            msg: u32,
            wparam: WPARAM,
            lparam: LPARAM,
            plresult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDraw: fn(
            self: *const ITextServices,
            dwDrawAspect: DVASPECT,
            lindex: i32,
            pvAspect: ?*anyopaque,
            ptd: ?*DVTARGETDEVICE,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            lprcBounds: ?*RECTL,
            lprcWBounds: ?*RECTL,
            lprcUpdate: ?*RECT,
            pfnContinue: isize,
            dwContinue: u32,
            lViewId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHScroll: fn(
            self: *const ITextServices,
            plMin: ?*i32,
            plMax: ?*i32,
            plPos: ?*i32,
            plPage: ?*i32,
            pfEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetVScroll: fn(
            self: *const ITextServices,
            plMin: ?*i32,
            plMax: ?*i32,
            plPos: ?*i32,
            plPage: ?*i32,
            pfEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxSetCursor: fn(
            self: *const ITextServices,
            dwDrawAspect: DVASPECT,
            lindex: i32,
            pvAspect: ?*anyopaque,
            ptd: ?*DVTARGETDEVICE,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            lprcClient: ?*RECT,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxQueryHitPoint: fn(
            self: *const ITextServices,
            dwDrawAspect: DVASPECT,
            lindex: i32,
            pvAspect: ?*anyopaque,
            ptd: ?*DVTARGETDEVICE,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            lprcClient: ?*RECT,
            x: i32,
            y: i32,
            pHitResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceActivate: fn(
            self: *const ITextServices,
            prcClient: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceDeactivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIActivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIDeactivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetText: fn(
            self: *const ITextServices,
            pbstrText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetText: fn(
            self: *const ITextServices,
            pszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCurTargetX: fn(
            self: *const ITextServices,
            param0: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetBaseLinePos: fn(
            self: *const ITextServices,
            param0: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetNaturalSize: fn(
            self: *const ITextServices,
            dwAspect: u32,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            ptd: ?*DVTARGETDEVICE,
            dwMode: u32,
            psizelExtent: ?*const SIZE,
            pwidth: ?*i32,
            pheight: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetDropTarget: fn(
            self: *const ITextServices,
            ppDropTarget: ?*?*IDropTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxPropertyBitsChange: fn(
            self: *const ITextServices,
            dwMask: u32,
            dwBits: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCachedSize: fn(
            self: *const ITextServices,
            pdwWidth: ?*u32,
            pdwHeight: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxSendMessage(self: *const T, msg: u32, wparam: WPARAM, lparam: LPARAM, plresult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxSendMessage(@ptrCast(*const ITextServices, self), msg, wparam, lparam, plresult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxDraw(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: ?*anyopaque, ptd: ?*DVTARGETDEVICE, hdcDraw: ?HDC, hicTargetDev: ?HDC, lprcBounds: ?*RECTL, lprcWBounds: ?*RECTL, lprcUpdate: ?*RECT, pfnContinue: isize, dwContinue: u32, lViewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxDraw(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcBounds, lprcWBounds, lprcUpdate, pfnContinue, dwContinue, lViewId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetHScroll(self: *const T, plMin: ?*i32, plMax: ?*i32, plPos: ?*i32, plPage: ?*i32, pfEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetHScroll(@ptrCast(*const ITextServices, self), plMin, plMax, plPos, plPage, pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetVScroll(self: *const T, plMin: ?*i32, plMax: ?*i32, plPos: ?*i32, plPage: ?*i32, pfEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetVScroll(@ptrCast(*const ITextServices, self), plMin, plMax, plPos, plPage, pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxSetCursor(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: ?*anyopaque, ptd: ?*DVTARGETDEVICE, hdcDraw: ?HDC, hicTargetDev: ?HDC, lprcClient: ?*RECT, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxSetCursor(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxQueryHitPoint(self: *const T, dwDrawAspect: DVASPECT, lindex: i32, pvAspect: ?*anyopaque, ptd: ?*DVTARGETDEVICE, hdcDraw: ?HDC, hicTargetDev: ?HDC, lprcClient: ?*RECT, x: i32, y: i32, pHitResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxQueryHitPoint(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y, pHitResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxInPlaceActivate(self: *const T, prcClient: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxInPlaceActivate(@ptrCast(*const ITextServices, self), prcClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxInPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxInPlaceDeactivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxUIActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxUIActivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxUIDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxUIDeactivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetText(self: *const T, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetText(@ptrCast(*const ITextServices, self), pbstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxSetText(self: *const T, pszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxSetText(@ptrCast(*const ITextServices, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetCurTargetX(self: *const T, param0: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetCurTargetX(@ptrCast(*const ITextServices, self), param0);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetBaseLinePos(self: *const T, param0: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetBaseLinePos(@ptrCast(*const ITextServices, self), param0);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetNaturalSize(self: *const T, dwAspect: u32, hdcDraw: ?HDC, hicTargetDev: ?HDC, ptd: ?*DVTARGETDEVICE, dwMode: u32, psizelExtent: ?*const SIZE, pwidth: ?*i32, pheight: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetNaturalSize(@ptrCast(*const ITextServices, self), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetDropTarget(self: *const T, ppDropTarget: ?*?*IDropTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetDropTarget(@ptrCast(*const ITextServices, self), ppDropTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxPropertyBitsChange(self: *const T, dwMask: u32, dwBits: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxPropertyBitsChange(@ptrCast(*const ITextServices, self), dwMask, dwBits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetCachedSize(self: *const T, pdwWidth: ?*u32, pdwHeight: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetCachedSize(@ptrCast(*const ITextServices, self), pdwWidth, pdwHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CARET_FLAGS = enum(i32) {
    NONE = 0,
    CUSTOM = 1,
    RTL = 2,
    ITALIC = 32,
    NULL = 64,
    ROTATE90 = 128,
};
pub const CARET_NONE = CARET_FLAGS.NONE;
pub const CARET_CUSTOM = CARET_FLAGS.CUSTOM;
pub const CARET_RTL = CARET_FLAGS.RTL;
pub const CARET_ITALIC = CARET_FLAGS.ITALIC;
pub const CARET_NULL = CARET_FLAGS.NULL;
pub const CARET_ROTATE90 = CARET_FLAGS.ROTATE90;

pub const CARET_INFO = extern union {
    hbitmap: ?HBITMAP,
    caretFlags: CARET_FLAGS,
};

pub const ITextHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxGetDC: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) ?HDC,
        TxReleaseDC: fn(
            self: *const ITextHost,
            hdc: ?HDC,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        TxShowScrollBar: fn(
            self: *const ITextHost,
            fnBar: i32,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxEnableScrollBar: fn(
            self: *const ITextHost,
            fuSBFlags: SCROLLBAR_CONSTANTS,
            fuArrowflags: ENABLE_SCROLL_BAR_ARROWS,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollRange: fn(
            self: *const ITextHost,
            fnBar: i32,
            nMinPos: i32,
            nMaxPos: i32,
            fRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollPos: fn(
            self: *const ITextHost,
            fnBar: i32,
            nPos: i32,
            fRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxInvalidateRect: fn(
            self: *const ITextHost,
            prc: ?*RECT,
            fMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxViewChange: fn(
            self: *const ITextHost,
            fUpdate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxCreateCaret: fn(
            self: *const ITextHost,
            hbmp: ?HBITMAP,
            xWidth: i32,
            yHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxShowCaret: fn(
            self: *const ITextHost,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetCaretPos: fn(
            self: *const ITextHost,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetTimer: fn(
            self: *const ITextHost,
            idTimer: u32,
            uTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxKillTimer: fn(
            self: *const ITextHost,
            idTimer: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScrollWindowEx: fn(
            self: *const ITextHost,
            dx: i32,
            dy: i32,
            lprcScroll: ?*RECT,
            lprcClip: ?*RECT,
            hrgnUpdate: ?HRGN,
            lprcUpdate: ?*RECT,
            fuScroll: SHOW_WINDOW_CMD,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCapture: fn(
            self: *const ITextHost,
            fCapture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetFocus: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCursor: fn(
            self: *const ITextHost,
            hcur: ?HCURSOR,
            fText: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScreenToClient: fn(
            self: *const ITextHost,
            lppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxClientToScreen: fn(
            self: *const ITextHost,
            lppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxActivate: fn(
            self: *const ITextHost,
            plOldState: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDeactivate: fn(
            self: *const ITextHost,
            lNewState: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetClientRect: fn(
            self: *const ITextHost,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetViewInset: fn(
            self: *const ITextHost,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCharFormat: fn(
            self: *const ITextHost,
            ppCF: ?*const ?*CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetParaFormat: fn(
            self: *const ITextHost,
            ppPF: ?*const ?*PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetSysColor: fn(
            self: *const ITextHost,
            nIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        TxGetBackStyle: fn(
            self: *const ITextHost,
            pstyle: ?*TXTBACKSTYLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetMaxLength: fn(
            self: *const ITextHost,
            plength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetScrollBars: fn(
            self: *const ITextHost,
            pdwScrollBar: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPasswordChar: fn(
            self: *const ITextHost,
            pch: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetAcceleratorPos: fn(
            self: *const ITextHost,
            pcp: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetExtent: fn(
            self: *const ITextHost,
            lpExtent: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxCharFormatChange: fn(
            self: *const ITextHost,
            pCF: ?*const CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxParaFormatChange: fn(
            self: *const ITextHost,
            pPF: ?*const PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPropertyBits: fn(
            self: *const ITextHost,
            dwMask: u32,
            pdwBits: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxNotify: fn(
            self: *const ITextHost,
            iNotify: u32,
            pv: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxImmGetContext: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) ?HIMC,
        TxImmReleaseContext: fn(
            self: *const ITextHost,
            himc: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetSelectionBarWidth: fn(
            self: *const ITextHost,
            lSelBarWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetDC(self: *const T) callconv(.Inline) ?HDC {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetDC(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxReleaseDC(self: *const T, hdc: ?HDC) callconv(.Inline) i32 {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxReleaseDC(@ptrCast(*const ITextHost, self), hdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxShowScrollBar(self: *const T, fnBar: i32, fShow: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxShowScrollBar(@ptrCast(*const ITextHost, self), fnBar, fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxEnableScrollBar(self: *const T, fuSBFlags: SCROLLBAR_CONSTANTS, fuArrowflags: ENABLE_SCROLL_BAR_ARROWS) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxEnableScrollBar(@ptrCast(*const ITextHost, self), fuSBFlags, fuArrowflags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetScrollRange(self: *const T, fnBar: i32, nMinPos: i32, nMaxPos: i32, fRedraw: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetScrollRange(@ptrCast(*const ITextHost, self), fnBar, nMinPos, nMaxPos, fRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetScrollPos(self: *const T, fnBar: i32, nPos: i32, fRedraw: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetScrollPos(@ptrCast(*const ITextHost, self), fnBar, nPos, fRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxInvalidateRect(self: *const T, prc: ?*RECT, fMode: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxInvalidateRect(@ptrCast(*const ITextHost, self), prc, fMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxViewChange(self: *const T, fUpdate: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxViewChange(@ptrCast(*const ITextHost, self), fUpdate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxCreateCaret(self: *const T, hbmp: ?HBITMAP, xWidth: i32, yHeight: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxCreateCaret(@ptrCast(*const ITextHost, self), hbmp, xWidth, yHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxShowCaret(self: *const T, fShow: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxShowCaret(@ptrCast(*const ITextHost, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCaretPos(self: *const T, x: i32, y: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCaretPos(@ptrCast(*const ITextHost, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetTimer(self: *const T, idTimer: u32, uTimeout: u32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetTimer(@ptrCast(*const ITextHost, self), idTimer, uTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxKillTimer(self: *const T, idTimer: u32) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxKillTimer(@ptrCast(*const ITextHost, self), idTimer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxScrollWindowEx(self: *const T, dx: i32, dy: i32, lprcScroll: ?*RECT, lprcClip: ?*RECT, hrgnUpdate: ?HRGN, lprcUpdate: ?*RECT, fuScroll: SHOW_WINDOW_CMD) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxScrollWindowEx(@ptrCast(*const ITextHost, self), dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate, fuScroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCapture(self: *const T, fCapture: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCapture(@ptrCast(*const ITextHost, self), fCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetFocus(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetFocus(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCursor(self: *const T, hcur: ?HCURSOR, fText: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCursor(@ptrCast(*const ITextHost, self), hcur, fText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxScreenToClient(self: *const T, lppt: ?*POINT) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxScreenToClient(@ptrCast(*const ITextHost, self), lppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxClientToScreen(self: *const T, lppt: ?*POINT) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxClientToScreen(@ptrCast(*const ITextHost, self), lppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxActivate(self: *const T, plOldState: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxActivate(@ptrCast(*const ITextHost, self), plOldState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxDeactivate(self: *const T, lNewState: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxDeactivate(@ptrCast(*const ITextHost, self), lNewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetClientRect(self: *const T, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetClientRect(@ptrCast(*const ITextHost, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetViewInset(self: *const T, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetViewInset(@ptrCast(*const ITextHost, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetCharFormat(self: *const T, ppCF: ?*const ?*CHARFORMATW) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetCharFormat(@ptrCast(*const ITextHost, self), ppCF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetParaFormat(self: *const T, ppPF: ?*const ?*PARAFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetParaFormat(@ptrCast(*const ITextHost, self), ppPF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetSysColor(self: *const T, nIndex: i32) callconv(.Inline) u32 {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetSysColor(@ptrCast(*const ITextHost, self), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetBackStyle(self: *const T, pstyle: ?*TXTBACKSTYLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetBackStyle(@ptrCast(*const ITextHost, self), pstyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetMaxLength(self: *const T, plength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetMaxLength(@ptrCast(*const ITextHost, self), plength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetScrollBars(self: *const T, pdwScrollBar: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetScrollBars(@ptrCast(*const ITextHost, self), pdwScrollBar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetPasswordChar(self: *const T, pch: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetPasswordChar(@ptrCast(*const ITextHost, self), pch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetAcceleratorPos(self: *const T, pcp: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetAcceleratorPos(@ptrCast(*const ITextHost, self), pcp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetExtent(self: *const T, lpExtent: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetExtent(@ptrCast(*const ITextHost, self), lpExtent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_OnTxCharFormatChange(self: *const T, pCF: ?*const CHARFORMATW) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).OnTxCharFormatChange(@ptrCast(*const ITextHost, self), pCF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_OnTxParaFormatChange(self: *const T, pPF: ?*const PARAFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).OnTxParaFormatChange(@ptrCast(*const ITextHost, self), pPF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetPropertyBits(self: *const T, dwMask: u32, pdwBits: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetPropertyBits(@ptrCast(*const ITextHost, self), dwMask, pdwBits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxNotify(self: *const T, iNotify: u32, pv: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxNotify(@ptrCast(*const ITextHost, self), iNotify, pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxImmGetContext(self: *const T) callconv(.Inline) ?HIMC {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxImmGetContext(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxImmReleaseContext(self: *const T, himc: ?HIMC) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxImmReleaseContext(@ptrCast(*const ITextHost, self), himc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetSelectionBarWidth(self: *const T, lSelBarWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetSelectionBarWidth(@ptrCast(*const ITextHost, self), lSelBarWidth);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
pub const IRicheditUiaOverrides = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyOverrideValue: fn(
            self: *const IRicheditUiaOverrides,
            propertyId: i32,
            pRetValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRicheditUiaOverrides_GetPropertyOverrideValue(self: *const T, propertyId: i32, pRetValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRicheditUiaOverrides.VTable, self.vtable).GetPropertyOverrideValue(@ptrCast(*const IRicheditUiaOverrides, self), propertyId, pRetValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PCreateTextServices = fn(
    punkOuter: ?*IUnknown,
    pITextHost: ?*ITextHost,
    ppUnk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PShutdownTextServices = fn(
    pTextServices: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const ITextHost2 = extern struct {
    pub const VTable = extern struct {
        base: ITextHost.VTable,
        TxIsDoubleClickPending: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxGetWindow: fn(
            self: *const ITextHost2,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetForegroundWindow: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPalette: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) ?HPALETTE,
        TxGetEastAsianFlags: fn(
            self: *const ITextHost2,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetCursor2: fn(
            self: *const ITextHost2,
            hcur: ?HCURSOR,
            bText: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) ?HCURSOR,
        TxFreeTextServicesNotification: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetEditStyle: fn(
            self: *const ITextHost2,
            dwItem: u32,
            pdwData: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetWindowStyles: fn(
            self: *const ITextHost2,
            pdwStyle: ?*u32,
            pdwExStyle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxShowDropCaret: fn(
            self: *const ITextHost2,
            fShow: BOOL,
            hdc: ?HDC,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDestroyCaret: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHorzExtent: fn(
            self: *const ITextHost2,
            plHorzExtent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextHost.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxIsDoubleClickPending(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxIsDoubleClickPending(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetWindow(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetWindow(@ptrCast(*const ITextHost2, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxSetForegroundWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxSetForegroundWindow(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetPalette(self: *const T) callconv(.Inline) ?HPALETTE {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetPalette(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetEastAsianFlags(self: *const T, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetEastAsianFlags(@ptrCast(*const ITextHost2, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxSetCursor2(self: *const T, hcur: ?HCURSOR, bText: BOOL) callconv(.Inline) ?HCURSOR {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxSetCursor2(@ptrCast(*const ITextHost2, self), hcur, bText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxFreeTextServicesNotification(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxFreeTextServicesNotification(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetEditStyle(self: *const T, dwItem: u32, pdwData: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetEditStyle(@ptrCast(*const ITextHost2, self), dwItem, pdwData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetWindowStyles(self: *const T, pdwStyle: ?*u32, pdwExStyle: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetWindowStyles(@ptrCast(*const ITextHost2, self), pdwStyle, pdwExStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxShowDropCaret(self: *const T, fShow: BOOL, hdc: ?HDC, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxShowDropCaret(@ptrCast(*const ITextHost2, self), fShow, hdc, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxDestroyCaret(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxDestroyCaret(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetHorzExtent(self: *const T, plHorzExtent: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetHorzExtent(@ptrCast(*const ITextHost2, self), plHorzExtent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ITextServices2 = extern struct {
    pub const VTable = extern struct {
        base: ITextServices.VTable,
        TxGetNaturalSize2: fn(
            self: *const ITextServices2,
            dwAspect: u32,
            hdcDraw: ?HDC,
            hicTargetDev: ?HDC,
            ptd: ?*DVTARGETDEVICE,
            dwMode: u32,
            psizelExtent: ?*const SIZE,
            pwidth: ?*i32,
            pheight: ?*i32,
            pascent: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDrawD2D: fn(
            self: *const ITextServices2,
            pRenderTarget: ?*ID2D1RenderTarget,
            lprcBounds: ?*RECTL,
            lprcUpdate: ?*RECT,
            lViewId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextServices.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices2_TxGetNaturalSize2(self: *const T, dwAspect: u32, hdcDraw: ?HDC, hicTargetDev: ?HDC, ptd: ?*DVTARGETDEVICE, dwMode: u32, psizelExtent: ?*const SIZE, pwidth: ?*i32, pheight: ?*i32, pascent: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices2.VTable, self.vtable).TxGetNaturalSize2(@ptrCast(*const ITextServices2, self), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight, pascent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices2_TxDrawD2D(self: *const T, pRenderTarget: ?*ID2D1RenderTarget, lprcBounds: ?*RECTL, lprcUpdate: ?*RECT, lViewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices2.VTable, self.vtable).TxDrawD2D(@ptrCast(*const ITextServices2, self), pRenderTarget, lprcBounds, lprcUpdate, lViewId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const REOBJECT = extern struct {
    cbStruct: u32,
    cp: i32,
    clsid: Guid,
    poleobj: ?*IOleObject,
    pstg: ?*IStorage,
    polesite: ?*IOleClientSite,
    sizel: SIZE,
    dvaspect: u32,
    dwFlags: REOBJECT_FLAGS,
    dwUser: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOle_Value = @import("../../zig.zig").Guid.initString("00020d00-0000-0000-c000-000000000046");
pub const IID_IRichEditOle = &IID_IRichEditOle_Value;
pub const IRichEditOle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientSite: fn(
            self: *const IRichEditOle,
            lplpolesite: ?*?*IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectCount: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetLinkCount: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetObject: fn(
            self: *const IRichEditOle,
            iob: i32,
            lpreobject: ?*REOBJECT,
            dwFlags: RICH_EDIT_GET_OBJECT_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertObject: fn(
            self: *const IRichEditOle,
            lpreobject: ?*REOBJECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertObject: fn(
            self: *const IRichEditOle,
            iob: i32,
            rclsidNew: ?*const Guid,
            lpstrUserTypeNew: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAs: fn(
            self: *const IRichEditOle,
            rclsid: ?*const Guid,
            rclsidAs: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHostNames: fn(
            self: *const IRichEditOle,
            lpstrContainerApp: ?[*:0]const u8,
            lpstrContainerObj: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLinkAvailable: fn(
            self: *const IRichEditOle,
            iob: i32,
            fAvailable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDvaspect: fn(
            self: *const IRichEditOle,
            iob: i32,
            dvaspect: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandsOffStorage: fn(
            self: *const IRichEditOle,
            iob: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: fn(
            self: *const IRichEditOle,
            iob: i32,
            lpstg: ?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InPlaceDeactivate: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: fn(
            self: *const IRichEditOle,
            fEnterMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: fn(
            self: *const IRichEditOle,
            lpchrg: ?*CHARRANGE,
            reco: u32,
            lplpdataobj: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportDataObject: fn(
            self: *const IRichEditOle,
            lpdataobj: ?*IDataObject,
            cf: u16,
            hMetaPict: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetClientSite(self: *const T, lplpolesite: ?*?*IOleClientSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetClientSite(@ptrCast(*const IRichEditOle, self), lplpolesite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetObjectCount(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetObjectCount(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetLinkCount(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetLinkCount(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetObject(self: *const T, iob: i32, lpreobject: ?*REOBJECT, dwFlags: RICH_EDIT_GET_OBJECT_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetObject(@ptrCast(*const IRichEditOle, self), iob, lpreobject, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_InsertObject(self: *const T, lpreobject: ?*REOBJECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).InsertObject(@ptrCast(*const IRichEditOle, self), lpreobject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ConvertObject(self: *const T, iob: i32, rclsidNew: ?*const Guid, lpstrUserTypeNew: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ConvertObject(@ptrCast(*const IRichEditOle, self), iob, rclsidNew, lpstrUserTypeNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ActivateAs(self: *const T, rclsid: ?*const Guid, rclsidAs: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ActivateAs(@ptrCast(*const IRichEditOle, self), rclsid, rclsidAs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetHostNames(self: *const T, lpstrContainerApp: ?[*:0]const u8, lpstrContainerObj: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetHostNames(@ptrCast(*const IRichEditOle, self), lpstrContainerApp, lpstrContainerObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetLinkAvailable(self: *const T, iob: i32, fAvailable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetLinkAvailable(@ptrCast(*const IRichEditOle, self), iob, fAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetDvaspect(self: *const T, iob: i32, dvaspect: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetDvaspect(@ptrCast(*const IRichEditOle, self), iob, dvaspect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_HandsOffStorage(self: *const T, iob: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).HandsOffStorage(@ptrCast(*const IRichEditOle, self), iob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SaveCompleted(self: *const T, iob: i32, lpstg: ?*IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SaveCompleted(@ptrCast(*const IRichEditOle, self), iob, lpstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_InPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).InPlaceDeactivate(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ContextSensitiveHelp(@ptrCast(*const IRichEditOle, self), fEnterMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetClipboardData(self: *const T, lpchrg: ?*CHARRANGE, reco: u32, lplpdataobj: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetClipboardData(@ptrCast(*const IRichEditOle, self), lpchrg, reco, lplpdataobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ImportDataObject(self: *const T, lpdataobj: ?*IDataObject, cf: u16, hMetaPict: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ImportDataObject(@ptrCast(*const IRichEditOle, self), lpdataobj, cf, hMetaPict);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRichEditOleCallback_Value = @import("../../zig.zig").Guid.initString("00020d03-0000-0000-c000-000000000046");
pub const IID_IRichEditOleCallback = &IID_IRichEditOleCallback_Value;
pub const IRichEditOleCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNewStorage: fn(
            self: *const IRichEditOleCallback,
            lplpstg: ?*?*IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInPlaceContext: fn(
            self: *const IRichEditOleCallback,
            lplpFrame: ?*?*IOleInPlaceFrame,
            lplpDoc: ?*?*IOleInPlaceUIWindow,
            lpFrameInfo: ?*OIFI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowContainerUI: fn(
            self: *const IRichEditOleCallback,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertObject: fn(
            self: *const IRichEditOleCallback,
            lpclsid: ?*Guid,
            lpstg: ?*IStorage,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteObject: fn(
            self: *const IRichEditOleCallback,
            lpoleobj: ?*IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAcceptData: fn(
            self: *const IRichEditOleCallback,
            lpdataobj: ?*IDataObject,
            lpcfFormat: ?*u16,
            reco: u32,
            fReally: BOOL,
            hMetaPict: isize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: fn(
            self: *const IRichEditOleCallback,
            fEnterMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: fn(
            self: *const IRichEditOleCallback,
            lpchrg: ?*CHARRANGE,
            reco: u32,
            lplpdataobj: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDragDropEffect: fn(
            self: *const IRichEditOleCallback,
            fDrag: BOOL,
            grfKeyState: u32,
            pdwEffect: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextMenu: fn(
            self: *const IRichEditOleCallback,
            seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE,
            lpoleobj: ?*IOleObject,
            lpchrg: ?*CHARRANGE,
            lphmenu: ?*?HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetNewStorage(self: *const T, lplpstg: ?*?*IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetNewStorage(@ptrCast(*const IRichEditOleCallback, self), lplpstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetInPlaceContext(self: *const T, lplpFrame: ?*?*IOleInPlaceFrame, lplpDoc: ?*?*IOleInPlaceUIWindow, lpFrameInfo: ?*OIFI) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetInPlaceContext(@ptrCast(*const IRichEditOleCallback, self), lplpFrame, lplpDoc, lpFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_ShowContainerUI(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).ShowContainerUI(@ptrCast(*const IRichEditOleCallback, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_QueryInsertObject(self: *const T, lpclsid: ?*Guid, lpstg: ?*IStorage, cp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).QueryInsertObject(@ptrCast(*const IRichEditOleCallback, self), lpclsid, lpstg, cp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_DeleteObject(self: *const T, lpoleobj: ?*IOleObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).DeleteObject(@ptrCast(*const IRichEditOleCallback, self), lpoleobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_QueryAcceptData(self: *const T, lpdataobj: ?*IDataObject, lpcfFormat: ?*u16, reco: u32, fReally: BOOL, hMetaPict: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).QueryAcceptData(@ptrCast(*const IRichEditOleCallback, self), lpdataobj, lpcfFormat, reco, fReally, hMetaPict);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).ContextSensitiveHelp(@ptrCast(*const IRichEditOleCallback, self), fEnterMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetClipboardData(self: *const T, lpchrg: ?*CHARRANGE, reco: u32, lplpdataobj: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetClipboardData(@ptrCast(*const IRichEditOleCallback, self), lpchrg, reco, lplpdataobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetDragDropEffect(self: *const T, fDrag: BOOL, grfKeyState: u32, pdwEffect: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetDragDropEffect(@ptrCast(*const IRichEditOleCallback, self), fDrag, grfKeyState, pdwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetContextMenu(self: *const T, seltype: RICH_EDIT_GET_CONTEXT_MENU_SEL_TYPE, lpoleobj: ?*IOleObject, lpchrg: ?*CHARRANGE, lphmenu: ?*?HMENU) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetContextMenu(@ptrCast(*const IRichEditOleCallback, self), seltype, lpoleobj, lpchrg, lphmenu);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const tomConstants = enum(i32) {
    False = 0,
    True = -1,
    Undefined = -9999999,
    Toggle = -9999998,
    AutoColor = -9999997,
    Default = -9999996,
    Suspend = -9999995,
    Resume = -9999994,
    // ApplyNow = 0, this enum value conflicts with False
    ApplyLater = 1,
    TrackParms = 2,
    CacheParms = 3,
    ApplyTmp = 4,
    DisableSmartFont = 8,
    EnableSmartFont = 9,
    UsePoints = 10,
    UseTwips = 11,
    Backward = -1073741823,
    Forward = 1073741823,
    // Move = 0, this enum value conflicts with False
    // Extend = 1, this enum value conflicts with ApplyLater
    // NoSelection = 0, this enum value conflicts with False
    // SelectionIP = 1, this enum value conflicts with ApplyLater
    // SelectionNormal = 2, this enum value conflicts with TrackParms
    // SelectionFrame = 3, this enum value conflicts with CacheParms
    // SelectionColumn = 4, this enum value conflicts with ApplyTmp
    SelectionRow = 5,
    SelectionBlock = 6,
    SelectionInlineShape = 7,
    // SelectionShape = 8, this enum value conflicts with DisableSmartFont
    // SelStartActive = 1, this enum value conflicts with ApplyLater
    // SelAtEOL = 2, this enum value conflicts with TrackParms
    // SelOvertype = 4, this enum value conflicts with ApplyTmp
    // SelActive = 8, this enum value conflicts with DisableSmartFont
    SelReplace = 16,
    // End = 0, this enum value conflicts with False
    Start = 32,
    // CollapseEnd = 0, this enum value conflicts with False
    // CollapseStart = 1, this enum value conflicts with ApplyLater
    ClientCoord = 256,
    AllowOffClient = 512,
    Transform = 1024,
    ObjectArg = 2048,
    AtEnd = 4096,
    // None = 0, this enum value conflicts with False
    // Single = 1, this enum value conflicts with ApplyLater
    // Words = 2, this enum value conflicts with TrackParms
    // Double = 3, this enum value conflicts with CacheParms
    // Dotted = 4, this enum value conflicts with ApplyTmp
    // Dash = 5, this enum value conflicts with SelectionRow
    // DashDot = 6, this enum value conflicts with SelectionBlock
    // DashDotDot = 7, this enum value conflicts with SelectionInlineShape
    // Wave = 8, this enum value conflicts with DisableSmartFont
    // Thick = 9, this enum value conflicts with EnableSmartFont
    // Hair = 10, this enum value conflicts with UsePoints
    // DoubleWave = 11, this enum value conflicts with UseTwips
    HeavyWave = 12,
    LongDash = 13,
    ThickDash = 14,
    ThickDashDot = 15,
    // ThickDashDotDot = 16, this enum value conflicts with SelReplace
    ThickDotted = 17,
    ThickLongDash = 18,
    // LineSpaceSingle = 0, this enum value conflicts with False
    // LineSpace1pt5 = 1, this enum value conflicts with ApplyLater
    // LineSpaceDouble = 2, this enum value conflicts with TrackParms
    // LineSpaceAtLeast = 3, this enum value conflicts with CacheParms
    // LineSpaceExactly = 4, this enum value conflicts with ApplyTmp
    // LineSpaceMultiple = 5, this enum value conflicts with SelectionRow
    // LineSpacePercent = 6, this enum value conflicts with SelectionBlock
    // AlignLeft = 0, this enum value conflicts with False
    // AlignCenter = 1, this enum value conflicts with ApplyLater
    // AlignRight = 2, this enum value conflicts with TrackParms
    // AlignJustify = 3, this enum value conflicts with CacheParms
    // AlignDecimal = 3, this enum value conflicts with CacheParms
    // AlignBar = 4, this enum value conflicts with ApplyTmp
    // DefaultTab = 5, this enum value conflicts with SelectionRow
    // AlignInterWord = 3, this enum value conflicts with CacheParms
    // AlignNewspaper = 4, this enum value conflicts with ApplyTmp
    // AlignInterLetter = 5, this enum value conflicts with SelectionRow
    // AlignScaled = 6, this enum value conflicts with SelectionBlock
    // Spaces = 0, this enum value conflicts with False
    // Dots = 1, this enum value conflicts with ApplyLater
    // Dashes = 2, this enum value conflicts with TrackParms
    // Lines = 3, this enum value conflicts with CacheParms
    // ThickLines = 4, this enum value conflicts with ApplyTmp
    // Equals = 5, this enum value conflicts with SelectionRow
    TabBack = -3,
    TabNext = -2,
    // TabHere = -1, this enum value conflicts with True
    // ListNone = 0, this enum value conflicts with False
    // ListBullet = 1, this enum value conflicts with ApplyLater
    // ListNumberAsArabic = 2, this enum value conflicts with TrackParms
    // ListNumberAsLCLetter = 3, this enum value conflicts with CacheParms
    // ListNumberAsUCLetter = 4, this enum value conflicts with ApplyTmp
    // ListNumberAsLCRoman = 5, this enum value conflicts with SelectionRow
    // ListNumberAsUCRoman = 6, this enum value conflicts with SelectionBlock
    // ListNumberAsSequence = 7, this enum value conflicts with SelectionInlineShape
    // ListNumberedCircle = 8, this enum value conflicts with DisableSmartFont
    // ListNumberedBlackCircleWingding = 9, this enum value conflicts with EnableSmartFont
    // ListNumberedWhiteCircleWingding = 10, this enum value conflicts with UsePoints
    // ListNumberedArabicWide = 11, this enum value conflicts with UseTwips
    // ListNumberedChS = 12, this enum value conflicts with HeavyWave
    // ListNumberedChT = 13, this enum value conflicts with LongDash
    // ListNumberedJpnChS = 14, this enum value conflicts with ThickDash
    // ListNumberedJpnKor = 15, this enum value conflicts with ThickDashDot
    // ListNumberedArabic1 = 16, this enum value conflicts with SelReplace
    // ListNumberedArabic2 = 17, this enum value conflicts with ThickDotted
    // ListNumberedHebrew = 18, this enum value conflicts with ThickLongDash
    ListNumberedThaiAlpha = 19,
    ListNumberedThaiNum = 20,
    ListNumberedHindiAlpha = 21,
    ListNumberedHindiAlpha1 = 22,
    ListNumberedHindiNum = 23,
    ListParentheses = 65536,
    ListPeriod = 131072,
    ListPlain = 196608,
    ListNoNumber = 262144,
    ListMinus = 524288,
    IgnoreNumberStyle = 16777216,
    // ParaStyleNormal = -1, this enum value conflicts with True
    // ParaStyleHeading1 = -2, this enum value conflicts with TabNext
    // ParaStyleHeading2 = -3, this enum value conflicts with TabBack
    ParaStyleHeading3 = -4,
    ParaStyleHeading4 = -5,
    ParaStyleHeading5 = -6,
    ParaStyleHeading6 = -7,
    ParaStyleHeading7 = -8,
    ParaStyleHeading8 = -9,
    ParaStyleHeading9 = -10,
    // Character = 1, this enum value conflicts with ApplyLater
    // Word = 2, this enum value conflicts with TrackParms
    // Sentence = 3, this enum value conflicts with CacheParms
    // Paragraph = 4, this enum value conflicts with ApplyTmp
    // Line = 5, this enum value conflicts with SelectionRow
    // Story = 6, this enum value conflicts with SelectionBlock
    // Screen = 7, this enum value conflicts with SelectionInlineShape
    // Section = 8, this enum value conflicts with DisableSmartFont
    // TableColumn = 9, this enum value conflicts with EnableSmartFont
    // Column = 9, this enum value conflicts with EnableSmartFont
    // Row = 10, this enum value conflicts with UsePoints
    // Window = 11, this enum value conflicts with UseTwips
    // Cell = 12, this enum value conflicts with HeavyWave
    // CharFormat = 13, this enum value conflicts with LongDash
    // ParaFormat = 14, this enum value conflicts with ThickDash
    // Table = 15, this enum value conflicts with ThickDashDot
    // Object = 16, this enum value conflicts with SelReplace
    // Page = 17, this enum value conflicts with ThickDotted
    // HardParagraph = 18, this enum value conflicts with ThickLongDash
    // Cluster = 19, this enum value conflicts with ListNumberedThaiAlpha
    // InlineObject = 20, this enum value conflicts with ListNumberedThaiNum
    // InlineObjectArg = 21, this enum value conflicts with ListNumberedHindiAlpha
    // LeafLine = 22, this enum value conflicts with ListNumberedHindiAlpha1
    // LayoutColumn = 23, this enum value conflicts with ListNumberedHindiNum
    ProcessId = 1073741825,
    // MatchWord = 2, this enum value conflicts with TrackParms
    // MatchCase = 4, this enum value conflicts with ApplyTmp
    // MatchPattern = 8, this enum value conflicts with DisableSmartFont
    // UnknownStory = 0, this enum value conflicts with False
    // MainTextStory = 1, this enum value conflicts with ApplyLater
    // FootnotesStory = 2, this enum value conflicts with TrackParms
    // EndnotesStory = 3, this enum value conflicts with CacheParms
    // CommentsStory = 4, this enum value conflicts with ApplyTmp
    // TextFrameStory = 5, this enum value conflicts with SelectionRow
    // EvenPagesHeaderStory = 6, this enum value conflicts with SelectionBlock
    // PrimaryHeaderStory = 7, this enum value conflicts with SelectionInlineShape
    // EvenPagesFooterStory = 8, this enum value conflicts with DisableSmartFont
    // PrimaryFooterStory = 9, this enum value conflicts with EnableSmartFont
    // FirstPageHeaderStory = 10, this enum value conflicts with UsePoints
    // FirstPageFooterStory = 11, this enum value conflicts with UseTwips
    ScratchStory = 127,
    FindStory = 128,
    ReplaceStory = 129,
    // StoryInactive = 0, this enum value conflicts with False
    // StoryActiveDisplay = 1, this enum value conflicts with ApplyLater
    // StoryActiveUI = 2, this enum value conflicts with TrackParms
    // StoryActiveDisplayUI = 3, this enum value conflicts with CacheParms
    // NoAnimation = 0, this enum value conflicts with False
    // LasVegasLights = 1, this enum value conflicts with ApplyLater
    // BlinkingBackground = 2, this enum value conflicts with TrackParms
    // SparkleText = 3, this enum value conflicts with CacheParms
    // MarchingBlackAnts = 4, this enum value conflicts with ApplyTmp
    // MarchingRedAnts = 5, this enum value conflicts with SelectionRow
    // Shimmer = 6, this enum value conflicts with SelectionBlock
    // WipeDown = 7, this enum value conflicts with SelectionInlineShape
    // WipeRight = 8, this enum value conflicts with DisableSmartFont
    // AnimationMax = 8, this enum value conflicts with DisableSmartFont
    // LowerCase = 0, this enum value conflicts with False
    // UpperCase = 1, this enum value conflicts with ApplyLater
    // TitleCase = 2, this enum value conflicts with TrackParms
    // SentenceCase = 4, this enum value conflicts with ApplyTmp
    // ToggleCase = 5, this enum value conflicts with SelectionRow
    // ReadOnly = 256, this enum value conflicts with ClientCoord
    // ShareDenyRead = 512, this enum value conflicts with AllowOffClient
    // ShareDenyWrite = 1024, this enum value conflicts with Transform
    // PasteFile = 4096, this enum value conflicts with AtEnd
    // CreateNew = 16, this enum value conflicts with SelReplace
    // CreateAlways = 32, this enum value conflicts with Start
    OpenExisting = 48,
    OpenAlways = 64,
    TruncateExisting = 80,
    // RTF = 1, this enum value conflicts with ApplyLater
    // Text = 2, this enum value conflicts with TrackParms
    // HTML = 3, this enum value conflicts with CacheParms
    // WordDocument = 4, this enum value conflicts with ApplyTmp
    Bold = -2147483647,
    Italic = -2147483646,
    Underline = -2147483644,
    Strikeout = -2147483640,
    Protected = -2147483632,
    Link = -2147483616,
    SmallCaps = -2147483584,
    AllCaps = -2147483520,
    Hidden = -2147483392,
    Outline = -2147483136,
    Shadow = -2147482624,
    Emboss = -2147481600,
    Imprint = -2147479552,
    Disabled = -2147475456,
    Revised = -2147467264,
    SubscriptCF = -2147418112,
    SuperscriptCF = -2147352576,
    FontBound = -2146435072,
    LinkProtected = -2139095040,
    InlineObjectStart = -2130706432,
    ExtendedChar = -2113929216,
    AutoBackColor = -2080374784,
    MathZoneNoBuildUp = -2013265920,
    MathZone = -1879048192,
    MathZoneOrdinary = -1610612736,
    AutoTextColor = -1073741824,
    // MathZoneDisplay = 262144, this enum value conflicts with ListNoNumber
    // ParaEffectRTL = 1, this enum value conflicts with ApplyLater
    // ParaEffectKeep = 2, this enum value conflicts with TrackParms
    // ParaEffectKeepNext = 4, this enum value conflicts with ApplyTmp
    // ParaEffectPageBreakBefore = 8, this enum value conflicts with DisableSmartFont
    // ParaEffectNoLineNumber = 16, this enum value conflicts with SelReplace
    // ParaEffectNoWidowControl = 32, this enum value conflicts with Start
    // ParaEffectDoNotHyphen = 64, this enum value conflicts with OpenAlways
    // ParaEffectSideBySide = 128, this enum value conflicts with FindStory
    // ParaEffectCollapsed = 256, this enum value conflicts with ClientCoord
    // ParaEffectOutlineLevel = 512, this enum value conflicts with AllowOffClient
    // ParaEffectBox = 1024, this enum value conflicts with Transform
    // ParaEffectTableRowDelimiter = 4096, this enum value conflicts with AtEnd
    ParaEffectTable = 16384,
    // ModWidthPairs = 1, this enum value conflicts with ApplyLater
    // ModWidthSpace = 2, this enum value conflicts with TrackParms
    // AutoSpaceAlpha = 4, this enum value conflicts with ApplyTmp
    // AutoSpaceNumeric = 8, this enum value conflicts with DisableSmartFont
    // AutoSpaceParens = 16, this enum value conflicts with SelReplace
    // EmbeddedFont = 32, this enum value conflicts with Start
    // Doublestrike = 64, this enum value conflicts with OpenAlways
    // Overlapping = 128, this enum value conflicts with FindStory
    // NormalCaret = 0, this enum value conflicts with False
    // KoreanBlockCaret = 1, this enum value conflicts with ApplyLater
    // NullCaret = 2, this enum value conflicts with TrackParms
    // IncludeInset = 1, this enum value conflicts with ApplyLater
    // UnicodeBiDi = 1, this enum value conflicts with ApplyLater
    // MathCFCheck = 4, this enum value conflicts with ApplyTmp
    // Unlink = 8, this enum value conflicts with DisableSmartFont
    // Unhide = 16, this enum value conflicts with SelReplace
    // CheckTextLimit = 32, this enum value conflicts with Start
    // IgnoreCurrentFont = 0, this enum value conflicts with False
    // MatchCharRep = 1, this enum value conflicts with ApplyLater
    // MatchFontSignature = 2, this enum value conflicts with TrackParms
    // MatchAscii = 4, this enum value conflicts with ApplyTmp
    // GetHeightOnly = 8, this enum value conflicts with DisableSmartFont
    // MatchMathFont = 16, this enum value conflicts with SelReplace
    Charset = -2147483648,
    CharRepFromLcid = 1073741824,
    // Ansi = 0, this enum value conflicts with False
    // EastEurope = 1, this enum value conflicts with ApplyLater
    // Cyrillic = 2, this enum value conflicts with TrackParms
    // Greek = 3, this enum value conflicts with CacheParms
    // Turkish = 4, this enum value conflicts with ApplyTmp
    // Hebrew = 5, this enum value conflicts with SelectionRow
    // Arabic = 6, this enum value conflicts with SelectionBlock
    // Baltic = 7, this enum value conflicts with SelectionInlineShape
    // Vietnamese = 8, this enum value conflicts with DisableSmartFont
    // DefaultCharRep = 9, this enum value conflicts with EnableSmartFont
    // Symbol = 10, this enum value conflicts with UsePoints
    // Thai = 11, this enum value conflicts with UseTwips
    // ShiftJIS = 12, this enum value conflicts with HeavyWave
    // GB2312 = 13, this enum value conflicts with LongDash
    // Hangul = 14, this enum value conflicts with ThickDash
    // BIG5 = 15, this enum value conflicts with ThickDashDot
    // PC437 = 16, this enum value conflicts with SelReplace
    // OEM = 17, this enum value conflicts with ThickDotted
    // Mac = 18, this enum value conflicts with ThickLongDash
    // Armenian = 19, this enum value conflicts with ListNumberedThaiAlpha
    // Syriac = 20, this enum value conflicts with ListNumberedThaiNum
    // Thaana = 21, this enum value conflicts with ListNumberedHindiAlpha
    // Devanagari = 22, this enum value conflicts with ListNumberedHindiAlpha1
    // Bengali = 23, this enum value conflicts with ListNumberedHindiNum
    Gurmukhi = 24,
    Gujarati = 25,
    Oriya = 26,
    Tamil = 27,
    Telugu = 28,
    Kannada = 29,
    Malayalam = 30,
    Sinhala = 31,
    // Lao = 32, this enum value conflicts with Start
    Tibetan = 33,
    Myanmar = 34,
    Georgian = 35,
    Jamo = 36,
    Ethiopic = 37,
    Cherokee = 38,
    Aboriginal = 39,
    Ogham = 40,
    Runic = 41,
    Khmer = 42,
    Mongolian = 43,
    Braille = 44,
    Yi = 45,
    Limbu = 46,
    TaiLe = 47,
    // NewTaiLue = 48, this enum value conflicts with OpenExisting
    SylotiNagri = 49,
    Kharoshthi = 50,
    Kayahli = 51,
    Usymbol = 52,
    Emoji = 53,
    Glagolitic = 54,
    Lisu = 55,
    Vai = 56,
    NKo = 57,
    Osmanya = 58,
    PhagsPa = 59,
    Gothic = 60,
    Deseret = 61,
    Tifinagh = 62,
    CharRepMax = 63,
    // RE10Mode = 1, this enum value conflicts with ApplyLater
    // UseAtFont = 2, this enum value conflicts with TrackParms
    // TextFlowMask = 12, this enum value conflicts with HeavyWave
    // TextFlowES = 0, this enum value conflicts with False
    // TextFlowSW = 4, this enum value conflicts with ApplyTmp
    // TextFlowWN = 8, this enum value conflicts with DisableSmartFont
    // TextFlowNE = 12, this enum value conflicts with HeavyWave
    // NoIME = 524288, this enum value conflicts with ListMinus
    // SelfIME = 262144, this enum value conflicts with ListNoNumber
    // NoUpScroll = 65536, this enum value conflicts with ListParentheses
    // NoVpScroll = 262144, this enum value conflicts with ListNoNumber
    // NoLink = 0, this enum value conflicts with False
    // ClientLink = 1, this enum value conflicts with ApplyLater
    // FriendlyLinkName = 2, this enum value conflicts with TrackParms
    // FriendlyLinkAddress = 3, this enum value conflicts with CacheParms
    // AutoLinkURL = 4, this enum value conflicts with ApplyTmp
    // AutoLinkEmail = 5, this enum value conflicts with SelectionRow
    // AutoLinkPhone = 6, this enum value conflicts with SelectionBlock
    // AutoLinkPath = 7, this enum value conflicts with SelectionInlineShape
    // CompressNone = 0, this enum value conflicts with False
    // CompressPunctuation = 1, this enum value conflicts with ApplyLater
    // CompressPunctuationAndKana = 2, this enum value conflicts with TrackParms
    // CompressMax = 2, this enum value conflicts with TrackParms
    // UnderlinePositionAuto = 0, this enum value conflicts with False
    // UnderlinePositionBelow = 1, this enum value conflicts with ApplyLater
    // UnderlinePositionAbove = 2, this enum value conflicts with TrackParms
    // UnderlinePositionMax = 2, this enum value conflicts with TrackParms
    // FontAlignmentAuto = 0, this enum value conflicts with False
    // FontAlignmentTop = 1, this enum value conflicts with ApplyLater
    // FontAlignmentBaseline = 2, this enum value conflicts with TrackParms
    // FontAlignmentBottom = 3, this enum value conflicts with CacheParms
    // FontAlignmentCenter = 4, this enum value conflicts with ApplyTmp
    // FontAlignmentMax = 4, this enum value conflicts with ApplyTmp
    // RubyBelow = 128, this enum value conflicts with FindStory
    // RubyAlignCenter = 0, this enum value conflicts with False
    // RubyAlign010 = 1, this enum value conflicts with ApplyLater
    // RubyAlign121 = 2, this enum value conflicts with TrackParms
    // RubyAlignLeft = 3, this enum value conflicts with CacheParms
    // RubyAlignRight = 4, this enum value conflicts with ApplyTmp
    // LimitsDefault = 0, this enum value conflicts with False
    // LimitsUnderOver = 1, this enum value conflicts with ApplyLater
    // LimitsSubSup = 2, this enum value conflicts with TrackParms
    // UpperLimitAsSuperScript = 3, this enum value conflicts with CacheParms
    // LimitsOpposite = 4, this enum value conflicts with ApplyTmp
    // ShowLLimPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // ShowULimPlaceHldr = 16, this enum value conflicts with SelReplace
    // DontGrowWithContent = 64, this enum value conflicts with OpenAlways
    // GrowWithContent = 128, this enum value conflicts with FindStory
    // SubSupAlign = 1, this enum value conflicts with ApplyLater
    // LimitAlignMask = 3, this enum value conflicts with CacheParms
    // LimitAlignCenter = 0, this enum value conflicts with False
    // LimitAlignLeft = 1, this enum value conflicts with ApplyLater
    // LimitAlignRight = 2, this enum value conflicts with TrackParms
    // ShowDegPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // AlignDefault = 0, this enum value conflicts with False
    // AlignMatchAscentDescent = 2, this enum value conflicts with TrackParms
    // MathVariant = 32, this enum value conflicts with Start
    // StyleDefault = 0, this enum value conflicts with False
    // StyleScriptScriptCramped = 1, this enum value conflicts with ApplyLater
    // StyleScriptScript = 2, this enum value conflicts with TrackParms
    // StyleScriptCramped = 3, this enum value conflicts with CacheParms
    // StyleScript = 4, this enum value conflicts with ApplyTmp
    // StyleTextCramped = 5, this enum value conflicts with SelectionRow
    // StyleText = 6, this enum value conflicts with SelectionBlock
    // StyleDisplayCramped = 7, this enum value conflicts with SelectionInlineShape
    // StyleDisplay = 8, this enum value conflicts with DisableSmartFont
    // MathRelSize = 64, this enum value conflicts with OpenAlways
    DecDecSize = 254,
    DecSize = 255,
    IncSize = 65,
    IncIncSize = 66,
    // GravityUI = 0, this enum value conflicts with False
    // GravityBack = 1, this enum value conflicts with ApplyLater
    // GravityFore = 2, this enum value conflicts with TrackParms
    // GravityIn = 3, this enum value conflicts with CacheParms
    // GravityOut = 4, this enum value conflicts with ApplyTmp
    GravityBackward = 536870912,
    // GravityForward = 1073741824, this enum value conflicts with CharRepFromLcid
    // AdjustCRLF = 1, this enum value conflicts with ApplyLater
    // UseCRLF = 2, this enum value conflicts with TrackParms
    // Textize = 4, this enum value conflicts with ApplyTmp
    // AllowFinalEOP = 8, this enum value conflicts with DisableSmartFont
    // FoldMathAlpha = 16, this enum value conflicts with SelReplace
    // NoHidden = 32, this enum value conflicts with Start
    // IncludeNumbering = 64, this enum value conflicts with OpenAlways
    // TranslateTableCell = 128, this enum value conflicts with FindStory
    // NoMathZoneBrackets = 256, this enum value conflicts with ClientCoord
    // ConvertMathChar = 512, this enum value conflicts with AllowOffClient
    // NoUCGreekItalic = 1024, this enum value conflicts with Transform
    // AllowMathBold = 2048, this enum value conflicts with ObjectArg
    // LanguageTag = 4096, this enum value conflicts with AtEnd
    ConvertRTF = 8192,
    // ApplyRtfDocProps = 16384, this enum value conflicts with ParaEffectTable
    // PhantomShow = 1, this enum value conflicts with ApplyLater
    // PhantomZeroWidth = 2, this enum value conflicts with TrackParms
    // PhantomZeroAscent = 4, this enum value conflicts with ApplyTmp
    // PhantomZeroDescent = 8, this enum value conflicts with DisableSmartFont
    // PhantomTransparent = 16, this enum value conflicts with SelReplace
    // PhantomASmash = 5, this enum value conflicts with SelectionRow
    // PhantomDSmash = 9, this enum value conflicts with EnableSmartFont
    // PhantomHSmash = 3, this enum value conflicts with CacheParms
    // PhantomSmash = 13, this enum value conflicts with LongDash
    // PhantomHorz = 12, this enum value conflicts with HeavyWave
    // PhantomVert = 2, this enum value conflicts with TrackParms
    // BoxHideTop = 1, this enum value conflicts with ApplyLater
    // BoxHideBottom = 2, this enum value conflicts with TrackParms
    // BoxHideLeft = 4, this enum value conflicts with ApplyTmp
    // BoxHideRight = 8, this enum value conflicts with DisableSmartFont
    // BoxStrikeH = 16, this enum value conflicts with SelReplace
    // BoxStrikeV = 32, this enum value conflicts with Start
    // BoxStrikeTLBR = 64, this enum value conflicts with OpenAlways
    // BoxStrikeBLTR = 128, this enum value conflicts with FindStory
    // BoxAlignCenter = 1, this enum value conflicts with ApplyLater
    // SpaceMask = 28, this enum value conflicts with Telugu
    // SpaceDefault = 0, this enum value conflicts with False
    // SpaceUnary = 4, this enum value conflicts with ApplyTmp
    // SpaceBinary = 8, this enum value conflicts with DisableSmartFont
    // SpaceRelational = 12, this enum value conflicts with HeavyWave
    // SpaceSkip = 16, this enum value conflicts with SelReplace
    // SpaceOrd = 20, this enum value conflicts with ListNumberedThaiNum
    // SpaceDifferential = 24, this enum value conflicts with Gurmukhi
    // SizeText = 32, this enum value conflicts with Start
    // SizeScript = 64, this enum value conflicts with OpenAlways
    SizeScriptScript = 96,
    // NoBreak = 128, this enum value conflicts with FindStory
    // TransparentForPositioning = 256, this enum value conflicts with ClientCoord
    // TransparentForSpacing = 512, this enum value conflicts with AllowOffClient
    // StretchCharBelow = 0, this enum value conflicts with False
    // StretchCharAbove = 1, this enum value conflicts with ApplyLater
    // StretchBaseBelow = 2, this enum value conflicts with TrackParms
    // StretchBaseAbove = 3, this enum value conflicts with CacheParms
    // MatrixAlignMask = 3, this enum value conflicts with CacheParms
    // MatrixAlignCenter = 0, this enum value conflicts with False
    // MatrixAlignTopRow = 1, this enum value conflicts with ApplyLater
    // MatrixAlignBottomRow = 3, this enum value conflicts with CacheParms
    // ShowMatPlaceHldr = 8, this enum value conflicts with DisableSmartFont
    // EqArrayLayoutWidth = 1, this enum value conflicts with ApplyLater
    // EqArrayAlignMask = 12, this enum value conflicts with HeavyWave
    // EqArrayAlignCenter = 0, this enum value conflicts with False
    // EqArrayAlignTopRow = 4, this enum value conflicts with ApplyTmp
    // EqArrayAlignBottomRow = 12, this enum value conflicts with HeavyWave
    // MathManualBreakMask = 127, this enum value conflicts with ScratchStory
    MathBreakLeft = 125,
    MathBreakCenter = 126,
    // MathBreakRight = 127, this enum value conflicts with ScratchStory
    // MathEqAlign = 128, this enum value conflicts with FindStory
    MathArgShadingStart = 593,
    MathArgShadingEnd = 594,
    MathObjShadingStart = 595,
    MathObjShadingEnd = 596,
    // FunctionTypeNone = 0, this enum value conflicts with False
    // FunctionTypeTakesArg = 1, this enum value conflicts with ApplyLater
    // FunctionTypeTakesLim = 2, this enum value conflicts with TrackParms
    // FunctionTypeTakesLim2 = 3, this enum value conflicts with CacheParms
    // FunctionTypeIsLim = 4, this enum value conflicts with ApplyTmp
    // MathParaAlignDefault = 0, this enum value conflicts with False
    // MathParaAlignCenterGroup = 1, this enum value conflicts with ApplyLater
    // MathParaAlignCenter = 2, this enum value conflicts with TrackParms
    // MathParaAlignLeft = 3, this enum value conflicts with CacheParms
    // MathParaAlignRight = 4, this enum value conflicts with ApplyTmp
    // MathDispAlignMask = 3, this enum value conflicts with CacheParms
    // MathDispAlignCenterGroup = 0, this enum value conflicts with False
    // MathDispAlignCenter = 1, this enum value conflicts with ApplyLater
    // MathDispAlignLeft = 2, this enum value conflicts with TrackParms
    // MathDispAlignRight = 3, this enum value conflicts with CacheParms
    // MathDispIntUnderOver = 4, this enum value conflicts with ApplyTmp
    // MathDispFracTeX = 8, this enum value conflicts with DisableSmartFont
    // MathDispNaryGrow = 16, this enum value conflicts with SelReplace
    // MathDocEmptyArgMask = 96, this enum value conflicts with SizeScriptScript
    // MathDocEmptyArgAuto = 0, this enum value conflicts with False
    // MathDocEmptyArgAlways = 32, this enum value conflicts with Start
    // MathDocEmptyArgNever = 64, this enum value conflicts with OpenAlways
    // MathDocSbSpOpUnchanged = 128, this enum value conflicts with FindStory
    MathDocDiffMask = 768,
    // MathDocDiffDefault = 0, this enum value conflicts with False
    // MathDocDiffUpright = 256, this enum value conflicts with ClientCoord
    // MathDocDiffItalic = 512, this enum value conflicts with AllowOffClient
    // MathDocDiffOpenItalic = 768, this enum value conflicts with MathDocDiffMask
    // MathDispNarySubSup = 1024, this enum value conflicts with Transform
    // MathDispDef = 2048, this enum value conflicts with ObjectArg
    // MathEnableRtl = 4096, this enum value conflicts with AtEnd
    // MathBrkBinMask = 196608, this enum value conflicts with ListPlain
    // MathBrkBinBefore = 0, this enum value conflicts with False
    // MathBrkBinAfter = 65536, this enum value conflicts with ListParentheses
    // MathBrkBinDup = 131072, this enum value conflicts with ListPeriod
    MathBrkBinSubMask = 786432,
    // MathBrkBinSubMM = 0, this enum value conflicts with False
    // MathBrkBinSubPM = 262144, this enum value conflicts with ListNoNumber
    // MathBrkBinSubMP = 524288, this enum value conflicts with ListMinus
    SelRange = 597,
    // Hstring = 596, this enum value conflicts with MathObjShadingEnd
    FontPropTeXStyle = 828,
    FontPropAlign = 829,
    FontStretch = 830,
    FontStyle = 831,
    // FontStyleUpright = 0, this enum value conflicts with False
    // FontStyleOblique = 1, this enum value conflicts with ApplyLater
    // FontStyleItalic = 2, this enum value conflicts with TrackParms
    // FontStretchDefault = 0, this enum value conflicts with False
    // FontStretchUltraCondensed = 1, this enum value conflicts with ApplyLater
    // FontStretchExtraCondensed = 2, this enum value conflicts with TrackParms
    // FontStretchCondensed = 3, this enum value conflicts with CacheParms
    // FontStretchSemiCondensed = 4, this enum value conflicts with ApplyTmp
    // FontStretchNormal = 5, this enum value conflicts with SelectionRow
    // FontStretchSemiExpanded = 6, this enum value conflicts with SelectionBlock
    // FontStretchExpanded = 7, this enum value conflicts with SelectionInlineShape
    // FontStretchExtraExpanded = 8, this enum value conflicts with DisableSmartFont
    // FontStretchUltraExpanded = 9, this enum value conflicts with EnableSmartFont
    // FontWeightDefault = 0, this enum value conflicts with False
    FontWeightThin = 100,
    FontWeightExtraLight = 200,
    FontWeightLight = 300,
    FontWeightNormal = 400,
    // FontWeightRegular = 400, this enum value conflicts with FontWeightNormal
    FontWeightMedium = 500,
    FontWeightSemiBold = 600,
    FontWeightBold = 700,
    FontWeightExtraBold = 800,
    FontWeightBlack = 900,
    // FontWeightHeavy = 900, this enum value conflicts with FontWeightBlack
    FontWeightExtraBlack = 950,
    ParaPropMathAlign = 1079,
    // DocMathBuild = 128, this enum value conflicts with FindStory
    // MathLMargin = 129, this enum value conflicts with ReplaceStory
    MathRMargin = 130,
    MathWrapIndent = 131,
    MathWrapRight = 132,
    MathPostSpace = 134,
    MathPreSpace = 133,
    MathInterSpace = 135,
    MathIntraSpace = 136,
    CanCopy = 137,
    CanRedo = 138,
    CanUndo = 139,
    UndoLimit = 140,
    DocAutoLink = 141,
    EllipsisMode = 142,
    EllipsisState = 143,
    // EllipsisNone = 0, this enum value conflicts with False
    // EllipsisEnd = 1, this enum value conflicts with ApplyLater
    // EllipsisWord = 3, this enum value conflicts with CacheParms
    // EllipsisPresent = 1, this enum value conflicts with ApplyLater
    // VTopCell = 1, this enum value conflicts with ApplyLater
    // VLowCell = 2, this enum value conflicts with TrackParms
    // HStartCell = 4, this enum value conflicts with ApplyTmp
    // HContCell = 8, this enum value conflicts with DisableSmartFont
    // RowUpdate = 1, this enum value conflicts with ApplyLater
    // RowApplyDefault = 0, this enum value conflicts with False
    // CellStructureChangeOnly = 1, this enum value conflicts with ApplyLater
    RowHeightActual = 2059,
};
pub const tomFalse = tomConstants.False;
pub const tomTrue = tomConstants.True;
pub const tomUndefined = tomConstants.Undefined;
pub const tomToggle = tomConstants.Toggle;
pub const tomAutoColor = tomConstants.AutoColor;
pub const tomDefault = tomConstants.Default;
pub const tomSuspend = tomConstants.Suspend;
pub const tomResume = tomConstants.Resume;
pub const tomApplyNow = tomConstants.False;
pub const tomApplyLater = tomConstants.ApplyLater;
pub const tomTrackParms = tomConstants.TrackParms;
pub const tomCacheParms = tomConstants.CacheParms;
pub const tomApplyTmp = tomConstants.ApplyTmp;
pub const tomDisableSmartFont = tomConstants.DisableSmartFont;
pub const tomEnableSmartFont = tomConstants.EnableSmartFont;
pub const tomUsePoints = tomConstants.UsePoints;
pub const tomUseTwips = tomConstants.UseTwips;
pub const tomBackward = tomConstants.Backward;
pub const tomForward = tomConstants.Forward;
pub const tomMove = tomConstants.False;
pub const tomExtend = tomConstants.ApplyLater;
pub const tomNoSelection = tomConstants.False;
pub const tomSelectionIP = tomConstants.ApplyLater;
pub const tomSelectionNormal = tomConstants.TrackParms;
pub const tomSelectionFrame = tomConstants.CacheParms;
pub const tomSelectionColumn = tomConstants.ApplyTmp;
pub const tomSelectionRow = tomConstants.SelectionRow;
pub const tomSelectionBlock = tomConstants.SelectionBlock;
pub const tomSelectionInlineShape = tomConstants.SelectionInlineShape;
pub const tomSelectionShape = tomConstants.DisableSmartFont;
pub const tomSelStartActive = tomConstants.ApplyLater;
pub const tomSelAtEOL = tomConstants.TrackParms;
pub const tomSelOvertype = tomConstants.ApplyTmp;
pub const tomSelActive = tomConstants.DisableSmartFont;
pub const tomSelReplace = tomConstants.SelReplace;
pub const tomEnd = tomConstants.False;
pub const tomStart = tomConstants.Start;
pub const tomCollapseEnd = tomConstants.False;
pub const tomCollapseStart = tomConstants.ApplyLater;
pub const tomClientCoord = tomConstants.ClientCoord;
pub const tomAllowOffClient = tomConstants.AllowOffClient;
pub const tomTransform = tomConstants.Transform;
pub const tomObjectArg = tomConstants.ObjectArg;
pub const tomAtEnd = tomConstants.AtEnd;
pub const tomNone = tomConstants.False;
pub const tomSingle = tomConstants.ApplyLater;
pub const tomWords = tomConstants.TrackParms;
pub const tomDouble = tomConstants.CacheParms;
pub const tomDotted = tomConstants.ApplyTmp;
pub const tomDash = tomConstants.SelectionRow;
pub const tomDashDot = tomConstants.SelectionBlock;
pub const tomDashDotDot = tomConstants.SelectionInlineShape;
pub const tomWave = tomConstants.DisableSmartFont;
pub const tomThick = tomConstants.EnableSmartFont;
pub const tomHair = tomConstants.UsePoints;
pub const tomDoubleWave = tomConstants.UseTwips;
pub const tomHeavyWave = tomConstants.HeavyWave;
pub const tomLongDash = tomConstants.LongDash;
pub const tomThickDash = tomConstants.ThickDash;
pub const tomThickDashDot = tomConstants.ThickDashDot;
pub const tomThickDashDotDot = tomConstants.SelReplace;
pub const tomThickDotted = tomConstants.ThickDotted;
pub const tomThickLongDash = tomConstants.ThickLongDash;
pub const tomLineSpaceSingle = tomConstants.False;
pub const tomLineSpace1pt5 = tomConstants.ApplyLater;
pub const tomLineSpaceDouble = tomConstants.TrackParms;
pub const tomLineSpaceAtLeast = tomConstants.CacheParms;
pub const tomLineSpaceExactly = tomConstants.ApplyTmp;
pub const tomLineSpaceMultiple = tomConstants.SelectionRow;
pub const tomLineSpacePercent = tomConstants.SelectionBlock;
pub const tomAlignLeft = tomConstants.False;
pub const tomAlignCenter = tomConstants.ApplyLater;
pub const tomAlignRight = tomConstants.TrackParms;
pub const tomAlignJustify = tomConstants.CacheParms;
pub const tomAlignDecimal = tomConstants.CacheParms;
pub const tomAlignBar = tomConstants.ApplyTmp;
pub const tomDefaultTab = tomConstants.SelectionRow;
pub const tomAlignInterWord = tomConstants.CacheParms;
pub const tomAlignNewspaper = tomConstants.ApplyTmp;
pub const tomAlignInterLetter = tomConstants.SelectionRow;
pub const tomAlignScaled = tomConstants.SelectionBlock;
pub const tomSpaces = tomConstants.False;
pub const tomDots = tomConstants.ApplyLater;
pub const tomDashes = tomConstants.TrackParms;
pub const tomLines = tomConstants.CacheParms;
pub const tomThickLines = tomConstants.ApplyTmp;
pub const tomEquals = tomConstants.SelectionRow;
pub const tomTabBack = tomConstants.TabBack;
pub const tomTabNext = tomConstants.TabNext;
pub const tomTabHere = tomConstants.True;
pub const tomListNone = tomConstants.False;
pub const tomListBullet = tomConstants.ApplyLater;
pub const tomListNumberAsArabic = tomConstants.TrackParms;
pub const tomListNumberAsLCLetter = tomConstants.CacheParms;
pub const tomListNumberAsUCLetter = tomConstants.ApplyTmp;
pub const tomListNumberAsLCRoman = tomConstants.SelectionRow;
pub const tomListNumberAsUCRoman = tomConstants.SelectionBlock;
pub const tomListNumberAsSequence = tomConstants.SelectionInlineShape;
pub const tomListNumberedCircle = tomConstants.DisableSmartFont;
pub const tomListNumberedBlackCircleWingding = tomConstants.EnableSmartFont;
pub const tomListNumberedWhiteCircleWingding = tomConstants.UsePoints;
pub const tomListNumberedArabicWide = tomConstants.UseTwips;
pub const tomListNumberedChS = tomConstants.HeavyWave;
pub const tomListNumberedChT = tomConstants.LongDash;
pub const tomListNumberedJpnChS = tomConstants.ThickDash;
pub const tomListNumberedJpnKor = tomConstants.ThickDashDot;
pub const tomListNumberedArabic1 = tomConstants.SelReplace;
pub const tomListNumberedArabic2 = tomConstants.ThickDotted;
pub const tomListNumberedHebrew = tomConstants.ThickLongDash;
pub const tomListNumberedThaiAlpha = tomConstants.ListNumberedThaiAlpha;
pub const tomListNumberedThaiNum = tomConstants.ListNumberedThaiNum;
pub const tomListNumberedHindiAlpha = tomConstants.ListNumberedHindiAlpha;
pub const tomListNumberedHindiAlpha1 = tomConstants.ListNumberedHindiAlpha1;
pub const tomListNumberedHindiNum = tomConstants.ListNumberedHindiNum;
pub const tomListParentheses = tomConstants.ListParentheses;
pub const tomListPeriod = tomConstants.ListPeriod;
pub const tomListPlain = tomConstants.ListPlain;
pub const tomListNoNumber = tomConstants.ListNoNumber;
pub const tomListMinus = tomConstants.ListMinus;
pub const tomIgnoreNumberStyle = tomConstants.IgnoreNumberStyle;
pub const tomParaStyleNormal = tomConstants.True;
pub const tomParaStyleHeading1 = tomConstants.TabNext;
pub const tomParaStyleHeading2 = tomConstants.TabBack;
pub const tomParaStyleHeading3 = tomConstants.ParaStyleHeading3;
pub const tomParaStyleHeading4 = tomConstants.ParaStyleHeading4;
pub const tomParaStyleHeading5 = tomConstants.ParaStyleHeading5;
pub const tomParaStyleHeading6 = tomConstants.ParaStyleHeading6;
pub const tomParaStyleHeading7 = tomConstants.ParaStyleHeading7;
pub const tomParaStyleHeading8 = tomConstants.ParaStyleHeading8;
pub const tomParaStyleHeading9 = tomConstants.ParaStyleHeading9;
pub const tomCharacter = tomConstants.ApplyLater;
pub const tomWord = tomConstants.TrackParms;
pub const tomSentence = tomConstants.CacheParms;
pub const tomParagraph = tomConstants.ApplyTmp;
pub const tomLine = tomConstants.SelectionRow;
pub const tomStory = tomConstants.SelectionBlock;
pub const tomScreen = tomConstants.SelectionInlineShape;
pub const tomSection = tomConstants.DisableSmartFont;
pub const tomTableColumn = tomConstants.EnableSmartFont;
pub const tomColumn = tomConstants.EnableSmartFont;
pub const tomRow = tomConstants.UsePoints;
pub const tomWindow = tomConstants.UseTwips;
pub const tomCell = tomConstants.HeavyWave;
pub const tomCharFormat = tomConstants.LongDash;
pub const tomParaFormat = tomConstants.ThickDash;
pub const tomTable = tomConstants.ThickDashDot;
pub const tomObject = tomConstants.SelReplace;
pub const tomPage = tomConstants.ThickDotted;
pub const tomHardParagraph = tomConstants.ThickLongDash;
pub const tomCluster = tomConstants.ListNumberedThaiAlpha;
pub const tomInlineObject = tomConstants.ListNumberedThaiNum;
pub const tomInlineObjectArg = tomConstants.ListNumberedHindiAlpha;
pub const tomLeafLine = tomConstants.ListNumberedHindiAlpha1;
pub const tomLayoutColumn = tomConstants.ListNumberedHindiNum;
pub const tomProcessId = tomConstants.ProcessId;
pub const tomMatchWord = tomConstants.TrackParms;
pub const tomMatchCase = tomConstants.ApplyTmp;
pub const tomMatchPattern = tomConstants.DisableSmartFont;
pub const tomUnknownStory = tomConstants.False;
pub const tomMainTextStory = tomConstants.ApplyLater;
pub const tomFootnotesStory = tomConstants.TrackParms;
pub const tomEndnotesStory = tomConstants.CacheParms;
pub const tomCommentsStory = tomConstants.ApplyTmp;
pub const tomTextFrameStory = tomConstants.SelectionRow;
pub const tomEvenPagesHeaderStory = tomConstants.SelectionBlock;
pub const tomPrimaryHeaderStory = tomConstants.SelectionInlineShape;
pub const tomEvenPagesFooterStory = tomConstants.DisableSmartFont;
pub const tomPrimaryFooterStory = tomConstants.EnableSmartFont;
pub const tomFirstPageHeaderStory = tomConstants.UsePoints;
pub const tomFirstPageFooterStory = tomConstants.UseTwips;
pub const tomScratchStory = tomConstants.ScratchStory;
pub const tomFindStory = tomConstants.FindStory;
pub const tomReplaceStory = tomConstants.ReplaceStory;
pub const tomStoryInactive = tomConstants.False;
pub const tomStoryActiveDisplay = tomConstants.ApplyLater;
pub const tomStoryActiveUI = tomConstants.TrackParms;
pub const tomStoryActiveDisplayUI = tomConstants.CacheParms;
pub const tomNoAnimation = tomConstants.False;
pub const tomLasVegasLights = tomConstants.ApplyLater;
pub const tomBlinkingBackground = tomConstants.TrackParms;
pub const tomSparkleText = tomConstants.CacheParms;
pub const tomMarchingBlackAnts = tomConstants.ApplyTmp;
pub const tomMarchingRedAnts = tomConstants.SelectionRow;
pub const tomShimmer = tomConstants.SelectionBlock;
pub const tomWipeDown = tomConstants.SelectionInlineShape;
pub const tomWipeRight = tomConstants.DisableSmartFont;
pub const tomAnimationMax = tomConstants.DisableSmartFont;
pub const tomLowerCase = tomConstants.False;
pub const tomUpperCase = tomConstants.ApplyLater;
pub const tomTitleCase = tomConstants.TrackParms;
pub const tomSentenceCase = tomConstants.ApplyTmp;
pub const tomToggleCase = tomConstants.SelectionRow;
pub const tomReadOnly = tomConstants.ClientCoord;
pub const tomShareDenyRead = tomConstants.AllowOffClient;
pub const tomShareDenyWrite = tomConstants.Transform;
pub const tomPasteFile = tomConstants.AtEnd;
pub const tomCreateNew = tomConstants.SelReplace;
pub const tomCreateAlways = tomConstants.Start;
pub const tomOpenExisting = tomConstants.OpenExisting;
pub const tomOpenAlways = tomConstants.OpenAlways;
pub const tomTruncateExisting = tomConstants.TruncateExisting;
pub const tomRTF = tomConstants.ApplyLater;
pub const tomText = tomConstants.TrackParms;
pub const tomHTML = tomConstants.CacheParms;
pub const tomWordDocument = tomConstants.ApplyTmp;
pub const tomBold = tomConstants.Bold;
pub const tomItalic = tomConstants.Italic;
pub const tomUnderline = tomConstants.Underline;
pub const tomStrikeout = tomConstants.Strikeout;
pub const tomProtected = tomConstants.Protected;
pub const tomLink = tomConstants.Link;
pub const tomSmallCaps = tomConstants.SmallCaps;
pub const tomAllCaps = tomConstants.AllCaps;
pub const tomHidden = tomConstants.Hidden;
pub const tomOutline = tomConstants.Outline;
pub const tomShadow = tomConstants.Shadow;
pub const tomEmboss = tomConstants.Emboss;
pub const tomImprint = tomConstants.Imprint;
pub const tomDisabled = tomConstants.Disabled;
pub const tomRevised = tomConstants.Revised;
pub const tomSubscriptCF = tomConstants.SubscriptCF;
pub const tomSuperscriptCF = tomConstants.SuperscriptCF;
pub const tomFontBound = tomConstants.FontBound;
pub const tomLinkProtected = tomConstants.LinkProtected;
pub const tomInlineObjectStart = tomConstants.InlineObjectStart;
pub const tomExtendedChar = tomConstants.ExtendedChar;
pub const tomAutoBackColor = tomConstants.AutoBackColor;
pub const tomMathZoneNoBuildUp = tomConstants.MathZoneNoBuildUp;
pub const tomMathZone = tomConstants.MathZone;
pub const tomMathZoneOrdinary = tomConstants.MathZoneOrdinary;
pub const tomAutoTextColor = tomConstants.AutoTextColor;
pub const tomMathZoneDisplay = tomConstants.ListNoNumber;
pub const tomParaEffectRTL = tomConstants.ApplyLater;
pub const tomParaEffectKeep = tomConstants.TrackParms;
pub const tomParaEffectKeepNext = tomConstants.ApplyTmp;
pub const tomParaEffectPageBreakBefore = tomConstants.DisableSmartFont;
pub const tomParaEffectNoLineNumber = tomConstants.SelReplace;
pub const tomParaEffectNoWidowControl = tomConstants.Start;
pub const tomParaEffectDoNotHyphen = tomConstants.OpenAlways;
pub const tomParaEffectSideBySide = tomConstants.FindStory;
pub const tomParaEffectCollapsed = tomConstants.ClientCoord;
pub const tomParaEffectOutlineLevel = tomConstants.AllowOffClient;
pub const tomParaEffectBox = tomConstants.Transform;
pub const tomParaEffectTableRowDelimiter = tomConstants.AtEnd;
pub const tomParaEffectTable = tomConstants.ParaEffectTable;
pub const tomModWidthPairs = tomConstants.ApplyLater;
pub const tomModWidthSpace = tomConstants.TrackParms;
pub const tomAutoSpaceAlpha = tomConstants.ApplyTmp;
pub const tomAutoSpaceNumeric = tomConstants.DisableSmartFont;
pub const tomAutoSpaceParens = tomConstants.SelReplace;
pub const tomEmbeddedFont = tomConstants.Start;
pub const tomDoublestrike = tomConstants.OpenAlways;
pub const tomOverlapping = tomConstants.FindStory;
pub const tomNormalCaret = tomConstants.False;
pub const tomKoreanBlockCaret = tomConstants.ApplyLater;
pub const tomNullCaret = tomConstants.TrackParms;
pub const tomIncludeInset = tomConstants.ApplyLater;
pub const tomUnicodeBiDi = tomConstants.ApplyLater;
pub const tomMathCFCheck = tomConstants.ApplyTmp;
pub const tomUnlink = tomConstants.DisableSmartFont;
pub const tomUnhide = tomConstants.SelReplace;
pub const tomCheckTextLimit = tomConstants.Start;
pub const tomIgnoreCurrentFont = tomConstants.False;
pub const tomMatchCharRep = tomConstants.ApplyLater;
pub const tomMatchFontSignature = tomConstants.TrackParms;
pub const tomMatchAscii = tomConstants.ApplyTmp;
pub const tomGetHeightOnly = tomConstants.DisableSmartFont;
pub const tomMatchMathFont = tomConstants.SelReplace;
pub const tomCharset = tomConstants.Charset;
pub const tomCharRepFromLcid = tomConstants.CharRepFromLcid;
pub const tomAnsi = tomConstants.False;
pub const tomEastEurope = tomConstants.ApplyLater;
pub const tomCyrillic = tomConstants.TrackParms;
pub const tomGreek = tomConstants.CacheParms;
pub const tomTurkish = tomConstants.ApplyTmp;
pub const tomHebrew = tomConstants.SelectionRow;
pub const tomArabic = tomConstants.SelectionBlock;
pub const tomBaltic = tomConstants.SelectionInlineShape;
pub const tomVietnamese = tomConstants.DisableSmartFont;
pub const tomDefaultCharRep = tomConstants.EnableSmartFont;
pub const tomSymbol = tomConstants.UsePoints;
pub const tomThai = tomConstants.UseTwips;
pub const tomShiftJIS = tomConstants.HeavyWave;
pub const tomGB2312 = tomConstants.LongDash;
pub const tomHangul = tomConstants.ThickDash;
pub const tomBIG5 = tomConstants.ThickDashDot;
pub const tomPC437 = tomConstants.SelReplace;
pub const tomOEM = tomConstants.ThickDotted;
pub const tomMac = tomConstants.ThickLongDash;
pub const tomArmenian = tomConstants.ListNumberedThaiAlpha;
pub const tomSyriac = tomConstants.ListNumberedThaiNum;
pub const tomThaana = tomConstants.ListNumberedHindiAlpha;
pub const tomDevanagari = tomConstants.ListNumberedHindiAlpha1;
pub const tomBengali = tomConstants.ListNumberedHindiNum;
pub const tomGurmukhi = tomConstants.Gurmukhi;
pub const tomGujarati = tomConstants.Gujarati;
pub const tomOriya = tomConstants.Oriya;
pub const tomTamil = tomConstants.Tamil;
pub const tomTelugu = tomConstants.Telugu;
pub const tomKannada = tomConstants.Kannada;
pub const tomMalayalam = tomConstants.Malayalam;
pub const tomSinhala = tomConstants.Sinhala;
pub const tomLao = tomConstants.Start;
pub const tomTibetan = tomConstants.Tibetan;
pub const tomMyanmar = tomConstants.Myanmar;
pub const tomGeorgian = tomConstants.Georgian;
pub const tomJamo = tomConstants.Jamo;
pub const tomEthiopic = tomConstants.Ethiopic;
pub const tomCherokee = tomConstants.Cherokee;
pub const tomAboriginal = tomConstants.Aboriginal;
pub const tomOgham = tomConstants.Ogham;
pub const tomRunic = tomConstants.Runic;
pub const tomKhmer = tomConstants.Khmer;
pub const tomMongolian = tomConstants.Mongolian;
pub const tomBraille = tomConstants.Braille;
pub const tomYi = tomConstants.Yi;
pub const tomLimbu = tomConstants.Limbu;
pub const tomTaiLe = tomConstants.TaiLe;
pub const tomNewTaiLue = tomConstants.OpenExisting;
pub const tomSylotiNagri = tomConstants.SylotiNagri;
pub const tomKharoshthi = tomConstants.Kharoshthi;
pub const tomKayahli = tomConstants.Kayahli;
pub const tomUsymbol = tomConstants.Usymbol;
pub const tomEmoji = tomConstants.Emoji;
pub const tomGlagolitic = tomConstants.Glagolitic;
pub const tomLisu = tomConstants.Lisu;
pub const tomVai = tomConstants.Vai;
pub const tomNKo = tomConstants.NKo;
pub const tomOsmanya = tomConstants.Osmanya;
pub const tomPhagsPa = tomConstants.PhagsPa;
pub const tomGothic = tomConstants.Gothic;
pub const tomDeseret = tomConstants.Deseret;
pub const tomTifinagh = tomConstants.Tifinagh;
pub const tomCharRepMax = tomConstants.CharRepMax;
pub const tomRE10Mode = tomConstants.ApplyLater;
pub const tomUseAtFont = tomConstants.TrackParms;
pub const tomTextFlowMask = tomConstants.HeavyWave;
pub const tomTextFlowES = tomConstants.False;
pub const tomTextFlowSW = tomConstants.ApplyTmp;
pub const tomTextFlowWN = tomConstants.DisableSmartFont;
pub const tomTextFlowNE = tomConstants.HeavyWave;
pub const tomNoIME = tomConstants.ListMinus;
pub const tomSelfIME = tomConstants.ListNoNumber;
pub const tomNoUpScroll = tomConstants.ListParentheses;
pub const tomNoVpScroll = tomConstants.ListNoNumber;
pub const tomNoLink = tomConstants.False;
pub const tomClientLink = tomConstants.ApplyLater;
pub const tomFriendlyLinkName = tomConstants.TrackParms;
pub const tomFriendlyLinkAddress = tomConstants.CacheParms;
pub const tomAutoLinkURL = tomConstants.ApplyTmp;
pub const tomAutoLinkEmail = tomConstants.SelectionRow;
pub const tomAutoLinkPhone = tomConstants.SelectionBlock;
pub const tomAutoLinkPath = tomConstants.SelectionInlineShape;
pub const tomCompressNone = tomConstants.False;
pub const tomCompressPunctuation = tomConstants.ApplyLater;
pub const tomCompressPunctuationAndKana = tomConstants.TrackParms;
pub const tomCompressMax = tomConstants.TrackParms;
pub const tomUnderlinePositionAuto = tomConstants.False;
pub const tomUnderlinePositionBelow = tomConstants.ApplyLater;
pub const tomUnderlinePositionAbove = tomConstants.TrackParms;
pub const tomUnderlinePositionMax = tomConstants.TrackParms;
pub const tomFontAlignmentAuto = tomConstants.False;
pub const tomFontAlignmentTop = tomConstants.ApplyLater;
pub const tomFontAlignmentBaseline = tomConstants.TrackParms;
pub const tomFontAlignmentBottom = tomConstants.CacheParms;
pub const tomFontAlignmentCenter = tomConstants.ApplyTmp;
pub const tomFontAlignmentMax = tomConstants.ApplyTmp;
pub const tomRubyBelow = tomConstants.FindStory;
pub const tomRubyAlignCenter = tomConstants.False;
pub const tomRubyAlign010 = tomConstants.ApplyLater;
pub const tomRubyAlign121 = tomConstants.TrackParms;
pub const tomRubyAlignLeft = tomConstants.CacheParms;
pub const tomRubyAlignRight = tomConstants.ApplyTmp;
pub const tomLimitsDefault = tomConstants.False;
pub const tomLimitsUnderOver = tomConstants.ApplyLater;
pub const tomLimitsSubSup = tomConstants.TrackParms;
pub const tomUpperLimitAsSuperScript = tomConstants.CacheParms;
pub const tomLimitsOpposite = tomConstants.ApplyTmp;
pub const tomShowLLimPlaceHldr = tomConstants.DisableSmartFont;
pub const tomShowULimPlaceHldr = tomConstants.SelReplace;
pub const tomDontGrowWithContent = tomConstants.OpenAlways;
pub const tomGrowWithContent = tomConstants.FindStory;
pub const tomSubSupAlign = tomConstants.ApplyLater;
pub const tomLimitAlignMask = tomConstants.CacheParms;
pub const tomLimitAlignCenter = tomConstants.False;
pub const tomLimitAlignLeft = tomConstants.ApplyLater;
pub const tomLimitAlignRight = tomConstants.TrackParms;
pub const tomShowDegPlaceHldr = tomConstants.DisableSmartFont;
pub const tomAlignDefault = tomConstants.False;
pub const tomAlignMatchAscentDescent = tomConstants.TrackParms;
pub const tomMathVariant = tomConstants.Start;
pub const tomStyleDefault = tomConstants.False;
pub const tomStyleScriptScriptCramped = tomConstants.ApplyLater;
pub const tomStyleScriptScript = tomConstants.TrackParms;
pub const tomStyleScriptCramped = tomConstants.CacheParms;
pub const tomStyleScript = tomConstants.ApplyTmp;
pub const tomStyleTextCramped = tomConstants.SelectionRow;
pub const tomStyleText = tomConstants.SelectionBlock;
pub const tomStyleDisplayCramped = tomConstants.SelectionInlineShape;
pub const tomStyleDisplay = tomConstants.DisableSmartFont;
pub const tomMathRelSize = tomConstants.OpenAlways;
pub const tomDecDecSize = tomConstants.DecDecSize;
pub const tomDecSize = tomConstants.DecSize;
pub const tomIncSize = tomConstants.IncSize;
pub const tomIncIncSize = tomConstants.IncIncSize;
pub const tomGravityUI = tomConstants.False;
pub const tomGravityBack = tomConstants.ApplyLater;
pub const tomGravityFore = tomConstants.TrackParms;
pub const tomGravityIn = tomConstants.CacheParms;
pub const tomGravityOut = tomConstants.ApplyTmp;
pub const tomGravityBackward = tomConstants.GravityBackward;
pub const tomGravityForward = tomConstants.CharRepFromLcid;
pub const tomAdjustCRLF = tomConstants.ApplyLater;
pub const tomUseCRLF = tomConstants.TrackParms;
pub const tomTextize = tomConstants.ApplyTmp;
pub const tomAllowFinalEOP = tomConstants.DisableSmartFont;
pub const tomFoldMathAlpha = tomConstants.SelReplace;
pub const tomNoHidden = tomConstants.Start;
pub const tomIncludeNumbering = tomConstants.OpenAlways;
pub const tomTranslateTableCell = tomConstants.FindStory;
pub const tomNoMathZoneBrackets = tomConstants.ClientCoord;
pub const tomConvertMathChar = tomConstants.AllowOffClient;
pub const tomNoUCGreekItalic = tomConstants.Transform;
pub const tomAllowMathBold = tomConstants.ObjectArg;
pub const tomLanguageTag = tomConstants.AtEnd;
pub const tomConvertRTF = tomConstants.ConvertRTF;
pub const tomApplyRtfDocProps = tomConstants.ParaEffectTable;
pub const tomPhantomShow = tomConstants.ApplyLater;
pub const tomPhantomZeroWidth = tomConstants.TrackParms;
pub const tomPhantomZeroAscent = tomConstants.ApplyTmp;
pub const tomPhantomZeroDescent = tomConstants.DisableSmartFont;
pub const tomPhantomTransparent = tomConstants.SelReplace;
pub const tomPhantomASmash = tomConstants.SelectionRow;
pub const tomPhantomDSmash = tomConstants.EnableSmartFont;
pub const tomPhantomHSmash = tomConstants.CacheParms;
pub const tomPhantomSmash = tomConstants.LongDash;
pub const tomPhantomHorz = tomConstants.HeavyWave;
pub const tomPhantomVert = tomConstants.TrackParms;
pub const tomBoxHideTop = tomConstants.ApplyLater;
pub const tomBoxHideBottom = tomConstants.TrackParms;
pub const tomBoxHideLeft = tomConstants.ApplyTmp;
pub const tomBoxHideRight = tomConstants.DisableSmartFont;
pub const tomBoxStrikeH = tomConstants.SelReplace;
pub const tomBoxStrikeV = tomConstants.Start;
pub const tomBoxStrikeTLBR = tomConstants.OpenAlways;
pub const tomBoxStrikeBLTR = tomConstants.FindStory;
pub const tomBoxAlignCenter = tomConstants.ApplyLater;
pub const tomSpaceMask = tomConstants.Telugu;
pub const tomSpaceDefault = tomConstants.False;
pub const tomSpaceUnary = tomConstants.ApplyTmp;
pub const tomSpaceBinary = tomConstants.DisableSmartFont;
pub const tomSpaceRelational = tomConstants.HeavyWave;
pub const tomSpaceSkip = tomConstants.SelReplace;
pub const tomSpaceOrd = tomConstants.ListNumberedThaiNum;
pub const tomSpaceDifferential = tomConstants.Gurmukhi;
pub const tomSizeText = tomConstants.Start;
pub const tomSizeScript = tomConstants.OpenAlways;
pub const tomSizeScriptScript = tomConstants.SizeScriptScript;
pub const tomNoBreak = tomConstants.FindStory;
pub const tomTransparentForPositioning = tomConstants.ClientCoord;
pub const tomTransparentForSpacing = tomConstants.AllowOffClient;
pub const tomStretchCharBelow = tomConstants.False;
pub const tomStretchCharAbove = tomConstants.ApplyLater;
pub const tomStretchBaseBelow = tomConstants.TrackParms;
pub const tomStretchBaseAbove = tomConstants.CacheParms;
pub const tomMatrixAlignMask = tomConstants.CacheParms;
pub const tomMatrixAlignCenter = tomConstants.False;
pub const tomMatrixAlignTopRow = tomConstants.ApplyLater;
pub const tomMatrixAlignBottomRow = tomConstants.CacheParms;
pub const tomShowMatPlaceHldr = tomConstants.DisableSmartFont;
pub const tomEqArrayLayoutWidth = tomConstants.ApplyLater;
pub const tomEqArrayAlignMask = tomConstants.HeavyWave;
pub const tomEqArrayAlignCenter = tomConstants.False;
pub const tomEqArrayAlignTopRow = tomConstants.ApplyTmp;
pub const tomEqArrayAlignBottomRow = tomConstants.HeavyWave;
pub const tomMathManualBreakMask = tomConstants.ScratchStory;
pub const tomMathBreakLeft = tomConstants.MathBreakLeft;
pub const tomMathBreakCenter = tomConstants.MathBreakCenter;
pub const tomMathBreakRight = tomConstants.ScratchStory;
pub const tomMathEqAlign = tomConstants.FindStory;
pub const tomMathArgShadingStart = tomConstants.MathArgShadingStart;
pub const tomMathArgShadingEnd = tomConstants.MathArgShadingEnd;
pub const tomMathObjShadingStart = tomConstants.MathObjShadingStart;
pub const tomMathObjShadingEnd = tomConstants.MathObjShadingEnd;
pub const tomFunctionTypeNone = tomConstants.False;
pub const tomFunctionTypeTakesArg = tomConstants.ApplyLater;
pub const tomFunctionTypeTakesLim = tomConstants.TrackParms;
pub const tomFunctionTypeTakesLim2 = tomConstants.CacheParms;
pub const tomFunctionTypeIsLim = tomConstants.ApplyTmp;
pub const tomMathParaAlignDefault = tomConstants.False;
pub const tomMathParaAlignCenterGroup = tomConstants.ApplyLater;
pub const tomMathParaAlignCenter = tomConstants.TrackParms;
pub const tomMathParaAlignLeft = tomConstants.CacheParms;
pub const tomMathParaAlignRight = tomConstants.ApplyTmp;
pub const tomMathDispAlignMask = tomConstants.CacheParms;
pub const tomMathDispAlignCenterGroup = tomConstants.False;
pub const tomMathDispAlignCenter = tomConstants.ApplyLater;
pub const tomMathDispAlignLeft = tomConstants.TrackParms;
pub const tomMathDispAlignRight = tomConstants.CacheParms;
pub const tomMathDispIntUnderOver = tomConstants.ApplyTmp;
pub const tomMathDispFracTeX = tomConstants.DisableSmartFont;
pub const tomMathDispNaryGrow = tomConstants.SelReplace;
pub const tomMathDocEmptyArgMask = tomConstants.SizeScriptScript;
pub const tomMathDocEmptyArgAuto = tomConstants.False;
pub const tomMathDocEmptyArgAlways = tomConstants.Start;
pub const tomMathDocEmptyArgNever = tomConstants.OpenAlways;
pub const tomMathDocSbSpOpUnchanged = tomConstants.FindStory;
pub const tomMathDocDiffMask = tomConstants.MathDocDiffMask;
pub const tomMathDocDiffDefault = tomConstants.False;
pub const tomMathDocDiffUpright = tomConstants.ClientCoord;
pub const tomMathDocDiffItalic = tomConstants.AllowOffClient;
pub const tomMathDocDiffOpenItalic = tomConstants.MathDocDiffMask;
pub const tomMathDispNarySubSup = tomConstants.Transform;
pub const tomMathDispDef = tomConstants.ObjectArg;
pub const tomMathEnableRtl = tomConstants.AtEnd;
pub const tomMathBrkBinMask = tomConstants.ListPlain;
pub const tomMathBrkBinBefore = tomConstants.False;
pub const tomMathBrkBinAfter = tomConstants.ListParentheses;
pub const tomMathBrkBinDup = tomConstants.ListPeriod;
pub const tomMathBrkBinSubMask = tomConstants.MathBrkBinSubMask;
pub const tomMathBrkBinSubMM = tomConstants.False;
pub const tomMathBrkBinSubPM = tomConstants.ListNoNumber;
pub const tomMathBrkBinSubMP = tomConstants.ListMinus;
pub const tomSelRange = tomConstants.SelRange;
pub const tomHstring = tomConstants.MathObjShadingEnd;
pub const tomFontPropTeXStyle = tomConstants.FontPropTeXStyle;
pub const tomFontPropAlign = tomConstants.FontPropAlign;
pub const tomFontStretch = tomConstants.FontStretch;
pub const tomFontStyle = tomConstants.FontStyle;
pub const tomFontStyleUpright = tomConstants.False;
pub const tomFontStyleOblique = tomConstants.ApplyLater;
pub const tomFontStyleItalic = tomConstants.TrackParms;
pub const tomFontStretchDefault = tomConstants.False;
pub const tomFontStretchUltraCondensed = tomConstants.ApplyLater;
pub const tomFontStretchExtraCondensed = tomConstants.TrackParms;
pub const tomFontStretchCondensed = tomConstants.CacheParms;
pub const tomFontStretchSemiCondensed = tomConstants.ApplyTmp;
pub const tomFontStretchNormal = tomConstants.SelectionRow;
pub const tomFontStretchSemiExpanded = tomConstants.SelectionBlock;
pub const tomFontStretchExpanded = tomConstants.SelectionInlineShape;
pub const tomFontStretchExtraExpanded = tomConstants.DisableSmartFont;
pub const tomFontStretchUltraExpanded = tomConstants.EnableSmartFont;
pub const tomFontWeightDefault = tomConstants.False;
pub const tomFontWeightThin = tomConstants.FontWeightThin;
pub const tomFontWeightExtraLight = tomConstants.FontWeightExtraLight;
pub const tomFontWeightLight = tomConstants.FontWeightLight;
pub const tomFontWeightNormal = tomConstants.FontWeightNormal;
pub const tomFontWeightRegular = tomConstants.FontWeightNormal;
pub const tomFontWeightMedium = tomConstants.FontWeightMedium;
pub const tomFontWeightSemiBold = tomConstants.FontWeightSemiBold;
pub const tomFontWeightBold = tomConstants.FontWeightBold;
pub const tomFontWeightExtraBold = tomConstants.FontWeightExtraBold;
pub const tomFontWeightBlack = tomConstants.FontWeightBlack;
pub const tomFontWeightHeavy = tomConstants.FontWeightBlack;
pub const tomFontWeightExtraBlack = tomConstants.FontWeightExtraBlack;
pub const tomParaPropMathAlign = tomConstants.ParaPropMathAlign;
pub const tomDocMathBuild = tomConstants.FindStory;
pub const tomMathLMargin = tomConstants.ReplaceStory;
pub const tomMathRMargin = tomConstants.MathRMargin;
pub const tomMathWrapIndent = tomConstants.MathWrapIndent;
pub const tomMathWrapRight = tomConstants.MathWrapRight;
pub const tomMathPostSpace = tomConstants.MathPostSpace;
pub const tomMathPreSpace = tomConstants.MathPreSpace;
pub const tomMathInterSpace = tomConstants.MathInterSpace;
pub const tomMathIntraSpace = tomConstants.MathIntraSpace;
pub const tomCanCopy = tomConstants.CanCopy;
pub const tomCanRedo = tomConstants.CanRedo;
pub const tomCanUndo = tomConstants.CanUndo;
pub const tomUndoLimit = tomConstants.UndoLimit;
pub const tomDocAutoLink = tomConstants.DocAutoLink;
pub const tomEllipsisMode = tomConstants.EllipsisMode;
pub const tomEllipsisState = tomConstants.EllipsisState;
pub const tomEllipsisNone = tomConstants.False;
pub const tomEllipsisEnd = tomConstants.ApplyLater;
pub const tomEllipsisWord = tomConstants.CacheParms;
pub const tomEllipsisPresent = tomConstants.ApplyLater;
pub const tomVTopCell = tomConstants.ApplyLater;
pub const tomVLowCell = tomConstants.TrackParms;
pub const tomHStartCell = tomConstants.ApplyTmp;
pub const tomHContCell = tomConstants.DisableSmartFont;
pub const tomRowUpdate = tomConstants.ApplyLater;
pub const tomRowApplyDefault = tomConstants.False;
pub const tomCellStructureChangeOnly = tomConstants.ApplyLater;
pub const tomRowHeightActual = tomConstants.RowHeightActual;

pub const OBJECTTYPE = enum(i32) {
    SimpleText = 0,
    Ruby = 1,
    HorzVert = 2,
    Warichu = 3,
    Eq = 9,
    Math = 10,
    // Accent = 10, this enum value conflicts with Math
    Box = 11,
    BoxedFormula = 12,
    Brackets = 13,
    BracketsWithSeps = 14,
    EquationArray = 15,
    Fraction = 16,
    FunctionApply = 17,
    LeftSubSup = 18,
    LowerLimit = 19,
    Matrix = 20,
    Nary = 21,
    OpChar = 22,
    Overbar = 23,
    Phantom = 24,
    Radical = 25,
    SlashedFraction = 26,
    Stack = 27,
    StretchStack = 28,
    Subscript = 29,
    SubSup = 30,
    Superscript = 31,
    Underbar = 32,
    UpperLimit = 33,
    // ObjectMax = 33, this enum value conflicts with UpperLimit
};
pub const tomSimpleText = OBJECTTYPE.SimpleText;
pub const tomRuby = OBJECTTYPE.Ruby;
pub const tomHorzVert = OBJECTTYPE.HorzVert;
pub const tomWarichu = OBJECTTYPE.Warichu;
pub const tomEq = OBJECTTYPE.Eq;
pub const tomMath = OBJECTTYPE.Math;
pub const tomAccent = OBJECTTYPE.Math;
pub const tomBox = OBJECTTYPE.Box;
pub const tomBoxedFormula = OBJECTTYPE.BoxedFormula;
pub const tomBrackets = OBJECTTYPE.Brackets;
pub const tomBracketsWithSeps = OBJECTTYPE.BracketsWithSeps;
pub const tomEquationArray = OBJECTTYPE.EquationArray;
pub const tomFraction = OBJECTTYPE.Fraction;
pub const tomFunctionApply = OBJECTTYPE.FunctionApply;
pub const tomLeftSubSup = OBJECTTYPE.LeftSubSup;
pub const tomLowerLimit = OBJECTTYPE.LowerLimit;
pub const tomMatrix = OBJECTTYPE.Matrix;
pub const tomNary = OBJECTTYPE.Nary;
pub const tomOpChar = OBJECTTYPE.OpChar;
pub const tomOverbar = OBJECTTYPE.Overbar;
pub const tomPhantom = OBJECTTYPE.Phantom;
pub const tomRadical = OBJECTTYPE.Radical;
pub const tomSlashedFraction = OBJECTTYPE.SlashedFraction;
pub const tomStack = OBJECTTYPE.Stack;
pub const tomStretchStack = OBJECTTYPE.StretchStack;
pub const tomSubscript = OBJECTTYPE.Subscript;
pub const tomSubSup = OBJECTTYPE.SubSup;
pub const tomSuperscript = OBJECTTYPE.Superscript;
pub const tomUnderbar = OBJECTTYPE.Underbar;
pub const tomUpperLimit = OBJECTTYPE.UpperLimit;
pub const tomObjectMax = OBJECTTYPE.UpperLimit;

pub const MANCODE = enum(i32) {
    BOLD = 16,
    ITAL = 32,
    GREEK = 64,
    ROMN = 0,
    SCRP = 1,
    FRAK = 2,
    OPEN = 3,
    SANS = 4,
    MONO = 5,
    MATH = 6,
    ISOL = 7,
    INIT = 8,
    TAIL = 9,
    STRCH = 10,
    LOOP = 11,
    OPENA = 12,
};
pub const MBOLD = MANCODE.BOLD;
pub const MITAL = MANCODE.ITAL;
pub const MGREEK = MANCODE.GREEK;
pub const MROMN = MANCODE.ROMN;
pub const MSCRP = MANCODE.SCRP;
pub const MFRAK = MANCODE.FRAK;
pub const MOPEN = MANCODE.OPEN;
pub const MSANS = MANCODE.SANS;
pub const MMONO = MANCODE.MONO;
pub const MMATH = MANCODE.MATH;
pub const MISOL = MANCODE.ISOL;
pub const MINIT = MANCODE.INIT;
pub const MTAIL = MANCODE.TAIL;
pub const MSTRCH = MANCODE.STRCH;
pub const MLOOP = MANCODE.LOOP;
pub const MOPENA = MANCODE.OPENA;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextDocument_Value = @import("../../zig.zig").Guid.initString("8cc497c0-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextDocument = &IID_ITextDocument_Value;
pub const ITextDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetName: fn(
            self: *const ITextDocument,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ITextDocument,
            ppSel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryCount: fn(
            self: *const ITextDocument,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges: fn(
            self: *const ITextDocument,
            ppStories: ?*?*ITextStoryRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSaved: fn(
            self: *const ITextDocument,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSaved: fn(
            self: *const ITextDocument,
            Value: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTabStop: fn(
            self: *const ITextDocument,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTabStop: fn(
            self: *const ITextDocument,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        New: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: fn(
            self: *const ITextDocument,
            pVar: ?*VARIANT,
            Flags: i32,
            CodePage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const ITextDocument,
            pVar: ?*VARIANT,
            Flags: i32,
            CodePage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Freeze: fn(
            self: *const ITextDocument,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unfreeze: fn(
            self: *const ITextDocument,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEditCollection: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndEditCollection: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Undo: fn(
            self: *const ITextDocument,
            Count: i32,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Redo: fn(
            self: *const ITextDocument,
            Count: i32,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range: fn(
            self: *const ITextDocument,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint: fn(
            self: *const ITextDocument,
            x: i32,
            y: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetName(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetName(@ptrCast(*const ITextDocument, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetSelection(self: *const T, ppSel: ?*?*ITextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetSelection(@ptrCast(*const ITextDocument, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetStoryCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetStoryCount(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetStoryRanges(self: *const T, ppStories: ?*?*ITextStoryRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetStoryRanges(@ptrCast(*const ITextDocument, self), ppStories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetSaved(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetSaved(@ptrCast(*const ITextDocument, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_SetSaved(self: *const T, Value: tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).SetSaved(@ptrCast(*const ITextDocument, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetDefaultTabStop(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetDefaultTabStop(@ptrCast(*const ITextDocument, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_SetDefaultTabStop(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).SetDefaultTabStop(@ptrCast(*const ITextDocument, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_New(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).New(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Open(self: *const T, pVar: ?*VARIANT, Flags: i32, CodePage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Open(@ptrCast(*const ITextDocument, self), pVar, Flags, CodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Save(self: *const T, pVar: ?*VARIANT, Flags: i32, CodePage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Save(@ptrCast(*const ITextDocument, self), pVar, Flags, CodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Freeze(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Freeze(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Unfreeze(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Unfreeze(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_BeginEditCollection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).BeginEditCollection(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_EndEditCollection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).EndEditCollection(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Undo(self: *const T, Count: i32, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Undo(@ptrCast(*const ITextDocument, self), Count, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Redo(self: *const T, Count: i32, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Redo(@ptrCast(*const ITextDocument, self), Count, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Range(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Range(@ptrCast(*const ITextDocument, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_RangeFromPoint(self: *const T, x: i32, y: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).RangeFromPoint(@ptrCast(*const ITextDocument, self), x, y, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextRange_Value = @import("../../zig.zig").Guid.initString("8cc497c2-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextRange = &IID_ITextRange_Value;
pub const ITextRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetText: fn(
            self: *const ITextRange,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextRange,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar: fn(
            self: *const ITextRange,
            pChar: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChar: fn(
            self: *const ITextRange,
            Char: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate: fn(
            self: *const ITextRange,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: fn(
            self: *const ITextRange,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStart: fn(
            self: *const ITextRange,
            pcpFirst: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStart: fn(
            self: *const ITextRange,
            cpFirst: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: fn(
            self: *const ITextRange,
            pcpLim: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnd: fn(
            self: *const ITextRange,
            cpLim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont: fn(
            self: *const ITextRange,
            ppFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont: fn(
            self: *const ITextRange,
            pFont: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara: fn(
            self: *const ITextRange,
            ppPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara: fn(
            self: *const ITextRange,
            pPara: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryLength: fn(
            self: *const ITextRange,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryType: fn(
            self: *const ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Collapse: fn(
            self: *const ITextRange,
            bStart: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Expand: fn(
            self: *const ITextRange,
            Unit: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const ITextRange,
            Unit: i32,
            pIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndex: fn(
            self: *const ITextRange,
            Unit: i32,
            Index: i32,
            Extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRange: fn(
            self: *const ITextRange,
            cpAnchor: i32,
            cpActive: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InRange: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InStory: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartOf: fn(
            self: *const ITextRange,
            Unit: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOf: fn(
            self: *const ITextRange,
            Unit: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStart: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEnd: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveWhile: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartWhile: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndWhile: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUntil: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartUntil: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndUntil: fn(
            self: *const ITextRange,
            Cset: ?*VARIANT,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindText: fn(
            self: *const ITextRange,
            bstr: ?BSTR,
            Count: i32,
            Flags: i32,
            pLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextStart: fn(
            self: *const ITextRange,
            bstr: ?BSTR,
            Count: i32,
            Flags: i32,
            pLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextEnd: fn(
            self: *const ITextRange,
            bstr: ?BSTR,
            Count: i32,
            Flags: i32,
            pLength: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cut: fn(
            self: *const ITextRange,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const ITextRange,
            pVar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Paste: fn(
            self: *const ITextRange,
            pVar: ?*VARIANT,
            Format: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanPaste: fn(
            self: *const ITextRange,
            pVar: ?*VARIANT,
            Format: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanEdit: fn(
            self: *const ITextRange,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCase: fn(
            self: *const ITextRange,
            Type: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPoint: fn(
            self: *const ITextRange,
            Type: i32,
            px: ?*i32,
            py: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPoint: fn(
            self: *const ITextRange,
            x: i32,
            y: i32,
            Type: i32,
            Extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const ITextRange,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbeddedObject: fn(
            self: *const ITextRange,
            ppObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetText(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetText(@ptrCast(*const ITextRange, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetText(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetText(@ptrCast(*const ITextRange, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetChar(self: *const T, pChar: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetChar(@ptrCast(*const ITextRange, self), pChar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetChar(self: *const T, Char: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetChar(@ptrCast(*const ITextRange, self), Char);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetDuplicate(self: *const T, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextRange, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetFormattedText(self: *const T, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetFormattedText(@ptrCast(*const ITextRange, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetFormattedText(self: *const T, pRange: ?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextRange, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStart(self: *const T, pcpFirst: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStart(@ptrCast(*const ITextRange, self), pcpFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetStart(self: *const T, cpFirst: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetStart(@ptrCast(*const ITextRange, self), cpFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetEnd(self: *const T, pcpLim: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetEnd(@ptrCast(*const ITextRange, self), pcpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetEnd(self: *const T, cpLim: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetEnd(@ptrCast(*const ITextRange, self), cpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetFont(self: *const T, ppFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetFont(@ptrCast(*const ITextRange, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetFont(self: *const T, pFont: ?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetFont(@ptrCast(*const ITextRange, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetPara(self: *const T, ppPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetPara(@ptrCast(*const ITextRange, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetPara(self: *const T, pPara: ?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetPara(@ptrCast(*const ITextRange, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStoryLength(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStoryLength(@ptrCast(*const ITextRange, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStoryType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStoryType(@ptrCast(*const ITextRange, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Collapse(self: *const T, bStart: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Collapse(@ptrCast(*const ITextRange, self), bStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Expand(self: *const T, Unit: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Expand(@ptrCast(*const ITextRange, self), Unit, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetIndex(self: *const T, Unit: i32, pIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetIndex(@ptrCast(*const ITextRange, self), Unit, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetIndex(self: *const T, Unit: i32, Index: i32, Extend: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetIndex(@ptrCast(*const ITextRange, self), Unit, Index, Extend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetRange(self: *const T, cpAnchor: i32, cpActive: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetRange(@ptrCast(*const ITextRange, self), cpAnchor, cpActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_InRange(self: *const T, pRange: ?*ITextRange, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).InRange(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_InStory(self: *const T, pRange: ?*ITextRange, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).InStory(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_IsEqual(self: *const T, pRange: ?*ITextRange, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).IsEqual(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Select(@ptrCast(*const ITextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_StartOf(self: *const T, Unit: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).StartOf(@ptrCast(*const ITextRange, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_EndOf(self: *const T, Unit: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).EndOf(@ptrCast(*const ITextRange, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Move(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Move(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStart(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStart(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEnd(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEnd(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveWhile(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStartWhile(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStartWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEndWhile(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEndWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveUntil(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStartUntil(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStartUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEndUntil(self: *const T, Cset: ?*VARIANT, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEndUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindText(self: *const T, bstr: ?BSTR, Count: i32, Flags: i32, pLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindText(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindTextStart(self: *const T, bstr: ?BSTR, Count: i32, Flags: i32, pLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindTextStart(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindTextEnd(self: *const T, bstr: ?BSTR, Count: i32, Flags: i32, pLength: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindTextEnd(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Delete(self: *const T, Unit: i32, Count: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Delete(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Cut(self: *const T, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Cut(@ptrCast(*const ITextRange, self), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Copy(self: *const T, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Copy(@ptrCast(*const ITextRange, self), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Paste(self: *const T, pVar: ?*VARIANT, Format: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Paste(@ptrCast(*const ITextRange, self), pVar, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_CanPaste(self: *const T, pVar: ?*VARIANT, Format: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).CanPaste(@ptrCast(*const ITextRange, self), pVar, Format, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_CanEdit(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).CanEdit(@ptrCast(*const ITextRange, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_ChangeCase(self: *const T, Type: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).ChangeCase(@ptrCast(*const ITextRange, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetPoint(self: *const T, Type: i32, px: ?*i32, py: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetPoint(@ptrCast(*const ITextRange, self), Type, px, py);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetPoint(self: *const T, x: i32, y: i32, Type: i32, Extend: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetPoint(@ptrCast(*const ITextRange, self), x, y, Type, Extend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_ScrollIntoView(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).ScrollIntoView(@ptrCast(*const ITextRange, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetEmbeddedObject(self: *const T, ppObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetEmbeddedObject(@ptrCast(*const ITextRange, self), ppObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextSelection_Value = @import("../../zig.zig").Guid.initString("8cc497c1-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextSelection = &IID_ITextSelection_Value;
pub const ITextSelection = extern struct {
    pub const VTable = extern struct {
        base: ITextRange.VTable,
        GetFlags: fn(
            self: *const ITextSelection,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const ITextSelection,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ITextSelection,
            pType: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveLeft: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveRight: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUp: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveDown: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HomeKey: fn(
            self: *const ITextSelection,
            Unit: tomConstants,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndKey: fn(
            self: *const ITextSelection,
            Unit: i32,
            Extend: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TypeText: fn(
            self: *const ITextSelection,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRange.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_GetFlags(self: *const T, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).GetFlags(@ptrCast(*const ITextSelection, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_SetFlags(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).SetFlags(@ptrCast(*const ITextSelection, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_GetType(self: *const T, pType: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).GetType(@ptrCast(*const ITextSelection, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveLeft(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveLeft(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveRight(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveRight(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveUp(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveUp(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveDown(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveDown(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_HomeKey(self: *const T, Unit: tomConstants, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).HomeKey(@ptrCast(*const ITextSelection, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_EndKey(self: *const T, Unit: i32, Extend: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).EndKey(@ptrCast(*const ITextSelection, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_TypeText(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).TypeText(@ptrCast(*const ITextSelection, self), bstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextFont_Value = @import("../../zig.zig").Guid.initString("8cc497c3-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextFont = &IID_ITextFont_Value;
pub const ITextFont = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: fn(
            self: *const ITextFont,
            ppFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: fn(
            self: *const ITextFont,
            pFont: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextFont,
            pFont: ?*ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextFont,
            Value: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCaps: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllCaps: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnimation: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAnimation: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackColor: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackColor: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBold: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBold: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmboss: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEmboss: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetForeColor: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetForeColor: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHidden: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHidden: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngrave: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngrave: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItalic: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItalic: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKerning: fn(
            self: *const ITextFont,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKerning: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageID: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLanguageID: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const ITextFont,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetName: fn(
            self: *const ITextFont,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutline: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutline: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const ITextFont,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPosition: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtected: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProtected: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShadow: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShadow: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const ITextFont,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSmallCaps: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSmallCaps: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpacing: fn(
            self: *const ITextFont,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpacing: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrikeThrough: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStrikeThrough: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscript: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubscript: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSuperscript: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSuperscript: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderline: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderline: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWeight: fn(
            self: *const ITextFont,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWeight: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetDuplicate(self: *const T, ppFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextFont, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetDuplicate(self: *const T, pFont: ?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetDuplicate(@ptrCast(*const ITextFont, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_CanChange(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).CanChange(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_IsEqual(self: *const T, pFont: ?*ITextFont, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).IsEqual(@ptrCast(*const ITextFont, self), pFont, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_Reset(self: *const T, Value: tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).Reset(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetStyle(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetStyle(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetStyle(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetStyle(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetAllCaps(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetAllCaps(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetAllCaps(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetAllCaps(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetAnimation(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetAnimation(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetAnimation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetAnimation(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetBackColor(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetBackColor(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetBackColor(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetBackColor(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetBold(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetBold(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetBold(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetBold(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetEmboss(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetEmboss(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetEmboss(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetEmboss(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetForeColor(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetForeColor(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetForeColor(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetForeColor(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetHidden(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetHidden(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetHidden(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetHidden(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetEngrave(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetEngrave(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetEngrave(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetEngrave(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetItalic(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetItalic(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetItalic(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetItalic(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetKerning(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetKerning(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetKerning(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetKerning(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetLanguageID(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetLanguageID(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetLanguageID(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetLanguageID(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetName(@ptrCast(*const ITextFont, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetName(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetName(@ptrCast(*const ITextFont, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetOutline(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetOutline(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetOutline(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetOutline(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetPosition(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetPosition(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetPosition(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetPosition(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetProtected(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetProtected(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetProtected(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetProtected(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetShadow(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetShadow(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetShadow(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetShadow(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSize(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSize(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSize(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSize(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSmallCaps(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSmallCaps(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSmallCaps(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSmallCaps(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSpacing(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSpacing(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSpacing(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSpacing(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetStrikeThrough(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetStrikeThrough(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetStrikeThrough(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetStrikeThrough(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSubscript(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSubscript(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSubscript(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSubscript(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSuperscript(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSuperscript(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSuperscript(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSuperscript(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetUnderline(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetUnderline(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetUnderline(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetUnderline(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetWeight(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetWeight(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetWeight(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetWeight(@ptrCast(*const ITextFont, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextPara_Value = @import("../../zig.zig").Guid.initString("8cc497c4-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextPara = &IID_ITextPara_Value;
pub const ITextPara = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: fn(
            self: *const ITextPara,
            ppPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: fn(
            self: *const ITextPara,
            pPara: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextPara,
            pPara: ?*ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlignment: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHyphenation: fn(
            self: *const ITextPara,
            pValue: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHyphenation: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstLineIndent: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: fn(
            self: *const ITextPara,
            pValue: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: fn(
            self: *const ITextPara,
            pValue: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeftIndent: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacing: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacingRule: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListAlignment: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListAlignment: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListLevelIndex: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListLevelIndex: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListStart: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListStart: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListTab: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListTab: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListType: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListType: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNoLineNumber: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNoLineNumber: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageBreakBefore: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPageBreakBefore: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRightIndent: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRightIndent: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndents: fn(
            self: *const ITextPara,
            First: f32,
            Left: f32,
            Right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLineSpacing: fn(
            self: *const ITextPara,
            Rule: i32,
            Spacing: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceAfter: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceAfter: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceBefore: fn(
            self: *const ITextPara,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceBefore: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWidowControl: fn(
            self: *const ITextPara,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWidowControl: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTabCount: fn(
            self: *const ITextPara,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTab: fn(
            self: *const ITextPara,
            tbPos: f32,
            tbAlign: i32,
            tbLeader: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearAllTabs: fn(
            self: *const ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTab: fn(
            self: *const ITextPara,
            tbPos: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTab: fn(
            self: *const ITextPara,
            iTab: i32,
            ptbPos: ?*f32,
            ptbAlign: ?*i32,
            ptbLeader: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetDuplicate(self: *const T, ppPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextPara, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetDuplicate(self: *const T, pPara: ?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetDuplicate(@ptrCast(*const ITextPara, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_CanChange(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).CanChange(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_IsEqual(self: *const T, pPara: ?*ITextPara, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).IsEqual(@ptrCast(*const ITextPara, self), pPara, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_Reset(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).Reset(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetStyle(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetStyle(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetStyle(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetStyle(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetAlignment(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetAlignment(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetHyphenation(self: *const T, pValue: ?*tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetHyphenation(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetHyphenation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetHyphenation(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetFirstLineIndent(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetFirstLineIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetKeepTogether(self: *const T, pValue: ?*tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetKeepTogether(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetKeepTogether(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetKeepTogether(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetKeepWithNext(self: *const T, pValue: ?*tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetKeepWithNext(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetKeepWithNext(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetKeepWithNext(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLeftIndent(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLeftIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLineSpacing(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLineSpacing(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLineSpacingRule(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLineSpacingRule(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListAlignment(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListAlignment(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListLevelIndex(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListLevelIndex(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListLevelIndex(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListLevelIndex(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListStart(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListStart(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListStart(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListTab(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListTab(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListTab(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListTab(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListType(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListType(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetNoLineNumber(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetNoLineNumber(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetNoLineNumber(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetNoLineNumber(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetPageBreakBefore(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetPageBreakBefore(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetPageBreakBefore(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetPageBreakBefore(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetRightIndent(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetRightIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetRightIndent(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetRightIndent(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetIndents(self: *const T, First: f32, Left: f32, Right: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetIndents(@ptrCast(*const ITextPara, self), First, Left, Right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetLineSpacing(self: *const T, Rule: i32, Spacing: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetLineSpacing(@ptrCast(*const ITextPara, self), Rule, Spacing);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetSpaceAfter(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetSpaceAfter(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetSpaceAfter(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetSpaceAfter(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetSpaceBefore(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetSpaceBefore(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetSpaceBefore(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetSpaceBefore(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetWidowControl(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetWidowControl(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetWidowControl(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetWidowControl(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetTabCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetTabCount(@ptrCast(*const ITextPara, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_AddTab(self: *const T, tbPos: f32, tbAlign: i32, tbLeader: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).AddTab(@ptrCast(*const ITextPara, self), tbPos, tbAlign, tbLeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_ClearAllTabs(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).ClearAllTabs(@ptrCast(*const ITextPara, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_DeleteTab(self: *const T, tbPos: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).DeleteTab(@ptrCast(*const ITextPara, self), tbPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetTab(self: *const T, iTab: i32, ptbPos: ?*f32, ptbAlign: ?*i32, ptbLeader: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetTab(@ptrCast(*const ITextPara, self), iTab, ptbPos, ptbAlign, ptbLeader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITextStoryRanges_Value = @import("../../zig.zig").Guid.initString("8cc497c5-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextStoryRanges = &IID_ITextStoryRanges_Value;
pub const ITextStoryRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        _NewEnum: fn(
            self: *const ITextStoryRanges,
            ppunkEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const ITextStoryRanges,
            Index: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextStoryRanges,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges__NewEnum(self: *const T, ppunkEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable)._NewEnum(@ptrCast(*const ITextStoryRanges, self), ppunkEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable).Item(@ptrCast(*const ITextStoryRanges, self), Index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges_GetCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable).GetCount(@ptrCast(*const ITextStoryRanges, self), pCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDocument2_Value = @import("../../zig.zig").Guid.initString("c241f5e0-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDocument2 = &IID_ITextDocument2_Value;
pub const ITextDocument2 = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        GetCaretType: fn(
            self: *const ITextDocument2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplays: fn(
            self: *const ITextDocument2,
            ppDisplays: ?*?*ITextDisplays,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: fn(
            self: *const ITextDocument2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentFont: fn(
            self: *const ITextDocument2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: fn(
            self: *const ITextDocument2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentPara: fn(
            self: *const ITextDocument2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEastAsianFlags: fn(
            self: *const ITextDocument2,
            pFlags: ?*tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenerator: fn(
            self: *const ITextDocument2,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIMEInProgress: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: fn(
            self: *const ITextDocument2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: fn(
            self: *const ITextDocument2,
            ppSel: ?*?*ITextSelection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges2: fn(
            self: *const ITextDocument2,
            ppStories: ?*?*ITextStoryRanges2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypographyOptions: fn(
            self: *const ITextDocument2,
            pOptions: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const ITextDocument2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: fn(
            self: *const ITextDocument2,
            pHwnd: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachMsgFilter: fn(
            self: *const ITextDocument2,
            pFilter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: fn(
            self: *const ITextDocument2,
            cch: i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: fn(
            self: *const ITextDocument2,
            ppVoid: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: fn(
            self: *const ITextDocument2,
            Type: tomConstants,
            pLeft: ?*i32,
            pTop: ?*i32,
            pRight: ?*i32,
            pBottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: fn(
            self: *const ITextDocument2,
            Index: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: fn(
            self: *const ITextDocument2,
            pContext: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: fn(
            self: *const ITextDocument2,
            cp: i32,
            CharRep: i32,
            Options: i32,
            curCharRep: i32,
            curFontSize: i32,
            pbstr: ?*?BSTR,
            pPitchAndFamily: ?*i32,
            pNewFontSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextDocument2,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrings: fn(
            self: *const ITextDocument2,
            ppStrs: ?*?*ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const ITextDocument2,
            Notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range2: fn(
            self: *const ITextDocument2,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint2: fn(
            self: *const ITextDocument2,
            x: i32,
            y: i32,
            Type: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: fn(
            self: *const ITextDocument2,
            pVoid: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: fn(
            self: *const ITextDocument2,
            Context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: fn(
            self: *const ITextDocument2,
            Index: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextDocument2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypographyOptions: fn(
            self: *const ITextDocument2,
            Options: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: fn(
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: fn(
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathProperties: fn(
            self: *const ITextDocument2,
            pOptions: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathProperties: fn(
            self: *const ITextDocument2,
            Options: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveStory: fn(
            self: *const ITextDocument2,
            pStory: ?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNewStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStory: fn(
            self: *const ITextDocument2,
            Index: i32,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetCaretType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetCaretType(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetCaretType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetCaretType(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDisplays(self: *const T, ppDisplays: ?*?*ITextDisplays) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDisplays(@ptrCast(*const ITextDocument2, self), ppDisplays);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDocumentFont(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDocumentFont(@ptrCast(*const ITextDocument2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetDocumentFont(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetDocumentFont(@ptrCast(*const ITextDocument2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDocumentPara(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDocumentPara(@ptrCast(*const ITextDocument2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetDocumentPara(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetDocumentPara(@ptrCast(*const ITextDocument2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetEastAsianFlags(self: *const T, pFlags: ?*tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetEastAsianFlags(@ptrCast(*const ITextDocument2, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetGenerator(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetGenerator(@ptrCast(*const ITextDocument2, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetIMEInProgress(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetIMEInProgress(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetNotificationMode(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetNotificationMode(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetNotificationMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetNotificationMode(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetSelection2(@ptrCast(*const ITextDocument2, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStoryRanges2(self: *const T, ppStories: ?*?*ITextStoryRanges2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStoryRanges2(@ptrCast(*const ITextDocument2, self), ppStories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetTypographyOptions(self: *const T, pOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetTypographyOptions(@ptrCast(*const ITextDocument2, self), pOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetVersion(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetVersion(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetWindow(self: *const T, pHwnd: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetWindow(@ptrCast(*const ITextDocument2, self), pHwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).AttachMsgFilter(@ptrCast(*const ITextDocument2, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_CheckTextLimit(self: *const T, cch: i32, pcch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).CheckTextLimit(@ptrCast(*const ITextDocument2, self), cch, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetCallManager(@ptrCast(*const ITextDocument2, self), ppVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetClientRect(self: *const T, Type: tomConstants, pLeft: ?*i32, pTop: ?*i32, pRight: ?*i32, pBottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetClientRect(@ptrCast(*const ITextDocument2, self), Type, pLeft, pTop, pRight, pBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetEffectColor(self: *const T, Index: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetEffectColor(@ptrCast(*const ITextDocument2, self), Index, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetImmContext(self: *const T, pContext: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetImmContext(@ptrCast(*const ITextDocument2, self), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Options: i32, curCharRep: i32, curFontSize: i32, pbstr: ?*?BSTR, pPitchAndFamily: ?*i32, pNewFontSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetPreferredFont(@ptrCast(*const ITextDocument2, self), cp, CharRep, Options, curCharRep, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextDocument2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStrings(self: *const T, ppStrs: ?*?*ITextStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStrings(@ptrCast(*const ITextDocument2, self), ppStrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Notify(self: *const T, Notify: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Notify(@ptrCast(*const ITextDocument2, self), Notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Range2(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Range2(@ptrCast(*const ITextDocument2, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_RangeFromPoint2(self: *const T, x: i32, y: i32, Type: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).RangeFromPoint2(@ptrCast(*const ITextDocument2, self), x, y, Type, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).ReleaseCallManager(@ptrCast(*const ITextDocument2, self), pVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_ReleaseImmContext(self: *const T, Context: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).ReleaseImmContext(@ptrCast(*const ITextDocument2, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetEffectColor(self: *const T, Index: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetEffectColor(@ptrCast(*const ITextDocument2, self), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextDocument2, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetTypographyOptions(self: *const T, Options: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetTypographyOptions(@ptrCast(*const ITextDocument2, self), Options, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SysBeep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SysBeep(@ptrCast(*const ITextDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Update(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Update(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_UpdateWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).UpdateWindow(@ptrCast(*const ITextDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetMathProperties(self: *const T, pOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetMathProperties(@ptrCast(*const ITextDocument2, self), pOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetMathProperties(self: *const T, Options: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetMathProperties(@ptrCast(*const ITextDocument2, self), Options, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetActiveStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetActiveStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetActiveStory(self: *const T, pStory: ?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetActiveStory(@ptrCast(*const ITextDocument2, self), pStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetMainStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetMainStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetNewStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetNewStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStory(self: *const T, Index: i32, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStory(@ptrCast(*const ITextDocument2, self), Index, ppStory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRange2_Value = @import("../../zig.zig").Guid.initString("c241f5e2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRange2 = &IID_ITextRange2_Value;
pub const ITextRange2 = extern struct {
    pub const VTable = extern struct {
        base: ITextSelection.VTable,
        GetCch: fn(
            self: *const ITextRange2,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCells: fn(
            self: *const ITextRange2,
            ppCells: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumn: fn(
            self: *const ITextRange2,
            ppColumn: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextRange2,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextRange2,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont2: fn(
            self: *const ITextRange2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont2: fn(
            self: *const ITextRange2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText2: fn(
            self: *const ITextRange2,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText2: fn(
            self: *const ITextRange2,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGravity: fn(
            self: *const ITextRange2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGravity: fn(
            self: *const ITextRange2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara2: fn(
            self: *const ITextRange2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara2: fn(
            self: *const ITextRange2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRow: fn(
            self: *const ITextRange2,
            ppRow: ?*?*ITextRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartPara: fn(
            self: *const ITextRange2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTable: fn(
            self: *const ITextRange2,
            ppTable: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: fn(
            self: *const ITextRange2,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetURL: fn(
            self: *const ITextRange2,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSubrange: fn(
            self: *const ITextRange2,
            cp1: i32,
            cp2: i32,
            Activate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BuildUpMath: fn(
            self: *const ITextRange2,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSubrange: fn(
            self: *const ITextRange2,
            cpFirst: i32,
            cpLim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: fn(
            self: *const ITextRange2,
            pRange: ?*ITextRange2,
            Count: i32,
            Flags: i32,
            pDelta: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar2: fn(
            self: *const ITextRange2,
            pChar: ?*i32,
            Offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropCap: fn(
            self: *const ITextRange2,
            pcLine: ?*i32,
            pPosition: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInlineObject: fn(
            self: *const ITextRange2,
            pType: ?*i32,
            pAlign: ?*i32,
            pChar: ?*i32,
            pChar1: ?*i32,
            pChar2: ?*i32,
            pCount: ?*i32,
            pTeXStyle: ?*i32,
            pcCol: ?*i32,
            pLevel: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextRange2,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRect: fn(
            self: *const ITextRange2,
            Type: i32,
            pLeft: ?*i32,
            pTop: ?*i32,
            pRight: ?*i32,
            pBottom: ?*i32,
            pHit: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubrange: fn(
            self: *const ITextRange2,
            iSubrange: i32,
            pcpFirst: ?*i32,
            pcpLim: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText2: fn(
            self: *const ITextRange2,
            Flags: i32,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HexToUnicode: fn(
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTable: fn(
            self: *const ITextRange2,
            cCol: i32,
            cRow: i32,
            AutoFit: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Linearize: fn(
            self: *const ITextRange2,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveSubrange: fn(
            self: *const ITextRange2,
            cpAnchor: i32,
            cpActive: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDropCap: fn(
            self: *const ITextRange2,
            cLine: i32,
            Position: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextRange2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText2: fn(
            self: *const ITextRange2,
            Flags: i32,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnicodeToHex: fn(
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInlineObject: fn(
            self: *const ITextRange2,
            Type: i32,
            Align: i32,
            Char: i32,
            Char1: i32,
            Char2: i32,
            Count: i32,
            TeXStyle: i32,
            cCol: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathFunctionType: fn(
            self: *const ITextRange2,
            bstr: ?BSTR,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertImage: fn(
            self: *const ITextRange2,
            width: i32,
            height: i32,
            ascent: i32,
            Type: TEXT_ALIGN_OPTIONS,
            bstrAltText: ?BSTR,
            pStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextSelection.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCch(self: *const T, pcch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCch(@ptrCast(*const ITextRange2, self), pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCells(self: *const T, ppCells: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCells(@ptrCast(*const ITextRange2, self), ppCells);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetColumn(self: *const T, ppColumn: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetColumn(@ptrCast(*const ITextRange2, self), ppColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCount(@ptrCast(*const ITextRange2, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetDuplicate2(self: *const T, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextRange2, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetFont2(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetFont2(@ptrCast(*const ITextRange2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetFont2(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetFont2(@ptrCast(*const ITextRange2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetFormattedText2(self: *const T, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetFormattedText2(@ptrCast(*const ITextRange2, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetFormattedText2(self: *const T, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetFormattedText2(@ptrCast(*const ITextRange2, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetGravity(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetGravity(@ptrCast(*const ITextRange2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetGravity(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetGravity(@ptrCast(*const ITextRange2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetPara2(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetPara2(@ptrCast(*const ITextRange2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetPara2(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetPara2(@ptrCast(*const ITextRange2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetRow(self: *const T, ppRow: ?*?*ITextRow) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetRow(@ptrCast(*const ITextRange2, self), ppRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetStartPara(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetStartPara(@ptrCast(*const ITextRange2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetTable(self: *const T, ppTable: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetTable(@ptrCast(*const ITextRange2, self), ppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetURL(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetURL(@ptrCast(*const ITextRange2, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetURL(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetURL(@ptrCast(*const ITextRange2, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_AddSubrange(self: *const T, cp1: i32, cp2: i32, Activate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).AddSubrange(@ptrCast(*const ITextRange2, self), cp1, cp2, Activate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_BuildUpMath(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).BuildUpMath(@ptrCast(*const ITextRange2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_DeleteSubrange(self: *const T, cpFirst: i32, cpLim: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).DeleteSubrange(@ptrCast(*const ITextRange2, self), cpFirst, cpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_Find(self: *const T, pRange: ?*ITextRange2, Count: i32, Flags: i32, pDelta: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).Find(@ptrCast(*const ITextRange2, self), pRange, Count, Flags, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetChar2(self: *const T, pChar: ?*i32, Offset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetChar2(@ptrCast(*const ITextRange2, self), pChar, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetDropCap(self: *const T, pcLine: ?*i32, pPosition: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetDropCap(@ptrCast(*const ITextRange2, self), pcLine, pPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetInlineObject(self: *const T, pType: ?*i32, pAlign: ?*i32, pChar: ?*i32, pChar1: ?*i32, pChar2: ?*i32, pCount: ?*i32, pTeXStyle: ?*i32, pcCol: ?*i32, pLevel: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetInlineObject(@ptrCast(*const ITextRange2, self), pType, pAlign, pChar, pChar1, pChar2, pCount, pTeXStyle, pcCol, pLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextRange2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetRect(self: *const T, Type: i32, pLeft: ?*i32, pTop: ?*i32, pRight: ?*i32, pBottom: ?*i32, pHit: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetRect(@ptrCast(*const ITextRange2, self), Type, pLeft, pTop, pRight, pBottom, pHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetSubrange(self: *const T, iSubrange: i32, pcpFirst: ?*i32, pcpLim: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetSubrange(@ptrCast(*const ITextRange2, self), iSubrange, pcpFirst, pcpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetText2(self: *const T, Flags: i32, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetText2(@ptrCast(*const ITextRange2, self), Flags, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_HexToUnicode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).HexToUnicode(@ptrCast(*const ITextRange2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_InsertTable(self: *const T, cCol: i32, cRow: i32, AutoFit: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).InsertTable(@ptrCast(*const ITextRange2, self), cCol, cRow, AutoFit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_Linearize(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).Linearize(@ptrCast(*const ITextRange2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetActiveSubrange(self: *const T, cpAnchor: i32, cpActive: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetActiveSubrange(@ptrCast(*const ITextRange2, self), cpAnchor, cpActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetDropCap(self: *const T, cLine: i32, Position: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetDropCap(@ptrCast(*const ITextRange2, self), cLine, Position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextRange2, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetText2(self: *const T, Flags: i32, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetText2(@ptrCast(*const ITextRange2, self), Flags, bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_UnicodeToHex(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).UnicodeToHex(@ptrCast(*const ITextRange2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetInlineObject(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetInlineObject(@ptrCast(*const ITextRange2, self), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetMathFunctionType(self: *const T, bstr: ?BSTR, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetMathFunctionType(@ptrCast(*const ITextRange2, self), bstr, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_InsertImage(self: *const T, width: i32, height: i32, ascent: i32, Type: TEXT_ALIGN_OPTIONS, bstrAltText: ?BSTR, pStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).InsertImage(@ptrCast(*const ITextRange2, self), width, height, ascent, Type, bstrAltText, pStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextSelection2_Value = @import("../../zig.zig").Guid.initString("c241f5e1-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextSelection2 = &IID_ITextSelection2_Value;
pub const ITextSelection2 = extern struct {
    pub const VTable = extern struct {
        base: ITextRange2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRange2.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextFont2_Value = @import("../../zig.zig").Guid.initString("c241f5e3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextFont2 = &IID_ITextFont2_Value;
pub const ITextFont2 = extern struct {
    pub const VTable = extern struct {
        base: ITextFont.VTable,
        GetCount: fn(
            self: *const ITextFont2,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutoLigatures: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutoLigatures: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceAlpha: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceAlpha: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceNumeric: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceNumeric: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceParens: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceParens: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharRep: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCharRep: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompressionMode: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompressionMode: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCookie: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCookie: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDoubleStrike: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDoubleStrike: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextFont2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: fn(
            self: *const ITextFont2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkType: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathZone: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathZone: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthPairs: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthPairs: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthSpace: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthSpace: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOldNumbers: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOldNumbers: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlapping: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlapping: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositionSubSuper: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPositionSubSuper: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScaling: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScaling: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceExtension: fn(
            self: *const ITextFont2,
            pValue: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceExtension: fn(
            self: *const ITextFont2,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderlinePositionMode: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderlinePositionMode: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
            pMask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects2: fn(
            self: *const ITextFont2,
            pValue: ?*i32,
            pMask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextFont2,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: fn(
            self: *const ITextFont2,
            Index: i32,
            pType: ?*i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: fn(
            self: *const ITextFont2,
            pFont: ?*ITextFont2,
            pB: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: fn(
            self: *const ITextFont2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects2: fn(
            self: *const ITextFont2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextFont2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextFont.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCount(@ptrCast(*const ITextFont2, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutoLigatures(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutoLigatures(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutoLigatures(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutoLigatures(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceAlpha(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceAlpha(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceAlpha(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceAlpha(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceNumeric(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceNumeric(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceNumeric(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceNumeric(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceParens(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceParens(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceParens(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceParens(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCharRep(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCharRep(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCharRep(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCharRep(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCompressionMode(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCompressionMode(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCompressionMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCompressionMode(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCookie(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCookie(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCookie(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCookie(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetDoubleStrike(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetDoubleStrike(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetDoubleStrike(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetDoubleStrike(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetDuplicate2(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextFont2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetDuplicate2(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetDuplicate2(@ptrCast(*const ITextFont2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetLinkType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetLinkType(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetMathZone(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetMathZone(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetMathZone(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetMathZone(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetModWidthPairs(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetModWidthPairs(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetModWidthPairs(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetModWidthPairs(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetModWidthSpace(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetModWidthSpace(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetModWidthSpace(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetModWidthSpace(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetOldNumbers(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetOldNumbers(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetOldNumbers(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetOldNumbers(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetOverlapping(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetOverlapping(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetOverlapping(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetOverlapping(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetPositionSubSuper(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetPositionSubSuper(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetPositionSubSuper(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetPositionSubSuper(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetScaling(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetScaling(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetScaling(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetScaling(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetSpaceExtension(self: *const T, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetSpaceExtension(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetSpaceExtension(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetSpaceExtension(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetUnderlinePositionMode(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetUnderlinePositionMode(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetUnderlinePositionMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetUnderlinePositionMode(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetEffects(self: *const T, pValue: ?*i32, pMask: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetEffects(@ptrCast(*const ITextFont2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetEffects2(self: *const T, pValue: ?*i32, pMask: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetEffects2(@ptrCast(*const ITextFont2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextFont2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetPropertyInfo(self: *const T, Index: i32, pType: ?*i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetPropertyInfo(@ptrCast(*const ITextFont2, self), Index, pType, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_IsEqual2(self: *const T, pFont: ?*ITextFont2, pB: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).IsEqual2(@ptrCast(*const ITextFont2, self), pFont, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetEffects(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetEffects(@ptrCast(*const ITextFont2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetEffects2(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetEffects2(@ptrCast(*const ITextFont2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextFont2, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextPara2_Value = @import("../../zig.zig").Guid.initString("c241f5e4-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextPara2 = &IID_ITextPara2_Value;
pub const ITextPara2 = extern struct {
    pub const VTable = extern struct {
        base: ITextPara.VTable,
        GetBorders: fn(
            self: *const ITextPara2,
            ppBorders: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextPara2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: fn(
            self: *const ITextPara2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFontAlignment: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFontAlignment: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHangingPunctuation: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHangingPunctuation: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapToGrid: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapToGrid: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrimPunctuationAtStart: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrimPunctuationAtStart: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: fn(
            self: *const ITextPara2,
            pValue: ?*i32,
            pMask: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextPara2,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: fn(
            self: *const ITextPara2,
            pPara: ?*ITextPara2,
            pB: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: fn(
            self: *const ITextPara2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextPara2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextPara.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetBorders(self: *const T, ppBorders: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetBorders(@ptrCast(*const ITextPara2, self), ppBorders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetDuplicate2(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextPara2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetDuplicate2(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetDuplicate2(@ptrCast(*const ITextPara2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetFontAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetFontAlignment(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetFontAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetFontAlignment(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetHangingPunctuation(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetHangingPunctuation(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetHangingPunctuation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetHangingPunctuation(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetSnapToGrid(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetSnapToGrid(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetSnapToGrid(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetSnapToGrid(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetTrimPunctuationAtStart(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetTrimPunctuationAtStart(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetTrimPunctuationAtStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetTrimPunctuationAtStart(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetEffects(self: *const T, pValue: ?*i32, pMask: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetEffects(@ptrCast(*const ITextPara2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextPara2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_IsEqual2(self: *const T, pPara: ?*ITextPara2, pB: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).IsEqual2(@ptrCast(*const ITextPara2, self), pPara, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetEffects(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetEffects(@ptrCast(*const ITextPara2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextPara2, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStoryRanges2_Value = @import("../../zig.zig").Guid.initString("c241f5e5-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStoryRanges2 = &IID_ITextStoryRanges2_Value;
pub const ITextStoryRanges2 = extern struct {
    pub const VTable = extern struct {
        base: ITextStoryRanges.VTable,
        Item2: fn(
            self: *const ITextStoryRanges2,
            Index: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextStoryRanges.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges2_Item2(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges2.VTable, self.vtable).Item2(@ptrCast(*const ITextStoryRanges2, self), Index, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStory_Value = @import("../../zig.zig").Guid.initString("c241f5f3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStory = &IID_ITextStory_Value;
pub const ITextStory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActive: fn(
            self: *const ITextStory,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActive: fn(
            self: *const ITextStory,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplay: fn(
            self: *const ITextStory,
            ppDisplay: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const ITextStory,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ITextStory,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetType: fn(
            self: *const ITextStory,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextStory,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRange: fn(
            self: *const ITextStory,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITextStory,
            Flags: i32,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextStory,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextStory,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextStory,
            Flags: i32,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetActive(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetActive(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetActive(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetActive(@ptrCast(*const ITextStory, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetDisplay(self: *const T, ppDisplay: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetDisplay(@ptrCast(*const ITextStory, self), ppDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetIndex(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetIndex(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetType(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetType(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetType(@ptrCast(*const ITextStory, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetProperty(@ptrCast(*const ITextStory, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetRange(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetRange(@ptrCast(*const ITextStory, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetText(self: *const T, Flags: i32, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetText(@ptrCast(*const ITextStory, self), Flags, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetFormattedText(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextStory, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetProperty(@ptrCast(*const ITextStory, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetText(self: *const T, Flags: i32, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetText(@ptrCast(*const ITextStory, self), Flags, bstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextStrings_Value = @import("../../zig.zig").Guid.initString("c241f5e7-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStrings = &IID_ITextStrings_Value;
pub const ITextStrings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: fn(
            self: *const ITextStrings,
            Index: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextStrings,
            pCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ITextStrings,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: fn(
            self: *const ITextStrings,
            pRange: ?*ITextRange2,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cat2: fn(
            self: *const ITextStrings,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CatTop2: fn(
            self: *const ITextStrings,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRange: fn(
            self: *const ITextStrings,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeFunction: fn(
            self: *const ITextStrings,
            Type: i32,
            Align: i32,
            Char: i32,
            Char1: i32,
            Char2: i32,
            Count: i32,
            TeXStyle: i32,
            cCol: i32,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCch: fn(
            self: *const ITextStrings,
            iString: i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertNullStr: fn(
            self: *const ITextStrings,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveBoundary: fn(
            self: *const ITextStrings,
            iString: i32,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrefixTop: fn(
            self: *const ITextStrings,
            bstr: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ITextStrings,
            iString: i32,
            cString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextStrings,
            pRangeD: ?*ITextRange2,
            pRangeS: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpCp: fn(
            self: *const ITextStrings,
            iString: i32,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuffixTop: fn(
            self: *const ITextStrings,
            bstr: ?BSTR,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Swap: fn(
            self: *const ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Item(@ptrCast(*const ITextStrings, self), Index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_GetCount(self: *const T, pCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).GetCount(@ptrCast(*const ITextStrings, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Add(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Add(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Append(self: *const T, pRange: ?*ITextRange2, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Append(@ptrCast(*const ITextStrings, self), pRange, iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Cat2(self: *const T, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Cat2(@ptrCast(*const ITextStrings, self), iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_CatTop2(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).CatTop2(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_DeleteRange(self: *const T, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).DeleteRange(@ptrCast(*const ITextStrings, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_EncodeFunction(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).EncodeFunction(@ptrCast(*const ITextStrings, self), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_GetCch(self: *const T, iString: i32, pcch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).GetCch(@ptrCast(*const ITextStrings, self), iString, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_InsertNullStr(self: *const T, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).InsertNullStr(@ptrCast(*const ITextStrings, self), iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_MoveBoundary(self: *const T, iString: i32, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).MoveBoundary(@ptrCast(*const ITextStrings, self), iString, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_PrefixTop(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).PrefixTop(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Remove(self: *const T, iString: i32, cString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Remove(@ptrCast(*const ITextStrings, self), iString, cString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SetFormattedText(self: *const T, pRangeD: ?*ITextRange2, pRangeS: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextStrings, self), pRangeD, pRangeS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SetOpCp(self: *const T, iString: i32, cp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SetOpCp(@ptrCast(*const ITextStrings, self), iString, cp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SuffixTop(self: *const T, bstr: ?BSTR, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SuffixTop(@ptrCast(*const ITextStrings, self), bstr, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Swap(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Swap(@ptrCast(*const ITextStrings, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextRow_Value = @import("../../zig.zig").Guid.initString("c241f5ef-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRow = &IID_ITextRow_Value;
pub const ITextRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetAlignment: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCount: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCount: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCountCache: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCountCache: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellIndex: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellIndex: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMargin: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMargin: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeight: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeight: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndent: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndent: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNestLevel: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRTL: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRTL: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellAlignment: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellAlignment: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorBack: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorBack: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorFore: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorFore: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMergeFlags: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMergeFlags: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellShading: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellShading: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellVerticalText: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellVerticalText: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellWidth: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellWidth: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderColors: fn(
            self: *const ITextRow,
            pcrLeft: ?*i32,
            pcrTop: ?*i32,
            pcrRight: ?*i32,
            pcrBottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderWidths: fn(
            self: *const ITextRow,
            pduLeft: ?*i32,
            pduTop: ?*i32,
            pduRight: ?*i32,
            pduBottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderColors: fn(
            self: *const ITextRow,
            crLeft: i32,
            crTop: i32,
            crRight: i32,
            crBottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderWidths: fn(
            self: *const ITextRow,
            duLeft: i32,
            duTop: i32,
            duRight: i32,
            duBottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Apply: fn(
            self: *const ITextRow,
            cRow: i32,
            Flags: tomConstants,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextRow,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextRow,
            Type: i32,
            pValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Insert: fn(
            self: *const ITextRow,
            cRow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextRow,
            pRow: ?*ITextRow,
            pB: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextRow,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetAlignment(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetAlignment(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellCount(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellCount(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellCount(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellCount(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellCountCache(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellCountCache(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellCountCache(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellCountCache(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellIndex(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellIndex(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellIndex(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellIndex(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellMargin(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellMargin(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellMargin(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellMargin(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetHeight(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetHeight(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetHeight(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetHeight(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetIndent(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetIndent(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetIndent(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetIndent(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetKeepTogether(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetKeepTogether(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetKeepTogether(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetKeepTogether(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetKeepWithNext(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetKeepWithNext(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetKeepWithNext(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetKeepWithNext(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetNestLevel(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetNestLevel(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetRTL(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetRTL(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetRTL(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetRTL(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellAlignment(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellAlignment(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellAlignment(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellColorBack(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellColorBack(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellColorBack(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellColorBack(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellColorFore(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellColorFore(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellColorFore(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellColorFore(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellMergeFlags(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellMergeFlags(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellMergeFlags(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellMergeFlags(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellShading(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellShading(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellShading(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellShading(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellVerticalText(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellVerticalText(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellVerticalText(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellVerticalText(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellWidth(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellWidth(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellWidth(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellWidth(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellBorderColors(self: *const T, pcrLeft: ?*i32, pcrTop: ?*i32, pcrRight: ?*i32, pcrBottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellBorderColors(@ptrCast(*const ITextRow, self), pcrLeft, pcrTop, pcrRight, pcrBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellBorderWidths(self: *const T, pduLeft: ?*i32, pduTop: ?*i32, pduRight: ?*i32, pduBottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellBorderWidths(@ptrCast(*const ITextRow, self), pduLeft, pduTop, pduRight, pduBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellBorderColors(self: *const T, crLeft: i32, crTop: i32, crRight: i32, crBottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellBorderColors(@ptrCast(*const ITextRow, self), crLeft, crTop, crRight, crBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellBorderWidths(self: *const T, duLeft: i32, duTop: i32, duRight: i32, duBottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellBorderWidths(@ptrCast(*const ITextRow, self), duLeft, duTop, duRight, duBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Apply(self: *const T, cRow: i32, Flags: tomConstants) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Apply(@ptrCast(*const ITextRow, self), cRow, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_CanChange(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).CanChange(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetProperty(self: *const T, Type: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetProperty(@ptrCast(*const ITextRow, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Insert(self: *const T, cRow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Insert(@ptrCast(*const ITextRow, self), cRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_IsEqual(self: *const T, pRow: ?*ITextRow, pB: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).IsEqual(@ptrCast(*const ITextRow, self), pRow, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Reset(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Reset(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetProperty(@ptrCast(*const ITextRow, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITextDisplays_Value = @import("../../zig.zig").Guid.initString("c241f5f2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDisplays = &IID_ITextDisplays_Value;
pub const ITextDisplays = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextDocument2Old_Value = @import("../../zig.zig").Guid.initString("01c25500-4268-11d1-883a-3c8b00c10000");
pub const IID_ITextDocument2Old = &IID_ITextDocument2Old_Value;
pub const ITextDocument2Old = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        AttachMsgFilter: fn(
            self: *const ITextDocument2Old,
            pFilter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: fn(
            self: *const ITextDocument2Old,
            Index: i32,
            cr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: fn(
            self: *const ITextDocument2Old,
            Index: i32,
            pcr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaretType: fn(
            self: *const ITextDocument2Old,
            pCaretType: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: fn(
            self: *const ITextDocument2Old,
            CaretType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: fn(
            self: *const ITextDocument2Old,
            pContext: ?*i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: fn(
            self: *const ITextDocument2Old,
            Context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: fn(
            self: *const ITextDocument2Old,
            cp: i32,
            CharRep: i32,
            Option: i32,
            CharRepCur: i32,
            curFontSize: i32,
            pbstr: ?*?BSTR,
            pPitchAndFamily: ?*i32,
            pNewFontSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: fn(
            self: *const ITextDocument2Old,
            pMode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: fn(
            self: *const ITextDocument2Old,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: fn(
            self: *const ITextDocument2Old,
            Type: i32,
            pLeft: ?*i32,
            pTop: ?*i32,
            pRight: ?*i32,
            pBottom: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: fn(
            self: *const ITextDocument2Old,
            ppSel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: fn(
            self: *const ITextDocument2Old,
            phWnd: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFEFlags: fn(
            self: *const ITextDocument2Old,
            pFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: fn(
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: fn(
            self: *const ITextDocument2Old,
            cch: i32,
            pcch: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IMEInProgress: fn(
            self: *const ITextDocument2Old,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: fn(
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const ITextDocument2Old,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const ITextDocument2Old,
            Notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: fn(
            self: *const ITextDocument2Old,
            ppITextFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: fn(
            self: *const ITextDocument2Old,
            ppITextPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: fn(
            self: *const ITextDocument2Old,
            ppVoid: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: fn(
            self: *const ITextDocument2Old,
            pVoid: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).AttachMsgFilter(@ptrCast(*const ITextDocument2Old, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetEffectColor(self: *const T, Index: i32, cr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetEffectColor(@ptrCast(*const ITextDocument2Old, self), Index, cr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetEffectColor(self: *const T, Index: i32, pcr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetEffectColor(@ptrCast(*const ITextDocument2Old, self), Index, pcr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetCaretType(self: *const T, pCaretType: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetCaretType(@ptrCast(*const ITextDocument2Old, self), pCaretType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetCaretType(self: *const T, CaretType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetCaretType(@ptrCast(*const ITextDocument2Old, self), CaretType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetImmContext(self: *const T, pContext: ?*i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetImmContext(@ptrCast(*const ITextDocument2Old, self), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_ReleaseImmContext(self: *const T, Context: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).ReleaseImmContext(@ptrCast(*const ITextDocument2Old, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Option: i32, CharRepCur: i32, curFontSize: i32, pbstr: ?*?BSTR, pPitchAndFamily: ?*i32, pNewFontSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetPreferredFont(@ptrCast(*const ITextDocument2Old, self), cp, CharRep, Option, CharRepCur, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetNotificationMode(self: *const T, pMode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetNotificationMode(@ptrCast(*const ITextDocument2Old, self), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetNotificationMode(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetNotificationMode(@ptrCast(*const ITextDocument2Old, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetClientRect(self: *const T, Type: i32, pLeft: ?*i32, pTop: ?*i32, pRight: ?*i32, pBottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetClientRect(@ptrCast(*const ITextDocument2Old, self), Type, pLeft, pTop, pRight, pBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetSelection2(@ptrCast(*const ITextDocument2Old, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetWindow(self: *const T, phWnd: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetWindow(@ptrCast(*const ITextDocument2Old, self), phWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetFEFlags(self: *const T, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetFEFlags(@ptrCast(*const ITextDocument2Old, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_UpdateWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).UpdateWindow(@ptrCast(*const ITextDocument2Old, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_CheckTextLimit(self: *const T, cch: i32, pcch: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).CheckTextLimit(@ptrCast(*const ITextDocument2Old, self), cch, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_IMEInProgress(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).IMEInProgress(@ptrCast(*const ITextDocument2Old, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SysBeep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SysBeep(@ptrCast(*const ITextDocument2Old, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_Update(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).Update(@ptrCast(*const ITextDocument2Old, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_Notify(self: *const T, Notify: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).Notify(@ptrCast(*const ITextDocument2Old, self), Notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetDocumentFont(self: *const T, ppITextFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetDocumentFont(@ptrCast(*const ITextDocument2Old, self), ppITextFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetDocumentPara(self: *const T, ppITextPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetDocumentPara(@ptrCast(*const ITextDocument2Old, self), ppITextPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetCallManager(@ptrCast(*const ITextDocument2Old, self), ppVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).ReleaseCallManager(@ptrCast(*const ITextDocument2Old, self), pVoid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (5)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const CHARFORMAT = thismodule.CHARFORMATA;
        pub const CHARFORMAT2 = thismodule.CHARFORMAT2A;
        pub const TEXTRANGE = thismodule.TEXTRANGEA;
        pub const FINDTEXT = thismodule.FINDTEXTA;
        pub const FINDTEXTEX = thismodule.FINDTEXTEXA;
    },
    .wide => struct {
        pub const CHARFORMAT = thismodule.CHARFORMATW;
        pub const CHARFORMAT2 = thismodule.CHARFORMAT2W;
        pub const TEXTRANGE = thismodule.TEXTRANGEW;
        pub const FINDTEXT = thismodule.FINDTEXTW;
        pub const FINDTEXTEX = thismodule.FINDTEXTEXW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const CHARFORMAT = *opaque{};
        pub const CHARFORMAT2 = *opaque{};
        pub const TEXTRANGE = *opaque{};
        pub const FINDTEXT = *opaque{};
        pub const FINDTEXTEX = *opaque{};
    } else struct {
        pub const CHARFORMAT = @compileError("'CHARFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT2 = @compileError("'CHARFORMAT2' requires that UNICODE be set to true or false in the root module");
        pub const TEXTRANGE = @compileError("'TEXTRANGE' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXT = @compileError("'FINDTEXT' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXTEX = @compileError("'FINDTEXTEX' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (43)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BSTR = @import("../../foundation.zig").BSTR;
const CHAR = @import("../../foundation.zig").CHAR;
const DVASPECT = @import("../../system/com.zig").DVASPECT;
const DVTARGETDEVICE = @import("../../system/com.zig").DVTARGETDEVICE;
const ENABLE_SCROLL_BAR_ARROWS = @import("../../ui/controls.zig").ENABLE_SCROLL_BAR_ARROWS;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HBITMAP = @import("../../graphics/gdi.zig").HBITMAP;
const HCURSOR = @import("../../ui/windows_and_messaging.zig").HCURSOR;
const HDC = @import("../../graphics/gdi.zig").HDC;
const HIMC = @import("../../globalization.zig").HIMC;
const HMENU = @import("../../ui/windows_and_messaging.zig").HMENU;
const HPALETTE = @import("../../graphics/gdi.zig").HPALETTE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HRGN = @import("../../graphics/gdi.zig").HRGN;
const HWND = @import("../../foundation.zig").HWND;
const ID2D1RenderTarget = @import("../../graphics/direct2d.zig").ID2D1RenderTarget;
const IDataObject = @import("../../system/com.zig").IDataObject;
const IDispatch = @import("../../system/com.zig").IDispatch;
const IDropTarget = @import("../../system/ole.zig").IDropTarget;
const IOleClientSite = @import("../../system/ole.zig").IOleClientSite;
const IOleInPlaceFrame = @import("../../system/ole.zig").IOleInPlaceFrame;
const IOleInPlaceUIWindow = @import("../../system/ole.zig").IOleInPlaceUIWindow;
const IOleObject = @import("../../system/ole.zig").IOleObject;
const IStorage = @import("../../system/com/structured_storage.zig").IStorage;
const IStream = @import("../../system/com.zig").IStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LPARAM = @import("../../foundation.zig").LPARAM;
const LRESULT = @import("../../foundation.zig").LRESULT;
const NMHDR = @import("../../ui/controls.zig").NMHDR;
const OIFI = @import("../../system/ole.zig").OIFI;
const POINT = @import("../../foundation.zig").POINT;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const RECT = @import("../../foundation.zig").RECT;
const RECTL = @import("../../foundation.zig").RECTL;
const SCROLLBAR_CONSTANTS = @import("../../ui/windows_and_messaging.zig").SCROLLBAR_CONSTANTS;
const SHOW_WINDOW_CMD = @import("../../ui/windows_and_messaging.zig").SHOW_WINDOW_CMD;
const SIZE = @import("../../foundation.zig").SIZE;
const TEXT_ALIGN_OPTIONS = @import("../../graphics/gdi.zig").TEXT_ALIGN_OPTIONS;
const VARIANT = @import("../../system/com.zig").VARIANT;
const WPARAM = @import("../../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "AutoCorrectProc")) { _ = AutoCorrectProc; }
    if (@hasDecl(@This(), "EDITWORDBREAKPROCEX")) { _ = EDITWORDBREAKPROCEX; }
    if (@hasDecl(@This(), "EDITSTREAMCALLBACK")) { _ = EDITSTREAMCALLBACK; }
    if (@hasDecl(@This(), "PCreateTextServices")) { _ = PCreateTextServices; }
    if (@hasDecl(@This(), "PShutdownTextServices")) { _ = PShutdownTextServices; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
