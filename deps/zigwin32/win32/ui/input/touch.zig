//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (16)
//--------------------------------------------------------------------------------
pub const GESTURECONFIG_ID = enum(u32) {
    BEGIN = 1,
    END = 2,
    ZOOM = 3,
    PAN = 4,
    ROTATE = 5,
    TWOFINGERTAP = 6,
    PRESSANDTAP = 7,
    // ROLLOVER = 7, this enum value conflicts with PRESSANDTAP
    _,
    pub fn initFlags(o: struct {
        BEGIN: u1 = 0,
        END: u1 = 0,
        ZOOM: u1 = 0,
        PAN: u1 = 0,
        ROTATE: u1 = 0,
        TWOFINGERTAP: u1 = 0,
        PRESSANDTAP: u1 = 0,
    }) GESTURECONFIG_ID {
        return @intToEnum(GESTURECONFIG_ID,
              (if (o.BEGIN == 1) @enumToInt(GESTURECONFIG_ID.BEGIN) else 0)
            | (if (o.END == 1) @enumToInt(GESTURECONFIG_ID.END) else 0)
            | (if (o.ZOOM == 1) @enumToInt(GESTURECONFIG_ID.ZOOM) else 0)
            | (if (o.PAN == 1) @enumToInt(GESTURECONFIG_ID.PAN) else 0)
            | (if (o.ROTATE == 1) @enumToInt(GESTURECONFIG_ID.ROTATE) else 0)
            | (if (o.TWOFINGERTAP == 1) @enumToInt(GESTURECONFIG_ID.TWOFINGERTAP) else 0)
            | (if (o.PRESSANDTAP == 1) @enumToInt(GESTURECONFIG_ID.PRESSANDTAP) else 0)
        );
    }
};
pub const GID_BEGIN = GESTURECONFIG_ID.BEGIN;
pub const GID_END = GESTURECONFIG_ID.END;
pub const GID_ZOOM = GESTURECONFIG_ID.ZOOM;
pub const GID_PAN = GESTURECONFIG_ID.PAN;
pub const GID_ROTATE = GESTURECONFIG_ID.ROTATE;
pub const GID_TWOFINGERTAP = GESTURECONFIG_ID.TWOFINGERTAP;
pub const GID_PRESSANDTAP = GESTURECONFIG_ID.PRESSANDTAP;
pub const GID_ROLLOVER = GESTURECONFIG_ID.PRESSANDTAP;

pub const TOUCHEVENTF_FLAGS = enum(u32) {
    MOVE = 1,
    DOWN = 2,
    UP = 4,
    INRANGE = 8,
    PRIMARY = 16,
    NOCOALESCE = 32,
    PEN = 64,
    PALM = 128,
    _,
    pub fn initFlags(o: struct {
        MOVE: u1 = 0,
        DOWN: u1 = 0,
        UP: u1 = 0,
        INRANGE: u1 = 0,
        PRIMARY: u1 = 0,
        NOCOALESCE: u1 = 0,
        PEN: u1 = 0,
        PALM: u1 = 0,
    }) TOUCHEVENTF_FLAGS {
        return @intToEnum(TOUCHEVENTF_FLAGS,
              (if (o.MOVE == 1) @enumToInt(TOUCHEVENTF_FLAGS.MOVE) else 0)
            | (if (o.DOWN == 1) @enumToInt(TOUCHEVENTF_FLAGS.DOWN) else 0)
            | (if (o.UP == 1) @enumToInt(TOUCHEVENTF_FLAGS.UP) else 0)
            | (if (o.INRANGE == 1) @enumToInt(TOUCHEVENTF_FLAGS.INRANGE) else 0)
            | (if (o.PRIMARY == 1) @enumToInt(TOUCHEVENTF_FLAGS.PRIMARY) else 0)
            | (if (o.NOCOALESCE == 1) @enumToInt(TOUCHEVENTF_FLAGS.NOCOALESCE) else 0)
            | (if (o.PEN == 1) @enumToInt(TOUCHEVENTF_FLAGS.PEN) else 0)
            | (if (o.PALM == 1) @enumToInt(TOUCHEVENTF_FLAGS.PALM) else 0)
        );
    }
};
pub const TOUCHEVENTF_MOVE = TOUCHEVENTF_FLAGS.MOVE;
pub const TOUCHEVENTF_DOWN = TOUCHEVENTF_FLAGS.DOWN;
pub const TOUCHEVENTF_UP = TOUCHEVENTF_FLAGS.UP;
pub const TOUCHEVENTF_INRANGE = TOUCHEVENTF_FLAGS.INRANGE;
pub const TOUCHEVENTF_PRIMARY = TOUCHEVENTF_FLAGS.PRIMARY;
pub const TOUCHEVENTF_NOCOALESCE = TOUCHEVENTF_FLAGS.NOCOALESCE;
pub const TOUCHEVENTF_PEN = TOUCHEVENTF_FLAGS.PEN;
pub const TOUCHEVENTF_PALM = TOUCHEVENTF_FLAGS.PALM;

pub const TOUCHINPUTMASKF_MASK = enum(u32) {
    TIMEFROMSYSTEM = 1,
    EXTRAINFO = 2,
    CONTACTAREA = 4,
    _,
    pub fn initFlags(o: struct {
        TIMEFROMSYSTEM: u1 = 0,
        EXTRAINFO: u1 = 0,
        CONTACTAREA: u1 = 0,
    }) TOUCHINPUTMASKF_MASK {
        return @intToEnum(TOUCHINPUTMASKF_MASK,
              (if (o.TIMEFROMSYSTEM == 1) @enumToInt(TOUCHINPUTMASKF_MASK.TIMEFROMSYSTEM) else 0)
            | (if (o.EXTRAINFO == 1) @enumToInt(TOUCHINPUTMASKF_MASK.EXTRAINFO) else 0)
            | (if (o.CONTACTAREA == 1) @enumToInt(TOUCHINPUTMASKF_MASK.CONTACTAREA) else 0)
        );
    }
};
pub const TOUCHINPUTMASKF_TIMEFROMSYSTEM = TOUCHINPUTMASKF_MASK.TIMEFROMSYSTEM;
pub const TOUCHINPUTMASKF_EXTRAINFO = TOUCHINPUTMASKF_MASK.EXTRAINFO;
pub const TOUCHINPUTMASKF_CONTACTAREA = TOUCHINPUTMASKF_MASK.CONTACTAREA;

pub const REGISTER_TOUCH_WINDOW_FLAGS = enum(u32) {
    FINETOUCH = 1,
    WANTPALM = 2,
};
pub const TWF_FINETOUCH = REGISTER_TOUCH_WINDOW_FLAGS.FINETOUCH;
pub const TWF_WANTPALM = REGISTER_TOUCH_WINDOW_FLAGS.WANTPALM;

pub const HGESTUREINFO = *opaque{};

pub const HTOUCHINPUT = *opaque{};

const CLSID_InertiaProcessor_Value = @import("../../zig.zig").Guid.initString("abb27087-4ce0-4e58-a0cb-e24df96814be");
pub const CLSID_InertiaProcessor = &CLSID_InertiaProcessor_Value;

const CLSID_ManipulationProcessor_Value = @import("../../zig.zig").Guid.initString("597d4fb0-47fd-4aff-89b9-c6cfae8cf08e");
pub const CLSID_ManipulationProcessor = &CLSID_ManipulationProcessor_Value;

pub const MANIPULATION_PROCESSOR_MANIPULATIONS = enum(i32) {
    NONE = 0,
    TRANSLATE_X = 1,
    TRANSLATE_Y = 2,
    SCALE = 4,
    ROTATE = 8,
    ALL = 15,
};
pub const MANIPULATION_NONE = MANIPULATION_PROCESSOR_MANIPULATIONS.NONE;
pub const MANIPULATION_TRANSLATE_X = MANIPULATION_PROCESSOR_MANIPULATIONS.TRANSLATE_X;
pub const MANIPULATION_TRANSLATE_Y = MANIPULATION_PROCESSOR_MANIPULATIONS.TRANSLATE_Y;
pub const MANIPULATION_SCALE = MANIPULATION_PROCESSOR_MANIPULATIONS.SCALE;
pub const MANIPULATION_ROTATE = MANIPULATION_PROCESSOR_MANIPULATIONS.ROTATE;
pub const MANIPULATION_ALL = MANIPULATION_PROCESSOR_MANIPULATIONS.ALL;

// TODO: this type is limited to platform 'windows6.1'
const IID__IManipulationEvents_Value = @import("../../zig.zig").Guid.initString("4f62c8da-9c53-4b22-93df-927a862bbb03");
pub const IID__IManipulationEvents = &IID__IManipulationEvents_Value;
pub const _IManipulationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ManipulationStarted: fn(
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ManipulationDelta: fn(
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
            translationDeltaX: f32,
            translationDeltaY: f32,
            scaleDelta: f32,
            expansionDelta: f32,
            rotationDelta: f32,
            cumulativeTranslationX: f32,
            cumulativeTranslationY: f32,
            cumulativeScale: f32,
            cumulativeExpansion: f32,
            cumulativeRotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ManipulationCompleted: fn(
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
            cumulativeTranslationX: f32,
            cumulativeTranslationY: f32,
            cumulativeScale: f32,
            cumulativeExpansion: f32,
            cumulativeRotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _IManipulationEvents_ManipulationStarted(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _IManipulationEvents.VTable, self.vtable).ManipulationStarted(@ptrCast(*const _IManipulationEvents, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _IManipulationEvents_ManipulationDelta(self: *const T, x: f32, y: f32, translationDeltaX: f32, translationDeltaY: f32, scaleDelta: f32, expansionDelta: f32, rotationDelta: f32, cumulativeTranslationX: f32, cumulativeTranslationY: f32, cumulativeScale: f32, cumulativeExpansion: f32, cumulativeRotation: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _IManipulationEvents.VTable, self.vtable).ManipulationDelta(@ptrCast(*const _IManipulationEvents, self), x, y, translationDeltaX, translationDeltaY, scaleDelta, expansionDelta, rotationDelta, cumulativeTranslationX, cumulativeTranslationY, cumulativeScale, cumulativeExpansion, cumulativeRotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _IManipulationEvents_ManipulationCompleted(self: *const T, x: f32, y: f32, cumulativeTranslationX: f32, cumulativeTranslationY: f32, cumulativeScale: f32, cumulativeExpansion: f32, cumulativeRotation: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _IManipulationEvents.VTable, self.vtable).ManipulationCompleted(@ptrCast(*const _IManipulationEvents, self), x, y, cumulativeTranslationX, cumulativeTranslationY, cumulativeScale, cumulativeExpansion, cumulativeRotation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInertiaProcessor_Value = @import("../../zig.zig").Guid.initString("18b00c6d-c5ee-41b1-90a9-9d4a929095ad");
pub const IID_IInertiaProcessor = &IID_IInertiaProcessor_Value;
pub const IInertiaProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialOriginX: fn(
            self: *const IInertiaProcessor,
            x: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialOriginX: fn(
            self: *const IInertiaProcessor,
            x: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialOriginY: fn(
            self: *const IInertiaProcessor,
            y: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialOriginY: fn(
            self: *const IInertiaProcessor,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialVelocityX: fn(
            self: *const IInertiaProcessor,
            x: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialVelocityX: fn(
            self: *const IInertiaProcessor,
            x: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialVelocityY: fn(
            self: *const IInertiaProcessor,
            y: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialVelocityY: fn(
            self: *const IInertiaProcessor,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialAngularVelocity: fn(
            self: *const IInertiaProcessor,
            velocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialAngularVelocity: fn(
            self: *const IInertiaProcessor,
            velocity: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialExpansionVelocity: fn(
            self: *const IInertiaProcessor,
            velocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialExpansionVelocity: fn(
            self: *const IInertiaProcessor,
            velocity: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialRadius: fn(
            self: *const IInertiaProcessor,
            radius: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialRadius: fn(
            self: *const IInertiaProcessor,
            radius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryLeft: fn(
            self: *const IInertiaProcessor,
            left: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryLeft: fn(
            self: *const IInertiaProcessor,
            left: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryTop: fn(
            self: *const IInertiaProcessor,
            top: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryTop: fn(
            self: *const IInertiaProcessor,
            top: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryRight: fn(
            self: *const IInertiaProcessor,
            right: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryRight: fn(
            self: *const IInertiaProcessor,
            right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BoundaryBottom: fn(
            self: *const IInertiaProcessor,
            bottom: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BoundaryBottom: fn(
            self: *const IInertiaProcessor,
            bottom: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginLeft: fn(
            self: *const IInertiaProcessor,
            left: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginLeft: fn(
            self: *const IInertiaProcessor,
            left: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginTop: fn(
            self: *const IInertiaProcessor,
            top: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginTop: fn(
            self: *const IInertiaProcessor,
            top: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginRight: fn(
            self: *const IInertiaProcessor,
            right: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginRight: fn(
            self: *const IInertiaProcessor,
            right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElasticMarginBottom: fn(
            self: *const IInertiaProcessor,
            bottom: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ElasticMarginBottom: fn(
            self: *const IInertiaProcessor,
            bottom: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredDisplacement: fn(
            self: *const IInertiaProcessor,
            displacement: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredDisplacement: fn(
            self: *const IInertiaProcessor,
            displacement: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredRotation: fn(
            self: *const IInertiaProcessor,
            rotation: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredRotation: fn(
            self: *const IInertiaProcessor,
            rotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredExpansion: fn(
            self: *const IInertiaProcessor,
            expansion: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredExpansion: fn(
            self: *const IInertiaProcessor,
            expansion: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredAngularDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredAngularDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DesiredExpansionDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DesiredExpansionDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InitialTimestamp: fn(
            self: *const IInertiaProcessor,
            timestamp: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InitialTimestamp: fn(
            self: *const IInertiaProcessor,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IInertiaProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Process: fn(
            self: *const IInertiaProcessor,
            completed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessTime: fn(
            self: *const IInertiaProcessor,
            timestamp: u32,
            completed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Complete: fn(
            self: *const IInertiaProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompleteTime: fn(
            self: *const IInertiaProcessor,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialOriginX(self: *const T, x: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialOriginX(@ptrCast(*const IInertiaProcessor, self), x);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialOriginX(self: *const T, x: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialOriginX(@ptrCast(*const IInertiaProcessor, self), x);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialOriginY(self: *const T, y: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialOriginY(@ptrCast(*const IInertiaProcessor, self), y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialOriginY(self: *const T, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialOriginY(@ptrCast(*const IInertiaProcessor, self), y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialVelocityX(self: *const T, x: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialVelocityX(@ptrCast(*const IInertiaProcessor, self), x);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialVelocityX(self: *const T, x: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialVelocityX(@ptrCast(*const IInertiaProcessor, self), x);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialVelocityY(self: *const T, y: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialVelocityY(@ptrCast(*const IInertiaProcessor, self), y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialVelocityY(self: *const T, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialVelocityY(@ptrCast(*const IInertiaProcessor, self), y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialAngularVelocity(self: *const T, velocity: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialAngularVelocity(@ptrCast(*const IInertiaProcessor, self), velocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialAngularVelocity(self: *const T, velocity: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialAngularVelocity(@ptrCast(*const IInertiaProcessor, self), velocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialExpansionVelocity(self: *const T, velocity: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialExpansionVelocity(@ptrCast(*const IInertiaProcessor, self), velocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialExpansionVelocity(self: *const T, velocity: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialExpansionVelocity(@ptrCast(*const IInertiaProcessor, self), velocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialRadius(self: *const T, radius: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialRadius(@ptrCast(*const IInertiaProcessor, self), radius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialRadius(self: *const T, radius: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialRadius(@ptrCast(*const IInertiaProcessor, self), radius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_BoundaryLeft(self: *const T, left: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_BoundaryLeft(@ptrCast(*const IInertiaProcessor, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_BoundaryLeft(self: *const T, left: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_BoundaryLeft(@ptrCast(*const IInertiaProcessor, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_BoundaryTop(self: *const T, top: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_BoundaryTop(@ptrCast(*const IInertiaProcessor, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_BoundaryTop(self: *const T, top: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_BoundaryTop(@ptrCast(*const IInertiaProcessor, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_BoundaryRight(self: *const T, right: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_BoundaryRight(@ptrCast(*const IInertiaProcessor, self), right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_BoundaryRight(self: *const T, right: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_BoundaryRight(@ptrCast(*const IInertiaProcessor, self), right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_BoundaryBottom(self: *const T, bottom: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_BoundaryBottom(@ptrCast(*const IInertiaProcessor, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_BoundaryBottom(self: *const T, bottom: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_BoundaryBottom(@ptrCast(*const IInertiaProcessor, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_ElasticMarginLeft(self: *const T, left: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_ElasticMarginLeft(@ptrCast(*const IInertiaProcessor, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_ElasticMarginLeft(self: *const T, left: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_ElasticMarginLeft(@ptrCast(*const IInertiaProcessor, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_ElasticMarginTop(self: *const T, top: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_ElasticMarginTop(@ptrCast(*const IInertiaProcessor, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_ElasticMarginTop(self: *const T, top: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_ElasticMarginTop(@ptrCast(*const IInertiaProcessor, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_ElasticMarginRight(self: *const T, right: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_ElasticMarginRight(@ptrCast(*const IInertiaProcessor, self), right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_ElasticMarginRight(self: *const T, right: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_ElasticMarginRight(@ptrCast(*const IInertiaProcessor, self), right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_ElasticMarginBottom(self: *const T, bottom: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_ElasticMarginBottom(@ptrCast(*const IInertiaProcessor, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_ElasticMarginBottom(self: *const T, bottom: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_ElasticMarginBottom(@ptrCast(*const IInertiaProcessor, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredDisplacement(self: *const T, displacement: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredDisplacement(@ptrCast(*const IInertiaProcessor, self), displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredDisplacement(self: *const T, displacement: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredDisplacement(@ptrCast(*const IInertiaProcessor, self), displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredRotation(self: *const T, rotation: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredRotation(@ptrCast(*const IInertiaProcessor, self), rotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredRotation(self: *const T, rotation: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredRotation(@ptrCast(*const IInertiaProcessor, self), rotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredExpansion(self: *const T, expansion: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredExpansion(@ptrCast(*const IInertiaProcessor, self), expansion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredExpansion(self: *const T, expansion: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredExpansion(@ptrCast(*const IInertiaProcessor, self), expansion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredDeceleration(self: *const T, deceleration: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredDeceleration(self: *const T, deceleration: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredAngularDeceleration(self: *const T, deceleration: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredAngularDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredAngularDeceleration(self: *const T, deceleration: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredAngularDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredExpansionDeceleration(self: *const T, deceleration: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredExpansionDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredExpansionDeceleration(self: *const T, deceleration: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredExpansionDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialTimestamp(self: *const T, timestamp: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialTimestamp(@ptrCast(*const IInertiaProcessor, self), timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialTimestamp(self: *const T, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialTimestamp(@ptrCast(*const IInertiaProcessor, self), timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).Reset(@ptrCast(*const IInertiaProcessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_Process(self: *const T, completed: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).Process(@ptrCast(*const IInertiaProcessor, self), completed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_ProcessTime(self: *const T, timestamp: u32, completed: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).ProcessTime(@ptrCast(*const IInertiaProcessor, self), timestamp, completed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_Complete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).Complete(@ptrCast(*const IInertiaProcessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_CompleteTime(self: *const T, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).CompleteTime(@ptrCast(*const IInertiaProcessor, self), timestamp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IManipulationProcessor_Value = @import("../../zig.zig").Guid.initString("a22ac519-8300-48a0-bef4-f1be8737dba4");
pub const IID_IManipulationProcessor = &IID_IManipulationProcessor_Value;
pub const IManipulationProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedManipulations: fn(
            self: *const IManipulationProcessor,
            manipulations: ?*MANIPULATION_PROCESSOR_MANIPULATIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SupportedManipulations: fn(
            self: *const IManipulationProcessor,
            manipulations: MANIPULATION_PROCESSOR_MANIPULATIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PivotPointX: fn(
            self: *const IManipulationProcessor,
            pivotPointX: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PivotPointX: fn(
            self: *const IManipulationProcessor,
            pivotPointX: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PivotPointY: fn(
            self: *const IManipulationProcessor,
            pivotPointY: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PivotPointY: fn(
            self: *const IManipulationProcessor,
            pivotPointY: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PivotRadius: fn(
            self: *const IManipulationProcessor,
            pivotRadius: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PivotRadius: fn(
            self: *const IManipulationProcessor,
            pivotRadius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompleteManipulation: fn(
            self: *const IManipulationProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessDown: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMove: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUp: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessDownWithTime: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMoveWithTime: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUpWithTime: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVelocityX: fn(
            self: *const IManipulationProcessor,
            velocityX: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVelocityY: fn(
            self: *const IManipulationProcessor,
            velocityY: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpansionVelocity: fn(
            self: *const IManipulationProcessor,
            expansionVelocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAngularVelocity: fn(
            self: *const IManipulationProcessor,
            angularVelocity: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinimumScaleRotateRadius: fn(
            self: *const IManipulationProcessor,
            minRadius: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinimumScaleRotateRadius: fn(
            self: *const IManipulationProcessor,
            minRadius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_SupportedManipulations(self: *const T, manipulations: ?*MANIPULATION_PROCESSOR_MANIPULATIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_SupportedManipulations(@ptrCast(*const IManipulationProcessor, self), manipulations);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_SupportedManipulations(self: *const T, manipulations: MANIPULATION_PROCESSOR_MANIPULATIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_SupportedManipulations(@ptrCast(*const IManipulationProcessor, self), manipulations);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_PivotPointX(self: *const T, pivotPointX: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_PivotPointX(@ptrCast(*const IManipulationProcessor, self), pivotPointX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_PivotPointX(self: *const T, pivotPointX: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_PivotPointX(@ptrCast(*const IManipulationProcessor, self), pivotPointX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_PivotPointY(self: *const T, pivotPointY: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_PivotPointY(@ptrCast(*const IManipulationProcessor, self), pivotPointY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_PivotPointY(self: *const T, pivotPointY: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_PivotPointY(@ptrCast(*const IManipulationProcessor, self), pivotPointY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_PivotRadius(self: *const T, pivotRadius: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_PivotRadius(@ptrCast(*const IManipulationProcessor, self), pivotRadius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_PivotRadius(self: *const T, pivotRadius: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_PivotRadius(@ptrCast(*const IManipulationProcessor, self), pivotRadius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_CompleteManipulation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).CompleteManipulation(@ptrCast(*const IManipulationProcessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessDown(self: *const T, manipulatorId: u32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessDown(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessMove(self: *const T, manipulatorId: u32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessMove(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessUp(self: *const T, manipulatorId: u32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessUp(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessDownWithTime(self: *const T, manipulatorId: u32, x: f32, y: f32, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessDownWithTime(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y, timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessMoveWithTime(self: *const T, manipulatorId: u32, x: f32, y: f32, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessMoveWithTime(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y, timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessUpWithTime(self: *const T, manipulatorId: u32, x: f32, y: f32, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessUpWithTime(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y, timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_GetVelocityX(self: *const T, velocityX: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).GetVelocityX(@ptrCast(*const IManipulationProcessor, self), velocityX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_GetVelocityY(self: *const T, velocityY: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).GetVelocityY(@ptrCast(*const IManipulationProcessor, self), velocityY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_GetExpansionVelocity(self: *const T, expansionVelocity: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).GetExpansionVelocity(@ptrCast(*const IManipulationProcessor, self), expansionVelocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_GetAngularVelocity(self: *const T, angularVelocity: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).GetAngularVelocity(@ptrCast(*const IManipulationProcessor, self), angularVelocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_MinimumScaleRotateRadius(self: *const T, minRadius: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_MinimumScaleRotateRadius(@ptrCast(*const IManipulationProcessor, self), minRadius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_MinimumScaleRotateRadius(self: *const T, minRadius: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_MinimumScaleRotateRadius(@ptrCast(*const IManipulationProcessor, self), minRadius);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TOUCHINPUT = extern struct {
    x: i32,
    y: i32,
    hSource: ?HANDLE,
    dwID: u32,
    dwFlags: TOUCHEVENTF_FLAGS,
    dwMask: TOUCHINPUTMASKF_MASK,
    dwTime: u32,
    dwExtraInfo: usize,
    cxContact: u32,
    cyContact: u32,
};

pub const GESTUREINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwID: u32,
    hwndTarget: ?HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
    dwSequenceID: u32,
    ullArguments: u64,
    cbExtraArgs: u32,
};

pub const GESTURENOTIFYSTRUCT = extern struct {
    cbSize: u32,
    dwFlags: u32,
    hwndTarget: ?HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
};

pub const GESTURECONFIG = extern struct {
    dwID: GESTURECONFIG_ID,
    dwWant: u32,
    dwBlock: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (10)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn GetTouchInputInfo(
    hTouchInput: ?HTOUCHINPUT,
    cInputs: u32,
    pInputs: [*]TOUCHINPUT,
    cbSize: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn CloseTouchInputHandle(
    hTouchInput: ?HTOUCHINPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn RegisterTouchWindow(
    hwnd: ?HWND,
    ulFlags: REGISTER_TOUCH_WINDOW_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn UnregisterTouchWindow(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn IsTouchWindow(
    hwnd: ?HWND,
    pulFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn GetGestureInfo(
    hGestureInfo: ?HGESTUREINFO,
    pGestureInfo: ?*GESTUREINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn GetGestureExtraArgs(
    hGestureInfo: ?HGESTUREINFO,
    cbExtraArgs: u32,
    // TODO: what to do with BytesParamIndex 1?
    pExtraArgs: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn CloseGestureInfoHandle(
    hGestureInfo: ?HGESTUREINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn SetGestureConfig(
    hwnd: ?HWND,
    dwReserved: u32,
    cIDs: u32,
    pGestureConfig: [*]GESTURECONFIG,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "USER32" fn GetGestureConfig(
    hwnd: ?HWND,
    dwReserved: u32,
    dwFlags: u32,
    pcIDs: ?*u32,
    pGestureConfig: [*]GESTURECONFIG,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (6)
//--------------------------------------------------------------------------------
const BOOL = @import("../../foundation.zig").BOOL;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IUnknown = @import("../../system/com.zig").IUnknown;
const POINTS = @import("../../foundation.zig").POINTS;

test {
    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
