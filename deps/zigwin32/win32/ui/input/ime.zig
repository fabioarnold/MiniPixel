//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (635)
//--------------------------------------------------------------------------------
pub const CLSID_VERSION_DEPENDENT_MSIME_JAPANESE = Guid.initString("6a91029e-aa49-471b-aee7-7d332785660d");
pub const IFEC_S_ALREADY_DEFAULT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291840));
pub const FELANG_REQ_CONV = @as(u32, 65536);
pub const FELANG_REQ_RECONV = @as(u32, 131072);
pub const FELANG_REQ_REV = @as(u32, 196608);
pub const FELANG_CMODE_MONORUBY = @as(u32, 2);
pub const FELANG_CMODE_NOPRUNING = @as(u32, 4);
pub const FELANG_CMODE_KATAKANAOUT = @as(u32, 8);
pub const FELANG_CMODE_HIRAGANAOUT = @as(u32, 0);
pub const FELANG_CMODE_HALFWIDTHOUT = @as(u32, 16);
pub const FELANG_CMODE_FULLWIDTHOUT = @as(u32, 32);
pub const FELANG_CMODE_BOPOMOFO = @as(u32, 64);
pub const FELANG_CMODE_HANGUL = @as(u32, 128);
pub const FELANG_CMODE_PINYIN = @as(u32, 256);
pub const FELANG_CMODE_PRECONV = @as(u32, 512);
pub const FELANG_CMODE_RADICAL = @as(u32, 1024);
pub const FELANG_CMODE_UNKNOWNREADING = @as(u32, 2048);
pub const FELANG_CMODE_MERGECAND = @as(u32, 4096);
pub const FELANG_CMODE_ROMAN = @as(u32, 8192);
pub const FELANG_CMODE_BESTFIRST = @as(u32, 16384);
pub const FELANG_CMODE_USENOREVWORDS = @as(u32, 32768);
pub const FELANG_CMODE_NONE = @as(u32, 16777216);
pub const FELANG_CMODE_PLAURALCLAUSE = @as(u32, 33554432);
pub const FELANG_CMODE_SINGLECONVERT = @as(u32, 67108864);
pub const FELANG_CMODE_AUTOMATIC = @as(u32, 134217728);
pub const FELANG_CMODE_PHRASEPREDICT = @as(u32, 268435456);
pub const FELANG_CMODE_CONVERSATION = @as(u32, 536870912);
pub const FELANG_CMODE_NAME = @as(u32, 268435456);
pub const FELANG_CMODE_NOINVISIBLECHAR = @as(u32, 1073741824);
pub const E_NOCAND = @as(u32, 48);
pub const E_NOTENOUGH_BUFFER = @as(u32, 49);
pub const E_NOTENOUGH_WDD = @as(u32, 50);
pub const E_LARGEINPUT = @as(u32, 51);
pub const FELANG_CLMN_WBREAK = @as(u32, 1);
pub const FELANG_CLMN_NOWBREAK = @as(u32, 2);
pub const FELANG_CLMN_PBREAK = @as(u32, 4);
pub const FELANG_CLMN_NOPBREAK = @as(u32, 8);
pub const FELANG_CLMN_FIXR = @as(u32, 16);
pub const FELANG_CLMN_FIXD = @as(u32, 32);
pub const FELANG_INVALD_PO = @as(u32, 65535);
pub const IFED_POS_NONE = @as(u32, 0);
pub const IFED_POS_NOUN = @as(u32, 1);
pub const IFED_POS_VERB = @as(u32, 2);
pub const IFED_POS_ADJECTIVE = @as(u32, 4);
pub const IFED_POS_ADJECTIVE_VERB = @as(u32, 8);
pub const IFED_POS_ADVERB = @as(u32, 16);
pub const IFED_POS_ADNOUN = @as(u32, 32);
pub const IFED_POS_CONJUNCTION = @as(u32, 64);
pub const IFED_POS_INTERJECTION = @as(u32, 128);
pub const IFED_POS_INDEPENDENT = @as(u32, 255);
pub const IFED_POS_INFLECTIONALSUFFIX = @as(u32, 256);
pub const IFED_POS_PREFIX = @as(u32, 512);
pub const IFED_POS_SUFFIX = @as(u32, 1024);
pub const IFED_POS_AFFIX = @as(u32, 1536);
pub const IFED_POS_TANKANJI = @as(u32, 2048);
pub const IFED_POS_IDIOMS = @as(u32, 4096);
pub const IFED_POS_SYMBOLS = @as(u32, 8192);
pub const IFED_POS_PARTICLE = @as(u32, 16384);
pub const IFED_POS_AUXILIARY_VERB = @as(u32, 32768);
pub const IFED_POS_SUB_VERB = @as(u32, 65536);
pub const IFED_POS_DEPENDENT = @as(u32, 114688);
pub const IFED_POS_ALL = @as(u32, 131071);
pub const IFED_SELECT_NONE = @as(u32, 0);
pub const IFED_SELECT_READING = @as(u32, 1);
pub const IFED_SELECT_DISPLAY = @as(u32, 2);
pub const IFED_SELECT_POS = @as(u32, 4);
pub const IFED_SELECT_COMMENT = @as(u32, 8);
pub const IFED_SELECT_ALL = @as(u32, 15);
pub const IFED_REG_NONE = @as(u32, 0);
pub const IFED_REG_USER = @as(u32, 1);
pub const IFED_REG_AUTO = @as(u32, 2);
pub const IFED_REG_GRAMMAR = @as(u32, 4);
pub const IFED_REG_ALL = @as(u32, 7);
pub const IFED_TYPE_NONE = @as(u32, 0);
pub const IFED_TYPE_GENERAL = @as(u32, 1);
pub const IFED_TYPE_NAMEPLACE = @as(u32, 2);
pub const IFED_TYPE_SPEECH = @as(u32, 4);
pub const IFED_TYPE_REVERSE = @as(u32, 8);
pub const IFED_TYPE_ENGLISH = @as(u32, 16);
pub const IFED_TYPE_ALL = @as(u32, 31);
pub const IFED_S_MORE_ENTRIES = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291328));
pub const IFED_S_EMPTY_DICTIONARY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291329));
pub const IFED_S_WORD_EXISTS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291330));
pub const IFED_S_COMMENT_CHANGED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 291331));
pub const IFED_E_NOT_FOUND = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192064));
pub const IFED_E_INVALID_FORMAT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192063));
pub const IFED_E_OPEN_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192062));
pub const IFED_E_WRITE_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192061));
pub const IFED_E_NO_ENTRY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192060));
pub const IFED_E_REGISTER_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192059));
pub const IFED_E_NOT_USER_DIC = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192058));
pub const IFED_E_NOT_SUPPORTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192057));
pub const IFED_E_USER_COMMENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192056));
pub const IFED_E_REGISTER_ILLEGAL_POS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192055));
pub const IFED_E_REGISTER_IMPROPER_WORD = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192054));
pub const IFED_E_REGISTER_DISCONNECTED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147192053));
pub const POS_UNDEFINED = @as(u32, 0);
pub const JPOS_UNDEFINED = @as(u32, 0);
pub const JPOS_MEISHI_FUTSU = @as(u32, 100);
pub const JPOS_MEISHI_SAHEN = @as(u32, 101);
pub const JPOS_MEISHI_ZAHEN = @as(u32, 102);
pub const JPOS_MEISHI_KEIYOUDOUSHI = @as(u32, 103);
pub const JPOS_HUKUSIMEISHI = @as(u32, 104);
pub const JPOS_MEISA_KEIDOU = @as(u32, 105);
pub const JPOS_JINMEI = @as(u32, 106);
pub const JPOS_JINMEI_SEI = @as(u32, 107);
pub const JPOS_JINMEI_MEI = @as(u32, 108);
pub const JPOS_CHIMEI = @as(u32, 109);
pub const JPOS_CHIMEI_KUNI = @as(u32, 110);
pub const JPOS_CHIMEI_KEN = @as(u32, 111);
pub const JPOS_CHIMEI_GUN = @as(u32, 112);
pub const JPOS_CHIMEI_KU = @as(u32, 113);
pub const JPOS_CHIMEI_SHI = @as(u32, 114);
pub const JPOS_CHIMEI_MACHI = @as(u32, 115);
pub const JPOS_CHIMEI_MURA = @as(u32, 116);
pub const JPOS_CHIMEI_EKI = @as(u32, 117);
pub const JPOS_SONOTA = @as(u32, 118);
pub const JPOS_SHAMEI = @as(u32, 119);
pub const JPOS_SOSHIKI = @as(u32, 120);
pub const JPOS_KENCHIKU = @as(u32, 121);
pub const JPOS_BUPPIN = @as(u32, 122);
pub const JPOS_DAIMEISHI = @as(u32, 123);
pub const JPOS_DAIMEISHI_NINSHOU = @as(u32, 124);
pub const JPOS_DAIMEISHI_SHIJI = @as(u32, 125);
pub const JPOS_KAZU = @as(u32, 126);
pub const JPOS_KAZU_SURYOU = @as(u32, 127);
pub const JPOS_KAZU_SUSHI = @as(u32, 128);
pub const JPOS_5DAN_AWA = @as(u32, 200);
pub const JPOS_5DAN_KA = @as(u32, 201);
pub const JPOS_5DAN_GA = @as(u32, 202);
pub const JPOS_5DAN_SA = @as(u32, 203);
pub const JPOS_5DAN_TA = @as(u32, 204);
pub const JPOS_5DAN_NA = @as(u32, 205);
pub const JPOS_5DAN_BA = @as(u32, 206);
pub const JPOS_5DAN_MA = @as(u32, 207);
pub const JPOS_5DAN_RA = @as(u32, 208);
pub const JPOS_5DAN_AWAUON = @as(u32, 209);
pub const JPOS_5DAN_KASOKUON = @as(u32, 210);
pub const JPOS_5DAN_RAHEN = @as(u32, 211);
pub const JPOS_4DAN_HA = @as(u32, 212);
pub const JPOS_1DAN = @as(u32, 213);
pub const JPOS_TOKUSHU_KAHEN = @as(u32, 214);
pub const JPOS_TOKUSHU_SAHENSURU = @as(u32, 215);
pub const JPOS_TOKUSHU_SAHEN = @as(u32, 216);
pub const JPOS_TOKUSHU_ZAHEN = @as(u32, 217);
pub const JPOS_TOKUSHU_NAHEN = @as(u32, 218);
pub const JPOS_KURU_KI = @as(u32, 219);
pub const JPOS_KURU_KITA = @as(u32, 220);
pub const JPOS_KURU_KITARA = @as(u32, 221);
pub const JPOS_KURU_KITARI = @as(u32, 222);
pub const JPOS_KURU_KITAROU = @as(u32, 223);
pub const JPOS_KURU_KITE = @as(u32, 224);
pub const JPOS_KURU_KUREBA = @as(u32, 225);
pub const JPOS_KURU_KO = @as(u32, 226);
pub const JPOS_KURU_KOI = @as(u32, 227);
pub const JPOS_KURU_KOYOU = @as(u32, 228);
pub const JPOS_SURU_SA = @as(u32, 229);
pub const JPOS_SURU_SI = @as(u32, 230);
pub const JPOS_SURU_SITA = @as(u32, 231);
pub const JPOS_SURU_SITARA = @as(u32, 232);
pub const JPOS_SURU_SIATRI = @as(u32, 233);
pub const JPOS_SURU_SITAROU = @as(u32, 234);
pub const JPOS_SURU_SITE = @as(u32, 235);
pub const JPOS_SURU_SIYOU = @as(u32, 236);
pub const JPOS_SURU_SUREBA = @as(u32, 237);
pub const JPOS_SURU_SE = @as(u32, 238);
pub const JPOS_SURU_SEYO = @as(u32, 239);
pub const JPOS_KEIYOU = @as(u32, 300);
pub const JPOS_KEIYOU_GARU = @as(u32, 301);
pub const JPOS_KEIYOU_GE = @as(u32, 302);
pub const JPOS_KEIYOU_ME = @as(u32, 303);
pub const JPOS_KEIYOU_YUU = @as(u32, 304);
pub const JPOS_KEIYOU_U = @as(u32, 305);
pub const JPOS_KEIDOU = @as(u32, 400);
pub const JPOS_KEIDOU_NO = @as(u32, 401);
pub const JPOS_KEIDOU_TARU = @as(u32, 402);
pub const JPOS_KEIDOU_GARU = @as(u32, 403);
pub const JPOS_FUKUSHI = @as(u32, 500);
pub const JPOS_FUKUSHI_SAHEN = @as(u32, 501);
pub const JPOS_FUKUSHI_NI = @as(u32, 502);
pub const JPOS_FUKUSHI_NANO = @as(u32, 503);
pub const JPOS_FUKUSHI_DA = @as(u32, 504);
pub const JPOS_FUKUSHI_TO = @as(u32, 505);
pub const JPOS_FUKUSHI_TOSURU = @as(u32, 506);
pub const JPOS_RENTAISHI = @as(u32, 600);
pub const JPOS_RENTAISHI_SHIJI = @as(u32, 601);
pub const JPOS_SETSUZOKUSHI = @as(u32, 650);
pub const JPOS_KANDOUSHI = @as(u32, 670);
pub const JPOS_SETTOU = @as(u32, 700);
pub const JPOS_SETTOU_KAKU = @as(u32, 701);
pub const JPOS_SETTOU_SAI = @as(u32, 702);
pub const JPOS_SETTOU_FUKU = @as(u32, 703);
pub const JPOS_SETTOU_MI = @as(u32, 704);
pub const JPOS_SETTOU_DAISHOU = @as(u32, 705);
pub const JPOS_SETTOU_KOUTEI = @as(u32, 706);
pub const JPOS_SETTOU_CHOUTAN = @as(u32, 707);
pub const JPOS_SETTOU_SHINKYU = @as(u32, 708);
pub const JPOS_SETTOU_JINMEI = @as(u32, 709);
pub const JPOS_SETTOU_CHIMEI = @as(u32, 710);
pub const JPOS_SETTOU_SONOTA = @as(u32, 711);
pub const JPOS_SETTOU_JOSUSHI = @as(u32, 712);
pub const JPOS_SETTOU_TEINEI_O = @as(u32, 713);
pub const JPOS_SETTOU_TEINEI_GO = @as(u32, 714);
pub const JPOS_SETTOU_TEINEI_ON = @as(u32, 715);
pub const JPOS_SETSUBI = @as(u32, 800);
pub const JPOS_SETSUBI_TEKI = @as(u32, 801);
pub const JPOS_SETSUBI_SEI = @as(u32, 802);
pub const JPOS_SETSUBI_KA = @as(u32, 803);
pub const JPOS_SETSUBI_CHU = @as(u32, 804);
pub const JPOS_SETSUBI_FU = @as(u32, 805);
pub const JPOS_SETSUBI_RYU = @as(u32, 806);
pub const JPOS_SETSUBI_YOU = @as(u32, 807);
pub const JPOS_SETSUBI_KATA = @as(u32, 808);
pub const JPOS_SETSUBI_MEISHIRENDAKU = @as(u32, 809);
pub const JPOS_SETSUBI_JINMEI = @as(u32, 810);
pub const JPOS_SETSUBI_CHIMEI = @as(u32, 811);
pub const JPOS_SETSUBI_KUNI = @as(u32, 812);
pub const JPOS_SETSUBI_KEN = @as(u32, 813);
pub const JPOS_SETSUBI_GUN = @as(u32, 814);
pub const JPOS_SETSUBI_KU = @as(u32, 815);
pub const JPOS_SETSUBI_SHI = @as(u32, 816);
pub const JPOS_SETSUBI_MACHI = @as(u32, 817);
pub const JPOS_SETSUBI_CHOU = @as(u32, 818);
pub const JPOS_SETSUBI_MURA = @as(u32, 819);
pub const JPOS_SETSUBI_SON = @as(u32, 820);
pub const JPOS_SETSUBI_EKI = @as(u32, 821);
pub const JPOS_SETSUBI_SONOTA = @as(u32, 822);
pub const JPOS_SETSUBI_SHAMEI = @as(u32, 823);
pub const JPOS_SETSUBI_SOSHIKI = @as(u32, 824);
pub const JPOS_SETSUBI_KENCHIKU = @as(u32, 825);
pub const JPOS_RENYOU_SETSUBI = @as(u32, 826);
pub const JPOS_SETSUBI_JOSUSHI = @as(u32, 827);
pub const JPOS_SETSUBI_JOSUSHIPLUS = @as(u32, 828);
pub const JPOS_SETSUBI_JIKAN = @as(u32, 829);
pub const JPOS_SETSUBI_JIKANPLUS = @as(u32, 830);
pub const JPOS_SETSUBI_TEINEI = @as(u32, 831);
pub const JPOS_SETSUBI_SAN = @as(u32, 832);
pub const JPOS_SETSUBI_KUN = @as(u32, 833);
pub const JPOS_SETSUBI_SAMA = @as(u32, 834);
pub const JPOS_SETSUBI_DONO = @as(u32, 835);
pub const JPOS_SETSUBI_FUKUSU = @as(u32, 836);
pub const JPOS_SETSUBI_TACHI = @as(u32, 837);
pub const JPOS_SETSUBI_RA = @as(u32, 838);
pub const JPOS_TANKANJI = @as(u32, 900);
pub const JPOS_TANKANJI_KAO = @as(u32, 901);
pub const JPOS_KANYOUKU = @as(u32, 902);
pub const JPOS_DOKURITSUGO = @as(u32, 903);
pub const JPOS_FUTEIGO = @as(u32, 904);
pub const JPOS_KIGOU = @as(u32, 905);
pub const JPOS_EIJI = @as(u32, 906);
pub const JPOS_KUTEN = @as(u32, 907);
pub const JPOS_TOUTEN = @as(u32, 908);
pub const JPOS_KANJI = @as(u32, 909);
pub const JPOS_OPENBRACE = @as(u32, 910);
pub const JPOS_CLOSEBRACE = @as(u32, 911);
pub const JPOS_YOKUSEI = @as(u32, 912);
pub const JPOS_TANSHUKU = @as(u32, 913);
pub const VERSION_ID_JAPANESE = @as(u32, 16777216);
pub const VERSION_ID_KOREAN = @as(u32, 33554432);
pub const VERSION_ID_CHINESE_TRADITIONAL = @as(u32, 67108864);
pub const VERSION_ID_CHINESE_SIMPLIFIED = @as(u32, 134217728);
pub const FID_MSIME_VERSION = @as(u32, 0);
pub const VERSION_MOUSE_OPERATION = @as(u32, 1);
pub const IMEMOUSERET_NOTHANDLED = @as(i32, -1);
pub const IMEMOUSE_VERSION = @as(u32, 255);
pub const IMEMOUSE_NONE = @as(u32, 0);
pub const IMEMOUSE_LDOWN = @as(u32, 1);
pub const IMEMOUSE_RDOWN = @as(u32, 2);
pub const IMEMOUSE_MDOWN = @as(u32, 4);
pub const IMEMOUSE_WUP = @as(u32, 16);
pub const IMEMOUSE_WDOWN = @as(u32, 32);
pub const FID_RECONVERT_VERSION = @as(u32, 268435456);
pub const VERSION_RECONVERSION = @as(u32, 1);
pub const VERSION_DOCUMENTFEED = @as(u32, 1);
pub const VERSION_QUERYPOSITION = @as(u32, 1);
pub const VERSION_MODEBIAS = @as(u32, 1);
pub const MODEBIAS_GETVERSION = @as(u32, 0);
pub const MODEBIAS_SETVALUE = @as(u32, 1);
pub const MODEBIAS_GETVALUE = @as(u32, 2);
pub const MODEBIASMODE_DEFAULT = @as(u32, 0);
pub const MODEBIASMODE_FILENAME = @as(u32, 1);
pub const MODEBIASMODE_READING = @as(u32, 2);
pub const MODEBIASMODE_DIGIT = @as(u32, 4);
pub const SHOWIMEPAD_DEFAULT = @as(u32, 0);
pub const SHOWIMEPAD_CATEGORY = @as(u32, 1);
pub const SHOWIMEPAD_GUID = @as(u32, 2);
pub const FID_MSIME_KMS_VERSION = @as(u32, 1);
pub const FID_MSIME_KMS_INIT = @as(u32, 2);
pub const FID_MSIME_KMS_TERM = @as(u32, 3);
pub const FID_MSIME_KMS_DEL_KEYLIST = @as(u32, 4);
pub const FID_MSIME_KMS_NOTIFY = @as(u32, 5);
pub const FID_MSIME_KMS_GETMAP = @as(u32, 6);
pub const FID_MSIME_KMS_INVOKE = @as(u32, 7);
pub const FID_MSIME_KMS_SETMAP = @as(u32, 8);
pub const FID_MSIME_KMS_FUNCDESC = @as(u32, 9);
pub const FID_MSIME_KMS_GETMAPSEAMLESS = @as(u32, 10);
pub const FID_MSIME_KMS_GETMAPFAST = @as(u32, 11);
pub const IMEKMS_NOCOMPOSITION = @as(u32, 0);
pub const IMEKMS_COMPOSITION = @as(u32, 1);
pub const IMEKMS_SELECTION = @as(u32, 2);
pub const IMEKMS_IMEOFF = @as(u32, 3);
pub const IMEKMS_2NDLEVEL = @as(u32, 4);
pub const IMEKMS_INPTGL = @as(u32, 5);
pub const IMEKMS_CANDIDATE = @as(u32, 6);
pub const IMEKMS_TYPECAND = @as(u32, 7);
pub const RECONVOPT_NONE = @as(u32, 0);
pub const RECONVOPT_USECANCELNOTIFY = @as(u32, 1);
pub const GCSEX_CANCELRECONVERT = @as(u32, 268435456);
pub const STYLE_DESCRIPTION_SIZE = @as(u32, 32);
pub const IMEMENUITEM_STRING_SIZE = @as(u32, 80);
pub const IMC_GETCANDIDATEPOS = @as(u32, 7);
pub const IMC_SETCANDIDATEPOS = @as(u32, 8);
pub const IMC_GETCOMPOSITIONFONT = @as(u32, 9);
pub const IMC_SETCOMPOSITIONFONT = @as(u32, 10);
pub const IMC_GETCOMPOSITIONWINDOW = @as(u32, 11);
pub const IMC_SETCOMPOSITIONWINDOW = @as(u32, 12);
pub const IMC_GETSTATUSWINDOWPOS = @as(u32, 15);
pub const IMC_SETSTATUSWINDOWPOS = @as(u32, 16);
pub const IMC_CLOSESTATUSWINDOW = @as(u32, 33);
pub const IMC_OPENSTATUSWINDOW = @as(u32, 34);
pub const NI_FINALIZECONVERSIONRESULT = @as(u32, 20);
pub const ISC_SHOWUICANDIDATEWINDOW = @as(u32, 1);
pub const ISC_SHOWUICOMPOSITIONWINDOW = @as(u32, 2147483648);
pub const ISC_SHOWUIGUIDELINE = @as(u32, 1073741824);
pub const ISC_SHOWUIALLCANDIDATEWINDOW = @as(u32, 15);
pub const ISC_SHOWUIALL = @as(u32, 3221225487);
pub const MOD_LEFT = @as(u32, 32768);
pub const MOD_RIGHT = @as(u32, 16384);
pub const MOD_ON_KEYUP = @as(u32, 2048);
pub const MOD_IGNORE_ALL_MODIFIER = @as(u32, 1024);
pub const IME_CHOTKEY_IME_NONIME_TOGGLE = @as(u32, 16);
pub const IME_CHOTKEY_SHAPE_TOGGLE = @as(u32, 17);
pub const IME_CHOTKEY_SYMBOL_TOGGLE = @as(u32, 18);
pub const IME_JHOTKEY_CLOSE_OPEN = @as(u32, 48);
pub const IME_KHOTKEY_SHAPE_TOGGLE = @as(u32, 80);
pub const IME_KHOTKEY_HANJACONVERT = @as(u32, 81);
pub const IME_KHOTKEY_ENGLISH = @as(u32, 82);
pub const IME_THOTKEY_IME_NONIME_TOGGLE = @as(u32, 112);
pub const IME_THOTKEY_SHAPE_TOGGLE = @as(u32, 113);
pub const IME_THOTKEY_SYMBOL_TOGGLE = @as(u32, 114);
pub const IME_HOTKEY_DSWITCH_FIRST = @as(u32, 256);
pub const IME_HOTKEY_DSWITCH_LAST = @as(u32, 287);
pub const IME_HOTKEY_PRIVATE_FIRST = @as(u32, 512);
pub const IME_ITHOTKEY_RESEND_RESULTSTR = @as(u32, 512);
pub const IME_ITHOTKEY_PREVIOUS_COMPOSITION = @as(u32, 513);
pub const IME_ITHOTKEY_UISTYLE_TOGGLE = @as(u32, 514);
pub const IME_ITHOTKEY_RECONVERTSTRING = @as(u32, 515);
pub const IME_HOTKEY_PRIVATE_LAST = @as(u32, 543);
pub const GCS_COMPREADSTR = @as(u32, 1);
pub const GCS_COMPREADATTR = @as(u32, 2);
pub const GCS_COMPREADCLAUSE = @as(u32, 4);
pub const GCS_COMPSTR = @as(u32, 8);
pub const GCS_COMPATTR = @as(u32, 16);
pub const GCS_COMPCLAUSE = @as(u32, 32);
pub const GCS_CURSORPOS = @as(u32, 128);
pub const GCS_DELTASTART = @as(u32, 256);
pub const GCS_RESULTREADSTR = @as(u32, 512);
pub const GCS_RESULTREADCLAUSE = @as(u32, 1024);
pub const GCS_RESULTSTR = @as(u32, 2048);
pub const GCS_RESULTCLAUSE = @as(u32, 4096);
pub const CS_INSERTCHAR = @as(u32, 8192);
pub const CS_NOMOVECARET = @as(u32, 16384);
pub const IMEVER_0310 = @as(u32, 196618);
pub const IMEVER_0400 = @as(u32, 262144);
pub const IME_PROP_AT_CARET = @as(u32, 65536);
pub const IME_PROP_SPECIAL_UI = @as(u32, 131072);
pub const IME_PROP_CANDLIST_START_FROM_1 = @as(u32, 262144);
pub const IME_PROP_UNICODE = @as(u32, 524288);
pub const IME_PROP_COMPLETE_ON_UNSELECT = @as(u32, 1048576);
pub const UI_CAP_2700 = @as(u32, 1);
pub const UI_CAP_ROT90 = @as(u32, 2);
pub const UI_CAP_ROTANY = @as(u32, 4);
pub const SCS_CAP_COMPSTR = @as(u32, 1);
pub const SCS_CAP_MAKEREAD = @as(u32, 2);
pub const SCS_CAP_SETRECONVERTSTRING = @as(u32, 4);
pub const SELECT_CAP_CONVERSION = @as(u32, 1);
pub const SELECT_CAP_SENTENCE = @as(u32, 2);
pub const GL_LEVEL_NOGUIDELINE = @as(u32, 0);
pub const GL_LEVEL_FATAL = @as(u32, 1);
pub const GL_LEVEL_ERROR = @as(u32, 2);
pub const GL_LEVEL_WARNING = @as(u32, 3);
pub const GL_LEVEL_INFORMATION = @as(u32, 4);
pub const GL_ID_UNKNOWN = @as(u32, 0);
pub const GL_ID_NOMODULE = @as(u32, 1);
pub const GL_ID_NODICTIONARY = @as(u32, 16);
pub const GL_ID_CANNOTSAVE = @as(u32, 17);
pub const GL_ID_NOCONVERT = @as(u32, 32);
pub const GL_ID_TYPINGERROR = @as(u32, 33);
pub const GL_ID_TOOMANYSTROKE = @as(u32, 34);
pub const GL_ID_READINGCONFLICT = @as(u32, 35);
pub const GL_ID_INPUTREADING = @as(u32, 36);
pub const GL_ID_INPUTRADICAL = @as(u32, 37);
pub const GL_ID_INPUTCODE = @as(u32, 38);
pub const GL_ID_INPUTSYMBOL = @as(u32, 39);
pub const GL_ID_CHOOSECANDIDATE = @as(u32, 40);
pub const GL_ID_REVERSECONVERSION = @as(u32, 41);
pub const GL_ID_PRIVATE_FIRST = @as(u32, 32768);
pub const GL_ID_PRIVATE_LAST = @as(u32, 65535);
pub const ATTR_INPUT = @as(u32, 0);
pub const ATTR_TARGET_CONVERTED = @as(u32, 1);
pub const ATTR_CONVERTED = @as(u32, 2);
pub const ATTR_TARGET_NOTCONVERTED = @as(u32, 3);
pub const ATTR_INPUT_ERROR = @as(u32, 4);
pub const ATTR_FIXEDCONVERTED = @as(u32, 5);
pub const CFS_DEFAULT = @as(u32, 0);
pub const CFS_RECT = @as(u32, 1);
pub const CFS_POINT = @as(u32, 2);
pub const CFS_FORCE_POSITION = @as(u32, 32);
pub const CFS_CANDIDATEPOS = @as(u32, 64);
pub const CFS_EXCLUDE = @as(u32, 128);
pub const IME_CMODE_SOFTKBD = @as(u32, 128);
pub const IME_CMODE_NOCONVERSION = @as(u32, 256);
pub const IME_CMODE_EUDC = @as(u32, 512);
pub const IME_CMODE_SYMBOL = @as(u32, 1024);
pub const IME_CMODE_FIXED = @as(u32, 2048);
pub const IME_CMODE_RESERVED = @as(u32, 4026531840);
pub const IME_SMODE_NONE = @as(u32, 0);
pub const IME_SMODE_PLAURALCLAUSE = @as(u32, 1);
pub const IME_SMODE_SINGLECONVERT = @as(u32, 2);
pub const IME_SMODE_AUTOMATIC = @as(u32, 4);
pub const IME_SMODE_PHRASEPREDICT = @as(u32, 8);
pub const IME_SMODE_CONVERSATION = @as(u32, 16);
pub const IME_SMODE_RESERVED = @as(u32, 61440);
pub const IME_CAND_UNKNOWN = @as(u32, 0);
pub const IME_CAND_READ = @as(u32, 1);
pub const IME_CAND_CODE = @as(u32, 2);
pub const IME_CAND_MEANING = @as(u32, 3);
pub const IME_CAND_RADICAL = @as(u32, 4);
pub const IME_CAND_STROKE = @as(u32, 5);
pub const IMN_CLOSESTATUSWINDOW = @as(u32, 1);
pub const IMN_OPENSTATUSWINDOW = @as(u32, 2);
pub const IMN_CHANGECANDIDATE = @as(u32, 3);
pub const IMN_CLOSECANDIDATE = @as(u32, 4);
pub const IMN_OPENCANDIDATE = @as(u32, 5);
pub const IMN_SETCONVERSIONMODE = @as(u32, 6);
pub const IMN_SETSENTENCEMODE = @as(u32, 7);
pub const IMN_SETOPENSTATUS = @as(u32, 8);
pub const IMN_SETCANDIDATEPOS = @as(u32, 9);
pub const IMN_SETCOMPOSITIONFONT = @as(u32, 10);
pub const IMN_SETCOMPOSITIONWINDOW = @as(u32, 11);
pub const IMN_SETSTATUSWINDOWPOS = @as(u32, 12);
pub const IMN_GUIDELINE = @as(u32, 13);
pub const IMN_PRIVATE = @as(u32, 14);
pub const IMR_COMPOSITIONWINDOW = @as(u32, 1);
pub const IMR_CANDIDATEWINDOW = @as(u32, 2);
pub const IMR_COMPOSITIONFONT = @as(u32, 3);
pub const IMR_RECONVERTSTRING = @as(u32, 4);
pub const IMR_CONFIRMRECONVERTSTRING = @as(u32, 5);
pub const IMR_QUERYCHARPOSITION = @as(u32, 6);
pub const IMR_DOCUMENTFEED = @as(u32, 7);
pub const IMM_ERROR_NODATA = @as(i32, -1);
pub const IMM_ERROR_GENERAL = @as(i32, -2);
pub const IME_CONFIG_GENERAL = @as(u32, 1);
pub const IME_CONFIG_REGISTERWORD = @as(u32, 2);
pub const IME_CONFIG_SELECTDICTIONARY = @as(u32, 3);
pub const IME_ESC_QUERY_SUPPORT = @as(u32, 3);
pub const IME_ESC_RESERVED_FIRST = @as(u32, 4);
pub const IME_ESC_RESERVED_LAST = @as(u32, 2047);
pub const IME_ESC_PRIVATE_FIRST = @as(u32, 2048);
pub const IME_ESC_PRIVATE_LAST = @as(u32, 4095);
pub const IME_ESC_SEQUENCE_TO_INTERNAL = @as(u32, 4097);
pub const IME_ESC_GET_EUDC_DICTIONARY = @as(u32, 4099);
pub const IME_ESC_SET_EUDC_DICTIONARY = @as(u32, 4100);
pub const IME_ESC_MAX_KEY = @as(u32, 4101);
pub const IME_ESC_IME_NAME = @as(u32, 4102);
pub const IME_ESC_SYNC_HOTKEY = @as(u32, 4103);
pub const IME_ESC_HANJA_MODE = @as(u32, 4104);
pub const IME_ESC_AUTOMATA = @as(u32, 4105);
pub const IME_ESC_PRIVATE_HOTKEY = @as(u32, 4106);
pub const IME_ESC_GETHELPFILENAME = @as(u32, 4107);
pub const IME_REGWORD_STYLE_EUDC = @as(u32, 1);
pub const IME_REGWORD_STYLE_USER_FIRST = @as(u32, 2147483648);
pub const IME_REGWORD_STYLE_USER_LAST = @as(u32, 4294967295);
pub const IACE_CHILDREN = @as(u32, 1);
pub const IACE_DEFAULT = @as(u32, 16);
pub const IACE_IGNORENOCONTEXT = @as(u32, 32);
pub const IGIMIF_RIGHTMENU = @as(u32, 1);
pub const IGIMII_CMODE = @as(u32, 1);
pub const IGIMII_SMODE = @as(u32, 2);
pub const IGIMII_CONFIGURE = @as(u32, 4);
pub const IGIMII_TOOLS = @as(u32, 8);
pub const IGIMII_HELP = @as(u32, 16);
pub const IGIMII_OTHER = @as(u32, 32);
pub const IGIMII_INPUTTOOLS = @as(u32, 64);
pub const IMFT_RADIOCHECK = @as(u32, 1);
pub const IMFT_SEPARATOR = @as(u32, 2);
pub const IMFT_SUBMENU = @as(u32, 4);
pub const SOFTKEYBOARD_TYPE_T1 = @as(u32, 1);
pub const SOFTKEYBOARD_TYPE_C1 = @as(u32, 2);
pub const IMMGWL_IMC = @as(u32, 0);
pub const IMMGWLP_IMC = @as(u32, 0);
pub const IMC_SETCONVERSIONMODE = @as(u32, 2);
pub const IMC_SETSENTENCEMODE = @as(u32, 4);
pub const IMC_SETOPENSTATUS = @as(u32, 6);
pub const IMC_GETSOFTKBDFONT = @as(u32, 17);
pub const IMC_SETSOFTKBDFONT = @as(u32, 18);
pub const IMC_GETSOFTKBDPOS = @as(u32, 19);
pub const IMC_SETSOFTKBDPOS = @as(u32, 20);
pub const IMC_GETSOFTKBDSUBTYPE = @as(u32, 21);
pub const IMC_SETSOFTKBDSUBTYPE = @as(u32, 22);
pub const IMC_SETSOFTKBDDATA = @as(u32, 24);
pub const NI_CONTEXTUPDATED = @as(u32, 3);
pub const IME_SYSINFO_WINLOGON = @as(u32, 1);
pub const IME_SYSINFO_WOW16 = @as(u32, 2);
pub const INIT_STATUSWNDPOS = @as(u32, 1);
pub const INIT_CONVERSION = @as(u32, 2);
pub const INIT_SENTENCE = @as(u32, 4);
pub const INIT_LOGFONT = @as(u32, 8);
pub const INIT_COMPFORM = @as(u32, 16);
pub const INIT_SOFTKBDPOS = @as(u32, 32);
pub const IME_PROP_END_UNLOAD = @as(u32, 1);
pub const IME_PROP_KBD_CHAR_FIRST = @as(u32, 2);
pub const IME_PROP_IGNORE_UPKEYS = @as(u32, 4);
pub const IME_PROP_NEED_ALTKEY = @as(u32, 8);
pub const IME_PROP_NO_KEYS_ON_CLOSE = @as(u32, 16);
pub const IME_PROP_ACCEPT_WIDE_VKEY = @as(u32, 32);
pub const UI_CAP_SOFTKBD = @as(u32, 65536);
pub const IMN_SOFTKBDDESTROYED = @as(u32, 17);
pub const IME_UI_CLASS_NAME_SIZE = @as(u32, 16);
pub const IME_ESC_STRING_BUFFER_SIZE = @as(u32, 80);
pub const CATID_MSIME_IImePadApplet_VER7 = Guid.initString("4a0f8e31-c3ee-11d1-afef-00805f0c8b6d");
pub const CATID_MSIME_IImePadApplet_VER80 = Guid.initString("56f7a792-fef1-11d3-8463-00c04f7a06e5");
pub const CATID_MSIME_IImePadApplet_VER81 = Guid.initString("656520b0-bb88-11d4-84c0-00c04f7a06e5");
pub const CATID_MSIME_IImePadApplet900 = Guid.initString("faae51bf-5e5b-4a1d-8de1-17c1d9e1728d");
pub const CATID_MSIME_IImePadApplet1000 = Guid.initString("e081e1d6-2389-43cb-b66f-609f823d9f9c");
pub const CATID_MSIME_IImePadApplet1200 = Guid.initString("a47fb5fc-7d15-4223-a789-b781bf9ae667");
pub const CATID_MSIME_IImePadApplet = Guid.initString("7566cad1-4ec9-4478-9fe9-8ed766619edf");
pub const FEID_NONE = @as(u32, 0);
pub const FEID_CHINESE_TRADITIONAL = @as(u32, 1);
pub const FEID_CHINESE_SIMPLIFIED = @as(u32, 2);
pub const FEID_CHINESE_HONGKONG = @as(u32, 3);
pub const FEID_CHINESE_SINGAPORE = @as(u32, 4);
pub const FEID_JAPANESE = @as(u32, 5);
pub const FEID_KOREAN = @as(u32, 6);
pub const FEID_KOREAN_JOHAB = @as(u32, 7);
pub const INFOMASK_NONE = @as(u32, 0);
pub const INFOMASK_QUERY_CAND = @as(u32, 1);
pub const INFOMASK_APPLY_CAND = @as(u32, 2);
pub const INFOMASK_APPLY_CAND_EX = @as(u32, 4);
pub const INFOMASK_STRING_FIX = @as(u32, 65536);
pub const INFOMASK_HIDE_CAND = @as(u32, 131072);
pub const INFOMASK_BLOCK_CAND = @as(u32, 262144);
pub const IMEFAREASTINFO_TYPE_DEFAULT = @as(u32, 0);
pub const IMEFAREASTINFO_TYPE_READING = @as(u32, 1);
pub const IMEFAREASTINFO_TYPE_COMMENT = @as(u32, 2);
pub const IMEFAREASTINFO_TYPE_COSTTIME = @as(u32, 3);
pub const CHARINFO_APPLETID_MASK = @as(u32, 4278190080);
pub const CHARINFO_FEID_MASK = @as(u32, 15728640);
pub const CHARINFO_CHARID_MASK = @as(u32, 65535);
pub const MAX_APPLETTITLE = @as(u32, 64);
pub const MAX_FONTFACE = @as(u32, 32);
pub const IPACFG_NONE = @as(i32, 0);
pub const IPACFG_PROPERTY = @as(i32, 1);
pub const IPACFG_HELP = @as(i32, 2);
pub const IPACFG_TITLE = @as(i32, 65536);
pub const IPACFG_TITLEFONTFACE = @as(i32, 131072);
pub const IPACFG_CATEGORY = @as(i32, 262144);
pub const IPACFG_LANG = @as(i32, 16);
pub const IPACID_NONE = @as(u32, 0);
pub const IPACID_SOFTKEY = @as(u32, 1);
pub const IPACID_HANDWRITING = @as(u32, 2);
pub const IPACID_STROKESEARCH = @as(u32, 3);
pub const IPACID_RADICALSEARCH = @as(u32, 4);
pub const IPACID_SYMBOLSEARCH = @as(u32, 5);
pub const IPACID_VOICE = @as(u32, 6);
pub const IPACID_EPWING = @as(u32, 7);
pub const IPACID_OCR = @as(u32, 8);
pub const IPACID_CHARLIST = @as(u32, 9);
pub const IPACID_USER = @as(u32, 256);
pub const IMEPADREQ_FIRST = @as(u32, 4096);
pub const IMEPADREQ_INSERTSTRINGCANDIDATE = @as(u32, 4098);
pub const IMEPADREQ_INSERTITEMCANDIDATE = @as(u32, 4099);
pub const IMEPADREQ_SENDKEYCONTROL = @as(u32, 4101);
pub const IMEPADREQ_GETSELECTEDSTRING = @as(u32, 4103);
pub const IMEPADREQ_SETAPPLETDATA = @as(u32, 4105);
pub const IMEPADREQ_GETAPPLETDATA = @as(u32, 4106);
pub const IMEPADREQ_SETTITLEFONT = @as(u32, 4107);
pub const IMEPADREQ_GETCOMPOSITIONSTRINGID = @as(u32, 4109);
pub const IMEPADREQ_INSERTSTRINGCANDIDATEINFO = @as(u32, 4110);
pub const IMEPADREQ_CHANGESTRINGCANDIDATEINFO = @as(u32, 4111);
pub const IMEPADREQ_INSERTSTRINGINFO = @as(u32, 4114);
pub const IMEPADREQ_CHANGESTRINGINFO = @as(u32, 4115);
pub const IMEPADREQ_GETCURRENTUILANGID = @as(u32, 4120);
pub const IMEPADCTRL_CONVERTALL = @as(u32, 1);
pub const IMEPADCTRL_DETERMINALL = @as(u32, 2);
pub const IMEPADCTRL_DETERMINCHAR = @as(u32, 3);
pub const IMEPADCTRL_CLEARALL = @as(u32, 4);
pub const IMEPADCTRL_CARETSET = @as(u32, 5);
pub const IMEPADCTRL_CARETLEFT = @as(u32, 6);
pub const IMEPADCTRL_CARETRIGHT = @as(u32, 7);
pub const IMEPADCTRL_CARETTOP = @as(u32, 8);
pub const IMEPADCTRL_CARETBOTTOM = @as(u32, 9);
pub const IMEPADCTRL_CARETBACKSPACE = @as(u32, 10);
pub const IMEPADCTRL_CARETDELETE = @as(u32, 11);
pub const IMEPADCTRL_PHRASEDELETE = @as(u32, 12);
pub const IMEPADCTRL_INSERTSPACE = @as(u32, 13);
pub const IMEPADCTRL_INSERTFULLSPACE = @as(u32, 14);
pub const IMEPADCTRL_INSERTHALFSPACE = @as(u32, 15);
pub const IMEPADCTRL_ONIME = @as(u32, 16);
pub const IMEPADCTRL_OFFIME = @as(u32, 17);
pub const IMEPADCTRL_ONPRECONVERSION = @as(u32, 18);
pub const IMEPADCTRL_OFFPRECONVERSION = @as(u32, 19);
pub const IMEPADCTRL_PHONETICCANDIDATE = @as(u32, 20);
pub const IMEKEYCTRLMASK_ALT = @as(u32, 1);
pub const IMEKEYCTRLMASK_CTRL = @as(u32, 2);
pub const IMEKEYCTRLMASK_SHIFT = @as(u32, 4);
pub const IMEKEYCTRL_UP = @as(u32, 1);
pub const IMEKEYCTRL_DOWN = @as(u32, 0);
pub const IMEPN_FIRST = @as(u32, 256);
pub const IMEPN_ACTIVATE = @as(u32, 257);
pub const IMEPN_INACTIVATE = @as(u32, 258);
pub const IMEPN_SHOW = @as(u32, 260);
pub const IMEPN_HIDE = @as(u32, 261);
pub const IMEPN_SIZECHANGING = @as(u32, 262);
pub const IMEPN_SIZECHANGED = @as(u32, 263);
pub const IMEPN_CONFIG = @as(u32, 264);
pub const IMEPN_HELP = @as(u32, 265);
pub const IMEPN_QUERYCAND = @as(u32, 266);
pub const IMEPN_APPLYCAND = @as(u32, 267);
pub const IMEPN_APPLYCANDEX = @as(u32, 268);
pub const IMEPN_SETTINGCHANGED = @as(u32, 269);
pub const IMEPN_USER = @as(u32, 356);
pub const IPAWS_ENABLED = @as(i32, 1);
pub const IPAWS_SIZINGNOTIFY = @as(i32, 4);
pub const IPAWS_VERTICALFIXED = @as(i32, 256);
pub const IPAWS_HORIZONTALFIXED = @as(i32, 512);
pub const IPAWS_SIZEFIXED = @as(i32, 768);
pub const IPAWS_MAXWIDTHFIXED = @as(i32, 4096);
pub const IPAWS_MAXHEIGHTFIXED = @as(i32, 8192);
pub const IPAWS_MAXSIZEFIXED = @as(i32, 12288);
pub const IPAWS_MINWIDTHFIXED = @as(i32, 65536);
pub const IPAWS_MINHEIGHTFIXED = @as(i32, 131072);
pub const IPAWS_MINSIZEFIXED = @as(i32, 196608);
pub const CLSID_ImePlugInDictDictionaryList_CHS = Guid.initString("7bf0129b-5bef-4de4-9b0b-5edb66ac2fa6");
pub const CLSID_ImePlugInDictDictionaryList_JPN = Guid.initString("4fe2776b-b0f9-4396-b5fc-e9d4cf1ec195");

//--------------------------------------------------------------------------------
// Section: Types (80)
//--------------------------------------------------------------------------------
pub const SET_COMPOSITION_STRING_TYPE = enum(u32) {
    SETSTR = 9,
    CHANGEATTR = 18,
    CHANGECLAUSE = 36,
    SETRECONVERTSTRING = 65536,
    QUERYRECONVERTSTRING = 131072,
};
pub const SCS_SETSTR = SET_COMPOSITION_STRING_TYPE.SETSTR;
pub const SCS_CHANGEATTR = SET_COMPOSITION_STRING_TYPE.CHANGEATTR;
pub const SCS_CHANGECLAUSE = SET_COMPOSITION_STRING_TYPE.CHANGECLAUSE;
pub const SCS_SETRECONVERTSTRING = SET_COMPOSITION_STRING_TYPE.SETRECONVERTSTRING;
pub const SCS_QUERYRECONVERTSTRING = SET_COMPOSITION_STRING_TYPE.QUERYRECONVERTSTRING;

pub const GET_GUIDE_LINE_TYPE = enum(u32) {
    LEVEL = 1,
    INDEX = 2,
    STRING = 3,
    PRIVATE = 4,
};
pub const GGL_LEVEL = GET_GUIDE_LINE_TYPE.LEVEL;
pub const GGL_INDEX = GET_GUIDE_LINE_TYPE.INDEX;
pub const GGL_STRING = GET_GUIDE_LINE_TYPE.STRING;
pub const GGL_PRIVATE = GET_GUIDE_LINE_TYPE.PRIVATE;

pub const NOTIFY_IME_INDEX = enum(u32) {
    CANCEL = 4,
    COMPLETE = 1,
    CONVERT = 2,
    REVERT = 3,
};
pub const CPS_CANCEL = NOTIFY_IME_INDEX.CANCEL;
pub const CPS_COMPLETE = NOTIFY_IME_INDEX.COMPLETE;
pub const CPS_CONVERT = NOTIFY_IME_INDEX.CONVERT;
pub const CPS_REVERT = NOTIFY_IME_INDEX.REVERT;

pub const NOTIFY_IME_ACTION = enum(u32) {
    CHANGECANDIDATELIST = 19,
    CLOSECANDIDATE = 17,
    COMPOSITIONSTR = 21,
    IMEMENUSELECTED = 24,
    OPENCANDIDATE = 16,
    SELECTCANDIDATESTR = 18,
    SETCANDIDATE_PAGESIZE = 23,
    SETCANDIDATE_PAGESTART = 22,
};
pub const NI_CHANGECANDIDATELIST = NOTIFY_IME_ACTION.CHANGECANDIDATELIST;
pub const NI_CLOSECANDIDATE = NOTIFY_IME_ACTION.CLOSECANDIDATE;
pub const NI_COMPOSITIONSTR = NOTIFY_IME_ACTION.COMPOSITIONSTR;
pub const NI_IMEMENUSELECTED = NOTIFY_IME_ACTION.IMEMENUSELECTED;
pub const NI_OPENCANDIDATE = NOTIFY_IME_ACTION.OPENCANDIDATE;
pub const NI_SELECTCANDIDATESTR = NOTIFY_IME_ACTION.SELECTCANDIDATESTR;
pub const NI_SETCANDIDATE_PAGESIZE = NOTIFY_IME_ACTION.SETCANDIDATE_PAGESIZE;
pub const NI_SETCANDIDATE_PAGESTART = NOTIFY_IME_ACTION.SETCANDIDATE_PAGESTART;

pub const GET_CONVERSION_LIST_FLAG = enum(u32) {
    CONVERSION = 1,
    REVERSECONVERSION = 2,
    REVERSE_LENGTH = 3,
};
pub const GCL_CONVERSION = GET_CONVERSION_LIST_FLAG.CONVERSION;
pub const GCL_REVERSECONVERSION = GET_CONVERSION_LIST_FLAG.REVERSECONVERSION;
pub const GCL_REVERSE_LENGTH = GET_CONVERSION_LIST_FLAG.REVERSE_LENGTH;

pub const IME_PAD_REQUEST_FLAGS = enum(u32) {
    INSERTSTRING = 4097,
    SENDCONTROL = 4100,
    SETAPPLETSIZE = 4104,
    GETCOMPOSITIONSTRING = 4102,
    GETCOMPOSITIONSTRINGINFO = 4108,
    DELETESTRING = 4112,
    CHANGESTRING = 4113,
    GETAPPLHWND = 4116,
    FORCEIMEPADWINDOWSHOW = 4117,
    POSTMODALNOTIFY = 4118,
    GETDEFAULTUILANGID = 4119,
    GETAPPLETUISTYLE = 4121,
    SETAPPLETUISTYLE = 4122,
    ISAPPLETACTIVE = 4123,
    ISIMEPADWINDOWVISIBLE = 4124,
    SETAPPLETMINMAXSIZE = 4125,
    GETCONVERSIONSTATUS = 4126,
    GETVERSION = 4127,
    GETCURRENTIMEINFO = 4128,
};
pub const IMEPADREQ_INSERTSTRING = IME_PAD_REQUEST_FLAGS.INSERTSTRING;
pub const IMEPADREQ_SENDCONTROL = IME_PAD_REQUEST_FLAGS.SENDCONTROL;
pub const IMEPADREQ_SETAPPLETSIZE = IME_PAD_REQUEST_FLAGS.SETAPPLETSIZE;
pub const IMEPADREQ_GETCOMPOSITIONSTRING = IME_PAD_REQUEST_FLAGS.GETCOMPOSITIONSTRING;
pub const IMEPADREQ_GETCOMPOSITIONSTRINGINFO = IME_PAD_REQUEST_FLAGS.GETCOMPOSITIONSTRINGINFO;
pub const IMEPADREQ_DELETESTRING = IME_PAD_REQUEST_FLAGS.DELETESTRING;
pub const IMEPADREQ_CHANGESTRING = IME_PAD_REQUEST_FLAGS.CHANGESTRING;
pub const IMEPADREQ_GETAPPLHWND = IME_PAD_REQUEST_FLAGS.GETAPPLHWND;
pub const IMEPADREQ_FORCEIMEPADWINDOWSHOW = IME_PAD_REQUEST_FLAGS.FORCEIMEPADWINDOWSHOW;
pub const IMEPADREQ_POSTMODALNOTIFY = IME_PAD_REQUEST_FLAGS.POSTMODALNOTIFY;
pub const IMEPADREQ_GETDEFAULTUILANGID = IME_PAD_REQUEST_FLAGS.GETDEFAULTUILANGID;
pub const IMEPADREQ_GETAPPLETUISTYLE = IME_PAD_REQUEST_FLAGS.GETAPPLETUISTYLE;
pub const IMEPADREQ_SETAPPLETUISTYLE = IME_PAD_REQUEST_FLAGS.SETAPPLETUISTYLE;
pub const IMEPADREQ_ISAPPLETACTIVE = IME_PAD_REQUEST_FLAGS.ISAPPLETACTIVE;
pub const IMEPADREQ_ISIMEPADWINDOWVISIBLE = IME_PAD_REQUEST_FLAGS.ISIMEPADWINDOWVISIBLE;
pub const IMEPADREQ_SETAPPLETMINMAXSIZE = IME_PAD_REQUEST_FLAGS.SETAPPLETMINMAXSIZE;
pub const IMEPADREQ_GETCONVERSIONSTATUS = IME_PAD_REQUEST_FLAGS.GETCONVERSIONSTATUS;
pub const IMEPADREQ_GETVERSION = IME_PAD_REQUEST_FLAGS.GETVERSION;
pub const IMEPADREQ_GETCURRENTIMEINFO = IME_PAD_REQUEST_FLAGS.GETCURRENTIMEINFO;

pub const COMPOSITIONFORM = extern struct {
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};

pub const CANDIDATEFORM = extern struct {
    dwIndex: u32,
    dwStyle: u32,
    ptCurrentPos: POINT,
    rcArea: RECT,
};

pub const CANDIDATELIST = extern struct {
    dwSize: u32,
    dwStyle: u32,
    dwCount: u32,
    dwSelection: u32,
    dwPageStart: u32,
    dwPageSize: u32,
    dwOffset: [1]u32,
};

pub const REGISTERWORDA = extern struct {
    lpReading: ?PSTR,
    lpWord: ?PSTR,
};

pub const REGISTERWORDW = extern struct {
    lpReading: ?PWSTR,
    lpWord: ?PWSTR,
};

pub const RECONVERTSTRING = extern struct {
    dwSize: u32,
    dwVersion: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwTargetStrLen: u32,
    dwTargetStrOffset: u32,
};

pub const STYLEBUFA = extern struct {
    dwStyle: u32,
    szDescription: [32]CHAR,
};

pub const STYLEBUFW = extern struct {
    dwStyle: u32,
    szDescription: [32]u16,
};

pub const IMEMENUITEMINFOA = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: ?HBITMAP,
    hbmpUnchecked: ?HBITMAP,
    dwItemData: u32,
    szString: [80]CHAR,
    hbmpItem: ?HBITMAP,
};

pub const IMEMENUITEMINFOW = extern struct {
    cbSize: u32,
    fType: u32,
    fState: u32,
    wID: u32,
    hbmpChecked: ?HBITMAP,
    hbmpUnchecked: ?HBITMAP,
    dwItemData: u32,
    szString: [80]u16,
    hbmpItem: ?HBITMAP,
};

pub const IMECHARPOSITION = extern struct {
    dwSize: u32,
    dwCharPos: u32,
    pt: POINT,
    cLineHeight: u32,
    rcDocument: RECT,
};

pub const IMCENUMPROC = fn(
    param0: ?HIMC,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const REGISTERWORDENUMPROCA = fn(
    lpszReading: ?[*:0]const u8,
    param1: u32,
    lpszString: ?[*:0]const u8,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const REGISTERWORDENUMPROCW = fn(
    lpszReading: ?[*:0]const u16,
    param1: u32,
    lpszString: ?[*:0]const u16,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const IFEClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IClassFactory.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IClassFactory.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMEDLG = packed struct {
    cbIMEDLG: i32,
    hwnd: ?HWND,
    lpwstrWord: ?PWSTR,
    nTabId: i32,
};

const IID_IFECommon_Value = @import("../../zig.zig").Guid.initString("019f7151-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFECommon = &IID_IFECommon_Value;
pub const IFECommon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsDefaultIME: fn(
            self: *const IFECommon,
            szName: [*:0]const u8,
            cszName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultIME: fn(
            self: *const IFECommon,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeWordRegDialog: fn(
            self: *const IFECommon,
            pimedlg: ?*IMEDLG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeDictToolDialog: fn(
            self: *const IFECommon,
            pimedlg: ?*IMEDLG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFECommon_IsDefaultIME(self: *const T, szName: [*:0]const u8, cszName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFECommon.VTable, self.vtable).IsDefaultIME(@ptrCast(*const IFECommon, self), szName, cszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFECommon_SetDefaultIME(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFECommon.VTable, self.vtable).SetDefaultIME(@ptrCast(*const IFECommon, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFECommon_InvokeWordRegDialog(self: *const T, pimedlg: ?*IMEDLG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFECommon.VTable, self.vtable).InvokeWordRegDialog(@ptrCast(*const IFECommon, self), pimedlg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFECommon_InvokeDictToolDialog(self: *const T, pimedlg: ?*IMEDLG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFECommon.VTable, self.vtable).InvokeDictToolDialog(@ptrCast(*const IFECommon, self), pimedlg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WDD = packed struct {
    wDispPos: u16,
    Anonymous1: packed union {
        wReadPos: u16,
        wCompPos: u16,
    },
    cchDisp: u16,
    Anonymous2: packed union {
        cchRead: u16,
        cchComp: u16,
    },
    WDD_nReserve1: u32,
    nPos: u16,
    _bitfield: u16,
    pReserved: ?*anyopaque,
};

pub const MORRSLT = packed struct {
    dwSize: u32,
    pwchOutput: ?PWSTR,
    cchOutput: u16,
    Anonymous1: packed union {
        pwchRead: ?PWSTR,
        pwchComp: ?PWSTR,
    },
    Anonymous2: packed union {
        cchRead: u16,
        cchComp: u16,
    },
    pchInputPos: ?*u16,
    pchOutputIdxWDD: ?*u16,
    Anonymous3: packed union {
        pchReadIdxWDD: ?*u16,
        pchCompIdxWDD: ?*u16,
    },
    paMonoRubyPos: ?*u16,
    pWDD: ?*WDD,
    cWDD: i32,
    pPrivate: ?*anyopaque,
    BLKBuff: [1]u16,
};

const IID_IFELanguage_Value = @import("../../zig.zig").Guid.initString("019f7152-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFELanguage = &IID_IFELanguage_Value;
pub const IFELanguage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IFELanguage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IFELanguage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetJMorphResult: fn(
            self: *const IFELanguage,
            dwRequest: u32,
            dwCMode: u32,
            cwchInput: i32,
            pwchInput: ?[*:0]const u16,
            pfCInfo: ?*u32,
            ppResult: ?*?*MORRSLT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionModeCaps: fn(
            self: *const IFELanguage,
            pdwCaps: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPhonetic: fn(
            self: *const IFELanguage,
            string: ?BSTR,
            start: i32,
            length: i32,
            phonetic: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversion: fn(
            self: *const IFELanguage,
            string: ?BSTR,
            start: i32,
            length: i32,
            result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_Open(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).Open(@ptrCast(*const IFELanguage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).Close(@ptrCast(*const IFELanguage, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_GetJMorphResult(self: *const T, dwRequest: u32, dwCMode: u32, cwchInput: i32, pwchInput: ?[*:0]const u16, pfCInfo: ?*u32, ppResult: ?*?*MORRSLT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).GetJMorphResult(@ptrCast(*const IFELanguage, self), dwRequest, dwCMode, cwchInput, pwchInput, pfCInfo, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_GetConversionModeCaps(self: *const T, pdwCaps: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).GetConversionModeCaps(@ptrCast(*const IFELanguage, self), pdwCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_GetPhonetic(self: *const T, string: ?BSTR, start: i32, length: i32, phonetic: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).GetPhonetic(@ptrCast(*const IFELanguage, self), string, start, length, phonetic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFELanguage_GetConversion(self: *const T, string: ?BSTR, start: i32, length: i32, result: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFELanguage.VTable, self.vtable).GetConversion(@ptrCast(*const IFELanguage, self), string, start, length, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMEREG = enum(i32) {
    HEAD = 0,
    TAIL = 1,
    DEL = 2,
};
pub const IFED_REG_HEAD = IMEREG.HEAD;
pub const IFED_REG_TAIL = IMEREG.TAIL;
pub const IFED_REG_DEL = IMEREG.DEL;

pub const IMEFMT = enum(i32) {
    UNKNOWN = 0,
    MSIME2_BIN_SYSTEM = 1,
    MSIME2_BIN_USER = 2,
    MSIME2_TEXT_USER = 3,
    MSIME95_BIN_SYSTEM = 4,
    MSIME95_BIN_USER = 5,
    MSIME95_TEXT_USER = 6,
    MSIME97_BIN_SYSTEM = 7,
    MSIME97_BIN_USER = 8,
    MSIME97_TEXT_USER = 9,
    MSIME98_BIN_SYSTEM = 10,
    MSIME98_BIN_USER = 11,
    MSIME98_TEXT_USER = 12,
    ACTIVE_DICT = 13,
    ATOK9 = 14,
    ATOK10 = 15,
    NEC_AI_ = 16,
    WX_II = 17,
    WX_III = 18,
    VJE_20 = 19,
    MSIME98_SYSTEM_CE = 20,
    MSIME_BIN_SYSTEM = 21,
    MSIME_BIN_USER = 22,
    MSIME_TEXT_USER = 23,
    PIME2_BIN_USER = 24,
    PIME2_BIN_SYSTEM = 25,
    PIME2_BIN_STANDARD_SYSTEM = 26,
};
pub const IFED_UNKNOWN = IMEFMT.UNKNOWN;
pub const IFED_MSIME2_BIN_SYSTEM = IMEFMT.MSIME2_BIN_SYSTEM;
pub const IFED_MSIME2_BIN_USER = IMEFMT.MSIME2_BIN_USER;
pub const IFED_MSIME2_TEXT_USER = IMEFMT.MSIME2_TEXT_USER;
pub const IFED_MSIME95_BIN_SYSTEM = IMEFMT.MSIME95_BIN_SYSTEM;
pub const IFED_MSIME95_BIN_USER = IMEFMT.MSIME95_BIN_USER;
pub const IFED_MSIME95_TEXT_USER = IMEFMT.MSIME95_TEXT_USER;
pub const IFED_MSIME97_BIN_SYSTEM = IMEFMT.MSIME97_BIN_SYSTEM;
pub const IFED_MSIME97_BIN_USER = IMEFMT.MSIME97_BIN_USER;
pub const IFED_MSIME97_TEXT_USER = IMEFMT.MSIME97_TEXT_USER;
pub const IFED_MSIME98_BIN_SYSTEM = IMEFMT.MSIME98_BIN_SYSTEM;
pub const IFED_MSIME98_BIN_USER = IMEFMT.MSIME98_BIN_USER;
pub const IFED_MSIME98_TEXT_USER = IMEFMT.MSIME98_TEXT_USER;
pub const IFED_ACTIVE_DICT = IMEFMT.ACTIVE_DICT;
pub const IFED_ATOK9 = IMEFMT.ATOK9;
pub const IFED_ATOK10 = IMEFMT.ATOK10;
pub const IFED_NEC_AI_ = IMEFMT.NEC_AI_;
pub const IFED_WX_II = IMEFMT.WX_II;
pub const IFED_WX_III = IMEFMT.WX_III;
pub const IFED_VJE_20 = IMEFMT.VJE_20;
pub const IFED_MSIME98_SYSTEM_CE = IMEFMT.MSIME98_SYSTEM_CE;
pub const IFED_MSIME_BIN_SYSTEM = IMEFMT.MSIME_BIN_SYSTEM;
pub const IFED_MSIME_BIN_USER = IMEFMT.MSIME_BIN_USER;
pub const IFED_MSIME_TEXT_USER = IMEFMT.MSIME_TEXT_USER;
pub const IFED_PIME2_BIN_USER = IMEFMT.PIME2_BIN_USER;
pub const IFED_PIME2_BIN_SYSTEM = IMEFMT.PIME2_BIN_SYSTEM;
pub const IFED_PIME2_BIN_STANDARD_SYSTEM = IMEFMT.PIME2_BIN_STANDARD_SYSTEM;

pub const IMEUCT = enum(i32) {
    NONE = 0,
    STRING_SJIS = 1,
    STRING_UNICODE = 2,
    USER_DEFINED = 3,
    MAX = 4,
};
pub const IFED_UCT_NONE = IMEUCT.NONE;
pub const IFED_UCT_STRING_SJIS = IMEUCT.STRING_SJIS;
pub const IFED_UCT_STRING_UNICODE = IMEUCT.STRING_UNICODE;
pub const IFED_UCT_USER_DEFINED = IMEUCT.USER_DEFINED;
pub const IFED_UCT_MAX = IMEUCT.MAX;

pub const IMEWRD = packed struct {
    pwchReading: ?PWSTR,
    pwchDisplay: ?PWSTR,
    Anonymous: packed union {
        ulPos: u32,
        Anonymous: packed struct {
            nPos1: u16,
            nPos2: u16,
        },
    },
    rgulAttrs: [2]u32,
    cbComment: i32,
    uct: IMEUCT,
    pvComment: ?*anyopaque,
};

pub const IMESHF = packed struct {
    cbShf: u16,
    verDic: u16,
    szTitle: [48]CHAR,
    szDescription: [256]CHAR,
    szCopyright: [128]CHAR,
};

pub const POSTBL = packed struct {
    nPos: u16,
    szName: ?*u8,
};

pub const IMEREL = enum(i32) {
    NONE = 0,
    NO = 1,
    GA = 2,
    WO = 3,
    NI = 4,
    DE = 5,
    YORI = 6,
    KARA = 7,
    MADE = 8,
    HE = 9,
    TO = 10,
    IDEOM = 11,
    FUKU_YOUGEN = 12,
    KEIYOU_YOUGEN = 13,
    KEIDOU1_YOUGEN = 14,
    KEIDOU2_YOUGEN = 15,
    TAIGEN = 16,
    YOUGEN = 17,
    RENTAI_MEI = 18,
    RENSOU = 19,
    KEIYOU_TO_YOUGEN = 20,
    KEIYOU_TARU_YOUGEN = 21,
    UNKNOWN1 = 22,
    UNKNOWN2 = 23,
    ALL = 24,
};
pub const IFED_REL_NONE = IMEREL.NONE;
pub const IFED_REL_NO = IMEREL.NO;
pub const IFED_REL_GA = IMEREL.GA;
pub const IFED_REL_WO = IMEREL.WO;
pub const IFED_REL_NI = IMEREL.NI;
pub const IFED_REL_DE = IMEREL.DE;
pub const IFED_REL_YORI = IMEREL.YORI;
pub const IFED_REL_KARA = IMEREL.KARA;
pub const IFED_REL_MADE = IMEREL.MADE;
pub const IFED_REL_HE = IMEREL.HE;
pub const IFED_REL_TO = IMEREL.TO;
pub const IFED_REL_IDEOM = IMEREL.IDEOM;
pub const IFED_REL_FUKU_YOUGEN = IMEREL.FUKU_YOUGEN;
pub const IFED_REL_KEIYOU_YOUGEN = IMEREL.KEIYOU_YOUGEN;
pub const IFED_REL_KEIDOU1_YOUGEN = IMEREL.KEIDOU1_YOUGEN;
pub const IFED_REL_KEIDOU2_YOUGEN = IMEREL.KEIDOU2_YOUGEN;
pub const IFED_REL_TAIGEN = IMEREL.TAIGEN;
pub const IFED_REL_YOUGEN = IMEREL.YOUGEN;
pub const IFED_REL_RENTAI_MEI = IMEREL.RENTAI_MEI;
pub const IFED_REL_RENSOU = IMEREL.RENSOU;
pub const IFED_REL_KEIYOU_TO_YOUGEN = IMEREL.KEIYOU_TO_YOUGEN;
pub const IFED_REL_KEIYOU_TARU_YOUGEN = IMEREL.KEIYOU_TARU_YOUGEN;
pub const IFED_REL_UNKNOWN1 = IMEREL.UNKNOWN1;
pub const IFED_REL_UNKNOWN2 = IMEREL.UNKNOWN2;
pub const IFED_REL_ALL = IMEREL.ALL;

pub const IMEDP = packed struct {
    wrdModifier: IMEWRD,
    wrdModifiee: IMEWRD,
    relID: IMEREL,
};

pub const PFNLOG = fn(
    param0: ?*IMEDP,
    param1: HRESULT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const IID_IFEDictionary_Value = @import("../../zig.zig").Guid.initString("019f7153-e6db-11d0-83c3-00c04fddb82e");
pub const IID_IFEDictionary = &IID_IFEDictionary_Value;
pub const IFEDictionary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IFEDictionary,
            pchDictPath: ?*[260]u8,
            pshf: ?*IMESHF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IFEDictionary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeader: fn(
            self: *const IFEDictionary,
            pchDictPath: ?*[260]u8,
            pshf: ?*IMESHF,
            pjfmt: ?*IMEFMT,
            pulType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayProperty: fn(
            self: *const IFEDictionary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosTable: fn(
            self: *const IFEDictionary,
            prgPosTbl: ?*?*POSTBL,
            pcPosTbl: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWords: fn(
            self: *const IFEDictionary,
            pwchFirst: ?[*:0]const u16,
            pwchLast: ?[*:0]const u16,
            pwchDisplay: ?[*:0]const u16,
            ulPos: u32,
            ulSelect: u32,
            ulWordSrc: u32,
            pchBuffer: ?*u8,
            cbBuffer: u32,
            pcWrd: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextWords: fn(
            self: *const IFEDictionary,
            pchBuffer: ?*u8,
            cbBuffer: u32,
            pcWrd: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: fn(
            self: *const IFEDictionary,
            pchDictPath: ?[*:0]const u8,
            pshf: ?*IMESHF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeader: fn(
            self: *const IFEDictionary,
            pshf: ?*IMESHF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExistWord: fn(
            self: *const IFEDictionary,
            pwrd: ?*IMEWRD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExistDependency: fn(
            self: *const IFEDictionary,
            pdp: ?*IMEDP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWord: fn(
            self: *const IFEDictionary,
            reg: IMEREG,
            pwrd: ?*IMEWRD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterDependency: fn(
            self: *const IFEDictionary,
            reg: IMEREG,
            pdp: ?*IMEDP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDependencies: fn(
            self: *const IFEDictionary,
            pwchKakariReading: ?[*:0]const u16,
            pwchKakariDisplay: ?[*:0]const u16,
            ulKakariPos: u32,
            pwchUkeReading: ?[*:0]const u16,
            pwchUkeDisplay: ?[*:0]const u16,
            ulUkePos: u32,
            jrel: IMEREL,
            ulWordSrc: u32,
            pchBuffer: ?*u8,
            cbBuffer: u32,
            pcdp: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextDependencies: fn(
            self: *const IFEDictionary,
            pchBuffer: ?*u8,
            cbBuffer: u32,
            pcDp: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertFromOldMSIME: fn(
            self: *const IFEDictionary,
            pchDic: ?[*:0]const u8,
            pfnLog: ?PFNLOG,
            reg: IMEREG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertFromUserToSys: fn(
            self: *const IFEDictionary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_Open(self: *const T, pchDictPath: ?*[260]u8, pshf: ?*IMESHF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).Open(@ptrCast(*const IFEDictionary, self), pchDictPath, pshf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).Close(@ptrCast(*const IFEDictionary, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_GetHeader(self: *const T, pchDictPath: ?*[260]u8, pshf: ?*IMESHF, pjfmt: ?*IMEFMT, pulType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).GetHeader(@ptrCast(*const IFEDictionary, self), pchDictPath, pshf, pjfmt, pulType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_DisplayProperty(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).DisplayProperty(@ptrCast(*const IFEDictionary, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_GetPosTable(self: *const T, prgPosTbl: ?*?*POSTBL, pcPosTbl: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).GetPosTable(@ptrCast(*const IFEDictionary, self), prgPosTbl, pcPosTbl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_GetWords(self: *const T, pwchFirst: ?[*:0]const u16, pwchLast: ?[*:0]const u16, pwchDisplay: ?[*:0]const u16, ulPos: u32, ulSelect: u32, ulWordSrc: u32, pchBuffer: ?*u8, cbBuffer: u32, pcWrd: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).GetWords(@ptrCast(*const IFEDictionary, self), pwchFirst, pwchLast, pwchDisplay, ulPos, ulSelect, ulWordSrc, pchBuffer, cbBuffer, pcWrd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_NextWords(self: *const T, pchBuffer: ?*u8, cbBuffer: u32, pcWrd: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).NextWords(@ptrCast(*const IFEDictionary, self), pchBuffer, cbBuffer, pcWrd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_Create(self: *const T, pchDictPath: ?[*:0]const u8, pshf: ?*IMESHF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).Create(@ptrCast(*const IFEDictionary, self), pchDictPath, pshf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_SetHeader(self: *const T, pshf: ?*IMESHF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).SetHeader(@ptrCast(*const IFEDictionary, self), pshf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_ExistWord(self: *const T, pwrd: ?*IMEWRD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).ExistWord(@ptrCast(*const IFEDictionary, self), pwrd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_ExistDependency(self: *const T, pdp: ?*IMEDP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).ExistDependency(@ptrCast(*const IFEDictionary, self), pdp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_RegisterWord(self: *const T, reg: IMEREG, pwrd: ?*IMEWRD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).RegisterWord(@ptrCast(*const IFEDictionary, self), reg, pwrd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_RegisterDependency(self: *const T, reg: IMEREG, pdp: ?*IMEDP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).RegisterDependency(@ptrCast(*const IFEDictionary, self), reg, pdp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_GetDependencies(self: *const T, pwchKakariReading: ?[*:0]const u16, pwchKakariDisplay: ?[*:0]const u16, ulKakariPos: u32, pwchUkeReading: ?[*:0]const u16, pwchUkeDisplay: ?[*:0]const u16, ulUkePos: u32, jrel: IMEREL, ulWordSrc: u32, pchBuffer: ?*u8, cbBuffer: u32, pcdp: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).GetDependencies(@ptrCast(*const IFEDictionary, self), pwchKakariReading, pwchKakariDisplay, ulKakariPos, pwchUkeReading, pwchUkeDisplay, ulUkePos, jrel, ulWordSrc, pchBuffer, cbBuffer, pcdp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_NextDependencies(self: *const T, pchBuffer: ?*u8, cbBuffer: u32, pcDp: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).NextDependencies(@ptrCast(*const IFEDictionary, self), pchBuffer, cbBuffer, pcDp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_ConvertFromOldMSIME(self: *const T, pchDic: ?[*:0]const u8, pfnLog: ?PFNLOG, reg: IMEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).ConvertFromOldMSIME(@ptrCast(*const IFEDictionary, self), pchDic, pfnLog, reg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFEDictionary_ConvertFromUserToSys(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFEDictionary.VTable, self.vtable).ConvertFromUserToSys(@ptrCast(*const IFEDictionary, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMEKMSINIT = packed struct {
    cbSize: i32,
    hWnd: ?HWND,
};

pub const IMEKMSKEY = packed struct {
    dwStatus: u32,
    dwCompStatus: u32,
    dwVKEY: u32,
    Anonymous1: packed union {
        dwControl: u32,
        dwNotUsed: u32,
    },
    Anonymous2: packed union {
        pwszDscr: [31]u16,
        pwszNoUse: [31]u16,
    },
};

pub const IMEKMS = packed struct {
    cbSize: i32,
    hIMC: ?HIMC,
    cKeyList: u32,
    pKeyList: ?*IMEKMSKEY,
};

pub const IMEKMSNTFY = packed struct {
    cbSize: i32,
    hIMC: ?HIMC,
    fSelect: BOOL,
};

pub const IMEKMSKMP = packed struct {
    cbSize: i32,
    hIMC: ?HIMC,
    idLang: u16,
    wVKStart: u16,
    wVKEnd: u16,
    cKeyList: i32,
    pKeyList: ?*IMEKMSKEY,
};

pub const IMEKMSINVK = packed struct {
    cbSize: i32,
    hIMC: ?HIMC,
    dwControl: u32,
};

pub const IMEKMSFUNCDESC = packed struct {
    cbSize: i32,
    idLang: u16,
    dwControl: u32,
    pwszDescription: [128]u16,
};

pub const fpCreateIFECommonInstanceType = fn(
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const fpCreateIFELanguageInstanceType = fn(
    clsid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const fpCreateIFEDictionaryInstanceType = fn(
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const COMPOSITIONSTRING = extern struct {
    dwSize: u32,
    dwCompReadAttrLen: u32,
    dwCompReadAttrOffset: u32,
    dwCompReadClauseLen: u32,
    dwCompReadClauseOffset: u32,
    dwCompReadStrLen: u32,
    dwCompReadStrOffset: u32,
    dwCompAttrLen: u32,
    dwCompAttrOffset: u32,
    dwCompClauseLen: u32,
    dwCompClauseOffset: u32,
    dwCompStrLen: u32,
    dwCompStrOffset: u32,
    dwCursorPos: u32,
    dwDeltaStart: u32,
    dwResultReadClauseLen: u32,
    dwResultReadClauseOffset: u32,
    dwResultReadStrLen: u32,
    dwResultReadStrOffset: u32,
    dwResultClauseLen: u32,
    dwResultClauseOffset: u32,
    dwResultStrLen: u32,
    dwResultStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const GUIDELINE = extern struct {
    dwSize: u32,
    dwLevel: u32,
    dwIndex: u32,
    dwStrLen: u32,
    dwStrOffset: u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const TRANSMSG = extern struct {
    message: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};

pub const TRANSMSGLIST = extern struct {
    uMsgCount: u32,
    TransMsg: [1]TRANSMSG,
};

pub const CANDIDATEINFO = extern struct {
    dwSize: u32,
    dwCount: u32,
    dwOffset: [32]u32,
    dwPrivateSize: u32,
    dwPrivateOffset: u32,
};

pub const INPUTCONTEXT = extern struct {
    hWnd: ?HWND,
    fOpen: BOOL,
    ptStatusWndPos: POINT,
    ptSoftKbdPos: POINT,
    fdwConversion: u32,
    fdwSentence: u32,
    lfFont: extern union {
        A: LOGFONTA,
        W: LOGFONTW,
    },
    cfCompForm: COMPOSITIONFORM,
    cfCandForm: [4]CANDIDATEFORM,
    hCompStr: ?HIMCC,
    hCandInfo: ?HIMCC,
    hGuideLine: ?HIMCC,
    hPrivate: ?HIMCC,
    dwNumMsgBuf: u32,
    hMsgBuf: ?HIMCC,
    fdwInit: u32,
    dwReserve: [3]u32,
};

pub const IMEINFO = extern struct {
    dwPrivateDataSize: u32,
    fdwProperty: u32,
    fdwConversionCaps: u32,
    fdwSentenceCaps: u32,
    fdwUICaps: u32,
    fdwSCSCaps: u32,
    fdwSelectCaps: u32,
};

pub const SOFTKBDDATA = extern struct {
    uCount: u32,
    wCode: [256]u16,
};

pub const APPLETIDLIST = extern struct {
    count: i32,
    pIIDList: ?*Guid,
};

pub const IMESTRINGCANDIDATE = extern struct {
    uCount: u32,
    lpwstr: [1]?PWSTR,
};

pub const IMEITEM = extern struct {
    cbSize: i32,
    iType: i32,
    lpItemData: ?*anyopaque,
};

pub const IMEITEMCANDIDATE = extern struct {
    uCount: u32,
    imeItem: [1]IMEITEM,
};

pub const tabIMESTRINGINFO = extern struct {
    dwFarEastId: u32,
    lpwstr: ?PWSTR,
};

pub const tabIMEFAREASTINFO = extern struct {
    dwSize: u32,
    dwType: u32,
    dwData: [1]u32,
};

pub const IMESTRINGCANDIDATEINFO = extern struct {
    dwFarEastId: u32,
    lpFarEastInfo: ?*tabIMEFAREASTINFO,
    fInfoMask: u32,
    iSelIndex: i32,
    uCount: u32,
    lpwstr: [1]?PWSTR,
};

pub const IMECOMPOSITIONSTRINGINFO = extern struct {
    iCompStrLen: i32,
    iCaretPos: i32,
    iEditStart: i32,
    iEditLen: i32,
    iTargetStart: i32,
    iTargetLen: i32,
};

pub const IMECHARINFO = extern struct {
    wch: u16,
    dwCharInfo: u32,
};

pub const IMEAPPLETCFG = extern struct {
    dwConfig: u32,
    wchTitle: [64]u16,
    wchTitleFontFace: [32]u16,
    dwCharSet: u32,
    iCategory: i32,
    hIcon: ?HICON,
    langID: u16,
    dummy: u16,
    lReserved1: LPARAM,
};

pub const IMEAPPLETUI = extern struct {
    hwnd: ?HWND,
    dwStyle: u32,
    width: i32,
    height: i32,
    minWidth: i32,
    minHeight: i32,
    maxWidth: i32,
    maxHeight: i32,
    lReserved1: LPARAM,
    lReserved2: LPARAM,
};

pub const APPLYCANDEXPARAM = extern struct {
    dwSize: u32,
    lpwstrDisplay: ?PWSTR,
    lpwstrReading: ?PWSTR,
    dwReserved: u32,
};

const IID_IImeSpecifyApplets_Value = @import("../../zig.zig").Guid.initString("5d8e643c-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImeSpecifyApplets = &IID_IImeSpecifyApplets_Value;
pub const IImeSpecifyApplets = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppletIIDList: fn(
            self: *const IImeSpecifyApplets,
            refiid: ?*const Guid,
            lpIIDList: ?*APPLETIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImeSpecifyApplets_GetAppletIIDList(self: *const T, refiid: ?*const Guid, lpIIDList: ?*APPLETIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImeSpecifyApplets.VTable, self.vtable).GetAppletIIDList(@ptrCast(*const IImeSpecifyApplets, self), refiid, lpIIDList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IImePadApplet_Value = @import("../../zig.zig").Guid.initString("5d8e643b-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImePadApplet = &IID_IImePadApplet_Value;
pub const IImePadApplet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IImePadApplet,
            lpIImePad: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Terminate: fn(
            self: *const IImePadApplet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppletConfig: fn(
            self: *const IImePadApplet,
            lpAppletCfg: ?*IMEAPPLETCFG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateUI: fn(
            self: *const IImePadApplet,
            hwndParent: ?HWND,
            lpImeAppletUI: ?*IMEAPPLETUI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const IImePadApplet,
            lpImePad: ?*IUnknown,
            notify: i32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_Initialize(self: *const T, lpIImePad: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).Initialize(@ptrCast(*const IImePadApplet, self), lpIImePad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_Terminate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).Terminate(@ptrCast(*const IImePadApplet, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_GetAppletConfig(self: *const T, lpAppletCfg: ?*IMEAPPLETCFG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).GetAppletConfig(@ptrCast(*const IImePadApplet, self), lpAppletCfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_CreateUI(self: *const T, hwndParent: ?HWND, lpImeAppletUI: ?*IMEAPPLETUI) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).CreateUI(@ptrCast(*const IImePadApplet, self), hwndParent, lpImeAppletUI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePadApplet_Notify(self: *const T, lpImePad: ?*IUnknown, notify: i32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePadApplet.VTable, self.vtable).Notify(@ptrCast(*const IImePadApplet, self), lpImePad, notify, wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IImePad_Value = @import("../../zig.zig").Guid.initString("5d8e643a-c3a9-11d1-afef-00805f0c8b6d");
pub const IID_IImePad = &IID_IImePad_Value;
pub const IImePad = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Request: fn(
            self: *const IImePad,
            pIImePadApplet: ?*IImePadApplet,
            reqId: IME_PAD_REQUEST_FLAGS,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePad_Request(self: *const T, pIImePadApplet: ?*IImePadApplet, reqId: IME_PAD_REQUEST_FLAGS, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePad.VTable, self.vtable).Request(@ptrCast(*const IImePad, self), pIImePadApplet, reqId, wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IImePlugInDictDictionaryList_Value = @import("../../zig.zig").Guid.initString("98752974-b0a6-489b-8f6f-bff3769c8eeb");
pub const IID_IImePlugInDictDictionaryList = &IID_IImePlugInDictDictionaryList_Value;
pub const IImePlugInDictDictionaryList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDictionariesInUse: fn(
            self: *const IImePlugInDictDictionaryList,
            prgDictionaryGUID: ?*?*SAFEARRAY,
            prgDateCreated: ?*?*SAFEARRAY,
            prgfEncrypted: ?*?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteDictionary: fn(
            self: *const IImePlugInDictDictionaryList,
            bstrDictionaryGUID: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePlugInDictDictionaryList_GetDictionariesInUse(self: *const T, prgDictionaryGUID: ?*?*SAFEARRAY, prgDateCreated: ?*?*SAFEARRAY, prgfEncrypted: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePlugInDictDictionaryList.VTable, self.vtable).GetDictionariesInUse(@ptrCast(*const IImePlugInDictDictionaryList, self), prgDictionaryGUID, prgDateCreated, prgfEncrypted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImePlugInDictDictionaryList_DeleteDictionary(self: *const T, bstrDictionaryGUID: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImePlugInDictDictionaryList.VTable, self.vtable).DeleteDictionary(@ptrCast(*const IImePlugInDictDictionaryList, self), bstrDictionaryGUID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CActiveIMM_Value = @import("../../zig.zig").Guid.initString("4955dd33-b159-11d0-8fcf-00aa006bcc59");
pub const CLSID_CActiveIMM = &CLSID_CActiveIMM_Value;

const IID_IEnumRegisterWordA_Value = @import("../../zig.zig").Guid.initString("08c03412-f96b-11d0-a475-00aa006bcc59");
pub const IID_IEnumRegisterWordA = &IID_IEnumRegisterWordA_Value;
pub const IEnumRegisterWordA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumRegisterWordA,
            ppEnum: ?*?*IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumRegisterWordA,
            ulCount: u32,
            rgRegisterWord: ?*REGISTERWORDA,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumRegisterWordA,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordA_Clone(self: *const T, ppEnum: ?*?*IEnumRegisterWordA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordA.VTable, self.vtable).Clone(@ptrCast(*const IEnumRegisterWordA, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordA_Next(self: *const T, ulCount: u32, rgRegisterWord: ?*REGISTERWORDA, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordA.VTable, self.vtable).Next(@ptrCast(*const IEnumRegisterWordA, self), ulCount, rgRegisterWord, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordA_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordA.VTable, self.vtable).Reset(@ptrCast(*const IEnumRegisterWordA, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordA_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordA.VTable, self.vtable).Skip(@ptrCast(*const IEnumRegisterWordA, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRegisterWordW_Value = @import("../../zig.zig").Guid.initString("4955dd31-b159-11d0-8fcf-00aa006bcc59");
pub const IID_IEnumRegisterWordW = &IID_IEnumRegisterWordW_Value;
pub const IEnumRegisterWordW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumRegisterWordW,
            ppEnum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumRegisterWordW,
            ulCount: u32,
            rgRegisterWord: ?*REGISTERWORDW,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumRegisterWordW,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordW_Clone(self: *const T, ppEnum: ?*?*IEnumRegisterWordW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordW.VTable, self.vtable).Clone(@ptrCast(*const IEnumRegisterWordW, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordW_Next(self: *const T, ulCount: u32, rgRegisterWord: ?*REGISTERWORDW, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordW.VTable, self.vtable).Next(@ptrCast(*const IEnumRegisterWordW, self), ulCount, rgRegisterWord, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordW_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordW.VTable, self.vtable).Reset(@ptrCast(*const IEnumRegisterWordW, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegisterWordW_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRegisterWordW.VTable, self.vtable).Skip(@ptrCast(*const IEnumRegisterWordW, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumInputContext_Value = @import("../../zig.zig").Guid.initString("09b5eab0-f997-11d1-93d4-0060b067b86e");
pub const IID_IEnumInputContext = &IID_IEnumInputContext_Value;
pub const IEnumInputContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumInputContext,
            ppEnum: ?*?*IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumInputContext,
            ulCount: u32,
            rgInputContext: ?*?HIMC,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumInputContext,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumInputContext_Clone(self: *const T, ppEnum: ?*?*IEnumInputContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumInputContext.VTable, self.vtable).Clone(@ptrCast(*const IEnumInputContext, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumInputContext_Next(self: *const T, ulCount: u32, rgInputContext: ?*?HIMC, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumInputContext.VTable, self.vtable).Next(@ptrCast(*const IEnumInputContext, self), ulCount, rgInputContext, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumInputContext_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumInputContext.VTable, self.vtable).Reset(@ptrCast(*const IEnumInputContext, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumInputContext_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumInputContext.VTable, self.vtable).Skip(@ptrCast(*const IEnumInputContext, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMRegistrar_Value = @import("../../zig.zig").Guid.initString("b3458082-bd00-11d1-939b-0060b067b86e");
pub const IID_IActiveIMMRegistrar = &IID_IActiveIMMRegistrar_Value;
pub const IActiveIMMRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterIME: fn(
            self: *const IActiveIMMRegistrar,
            rclsid: ?*const Guid,
            lgid: u16,
            pszIconFile: ?[*:0]const u16,
            pszDesc: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterIME: fn(
            self: *const IActiveIMMRegistrar,
            rclsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMRegistrar_RegisterIME(self: *const T, rclsid: ?*const Guid, lgid: u16, pszIconFile: ?[*:0]const u16, pszDesc: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMRegistrar.VTable, self.vtable).RegisterIME(@ptrCast(*const IActiveIMMRegistrar, self), rclsid, lgid, pszIconFile, pszDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMRegistrar_UnregisterIME(self: *const T, rclsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMRegistrar.VTable, self.vtable).UnregisterIME(@ptrCast(*const IActiveIMMRegistrar, self), rclsid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMMessagePumpOwner_Value = @import("../../zig.zig").Guid.initString("b5cf2cfa-8aeb-11d1-9364-0060b067b86e");
pub const IID_IActiveIMMMessagePumpOwner = &IID_IActiveIMMMessagePumpOwner_Value;
pub const IActiveIMMMessagePumpOwner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const IActiveIMMMessagePumpOwner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: fn(
            self: *const IActiveIMMMessagePumpOwner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTranslateMessage: fn(
            self: *const IActiveIMMMessagePumpOwner,
            pMsg: ?*const MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IActiveIMMMessagePumpOwner,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IActiveIMMMessagePumpOwner,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_Start(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).Start(@ptrCast(*const IActiveIMMMessagePumpOwner, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_End(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).End(@ptrCast(*const IActiveIMMMessagePumpOwner, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_OnTranslateMessage(self: *const T, pMsg: ?*const MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).OnTranslateMessage(@ptrCast(*const IActiveIMMMessagePumpOwner, self), pMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_Pause(self: *const T, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).Pause(@ptrCast(*const IActiveIMMMessagePumpOwner, self), pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMMessagePumpOwner_Resume(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMMessagePumpOwner.VTable, self.vtable).Resume(@ptrCast(*const IActiveIMMMessagePumpOwner, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMApp_Value = @import("../../zig.zig").Guid.initString("08c0e040-62d1-11d1-9326-0060b067b86e");
pub const IID_IActiveIMMApp = &IID_IActiveIMMApp_Value;
pub const IActiveIMMApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateContext: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            hIME: ?HIMC,
            phPrev: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pData: ?*REGISTERWORDA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pData: ?*REGISTERWORDW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateContext: fn(
            self: *const IActiveIMMApp,
            phIMC: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyContext: fn(
            self: *const IActiveIMMApp,
            hIME: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szRegister: ?PSTR,
            pData: ?*anyopaque,
            pEnum: ?*?*IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
            pData: ?*anyopaque,
            pEnum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*anyopaque,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*anyopaque,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            uBufLen: u32,
            pCandList: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            uBufLen: u32,
            pCandList: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pdwListSize: ?*u32,
            pdwBufLen: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pdwListSize: ?*u32,
            pdwBufLen: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateWindow: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            pCandidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            plCopied: ?*i32,
            pBuf: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            plCopied: ?*i32,
            pBuf: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionWindow: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pCompForm: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            phIMC: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hIMC: ?HIMC,
            pSrc: ?PSTR,
            uBufLen: u32,
            uFlag: u32,
            pDst: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            hIMC: ?HIMC,
            pSrc: ?PWSTR,
            uBufLen: u32,
            uFlag: u32,
            pDst: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionStatus: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pfdwConversion: ?*u32,
            pfdwSentence: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultIMEWnd: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            phDefWnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uBufLen: u32,
            szDescription: ?PSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uBufLen: u32,
            szDescription: ?PWSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            pBuf: ?PSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            pBuf: ?PWSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uBufLen: u32,
            szFileName: ?PSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uBufLen: u32,
            szFileName: ?PWSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOpenStatus: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            fdwIndex: u32,
            pdwProperty: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFA,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFW,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatusWindowPos: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pptPos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVirtualKey: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            puVirtualKey: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEA: fn(
            self: *const IActiveIMMApp,
            szIMEFileName: ?PSTR,
            szLayoutText: ?PSTR,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEW: fn(
            self: *const IActiveIMMApp,
            szIMEFileName: ?PWSTR,
            szLayoutText: ?PWSTR,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIME: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageA: fn(
            self: *const IActiveIMMApp,
            hWndIME: ?HWND,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageW: fn(
            self: *const IActiveIMMApp,
            hWndIME: ?HWND,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyIME: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwAction: u32,
            dwIndex: u32,
            dwValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szRegister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseContext: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCandidateWindow: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pCandidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*anyopaque,
            dwCompLen: u32,
            pRead: ?*anyopaque,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*anyopaque,
            dwCompLen: u32,
            pRead: ?*anyopaque,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionWindow: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pCompForm: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConversionStatus: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            fdwConversion: u32,
            fdwSentence: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpenStatus: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            fOpen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatusWindowPos: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            pptPos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SimulateHotKey: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            dwHotKeyID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szUnregister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordW: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szUnregister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: fn(
            self: *const IActiveIMMApp,
            fRestoreLayout: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: fn(
            self: *const IActiveIMMApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDefWindowProc: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            Msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FilterClientWindows: fn(
            self: *const IActiveIMMApp,
            aaClassList: ?*u16,
            uSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageA: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            uCodePage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangId: fn(
            self: *const IActiveIMMApp,
            hKL: ?HKL,
            plid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateContextEx: fn(
            self: *const IActiveIMMApp,
            hWnd: ?HWND,
            hIMC: ?HIMC,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableIME: fn(
            self: *const IActiveIMMApp,
            idThread: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsA: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwFlags: u32,
            dwType: u32,
            pImeParentMenu: ?*IMEMENUITEMINFOA,
            pImeMenu: ?*IMEMENUITEMINFOA,
            dwSize: u32,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsW: fn(
            self: *const IActiveIMMApp,
            hIMC: ?HIMC,
            dwFlags: u32,
            dwType: u32,
            pImeParentMenu: ?*IMEMENUITEMINFOW,
            pImeMenu: ?*IMEMENUITEMINFOW,
            dwSize: u32,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumInputContext: fn(
            self: *const IActiveIMMApp,
            idThread: u32,
            ppEnum: ?*?*IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_AssociateContext(self: *const T, hWnd: ?HWND, hIME: ?HIMC, phPrev: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).AssociateContext(@ptrCast(*const IActiveIMMApp, self), hWnd, hIME, phPrev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_ConfigureIMEA(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).ConfigureIMEA(@ptrCast(*const IActiveIMMApp, self), hKL, hWnd, dwMode, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_ConfigureIMEW(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).ConfigureIMEW(@ptrCast(*const IActiveIMMApp, self), hKL, hWnd, dwMode, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_CreateContext(self: *const T, phIMC: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).CreateContext(@ptrCast(*const IActiveIMMApp, self), phIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_DestroyContext(self: *const T, hIME: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).DestroyContext(@ptrCast(*const IActiveIMMApp, self), hIME);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EnumRegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR, pData: ?*anyopaque, pEnum: ?*?*IEnumRegisterWordA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EnumRegisterWordA(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szRegister, pData, pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EnumRegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR, pData: ?*anyopaque, pEnum: ?*?*IEnumRegisterWordW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EnumRegisterWordW(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szRegister, pData, pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EscapeA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EscapeA(@ptrCast(*const IActiveIMMApp, self), hKL, hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EscapeW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EscapeW(@ptrCast(*const IActiveIMMApp, self), hKL, hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateListA(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateListA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, uBufLen, pCandList, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateListW(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateListW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, uBufLen, pCandList, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateListCountA(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateListCountA(@ptrCast(*const IActiveIMMApp, self), hIMC, pdwListSize, pdwBufLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateListCountW(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateListCountW(@ptrCast(*const IActiveIMMApp, self), hIMC, pdwListSize, pdwBufLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCandidateWindow(self: *const T, hIMC: ?HIMC, dwIndex: u32, pCandidate: ?*CANDIDATEFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCandidateWindow(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, pCandidate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionFontA(@ptrCast(*const IActiveIMMApp, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionFontW(@ptrCast(*const IActiveIMMApp, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionStringA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionStringW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCompositionWindow(@ptrCast(*const IActiveIMMApp, self), hIMC, pCompForm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetContext(self: *const T, hWnd: ?HWND, phIMC: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetContext(@ptrCast(*const IActiveIMMApp, self), hWnd, phIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetConversionListA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetConversionListA(@ptrCast(*const IActiveIMMApp, self), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetConversionListW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PWSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetConversionListW(@ptrCast(*const IActiveIMMApp, self), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetConversionStatus(self: *const T, hIMC: ?HIMC, pfdwConversion: ?*u32, pfdwSentence: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetConversionStatus(@ptrCast(*const IActiveIMMApp, self), hIMC, pfdwConversion, pfdwSentence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetDefaultIMEWnd(self: *const T, hWnd: ?HWND, phDefWnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetDefaultIMEWnd(@ptrCast(*const IActiveIMMApp, self), hWnd, phDefWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetDescriptionA(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetDescriptionA(@ptrCast(*const IActiveIMMApp, self), hKL, uBufLen, szDescription, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetDescriptionW(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PWSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetDescriptionW(@ptrCast(*const IActiveIMMApp, self), hKL, uBufLen, szDescription, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetGuideLineA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetGuideLineA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetGuideLineW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PWSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetGuideLineW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetIMEFileNameA(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetIMEFileNameA(@ptrCast(*const IActiveIMMApp, self), hKL, uBufLen, szFileName, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetIMEFileNameW(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PWSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetIMEFileNameW(@ptrCast(*const IActiveIMMApp, self), hKL, uBufLen, szFileName, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetOpenStatus(self: *const T, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetOpenStatus(@ptrCast(*const IActiveIMMApp, self), hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetProperty(self: *const T, hKL: ?HKL, fdwIndex: u32, pdwProperty: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetProperty(@ptrCast(*const IActiveIMMApp, self), hKL, fdwIndex, pdwProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetRegisterWordStyleA(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFA, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetRegisterWordStyleA(@ptrCast(*const IActiveIMMApp, self), hKL, nItem, pStyleBuf, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetRegisterWordStyleW(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFW, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetRegisterWordStyleW(@ptrCast(*const IActiveIMMApp, self), hKL, nItem, pStyleBuf, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetStatusWindowPos(@ptrCast(*const IActiveIMMApp, self), hIMC, pptPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetVirtualKey(self: *const T, hWnd: ?HWND, puVirtualKey: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetVirtualKey(@ptrCast(*const IActiveIMMApp, self), hWnd, puVirtualKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_InstallIMEA(self: *const T, szIMEFileName: ?PSTR, szLayoutText: ?PSTR, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).InstallIMEA(@ptrCast(*const IActiveIMMApp, self), szIMEFileName, szLayoutText, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_InstallIMEW(self: *const T, szIMEFileName: ?PWSTR, szLayoutText: ?PWSTR, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).InstallIMEW(@ptrCast(*const IActiveIMMApp, self), szIMEFileName, szLayoutText, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_IsIME(self: *const T, hKL: ?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).IsIME(@ptrCast(*const IActiveIMMApp, self), hKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_IsUIMessageA(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).IsUIMessageA(@ptrCast(*const IActiveIMMApp, self), hWndIME, msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_IsUIMessageW(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).IsUIMessageW(@ptrCast(*const IActiveIMMApp, self), hWndIME, msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_NotifyIME(self: *const T, hIMC: ?HIMC, dwAction: u32, dwIndex: u32, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).NotifyIME(@ptrCast(*const IActiveIMMApp, self), hIMC, dwAction, dwIndex, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_RegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).RegisterWordA(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_RegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).RegisterWordW(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_ReleaseContext(self: *const T, hWnd: ?HWND, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).ReleaseContext(@ptrCast(*const IActiveIMMApp, self), hWnd, hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCandidateWindow(self: *const T, hIMC: ?HIMC, pCandidate: ?*CANDIDATEFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCandidateWindow(@ptrCast(*const IActiveIMMApp, self), hIMC, pCandidate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionFontA(@ptrCast(*const IActiveIMMApp, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionFontW(@ptrCast(*const IActiveIMMApp, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionStringA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionStringW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetCompositionWindow(@ptrCast(*const IActiveIMMApp, self), hIMC, pCompForm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetConversionStatus(self: *const T, hIMC: ?HIMC, fdwConversion: u32, fdwSentence: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetConversionStatus(@ptrCast(*const IActiveIMMApp, self), hIMC, fdwConversion, fdwSentence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetOpenStatus(self: *const T, hIMC: ?HIMC, fOpen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetOpenStatus(@ptrCast(*const IActiveIMMApp, self), hIMC, fOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SetStatusWindowPos(@ptrCast(*const IActiveIMMApp, self), hIMC, pptPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_SimulateHotKey(self: *const T, hWnd: ?HWND, dwHotKeyID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).SimulateHotKey(@ptrCast(*const IActiveIMMApp, self), hWnd, dwHotKeyID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_UnregisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szUnregister: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).UnregisterWordA(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szUnregister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_UnregisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szUnregister: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).UnregisterWordW(@ptrCast(*const IActiveIMMApp, self), hKL, szReading, dwStyle, szUnregister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_Activate(self: *const T, fRestoreLayout: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).Activate(@ptrCast(*const IActiveIMMApp, self), fRestoreLayout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_Deactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).Deactivate(@ptrCast(*const IActiveIMMApp, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_OnDefWindowProc(self: *const T, hWnd: ?HWND, Msg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).OnDefWindowProc(@ptrCast(*const IActiveIMMApp, self), hWnd, Msg, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_FilterClientWindows(self: *const T, aaClassList: ?*u16, uSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).FilterClientWindows(@ptrCast(*const IActiveIMMApp, self), aaClassList, uSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetCodePageA(self: *const T, hKL: ?HKL, uCodePage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetCodePageA(@ptrCast(*const IActiveIMMApp, self), hKL, uCodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetLangId(self: *const T, hKL: ?HKL, plid: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetLangId(@ptrCast(*const IActiveIMMApp, self), hKL, plid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_AssociateContextEx(self: *const T, hWnd: ?HWND, hIMC: ?HIMC, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).AssociateContextEx(@ptrCast(*const IActiveIMMApp, self), hWnd, hIMC, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_DisableIME(self: *const T, idThread: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).DisableIME(@ptrCast(*const IActiveIMMApp, self), idThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetImeMenuItemsA(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOA, pImeMenu: ?*IMEMENUITEMINFOA, dwSize: u32, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetImeMenuItemsA(@ptrCast(*const IActiveIMMApp, self), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_GetImeMenuItemsW(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOW, pImeMenu: ?*IMEMENUITEMINFOW, dwSize: u32, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).GetImeMenuItemsW(@ptrCast(*const IActiveIMMApp, self), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMApp_EnumInputContext(self: *const T, idThread: u32, ppEnum: ?*?*IEnumInputContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMApp.VTable, self.vtable).EnumInputContext(@ptrCast(*const IActiveIMMApp, self), idThread, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIMMIME_Value = @import("../../zig.zig").Guid.initString("08c03411-f96b-11d0-a475-00aa006bcc59");
pub const IID_IActiveIMMIME = &IID_IActiveIMMIME_Value;
pub const IActiveIMMIME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateContext: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            hIME: ?HIMC,
            phPrev: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pData: ?*REGISTERWORDA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureIMEW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pData: ?*REGISTERWORDW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateContext: fn(
            self: *const IActiveIMMIME,
            phIMC: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyContext: fn(
            self: *const IActiveIMMIME,
            hIME: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szRegister: ?PSTR,
            pData: ?*anyopaque,
            pEnum: ?*?*IEnumRegisterWordA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWordW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
            pData: ?*anyopaque,
            pEnum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*anyopaque,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EscapeW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*anyopaque,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            uBufLen: u32,
            pCandList: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            uBufLen: u32,
            pCandList: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pdwListSize: ?*u32,
            pdwBufLen: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateListCountW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pdwListSize: ?*u32,
            pdwBufLen: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCandidateWindow: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            pCandidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionFontW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            plCopied: ?*i32,
            pBuf: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionStringW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            plCopied: ?*i32,
            pBuf: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionWindow: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pCompForm: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            phIMC: ?*?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hIMC: ?HIMC,
            pSrc: ?PSTR,
            uBufLen: u32,
            uFlag: u32,
            pDst: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionListW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            hIMC: ?HIMC,
            pSrc: ?PWSTR,
            uBufLen: u32,
            uFlag: u32,
            pDst: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionStatus: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pfdwConversion: ?*u32,
            pfdwSentence: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultIMEWnd: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            phDefWnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uBufLen: u32,
            szDescription: ?PSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uBufLen: u32,
            szDescription: ?PWSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            pBuf: ?PSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuideLineW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            dwBufLen: u32,
            pBuf: ?PWSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uBufLen: u32,
            szFileName: ?PSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMEFileNameW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uBufLen: u32,
            szFileName: ?PWSTR,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOpenStatus: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            fdwIndex: u32,
            pdwProperty: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFA,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyleW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFW,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatusWindowPos: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pptPos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVirtualKey: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            puVirtualKey: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEA: fn(
            self: *const IActiveIMMIME,
            szIMEFileName: ?PSTR,
            szLayoutText: ?PSTR,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallIMEW: fn(
            self: *const IActiveIMMIME,
            szIMEFileName: ?PWSTR,
            szLayoutText: ?PWSTR,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsIME: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageA: fn(
            self: *const IActiveIMMIME,
            hWndIME: ?HWND,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsUIMessageW: fn(
            self: *const IActiveIMMIME,
            hWndIME: ?HWND,
            msg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyIME: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwAction: u32,
            dwIndex: u32,
            dwValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szRegister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWordW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseContext: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCandidateWindow: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pCandidate: ?*CANDIDATEFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            plf: ?*LOGFONTA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionFontW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*anyopaque,
            dwCompLen: u32,
            pRead: ?*anyopaque,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionStringW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*anyopaque,
            dwCompLen: u32,
            pRead: ?*anyopaque,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionWindow: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pCompForm: ?*COMPOSITIONFORM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConversionStatus: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            fdwConversion: u32,
            fdwSentence: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpenStatus: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            fOpen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatusWindowPos: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pptPos: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SimulateHotKey: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            dwHotKeyID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PSTR,
            dwStyle: u32,
            szUnregister: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWordW: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            szReading: ?PWSTR,
            dwStyle: u32,
            szUnregister: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateMessage: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockIMC: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            ppIMC: ?*?*INPUTCONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockIMC: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMCLockCount: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            pdwLockCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateIMCC: fn(
            self: *const IActiveIMMIME,
            dwSize: u32,
            phIMCC: ?*?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyIMCC: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockIMCC: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockIMCC: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReSizeIMCC: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
            dwSize: u32,
            phIMCC: ?*?HIMCC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMCCSize: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
            pdwSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIMCCLockCount: fn(
            self: *const IActiveIMMIME,
            hIMCC: ?HIMCC,
            pdwLockCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHotKey: fn(
            self: *const IActiveIMMIME,
            dwHotKeyID: u32,
            puModifiers: ?*u32,
            puVKey: ?*u32,
            phKL: ?*?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHotKey: fn(
            self: *const IActiveIMMIME,
            dwHotKeyID: u32,
            uModifiers: u32,
            uVKey: u32,
            hKL: ?HKL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSoftKeyboard: fn(
            self: *const IActiveIMMIME,
            uType: u32,
            hOwner: ?HWND,
            x: i32,
            y: i32,
            phSoftKbdWnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroySoftKeyboard: fn(
            self: *const IActiveIMMIME,
            hSoftKbdWnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowSoftKeyboard: fn(
            self: *const IActiveIMMIME,
            hSoftKbdWnd: ?HWND,
            nCmdShow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageA: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            uCodePage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangId: fn(
            self: *const IActiveIMMIME,
            hKL: ?HKL,
            plid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeybdEvent: fn(
            self: *const IActiveIMMIME,
            lgidIME: u16,
            bVk: u8,
            bScan: u8,
            dwFlags: u32,
            dwExtraInfo: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockModal: fn(
            self: *const IActiveIMMIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockModal: fn(
            self: *const IActiveIMMIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateContextEx: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            hIMC: ?HIMC,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableIME: fn(
            self: *const IActiveIMMIME,
            idThread: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwFlags: u32,
            dwType: u32,
            pImeParentMenu: ?*IMEMENUITEMINFOA,
            pImeMenu: ?*IMEMENUITEMINFOA,
            dwSize: u32,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImeMenuItemsW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            dwFlags: u32,
            dwType: u32,
            pImeParentMenu: ?*IMEMENUITEMINFOW,
            pImeMenu: ?*IMEMENUITEMINFOW,
            dwSize: u32,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumInputContext: fn(
            self: *const IActiveIMMIME,
            idThread: u32,
            ppEnum: ?*?*IEnumInputContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestMessageA: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestMessageW: fn(
            self: *const IActiveIMMIME,
            hIMC: ?HIMC,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendIMCA: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendIMCW: fn(
            self: *const IActiveIMMIME,
            hWnd: ?HWND,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSleeping: fn(
            self: *const IActiveIMMIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_AssociateContext(self: *const T, hWnd: ?HWND, hIME: ?HIMC, phPrev: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).AssociateContext(@ptrCast(*const IActiveIMMIME, self), hWnd, hIME, phPrev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ConfigureIMEA(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ConfigureIMEA(@ptrCast(*const IActiveIMMIME, self), hKL, hWnd, dwMode, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ConfigureIMEW(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pData: ?*REGISTERWORDW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ConfigureIMEW(@ptrCast(*const IActiveIMMIME, self), hKL, hWnd, dwMode, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_CreateContext(self: *const T, phIMC: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).CreateContext(@ptrCast(*const IActiveIMMIME, self), phIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_DestroyContext(self: *const T, hIME: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).DestroyContext(@ptrCast(*const IActiveIMMIME, self), hIME);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EnumRegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR, pData: ?*anyopaque, pEnum: ?*?*IEnumRegisterWordA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EnumRegisterWordA(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szRegister, pData, pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EnumRegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR, pData: ?*anyopaque, pEnum: ?*?*IEnumRegisterWordW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EnumRegisterWordW(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szRegister, pData, pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EscapeA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EscapeA(@ptrCast(*const IActiveIMMIME, self), hKL, hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EscapeW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EscapeW(@ptrCast(*const IActiveIMMIME, self), hKL, hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateListA(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateListA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, uBufLen, pCandList, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateListW(self: *const T, hIMC: ?HIMC, dwIndex: u32, uBufLen: u32, pCandList: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateListW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, uBufLen, pCandList, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateListCountA(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateListCountA(@ptrCast(*const IActiveIMMIME, self), hIMC, pdwListSize, pdwBufLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateListCountW(self: *const T, hIMC: ?HIMC, pdwListSize: ?*u32, pdwBufLen: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateListCountW(@ptrCast(*const IActiveIMMIME, self), hIMC, pdwListSize, pdwBufLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCandidateWindow(self: *const T, hIMC: ?HIMC, dwIndex: u32, pCandidate: ?*CANDIDATEFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCandidateWindow(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, pCandidate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionFontA(@ptrCast(*const IActiveIMMIME, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionFontW(@ptrCast(*const IActiveIMMIME, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionStringA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, plCopied: ?*i32, pBuf: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionStringW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, dwBufLen, plCopied, pBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCompositionWindow(@ptrCast(*const IActiveIMMIME, self), hIMC, pCompForm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetContext(self: *const T, hWnd: ?HWND, phIMC: ?*?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetContext(@ptrCast(*const IActiveIMMIME, self), hWnd, phIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetConversionListA(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetConversionListA(@ptrCast(*const IActiveIMMIME, self), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetConversionListW(self: *const T, hKL: ?HKL, hIMC: ?HIMC, pSrc: ?PWSTR, uBufLen: u32, uFlag: u32, pDst: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetConversionListW(@ptrCast(*const IActiveIMMIME, self), hKL, hIMC, pSrc, uBufLen, uFlag, pDst, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetConversionStatus(self: *const T, hIMC: ?HIMC, pfdwConversion: ?*u32, pfdwSentence: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetConversionStatus(@ptrCast(*const IActiveIMMIME, self), hIMC, pfdwConversion, pfdwSentence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetDefaultIMEWnd(self: *const T, hWnd: ?HWND, phDefWnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetDefaultIMEWnd(@ptrCast(*const IActiveIMMIME, self), hWnd, phDefWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetDescriptionA(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetDescriptionA(@ptrCast(*const IActiveIMMIME, self), hKL, uBufLen, szDescription, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetDescriptionW(self: *const T, hKL: ?HKL, uBufLen: u32, szDescription: ?PWSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetDescriptionW(@ptrCast(*const IActiveIMMIME, self), hKL, uBufLen, szDescription, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetGuideLineA(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetGuideLineA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetGuideLineW(self: *const T, hIMC: ?HIMC, dwIndex: u32, dwBufLen: u32, pBuf: ?PWSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetGuideLineW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMEFileNameA(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMEFileNameA(@ptrCast(*const IActiveIMMIME, self), hKL, uBufLen, szFileName, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMEFileNameW(self: *const T, hKL: ?HKL, uBufLen: u32, szFileName: ?PWSTR, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMEFileNameW(@ptrCast(*const IActiveIMMIME, self), hKL, uBufLen, szFileName, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetOpenStatus(self: *const T, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetOpenStatus(@ptrCast(*const IActiveIMMIME, self), hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetProperty(self: *const T, hKL: ?HKL, fdwIndex: u32, pdwProperty: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetProperty(@ptrCast(*const IActiveIMMIME, self), hKL, fdwIndex, pdwProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetRegisterWordStyleA(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFA, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetRegisterWordStyleA(@ptrCast(*const IActiveIMMIME, self), hKL, nItem, pStyleBuf, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetRegisterWordStyleW(self: *const T, hKL: ?HKL, nItem: u32, pStyleBuf: ?*STYLEBUFW, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetRegisterWordStyleW(@ptrCast(*const IActiveIMMIME, self), hKL, nItem, pStyleBuf, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetStatusWindowPos(@ptrCast(*const IActiveIMMIME, self), hIMC, pptPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetVirtualKey(self: *const T, hWnd: ?HWND, puVirtualKey: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetVirtualKey(@ptrCast(*const IActiveIMMIME, self), hWnd, puVirtualKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_InstallIMEA(self: *const T, szIMEFileName: ?PSTR, szLayoutText: ?PSTR, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).InstallIMEA(@ptrCast(*const IActiveIMMIME, self), szIMEFileName, szLayoutText, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_InstallIMEW(self: *const T, szIMEFileName: ?PWSTR, szLayoutText: ?PWSTR, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).InstallIMEW(@ptrCast(*const IActiveIMMIME, self), szIMEFileName, szLayoutText, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_IsIME(self: *const T, hKL: ?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).IsIME(@ptrCast(*const IActiveIMMIME, self), hKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_IsUIMessageA(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).IsUIMessageA(@ptrCast(*const IActiveIMMIME, self), hWndIME, msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_IsUIMessageW(self: *const T, hWndIME: ?HWND, msg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).IsUIMessageW(@ptrCast(*const IActiveIMMIME, self), hWndIME, msg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_NotifyIME(self: *const T, hIMC: ?HIMC, dwAction: u32, dwIndex: u32, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).NotifyIME(@ptrCast(*const IActiveIMMIME, self), hIMC, dwAction, dwIndex, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_RegisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szRegister: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).RegisterWordA(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_RegisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).RegisterWordW(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ReleaseContext(self: *const T, hWnd: ?HWND, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ReleaseContext(@ptrCast(*const IActiveIMMIME, self), hWnd, hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCandidateWindow(self: *const T, hIMC: ?HIMC, pCandidate: ?*CANDIDATEFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCandidateWindow(@ptrCast(*const IActiveIMMIME, self), hIMC, pCandidate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionFontA(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionFontA(@ptrCast(*const IActiveIMMIME, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionFontW(self: *const T, hIMC: ?HIMC, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionFontW(@ptrCast(*const IActiveIMMIME, self), hIMC, plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionStringA(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionStringA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionStringW(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionStringW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetCompositionWindow(self: *const T, hIMC: ?HIMC, pCompForm: ?*COMPOSITIONFORM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetCompositionWindow(@ptrCast(*const IActiveIMMIME, self), hIMC, pCompForm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetConversionStatus(self: *const T, hIMC: ?HIMC, fdwConversion: u32, fdwSentence: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetConversionStatus(@ptrCast(*const IActiveIMMIME, self), hIMC, fdwConversion, fdwSentence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetOpenStatus(self: *const T, hIMC: ?HIMC, fOpen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetOpenStatus(@ptrCast(*const IActiveIMMIME, self), hIMC, fOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetStatusWindowPos(self: *const T, hIMC: ?HIMC, pptPos: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetStatusWindowPos(@ptrCast(*const IActiveIMMIME, self), hIMC, pptPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SimulateHotKey(self: *const T, hWnd: ?HWND, dwHotKeyID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SimulateHotKey(@ptrCast(*const IActiveIMMIME, self), hWnd, dwHotKeyID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnregisterWordA(self: *const T, hKL: ?HKL, szReading: ?PSTR, dwStyle: u32, szUnregister: ?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnregisterWordA(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szUnregister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnregisterWordW(self: *const T, hKL: ?HKL, szReading: ?PWSTR, dwStyle: u32, szUnregister: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnregisterWordW(@ptrCast(*const IActiveIMMIME, self), hKL, szReading, dwStyle, szUnregister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GenerateMessage(self: *const T, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GenerateMessage(@ptrCast(*const IActiveIMMIME, self), hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_LockIMC(self: *const T, hIMC: ?HIMC, ppIMC: ?*?*INPUTCONTEXT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).LockIMC(@ptrCast(*const IActiveIMMIME, self), hIMC, ppIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnlockIMC(self: *const T, hIMC: ?HIMC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnlockIMC(@ptrCast(*const IActiveIMMIME, self), hIMC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMCLockCount(self: *const T, hIMC: ?HIMC, pdwLockCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMCLockCount(@ptrCast(*const IActiveIMMIME, self), hIMC, pdwLockCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_CreateIMCC(self: *const T, dwSize: u32, phIMCC: ?*?HIMCC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).CreateIMCC(@ptrCast(*const IActiveIMMIME, self), dwSize, phIMCC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_DestroyIMCC(self: *const T, hIMCC: ?HIMCC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).DestroyIMCC(@ptrCast(*const IActiveIMMIME, self), hIMCC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_LockIMCC(self: *const T, hIMCC: ?HIMCC, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).LockIMCC(@ptrCast(*const IActiveIMMIME, self), hIMCC, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnlockIMCC(self: *const T, hIMCC: ?HIMCC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnlockIMCC(@ptrCast(*const IActiveIMMIME, self), hIMCC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ReSizeIMCC(self: *const T, hIMCC: ?HIMCC, dwSize: u32, phIMCC: ?*?HIMCC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ReSizeIMCC(@ptrCast(*const IActiveIMMIME, self), hIMCC, dwSize, phIMCC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMCCSize(self: *const T, hIMCC: ?HIMCC, pdwSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMCCSize(@ptrCast(*const IActiveIMMIME, self), hIMCC, pdwSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetIMCCLockCount(self: *const T, hIMCC: ?HIMCC, pdwLockCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetIMCCLockCount(@ptrCast(*const IActiveIMMIME, self), hIMCC, pdwLockCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetHotKey(self: *const T, dwHotKeyID: u32, puModifiers: ?*u32, puVKey: ?*u32, phKL: ?*?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetHotKey(@ptrCast(*const IActiveIMMIME, self), dwHotKeyID, puModifiers, puVKey, phKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SetHotKey(self: *const T, dwHotKeyID: u32, uModifiers: u32, uVKey: u32, hKL: ?HKL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SetHotKey(@ptrCast(*const IActiveIMMIME, self), dwHotKeyID, uModifiers, uVKey, hKL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_CreateSoftKeyboard(self: *const T, uType: u32, hOwner: ?HWND, x: i32, y: i32, phSoftKbdWnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).CreateSoftKeyboard(@ptrCast(*const IActiveIMMIME, self), uType, hOwner, x, y, phSoftKbdWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_DestroySoftKeyboard(self: *const T, hSoftKbdWnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).DestroySoftKeyboard(@ptrCast(*const IActiveIMMIME, self), hSoftKbdWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_ShowSoftKeyboard(self: *const T, hSoftKbdWnd: ?HWND, nCmdShow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).ShowSoftKeyboard(@ptrCast(*const IActiveIMMIME, self), hSoftKbdWnd, nCmdShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetCodePageA(self: *const T, hKL: ?HKL, uCodePage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetCodePageA(@ptrCast(*const IActiveIMMIME, self), hKL, uCodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetLangId(self: *const T, hKL: ?HKL, plid: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetLangId(@ptrCast(*const IActiveIMMIME, self), hKL, plid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_KeybdEvent(self: *const T, lgidIME: u16, bVk: u8, bScan: u8, dwFlags: u32, dwExtraInfo: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).KeybdEvent(@ptrCast(*const IActiveIMMIME, self), lgidIME, bVk, bScan, dwFlags, dwExtraInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_LockModal(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).LockModal(@ptrCast(*const IActiveIMMIME, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_UnlockModal(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).UnlockModal(@ptrCast(*const IActiveIMMIME, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_AssociateContextEx(self: *const T, hWnd: ?HWND, hIMC: ?HIMC, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).AssociateContextEx(@ptrCast(*const IActiveIMMIME, self), hWnd, hIMC, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_DisableIME(self: *const T, idThread: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).DisableIME(@ptrCast(*const IActiveIMMIME, self), idThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetImeMenuItemsA(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOA, pImeMenu: ?*IMEMENUITEMINFOA, dwSize: u32, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetImeMenuItemsA(@ptrCast(*const IActiveIMMIME, self), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_GetImeMenuItemsW(self: *const T, hIMC: ?HIMC, dwFlags: u32, dwType: u32, pImeParentMenu: ?*IMEMENUITEMINFOW, pImeMenu: ?*IMEMENUITEMINFOW, dwSize: u32, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).GetImeMenuItemsW(@ptrCast(*const IActiveIMMIME, self), hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_EnumInputContext(self: *const T, idThread: u32, ppEnum: ?*?*IEnumInputContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).EnumInputContext(@ptrCast(*const IActiveIMMIME, self), idThread, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_RequestMessageA(self: *const T, hIMC: ?HIMC, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).RequestMessageA(@ptrCast(*const IActiveIMMIME, self), hIMC, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_RequestMessageW(self: *const T, hIMC: ?HIMC, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).RequestMessageW(@ptrCast(*const IActiveIMMIME, self), hIMC, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SendIMCA(self: *const T, hWnd: ?HWND, uMsg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SendIMCA(@ptrCast(*const IActiveIMMIME, self), hWnd, uMsg, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_SendIMCW(self: *const T, hWnd: ?HWND, uMsg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).SendIMCW(@ptrCast(*const IActiveIMMIME, self), hWnd, uMsg, wParam, lParam, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIMMIME_IsSleeping(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIMMIME.VTable, self.vtable).IsSleeping(@ptrCast(*const IActiveIMMIME, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIME_Value = @import("../../zig.zig").Guid.initString("6fe20962-d077-11d0-8fe7-00aa006bcc59");
pub const IID_IActiveIME = &IID_IActiveIME_Value;
pub const IActiveIME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Inquire: fn(
            self: *const IActiveIME,
            dwSystemInfoFlags: u32,
            pIMEInfo: ?*IMEINFO,
            szWndClass: ?PWSTR,
            pdwPrivate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConversionList: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            szSource: ?PWSTR,
            uFlag: u32,
            uBufLen: u32,
            pDest: ?*CANDIDATELIST,
            puCopied: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Configure: fn(
            self: *const IActiveIME,
            hKL: ?HKL,
            hWnd: ?HWND,
            dwMode: u32,
            pRegisterWord: ?*REGISTERWORDW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Destroy: fn(
            self: *const IActiveIME,
            uReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Escape: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            uEscape: u32,
            pData: ?*anyopaque,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveContext: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            fFlag: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessKey: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            uVirKey: u32,
            lParam: u32,
            pbKeyState: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            dwAction: u32,
            dwIndex: u32,
            dwValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            fSelect: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionString: fn(
            self: *const IActiveIME,
            hIMC: ?HIMC,
            dwIndex: u32,
            pComp: ?*anyopaque,
            dwCompLen: u32,
            pRead: ?*anyopaque,
            dwReadLen: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ToAsciiEx: fn(
            self: *const IActiveIME,
            uVirKey: u32,
            uScanCode: u32,
            pbKeyState: ?*u8,
            fuState: u32,
            hIMC: ?HIMC,
            pdwTransBuf: ?*u32,
            puSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWord: fn(
            self: *const IActiveIME,
            szReading: ?PWSTR,
            dwStyle: u32,
            szString: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterWord: fn(
            self: *const IActiveIME,
            szReading: ?PWSTR,
            dwStyle: u32,
            szString: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegisterWordStyle: fn(
            self: *const IActiveIME,
            nItem: u32,
            pStyleBuf: ?*STYLEBUFW,
            puBufSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumRegisterWord: fn(
            self: *const IActiveIME,
            szReading: ?PWSTR,
            dwStyle: u32,
            szRegister: ?PWSTR,
            pData: ?*anyopaque,
            ppEnum: ?*?*IEnumRegisterWordW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePageA: fn(
            self: *const IActiveIME,
            uCodePage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLangId: fn(
            self: *const IActiveIME,
            plid: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Inquire(self: *const T, dwSystemInfoFlags: u32, pIMEInfo: ?*IMEINFO, szWndClass: ?PWSTR, pdwPrivate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Inquire(@ptrCast(*const IActiveIME, self), dwSystemInfoFlags, pIMEInfo, szWndClass, pdwPrivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_ConversionList(self: *const T, hIMC: ?HIMC, szSource: ?PWSTR, uFlag: u32, uBufLen: u32, pDest: ?*CANDIDATELIST, puCopied: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).ConversionList(@ptrCast(*const IActiveIME, self), hIMC, szSource, uFlag, uBufLen, pDest, puCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Configure(self: *const T, hKL: ?HKL, hWnd: ?HWND, dwMode: u32, pRegisterWord: ?*REGISTERWORDW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Configure(@ptrCast(*const IActiveIME, self), hKL, hWnd, dwMode, pRegisterWord);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Destroy(self: *const T, uReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Destroy(@ptrCast(*const IActiveIME, self), uReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Escape(self: *const T, hIMC: ?HIMC, uEscape: u32, pData: ?*anyopaque, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Escape(@ptrCast(*const IActiveIME, self), hIMC, uEscape, pData, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_SetActiveContext(self: *const T, hIMC: ?HIMC, fFlag: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).SetActiveContext(@ptrCast(*const IActiveIME, self), hIMC, fFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_ProcessKey(self: *const T, hIMC: ?HIMC, uVirKey: u32, lParam: u32, pbKeyState: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).ProcessKey(@ptrCast(*const IActiveIME, self), hIMC, uVirKey, lParam, pbKeyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Notify(self: *const T, hIMC: ?HIMC, dwAction: u32, dwIndex: u32, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Notify(@ptrCast(*const IActiveIME, self), hIMC, dwAction, dwIndex, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_Select(self: *const T, hIMC: ?HIMC, fSelect: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).Select(@ptrCast(*const IActiveIME, self), hIMC, fSelect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_SetCompositionString(self: *const T, hIMC: ?HIMC, dwIndex: u32, pComp: ?*anyopaque, dwCompLen: u32, pRead: ?*anyopaque, dwReadLen: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).SetCompositionString(@ptrCast(*const IActiveIME, self), hIMC, dwIndex, pComp, dwCompLen, pRead, dwReadLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_ToAsciiEx(self: *const T, uVirKey: u32, uScanCode: u32, pbKeyState: ?*u8, fuState: u32, hIMC: ?HIMC, pdwTransBuf: ?*u32, puSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).ToAsciiEx(@ptrCast(*const IActiveIME, self), uVirKey, uScanCode, pbKeyState, fuState, hIMC, pdwTransBuf, puSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_RegisterWord(self: *const T, szReading: ?PWSTR, dwStyle: u32, szString: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).RegisterWord(@ptrCast(*const IActiveIME, self), szReading, dwStyle, szString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_UnregisterWord(self: *const T, szReading: ?PWSTR, dwStyle: u32, szString: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).UnregisterWord(@ptrCast(*const IActiveIME, self), szReading, dwStyle, szString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_GetRegisterWordStyle(self: *const T, nItem: u32, pStyleBuf: ?*STYLEBUFW, puBufSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).GetRegisterWordStyle(@ptrCast(*const IActiveIME, self), nItem, pStyleBuf, puBufSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_EnumRegisterWord(self: *const T, szReading: ?PWSTR, dwStyle: u32, szRegister: ?PWSTR, pData: ?*anyopaque, ppEnum: ?*?*IEnumRegisterWordW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).EnumRegisterWord(@ptrCast(*const IActiveIME, self), szReading, dwStyle, szRegister, pData, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_GetCodePageA(self: *const T, uCodePage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).GetCodePageA(@ptrCast(*const IActiveIME, self), uCodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME_GetLangId(self: *const T, plid: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME.VTable, self.vtable).GetLangId(@ptrCast(*const IActiveIME, self), plid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveIME2_Value = @import("../../zig.zig").Guid.initString("e1c4bf0e-2d53-11d2-93e1-0060b067b86e");
pub const IID_IActiveIME2 = &IID_IActiveIME2_Value;
pub const IActiveIME2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveIME.VTable,
        Sleep: fn(
            self: *const IActiveIME2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unsleep: fn(
            self: *const IActiveIME2,
            fDead: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveIME.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME2_Sleep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME2.VTable, self.vtable).Sleep(@ptrCast(*const IActiveIME2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveIME2_Unsleep(self: *const T, fDead: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveIME2.VTable, self.vtable).Unsleep(@ptrCast(*const IActiveIME2, self), fDead);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (82)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmInstallIMEA(
    lpszIMEFileName: ?[*:0]const u8,
    lpszLayoutText: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HKL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmInstallIMEW(
    lpszIMEFileName: ?[*:0]const u16,
    lpszLayoutText: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?HKL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetDefaultIMEWnd(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetDescriptionA(
    param0: ?HKL,
    lpszDescription: ?[*:0]u8,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetDescriptionW(
    param0: ?HKL,
    lpszDescription: ?[*:0]u16,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetIMEFileNameA(
    param0: ?HKL,
    lpszFileName: ?[*:0]u8,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetIMEFileNameW(
    param0: ?HKL,
    lpszFileName: ?[*:0]u16,
    uBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetProperty(
    param0: ?HKL,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmIsIME(
    param0: ?HKL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSimulateHotKey(
    param0: ?HWND,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmCreateContext(
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmDestroyContext(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetContext(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmReleaseContext(
    param0: ?HWND,
    param1: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmAssociateContext(
    param0: ?HWND,
    param1: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) ?HIMC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmAssociateContextEx(
    param0: ?HWND,
    param1: ?HIMC,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionStringA(
    param0: ?HIMC,
    param1: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?*anyopaque,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionStringW(
    param0: ?HIMC,
    param1: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?*anyopaque,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionStringA(
    param0: ?HIMC,
    dwIndex: SET_COMPOSITION_STRING_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpComp: ?*anyopaque,
    dwCompLen: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpRead: ?*anyopaque,
    dwReadLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionStringW(
    param0: ?HIMC,
    dwIndex: SET_COMPOSITION_STRING_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpComp: ?*anyopaque,
    dwCompLen: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpRead: ?*anyopaque,
    dwReadLen: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateListCountA(
    param0: ?HIMC,
    lpdwListCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateListCountW(
    param0: ?HIMC,
    lpdwListCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateListA(
    param0: ?HIMC,
    deIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpCandList: ?*CANDIDATELIST,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateListW(
    param0: ?HIMC,
    deIndex: u32,
    // TODO: what to do with BytesParamIndex 3?
    lpCandList: ?*CANDIDATELIST,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetGuideLineA(
    param0: ?HIMC,
    dwIndex: GET_GUIDE_LINE_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?PSTR,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetGuideLineW(
    param0: ?HIMC,
    dwIndex: GET_GUIDE_LINE_TYPE,
    // TODO: what to do with BytesParamIndex 3?
    lpBuf: ?PWSTR,
    dwBufLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetConversionStatus(
    param0: ?HIMC,
    lpfdwConversion: ?*u32,
    lpfdwSentence: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetConversionStatus(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetOpenStatus(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetOpenStatus(
    param0: ?HIMC,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionFontA(
    param0: ?HIMC,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionFontW(
    param0: ?HIMC,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionFontA(
    param0: ?HIMC,
    lplf: ?*LOGFONTA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionFontW(
    param0: ?HIMC,
    lplf: ?*LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmConfigureIMEA(
    param0: ?HKL,
    param1: ?HWND,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmConfigureIMEW(
    param0: ?HKL,
    param1: ?HWND,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEscapeA(
    param0: ?HKL,
    param1: ?HIMC,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEscapeW(
    param0: ?HKL,
    param1: ?HIMC,
    param2: u32,
    param3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetConversionListA(
    param0: ?HKL,
    param1: ?HIMC,
    lpSrc: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    lpDst: ?*CANDIDATELIST,
    dwBufLen: u32,
    uFlag: GET_CONVERSION_LIST_FLAG,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetConversionListW(
    param0: ?HKL,
    param1: ?HIMC,
    lpSrc: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    lpDst: ?*CANDIDATELIST,
    dwBufLen: u32,
    uFlag: GET_CONVERSION_LIST_FLAG,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmNotifyIME(
    param0: ?HIMC,
    dwAction: NOTIFY_IME_ACTION,
    dwIndex: NOTIFY_IME_INDEX,
    dwValue: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetStatusWindowPos(
    param0: ?HIMC,
    lpptPos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetStatusWindowPos(
    param0: ?HIMC,
    lpptPos: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCompositionWindow(
    param0: ?HIMC,
    lpCompForm: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCompositionWindow(
    param0: ?HIMC,
    lpCompForm: ?*COMPOSITIONFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetCandidateWindow(
    param0: ?HIMC,
    param1: u32,
    lpCandidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmSetCandidateWindow(
    param0: ?HIMC,
    lpCandidate: ?*CANDIDATEFORM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmIsUIMessageA(
    param0: ?HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmIsUIMessageW(
    param0: ?HWND,
    param1: u32,
    param2: WPARAM,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetVirtualKey(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmRegisterWordA(
    param0: ?HKL,
    lpszReading: ?[*:0]const u8,
    param2: u32,
    lpszRegister: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmRegisterWordW(
    param0: ?HKL,
    lpszReading: ?[*:0]const u16,
    param2: u32,
    lpszRegister: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmUnregisterWordA(
    param0: ?HKL,
    lpszReading: ?[*:0]const u8,
    param2: u32,
    lpszUnregister: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmUnregisterWordW(
    param0: ?HKL,
    lpszReading: ?[*:0]const u16,
    param2: u32,
    lpszUnregister: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetRegisterWordStyleA(
    param0: ?HKL,
    nItem: u32,
    lpStyleBuf: [*]STYLEBUFA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetRegisterWordStyleW(
    param0: ?HKL,
    nItem: u32,
    lpStyleBuf: [*]STYLEBUFW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEnumRegisterWordA(
    param0: ?HKL,
    param1: ?REGISTERWORDENUMPROCA,
    lpszReading: ?[*:0]const u8,
    param3: u32,
    lpszRegister: ?[*:0]const u8,
    param5: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEnumRegisterWordW(
    param0: ?HKL,
    param1: ?REGISTERWORDENUMPROCW,
    lpszReading: ?[*:0]const u16,
    param3: u32,
    lpszRegister: ?[*:0]const u16,
    param5: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmDisableIME(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmEnumInputContext(
    idThread: u32,
    lpfn: ?IMCENUMPROC,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetImeMenuItemsA(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
    lpImeParentMenu: ?*IMEMENUITEMINFOA,
    // TODO: what to do with BytesParamIndex 5?
    lpImeMenu: ?*IMEMENUITEMINFOA,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmGetImeMenuItemsW(
    param0: ?HIMC,
    param1: u32,
    param2: u32,
    lpImeParentMenu: ?*IMEMENUITEMINFOW,
    // TODO: what to do with BytesParamIndex 5?
    lpImeMenu: ?*IMEMENUITEMINFOW,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmDisableTextFrameService(
    idThread: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "IMM32" fn ImmDisableLegacyIME(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmGetHotKey(
    param0: u32,
    lpuModifiers: ?*u32,
    lpuVKey: ?*u32,
    phKL: ?*isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmSetHotKey(
    param0: u32,
    param1: u32,
    param2: u32,
    param3: ?HKL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmGenerateMessage(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmRequestMessageA(
    param0: ?HIMC,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IMM32" fn ImmRequestMessageW(
    param0: ?HIMC,
    param1: WPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "IMM32" fn ImmCreateSoftKeyboard(
    param0: u32,
    param1: ?HWND,
    param2: i32,
    param3: i32,
) callconv(@import("std").os.windows.WINAPI) ?HWND;

pub extern "IMM32" fn ImmDestroySoftKeyboard(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmShowSoftKeyboard(
    param0: ?HWND,
    param1: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmLockIMC(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) ?*INPUTCONTEXT;

pub extern "IMM32" fn ImmUnlockIMC(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmGetIMCLockCount(
    param0: ?HIMC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IMM32" fn ImmCreateIMCC(
    param0: u32,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "IMM32" fn ImmDestroyIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "IMM32" fn ImmLockIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "IMM32" fn ImmUnlockIMCC(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IMM32" fn ImmGetIMCCLockCount(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IMM32" fn ImmReSizeIMCC(
    param0: ?HIMCC,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) ?HIMCC;

pub extern "IMM32" fn ImmGetIMCCSize(
    param0: ?HIMCC,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (25)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const REGISTERWORD = thismodule.REGISTERWORDA;
        pub const STYLEBUF = thismodule.STYLEBUFA;
        pub const IMEMENUITEMINFO = thismodule.IMEMENUITEMINFOA;
        pub const REGISTERWORDENUMPROC = thismodule.REGISTERWORDENUMPROCA;
        pub const IEnumRegisterWord = thismodule.IEnumRegisterWordA;
        pub const ImmInstallIME = thismodule.ImmInstallIMEA;
        pub const ImmGetDescription = thismodule.ImmGetDescriptionA;
        pub const ImmGetIMEFileName = thismodule.ImmGetIMEFileNameA;
        pub const ImmGetCompositionString = thismodule.ImmGetCompositionStringA;
        pub const ImmSetCompositionString = thismodule.ImmSetCompositionStringA;
        pub const ImmGetCandidateListCount = thismodule.ImmGetCandidateListCountA;
        pub const ImmGetCandidateList = thismodule.ImmGetCandidateListA;
        pub const ImmGetGuideLine = thismodule.ImmGetGuideLineA;
        pub const ImmGetCompositionFont = thismodule.ImmGetCompositionFontA;
        pub const ImmSetCompositionFont = thismodule.ImmSetCompositionFontA;
        pub const ImmConfigureIME = thismodule.ImmConfigureIMEA;
        pub const ImmEscape = thismodule.ImmEscapeA;
        pub const ImmGetConversionList = thismodule.ImmGetConversionListA;
        pub const ImmIsUIMessage = thismodule.ImmIsUIMessageA;
        pub const ImmRegisterWord = thismodule.ImmRegisterWordA;
        pub const ImmUnregisterWord = thismodule.ImmUnregisterWordA;
        pub const ImmGetRegisterWordStyle = thismodule.ImmGetRegisterWordStyleA;
        pub const ImmEnumRegisterWord = thismodule.ImmEnumRegisterWordA;
        pub const ImmGetImeMenuItems = thismodule.ImmGetImeMenuItemsA;
        pub const ImmRequestMessage = thismodule.ImmRequestMessageA;
    },
    .wide => struct {
        pub const REGISTERWORD = thismodule.REGISTERWORDW;
        pub const STYLEBUF = thismodule.STYLEBUFW;
        pub const IMEMENUITEMINFO = thismodule.IMEMENUITEMINFOW;
        pub const REGISTERWORDENUMPROC = thismodule.REGISTERWORDENUMPROCW;
        pub const IEnumRegisterWord = thismodule.IEnumRegisterWordW;
        pub const ImmInstallIME = thismodule.ImmInstallIMEW;
        pub const ImmGetDescription = thismodule.ImmGetDescriptionW;
        pub const ImmGetIMEFileName = thismodule.ImmGetIMEFileNameW;
        pub const ImmGetCompositionString = thismodule.ImmGetCompositionStringW;
        pub const ImmSetCompositionString = thismodule.ImmSetCompositionStringW;
        pub const ImmGetCandidateListCount = thismodule.ImmGetCandidateListCountW;
        pub const ImmGetCandidateList = thismodule.ImmGetCandidateListW;
        pub const ImmGetGuideLine = thismodule.ImmGetGuideLineW;
        pub const ImmGetCompositionFont = thismodule.ImmGetCompositionFontW;
        pub const ImmSetCompositionFont = thismodule.ImmSetCompositionFontW;
        pub const ImmConfigureIME = thismodule.ImmConfigureIMEW;
        pub const ImmEscape = thismodule.ImmEscapeW;
        pub const ImmGetConversionList = thismodule.ImmGetConversionListW;
        pub const ImmIsUIMessage = thismodule.ImmIsUIMessageW;
        pub const ImmRegisterWord = thismodule.ImmRegisterWordW;
        pub const ImmUnregisterWord = thismodule.ImmUnregisterWordW;
        pub const ImmGetRegisterWordStyle = thismodule.ImmGetRegisterWordStyleW;
        pub const ImmEnumRegisterWord = thismodule.ImmEnumRegisterWordW;
        pub const ImmGetImeMenuItems = thismodule.ImmGetImeMenuItemsW;
        pub const ImmRequestMessage = thismodule.ImmRequestMessageW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const REGISTERWORD = *opaque{};
        pub const STYLEBUF = *opaque{};
        pub const IMEMENUITEMINFO = *opaque{};
        pub const REGISTERWORDENUMPROC = *opaque{};
        pub const IEnumRegisterWord = *opaque{};
        pub const ImmInstallIME = *opaque{};
        pub const ImmGetDescription = *opaque{};
        pub const ImmGetIMEFileName = *opaque{};
        pub const ImmGetCompositionString = *opaque{};
        pub const ImmSetCompositionString = *opaque{};
        pub const ImmGetCandidateListCount = *opaque{};
        pub const ImmGetCandidateList = *opaque{};
        pub const ImmGetGuideLine = *opaque{};
        pub const ImmGetCompositionFont = *opaque{};
        pub const ImmSetCompositionFont = *opaque{};
        pub const ImmConfigureIME = *opaque{};
        pub const ImmEscape = *opaque{};
        pub const ImmGetConversionList = *opaque{};
        pub const ImmIsUIMessage = *opaque{};
        pub const ImmRegisterWord = *opaque{};
        pub const ImmUnregisterWord = *opaque{};
        pub const ImmGetRegisterWordStyle = *opaque{};
        pub const ImmEnumRegisterWord = *opaque{};
        pub const ImmGetImeMenuItems = *opaque{};
        pub const ImmRequestMessage = *opaque{};
    } else struct {
        pub const REGISTERWORD = @compileError("'REGISTERWORD' requires that UNICODE be set to true or false in the root module");
        pub const STYLEBUF = @compileError("'STYLEBUF' requires that UNICODE be set to true or false in the root module");
        pub const IMEMENUITEMINFO = @compileError("'IMEMENUITEMINFO' requires that UNICODE be set to true or false in the root module");
        pub const REGISTERWORDENUMPROC = @compileError("'REGISTERWORDENUMPROC' requires that UNICODE be set to true or false in the root module");
        pub const IEnumRegisterWord = @compileError("'IEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmInstallIME = @compileError("'ImmInstallIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetDescription = @compileError("'ImmGetDescription' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetIMEFileName = @compileError("'ImmGetIMEFileName' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionString = @compileError("'ImmGetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionString = @compileError("'ImmSetCompositionString' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateListCount = @compileError("'ImmGetCandidateListCount' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCandidateList = @compileError("'ImmGetCandidateList' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetGuideLine = @compileError("'ImmGetGuideLine' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetCompositionFont = @compileError("'ImmGetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmSetCompositionFont = @compileError("'ImmSetCompositionFont' requires that UNICODE be set to true or false in the root module");
        pub const ImmConfigureIME = @compileError("'ImmConfigureIME' requires that UNICODE be set to true or false in the root module");
        pub const ImmEscape = @compileError("'ImmEscape' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetConversionList = @compileError("'ImmGetConversionList' requires that UNICODE be set to true or false in the root module");
        pub const ImmIsUIMessage = @compileError("'ImmIsUIMessage' requires that UNICODE be set to true or false in the root module");
        pub const ImmRegisterWord = @compileError("'ImmRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmUnregisterWord = @compileError("'ImmUnregisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetRegisterWordStyle = @compileError("'ImmGetRegisterWordStyle' requires that UNICODE be set to true or false in the root module");
        pub const ImmEnumRegisterWord = @compileError("'ImmEnumRegisterWord' requires that UNICODE be set to true or false in the root module");
        pub const ImmGetImeMenuItems = @compileError("'ImmGetImeMenuItems' requires that UNICODE be set to true or false in the root module");
        pub const ImmRequestMessage = @compileError("'ImmRequestMessage' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (24)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BSTR = @import("../../foundation.zig").BSTR;
const CHAR = @import("../../foundation.zig").CHAR;
const HBITMAP = @import("../../graphics/gdi.zig").HBITMAP;
const HICON = @import("../../ui/windows_and_messaging.zig").HICON;
const HIMC = @import("../../globalization.zig").HIMC;
const HIMCC = @import("../../globalization.zig").HIMCC;
const HKL = @import("../../ui/text_services.zig").HKL;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IClassFactory = @import("../../system/com.zig").IClassFactory;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LOGFONTA = @import("../../graphics/gdi.zig").LOGFONTA;
const LOGFONTW = @import("../../graphics/gdi.zig").LOGFONTW;
const LPARAM = @import("../../foundation.zig").LPARAM;
const LRESULT = @import("../../foundation.zig").LRESULT;
const MSG = @import("../../ui/windows_and_messaging.zig").MSG;
const POINT = @import("../../foundation.zig").POINT;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const RECT = @import("../../foundation.zig").RECT;
const SAFEARRAY = @import("../../system/com.zig").SAFEARRAY;
const WPARAM = @import("../../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "IMCENUMPROC")) { _ = IMCENUMPROC; }
    if (@hasDecl(@This(), "REGISTERWORDENUMPROCA")) { _ = REGISTERWORDENUMPROCA; }
    if (@hasDecl(@This(), "REGISTERWORDENUMPROCW")) { _ = REGISTERWORDENUMPROCW; }
    if (@hasDecl(@This(), "PFNLOG")) { _ = PFNLOG; }
    if (@hasDecl(@This(), "fpCreateIFECommonInstanceType")) { _ = fpCreateIFECommonInstanceType; }
    if (@hasDecl(@This(), "fpCreateIFELanguageInstanceType")) { _ = fpCreateIFELanguageInstanceType; }
    if (@hasDecl(@This(), "fpCreateIFEDictionaryInstanceType")) { _ = fpCreateIFEDictionaryInstanceType; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
