//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1580)
//--------------------------------------------------------------------------------
pub const HLINK_E_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221248));
pub const HLINK_S_FIRST = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262400));
pub const WM_CPL_LAUNCH = @as(u32, 2024);
pub const WM_CPL_LAUNCHED = @as(u32, 2025);
pub const CPL_DYNAMIC_RES = @as(u32, 0);
pub const CPL_INIT = @as(u32, 1);
pub const CPL_GETCOUNT = @as(u32, 2);
pub const CPL_INQUIRE = @as(u32, 3);
pub const CPL_SELECT = @as(u32, 4);
pub const CPL_DBLCLK = @as(u32, 5);
pub const CPL_STOP = @as(u32, 6);
pub const CPL_EXIT = @as(u32, 7);
pub const CPL_NEWINQUIRE = @as(u32, 8);
pub const CPL_STARTWPARMSA = @as(u32, 9);
pub const CPL_STARTWPARMSW = @as(u32, 10);
pub const CPL_STARTWPARMS = @as(u32, 10);
pub const CPL_SETUP = @as(u32, 200);
pub const HLINK_S_DONTHIDE = @as(i32, 262400);
pub const FOLDERID_NetworkFolder = Guid.initString("d20beec4-5ca8-4905-ae3b-bf251ea09b53");
pub const FOLDERID_ComputerFolder = Guid.initString("0ac0837c-bbf8-452a-850d-79d08e667ca7");
pub const FOLDERID_InternetFolder = Guid.initString("4d9f7874-4e0c-4904-967b-40b0d20c3e4b");
pub const FOLDERID_ControlPanelFolder = Guid.initString("82a74aeb-aeb4-465c-a014-d097ee346d63");
pub const FOLDERID_PrintersFolder = Guid.initString("76fc4e2d-d6ad-4519-a663-37bd56068185");
pub const FOLDERID_SyncManagerFolder = Guid.initString("43668bf8-c14e-49b2-97c9-747784d784b7");
pub const FOLDERID_SyncSetupFolder = Guid.initString("0f214138-b1d3-4a90-bba9-27cbc0c5389a");
pub const FOLDERID_ConflictFolder = Guid.initString("4bfefb45-347d-4006-a5be-ac0cb0567192");
pub const FOLDERID_SyncResultsFolder = Guid.initString("289a9a43-be44-4057-a41b-587a76d7e7f9");
pub const FOLDERID_RecycleBinFolder = Guid.initString("b7534046-3ecb-4c18-be4e-64cd4cb7d6ac");
pub const FOLDERID_ConnectionsFolder = Guid.initString("6f0cd92b-2e97-45d1-88ff-b0d186b8dedd");
pub const FOLDERID_Fonts = Guid.initString("fd228cb7-ae11-4ae3-864c-16f3910ab8fe");
pub const FOLDERID_Desktop = Guid.initString("b4bfcc3a-db2c-424c-b029-7fe99a87c641");
pub const FOLDERID_Startup = Guid.initString("b97d20bb-f46a-4c97-ba10-5e3608430854");
pub const FOLDERID_Programs = Guid.initString("a77f5d77-2e2b-44c3-a6a2-aba601054a51");
pub const FOLDERID_StartMenu = Guid.initString("625b53c3-ab48-4ec1-ba1f-a1ef4146fc19");
pub const FOLDERID_Recent = Guid.initString("ae50c081-ebd2-438a-8655-8a092e34987a");
pub const FOLDERID_SendTo = Guid.initString("8983036c-27c0-404b-8f08-102d10dcfd74");
pub const FOLDERID_Documents = Guid.initString("fdd39ad0-238f-46af-adb4-6c85480369c7");
pub const FOLDERID_Favorites = Guid.initString("1777f761-68ad-4d8a-87bd-30b759fa33dd");
pub const FOLDERID_NetHood = Guid.initString("c5abbf53-e17f-4121-8900-86626fc2c973");
pub const FOLDERID_PrintHood = Guid.initString("9274bd8d-cfd1-41c3-b35e-b13f55a758f4");
pub const FOLDERID_Templates = Guid.initString("a63293e8-664e-48db-a079-df759e0509f7");
pub const FOLDERID_CommonStartup = Guid.initString("82a5ea35-d9cd-47c5-9629-e15d2f714e6e");
pub const FOLDERID_CommonPrograms = Guid.initString("0139d44e-6afe-49f2-8690-3dafcae6ffb8");
pub const FOLDERID_CommonStartMenu = Guid.initString("a4115719-d62e-491d-aa7c-e74b8be3b067");
pub const FOLDERID_PublicDesktop = Guid.initString("c4aa340d-f20f-4863-afef-f87ef2e6ba25");
pub const FOLDERID_ProgramData = Guid.initString("62ab5d82-fdc1-4dc3-a9dd-070d1d495d97");
pub const FOLDERID_CommonTemplates = Guid.initString("b94237e7-57ac-4347-9151-b08c6c32d1f7");
pub const FOLDERID_PublicDocuments = Guid.initString("ed4824af-dce4-45a8-81e2-fc7965083634");
pub const FOLDERID_RoamingAppData = Guid.initString("3eb685db-65f9-4cf6-a03a-e3ef65729f3d");
pub const FOLDERID_LocalAppData = Guid.initString("f1b32785-6fba-4fcf-9d55-7b8e7f157091");
pub const FOLDERID_LocalAppDataLow = Guid.initString("a520a1a4-1780-4ff6-bd18-167343c5af16");
pub const FOLDERID_InternetCache = Guid.initString("352481e8-33be-4251-ba85-6007caedcf9d");
pub const FOLDERID_Cookies = Guid.initString("2b0f765d-c0e9-4171-908e-08a611b84ff6");
pub const FOLDERID_History = Guid.initString("d9dc8a3b-b784-432e-a781-5a1130a75963");
pub const FOLDERID_System = Guid.initString("1ac14e77-02e7-4e5d-b744-2eb1ae5198b7");
pub const FOLDERID_SystemX86 = Guid.initString("d65231b0-b2f1-4857-a4ce-a8e7c6ea7d27");
pub const FOLDERID_Windows = Guid.initString("f38bf404-1d43-42f2-9305-67de0b28fc23");
pub const FOLDERID_Profile = Guid.initString("5e6c858f-0e22-4760-9afe-ea3317b67173");
pub const FOLDERID_Pictures = Guid.initString("33e28130-4e1e-4676-835a-98395c3bc3bb");
pub const FOLDERID_ProgramFilesX86 = Guid.initString("7c5a40ef-a0fb-4bfc-874a-c0f2e0b9fa8e");
pub const FOLDERID_ProgramFilesCommonX86 = Guid.initString("de974d24-d9c6-4d3e-bf91-f4455120b917");
pub const FOLDERID_ProgramFilesX64 = Guid.initString("6d809377-6af0-444b-8957-a3773f02200e");
pub const FOLDERID_ProgramFilesCommonX64 = Guid.initString("6365d5a7-0f0d-45e5-87f6-0da56b6a4f7d");
pub const FOLDERID_ProgramFiles = Guid.initString("905e63b6-c1bf-494e-b29c-65b732d3d21a");
pub const FOLDERID_ProgramFilesCommon = Guid.initString("f7f1ed05-9f6d-47a2-aaae-29d317c6f066");
pub const FOLDERID_UserProgramFiles = Guid.initString("5cd7aee2-2219-4a67-b85d-6c9ce15660cb");
pub const FOLDERID_UserProgramFilesCommon = Guid.initString("bcbd3057-ca5c-4622-b42d-bc56db0ae516");
pub const FOLDERID_AdminTools = Guid.initString("724ef170-a42d-4fef-9f26-b60e846fba4f");
pub const FOLDERID_CommonAdminTools = Guid.initString("d0384e7d-bac3-4797-8f14-cba229b392b5");
pub const FOLDERID_Music = Guid.initString("4bd8d571-6d19-48d3-be97-422220080e43");
pub const FOLDERID_Videos = Guid.initString("18989b1d-99b5-455b-841c-ab7c74e4ddfc");
pub const FOLDERID_Ringtones = Guid.initString("c870044b-f49e-4126-a9c3-b52a1ff411e8");
pub const FOLDERID_PublicPictures = Guid.initString("b6ebfb86-6907-413c-9af7-4fc2abf07cc5");
pub const FOLDERID_PublicMusic = Guid.initString("3214fab5-9757-4298-bb61-92a9deaa44ff");
pub const FOLDERID_PublicVideos = Guid.initString("2400183a-6185-49fb-a2d8-4a392a602ba3");
pub const FOLDERID_PublicRingtones = Guid.initString("e555ab60-153b-4d17-9f04-a5fe99fc15ec");
pub const FOLDERID_ResourceDir = Guid.initString("8ad10c31-2adb-4296-a8f7-e4701232c972");
pub const FOLDERID_LocalizedResourcesDir = Guid.initString("2a00375e-224c-49de-b8d1-440df7ef3ddc");
pub const FOLDERID_CommonOEMLinks = Guid.initString("c1bae2d0-10df-4334-bedd-7aa20b227a9d");
pub const FOLDERID_CDBurning = Guid.initString("9e52ab10-f80d-49df-acb8-4330f5687855");
pub const FOLDERID_UserProfiles = Guid.initString("0762d272-c50a-4bb0-a382-697dcd729b80");
pub const FOLDERID_Playlists = Guid.initString("de92c1c7-837f-4f69-a3bb-86e631204a23");
pub const FOLDERID_SamplePlaylists = Guid.initString("15ca69b3-30ee-49c1-ace1-6b5ec372afb5");
pub const FOLDERID_SampleMusic = Guid.initString("b250c668-f57d-4ee1-a63c-290ee7d1aa1f");
pub const FOLDERID_SamplePictures = Guid.initString("c4900540-2379-4c75-844b-64e6faf8716b");
pub const FOLDERID_SampleVideos = Guid.initString("859ead94-2e85-48ad-a71a-0969cb56a6cd");
pub const FOLDERID_PhotoAlbums = Guid.initString("69d2cf90-fc33-4fb7-9a0c-ebb0f0fcb43c");
pub const FOLDERID_Public = Guid.initString("dfdf76a2-c82a-4d63-906a-5644ac457385");
pub const FOLDERID_ChangeRemovePrograms = Guid.initString("df7266ac-9274-4867-8d55-3bd661de872d");
pub const FOLDERID_AppUpdates = Guid.initString("a305ce99-f527-492b-8b1a-7e76fa98d6e4");
pub const FOLDERID_AddNewPrograms = Guid.initString("de61d971-5ebc-4f02-a3a9-6c82895e5c04");
pub const FOLDERID_Downloads = Guid.initString("374de290-123f-4565-9164-39c4925e467b");
pub const FOLDERID_PublicDownloads = Guid.initString("3d644c9b-1fb8-4f30-9b45-f670235f79c0");
pub const FOLDERID_SavedSearches = Guid.initString("7d1d3a04-debb-4115-95cf-2f29da2920da");
pub const FOLDERID_QuickLaunch = Guid.initString("52a4f021-7b75-48a9-9f6b-4b87a210bc8f");
pub const FOLDERID_Contacts = Guid.initString("56784854-c6cb-462b-8169-88e350acb882");
pub const FOLDERID_SidebarParts = Guid.initString("a75d362e-50fc-4fb7-ac2c-a8beaa314493");
pub const FOLDERID_SidebarDefaultParts = Guid.initString("7b396e54-9ec5-4300-be0a-2482ebae1a26");
pub const FOLDERID_PublicGameTasks = Guid.initString("debf2536-e1a8-4c59-b6a2-414586476aea");
pub const FOLDERID_GameTasks = Guid.initString("054fae61-4dd8-4787-80b6-090220c4b700");
pub const FOLDERID_SavedGames = Guid.initString("4c5c32ff-bb9d-43b0-b5b4-2d72e54eaaa4");
pub const FOLDERID_Games = Guid.initString("cac52c1a-b53d-4edc-92d7-6b2e8ac19434");
pub const FOLDERID_SEARCH_MAPI = Guid.initString("98ec0e18-2098-4d44-8644-66979315a281");
pub const FOLDERID_SEARCH_CSC = Guid.initString("ee32e446-31ca-4aba-814f-a5ebd2fd6d5e");
pub const FOLDERID_Links = Guid.initString("bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968");
pub const FOLDERID_UsersFiles = Guid.initString("f3ce0f7c-4901-4acc-8648-d5d44b04ef8f");
pub const FOLDERID_UsersLibraries = Guid.initString("a302545d-deff-464b-abe8-61c8648d939b");
pub const FOLDERID_SearchHome = Guid.initString("190337d1-b8ca-4121-a639-6d472d16972a");
pub const FOLDERID_OriginalImages = Guid.initString("2c36c0aa-5812-4b87-bfd0-4cd0dfb19b39");
pub const FOLDERID_DocumentsLibrary = Guid.initString("7b0db17d-9cd2-4a93-9733-46cc89022e7c");
pub const FOLDERID_MusicLibrary = Guid.initString("2112ab0a-c86a-4ffe-a368-0de96e47012e");
pub const FOLDERID_PicturesLibrary = Guid.initString("a990ae9f-a03b-4e80-94bc-9912d7504104");
pub const FOLDERID_VideosLibrary = Guid.initString("491e922f-5643-4af4-a7eb-4e7a138d8174");
pub const FOLDERID_RecordedTVLibrary = Guid.initString("1a6fdba2-f42d-4358-a798-b74d745926c5");
pub const FOLDERID_HomeGroup = Guid.initString("52528a6b-b9e3-4add-b60d-588c2dba842d");
pub const FOLDERID_HomeGroupCurrentUser = Guid.initString("9b74b6a3-0dfd-4f11-9e78-5f7800f2e772");
pub const FOLDERID_DeviceMetadataStore = Guid.initString("5ce4a5e9-e4eb-479d-b89f-130c02886155");
pub const FOLDERID_Libraries = Guid.initString("1b3ea5dc-b587-4786-b4ef-bd1dc332aeae");
pub const FOLDERID_PublicLibraries = Guid.initString("48daf80b-e6cf-4f4e-b800-0e69d84ee384");
pub const FOLDERID_UserPinned = Guid.initString("9e3995ab-1f9c-4f13-b827-48b24b6c7174");
pub const FOLDERID_ImplicitAppShortcuts = Guid.initString("bcb5256f-79f6-4cee-b725-dc34e402fd46");
pub const FOLDERID_AccountPictures = Guid.initString("008ca0b1-55b4-4c56-b8a8-4de4b299d3be");
pub const FOLDERID_PublicUserTiles = Guid.initString("0482af6c-08f1-4c34-8c90-e17ec98b1e17");
pub const FOLDERID_AppsFolder = Guid.initString("1e87508d-89c2-42f0-8a7e-645a0f50ca58");
pub const FOLDERID_StartMenuAllPrograms = Guid.initString("f26305ef-6948-40b9-b255-81453d09c785");
pub const FOLDERID_CommonStartMenuPlaces = Guid.initString("a440879f-87a0-4f7d-b700-0207b966194a");
pub const FOLDERID_ApplicationShortcuts = Guid.initString("a3918781-e5f2-4890-b3d9-a7e54332328c");
pub const FOLDERID_RoamingTiles = Guid.initString("00bcfc5a-ed94-4e48-96a1-3f6217f21990");
pub const FOLDERID_RoamedTileImages = Guid.initString("aaa8d5a5-f1d6-4259-baa8-78e7ef60835e");
pub const FOLDERID_Screenshots = Guid.initString("b7bede81-df94-4682-a7d8-57a52620b86f");
pub const FOLDERID_CameraRoll = Guid.initString("ab5fb87b-7ce2-4f83-915d-550846c9537b");
pub const FOLDERID_SkyDrive = Guid.initString("a52bba46-e9e1-435f-b3d9-28daa648c0f6");
pub const FOLDERID_OneDrive = Guid.initString("a52bba46-e9e1-435f-b3d9-28daa648c0f6");
pub const FOLDERID_SkyDriveDocuments = Guid.initString("24d89e24-2f19-4534-9dde-6a6671fbb8fe");
pub const FOLDERID_SkyDrivePictures = Guid.initString("339719b5-8c47-4894-94c2-d8f77add44a6");
pub const FOLDERID_SkyDriveMusic = Guid.initString("c3f2459e-80d6-45dc-bfef-1f769f2be730");
pub const FOLDERID_SkyDriveCameraRoll = Guid.initString("767e6811-49cb-4273-87c2-20f355e1085b");
pub const FOLDERID_SearchHistory = Guid.initString("0d4c3db6-03a3-462f-a0e6-08924c41b5d4");
pub const FOLDERID_SearchTemplates = Guid.initString("7e636bfe-dfa9-4d5e-b456-d7b39851d8a9");
pub const FOLDERID_CameraRollLibrary = Guid.initString("2b20df75-1eda-4039-8097-38798227d5b7");
pub const FOLDERID_SavedPictures = Guid.initString("3b193882-d3ad-4eab-965a-69829d1fb59f");
pub const FOLDERID_SavedPicturesLibrary = Guid.initString("e25b5812-be88-4bd9-94b0-29233477b6c3");
pub const FOLDERID_RetailDemo = Guid.initString("12d4c69e-24ad-4923-be19-31321c43a767");
pub const FOLDERID_Device = Guid.initString("1c2ac1dc-4358-4b6c-9733-af21156576f0");
pub const FOLDERID_DevelopmentFiles = Guid.initString("dbe8e08e-3053-4bbc-b183-2a7b2b191e59");
pub const FOLDERID_Objects3D = Guid.initString("31c0dd25-9439-4f12-bf41-7ff4eda38722");
pub const FOLDERID_AppCaptures = Guid.initString("edc0fe71-98d8-4f4a-b920-c8dc133cb165");
pub const FOLDERID_LocalDocuments = Guid.initString("f42ee2d3-909f-4907-8871-4c22fc0bf756");
pub const FOLDERID_LocalPictures = Guid.initString("0ddd015d-b06c-45d5-8c4c-f59713854639");
pub const FOLDERID_LocalVideos = Guid.initString("35286a68-3c57-41a1-bbb1-0eae73d76c95");
pub const FOLDERID_LocalMusic = Guid.initString("a0c69a99-21c8-4671-8703-7934162fcf1d");
pub const FOLDERID_LocalDownloads = Guid.initString("7d83ee9b-2244-4e70-b1f5-5393042af1e4");
pub const FOLDERID_RecordedCalls = Guid.initString("2f8b40c2-83ed-48ee-b383-a1f157ec6f9a");
pub const FOLDERID_AllAppMods = Guid.initString("7ad67899-66af-43ba-9156-6aad42e6c596");
pub const FOLDERID_CurrentAppMods = Guid.initString("3db40b20-2a30-4dbe-917e-771dd21dd099");
pub const FOLDERID_AppDataDesktop = Guid.initString("b2c5e279-7add-439f-b28c-c41fe1bbf672");
pub const FOLDERID_AppDataDocuments = Guid.initString("7be16610-1f7f-44ac-bff0-83e15f2ffca1");
pub const FOLDERID_AppDataFavorites = Guid.initString("7cfbefbc-de1f-45aa-b843-a542ac536cc9");
pub const FOLDERID_AppDataProgramData = Guid.initString("559d40a3-a036-40fa-af61-84cb430a4d34");
pub const FOLDERID_LocalStorage = Guid.initString("b3eb08d3-a1f3-496b-865a-42b536cda0ec");
pub const CLSID_InternetShortcut = Guid.initString("fbf23b40-e3f0-101b-8488-00aa003e56f8");
pub const CLSID_NetworkDomain = Guid.initString("46e06680-4bf0-11d1-83ee-00a0c90dc849");
pub const CLSID_NetworkServer = Guid.initString("c0542a90-4bf0-11d1-83ee-00a0c90dc849");
pub const CLSID_NetworkShare = Guid.initString("54a754c0-4bf0-11d1-83ee-00a0c90dc849");
pub const CLSID_MyComputer = Guid.initString("20d04fe0-3aea-1069-a2d8-08002b30309d");
pub const CLSID_Internet = Guid.initString("871c5380-42a0-1069-a2ea-08002b30309d");
pub const CLSID_RecycleBin = Guid.initString("645ff040-5081-101b-9f08-00aa002f954e");
pub const CLSID_ControlPanel = Guid.initString("21ec2020-3aea-1069-a2dd-08002b30309d");
pub const CLSID_Printers = Guid.initString("2227a280-3aea-1069-a2de-08002b30309d");
pub const CLSID_MyDocuments = Guid.initString("450d8fba-ad25-11d0-98a8-0800361b1103");
pub const CATID_BrowsableShellExt = Guid.initString("00021490-0000-0000-c000-000000000046");
pub const CATID_BrowseInPlace = Guid.initString("00021491-0000-0000-c000-000000000046");
pub const CATID_DeskBand = Guid.initString("00021492-0000-0000-c000-000000000046");
pub const CATID_InfoBand = Guid.initString("00021493-0000-0000-c000-000000000046");
pub const CATID_CommBand = Guid.initString("00021494-0000-0000-c000-000000000046");
pub const FMTID_Intshcut = Guid.initString("000214a0-0000-0000-c000-000000000046");
pub const FMTID_InternetSite = Guid.initString("000214a1-0000-0000-c000-000000000046");
pub const CGID_Explorer = Guid.initString("000214d0-0000-0000-c000-000000000046");
pub const CGID_ShellDocView = Guid.initString("000214d1-0000-0000-c000-000000000046");
pub const CGID_ShellServiceObject = Guid.initString("000214d2-0000-0000-c000-000000000046");
pub const CGID_ExplorerBarDoc = Guid.initString("000214d3-0000-0000-c000-000000000046");
pub const CLSID_FolderShortcut = Guid.initString("0afaced1-e828-11d1-9187-b532f1e9575d");
pub const CLSID_CFSIconOverlayManager = Guid.initString("63b51f81-c868-11d0-999c-00c04fd655e1");
pub const CLSID_ShellThumbnailDiskCache = Guid.initString("1ebdcf80-a200-11d0-a3a4-00c04fd706ec");
pub const SID_DefView = Guid.initString("6d12fe80-7911-11cf-9534-0000c05bae0b");
pub const CGID_DefView = Guid.initString("4af07f10-d231-11d0-b942-00a0c90312e1");
pub const CLSID_MenuBand = Guid.initString("5b4dae26-b807-11d0-9815-00c04fd91972");
pub const VID_LargeIcons = Guid.initString("0057d0e0-3573-11cf-ae69-08002b2e1262");
pub const VID_SmallIcons = Guid.initString("089000c0-3573-11cf-ae69-08002b2e1262");
pub const VID_List = Guid.initString("0e1fa5e0-3573-11cf-ae69-08002b2e1262");
pub const VID_Details = Guid.initString("137e7700-3573-11cf-ae69-08002b2e1262");
pub const VID_Tile = Guid.initString("65f125e5-7be1-4810-ba9d-d271c8432ce3");
pub const VID_Content = Guid.initString("30c2c434-0889-4c8d-985d-a9f71830b0a9");
pub const VID_Thumbnails = Guid.initString("8bebb290-52d0-11d0-b7f4-00c04fd706ec");
pub const VID_ThumbStrip = Guid.initString("8eefa624-d1e9-445b-94b7-74fbce2ea11a");
pub const SID_SInPlaceBrowser = Guid.initString("1d2ae02b-3655-46cc-b63a-285988153bca");
pub const SID_SSearchBoxInfo = Guid.initString("142daa61-516b-4713-b49c-fb985ef82998");
pub const SID_CommandsPropertyBag = Guid.initString("6e043250-4416-485c-b143-e62a760d9fe5");
pub const CLSID_CUrlHistory = Guid.initString("3c374a40-bae4-11cf-bf7d-00aa006946ee");
pub const CLSID_CURLSearchHook = Guid.initString("cfbfae00-17a6-11d0-99cb-00c04fd64497");
pub const CLSID_AutoComplete = Guid.initString("00bb2763-6a77-11d0-a535-00c04fd7d062");
pub const CLSID_ACLHistory = Guid.initString("00bb2764-6a77-11d0-a535-00c04fd7d062");
pub const CLSID_ACListISF = Guid.initString("03c036f1-a186-11d0-824a-00aa005b4383");
pub const CLSID_ACLMRU = Guid.initString("6756a641-de71-11d0-831b-00aa005b4383");
pub const CLSID_ACLMulti = Guid.initString("00bb2765-6a77-11d0-a535-00c04fd7d062");
pub const CLSID_ACLCustomMRU = Guid.initString("6935db93-21e8-4ccc-beb9-9fe3c77a297a");
pub const CLSID_ProgressDialog = Guid.initString("f8383852-fcd3-11d1-a6b9-006097df5bd4");
pub const SID_STopLevelBrowser = Guid.initString("4c96be40-915c-11cf-99d3-00aa004ae837");
pub const CLSID_FileTypes = Guid.initString("b091e540-83e3-11cf-a713-0020afd79762");
pub const CLSID_ActiveDesktop = Guid.initString("75048700-ef1f-11d0-9888-006097deacf9");
pub const CLSID_QueryAssociations = Guid.initString("a07034fd-6caa-4954-ac3f-97a27216f98a");
pub const CLSID_LinkColumnProvider = Guid.initString("24f14f02-7b1c-11d1-838f-0000f80461cf");
pub const CGID_ShortCut = Guid.initString("93a68750-951a-11d1-946f-000000000000");
pub const CLSID_InternetButtons = Guid.initString("1e796980-9cc5-11d1-a83f-00c04fc99d61");
pub const CLSID_MSOButtons = Guid.initString("178f34b8-a282-11d2-86c5-00c04f8eea99");
pub const CLSID_ToolbarExtButtons = Guid.initString("2ce4b5d8-a28f-11d2-86c5-00c04f8eea99");
pub const CLSID_DarwinAppPublisher = Guid.initString("cfccc7a0-a282-11d1-9082-006008059382");
pub const CLSID_DocHostUIHandler = Guid.initString("7057e952-bd1b-11d1-8919-00c04fc2c836");
pub const FMTID_ShellDetails = Guid.initString("28636aa6-953d-11d2-b5d6-00c04fd918d0");
pub const PID_FINDDATA = @as(u32, 0);
pub const PID_NETRESOURCE = @as(u32, 1);
pub const PID_DESCRIPTIONID = @as(u32, 2);
pub const PID_WHICHFOLDER = @as(u32, 3);
pub const PID_NETWORKLOCATION = @as(u32, 4);
pub const PID_COMPUTERNAME = @as(u32, 5);
pub const FMTID_Storage = Guid.initString("b725f130-47ef-101a-a5f1-02608c9eebac");
pub const FMTID_ImageProperties = Guid.initString("14b81da1-0135-4d31-96d9-6cbfc9671a99");
pub const FMTID_CustomImageProperties = Guid.initString("7ecd8b0e-c136-4a9b-9411-4ebd6673ccc3");
pub const FMTID_LibraryProperties = Guid.initString("5d76b67f-9b3d-44bb-b6ae-25da4f638a67");
pub const FMTID_Displaced = Guid.initString("9b174b33-40ff-11d2-a27e-00c04fc30871");
pub const PID_DISPLACED_FROM = @as(u32, 2);
pub const PID_DISPLACED_DATE = @as(u32, 3);
pub const FMTID_Briefcase = Guid.initString("328d8b21-7729-4bfc-954c-902b329d56b0");
pub const PID_SYNC_COPY_IN = @as(u32, 2);
pub const FMTID_Misc = Guid.initString("9b174b34-40ff-11d2-a27e-00c04fc30871");
pub const PID_MISC_STATUS = @as(u32, 2);
pub const PID_MISC_ACCESSCOUNT = @as(u32, 3);
pub const PID_MISC_OWNER = @as(u32, 4);
pub const PID_HTMLINFOTIPFILE = @as(u32, 5);
pub const PID_MISC_PICS = @as(u32, 6);
pub const FMTID_WebView = Guid.initString("f2275480-f782-4291-bd94-f13693513aec");
pub const PID_DISPLAY_PROPERTIES = @as(u32, 0);
pub const PID_INTROTEXT = @as(u32, 1);
pub const FMTID_MUSIC = Guid.initString("56a3372e-ce9c-11d2-9f0e-006097c686f6");
pub const PIDSI_ARTIST = @as(u32, 2);
pub const PIDSI_SONGTITLE = @as(u32, 3);
pub const PIDSI_ALBUM = @as(u32, 4);
pub const PIDSI_YEAR = @as(u32, 5);
pub const PIDSI_COMMENT = @as(u32, 6);
pub const PIDSI_TRACK = @as(u32, 7);
pub const PIDSI_GENRE = @as(u32, 11);
pub const PIDSI_LYRICS = @as(u32, 12);
pub const FMTID_DRM = Guid.initString("aeac19e4-89ae-4508-b9b7-bb867abee2ed");
pub const PIDDRSI_PROTECTED = @as(u32, 2);
pub const PIDDRSI_DESCRIPTION = @as(u32, 3);
pub const PIDDRSI_PLAYCOUNT = @as(u32, 4);
pub const PIDDRSI_PLAYSTARTS = @as(u32, 5);
pub const PIDDRSI_PLAYEXPIRES = @as(u32, 6);
pub const PIDVSI_STREAM_NAME = @as(u32, 2);
pub const PIDVSI_FRAME_WIDTH = @as(u32, 3);
pub const PIDVSI_FRAME_HEIGHT = @as(u32, 4);
pub const PIDVSI_TIMELENGTH = @as(u32, 7);
pub const PIDVSI_FRAME_COUNT = @as(u32, 5);
pub const PIDVSI_FRAME_RATE = @as(u32, 6);
pub const PIDVSI_DATA_RATE = @as(u32, 8);
pub const PIDVSI_SAMPLE_SIZE = @as(u32, 9);
pub const PIDVSI_COMPRESSION = @as(u32, 10);
pub const PIDVSI_STREAM_NUMBER = @as(u32, 11);
pub const PIDASI_FORMAT = @as(u32, 2);
pub const PIDASI_TIMELENGTH = @as(u32, 3);
pub const PIDASI_AVG_DATA_RATE = @as(u32, 4);
pub const PIDASI_SAMPLE_RATE = @as(u32, 5);
pub const PIDASI_SAMPLE_SIZE = @as(u32, 6);
pub const PIDASI_CHANNEL_COUNT = @as(u32, 7);
pub const PIDASI_STREAM_NUMBER = @as(u32, 8);
pub const PIDASI_STREAM_NAME = @as(u32, 9);
pub const PIDASI_COMPRESSION = @as(u32, 10);
pub const PID_CONTROLPANEL_CATEGORY = @as(u32, 2);
pub const FMTID_Volume = Guid.initString("9b174b35-40ff-11d2-a27e-00c04fc30871");
pub const PID_VOLUME_FREE = @as(u32, 2);
pub const PID_VOLUME_CAPACITY = @as(u32, 3);
pub const PID_VOLUME_FILESYSTEM = @as(u32, 4);
pub const PID_SHARE_CSC_STATUS = @as(u32, 2);
pub const PID_LINK_TARGET = @as(u32, 2);
pub const PID_LINK_TARGET_TYPE = @as(u32, 3);
pub const FMTID_Query = Guid.initString("49691c90-7e17-101a-a91c-08002b2ecda9");
pub const PID_QUERY_RANK = @as(u32, 2);
pub const CLSID_HWShellExecute = Guid.initString("ffb8655f-81b9-4fce-b89c-9a6ba76d13e7");
pub const CLSID_DragDropHelper = Guid.initString("4657278a-411b-11d2-839a-00c04fd918d0");
pub const CLSID_CAnchorBrowsePropertyPage = Guid.initString("3050f3bb-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CImageBrowsePropertyPage = Guid.initString("3050f3b3-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CDocBrowsePropertyPage = Guid.initString("3050f3b4-98b5-11cf-bb82-00aa00bdce0b");
pub const SID_STopWindow = Guid.initString("49e1b500-4636-11d3-97f7-00c04f45d0b3");
pub const SID_SGetViewFromViewDual = Guid.initString("889a935d-971e-4b12-b90c-24dfc9e1e5e8");
pub const CLSID_FolderItemsMultiLevel = Guid.initString("53c74826-ab99-4d33-aca4-3117f51d3788");
pub const CLSID_NewMenu = Guid.initString("d969a300-e7ff-11d0-a93b-00a0c90f2719");
pub const BHID_SFObject = Guid.initString("3981e224-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_SFUIObject = Guid.initString("3981e225-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_SFViewObject = Guid.initString("3981e226-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_Storage = Guid.initString("3981e227-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_Stream = Guid.initString("1cebb3ab-7c10-499a-a417-92ca16c4cb83");
pub const BHID_RandomAccessStream = Guid.initString("f16fc93b-77ae-4cfe-bda7-a866eea6878d");
pub const BHID_LinkTargetItem = Guid.initString("3981e228-f559-11d3-8e3a-00c04f6837d5");
pub const BHID_StorageEnum = Guid.initString("4621a4e3-f0d6-4773-8a9c-46e77b174840");
pub const BHID_Transfer = Guid.initString("d5e346a1-f753-4932-b403-4574800e2498");
pub const BHID_PropertyStore = Guid.initString("0384e1a4-1523-439c-a4c8-ab911052f586");
pub const BHID_ThumbnailHandler = Guid.initString("7b2e650a-8e20-4f4a-b09e-6597afc72fb0");
pub const BHID_EnumItems = Guid.initString("94f60519-2850-4924-aa5a-d15e84868039");
pub const BHID_DataObject = Guid.initString("b8c0bd9f-ed24-455c-83e6-d5390c4fe8c4");
pub const BHID_AssociationArray = Guid.initString("bea9ef17-82f1-4f60-9284-4f8db75c3be9");
pub const BHID_Filter = Guid.initString("38d08778-f557-4690-9ebf-ba54706ad8f7");
pub const BHID_EnumAssocHandlers = Guid.initString("b8ab0b9c-c2ec-4f7a-918d-314900e6280a");
pub const BHID_StorageItem = Guid.initString("404e2109-77d2-4699-a5a0-4fdf10db9837");
pub const BHID_FilePlaceholder = Guid.initString("8677dceb-aae0-4005-8d3d-547fa852f825");
pub const CATID_FilePlaceholderMergeHandler = Guid.initString("3e9c9a51-d4aa-4870-b47c-7424b491f1cc");
pub const SID_CtxQueryAssociations = Guid.initString("faadfc40-b777-4b69-aa81-77035ef0e6e8");
pub const CLSID_QuickLinks = Guid.initString("0e5cbf21-d15f-11d0-8301-00aa005b4383");
pub const CLSID_ISFBand = Guid.initString("d82be2b0-5764-11d0-a96e-00c04fd705a2");
pub const CLSID_ShellFldSetExt = Guid.initString("6d5313c0-8c62-11d1-b2cd-006097df8c11");
pub const SID_SMenuBandChild = Guid.initString("ed9cc020-08b9-11d1-9823-00c04fd91972");
pub const SID_SMenuBandParent = Guid.initString("8c278eec-3eab-11d1-8cb0-00c04fd918d0");
pub const SID_SMenuPopup = Guid.initString("d1e7afeb-6a2e-11d0-8c78-00c04fd918b4");
pub const SID_SMenuBandBottomSelected = Guid.initString("165ebaf4-6d51-11d2-83ad-00c04fd918d0");
pub const SID_SMenuBandBottom = Guid.initString("743ca664-0deb-11d1-9825-00c04fd91972");
pub const SID_MenuShellFolder = Guid.initString("a6c17eb4-2d65-11d2-838f-00c04fd918d0");
pub const SID_SMenuBandContextMenuModifier = Guid.initString("39545874-7162-465e-b783-2aa1874fef81");
pub const SID_SMenuBandBKContextMenu = Guid.initString("164bbd86-1d0d-4de0-9a3b-d9729647c2b8");
pub const CGID_MENUDESKBAR = Guid.initString("5c9f0a12-959e-11d0-a3a4-00a0c9082636");
pub const SID_SMenuBandTop = Guid.initString("9493a810-ec38-11d0-bc46-00aa006ce2f5");
pub const CLSID_MenuToolbarBase = Guid.initString("40b96610-b522-11d1-b3b4-00aa006efde7");
pub const CLSID_MenuBandSite = Guid.initString("e13ef4e4-d2f2-11d0-9816-00c04fd91972");
pub const SID_SCommDlgBrowser = Guid.initString("80f30233-b7df-11d2-a33b-006097df5bd4");
pub const CPFG_LOGON_USERNAME = Guid.initString("da15bbe8-954d-4fd3-b0f4-1fb5b90b174b");
pub const CPFG_LOGON_PASSWORD = Guid.initString("60624cfa-a477-47b1-8a8e-3a4a19981827");
pub const CPFG_SMARTCARD_USERNAME = Guid.initString("3e1ecf69-568c-4d96-9d59-46444174e2d6");
pub const CPFG_SMARTCARD_PIN = Guid.initString("4fe5263b-9181-46c1-b0a4-9dedd4db7dea");
pub const CPFG_CREDENTIAL_PROVIDER_LOGO = Guid.initString("2d837775-f6cd-464e-a745-482fd0b47493");
pub const CPFG_CREDENTIAL_PROVIDER_LABEL = Guid.initString("286bbff3-bad4-438f-b007-79b7267c3d48");
pub const CPFG_STANDALONE_SUBMIT_BUTTON = Guid.initString("0b7b0ad8-cc36-4d59-802b-82f714fa7022");
pub const CPFG_STYLE_LINK_AS_BUTTON = Guid.initString("088fa508-94a6-4430-a4cb-6fc6e3c0b9e2");
pub const FOLDERTYPEID_Invalid = Guid.initString("57807898-8c4f-4462-bb63-71042380b109");
pub const FOLDERTYPEID_Generic = Guid.initString("5c4f28b5-f869-4e84-8e60-f11db97c5cc7");
pub const FOLDERTYPEID_GenericSearchResults = Guid.initString("7fde1a1e-8b31-49a5-93b8-6be14cfa4943");
pub const FOLDERTYPEID_GenericLibrary = Guid.initString("5f4eab9a-6833-4f61-899d-31cf46979d49");
pub const FOLDERTYPEID_Documents = Guid.initString("7d49d726-3c21-4f05-99aa-fdc2c9474656");
pub const FOLDERTYPEID_Pictures = Guid.initString("b3690e58-e961-423b-b687-386ebfd83239");
pub const FOLDERTYPEID_Music = Guid.initString("94d6ddcc-4a68-4175-a374-bd584a510b78");
pub const FOLDERTYPEID_Videos = Guid.initString("5fa96407-7e77-483c-ac93-691d05850de8");
pub const FOLDERTYPEID_Downloads = Guid.initString("885a186e-a440-4ada-812b-db871b942259");
pub const FOLDERTYPEID_UserFiles = Guid.initString("cd0fc69b-71e2-46e5-9690-5bcd9f57aab3");
pub const FOLDERTYPEID_UsersLibraries = Guid.initString("c4d98f09-6124-4fe0-9942-826416082da9");
pub const FOLDERTYPEID_OtherUsers = Guid.initString("b337fd00-9dd5-4635-a6d4-da33fd102b7a");
pub const FOLDERTYPEID_PublishedItems = Guid.initString("7f2f5b96-ff74-41da-afd8-1c78a5f3aea2");
pub const FOLDERTYPEID_Communications = Guid.initString("91475fe5-586b-4eba-8d75-d17434b8cdf6");
pub const FOLDERTYPEID_Contacts = Guid.initString("de2b70ec-9bf7-4a93-bd3d-243f7881d492");
pub const FOLDERTYPEID_StartMenu = Guid.initString("ef87b4cb-f2ce-4785-8658-4ca6c63e38c6");
pub const FOLDERTYPEID_RecordedTV = Guid.initString("5557a28f-5da6-4f83-8809-c2c98a11a6fa");
pub const FOLDERTYPEID_SavedGames = Guid.initString("d0363307-28cb-4106-9f23-2956e3e5e0e7");
pub const FOLDERTYPEID_OpenSearch = Guid.initString("8faf9629-1980-46ff-8023-9dceab9c3ee3");
pub const FOLDERTYPEID_SearchConnector = Guid.initString("982725ee-6f47-479e-b447-812bfa7d2e8f");
pub const FOLDERTYPEID_AccountPictures = Guid.initString("db2a5d8f-06e6-4007-aba6-af877d526ea6");
pub const FOLDERTYPEID_Games = Guid.initString("b689b0d0-76d3-4cbb-87f7-585d0e0ce070");
pub const FOLDERTYPEID_ControlPanelCategory = Guid.initString("de4f0660-fa10-4b8f-a494-068b20b22307");
pub const FOLDERTYPEID_ControlPanelClassic = Guid.initString("0c3794f3-b545-43aa-a329-c37430c58d2a");
pub const FOLDERTYPEID_Printers = Guid.initString("2c7bbec6-c844-4a0a-91fa-cef6f59cfda1");
pub const FOLDERTYPEID_RecycleBin = Guid.initString("d6d9e004-cd87-442b-9d57-5e0aeb4f6f72");
pub const FOLDERTYPEID_SoftwareExplorer = Guid.initString("d674391b-52d9-4e07-834e-67c98610f39d");
pub const FOLDERTYPEID_CompressedFolder = Guid.initString("80213e82-bcfd-4c4f-8817-bb27601267a9");
pub const FOLDERTYPEID_NetworkExplorer = Guid.initString("25cc242b-9a7c-4f51-80e0-7a2928febe42");
pub const FOLDERTYPEID_Searches = Guid.initString("0b0ba2e3-405f-415e-a6ee-cad625207853");
pub const FOLDERTYPEID_SearchHome = Guid.initString("834d8a44-0974-4ed6-866e-f203d80b3810");
pub const FOLDERTYPEID_StorageProviderGeneric = Guid.initString("4f01ebc5-2385-41f2-a28e-2c5c91fb56e0");
pub const FOLDERTYPEID_StorageProviderDocuments = Guid.initString("dd61bd66-70e8-48dd-9655-65c5e1aac2d1");
pub const FOLDERTYPEID_StorageProviderPictures = Guid.initString("71d642a9-f2b1-42cd-ad92-eb9300c7cc0a");
pub const FOLDERTYPEID_StorageProviderMusic = Guid.initString("672ecd7e-af04-4399-875c-0290845b6247");
pub const FOLDERTYPEID_StorageProviderVideos = Guid.initString("51294da1-d7b1-485b-9e9a-17cffe33e187");
pub const SYNCMGR_OBJECTID_Icon = Guid.initString("6dbc85c3-5d07-4c72-a777-7fec78072c06");
pub const SYNCMGR_OBJECTID_EventStore = Guid.initString("4bef34b9-a786-4075-ba88-0c2b9d89a98f");
pub const SYNCMGR_OBJECTID_ConflictStore = Guid.initString("d78181f4-2389-47e4-a960-60bcc2ed930b");
pub const SYNCMGR_OBJECTID_BrowseContent = Guid.initString("57cbb584-e9b4-47ae-a120-c4df3335dee2");
pub const SYNCMGR_OBJECTID_ShowSchedule = Guid.initString("edc6f3e3-8441-4109-adf3-6c1ca0b7de47");
pub const SYNCMGR_OBJECTID_QueryBeforeActivate = Guid.initString("d882d80b-e7aa-49ed-86b7-e6e1f714cdfe");
pub const SYNCMGR_OBJECTID_QueryBeforeDeactivate = Guid.initString("a0efc282-60e0-460e-9374-ea88513cfc80");
pub const SYNCMGR_OBJECTID_QueryBeforeEnable = Guid.initString("04cbf7f0-5beb-4de1-bc90-908345c480f6");
pub const SYNCMGR_OBJECTID_QueryBeforeDisable = Guid.initString("bb5f64aa-f004-4eb5-8e4d-26751966344c");
pub const SYNCMGR_OBJECTID_QueryBeforeDelete = Guid.initString("f76c3397-afb3-45d7-a59f-5a49e905437e");
pub const SYNCMGR_OBJECTID_EventLinkClick = Guid.initString("2203bdc1-1af1-4082-8c30-28399f41384c");
pub const EP_NavPane = Guid.initString("cb316b22-25f7-42b8-8a09-540d23a43c2f");
pub const EP_Commands = Guid.initString("d9745868-ca5f-4a76-91cd-f5a129fbb076");
pub const EP_Commands_Organize = Guid.initString("72e81700-e3ec-4660-bf24-3c3b7b648806");
pub const EP_Commands_View = Guid.initString("21f7c32d-eeaa-439b-bb51-37b96fd6a943");
pub const EP_DetailsPane = Guid.initString("43abf98b-89b8-472d-b9ce-e69b8229f019");
pub const EP_PreviewPane = Guid.initString("893c63d1-45c8-4d17-be19-223be71be365");
pub const EP_QueryPane = Guid.initString("65bcde4f-4f07-4f27-83a7-1afca4df7ddd");
pub const EP_AdvQueryPane = Guid.initString("b4e9db8b-34ba-4c39-b5cc-16a1bd2c411c");
pub const EP_StatusBar = Guid.initString("65fe56ce-5cfe-4bc4-ad8a-7ae3fe7e8f7c");
pub const EP_Ribbon = Guid.initString("d27524a8-c9f2-4834-a106-df8889fd4f37");
pub const CATID_LocationFactory = Guid.initString("965c4d51-8b76-4e57-80b7-564d2ea4b55e");
pub const CATID_LocationProvider = Guid.initString("1b3ca474-2614-414b-b813-1aceca3e3dd8");
pub const ItemCount_Property_GUID = Guid.initString("abbf5c45-5ccc-47b7-bb4e-87cb87bbd162");
pub const SelectedItemCount_Property_GUID = Guid.initString("8fe316d2-0e52-460a-9c1e-48f273d470a3");
pub const ItemIndex_Property_GUID = Guid.initString("92a053da-2969-4021-bf27-514cfc2e4a69");
pub const CATID_SearchableApplication = Guid.initString("366c292a-d9b3-4dbf-bb70-e62ec3d0bbbf");
pub const IDD_WIZEXTN_FIRST = @as(u32, 20480);
pub const IDD_WIZEXTN_LAST = @as(u32, 20736);
pub const SHPWHF_NORECOMPRESS = @as(u32, 1);
pub const SHPWHF_NONETPLACECREATE = @as(u32, 2);
pub const SHPWHF_NOFILESELECTOR = @as(u32, 4);
pub const SHPWHF_USEMRU = @as(u32, 8);
pub const SHPWHF_ANYLOCATION = @as(u32, 256);
pub const SHPWHF_VALIDATEVIAWEBFOLDERS = @as(u32, 65536);
pub const ACDD_VISIBLE = @as(u32, 1);
pub const SID_SCommandBarState = Guid.initString("b99eaa5c-3850-4400-bc33-2ce534048bf8");
pub const NSTCDHPOS_ONTOP = @as(i32, -1);
pub const FVSIF_RECT = @as(u32, 1);
pub const FVSIF_PINNED = @as(u32, 2);
pub const FVSIF_NEWFAILED = @as(u32, 134217728);
pub const FVSIF_NEWFILE = @as(u32, 2147483648);
pub const FVSIF_CANVIEWIT = @as(u32, 1073741824);
pub const FCIDM_TOOLBAR = @as(u32, 40960);
pub const FCIDM_STATUS = @as(u32, 40961);
pub const IDC_OFFLINE_HAND = @as(u32, 103);
pub const IDC_PANTOOL_HAND_OPEN = @as(u32, 104);
pub const IDC_PANTOOL_HAND_CLOSED = @as(u32, 105);
pub const PANE_NONE = @as(u32, 4294967295);
pub const PANE_ZONE = @as(u32, 1);
pub const PANE_OFFLINE = @as(u32, 2);
pub const PANE_PRINTER = @as(u32, 3);
pub const PANE_SSL = @as(u32, 4);
pub const PANE_NAVIGATION = @as(u32, 5);
pub const PANE_PROGRESS = @as(u32, 6);
pub const PANE_PRIVACY = @as(u32, 7);
pub const DWFRF_NORMAL = @as(u32, 0);
pub const DWFRF_DELETECONFIGDATA = @as(u32, 1);
pub const DWFAF_HIDDEN = @as(u32, 1);
pub const DWFAF_GROUP1 = @as(u32, 2);
pub const DWFAF_GROUP2 = @as(u32, 4);
pub const DWFAF_AUTOHIDE = @as(u32, 16);
pub const SHIMSTCAPFLAG_LOCKABLE = @as(u32, 1);
pub const SHIMSTCAPFLAG_PURGEABLE = @as(u32, 2);
pub const ISFB_MASK_STATE = @as(u32, 1);
pub const ISFB_MASK_BKCOLOR = @as(u32, 2);
pub const ISFB_MASK_VIEWMODE = @as(u32, 4);
pub const ISFB_MASK_SHELLFOLDER = @as(u32, 8);
pub const ISFB_MASK_IDLIST = @as(u32, 16);
pub const ISFB_MASK_COLORS = @as(u32, 32);
pub const ISFB_STATE_DEFAULT = @as(u32, 0);
pub const ISFB_STATE_DEBOSSED = @as(u32, 1);
pub const ISFB_STATE_ALLOWRENAME = @as(u32, 2);
pub const ISFB_STATE_NOSHOWTEXT = @as(u32, 4);
pub const ISFB_STATE_CHANNELBAR = @as(u32, 16);
pub const ISFB_STATE_QLINKSMODE = @as(u32, 32);
pub const ISFB_STATE_FULLOPEN = @as(u32, 64);
pub const ISFB_STATE_NONAMESORT = @as(u32, 128);
pub const ISFB_STATE_BTNMINSIZE = @as(u32, 256);
pub const ISFBVIEWMODE_SMALLICONS = @as(u32, 1);
pub const ISFBVIEWMODE_LARGEICONS = @as(u32, 2);
pub const ISFBVIEWMODE_LOGOS = @as(u32, 3);
pub const DBC_GS_IDEAL = @as(u32, 0);
pub const DBC_GS_SIZEDOWN = @as(u32, 1);
pub const DBC_HIDE = @as(u32, 0);
pub const DBC_SHOW = @as(u32, 1);
pub const DBC_SHOWOBSCURE = @as(u32, 2);
pub const SSM_CLEAR = @as(u32, 0);
pub const SSM_SET = @as(u32, 1);
pub const SSM_REFRESH = @as(u32, 2);
pub const SSM_UPDATE = @as(u32, 4);
pub const SCHEME_DISPLAY = @as(u32, 1);
pub const SCHEME_EDIT = @as(u32, 2);
pub const SCHEME_LOCAL = @as(u32, 4);
pub const SCHEME_GLOBAL = @as(u32, 8);
pub const SCHEME_REFRESH = @as(u32, 16);
pub const SCHEME_UPDATE = @as(u32, 32);
pub const SCHEME_DONOTUSE = @as(u32, 64);
pub const SCHEME_CREATE = @as(u32, 128);
pub const GADOF_DIRTY = @as(u32, 1);
pub const SHCDF_UPDATEITEM = @as(u32, 1);
pub const PPCF_ADDQUOTES = @as(u32, 1);
pub const PPCF_ADDARGUMENTS = @as(u32, 3);
pub const PPCF_NODIRECTORIES = @as(u32, 16);
pub const PPCF_FORCEQUALIFY = @as(u32, 64);
pub const PPCF_LONGESTPOSSIBLE = @as(u32, 128);
pub const OPENPROPS_NONE = @as(u32, 0);
pub const OPENPROPS_INHIBITPIF = @as(u32, 32768);
pub const GETPROPS_NONE = @as(u32, 0);
pub const SETPROPS_NONE = @as(u32, 0);
pub const CLOSEPROPS_NONE = @as(u32, 0);
pub const CLOSEPROPS_DISCARD = @as(u32, 1);
pub const TBIF_APPEND = @as(u32, 0);
pub const TBIF_PREPEND = @as(u32, 1);
pub const TBIF_REPLACE = @as(u32, 2);
pub const TBIF_DEFAULT = @as(u32, 0);
pub const TBIF_INTERNETBAR = @as(u32, 65536);
pub const TBIF_STANDARDTOOLBAR = @as(u32, 131072);
pub const TBIF_NOTOOLBAR = @as(u32, 196608);
pub const SFVM_REARRANGE = @as(u32, 1);
pub const SFVM_ADDOBJECT = @as(u32, 3);
pub const SFVM_REMOVEOBJECT = @as(u32, 6);
pub const SFVM_UPDATEOBJECT = @as(u32, 7);
pub const SFVM_GETSELECTEDOBJECTS = @as(u32, 9);
pub const SFVM_SETITEMPOS = @as(u32, 14);
pub const SFVM_SETCLIPBOARD = @as(u32, 16);
pub const SFVM_SETPOINTS = @as(u32, 23);
pub const GIL_OPENICON = @as(u32, 1);
pub const GIL_FORSHELL = @as(u32, 2);
pub const GIL_ASYNC = @as(u32, 32);
pub const GIL_DEFAULTICON = @as(u32, 64);
pub const GIL_FORSHORTCUT = @as(u32, 128);
pub const GIL_CHECKSHIELD = @as(u32, 512);
pub const GIL_SIMULATEDOC = @as(u32, 1);
pub const GIL_PERINSTANCE = @as(u32, 2);
pub const GIL_PERCLASS = @as(u32, 4);
pub const GIL_NOTFILENAME = @as(u32, 8);
pub const GIL_DONTCACHE = @as(u32, 16);
pub const GIL_SHIELD = @as(u32, 512);
pub const GIL_FORCENOSHIELD = @as(u32, 1024);
pub const SIOM_OVERLAYINDEX = @as(u32, 1);
pub const SIOM_ICONINDEX = @as(u32, 2);
pub const SIOM_RESERVED_SHARED = @as(u32, 0);
pub const SIOM_RESERVED_LINK = @as(u32, 1);
pub const SIOM_RESERVED_SLOWFILE = @as(u32, 2);
pub const SIOM_RESERVED_DEFAULT = @as(u32, 3);
pub const OI_DEFAULT = @as(u32, 0);
pub const OI_ASYNC = @as(u32, 4294962926);
pub const IDO_SHGIOI_SHARE = @as(u32, 268435455);
pub const IDO_SHGIOI_LINK = @as(u32, 268435454);
pub const IDO_SHGIOI_SLOWFILE = @as(u64, 4294967293);
pub const IDO_SHGIOI_DEFAULT = @as(u64, 4294967292);
pub const NT_CONSOLE_PROPS_SIG = @as(u32, 2684354562);
pub const NT_FE_CONSOLE_PROPS_SIG = @as(u32, 2684354564);
pub const EXP_DARWIN_ID_SIG = @as(u32, 2684354566);
pub const EXP_SPECIAL_FOLDER_SIG = @as(u32, 2684354565);
pub const EXP_SZ_LINK_SIG = @as(u32, 2684354561);
pub const EXP_SZ_ICON_SIG = @as(u32, 2684354567);
pub const EXP_PROPERTYSTORAGE_SIG = @as(u32, 2684354569);
pub const FCIDM_SHVIEWFIRST = @as(u32, 0);
pub const FCIDM_SHVIEWLAST = @as(u32, 32767);
pub const FCIDM_BROWSERFIRST = @as(u32, 40960);
pub const FCIDM_BROWSERLAST = @as(u32, 48896);
pub const FCIDM_GLOBALFIRST = @as(u32, 32768);
pub const FCIDM_GLOBALLAST = @as(u32, 40959);
pub const FCIDM_MENU_FILE = @as(u32, 32768);
pub const FCIDM_MENU_EDIT = @as(u32, 32832);
pub const FCIDM_MENU_VIEW = @as(u32, 32896);
pub const FCIDM_MENU_VIEW_SEP_OPTIONS = @as(u32, 32897);
pub const FCIDM_MENU_TOOLS = @as(u32, 32960);
pub const FCIDM_MENU_TOOLS_SEP_GOTO = @as(u32, 32961);
pub const FCIDM_MENU_HELP = @as(u32, 33024);
pub const FCIDM_MENU_FIND = @as(u32, 33088);
pub const FCIDM_MENU_EXPLORE = @as(u32, 33104);
pub const FCIDM_MENU_FAVORITES = @as(u32, 33136);
pub const OFASI_EDIT = @as(u32, 1);
pub const OFASI_OPENDESKTOP = @as(u32, 2);
pub const CSIDL_DESKTOP = @as(u32, 0);
pub const CSIDL_INTERNET = @as(u32, 1);
pub const CSIDL_PROGRAMS = @as(u32, 2);
pub const CSIDL_CONTROLS = @as(u32, 3);
pub const CSIDL_PRINTERS = @as(u32, 4);
pub const CSIDL_PERSONAL = @as(u32, 5);
pub const CSIDL_FAVORITES = @as(u32, 6);
pub const CSIDL_STARTUP = @as(u32, 7);
pub const CSIDL_RECENT = @as(u32, 8);
pub const CSIDL_SENDTO = @as(u32, 9);
pub const CSIDL_BITBUCKET = @as(u32, 10);
pub const CSIDL_STARTMENU = @as(u32, 11);
pub const CSIDL_MYDOCUMENTS = @as(u32, 5);
pub const CSIDL_MYMUSIC = @as(u32, 13);
pub const CSIDL_MYVIDEO = @as(u32, 14);
pub const CSIDL_DESKTOPDIRECTORY = @as(u32, 16);
pub const CSIDL_DRIVES = @as(u32, 17);
pub const CSIDL_NETWORK = @as(u32, 18);
pub const CSIDL_NETHOOD = @as(u32, 19);
pub const CSIDL_FONTS = @as(u32, 20);
pub const CSIDL_TEMPLATES = @as(u32, 21);
pub const CSIDL_COMMON_STARTMENU = @as(u32, 22);
pub const CSIDL_COMMON_PROGRAMS = @as(u32, 23);
pub const CSIDL_COMMON_STARTUP = @as(u32, 24);
pub const CSIDL_COMMON_DESKTOPDIRECTORY = @as(u32, 25);
pub const CSIDL_APPDATA = @as(u32, 26);
pub const CSIDL_PRINTHOOD = @as(u32, 27);
pub const CSIDL_LOCAL_APPDATA = @as(u32, 28);
pub const CSIDL_ALTSTARTUP = @as(u32, 29);
pub const CSIDL_COMMON_ALTSTARTUP = @as(u32, 30);
pub const CSIDL_COMMON_FAVORITES = @as(u32, 31);
pub const CSIDL_INTERNET_CACHE = @as(u32, 32);
pub const CSIDL_COOKIES = @as(u32, 33);
pub const CSIDL_HISTORY = @as(u32, 34);
pub const CSIDL_COMMON_APPDATA = @as(u32, 35);
pub const CSIDL_WINDOWS = @as(u32, 36);
pub const CSIDL_SYSTEM = @as(u32, 37);
pub const CSIDL_PROGRAM_FILES = @as(u32, 38);
pub const CSIDL_MYPICTURES = @as(u32, 39);
pub const CSIDL_PROFILE = @as(u32, 40);
pub const CSIDL_SYSTEMX86 = @as(u32, 41);
pub const CSIDL_PROGRAM_FILESX86 = @as(u32, 42);
pub const CSIDL_PROGRAM_FILES_COMMON = @as(u32, 43);
pub const CSIDL_PROGRAM_FILES_COMMONX86 = @as(u32, 44);
pub const CSIDL_COMMON_TEMPLATES = @as(u32, 45);
pub const CSIDL_COMMON_DOCUMENTS = @as(u32, 46);
pub const CSIDL_COMMON_ADMINTOOLS = @as(u32, 47);
pub const CSIDL_ADMINTOOLS = @as(u32, 48);
pub const CSIDL_CONNECTIONS = @as(u32, 49);
pub const CSIDL_COMMON_MUSIC = @as(u32, 53);
pub const CSIDL_COMMON_PICTURES = @as(u32, 54);
pub const CSIDL_COMMON_VIDEO = @as(u32, 55);
pub const CSIDL_RESOURCES = @as(u32, 56);
pub const CSIDL_RESOURCES_LOCALIZED = @as(u32, 57);
pub const CSIDL_COMMON_OEM_LINKS = @as(u32, 58);
pub const CSIDL_CDBURN_AREA = @as(u32, 59);
pub const CSIDL_COMPUTERSNEARME = @as(u32, 61);
pub const CSIDL_FLAG_CREATE = @as(u32, 32768);
pub const CSIDL_FLAG_DONT_VERIFY = @as(u32, 16384);
pub const CSIDL_FLAG_DONT_UNEXPAND = @as(u32, 8192);
pub const CSIDL_FLAG_NO_ALIAS = @as(u32, 4096);
pub const CSIDL_FLAG_PER_USER_INIT = @as(u32, 2048);
pub const CSIDL_FLAG_MASK = @as(u32, 65280);
pub const FCS_READ = @as(u32, 1);
pub const FCS_FORCEWRITE = @as(u32, 2);
pub const FCS_FLAG_DRAGDROP = @as(u32, 2);
pub const FCSM_VIEWID = @as(u32, 1);
pub const FCSM_WEBVIEWTEMPLATE = @as(u32, 2);
pub const FCSM_INFOTIP = @as(u32, 4);
pub const FCSM_CLSID = @as(u32, 8);
pub const FCSM_ICONFILE = @as(u32, 16);
pub const FCSM_LOGO = @as(u32, 32);
pub const FCSM_FLAGS = @as(u32, 64);
pub const BIF_RETURNONLYFSDIRS = @as(u32, 1);
pub const BIF_DONTGOBELOWDOMAIN = @as(u32, 2);
pub const BIF_STATUSTEXT = @as(u32, 4);
pub const BIF_RETURNFSANCESTORS = @as(u32, 8);
pub const BIF_EDITBOX = @as(u32, 16);
pub const BIF_VALIDATE = @as(u32, 32);
pub const BIF_NEWDIALOGSTYLE = @as(u32, 64);
pub const BIF_BROWSEINCLUDEURLS = @as(u32, 128);
pub const BIF_UAHINT = @as(u32, 256);
pub const BIF_NONEWFOLDERBUTTON = @as(u32, 512);
pub const BIF_NOTRANSLATETARGETS = @as(u32, 1024);
pub const BIF_BROWSEFORCOMPUTER = @as(u32, 4096);
pub const BIF_BROWSEFORPRINTER = @as(u32, 8192);
pub const BIF_BROWSEINCLUDEFILES = @as(u32, 16384);
pub const BIF_SHAREABLE = @as(u32, 32768);
pub const BIF_BROWSEFILEJUNCTIONS = @as(u32, 65536);
pub const BFFM_INITIALIZED = @as(u32, 1);
pub const BFFM_SELCHANGED = @as(u32, 2);
pub const BFFM_VALIDATEFAILEDA = @as(u32, 3);
pub const BFFM_VALIDATEFAILEDW = @as(u32, 4);
pub const BFFM_IUNKNOWN = @as(u32, 5);
pub const BFFM_SETSTATUSTEXTA = @as(u32, 1124);
pub const BFFM_ENABLEOK = @as(u32, 1125);
pub const BFFM_SETSELECTIONA = @as(u32, 1126);
pub const BFFM_SETSELECTIONW = @as(u32, 1127);
pub const BFFM_SETSTATUSTEXTW = @as(u32, 1128);
pub const BFFM_SETOKTEXT = @as(u32, 1129);
pub const BFFM_SETEXPANDED = @as(u32, 1130);
pub const BFFM_SETSTATUSTEXT = @as(u32, 1128);
pub const BFFM_SETSELECTION = @as(u32, 1127);
pub const BFFM_VALIDATEFAILED = @as(u32, 4);
pub const CMDID_INTSHORTCUTCREATE = @as(i32, 1);
pub const PROGDLG_NORMAL = @as(u32, 0);
pub const PROGDLG_MODAL = @as(u32, 1);
pub const PROGDLG_AUTOTIME = @as(u32, 2);
pub const PROGDLG_NOTIME = @as(u32, 4);
pub const PROGDLG_NOMINIMIZE = @as(u32, 8);
pub const PROGDLG_NOPROGRESSBAR = @as(u32, 16);
pub const PROGDLG_MARQUEEPROGRESS = @as(u32, 32);
pub const PROGDLG_NOCANCEL = @as(u32, 64);
pub const PDTIMER_RESET = @as(u32, 1);
pub const PDTIMER_PAUSE = @as(u32, 2);
pub const PDTIMER_RESUME = @as(u32, 3);
pub const COMPONENT_TOP = @as(u32, 1073741823);
pub const COMP_TYPE_HTMLDOC = @as(u32, 0);
pub const COMP_TYPE_PICTURE = @as(u32, 1);
pub const COMP_TYPE_WEBSITE = @as(u32, 2);
pub const COMP_TYPE_CONTROL = @as(u32, 3);
pub const COMP_TYPE_CFHTML = @as(u32, 4);
pub const COMP_TYPE_MAX = @as(u32, 4);
pub const IS_NORMAL = @as(u32, 1);
pub const IS_FULLSCREEN = @as(u32, 2);
pub const IS_SPLIT = @as(u32, 4);
pub const AD_APPLY_SAVE = @as(u32, 1);
pub const AD_APPLY_HTMLGEN = @as(u32, 2);
pub const AD_APPLY_REFRESH = @as(u32, 4);
pub const AD_APPLY_FORCE = @as(u32, 8);
pub const AD_APPLY_BUFFERED_REFRESH = @as(u32, 16);
pub const AD_APPLY_DYNAMICREFRESH = @as(u32, 32);
pub const AD_GETWP_BMP = @as(u32, 0);
pub const AD_GETWP_IMAGE = @as(u32, 1);
pub const AD_GETWP_LAST_APPLIED = @as(u32, 2);
pub const WPSTYLE_CENTER = @as(u32, 0);
pub const WPSTYLE_TILE = @as(u32, 1);
pub const WPSTYLE_STRETCH = @as(u32, 2);
pub const WPSTYLE_KEEPASPECT = @as(u32, 3);
pub const WPSTYLE_CROPTOFIT = @as(u32, 4);
pub const WPSTYLE_SPAN = @as(u32, 5);
pub const WPSTYLE_MAX = @as(u32, 6);
pub const COMP_ELEM_TYPE = @as(u32, 1);
pub const COMP_ELEM_CHECKED = @as(u32, 2);
pub const COMP_ELEM_DIRTY = @as(u32, 4);
pub const COMP_ELEM_NOSCROLL = @as(u32, 8);
pub const COMP_ELEM_POS_LEFT = @as(u32, 16);
pub const COMP_ELEM_POS_TOP = @as(u32, 32);
pub const COMP_ELEM_SIZE_WIDTH = @as(u32, 64);
pub const COMP_ELEM_SIZE_HEIGHT = @as(u32, 128);
pub const COMP_ELEM_POS_ZINDEX = @as(u32, 256);
pub const COMP_ELEM_SOURCE = @as(u32, 512);
pub const COMP_ELEM_FRIENDLYNAME = @as(u32, 1024);
pub const COMP_ELEM_SUBSCRIBEDURL = @as(u32, 2048);
pub const COMP_ELEM_ORIGINAL_CSI = @as(u32, 4096);
pub const COMP_ELEM_RESTORED_CSI = @as(u32, 8192);
pub const COMP_ELEM_CURITEMSTATE = @as(u32, 16384);
pub const ADDURL_SILENT = @as(u32, 1);
pub const COMPONENT_DEFAULT_LEFT = @as(u32, 65535);
pub const COMPONENT_DEFAULT_TOP = @as(u32, 65535);
pub const MAX_COLUMN_NAME_LEN = @as(u32, 80);
pub const MAX_COLUMN_DESC_LEN = @as(u32, 128);
pub const DVASPECT_SHORTNAME = @as(u32, 2);
pub const DVASPECT_COPY = @as(u32, 3);
pub const DVASPECT_LINK = @as(u32, 4);
pub const SHCNEE_ORDERCHANGED = @as(i32, 2);
pub const SHCNEE_MSI_CHANGE = @as(i32, 4);
pub const SHCNEE_MSI_UNINSTALL = @as(i32, 5);
pub const NUM_POINTS = @as(u32, 3);
pub const CABINETSTATE_VERSION = @as(u32, 2);
pub const PIFNAMESIZE = @as(u32, 30);
pub const PIFSTARTLOCSIZE = @as(u32, 63);
pub const PIFDEFPATHSIZE = @as(u32, 64);
pub const PIFPARAMSSIZE = @as(u32, 64);
pub const PIFSHPROGSIZE = @as(u32, 64);
pub const PIFSHDATASIZE = @as(u32, 64);
pub const PIFDEFFILESIZE = @as(u32, 80);
pub const PIFMAXFILEPATH = @as(u32, 260);
pub const QCMINFO_PLACE_BEFORE = @as(u32, 0);
pub const QCMINFO_PLACE_AFTER = @as(u32, 1);
pub const SFVSOC_INVALIDATE_ALL = @as(u32, 1);
pub const SFVSOC_NOSCROLL = @as(u32, 2);
pub const SHELLSTATEVERSION_IE4 = @as(u32, 9);
pub const SHELLSTATEVERSION_WIN2K = @as(u32, 10);
pub const SHPPFW_NONE = @as(u32, 0);
pub const SHPPFW_DIRCREATE = @as(u32, 1);
pub const SHPPFW_ASKDIRCREATE = @as(u32, 2);
pub const SHPPFW_IGNOREFILENAME = @as(u32, 4);
pub const SHPPFW_NOWRITECHECK = @as(u32, 8);
pub const SHPPFW_MEDIACHECKONLY = @as(u32, 16);
pub const CMF_NORMAL = @as(u32, 0);
pub const CMF_DEFAULTONLY = @as(u32, 1);
pub const CMF_VERBSONLY = @as(u32, 2);
pub const CMF_EXPLORE = @as(u32, 4);
pub const CMF_NOVERBS = @as(u32, 8);
pub const CMF_CANRENAME = @as(u32, 16);
pub const CMF_NODEFAULT = @as(u32, 32);
pub const CMF_INCLUDESTATIC = @as(u32, 64);
pub const CMF_ITEMMENU = @as(u32, 128);
pub const CMF_EXTENDEDVERBS = @as(u32, 256);
pub const CMF_DISABLEDVERBS = @as(u32, 512);
pub const CMF_ASYNCVERBSTATE = @as(u32, 1024);
pub const CMF_OPTIMIZEFORINVOKE = @as(u32, 2048);
pub const CMF_SYNCCASCADEMENU = @as(u32, 4096);
pub const CMF_DONOTPICKDEFAULT = @as(u32, 8192);
pub const CMF_RESERVED = @as(u32, 4294901760);
pub const GCS_VERBA = @as(u32, 0);
pub const GCS_HELPTEXTA = @as(u32, 1);
pub const GCS_VALIDATEA = @as(u32, 2);
pub const GCS_VERBW = @as(u32, 4);
pub const GCS_HELPTEXTW = @as(u32, 5);
pub const GCS_VALIDATEW = @as(u32, 6);
pub const GCS_VERBICONW = @as(u32, 20);
pub const GCS_UNICODE = @as(u32, 4);
pub const GCS_VERB = @as(u32, 4);
pub const GCS_HELPTEXT = @as(u32, 5);
pub const GCS_VALIDATE = @as(u32, 6);
pub const CMIC_MASK_SHIFT_DOWN = @as(u32, 268435456);
pub const CMIC_MASK_CONTROL_DOWN = @as(u32, 1073741824);
pub const CMIC_MASK_PTINVOKE = @as(u32, 536870912);
pub const IRTIR_TASK_NOT_RUNNING = @as(u32, 0);
pub const IRTIR_TASK_RUNNING = @as(u32, 1);
pub const IRTIR_TASK_SUSPENDED = @as(u32, 2);
pub const IRTIR_TASK_PENDING = @as(u32, 3);
pub const IRTIR_TASK_FINISHED = @as(u32, 4);
pub const ITSAT_DEFAULT_PRIORITY = @as(u32, 268435456);
pub const ITSAT_MAX_PRIORITY = @as(u32, 2147483647);
pub const ITSAT_MIN_PRIORITY = @as(u32, 0);
pub const ITSSFLAG_COMPLETE_ON_DESTROY = @as(u32, 0);
pub const ITSSFLAG_KILL_ON_DESTROY = @as(u32, 1);
pub const ITSSFLAG_FLAGS_MASK = @as(u32, 3);
pub const CSIDL_FLAG_PFTI_TRACKTARGET = @as(u32, 16384);
pub const SHCIDS_ALLFIELDS = @as(i32, -2147483648);
pub const SHCIDS_CANONICALONLY = @as(i32, 268435456);
pub const SHCIDS_BITMASK = @as(i32, -65536);
pub const SHCIDS_COLUMNMASK = @as(i32, 65535);
pub const SFGAO_CANCOPY = @as(u32, 1);
pub const SFGAO_CANMOVE = @as(u32, 2);
pub const SFGAO_CANLINK = @as(u32, 4);
pub const SFGAO_STORAGE = @as(i32, 8);
pub const SFGAO_CANRENAME = @as(i32, 16);
pub const SFGAO_CANDELETE = @as(i32, 32);
pub const SFGAO_HASPROPSHEET = @as(i32, 64);
pub const SFGAO_DROPTARGET = @as(i32, 256);
pub const SFGAO_CAPABILITYMASK = @as(i32, 375);
pub const SFGAO_PLACEHOLDER = @as(i32, 2048);
pub const SFGAO_SYSTEM = @as(i32, 4096);
pub const SFGAO_ENCRYPTED = @as(i32, 8192);
pub const SFGAO_ISSLOW = @as(i32, 16384);
pub const SFGAO_GHOSTED = @as(i32, 32768);
pub const SFGAO_LINK = @as(i32, 65536);
pub const SFGAO_SHARE = @as(i32, 131072);
pub const SFGAO_READONLY = @as(i32, 262144);
pub const SFGAO_HIDDEN = @as(i32, 524288);
pub const SFGAO_DISPLAYATTRMASK = @as(i32, 1032192);
pub const SFGAO_FILESYSANCESTOR = @as(i32, 268435456);
pub const SFGAO_FOLDER = @as(i32, 536870912);
pub const SFGAO_FILESYSTEM = @as(i32, 1073741824);
pub const SFGAO_HASSUBFOLDER = @as(i32, -2147483648);
pub const SFGAO_CONTENTSMASK = @as(i32, -2147483648);
pub const SFGAO_VALIDATE = @as(i32, 16777216);
pub const SFGAO_REMOVABLE = @as(i32, 33554432);
pub const SFGAO_COMPRESSED = @as(i32, 67108864);
pub const SFGAO_BROWSABLE = @as(i32, 134217728);
pub const SFGAO_NONENUMERATED = @as(i32, 1048576);
pub const SFGAO_NEWCONTENT = @as(i32, 2097152);
pub const SFGAO_CANMONIKER = @as(i32, 4194304);
pub const SFGAO_HASSTORAGE = @as(i32, 4194304);
pub const SFGAO_STREAM = @as(i32, 4194304);
pub const SFGAO_STORAGEANCESTOR = @as(i32, 8388608);
pub const SFGAO_STORAGECAPMASK = @as(i32, 1891958792);
pub const SFGAO_PKEYSFGAOMASK = @as(i32, -2130427904);
pub const BIND_INTERRUPTABLE = @as(u32, 4294967295);
pub const CDBOSC_SETFOCUS = @as(u32, 0);
pub const CDBOSC_KILLFOCUS = @as(u32, 1);
pub const CDBOSC_SELCHANGE = @as(u32, 2);
pub const CDBOSC_RENAME = @as(u32, 3);
pub const CDBOSC_STATECHANGE = @as(u32, 4);
pub const CDB2N_CONTEXTMENU_DONE = @as(u32, 1);
pub const CDB2N_CONTEXTMENU_START = @as(u32, 2);
pub const CDB2GVF_SHOWALLFILES = @as(u32, 1);
pub const CDB2GVF_ISFILESAVE = @as(u32, 2);
pub const CDB2GVF_ALLOWPREVIEWPANE = @as(u32, 4);
pub const CDB2GVF_NOSELECTVERB = @as(u32, 8);
pub const CDB2GVF_NOINCLUDEITEM = @as(u32, 16);
pub const CDB2GVF_ISFOLDERPICKER = @as(u32, 32);
pub const CDB2GVF_ADDSHIELD = @as(u32, 64);
pub const SBSP_DEFBROWSER = @as(u32, 0);
pub const SBSP_SAMEBROWSER = @as(u32, 1);
pub const SBSP_NEWBROWSER = @as(u32, 2);
pub const SBSP_DEFMODE = @as(u32, 0);
pub const SBSP_OPENMODE = @as(u32, 16);
pub const SBSP_EXPLOREMODE = @as(u32, 32);
pub const SBSP_HELPMODE = @as(u32, 64);
pub const SBSP_NOTRANSFERHIST = @as(u32, 128);
pub const SBSP_ABSOLUTE = @as(u32, 0);
pub const SBSP_RELATIVE = @as(u32, 4096);
pub const SBSP_PARENT = @as(u32, 8192);
pub const SBSP_NAVIGATEBACK = @as(u32, 16384);
pub const SBSP_NAVIGATEFORWARD = @as(u32, 32768);
pub const SBSP_ALLOW_AUTONAVIGATE = @as(u32, 65536);
pub const SBSP_KEEPSAMETEMPLATE = @as(u32, 131072);
pub const SBSP_KEEPWORDWHEELTEXT = @as(u32, 262144);
pub const SBSP_ACTIVATE_NOFOCUS = @as(u32, 524288);
pub const SBSP_CREATENOHISTORY = @as(u32, 1048576);
pub const SBSP_PLAYNOSOUND = @as(u32, 2097152);
pub const SBSP_CALLERUNTRUSTED = @as(u32, 8388608);
pub const SBSP_TRUSTFIRSTDOWNLOAD = @as(u32, 16777216);
pub const SBSP_UNTRUSTEDFORDOWNLOAD = @as(u32, 33554432);
pub const SBSP_NOAUTOSELECT = @as(u32, 67108864);
pub const SBSP_WRITENOHISTORY = @as(u32, 134217728);
pub const SBSP_TRUSTEDFORACTIVEX = @as(u32, 268435456);
pub const SBSP_FEEDNAVIGATION = @as(u32, 536870912);
pub const SBSP_REDIRECT = @as(u32, 1073741824);
pub const SBSP_INITIATEDBYHLINKFRAME = @as(u32, 2147483648);
pub const FCW_STATUS = @as(u32, 1);
pub const FCW_TOOLBAR = @as(u32, 2);
pub const FCW_TREE = @as(u32, 3);
pub const FCW_INTERNETBAR = @as(u32, 6);
pub const FCW_PROGRESS = @as(u32, 8);
pub const FCT_MERGE = @as(u32, 1);
pub const FCT_CONFIGABLE = @as(u32, 2);
pub const FCT_ADDTOEND = @as(u32, 4);
pub const ARCONTENT_AUTORUNINF = @as(u32, 2);
pub const ARCONTENT_AUDIOCD = @as(u32, 4);
pub const ARCONTENT_DVDMOVIE = @as(u32, 8);
pub const ARCONTENT_BLANKCD = @as(u32, 16);
pub const ARCONTENT_BLANKDVD = @as(u32, 32);
pub const ARCONTENT_UNKNOWNCONTENT = @as(u32, 64);
pub const ARCONTENT_AUTOPLAYPIX = @as(u32, 128);
pub const ARCONTENT_AUTOPLAYMUSIC = @as(u32, 256);
pub const ARCONTENT_AUTOPLAYVIDEO = @as(u32, 512);
pub const ARCONTENT_VCD = @as(u32, 1024);
pub const ARCONTENT_SVCD = @as(u32, 2048);
pub const ARCONTENT_DVDAUDIO = @as(u32, 4096);
pub const ARCONTENT_BLANKBD = @as(u32, 8192);
pub const ARCONTENT_BLURAY = @as(u32, 16384);
pub const ARCONTENT_CAMERASTORAGE = @as(u32, 32768);
pub const ARCONTENT_CUSTOMEVENT = @as(u32, 65536);
pub const ARCONTENT_NONE = @as(u32, 0);
pub const ARCONTENT_MASK = @as(u32, 131070);
pub const ARCONTENT_PHASE_UNKNOWN = @as(u32, 0);
pub const ARCONTENT_PHASE_PRESNIFF = @as(u32, 268435456);
pub const ARCONTENT_PHASE_SNIFFING = @as(u32, 536870912);
pub const ARCONTENT_PHASE_FINAL = @as(u32, 1073741824);
pub const ARCONTENT_PHASE_MASK = @as(u32, 1879048192);
pub const IEI_PRIORITY_MAX = @as(u32, 2147483647);
pub const IEI_PRIORITY_MIN = @as(u32, 0);
pub const IEIT_PRIORITY_NORMAL = @as(u32, 268435456);
pub const IEIFLAG_ASYNC = @as(u32, 1);
pub const IEIFLAG_CACHE = @as(u32, 2);
pub const IEIFLAG_ASPECT = @as(u32, 4);
pub const IEIFLAG_OFFLINE = @as(u32, 8);
pub const IEIFLAG_GLEAM = @as(u32, 16);
pub const IEIFLAG_SCREEN = @as(u32, 32);
pub const IEIFLAG_ORIGSIZE = @as(u32, 64);
pub const IEIFLAG_NOSTAMP = @as(u32, 128);
pub const IEIFLAG_NOBORDER = @as(u32, 256);
pub const IEIFLAG_QUALITY = @as(u32, 512);
pub const IEIFLAG_REFRESH = @as(u32, 1024);
pub const DBIM_MINSIZE = @as(u32, 1);
pub const DBIM_MAXSIZE = @as(u32, 2);
pub const DBIM_INTEGRAL = @as(u32, 4);
pub const DBIM_ACTUAL = @as(u32, 8);
pub const DBIM_TITLE = @as(u32, 16);
pub const DBIM_MODEFLAGS = @as(u32, 32);
pub const DBIM_BKCOLOR = @as(u32, 64);
pub const DBIMF_NORMAL = @as(u32, 0);
pub const DBIMF_FIXED = @as(u32, 1);
pub const DBIMF_FIXEDBMP = @as(u32, 4);
pub const DBIMF_VARIABLEHEIGHT = @as(u32, 8);
pub const DBIMF_UNDELETEABLE = @as(u32, 16);
pub const DBIMF_DEBOSSED = @as(u32, 32);
pub const DBIMF_BKCOLOR = @as(u32, 64);
pub const DBIMF_USECHEVRON = @as(u32, 128);
pub const DBIMF_BREAK = @as(u32, 256);
pub const DBIMF_ADDTOFRONT = @as(u32, 512);
pub const DBIMF_TOPALIGN = @as(u32, 1024);
pub const DBIMF_NOGRIPPER = @as(u32, 2048);
pub const DBIMF_ALWAYSGRIPPER = @as(u32, 4096);
pub const DBIMF_NOMARGINS = @as(u32, 8192);
pub const DBIF_VIEWMODE_NORMAL = @as(u32, 0);
pub const DBIF_VIEWMODE_VERTICAL = @as(u32, 1);
pub const DBIF_VIEWMODE_FLOATING = @as(u32, 2);
pub const DBIF_VIEWMODE_TRANSPARENT = @as(u32, 4);
pub const DBPC_SELECTFIRST = @as(u32, 4294967295);
pub const THBN_CLICKED = @as(u32, 6144);
pub const FOFX_NOSKIPJUNCTIONS = @as(u32, 65536);
pub const FOFX_PREFERHARDLINK = @as(u32, 131072);
pub const FOFX_SHOWELEVATIONPROMPT = @as(u32, 262144);
pub const FOFX_RECYCLEONDELETE = @as(u32, 524288);
pub const FOFX_EARLYFAILURE = @as(u32, 1048576);
pub const FOFX_PRESERVEFILEEXTENSIONS = @as(u32, 2097152);
pub const FOFX_KEEPNEWERFILE = @as(u32, 4194304);
pub const FOFX_NOCOPYHOOKS = @as(u32, 8388608);
pub const FOFX_NOMINIMIZEBOX = @as(u32, 16777216);
pub const FOFX_MOVEACLSACROSSVOLUMES = @as(u32, 33554432);
pub const FOFX_DONTDISPLAYSOURCEPATH = @as(u32, 67108864);
pub const FOFX_DONTDISPLAYDESTPATH = @as(u32, 134217728);
pub const FOFX_REQUIREELEVATION = @as(u32, 268435456);
pub const FOFX_ADDUNDORECORD = @as(u32, 536870912);
pub const FOFX_COPYASDOWNLOAD = @as(u32, 1073741824);
pub const FOFX_DONTDISPLAYLOCATIONS = @as(u32, 2147483648);
pub const BSIM_STATE = @as(u32, 1);
pub const BSIM_STYLE = @as(u32, 2);
pub const BSSF_VISIBLE = @as(u32, 1);
pub const BSSF_NOTITLE = @as(u32, 2);
pub const BSSF_UNDELETEABLE = @as(u32, 4096);
pub const BSIS_AUTOGRIPPER = @as(u32, 0);
pub const BSIS_NOGRIPPER = @as(u32, 1);
pub const BSIS_ALWAYSGRIPPER = @as(u32, 2);
pub const BSIS_LEFTALIGN = @as(u32, 4);
pub const BSIS_SINGLECLICK = @as(u32, 8);
pub const BSIS_NOCONTEXTMENU = @as(u32, 16);
pub const BSIS_NODROPTARGET = @as(u32, 32);
pub const BSIS_NOCAPTION = @as(u32, 64);
pub const BSIS_PREFERNOLINEBREAK = @as(u32, 128);
pub const BSIS_LOCKED = @as(u32, 256);
pub const BSIS_PRESERVEORDERDURINGLAYOUT = @as(u32, 512);
pub const BSIS_FIXEDORDER = @as(u32, 1024);
pub const OF_CAP_CANSWITCHTO = @as(u32, 1);
pub const OF_CAP_CANCLOSE = @as(u32, 2);
pub const SMDM_SHELLFOLDER = @as(u32, 1);
pub const SMDM_HMENU = @as(u32, 2);
pub const SMDM_TOOLBAR = @as(u32, 4);
pub const SMC_INITMENU = @as(u32, 1);
pub const SMC_CREATE = @as(u32, 2);
pub const SMC_EXITMENU = @as(u32, 3);
pub const SMC_GETINFO = @as(u32, 5);
pub const SMC_GETSFINFO = @as(u32, 6);
pub const SMC_GETOBJECT = @as(u32, 7);
pub const SMC_GETSFOBJECT = @as(u32, 8);
pub const SMC_SFEXEC = @as(u32, 9);
pub const SMC_SFSELECTITEM = @as(u32, 10);
pub const SMC_REFRESH = @as(u32, 16);
pub const SMC_DEMOTE = @as(u32, 17);
pub const SMC_PROMOTE = @as(u32, 18);
pub const SMC_DEFAULTICON = @as(u32, 22);
pub const SMC_NEWITEM = @as(u32, 23);
pub const SMC_CHEVRONEXPAND = @as(u32, 25);
pub const SMC_DISPLAYCHEVRONTIP = @as(u32, 42);
pub const SMC_SETSFOBJECT = @as(u32, 45);
pub const SMC_SHCHANGENOTIFY = @as(u32, 46);
pub const SMC_CHEVRONGETTIP = @as(u32, 47);
pub const SMC_SFDDRESTRICTED = @as(u32, 48);
pub const SMC_SFEXEC_MIDDLE = @as(u32, 49);
pub const SMC_GETAUTOEXPANDSTATE = @as(u32, 65);
pub const SMC_AUTOEXPANDCHANGE = @as(u32, 66);
pub const SMC_GETCONTEXTMENUMODIFIER = @as(u32, 67);
pub const SMC_GETBKCONTEXTMENU = @as(u32, 68);
pub const SMC_OPEN = @as(u32, 69);
pub const SMAE_EXPANDED = @as(u32, 1);
pub const SMAE_CONTRACTED = @as(u32, 2);
pub const SMAE_USER = @as(u32, 4);
pub const SMAE_VALID = @as(u32, 7);
pub const SMINIT_DEFAULT = @as(u32, 0);
pub const SMINIT_RESTRICT_DRAGDROP = @as(u32, 2);
pub const SMINIT_TOPLEVEL = @as(u32, 4);
pub const SMINIT_CACHED = @as(u32, 16);
pub const SMINIT_AUTOEXPAND = @as(u32, 256);
pub const SMINIT_AUTOTOOLTIP = @as(u32, 512);
pub const SMINIT_DROPONCONTAINER = @as(u32, 1024);
pub const SMINIT_VERTICAL = @as(u32, 268435456);
pub const SMINIT_HORIZONTAL = @as(u32, 536870912);
pub const SMSET_TOP = @as(u32, 268435456);
pub const SMSET_BOTTOM = @as(u32, 536870912);
pub const SMSET_DONTOWN = @as(u32, 1);
pub const SMINV_REFRESH = @as(u32, 1);
pub const SMINV_ID = @as(u32, 8);
pub const E_PREVIEWHANDLER_DRM_FAIL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2042494975));
pub const E_PREVIEWHANDLER_NOAUTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2042494974));
pub const E_PREVIEWHANDLER_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2042494973));
pub const E_PREVIEWHANDLER_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2042494972));
pub const SID_URLExecutionContext = Guid.initString("fb5f8ebc-bbb6-4d10-a461-777291a09030");
pub const SID_LaunchSourceViewSizePreference = Guid.initString("80605492-67d9-414f-af89-a1cdf1242bc1");
pub const SID_LaunchTargetViewSizePreference = Guid.initString("26db2472-b7b7-406b-9702-730a4e20d3bf");
pub const SID_LaunchSourceAppUserModelId = Guid.initString("2ce78010-74db-48bc-9c6a-10f372495723");
pub const SID_ShellExecuteNamedPropertyStore = Guid.initString("eb84ada2-00ff-4992-8324-ed5ce061cb29");
pub const ISIOI_ICONFILE = @as(u32, 1);
pub const ISIOI_ICONINDEX = @as(u32, 2);
pub const ABM_NEW = @as(u32, 0);
pub const ABM_REMOVE = @as(u32, 1);
pub const ABM_QUERYPOS = @as(u32, 2);
pub const ABM_SETPOS = @as(u32, 3);
pub const ABM_GETSTATE = @as(u32, 4);
pub const ABM_GETTASKBARPOS = @as(u32, 5);
pub const ABM_ACTIVATE = @as(u32, 6);
pub const ABM_GETAUTOHIDEBAR = @as(u32, 7);
pub const ABM_SETAUTOHIDEBAR = @as(u32, 8);
pub const ABM_WINDOWPOSCHANGED = @as(u32, 9);
pub const ABM_SETSTATE = @as(u32, 10);
pub const ABM_GETAUTOHIDEBAREX = @as(u32, 11);
pub const ABM_SETAUTOHIDEBAREX = @as(u32, 12);
pub const ABN_STATECHANGE = @as(u32, 0);
pub const ABN_POSCHANGED = @as(u32, 1);
pub const ABN_FULLSCREENAPP = @as(u32, 2);
pub const ABN_WINDOWARRANGE = @as(u32, 3);
pub const ABS_AUTOHIDE = @as(u32, 1);
pub const ABS_ALWAYSONTOP = @as(u32, 2);
pub const ABE_LEFT = @as(u32, 0);
pub const ABE_TOP = @as(u32, 1);
pub const ABE_RIGHT = @as(u32, 2);
pub const ABE_BOTTOM = @as(u32, 3);
pub const FO_MOVE = @as(u32, 1);
pub const FO_COPY = @as(u32, 2);
pub const FO_DELETE = @as(u32, 3);
pub const FO_RENAME = @as(u32, 4);
pub const FOF_MULTIDESTFILES = @as(u32, 1);
pub const FOF_CONFIRMMOUSE = @as(u32, 2);
pub const FOF_SILENT = @as(u32, 4);
pub const FOF_RENAMEONCOLLISION = @as(u32, 8);
pub const FOF_NOCONFIRMATION = @as(u32, 16);
pub const FOF_WANTMAPPINGHANDLE = @as(u32, 32);
pub const FOF_ALLOWUNDO = @as(u32, 64);
pub const FOF_FILESONLY = @as(u32, 128);
pub const FOF_SIMPLEPROGRESS = @as(u32, 256);
pub const FOF_NOCONFIRMMKDIR = @as(u32, 512);
pub const FOF_NOERRORUI = @as(u32, 1024);
pub const FOF_NOCOPYSECURITYATTRIBS = @as(u32, 2048);
pub const FOF_NORECURSION = @as(u32, 4096);
pub const FOF_NO_CONNECTED_ELEMENTS = @as(u32, 8192);
pub const FOF_WANTNUKEWARNING = @as(u32, 16384);
pub const FOF_NORECURSEREPARSE = @as(u32, 32768);
pub const PO_DELETE = @as(u32, 19);
pub const PO_RENAME = @as(u32, 20);
pub const PO_PORTCHANGE = @as(u32, 32);
pub const PO_REN_PORT = @as(u32, 52);
pub const SE_ERR_FNF = @as(u32, 2);
pub const SE_ERR_PNF = @as(u32, 3);
pub const SE_ERR_ACCESSDENIED = @as(u32, 5);
pub const SE_ERR_OOM = @as(u32, 8);
pub const SE_ERR_DLLNOTFOUND = @as(u32, 32);
pub const SE_ERR_SHARE = @as(u32, 26);
pub const SE_ERR_ASSOCINCOMPLETE = @as(u32, 27);
pub const SE_ERR_DDETIMEOUT = @as(u32, 28);
pub const SE_ERR_DDEFAIL = @as(u32, 29);
pub const SE_ERR_DDEBUSY = @as(u32, 30);
pub const SE_ERR_NOASSOC = @as(u32, 31);
pub const SEE_MASK_DEFAULT = @as(u32, 0);
pub const SEE_MASK_CLASSNAME = @as(u32, 1);
pub const SEE_MASK_CLASSKEY = @as(u32, 3);
pub const SEE_MASK_IDLIST = @as(u32, 4);
pub const SEE_MASK_INVOKEIDLIST = @as(u32, 12);
pub const SEE_MASK_ICON = @as(u32, 16);
pub const SEE_MASK_HOTKEY = @as(u32, 32);
pub const SEE_MASK_NOCLOSEPROCESS = @as(u32, 64);
pub const SEE_MASK_CONNECTNETDRV = @as(u32, 128);
pub const SEE_MASK_NOASYNC = @as(u32, 256);
pub const SEE_MASK_FLAG_DDEWAIT = @as(u32, 256);
pub const SEE_MASK_DOENVSUBST = @as(u32, 512);
pub const SEE_MASK_FLAG_NO_UI = @as(u32, 1024);
pub const SEE_MASK_UNICODE = @as(u32, 16384);
pub const SEE_MASK_NO_CONSOLE = @as(u32, 32768);
pub const SEE_MASK_ASYNCOK = @as(u32, 1048576);
pub const SEE_MASK_HMONITOR = @as(u32, 2097152);
pub const SEE_MASK_NOZONECHECKS = @as(u32, 8388608);
pub const SEE_MASK_NOQUERYCLASSSTORE = @as(u32, 16777216);
pub const SEE_MASK_WAITFORINPUTIDLE = @as(u32, 33554432);
pub const SEE_MASK_FLAG_LOG_USAGE = @as(u32, 67108864);
pub const SEE_MASK_FLAG_HINST_IS_SITE = @as(u32, 134217728);
pub const SHERB_NOCONFIRMATION = @as(u32, 1);
pub const SHERB_NOPROGRESSUI = @as(u32, 2);
pub const SHERB_NOSOUND = @as(u32, 4);
pub const NIN_SELECT = @as(u32, 1024);
pub const NINF_KEY = @as(u32, 1);
pub const NIN_BALLOONSHOW = @as(u32, 1026);
pub const NIN_BALLOONHIDE = @as(u32, 1027);
pub const NIN_BALLOONTIMEOUT = @as(u32, 1028);
pub const NIN_BALLOONUSERCLICK = @as(u32, 1029);
pub const NIN_POPUPOPEN = @as(u32, 1030);
pub const NIN_POPUPCLOSE = @as(u32, 1031);
pub const NOTIFYICON_VERSION = @as(u32, 3);
pub const NOTIFYICON_VERSION_4 = @as(u32, 4);
pub const NIS_HIDDEN = @as(u32, 1);
pub const NIS_SHAREDICON = @as(u32, 2);
pub const NIIF_NONE = @as(u32, 0);
pub const NIIF_INFO = @as(u32, 1);
pub const NIIF_WARNING = @as(u32, 2);
pub const NIIF_ERROR = @as(u32, 3);
pub const NIIF_USER = @as(u32, 4);
pub const NIIF_ICON_MASK = @as(u32, 15);
pub const NIIF_NOSOUND = @as(u32, 16);
pub const NIIF_LARGE_ICON = @as(u32, 32);
pub const NIIF_RESPECT_QUIET_TIME = @as(u32, 128);
pub const SHGSI_ICONLOCATION = @as(u32, 0);
pub const SHGNLI_PIDL = @as(u64, 1);
pub const SHGNLI_PREFIXNAME = @as(u64, 2);
pub const SHGNLI_NOUNIQUE = @as(u64, 4);
pub const SHGNLI_NOLNK = @as(u64, 8);
pub const SHGNLI_NOLOCNAME = @as(u64, 16);
pub const SHGNLI_USEURLEXT = @as(u64, 32);
pub const PRINTACTION_OPEN = @as(u32, 0);
pub const PRINTACTION_PROPERTIES = @as(u32, 1);
pub const PRINTACTION_NETINSTALL = @as(u32, 2);
pub const PRINTACTION_NETINSTALLLINK = @as(u32, 3);
pub const PRINTACTION_TESTPAGE = @as(u32, 4);
pub const PRINTACTION_OPENNETPRN = @as(u32, 5);
pub const PRINTACTION_DOCUMENTDEFAULTS = @as(u32, 6);
pub const PRINTACTION_SERVERPROPERTIES = @as(u32, 7);
pub const PRINT_PROP_FORCE_NAME = @as(u32, 1);
pub const OFFLINE_STATUS_LOCAL = @as(u32, 1);
pub const OFFLINE_STATUS_REMOTE = @as(u32, 2);
pub const OFFLINE_STATUS_INCOMPLETE = @as(u32, 4);
pub const SHIL_LARGE = @as(u32, 0);
pub const SHIL_SMALL = @as(u32, 1);
pub const SHIL_EXTRALARGE = @as(u32, 2);
pub const SHIL_SYSSMALL = @as(u32, 3);
pub const SHIL_JUMBO = @as(u32, 4);
pub const SHIL_LAST = @as(u32, 4);
pub const NCM_GETADDRESS = @as(u32, 1025);
pub const NCM_SETALLOWTYPE = @as(u32, 1026);
pub const NCM_GETALLOWTYPE = @as(u32, 1027);
pub const NCM_DISPLAYERRORTIP = @as(u32, 1028);
pub const CREDENTIAL_PROVIDER_NO_DEFAULT = @as(u32, 4294967295);
pub const Identity_LocalUserProvider = Guid.initString("a198529b-730f-4089-b646-a12557f5665e");
pub const MAX_SYNCMGR_ID = @as(u32, 64);
pub const MAX_SYNCMGR_PROGRESSTEXT = @as(u32, 260);
pub const MAX_SYNCMGR_NAME = @as(u32, 128);
pub const STIF_DEFAULT = @as(i32, 0);
pub const STIF_SUPPORT_HEX = @as(i32, 1);
pub const GCT_INVALID = @as(u32, 0);
pub const GCT_LFNCHAR = @as(u32, 1);
pub const GCT_SHORTCHAR = @as(u32, 2);
pub const GCT_WILD = @as(u32, 4);
pub const GCT_SEPARATOR = @as(u32, 8);
pub const PMSF_NORMAL = @as(u32, 0);
pub const PMSF_MULTIPLE = @as(u32, 1);
pub const PMSF_DONT_STRIP_SPACES = @as(u32, 65536);
pub const URL_UNESCAPE = @as(u32, 268435456);
pub const URL_ESCAPE_UNSAFE = @as(u32, 536870912);
pub const URL_PLUGGABLE_PROTOCOL = @as(u32, 1073741824);
pub const URL_WININET_COMPATIBILITY = @as(u32, 2147483648);
pub const URL_DONT_ESCAPE_EXTRA_INFO = @as(u32, 33554432);
pub const URL_DONT_UNESCAPE_EXTRA_INFO = @as(u32, 33554432);
pub const URL_BROWSER_MODE = @as(u32, 33554432);
pub const URL_ESCAPE_SPACES_ONLY = @as(u32, 67108864);
pub const URL_DONT_SIMPLIFY = @as(u32, 134217728);
pub const URL_NO_META = @as(u32, 134217728);
pub const URL_UNESCAPE_INPLACE = @as(u32, 1048576);
pub const URL_CONVERT_IF_DOSPATH = @as(u32, 2097152);
pub const URL_UNESCAPE_HIGH_ANSI_ONLY = @as(u32, 4194304);
pub const URL_INTERNAL_PATH = @as(u32, 8388608);
pub const URL_FILE_USE_PATHURL = @as(u32, 65536);
pub const URL_DONT_UNESCAPE = @as(u32, 131072);
pub const URL_ESCAPE_AS_UTF8 = @as(u32, 262144);
pub const URL_UNESCAPE_AS_UTF8 = @as(u32, 262144);
pub const URL_ESCAPE_ASCII_URI_COMPONENT = @as(u32, 524288);
pub const URL_UNESCAPE_URI_COMPONENT = @as(u32, 262144);
pub const URL_ESCAPE_PERCENT = @as(u32, 4096);
pub const URL_ESCAPE_SEGMENT_ONLY = @as(u32, 8192);
pub const URL_PARTFLAG_KEEPSCHEME = @as(u32, 1);
pub const URL_APPLY_DEFAULT = @as(u32, 1);
pub const URL_APPLY_GUESSSCHEME = @as(u32, 2);
pub const URL_APPLY_GUESSFILE = @as(u32, 4);
pub const URL_APPLY_FORCEAPPLY = @as(u32, 8);
pub const SRRF_RT_REG_NONE = @as(u32, 1);
pub const SRRF_RT_REG_SZ = @as(u32, 2);
pub const SRRF_RT_REG_EXPAND_SZ = @as(u32, 4);
pub const SRRF_RT_REG_BINARY = @as(u32, 8);
pub const SRRF_RT_REG_DWORD = @as(u32, 16);
pub const SRRF_RT_REG_MULTI_SZ = @as(u32, 32);
pub const SRRF_RT_REG_QWORD = @as(u32, 64);
pub const SRRF_RT_ANY = @as(u32, 65535);
pub const SRRF_RM_ANY = @as(u32, 0);
pub const SRRF_RM_NORMAL = @as(u32, 65536);
pub const SRRF_RM_SAFE = @as(u32, 131072);
pub const SRRF_RM_SAFENETWORK = @as(u32, 262144);
pub const SRRF_NOEXPAND = @as(u32, 268435456);
pub const SRRF_ZEROONFAILURE = @as(u32, 536870912);
pub const SRRF_NOVIRT = @as(u32, 1073741824);
pub const SHREGSET_HKCU = @as(u32, 1);
pub const SHREGSET_FORCE_HKCU = @as(u32, 2);
pub const SHREGSET_HKLM = @as(u32, 4);
pub const SHREGSET_FORCE_HKLM = @as(u32, 8);
pub const SPMODE_SHELL = @as(u32, 1);
pub const SPMODE_DEBUGOUT = @as(u32, 2);
pub const SPMODE_TEST = @as(u32, 4);
pub const SPMODE_BROWSER = @as(u32, 8);
pub const SPMODE_FLUSH = @as(u32, 16);
pub const SPMODE_EVENT = @as(u32, 32);
pub const SPMODE_MSVM = @as(u32, 64);
pub const SPMODE_FORMATTEXT = @as(u32, 128);
pub const SPMODE_PROFILE = @as(u32, 256);
pub const SPMODE_DEBUGBREAK = @as(u32, 512);
pub const SPMODE_MSGTRACE = @as(u32, 1024);
pub const SPMODE_PERFTAGS = @as(u32, 2048);
pub const SPMODE_MEMWATCH = @as(u32, 4096);
pub const SPMODE_DBMON = @as(u32, 8192);
pub const SPMODE_MULTISTOP = @as(u32, 16384);
pub const SPMODE_EVENTTRACE = @as(u32, 32768);
pub const SHGVSPB_PERUSER = @as(u32, 1);
pub const SHGVSPB_ALLUSERS = @as(u32, 2);
pub const SHGVSPB_PERFOLDER = @as(u32, 4);
pub const SHGVSPB_ALLFOLDERS = @as(u32, 8);
pub const SHGVSPB_INHERIT = @as(u32, 16);
pub const SHGVSPB_ROAM = @as(u32, 32);
pub const SHGVSPB_NOAUTODEFAULTS = @as(u32, 2147483648);
pub const FDTF_SHORTTIME = @as(u32, 1);
pub const FDTF_SHORTDATE = @as(u32, 2);
pub const FDTF_LONGDATE = @as(u32, 4);
pub const FDTF_LONGTIME = @as(u32, 8);
pub const FDTF_RELATIVE = @as(u32, 16);
pub const FDTF_LTRDATE = @as(u32, 256);
pub const FDTF_RTLDATE = @as(u32, 512);
pub const FDTF_NOAUTOREADINGORDER = @as(u32, 1024);
pub const PLATFORM_UNKNOWN = @as(u32, 0);
pub const PLATFORM_IE3 = @as(u32, 1);
pub const PLATFORM_BROWSERONLY = @as(u32, 1);
pub const PLATFORM_INTEGRATED = @as(u32, 2);
pub const ILMM_IE4 = @as(u32, 0);
pub const SHACF_DEFAULT = @as(u32, 0);
pub const SHACF_FILESYSTEM = @as(u32, 1);
pub const SHACF_URLHISTORY = @as(u32, 2);
pub const SHACF_URLMRU = @as(u32, 4);
pub const SHACF_USETAB = @as(u32, 8);
pub const SHACF_FILESYS_ONLY = @as(u32, 16);
pub const SHACF_FILESYS_DIRS = @as(u32, 32);
pub const SHACF_VIRTUAL_NAMESPACE = @as(u32, 64);
pub const SHACF_AUTOSUGGEST_FORCE_ON = @as(u32, 268435456);
pub const SHACF_AUTOSUGGEST_FORCE_OFF = @as(u32, 536870912);
pub const SHACF_AUTOAPPEND_FORCE_ON = @as(u32, 1073741824);
pub const SHACF_AUTOAPPEND_FORCE_OFF = @as(u32, 2147483648);
pub const DLLVER_PLATFORM_WINDOWS = @as(u32, 1);
pub const DLLVER_PLATFORM_NT = @as(u32, 2);
pub const DLLVER_MAJOR_MASK = @as(u64, 18446462598732840960);
pub const DLLVER_MINOR_MASK = @as(u64, 281470681743360);
pub const DLLVER_BUILD_MASK = @as(u64, 4294901760);
pub const DLLVER_QFE_MASK = @as(u64, 65535);
pub const WTS_E_FAILEDEXTRACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175936));
pub const WTS_E_EXTRACTIONTIMEDOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175935));
pub const WTS_E_SURROGATEUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175934));
pub const WTS_E_FASTEXTRACTIONNOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175933));
pub const WTS_E_DATAFILEUNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175932));
pub const WTS_E_EXTRACTIONPENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175931));
pub const WTS_E_EXTRACTIONBLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175930));
pub const WTS_E_NOSTORAGEPROVIDERTHUMBNAILHANDLER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147175929));
pub const SHIMGDEC_DEFAULT = @as(u32, 0);
pub const SHIMGDEC_THUMBNAIL = @as(u32, 1);
pub const SHIMGDEC_LOADFULL = @as(u32, 2);
pub const E_NOTVALIDFORANIMATEDIMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147221503));
pub const S_SYNCMGR_MISSINGITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const S_SYNCMGR_RETRYSYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262658));
pub const S_SYNCMGR_CANCELITEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262659));
pub const S_SYNCMGR_CANCELALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262660));
pub const S_SYNCMGR_ITEMDELETED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262672));
pub const S_SYNCMGR_ENUMITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262673));
pub const SYNCMGRPROGRESSITEM_STATUSTEXT = @as(u32, 1);
pub const SYNCMGRPROGRESSITEM_STATUSTYPE = @as(u32, 2);
pub const SYNCMGRPROGRESSITEM_PROGVALUE = @as(u32, 4);
pub const SYNCMGRPROGRESSITEM_MAXVALUE = @as(u32, 8);
pub const SYNCMGRLOGERROR_ERRORFLAGS = @as(u32, 1);
pub const SYNCMGRLOGERROR_ERRORID = @as(u32, 2);
pub const SYNCMGRLOGERROR_ITEMID = @as(u32, 4);
pub const SYNCMGRITEM_ITEMFLAGMASK = @as(u32, 127);
pub const MAX_SYNCMGRITEMNAME = @as(u32, 128);
pub const SYNCMGRHANDLERFLAG_MASK = @as(u32, 15);
pub const MAX_SYNCMGRHANDLERNAME = @as(u32, 32);
pub const SYNCMGRREGISTERFLAGS_MASK = @as(u32, 7);
pub const TLOG_BACK = @as(i32, -1);
pub const TLOG_CURRENT = @as(u32, 0);
pub const TLOG_FORE = @as(u32, 1);
pub const TLMENUF_INCLUDECURRENT = @as(u32, 1);
pub const TLMENUF_BACK = @as(u32, 16);
pub const TLMENUF_FORE = @as(u32, 32);
pub const BSF_REGISTERASDROPTARGET = @as(u32, 1);
pub const BSF_THEATERMODE = @as(u32, 2);
pub const BSF_NOLOCALFILEWARNING = @as(u32, 16);
pub const BSF_UISETBYAUTOMATION = @as(u32, 256);
pub const BSF_RESIZABLE = @as(u32, 512);
pub const BSF_CANMAXIMIZE = @as(u32, 1024);
pub const BSF_TOPBROWSER = @as(u32, 2048);
pub const BSF_NAVNOHISTORY = @as(u32, 4096);
pub const BSF_HTMLNAVCANCELED = @as(u32, 8192);
pub const BSF_DONTSHOWNAVCANCELPAGE = @as(u32, 16384);
pub const BSF_SETNAVIGATABLECODEPAGE = @as(u32, 32768);
pub const BSF_DELEGATEDNAVIGATION = @as(u32, 65536);
pub const BSF_TRUSTEDFORACTIVEX = @as(u32, 131072);
pub const BSF_MERGEDMENUS = @as(u32, 262144);
pub const BSF_FEEDNAVIGATION = @as(u32, 524288);
pub const BSF_FEEDSUBSCRIBED = @as(u32, 1048576);
pub const HLNF_CALLERUNTRUSTED = @as(u32, 2097152);
pub const HLNF_TRUSTEDFORACTIVEX = @as(u32, 4194304);
pub const HLNF_DISABLEWINDOWRESTRICTIONS = @as(u32, 8388608);
pub const HLNF_TRUSTFIRSTDOWNLOAD = @as(u32, 16777216);
pub const HLNF_UNTRUSTEDFORDOWNLOAD = @as(u32, 33554432);
pub const SHHLNF_NOAUTOSELECT = @as(u32, 67108864);
pub const SHHLNF_WRITENOHISTORY = @as(u32, 134217728);
pub const HLNF_EXTERNALNAVIGATE = @as(u32, 268435456);
pub const HLNF_ALLOW_AUTONAVIGATE = @as(u32, 536870912);
pub const HLNF_NEWWINDOWSMANAGED = @as(u32, 2147483648);
pub const INTERNET_MAX_PATH_LENGTH = @as(u32, 2048);
pub const INTERNET_MAX_SCHEME_LENGTH = @as(u32, 32);
pub const VIEW_PRIORITY_RESTRICTED = @as(u32, 112);
pub const VIEW_PRIORITY_CACHEHIT = @as(u32, 80);
pub const VIEW_PRIORITY_STALECACHEHIT = @as(u32, 69);
pub const VIEW_PRIORITY_USEASDEFAULT = @as(u32, 67);
pub const VIEW_PRIORITY_SHELLEXT = @as(u32, 64);
pub const VIEW_PRIORITY_CACHEMISS = @as(u32, 48);
pub const VIEW_PRIORITY_INHERIT = @as(u32, 32);
pub const VIEW_PRIORITY_SHELLEXT_ASBACKUP = @as(u32, 21);
pub const VIEW_PRIORITY_DESPERATE = @as(u32, 16);
pub const VIEW_PRIORITY_NONE = @as(u32, 0);
pub const PATHCCH_MAX_CCH = @as(u32, 32768);
pub const IDS_DESCRIPTION = @as(u32, 1);
pub const ID_APP = @as(u32, 100);
pub const DLG_SCRNSAVECONFIGURE = @as(u32, 2003);
pub const MAXFILELEN = @as(u32, 13);
pub const TITLEBARNAMELEN = @as(u32, 40);
pub const APPNAMEBUFFERLEN = @as(u32, 40);
pub const BUFFLEN = @as(u32, 255);
pub const SCRM_VERIFYPW = @as(u32, 32768);
pub const E_FLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217408));
pub const IS_E_EXEC_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147213310));
pub const URL_E_INVALID_SYNTAX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217407));
pub const URL_E_UNREGISTERED_PROTOCOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217406));
pub const CPLPAGE_MOUSE_BUTTONS = @as(u32, 1);
pub const CPLPAGE_MOUSE_PTRMOTION = @as(u32, 2);
pub const CPLPAGE_MOUSE_WHEEL = @as(u32, 3);
pub const CPLPAGE_KEYBOARD_SPEED = @as(u32, 1);
pub const CPLPAGE_DISPLAY_BACKGROUND = @as(u32, 1);
pub const DISPID_SELECTIONCHANGED = @as(u32, 200);
pub const DISPID_FILELISTENUMDONE = @as(u32, 201);
pub const DISPID_VERBINVOKED = @as(u32, 202);
pub const DISPID_DEFAULTVERBINVOKED = @as(u32, 203);
pub const DISPID_BEGINDRAG = @as(u32, 204);
pub const DISPID_VIEWMODECHANGED = @as(u32, 205);
pub const DISPID_NOITEMSTATE_CHANGED = @as(u32, 206);
pub const DISPID_CONTENTSCHANGED = @as(u32, 207);
pub const DISPID_FOCUSCHANGED = @as(u32, 208);
pub const DISPID_CHECKSTATECHANGED = @as(u32, 209);
pub const DISPID_ORDERCHANGED = @as(u32, 210);
pub const DISPID_VIEWPAINTDONE = @as(u32, 211);
pub const DISPID_COLUMNSCHANGED = @as(u32, 212);
pub const DISPID_CTRLMOUSEWHEEL = @as(u32, 213);
pub const DISPID_SORTDONE = @as(u32, 214);
pub const DISPID_ICONSIZECHANGED = @as(u32, 215);
pub const DISPID_FOLDERCHANGED = @as(u32, 217);
pub const DISPID_FILTERINVOKED = @as(u32, 218);
pub const DISPID_WORDWHEELEDITED = @as(u32, 219);
pub const DISPID_SELECTEDITEMCHANGED = @as(u32, 220);
pub const DISPID_EXPLORERWINDOWREADY = @as(u32, 221);
pub const DISPID_UPDATEIMAGE = @as(u32, 222);
pub const DISPID_INITIALENUMERATIONDONE = @as(u32, 223);
pub const DISPID_ENTERPRISEIDCHANGED = @as(u32, 224);
pub const DISPID_ENTERPRESSED = @as(u32, 200);
pub const DISPID_SEARCHCOMMAND_START = @as(u32, 1);
pub const DISPID_SEARCHCOMMAND_COMPLETE = @as(u32, 2);
pub const DISPID_SEARCHCOMMAND_ABORT = @as(u32, 3);
pub const DISPID_SEARCHCOMMAND_UPDATE = @as(u32, 4);
pub const DISPID_SEARCHCOMMAND_PROGRESSTEXT = @as(u32, 5);
pub const DISPID_SEARCHCOMMAND_ERROR = @as(u32, 6);
pub const DISPID_SEARCHCOMMAND_RESTORE = @as(u32, 7);
pub const DISPID_IADCCTL_DIRTY = @as(u32, 256);
pub const DISPID_IADCCTL_PUBCAT = @as(u32, 257);
pub const DISPID_IADCCTL_SORT = @as(u32, 258);
pub const DISPID_IADCCTL_FORCEX86 = @as(u32, 259);
pub const DISPID_IADCCTL_SHOWPOSTSETUP = @as(u32, 260);
pub const DISPID_IADCCTL_ONDOMAIN = @as(u32, 261);
pub const DISPID_IADCCTL_DEFAULTCAT = @as(u32, 262);
pub const COPYENGINE_S_YES = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555905));
pub const COPYENGINE_S_NOT_HANDLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555907));
pub const COPYENGINE_S_USER_RETRY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555908));
pub const COPYENGINE_S_USER_IGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555909));
pub const COPYENGINE_S_MERGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555910));
pub const COPYENGINE_S_DONT_PROCESS_CHILDREN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555912));
pub const COPYENGINE_S_ALREADY_DONE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555914));
pub const COPYENGINE_S_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555915));
pub const COPYENGINE_S_KEEP_BOTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555916));
pub const COPYENGINE_S_CLOSE_PROGRAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555917));
pub const COPYENGINE_S_COLLISIONRESOLVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555918));
pub const COPYENGINE_S_PROGRESS_PAUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, 2555919));
pub const COPYENGINE_E_USER_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927744));
pub const COPYENGINE_E_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927743));
pub const COPYENGINE_E_REQUIRES_ELEVATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927742));
pub const COPYENGINE_E_SAME_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927741));
pub const COPYENGINE_E_DIFF_DIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927740));
pub const COPYENGINE_E_MANY_SRC_1_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927739));
pub const COPYENGINE_E_DEST_SUBTREE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927735));
pub const COPYENGINE_E_DEST_SAME_TREE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927734));
pub const COPYENGINE_E_FLD_IS_FILE_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927733));
pub const COPYENGINE_E_FILE_IS_FLD_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927732));
pub const COPYENGINE_E_FILE_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927731));
pub const COPYENGINE_E_REMOVABLE_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927730));
pub const COPYENGINE_E_DEST_IS_RO_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927729));
pub const COPYENGINE_E_DEST_IS_RW_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927728));
pub const COPYENGINE_E_DEST_IS_R_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927727));
pub const COPYENGINE_E_DEST_IS_RO_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927726));
pub const COPYENGINE_E_DEST_IS_RW_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927725));
pub const COPYENGINE_E_DEST_IS_R_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927724));
pub const COPYENGINE_E_SRC_IS_RO_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927723));
pub const COPYENGINE_E_SRC_IS_RW_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927722));
pub const COPYENGINE_E_SRC_IS_R_CD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927721));
pub const COPYENGINE_E_SRC_IS_RO_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927720));
pub const COPYENGINE_E_SRC_IS_RW_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927719));
pub const COPYENGINE_E_SRC_IS_R_DVD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927718));
pub const COPYENGINE_E_INVALID_FILES_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927717));
pub const COPYENGINE_E_INVALID_FILES_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927716));
pub const COPYENGINE_E_PATH_TOO_DEEP_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927715));
pub const COPYENGINE_E_PATH_TOO_DEEP_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927714));
pub const COPYENGINE_E_ROOT_DIR_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927713));
pub const COPYENGINE_E_ROOT_DIR_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927712));
pub const COPYENGINE_E_ACCESS_DENIED_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927711));
pub const COPYENGINE_E_ACCESS_DENIED_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927710));
pub const COPYENGINE_E_PATH_NOT_FOUND_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927709));
pub const COPYENGINE_E_PATH_NOT_FOUND_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927708));
pub const COPYENGINE_E_NET_DISCONNECT_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927707));
pub const COPYENGINE_E_NET_DISCONNECT_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927706));
pub const COPYENGINE_E_SHARING_VIOLATION_SRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927705));
pub const COPYENGINE_E_SHARING_VIOLATION_DEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927704));
pub const COPYENGINE_E_ALREADY_EXISTS_NORMAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927703));
pub const COPYENGINE_E_ALREADY_EXISTS_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927702));
pub const COPYENGINE_E_ALREADY_EXISTS_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927701));
pub const COPYENGINE_E_ALREADY_EXISTS_FOLDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927700));
pub const COPYENGINE_E_STREAM_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927699));
pub const COPYENGINE_E_EA_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927698));
pub const COPYENGINE_E_PROPERTY_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927697));
pub const COPYENGINE_E_PROPERTIES_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927696));
pub const COPYENGINE_E_ENCRYPTION_LOSS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927695));
pub const COPYENGINE_E_DISK_FULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927694));
pub const COPYENGINE_E_DISK_FULL_CLEAN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927693));
pub const COPYENGINE_E_EA_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927692));
pub const COPYENGINE_E_CANT_REACH_SOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927691));
pub const COPYENGINE_E_RECYCLE_UNKNOWN_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927691));
pub const COPYENGINE_E_RECYCLE_FORCE_NUKE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927690));
pub const COPYENGINE_E_RECYCLE_SIZE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927689));
pub const COPYENGINE_E_RECYCLE_PATH_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927688));
pub const COPYENGINE_E_RECYCLE_BIN_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927686));
pub const COPYENGINE_E_NEWFILE_NAME_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927685));
pub const COPYENGINE_E_NEWFOLDER_NAME_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927684));
pub const COPYENGINE_E_DIR_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927683));
pub const COPYENGINE_E_FAT_MAX_IN_ROOT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927682));
pub const COPYENGINE_E_ACCESSDENIED_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927681));
pub const COPYENGINE_E_REDIRECTED_TO_WEBPAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927680));
pub const COPYENGINE_E_SERVER_BAD_FILE_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927679));
pub const COPYENGINE_E_INTERNET_ITEM_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927678));
pub const COPYENGINE_E_CANNOT_MOVE_FROM_RECYCLE_BIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927677));
pub const COPYENGINE_E_CANNOT_MOVE_SHARED_FOLDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927676));
pub const COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927675));
pub const COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_PAUSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927674));
pub const COPYENGINE_E_REQUIRES_EDP_CONSENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927673));
pub const COPYENGINE_E_BLOCKED_BY_EDP_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927672));
pub const COPYENGINE_E_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927671));
pub const COPYENGINE_E_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927670));
pub const COPYENGINE_E_RMS_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927669));
pub const COPYENGINE_E_RMS_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927668));
pub const COPYENGINE_E_WARNED_BY_DLP_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927667));
pub const COPYENGINE_E_BLOCKED_BY_DLP_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927666));
pub const COPYENGINE_E_SILENT_FAIL_BY_DLP_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927665));
pub const NETCACHE_E_NEGATIVE_CACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927488));
pub const EXECUTE_E_LAUNCH_APPLICATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927487));
pub const SHELL_E_WRONG_BITDEPTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927486));
pub const LINK_E_DELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927485));
pub const STORE_E_NEWER_VERSION_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927484));
pub const E_FILE_PLACEHOLDER_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927472));
pub const E_FILE_PLACEHOLDER_VERSION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927471));
pub const E_FILE_PLACEHOLDER_SERVER_TIMED_OUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927470));
pub const E_FILE_PLACEHOLDER_STORAGEPROVIDER_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927469));
pub const CAMERAROLL_E_NO_DOWNSAMPLING_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927456));
pub const E_ACTIVATIONDENIED_USERCLOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927440));
pub const E_ACTIVATIONDENIED_SHELLERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927439));
pub const E_ACTIVATIONDENIED_SHELLRESTART = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927438));
pub const E_ACTIVATIONDENIED_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927437));
pub const E_ACTIVATIONDENIED_SHELLNOTREADY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927436));
pub const LIBRARY_E_NO_SAVE_LOCATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927232));
pub const LIBRARY_E_NO_ACCESSIBLE_LOCATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927231));
pub const E_USERTILE_UNSUPPORTEDFILETYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927216));
pub const E_USERTILE_CHANGEDISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927215));
pub const E_USERTILE_LARGEORDYNAMIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927214));
pub const E_USERTILE_VIDEOFRAMESIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927213));
pub const E_USERTILE_FILESIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927212));
pub const IMM_ACC_DOCKING_E_INSUFFICIENTHEIGHT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927184));
pub const IMM_ACC_DOCKING_E_DOCKOCCUPIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927183));
pub const IMSC_E_SHELL_COMPONENT_STARTUP_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927181));
pub const SHC_E_SHELL_COMPONENT_STARTUP_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927180));
pub const E_TILE_NOTIFICATIONS_PLATFORM_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144927159));
pub const E_SHELL_EXTENSION_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144926975));
pub const E_IMAGEFEED_CHANGEDISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2144926960));
pub const GPFIDL_DEFAULT = @as(i32, 0);
pub const GPFIDL_ALTNAME = @as(i32, 1);
pub const GPFIDL_UNCPRINTER = @as(i32, 2);
pub const ISHCUTCMDID_DOWNLOADICON = @as(i32, 0);
pub const ISHCUTCMDID_INTSHORTCUTCREATE = @as(i32, 1);
pub const ISHCUTCMDID_COMMITHISTORY = @as(i32, 2);
pub const ISHCUTCMDID_SETUSERAWURL = @as(i32, 3);
pub const SFBID_PIDLCHANGED = @as(i32, 0);
pub const DBCID_EMPTY = @as(i32, 0);
pub const DBCID_ONDRAG = @as(i32, 1);
pub const DBCID_CLSIDOFBAR = @as(i32, 2);
pub const DBCID_RESIZE = @as(i32, 3);
pub const DBCID_GETBAR = @as(i32, 4);
pub const DBCID_UPDATESIZE = @as(i32, 5);
pub const BMICON_LARGE = @as(i32, 0);
pub const BMICON_SMALL = @as(i32, 1);
pub const ASSOCF_NONE = @as(i32, 0);
pub const ASSOCF_INIT_NOREMAPCLSID = @as(i32, 1);
pub const ASSOCF_INIT_BYEXENAME = @as(i32, 2);
pub const ASSOCF_OPEN_BYEXENAME = @as(i32, 2);
pub const ASSOCF_INIT_DEFAULTTOSTAR = @as(i32, 4);
pub const ASSOCF_INIT_DEFAULTTOFOLDER = @as(i32, 8);
pub const ASSOCF_NOUSERSETTINGS = @as(i32, 16);
pub const ASSOCF_NOTRUNCATE = @as(i32, 32);
pub const ASSOCF_VERIFY = @as(i32, 64);
pub const ASSOCF_REMAPRUNDLL = @as(i32, 128);
pub const ASSOCF_NOFIXUPS = @as(i32, 256);
pub const ASSOCF_IGNOREBASECLASS = @as(i32, 512);
pub const ASSOCF_INIT_IGNOREUNKNOWN = @as(i32, 1024);
pub const ASSOCF_INIT_FIXED_PROGID = @as(i32, 2048);
pub const ASSOCF_IS_PROTOCOL = @as(i32, 4096);
pub const ASSOCF_INIT_FOR_FILE = @as(i32, 8192);
pub const ASSOCF_IS_FULL_URI = @as(i32, 16384);
pub const ASSOCF_PER_MACHINE_ONLY = @as(i32, 32768);
pub const ASSOCF_APP_TO_APP = @as(i32, 65536);
pub const CTF_INSIST = @as(i32, 1);
pub const CTF_THREAD_REF = @as(i32, 2);
pub const CTF_PROCESS_REF = @as(i32, 4);
pub const CTF_COINIT_STA = @as(i32, 8);
pub const CTF_COINIT = @as(i32, 8);
pub const CTF_FREELIBANDEXIT = @as(i32, 16);
pub const CTF_REF_COUNTED = @as(i32, 32);
pub const CTF_WAIT_ALLOWCOM = @as(i32, 64);
pub const CTF_UNUSED = @as(i32, 128);
pub const CTF_INHERITWOW64 = @as(i32, 256);
pub const CTF_WAIT_NO_REENTRANCY = @as(i32, 512);
pub const CTF_KEYBOARD_LOCALE = @as(i32, 1024);
pub const CTF_OLEINITIALIZE = @as(i32, 2048);
pub const CTF_COINIT_MTA = @as(i32, 4096);
pub const CTF_NOADDREFLIB = @as(i32, 8192);

//--------------------------------------------------------------------------------
// Section: Types (966)
//--------------------------------------------------------------------------------
pub const SHGFI_FLAGS = enum(i32) {
    ADDOVERLAYS = 32,
    ATTR_SPECIFIED = 131072,
    ATTRIBUTES = 2048,
    DISPLAYNAME = 512,
    EXETYPE = 8192,
    ICON = 256,
    ICONLOCATION = 4096,
    LARGEICON = 0,
    LINKOVERLAY = 32768,
    OPENICON = 2,
    OVERLAYINDEX = 64,
    PIDL = 8,
    SELECTED = 65536,
    SHELLICONSIZE = 4,
    SMALLICON = 1,
    SYSICONINDEX = 16384,
    TYPENAME = 1024,
    USEFILEATTRIBUTES = 16,
    _,
    pub fn initFlags(o: struct {
        ADDOVERLAYS: u1 = 0,
        ATTR_SPECIFIED: u1 = 0,
        ATTRIBUTES: u1 = 0,
        DISPLAYNAME: u1 = 0,
        EXETYPE: u1 = 0,
        ICON: u1 = 0,
        ICONLOCATION: u1 = 0,
        LARGEICON: u1 = 0,
        LINKOVERLAY: u1 = 0,
        OPENICON: u1 = 0,
        OVERLAYINDEX: u1 = 0,
        PIDL: u1 = 0,
        SELECTED: u1 = 0,
        SHELLICONSIZE: u1 = 0,
        SMALLICON: u1 = 0,
        SYSICONINDEX: u1 = 0,
        TYPENAME: u1 = 0,
        USEFILEATTRIBUTES: u1 = 0,
    }) SHGFI_FLAGS {
        return @intToEnum(SHGFI_FLAGS,
              (if (o.ADDOVERLAYS == 1) @enumToInt(SHGFI_FLAGS.ADDOVERLAYS) else 0)
            | (if (o.ATTR_SPECIFIED == 1) @enumToInt(SHGFI_FLAGS.ATTR_SPECIFIED) else 0)
            | (if (o.ATTRIBUTES == 1) @enumToInt(SHGFI_FLAGS.ATTRIBUTES) else 0)
            | (if (o.DISPLAYNAME == 1) @enumToInt(SHGFI_FLAGS.DISPLAYNAME) else 0)
            | (if (o.EXETYPE == 1) @enumToInt(SHGFI_FLAGS.EXETYPE) else 0)
            | (if (o.ICON == 1) @enumToInt(SHGFI_FLAGS.ICON) else 0)
            | (if (o.ICONLOCATION == 1) @enumToInt(SHGFI_FLAGS.ICONLOCATION) else 0)
            | (if (o.LARGEICON == 1) @enumToInt(SHGFI_FLAGS.LARGEICON) else 0)
            | (if (o.LINKOVERLAY == 1) @enumToInt(SHGFI_FLAGS.LINKOVERLAY) else 0)
            | (if (o.OPENICON == 1) @enumToInt(SHGFI_FLAGS.OPENICON) else 0)
            | (if (o.OVERLAYINDEX == 1) @enumToInt(SHGFI_FLAGS.OVERLAYINDEX) else 0)
            | (if (o.PIDL == 1) @enumToInt(SHGFI_FLAGS.PIDL) else 0)
            | (if (o.SELECTED == 1) @enumToInt(SHGFI_FLAGS.SELECTED) else 0)
            | (if (o.SHELLICONSIZE == 1) @enumToInt(SHGFI_FLAGS.SHELLICONSIZE) else 0)
            | (if (o.SMALLICON == 1) @enumToInt(SHGFI_FLAGS.SMALLICON) else 0)
            | (if (o.SYSICONINDEX == 1) @enumToInt(SHGFI_FLAGS.SYSICONINDEX) else 0)
            | (if (o.TYPENAME == 1) @enumToInt(SHGFI_FLAGS.TYPENAME) else 0)
            | (if (o.USEFILEATTRIBUTES == 1) @enumToInt(SHGFI_FLAGS.USEFILEATTRIBUTES) else 0)
        );
    }
};
pub const SHGFI_ADDOVERLAYS = SHGFI_FLAGS.ADDOVERLAYS;
pub const SHGFI_ATTR_SPECIFIED = SHGFI_FLAGS.ATTR_SPECIFIED;
pub const SHGFI_ATTRIBUTES = SHGFI_FLAGS.ATTRIBUTES;
pub const SHGFI_DISPLAYNAME = SHGFI_FLAGS.DISPLAYNAME;
pub const SHGFI_EXETYPE = SHGFI_FLAGS.EXETYPE;
pub const SHGFI_ICON = SHGFI_FLAGS.ICON;
pub const SHGFI_ICONLOCATION = SHGFI_FLAGS.ICONLOCATION;
pub const SHGFI_LARGEICON = SHGFI_FLAGS.LARGEICON;
pub const SHGFI_LINKOVERLAY = SHGFI_FLAGS.LINKOVERLAY;
pub const SHGFI_OPENICON = SHGFI_FLAGS.OPENICON;
pub const SHGFI_OVERLAYINDEX = SHGFI_FLAGS.OVERLAYINDEX;
pub const SHGFI_PIDL = SHGFI_FLAGS.PIDL;
pub const SHGFI_SELECTED = SHGFI_FLAGS.SELECTED;
pub const SHGFI_SHELLICONSIZE = SHGFI_FLAGS.SHELLICONSIZE;
pub const SHGFI_SMALLICON = SHGFI_FLAGS.SMALLICON;
pub const SHGFI_SYSICONINDEX = SHGFI_FLAGS.SYSICONINDEX;
pub const SHGFI_TYPENAME = SHGFI_FLAGS.TYPENAME;
pub const SHGFI_USEFILEATTRIBUTES = SHGFI_FLAGS.USEFILEATTRIBUTES;

pub const SHCNE_ID = enum(u32) {
    RENAMEITEM = 1,
    CREATE = 2,
    DELETE = 4,
    MKDIR = 8,
    RMDIR = 16,
    MEDIAINSERTED = 32,
    MEDIAREMOVED = 64,
    DRIVEREMOVED = 128,
    DRIVEADD = 256,
    NETSHARE = 512,
    NETUNSHARE = 1024,
    ATTRIBUTES = 2048,
    UPDATEDIR = 4096,
    UPDATEITEM = 8192,
    SERVERDISCONNECT = 16384,
    UPDATEIMAGE = 32768,
    DRIVEADDGUI = 65536,
    RENAMEFOLDER = 131072,
    FREESPACE = 262144,
    EXTENDED_EVENT = 67108864,
    ASSOCCHANGED = 134217728,
    DISKEVENTS = 145439,
    GLOBALEVENTS = 201687520,
    ALLEVENTS = 2147483647,
    INTERRUPT = 2147483648,
    _,
    pub fn initFlags(o: struct {
        RENAMEITEM: u1 = 0,
        CREATE: u1 = 0,
        DELETE: u1 = 0,
        MKDIR: u1 = 0,
        RMDIR: u1 = 0,
        MEDIAINSERTED: u1 = 0,
        MEDIAREMOVED: u1 = 0,
        DRIVEREMOVED: u1 = 0,
        DRIVEADD: u1 = 0,
        NETSHARE: u1 = 0,
        NETUNSHARE: u1 = 0,
        ATTRIBUTES: u1 = 0,
        UPDATEDIR: u1 = 0,
        UPDATEITEM: u1 = 0,
        SERVERDISCONNECT: u1 = 0,
        UPDATEIMAGE: u1 = 0,
        DRIVEADDGUI: u1 = 0,
        RENAMEFOLDER: u1 = 0,
        FREESPACE: u1 = 0,
        EXTENDED_EVENT: u1 = 0,
        ASSOCCHANGED: u1 = 0,
        DISKEVENTS: u1 = 0,
        GLOBALEVENTS: u1 = 0,
        ALLEVENTS: u1 = 0,
        INTERRUPT: u1 = 0,
    }) SHCNE_ID {
        return @intToEnum(SHCNE_ID,
              (if (o.RENAMEITEM == 1) @enumToInt(SHCNE_ID.RENAMEITEM) else 0)
            | (if (o.CREATE == 1) @enumToInt(SHCNE_ID.CREATE) else 0)
            | (if (o.DELETE == 1) @enumToInt(SHCNE_ID.DELETE) else 0)
            | (if (o.MKDIR == 1) @enumToInt(SHCNE_ID.MKDIR) else 0)
            | (if (o.RMDIR == 1) @enumToInt(SHCNE_ID.RMDIR) else 0)
            | (if (o.MEDIAINSERTED == 1) @enumToInt(SHCNE_ID.MEDIAINSERTED) else 0)
            | (if (o.MEDIAREMOVED == 1) @enumToInt(SHCNE_ID.MEDIAREMOVED) else 0)
            | (if (o.DRIVEREMOVED == 1) @enumToInt(SHCNE_ID.DRIVEREMOVED) else 0)
            | (if (o.DRIVEADD == 1) @enumToInt(SHCNE_ID.DRIVEADD) else 0)
            | (if (o.NETSHARE == 1) @enumToInt(SHCNE_ID.NETSHARE) else 0)
            | (if (o.NETUNSHARE == 1) @enumToInt(SHCNE_ID.NETUNSHARE) else 0)
            | (if (o.ATTRIBUTES == 1) @enumToInt(SHCNE_ID.ATTRIBUTES) else 0)
            | (if (o.UPDATEDIR == 1) @enumToInt(SHCNE_ID.UPDATEDIR) else 0)
            | (if (o.UPDATEITEM == 1) @enumToInt(SHCNE_ID.UPDATEITEM) else 0)
            | (if (o.SERVERDISCONNECT == 1) @enumToInt(SHCNE_ID.SERVERDISCONNECT) else 0)
            | (if (o.UPDATEIMAGE == 1) @enumToInt(SHCNE_ID.UPDATEIMAGE) else 0)
            | (if (o.DRIVEADDGUI == 1) @enumToInt(SHCNE_ID.DRIVEADDGUI) else 0)
            | (if (o.RENAMEFOLDER == 1) @enumToInt(SHCNE_ID.RENAMEFOLDER) else 0)
            | (if (o.FREESPACE == 1) @enumToInt(SHCNE_ID.FREESPACE) else 0)
            | (if (o.EXTENDED_EVENT == 1) @enumToInt(SHCNE_ID.EXTENDED_EVENT) else 0)
            | (if (o.ASSOCCHANGED == 1) @enumToInt(SHCNE_ID.ASSOCCHANGED) else 0)
            | (if (o.DISKEVENTS == 1) @enumToInt(SHCNE_ID.DISKEVENTS) else 0)
            | (if (o.GLOBALEVENTS == 1) @enumToInt(SHCNE_ID.GLOBALEVENTS) else 0)
            | (if (o.ALLEVENTS == 1) @enumToInt(SHCNE_ID.ALLEVENTS) else 0)
            | (if (o.INTERRUPT == 1) @enumToInt(SHCNE_ID.INTERRUPT) else 0)
        );
    }
};
pub const SHCNE_RENAMEITEM = SHCNE_ID.RENAMEITEM;
pub const SHCNE_CREATE = SHCNE_ID.CREATE;
pub const SHCNE_DELETE = SHCNE_ID.DELETE;
pub const SHCNE_MKDIR = SHCNE_ID.MKDIR;
pub const SHCNE_RMDIR = SHCNE_ID.RMDIR;
pub const SHCNE_MEDIAINSERTED = SHCNE_ID.MEDIAINSERTED;
pub const SHCNE_MEDIAREMOVED = SHCNE_ID.MEDIAREMOVED;
pub const SHCNE_DRIVEREMOVED = SHCNE_ID.DRIVEREMOVED;
pub const SHCNE_DRIVEADD = SHCNE_ID.DRIVEADD;
pub const SHCNE_NETSHARE = SHCNE_ID.NETSHARE;
pub const SHCNE_NETUNSHARE = SHCNE_ID.NETUNSHARE;
pub const SHCNE_ATTRIBUTES = SHCNE_ID.ATTRIBUTES;
pub const SHCNE_UPDATEDIR = SHCNE_ID.UPDATEDIR;
pub const SHCNE_UPDATEITEM = SHCNE_ID.UPDATEITEM;
pub const SHCNE_SERVERDISCONNECT = SHCNE_ID.SERVERDISCONNECT;
pub const SHCNE_UPDATEIMAGE = SHCNE_ID.UPDATEIMAGE;
pub const SHCNE_DRIVEADDGUI = SHCNE_ID.DRIVEADDGUI;
pub const SHCNE_RENAMEFOLDER = SHCNE_ID.RENAMEFOLDER;
pub const SHCNE_FREESPACE = SHCNE_ID.FREESPACE;
pub const SHCNE_EXTENDED_EVENT = SHCNE_ID.EXTENDED_EVENT;
pub const SHCNE_ASSOCCHANGED = SHCNE_ID.ASSOCCHANGED;
pub const SHCNE_DISKEVENTS = SHCNE_ID.DISKEVENTS;
pub const SHCNE_GLOBALEVENTS = SHCNE_ID.GLOBALEVENTS;
pub const SHCNE_ALLEVENTS = SHCNE_ID.ALLEVENTS;
pub const SHCNE_INTERRUPT = SHCNE_ID.INTERRUPT;

pub const SHCNRF_SOURCE = enum(i32) {
    InterruptLevel = 1,
    ShellLevel = 2,
    RecursiveInterrupt = 4096,
    NewDelivery = 32768,
    _,
    pub fn initFlags(o: struct {
        InterruptLevel: u1 = 0,
        ShellLevel: u1 = 0,
        RecursiveInterrupt: u1 = 0,
        NewDelivery: u1 = 0,
    }) SHCNRF_SOURCE {
        return @intToEnum(SHCNRF_SOURCE,
              (if (o.InterruptLevel == 1) @enumToInt(SHCNRF_SOURCE.InterruptLevel) else 0)
            | (if (o.ShellLevel == 1) @enumToInt(SHCNRF_SOURCE.ShellLevel) else 0)
            | (if (o.RecursiveInterrupt == 1) @enumToInt(SHCNRF_SOURCE.RecursiveInterrupt) else 0)
            | (if (o.NewDelivery == 1) @enumToInt(SHCNRF_SOURCE.NewDelivery) else 0)
        );
    }
};
pub const SHCNRF_InterruptLevel = SHCNRF_SOURCE.InterruptLevel;
pub const SHCNRF_ShellLevel = SHCNRF_SOURCE.ShellLevel;
pub const SHCNRF_RecursiveInterrupt = SHCNRF_SOURCE.RecursiveInterrupt;
pub const SHCNRF_NewDelivery = SHCNRF_SOURCE.NewDelivery;

pub const SHCNF_FLAGS = enum(u32) {
    IDLIST = 0,
    PATHA = 1,
    PRINTERA = 2,
    DWORD = 3,
    PATHW = 5,
    PRINTERW = 6,
    TYPE = 255,
    FLUSH = 4096,
    FLUSHNOWAIT = 12288,
    NOTIFYRECURSIVE = 65536,
    // PATH = 5, this enum value conflicts with PATHW
    // PRINTER = 6, this enum value conflicts with PRINTERW
    _,
    pub fn initFlags(o: struct {
        IDLIST: u1 = 0,
        PATHA: u1 = 0,
        PRINTERA: u1 = 0,
        DWORD: u1 = 0,
        PATHW: u1 = 0,
        PRINTERW: u1 = 0,
        TYPE: u1 = 0,
        FLUSH: u1 = 0,
        FLUSHNOWAIT: u1 = 0,
        NOTIFYRECURSIVE: u1 = 0,
    }) SHCNF_FLAGS {
        return @intToEnum(SHCNF_FLAGS,
              (if (o.IDLIST == 1) @enumToInt(SHCNF_FLAGS.IDLIST) else 0)
            | (if (o.PATHA == 1) @enumToInt(SHCNF_FLAGS.PATHA) else 0)
            | (if (o.PRINTERA == 1) @enumToInt(SHCNF_FLAGS.PRINTERA) else 0)
            | (if (o.DWORD == 1) @enumToInt(SHCNF_FLAGS.DWORD) else 0)
            | (if (o.PATHW == 1) @enumToInt(SHCNF_FLAGS.PATHW) else 0)
            | (if (o.PRINTERW == 1) @enumToInt(SHCNF_FLAGS.PRINTERW) else 0)
            | (if (o.TYPE == 1) @enumToInt(SHCNF_FLAGS.TYPE) else 0)
            | (if (o.FLUSH == 1) @enumToInt(SHCNF_FLAGS.FLUSH) else 0)
            | (if (o.FLUSHNOWAIT == 1) @enumToInt(SHCNF_FLAGS.FLUSHNOWAIT) else 0)
            | (if (o.NOTIFYRECURSIVE == 1) @enumToInt(SHCNF_FLAGS.NOTIFYRECURSIVE) else 0)
        );
    }
};
pub const SHCNF_IDLIST = SHCNF_FLAGS.IDLIST;
pub const SHCNF_PATHA = SHCNF_FLAGS.PATHA;
pub const SHCNF_PRINTERA = SHCNF_FLAGS.PRINTERA;
pub const SHCNF_DWORD = SHCNF_FLAGS.DWORD;
pub const SHCNF_PATHW = SHCNF_FLAGS.PATHW;
pub const SHCNF_PRINTERW = SHCNF_FLAGS.PRINTERW;
pub const SHCNF_TYPE = SHCNF_FLAGS.TYPE;
pub const SHCNF_FLUSH = SHCNF_FLAGS.FLUSH;
pub const SHCNF_FLUSHNOWAIT = SHCNF_FLAGS.FLUSHNOWAIT;
pub const SHCNF_NOTIFYRECURSIVE = SHCNF_FLAGS.NOTIFYRECURSIVE;
pub const SHCNF_PATH = SHCNF_FLAGS.PATHW;
pub const SHCNF_PRINTER = SHCNF_FLAGS.PRINTERW;

pub const QITIPF_FLAGS = enum(i32) {
    TIPF_DEFAULT = 0,
    TIPF_USENAME = 1,
    TIPF_LINKNOTARGET = 2,
    TIPF_LINKUSETARGET = 4,
    TIPF_USESLOWTIP = 8,
    TIPF_SINGLELINE = 16,
    // F_CACHED = 1, this enum value conflicts with TIPF_USENAME
    // F_DONTEXPANDFOLDER = 2, this enum value conflicts with TIPF_LINKNOTARGET
    _,
    pub fn initFlags(o: struct {
        TIPF_DEFAULT: u1 = 0,
        TIPF_USENAME: u1 = 0,
        TIPF_LINKNOTARGET: u1 = 0,
        TIPF_LINKUSETARGET: u1 = 0,
        TIPF_USESLOWTIP: u1 = 0,
        TIPF_SINGLELINE: u1 = 0,
    }) QITIPF_FLAGS {
        return @intToEnum(QITIPF_FLAGS,
              (if (o.TIPF_DEFAULT == 1) @enumToInt(QITIPF_FLAGS.TIPF_DEFAULT) else 0)
            | (if (o.TIPF_USENAME == 1) @enumToInt(QITIPF_FLAGS.TIPF_USENAME) else 0)
            | (if (o.TIPF_LINKNOTARGET == 1) @enumToInt(QITIPF_FLAGS.TIPF_LINKNOTARGET) else 0)
            | (if (o.TIPF_LINKUSETARGET == 1) @enumToInt(QITIPF_FLAGS.TIPF_LINKUSETARGET) else 0)
            | (if (o.TIPF_USESLOWTIP == 1) @enumToInt(QITIPF_FLAGS.TIPF_USESLOWTIP) else 0)
            | (if (o.TIPF_SINGLELINE == 1) @enumToInt(QITIPF_FLAGS.TIPF_SINGLELINE) else 0)
        );
    }
};
pub const QITIPF_DEFAULT = QITIPF_FLAGS.TIPF_DEFAULT;
pub const QITIPF_USENAME = QITIPF_FLAGS.TIPF_USENAME;
pub const QITIPF_LINKNOTARGET = QITIPF_FLAGS.TIPF_LINKNOTARGET;
pub const QITIPF_LINKUSETARGET = QITIPF_FLAGS.TIPF_LINKUSETARGET;
pub const QITIPF_USESLOWTIP = QITIPF_FLAGS.TIPF_USESLOWTIP;
pub const QITIPF_SINGLELINE = QITIPF_FLAGS.TIPF_SINGLELINE;
pub const QIF_CACHED = QITIPF_FLAGS.TIPF_USENAME;
pub const QIF_DONTEXPANDFOLDER = QITIPF_FLAGS.TIPF_LINKNOTARGET;

pub const SHDID_ID = enum(i32) {
    ROOT_REGITEM = 1,
    FS_FILE = 2,
    FS_DIRECTORY = 3,
    FS_OTHER = 4,
    COMPUTER_DRIVE35 = 5,
    COMPUTER_DRIVE525 = 6,
    COMPUTER_REMOVABLE = 7,
    COMPUTER_FIXED = 8,
    COMPUTER_NETDRIVE = 9,
    COMPUTER_CDROM = 10,
    COMPUTER_RAMDISK = 11,
    COMPUTER_OTHER = 12,
    NET_DOMAIN = 13,
    NET_SERVER = 14,
    NET_SHARE = 15,
    NET_RESTOFNET = 16,
    NET_OTHER = 17,
    COMPUTER_IMAGING = 18,
    COMPUTER_AUDIO = 19,
    COMPUTER_SHAREDDOCS = 20,
    MOBILE_DEVICE = 21,
    REMOTE_DESKTOP_DRIVE = 22,
};
pub const SHDID_ROOT_REGITEM = SHDID_ID.ROOT_REGITEM;
pub const SHDID_FS_FILE = SHDID_ID.FS_FILE;
pub const SHDID_FS_DIRECTORY = SHDID_ID.FS_DIRECTORY;
pub const SHDID_FS_OTHER = SHDID_ID.FS_OTHER;
pub const SHDID_COMPUTER_DRIVE35 = SHDID_ID.COMPUTER_DRIVE35;
pub const SHDID_COMPUTER_DRIVE525 = SHDID_ID.COMPUTER_DRIVE525;
pub const SHDID_COMPUTER_REMOVABLE = SHDID_ID.COMPUTER_REMOVABLE;
pub const SHDID_COMPUTER_FIXED = SHDID_ID.COMPUTER_FIXED;
pub const SHDID_COMPUTER_NETDRIVE = SHDID_ID.COMPUTER_NETDRIVE;
pub const SHDID_COMPUTER_CDROM = SHDID_ID.COMPUTER_CDROM;
pub const SHDID_COMPUTER_RAMDISK = SHDID_ID.COMPUTER_RAMDISK;
pub const SHDID_COMPUTER_OTHER = SHDID_ID.COMPUTER_OTHER;
pub const SHDID_NET_DOMAIN = SHDID_ID.NET_DOMAIN;
pub const SHDID_NET_SERVER = SHDID_ID.NET_SERVER;
pub const SHDID_NET_SHARE = SHDID_ID.NET_SHARE;
pub const SHDID_NET_RESTOFNET = SHDID_ID.NET_RESTOFNET;
pub const SHDID_NET_OTHER = SHDID_ID.NET_OTHER;
pub const SHDID_COMPUTER_IMAGING = SHDID_ID.COMPUTER_IMAGING;
pub const SHDID_COMPUTER_AUDIO = SHDID_ID.COMPUTER_AUDIO;
pub const SHDID_COMPUTER_SHAREDDOCS = SHDID_ID.COMPUTER_SHAREDDOCS;
pub const SHDID_MOBILE_DEVICE = SHDID_ID.MOBILE_DEVICE;
pub const SHDID_REMOTE_DESKTOP_DRIVE = SHDID_ID.REMOTE_DESKTOP_DRIVE;

pub const SHGDFIL_FORMAT = enum(i32) {
    FINDDATA = 1,
    NETRESOURCE = 2,
    DESCRIPTIONID = 3,
};
pub const SHGDFIL_FINDDATA = SHGDFIL_FORMAT.FINDDATA;
pub const SHGDFIL_NETRESOURCE = SHGDFIL_FORMAT.NETRESOURCE;
pub const SHGDFIL_DESCRIPTIONID = SHGDFIL_FORMAT.DESCRIPTIONID;

pub const PRF_FLAGS = enum(i32) {
    VERIFYEXISTS = 1,
    TRYPROGRAMEXTENSIONS = 3,
    FIRSTDIRDEF = 4,
    DONTFINDLNK = 8,
    REQUIREABSOLUTE = 16,
    _,
    pub fn initFlags(o: struct {
        VERIFYEXISTS: u1 = 0,
        TRYPROGRAMEXTENSIONS: u1 = 0,
        FIRSTDIRDEF: u1 = 0,
        DONTFINDLNK: u1 = 0,
        REQUIREABSOLUTE: u1 = 0,
    }) PRF_FLAGS {
        return @intToEnum(PRF_FLAGS,
              (if (o.VERIFYEXISTS == 1) @enumToInt(PRF_FLAGS.VERIFYEXISTS) else 0)
            | (if (o.TRYPROGRAMEXTENSIONS == 1) @enumToInt(PRF_FLAGS.TRYPROGRAMEXTENSIONS) else 0)
            | (if (o.FIRSTDIRDEF == 1) @enumToInt(PRF_FLAGS.FIRSTDIRDEF) else 0)
            | (if (o.DONTFINDLNK == 1) @enumToInt(PRF_FLAGS.DONTFINDLNK) else 0)
            | (if (o.REQUIREABSOLUTE == 1) @enumToInt(PRF_FLAGS.REQUIREABSOLUTE) else 0)
        );
    }
};
pub const PRF_VERIFYEXISTS = PRF_FLAGS.VERIFYEXISTS;
pub const PRF_TRYPROGRAMEXTENSIONS = PRF_FLAGS.TRYPROGRAMEXTENSIONS;
pub const PRF_FIRSTDIRDEF = PRF_FLAGS.FIRSTDIRDEF;
pub const PRF_DONTFINDLNK = PRF_FLAGS.DONTFINDLNK;
pub const PRF_REQUIREABSOLUTE = PRF_FLAGS.REQUIREABSOLUTE;

pub const PCS_RET = enum(u32) {
    FATAL = 2147483648,
    REPLACEDCHAR = 1,
    REMOVEDCHAR = 2,
    TRUNCATED = 4,
    PATHTOOLONG = 8,
    _,
    pub fn initFlags(o: struct {
        FATAL: u1 = 0,
        REPLACEDCHAR: u1 = 0,
        REMOVEDCHAR: u1 = 0,
        TRUNCATED: u1 = 0,
        PATHTOOLONG: u1 = 0,
    }) PCS_RET {
        return @intToEnum(PCS_RET,
              (if (o.FATAL == 1) @enumToInt(PCS_RET.FATAL) else 0)
            | (if (o.REPLACEDCHAR == 1) @enumToInt(PCS_RET.REPLACEDCHAR) else 0)
            | (if (o.REMOVEDCHAR == 1) @enumToInt(PCS_RET.REMOVEDCHAR) else 0)
            | (if (o.TRUNCATED == 1) @enumToInt(PCS_RET.TRUNCATED) else 0)
            | (if (o.PATHTOOLONG == 1) @enumToInt(PCS_RET.PATHTOOLONG) else 0)
        );
    }
};
pub const PCS_FATAL = PCS_RET.FATAL;
pub const PCS_REPLACEDCHAR = PCS_RET.REPLACEDCHAR;
pub const PCS_REMOVEDCHAR = PCS_RET.REMOVEDCHAR;
pub const PCS_TRUNCATED = PCS_RET.TRUNCATED;
pub const PCS_PATHTOOLONG = PCS_RET.PATHTOOLONG;

pub const MM_FLAGS = enum(u32) {
    ADDSEPARATOR = 1,
    SUBMENUSHAVEIDS = 2,
    DONTREMOVESEPS = 4,
    _,
    pub fn initFlags(o: struct {
        ADDSEPARATOR: u1 = 0,
        SUBMENUSHAVEIDS: u1 = 0,
        DONTREMOVESEPS: u1 = 0,
    }) MM_FLAGS {
        return @intToEnum(MM_FLAGS,
              (if (o.ADDSEPARATOR == 1) @enumToInt(MM_FLAGS.ADDSEPARATOR) else 0)
            | (if (o.SUBMENUSHAVEIDS == 1) @enumToInt(MM_FLAGS.SUBMENUSHAVEIDS) else 0)
            | (if (o.DONTREMOVESEPS == 1) @enumToInt(MM_FLAGS.DONTREMOVESEPS) else 0)
        );
    }
};
pub const MM_ADDSEPARATOR = MM_FLAGS.ADDSEPARATOR;
pub const MM_SUBMENUSHAVEIDS = MM_FLAGS.SUBMENUSHAVEIDS;
pub const MM_DONTREMOVESEPS = MM_FLAGS.DONTREMOVESEPS;

pub const SHOP_TYPE = enum(i32) {
    PRINTERNAME = 1,
    FILEPATH = 2,
    VOLUMEGUID = 4,
    _,
    pub fn initFlags(o: struct {
        PRINTERNAME: u1 = 0,
        FILEPATH: u1 = 0,
        VOLUMEGUID: u1 = 0,
    }) SHOP_TYPE {
        return @intToEnum(SHOP_TYPE,
              (if (o.PRINTERNAME == 1) @enumToInt(SHOP_TYPE.PRINTERNAME) else 0)
            | (if (o.FILEPATH == 1) @enumToInt(SHOP_TYPE.FILEPATH) else 0)
            | (if (o.VOLUMEGUID == 1) @enumToInt(SHOP_TYPE.VOLUMEGUID) else 0)
        );
    }
};
pub const SHOP_PRINTERNAME = SHOP_TYPE.PRINTERNAME;
pub const SHOP_FILEPATH = SHOP_TYPE.FILEPATH;
pub const SHOP_VOLUMEGUID = SHOP_TYPE.VOLUMEGUID;

pub const SHFMT_ID = enum(u32) {
    T = 65535,
};
pub const SHFMT_ID_DEFAULT = SHFMT_ID.T;

pub const SHFMT_OPT = enum(i32) {
    NONE = 0,
    FULL = 1,
    SYSONLY = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        FULL: u1 = 0,
        SYSONLY: u1 = 0,
    }) SHFMT_OPT {
        return @intToEnum(SHFMT_OPT,
              (if (o.NONE == 1) @enumToInt(SHFMT_OPT.NONE) else 0)
            | (if (o.FULL == 1) @enumToInt(SHFMT_OPT.FULL) else 0)
            | (if (o.SYSONLY == 1) @enumToInt(SHFMT_OPT.SYSONLY) else 0)
        );
    }
};
pub const SHFMT_OPT_NONE = SHFMT_OPT.NONE;
pub const SHFMT_OPT_FULL = SHFMT_OPT.FULL;
pub const SHFMT_OPT_SYSONLY = SHFMT_OPT.SYSONLY;

pub const SHFMT_RET = enum(u32) {
    ERROR = 4294967295,
    CANCEL = 4294967294,
    NOFORMAT = 4294967293,
};
pub const SHFMT_ERROR = SHFMT_RET.ERROR;
pub const SHFMT_CANCEL = SHFMT_RET.CANCEL;
pub const SHFMT_NOFORMAT = SHFMT_RET.NOFORMAT;

pub const VALIDATEUNC_OPTION = enum(i32) {
    CONNECT = 1,
    NOUI = 2,
    PRINT = 4,
    PERSIST = 8,
    VALID = 15,
    _,
    pub fn initFlags(o: struct {
        CONNECT: u1 = 0,
        NOUI: u1 = 0,
        PRINT: u1 = 0,
        PERSIST: u1 = 0,
        VALID: u1 = 0,
    }) VALIDATEUNC_OPTION {
        return @intToEnum(VALIDATEUNC_OPTION,
              (if (o.CONNECT == 1) @enumToInt(VALIDATEUNC_OPTION.CONNECT) else 0)
            | (if (o.NOUI == 1) @enumToInt(VALIDATEUNC_OPTION.NOUI) else 0)
            | (if (o.PRINT == 1) @enumToInt(VALIDATEUNC_OPTION.PRINT) else 0)
            | (if (o.PERSIST == 1) @enumToInt(VALIDATEUNC_OPTION.PERSIST) else 0)
            | (if (o.VALID == 1) @enumToInt(VALIDATEUNC_OPTION.VALID) else 0)
        );
    }
};
pub const VALIDATEUNC_CONNECT = VALIDATEUNC_OPTION.CONNECT;
pub const VALIDATEUNC_NOUI = VALIDATEUNC_OPTION.NOUI;
pub const VALIDATEUNC_PRINT = VALIDATEUNC_OPTION.PRINT;
pub const VALIDATEUNC_PERSIST = VALIDATEUNC_OPTION.PERSIST;
pub const VALIDATEUNC_VALID = VALIDATEUNC_OPTION.VALID;

pub const SFVM_MESSAGE_ID = enum(i32) {
    MERGEMENU = 1,
    INVOKECOMMAND = 2,
    GETHELPTEXT = 3,
    GETTOOLTIPTEXT = 4,
    GETBUTTONINFO = 5,
    GETBUTTONS = 6,
    INITMENUPOPUP = 7,
    FSNOTIFY = 14,
    WINDOWCREATED = 15,
    GETDETAILSOF = 23,
    COLUMNCLICK = 24,
    QUERYFSNOTIFY = 25,
    DEFITEMCOUNT = 26,
    DEFVIEWMODE = 27,
    UNMERGEMENU = 28,
    UPDATESTATUSBAR = 31,
    BACKGROUNDENUM = 32,
    DIDDRAGDROP = 36,
    SETISFV = 39,
    THISIDLIST = 41,
    ADDPROPERTYPAGES = 47,
    BACKGROUNDENUMDONE = 48,
    GETNOTIFY = 49,
    GETSORTDEFAULTS = 53,
    SIZE = 57,
    GETZONE = 58,
    GETPANE = 59,
    GETHELPTOPIC = 63,
    GETANIMATION = 68,
};
pub const SFVM_MERGEMENU = SFVM_MESSAGE_ID.MERGEMENU;
pub const SFVM_INVOKECOMMAND = SFVM_MESSAGE_ID.INVOKECOMMAND;
pub const SFVM_GETHELPTEXT = SFVM_MESSAGE_ID.GETHELPTEXT;
pub const SFVM_GETTOOLTIPTEXT = SFVM_MESSAGE_ID.GETTOOLTIPTEXT;
pub const SFVM_GETBUTTONINFO = SFVM_MESSAGE_ID.GETBUTTONINFO;
pub const SFVM_GETBUTTONS = SFVM_MESSAGE_ID.GETBUTTONS;
pub const SFVM_INITMENUPOPUP = SFVM_MESSAGE_ID.INITMENUPOPUP;
pub const SFVM_FSNOTIFY = SFVM_MESSAGE_ID.FSNOTIFY;
pub const SFVM_WINDOWCREATED = SFVM_MESSAGE_ID.WINDOWCREATED;
pub const SFVM_GETDETAILSOF = SFVM_MESSAGE_ID.GETDETAILSOF;
pub const SFVM_COLUMNCLICK = SFVM_MESSAGE_ID.COLUMNCLICK;
pub const SFVM_QUERYFSNOTIFY = SFVM_MESSAGE_ID.QUERYFSNOTIFY;
pub const SFVM_DEFITEMCOUNT = SFVM_MESSAGE_ID.DEFITEMCOUNT;
pub const SFVM_DEFVIEWMODE = SFVM_MESSAGE_ID.DEFVIEWMODE;
pub const SFVM_UNMERGEMENU = SFVM_MESSAGE_ID.UNMERGEMENU;
pub const SFVM_UPDATESTATUSBAR = SFVM_MESSAGE_ID.UPDATESTATUSBAR;
pub const SFVM_BACKGROUNDENUM = SFVM_MESSAGE_ID.BACKGROUNDENUM;
pub const SFVM_DIDDRAGDROP = SFVM_MESSAGE_ID.DIDDRAGDROP;
pub const SFVM_SETISFV = SFVM_MESSAGE_ID.SETISFV;
pub const SFVM_THISIDLIST = SFVM_MESSAGE_ID.THISIDLIST;
pub const SFVM_ADDPROPERTYPAGES = SFVM_MESSAGE_ID.ADDPROPERTYPAGES;
pub const SFVM_BACKGROUNDENUMDONE = SFVM_MESSAGE_ID.BACKGROUNDENUMDONE;
pub const SFVM_GETNOTIFY = SFVM_MESSAGE_ID.GETNOTIFY;
pub const SFVM_GETSORTDEFAULTS = SFVM_MESSAGE_ID.GETSORTDEFAULTS;
pub const SFVM_SIZE = SFVM_MESSAGE_ID.SIZE;
pub const SFVM_GETZONE = SFVM_MESSAGE_ID.GETZONE;
pub const SFVM_GETPANE = SFVM_MESSAGE_ID.GETPANE;
pub const SFVM_GETHELPTOPIC = SFVM_MESSAGE_ID.GETHELPTOPIC;
pub const SFVM_GETANIMATION = SFVM_MESSAGE_ID.GETANIMATION;

pub const SFVS_SELECT = enum(i32) {
    NONE = 0,
    ALLITEMS = 1,
    INVERT = 2,
};
pub const SFVS_SELECT_NONE = SFVS_SELECT.NONE;
pub const SFVS_SELECT_ALLITEMS = SFVS_SELECT.ALLITEMS;
pub const SFVS_SELECT_INVERT = SFVS_SELECT.INVERT;

pub const DFM_MESSAGE_ID = enum(i32) {
    MERGECONTEXTMENU = 1,
    INVOKECOMMAND = 2,
    GETHELPTEXT = 5,
    WM_MEASUREITEM = 6,
    WM_DRAWITEM = 7,
    WM_INITMENUPOPUP = 8,
    VALIDATECMD = 9,
    MERGECONTEXTMENU_TOP = 10,
    GETHELPTEXTW = 11,
    INVOKECOMMANDEX = 12,
    MAPCOMMANDNAME = 13,
    GETDEFSTATICID = 14,
    GETVERBW = 15,
    GETVERBA = 16,
    MERGECONTEXTMENU_BOTTOM = 17,
    MODIFYQCMFLAGS = 18,
};
pub const DFM_MERGECONTEXTMENU = DFM_MESSAGE_ID.MERGECONTEXTMENU;
pub const DFM_INVOKECOMMAND = DFM_MESSAGE_ID.INVOKECOMMAND;
pub const DFM_GETHELPTEXT = DFM_MESSAGE_ID.GETHELPTEXT;
pub const DFM_WM_MEASUREITEM = DFM_MESSAGE_ID.WM_MEASUREITEM;
pub const DFM_WM_DRAWITEM = DFM_MESSAGE_ID.WM_DRAWITEM;
pub const DFM_WM_INITMENUPOPUP = DFM_MESSAGE_ID.WM_INITMENUPOPUP;
pub const DFM_VALIDATECMD = DFM_MESSAGE_ID.VALIDATECMD;
pub const DFM_MERGECONTEXTMENU_TOP = DFM_MESSAGE_ID.MERGECONTEXTMENU_TOP;
pub const DFM_GETHELPTEXTW = DFM_MESSAGE_ID.GETHELPTEXTW;
pub const DFM_INVOKECOMMANDEX = DFM_MESSAGE_ID.INVOKECOMMANDEX;
pub const DFM_MAPCOMMANDNAME = DFM_MESSAGE_ID.MAPCOMMANDNAME;
pub const DFM_GETDEFSTATICID = DFM_MESSAGE_ID.GETDEFSTATICID;
pub const DFM_GETVERBW = DFM_MESSAGE_ID.GETVERBW;
pub const DFM_GETVERBA = DFM_MESSAGE_ID.GETVERBA;
pub const DFM_MERGECONTEXTMENU_BOTTOM = DFM_MESSAGE_ID.MERGECONTEXTMENU_BOTTOM;
pub const DFM_MODIFYQCMFLAGS = DFM_MESSAGE_ID.MODIFYQCMFLAGS;

pub const DFM_CMD = enum(i32) {
    DELETE = -1,
    MOVE = -2,
    COPY = -3,
    LINK = -4,
    PROPERTIES = -5,
    NEWFOLDER = -6,
    PASTE = -7,
    VIEWLIST = -8,
    VIEWDETAILS = -9,
    PASTELINK = -10,
    PASTESPECIAL = -11,
    MODALPROP = -12,
    RENAME = -13,
};
pub const DFM_CMD_DELETE = DFM_CMD.DELETE;
pub const DFM_CMD_MOVE = DFM_CMD.MOVE;
pub const DFM_CMD_COPY = DFM_CMD.COPY;
pub const DFM_CMD_LINK = DFM_CMD.LINK;
pub const DFM_CMD_PROPERTIES = DFM_CMD.PROPERTIES;
pub const DFM_CMD_NEWFOLDER = DFM_CMD.NEWFOLDER;
pub const DFM_CMD_PASTE = DFM_CMD.PASTE;
pub const DFM_CMD_VIEWLIST = DFM_CMD.VIEWLIST;
pub const DFM_CMD_VIEWDETAILS = DFM_CMD.VIEWDETAILS;
pub const DFM_CMD_PASTELINK = DFM_CMD.PASTELINK;
pub const DFM_CMD_PASTESPECIAL = DFM_CMD.PASTESPECIAL;
pub const DFM_CMD_MODALPROP = DFM_CMD.MODALPROP;
pub const DFM_CMD_RENAME = DFM_CMD.RENAME;

pub const PID_IS = enum(i32) {
    URL = 2,
    NAME = 4,
    WORKINGDIR = 5,
    HOTKEY = 6,
    SHOWCMD = 7,
    ICONINDEX = 8,
    ICONFILE = 9,
    WHATSNEW = 10,
    AUTHOR = 11,
    DESCRIPTION = 12,
    COMMENT = 13,
    ROAMED = 15,
};
pub const PID_IS_URL = PID_IS.URL;
pub const PID_IS_NAME = PID_IS.NAME;
pub const PID_IS_WORKINGDIR = PID_IS.WORKINGDIR;
pub const PID_IS_HOTKEY = PID_IS.HOTKEY;
pub const PID_IS_SHOWCMD = PID_IS.SHOWCMD;
pub const PID_IS_ICONINDEX = PID_IS.ICONINDEX;
pub const PID_IS_ICONFILE = PID_IS.ICONFILE;
pub const PID_IS_WHATSNEW = PID_IS.WHATSNEW;
pub const PID_IS_AUTHOR = PID_IS.AUTHOR;
pub const PID_IS_DESCRIPTION = PID_IS.DESCRIPTION;
pub const PID_IS_COMMENT = PID_IS.COMMENT;
pub const PID_IS_ROAMED = PID_IS.ROAMED;

pub const PID_INTSITE = enum(i32) {
    WHATSNEW = 2,
    AUTHOR = 3,
    LASTVISIT = 4,
    LASTMOD = 5,
    VISITCOUNT = 6,
    DESCRIPTION = 7,
    COMMENT = 8,
    FLAGS = 9,
    CONTENTLEN = 10,
    CONTENTCODE = 11,
    RECURSE = 12,
    WATCH = 13,
    SUBSCRIPTION = 14,
    URL = 15,
    TITLE = 16,
    CODEPAGE = 18,
    TRACKING = 19,
    ICONINDEX = 20,
    ICONFILE = 21,
    ROAMED = 34,
};
pub const PID_INTSITE_WHATSNEW = PID_INTSITE.WHATSNEW;
pub const PID_INTSITE_AUTHOR = PID_INTSITE.AUTHOR;
pub const PID_INTSITE_LASTVISIT = PID_INTSITE.LASTVISIT;
pub const PID_INTSITE_LASTMOD = PID_INTSITE.LASTMOD;
pub const PID_INTSITE_VISITCOUNT = PID_INTSITE.VISITCOUNT;
pub const PID_INTSITE_DESCRIPTION = PID_INTSITE.DESCRIPTION;
pub const PID_INTSITE_COMMENT = PID_INTSITE.COMMENT;
pub const PID_INTSITE_FLAGS = PID_INTSITE.FLAGS;
pub const PID_INTSITE_CONTENTLEN = PID_INTSITE.CONTENTLEN;
pub const PID_INTSITE_CONTENTCODE = PID_INTSITE.CONTENTCODE;
pub const PID_INTSITE_RECURSE = PID_INTSITE.RECURSE;
pub const PID_INTSITE_WATCH = PID_INTSITE.WATCH;
pub const PID_INTSITE_SUBSCRIPTION = PID_INTSITE.SUBSCRIPTION;
pub const PID_INTSITE_URL = PID_INTSITE.URL;
pub const PID_INTSITE_TITLE = PID_INTSITE.TITLE;
pub const PID_INTSITE_CODEPAGE = PID_INTSITE.CODEPAGE;
pub const PID_INTSITE_TRACKING = PID_INTSITE.TRACKING;
pub const PID_INTSITE_ICONINDEX = PID_INTSITE.ICONINDEX;
pub const PID_INTSITE_ICONFILE = PID_INTSITE.ICONFILE;
pub const PID_INTSITE_ROAMED = PID_INTSITE.ROAMED;

pub const PIDISF_FLAGS = enum(i32) {
    RECENTLYCHANGED = 1,
    CACHEDSTICKY = 2,
    CACHEIMAGES = 16,
    FOLLOWALLLINKS = 32,
    _,
    pub fn initFlags(o: struct {
        RECENTLYCHANGED: u1 = 0,
        CACHEDSTICKY: u1 = 0,
        CACHEIMAGES: u1 = 0,
        FOLLOWALLLINKS: u1 = 0,
    }) PIDISF_FLAGS {
        return @intToEnum(PIDISF_FLAGS,
              (if (o.RECENTLYCHANGED == 1) @enumToInt(PIDISF_FLAGS.RECENTLYCHANGED) else 0)
            | (if (o.CACHEDSTICKY == 1) @enumToInt(PIDISF_FLAGS.CACHEDSTICKY) else 0)
            | (if (o.CACHEIMAGES == 1) @enumToInt(PIDISF_FLAGS.CACHEIMAGES) else 0)
            | (if (o.FOLLOWALLLINKS == 1) @enumToInt(PIDISF_FLAGS.FOLLOWALLLINKS) else 0)
        );
    }
};
pub const PIDISF_RECENTLYCHANGED = PIDISF_FLAGS.RECENTLYCHANGED;
pub const PIDISF_CACHEDSTICKY = PIDISF_FLAGS.CACHEDSTICKY;
pub const PIDISF_CACHEIMAGES = PIDISF_FLAGS.CACHEIMAGES;
pub const PIDISF_FOLLOWALLLINKS = PIDISF_FLAGS.FOLLOWALLLINKS;

pub const PIDISM_OPTIONS = enum(i32) {
    GLOBAL = 0,
    WATCH = 1,
    DONTWATCH = 2,
};
pub const PIDISM_GLOBAL = PIDISM_OPTIONS.GLOBAL;
pub const PIDISM_WATCH = PIDISM_OPTIONS.WATCH;
pub const PIDISM_DONTWATCH = PIDISM_OPTIONS.DONTWATCH;

pub const PIDISR_INFO = enum(i32) {
    UP_TO_DATE = 0,
    NEEDS_ADD = 1,
    NEEDS_UPDATE = 2,
    NEEDS_DELETE = 3,
};
pub const PIDISR_UP_TO_DATE = PIDISR_INFO.UP_TO_DATE;
pub const PIDISR_NEEDS_ADD = PIDISR_INFO.NEEDS_ADD;
pub const PIDISR_NEEDS_UPDATE = PIDISR_INFO.NEEDS_UPDATE;
pub const PIDISR_NEEDS_DELETE = PIDISR_INFO.NEEDS_DELETE;

pub const SSF_MASK = enum(u32) {
    SHOWALLOBJECTS = 1,
    SHOWEXTENSIONS = 2,
    HIDDENFILEEXTS = 4,
    // SERVERADMINUI = 4, this enum value conflicts with HIDDENFILEEXTS
    SHOWCOMPCOLOR = 8,
    SORTCOLUMNS = 16,
    SHOWSYSFILES = 32,
    DOUBLECLICKINWEBVIEW = 128,
    SHOWATTRIBCOL = 256,
    DESKTOPHTML = 512,
    WIN95CLASSIC = 1024,
    DONTPRETTYPATH = 2048,
    SHOWINFOTIP = 8192,
    MAPNETDRVBUTTON = 4096,
    NOCONFIRMRECYCLE = 32768,
    HIDEICONS = 16384,
    FILTER = 65536,
    WEBVIEW = 131072,
    SHOWSUPERHIDDEN = 262144,
    SEPPROCESS = 524288,
    NONETCRAWLING = 1048576,
    STARTPANELON = 2097152,
    SHOWSTARTPAGE = 4194304,
    AUTOCHECKSELECT = 8388608,
    ICONSONLY = 16777216,
    SHOWTYPEOVERLAY = 33554432,
    SHOWSTATUSBAR = 67108864,
    _,
    pub fn initFlags(o: struct {
        SHOWALLOBJECTS: u1 = 0,
        SHOWEXTENSIONS: u1 = 0,
        HIDDENFILEEXTS: u1 = 0,
        SHOWCOMPCOLOR: u1 = 0,
        SORTCOLUMNS: u1 = 0,
        SHOWSYSFILES: u1 = 0,
        DOUBLECLICKINWEBVIEW: u1 = 0,
        SHOWATTRIBCOL: u1 = 0,
        DESKTOPHTML: u1 = 0,
        WIN95CLASSIC: u1 = 0,
        DONTPRETTYPATH: u1 = 0,
        SHOWINFOTIP: u1 = 0,
        MAPNETDRVBUTTON: u1 = 0,
        NOCONFIRMRECYCLE: u1 = 0,
        HIDEICONS: u1 = 0,
        FILTER: u1 = 0,
        WEBVIEW: u1 = 0,
        SHOWSUPERHIDDEN: u1 = 0,
        SEPPROCESS: u1 = 0,
        NONETCRAWLING: u1 = 0,
        STARTPANELON: u1 = 0,
        SHOWSTARTPAGE: u1 = 0,
        AUTOCHECKSELECT: u1 = 0,
        ICONSONLY: u1 = 0,
        SHOWTYPEOVERLAY: u1 = 0,
        SHOWSTATUSBAR: u1 = 0,
    }) SSF_MASK {
        return @intToEnum(SSF_MASK,
              (if (o.SHOWALLOBJECTS == 1) @enumToInt(SSF_MASK.SHOWALLOBJECTS) else 0)
            | (if (o.SHOWEXTENSIONS == 1) @enumToInt(SSF_MASK.SHOWEXTENSIONS) else 0)
            | (if (o.HIDDENFILEEXTS == 1) @enumToInt(SSF_MASK.HIDDENFILEEXTS) else 0)
            | (if (o.SHOWCOMPCOLOR == 1) @enumToInt(SSF_MASK.SHOWCOMPCOLOR) else 0)
            | (if (o.SORTCOLUMNS == 1) @enumToInt(SSF_MASK.SORTCOLUMNS) else 0)
            | (if (o.SHOWSYSFILES == 1) @enumToInt(SSF_MASK.SHOWSYSFILES) else 0)
            | (if (o.DOUBLECLICKINWEBVIEW == 1) @enumToInt(SSF_MASK.DOUBLECLICKINWEBVIEW) else 0)
            | (if (o.SHOWATTRIBCOL == 1) @enumToInt(SSF_MASK.SHOWATTRIBCOL) else 0)
            | (if (o.DESKTOPHTML == 1) @enumToInt(SSF_MASK.DESKTOPHTML) else 0)
            | (if (o.WIN95CLASSIC == 1) @enumToInt(SSF_MASK.WIN95CLASSIC) else 0)
            | (if (o.DONTPRETTYPATH == 1) @enumToInt(SSF_MASK.DONTPRETTYPATH) else 0)
            | (if (o.SHOWINFOTIP == 1) @enumToInt(SSF_MASK.SHOWINFOTIP) else 0)
            | (if (o.MAPNETDRVBUTTON == 1) @enumToInt(SSF_MASK.MAPNETDRVBUTTON) else 0)
            | (if (o.NOCONFIRMRECYCLE == 1) @enumToInt(SSF_MASK.NOCONFIRMRECYCLE) else 0)
            | (if (o.HIDEICONS == 1) @enumToInt(SSF_MASK.HIDEICONS) else 0)
            | (if (o.FILTER == 1) @enumToInt(SSF_MASK.FILTER) else 0)
            | (if (o.WEBVIEW == 1) @enumToInt(SSF_MASK.WEBVIEW) else 0)
            | (if (o.SHOWSUPERHIDDEN == 1) @enumToInt(SSF_MASK.SHOWSUPERHIDDEN) else 0)
            | (if (o.SEPPROCESS == 1) @enumToInt(SSF_MASK.SEPPROCESS) else 0)
            | (if (o.NONETCRAWLING == 1) @enumToInt(SSF_MASK.NONETCRAWLING) else 0)
            | (if (o.STARTPANELON == 1) @enumToInt(SSF_MASK.STARTPANELON) else 0)
            | (if (o.SHOWSTARTPAGE == 1) @enumToInt(SSF_MASK.SHOWSTARTPAGE) else 0)
            | (if (o.AUTOCHECKSELECT == 1) @enumToInt(SSF_MASK.AUTOCHECKSELECT) else 0)
            | (if (o.ICONSONLY == 1) @enumToInt(SSF_MASK.ICONSONLY) else 0)
            | (if (o.SHOWTYPEOVERLAY == 1) @enumToInt(SSF_MASK.SHOWTYPEOVERLAY) else 0)
            | (if (o.SHOWSTATUSBAR == 1) @enumToInt(SSF_MASK.SHOWSTATUSBAR) else 0)
        );
    }
};
pub const SSF_SHOWALLOBJECTS = SSF_MASK.SHOWALLOBJECTS;
pub const SSF_SHOWEXTENSIONS = SSF_MASK.SHOWEXTENSIONS;
pub const SSF_HIDDENFILEEXTS = SSF_MASK.HIDDENFILEEXTS;
pub const SSF_SERVERADMINUI = SSF_MASK.HIDDENFILEEXTS;
pub const SSF_SHOWCOMPCOLOR = SSF_MASK.SHOWCOMPCOLOR;
pub const SSF_SORTCOLUMNS = SSF_MASK.SORTCOLUMNS;
pub const SSF_SHOWSYSFILES = SSF_MASK.SHOWSYSFILES;
pub const SSF_DOUBLECLICKINWEBVIEW = SSF_MASK.DOUBLECLICKINWEBVIEW;
pub const SSF_SHOWATTRIBCOL = SSF_MASK.SHOWATTRIBCOL;
pub const SSF_DESKTOPHTML = SSF_MASK.DESKTOPHTML;
pub const SSF_WIN95CLASSIC = SSF_MASK.WIN95CLASSIC;
pub const SSF_DONTPRETTYPATH = SSF_MASK.DONTPRETTYPATH;
pub const SSF_SHOWINFOTIP = SSF_MASK.SHOWINFOTIP;
pub const SSF_MAPNETDRVBUTTON = SSF_MASK.MAPNETDRVBUTTON;
pub const SSF_NOCONFIRMRECYCLE = SSF_MASK.NOCONFIRMRECYCLE;
pub const SSF_HIDEICONS = SSF_MASK.HIDEICONS;
pub const SSF_FILTER = SSF_MASK.FILTER;
pub const SSF_WEBVIEW = SSF_MASK.WEBVIEW;
pub const SSF_SHOWSUPERHIDDEN = SSF_MASK.SHOWSUPERHIDDEN;
pub const SSF_SEPPROCESS = SSF_MASK.SEPPROCESS;
pub const SSF_NONETCRAWLING = SSF_MASK.NONETCRAWLING;
pub const SSF_STARTPANELON = SSF_MASK.STARTPANELON;
pub const SSF_SHOWSTARTPAGE = SSF_MASK.SHOWSTARTPAGE;
pub const SSF_AUTOCHECKSELECT = SSF_MASK.AUTOCHECKSELECT;
pub const SSF_ICONSONLY = SSF_MASK.ICONSONLY;
pub const SSF_SHOWTYPEOVERLAY = SSF_MASK.SHOWTYPEOVERLAY;
pub const SSF_SHOWSTATUSBAR = SSF_MASK.SHOWSTATUSBAR;

pub const NOTIFY_ICON_MESSAGE = enum(u32) {
    ADD = 0,
    MODIFY = 1,
    DELETE = 2,
    SETFOCUS = 3,
    SETVERSION = 4,
};
pub const NIM_ADD = NOTIFY_ICON_MESSAGE.ADD;
pub const NIM_MODIFY = NOTIFY_ICON_MESSAGE.MODIFY;
pub const NIM_DELETE = NOTIFY_ICON_MESSAGE.DELETE;
pub const NIM_SETFOCUS = NOTIFY_ICON_MESSAGE.SETFOCUS;
pub const NIM_SETVERSION = NOTIFY_ICON_MESSAGE.SETVERSION;

pub const NOTIFY_ICON_DATA_FLAGS = enum(u32) {
    MESSAGE = 1,
    ICON = 2,
    TIP = 4,
    STATE = 8,
    INFO = 16,
    GUID = 32,
    REALTIME = 64,
    SHOWTIP = 128,
    _,
    pub fn initFlags(o: struct {
        MESSAGE: u1 = 0,
        ICON: u1 = 0,
        TIP: u1 = 0,
        STATE: u1 = 0,
        INFO: u1 = 0,
        GUID: u1 = 0,
        REALTIME: u1 = 0,
        SHOWTIP: u1 = 0,
    }) NOTIFY_ICON_DATA_FLAGS {
        return @intToEnum(NOTIFY_ICON_DATA_FLAGS,
              (if (o.MESSAGE == 1) @enumToInt(NOTIFY_ICON_DATA_FLAGS.MESSAGE) else 0)
            | (if (o.ICON == 1) @enumToInt(NOTIFY_ICON_DATA_FLAGS.ICON) else 0)
            | (if (o.TIP == 1) @enumToInt(NOTIFY_ICON_DATA_FLAGS.TIP) else 0)
            | (if (o.STATE == 1) @enumToInt(NOTIFY_ICON_DATA_FLAGS.STATE) else 0)
            | (if (o.INFO == 1) @enumToInt(NOTIFY_ICON_DATA_FLAGS.INFO) else 0)
            | (if (o.GUID == 1) @enumToInt(NOTIFY_ICON_DATA_FLAGS.GUID) else 0)
            | (if (o.REALTIME == 1) @enumToInt(NOTIFY_ICON_DATA_FLAGS.REALTIME) else 0)
            | (if (o.SHOWTIP == 1) @enumToInt(NOTIFY_ICON_DATA_FLAGS.SHOWTIP) else 0)
        );
    }
};
pub const NIF_MESSAGE = NOTIFY_ICON_DATA_FLAGS.MESSAGE;
pub const NIF_ICON = NOTIFY_ICON_DATA_FLAGS.ICON;
pub const NIF_TIP = NOTIFY_ICON_DATA_FLAGS.TIP;
pub const NIF_STATE = NOTIFY_ICON_DATA_FLAGS.STATE;
pub const NIF_INFO = NOTIFY_ICON_DATA_FLAGS.INFO;
pub const NIF_GUID = NOTIFY_ICON_DATA_FLAGS.GUID;
pub const NIF_REALTIME = NOTIFY_ICON_DATA_FLAGS.REALTIME;
pub const NIF_SHOWTIP = NOTIFY_ICON_DATA_FLAGS.SHOWTIP;

pub const OS = enum(u32) {
    WINDOWS = 0,
    NT = 1,
    WIN95ORGREATER = 2,
    NT4ORGREATER = 3,
    WIN98ORGREATER = 5,
    WIN98_GOLD = 6,
    WIN2000ORGREATER = 7,
    WIN2000PRO = 8,
    WIN2000SERVER = 9,
    WIN2000ADVSERVER = 10,
    WIN2000DATACENTER = 11,
    WIN2000TERMINAL = 12,
    EMBEDDED = 13,
    TERMINALCLIENT = 14,
    TERMINALREMOTEADMIN = 15,
    WIN95_GOLD = 16,
    MEORGREATER = 17,
    XPORGREATER = 18,
    HOME = 19,
    PROFESSIONAL = 20,
    DATACENTER = 21,
    ADVSERVER = 22,
    SERVER = 23,
    TERMINALSERVER = 24,
    PERSONALTERMINALSERVER = 25,
    FASTUSERSWITCHING = 26,
    WELCOMELOGONUI = 27,
    DOMAINMEMBER = 28,
    ANYSERVER = 29,
    WOW6432 = 30,
    WEBSERVER = 31,
    SMALLBUSINESSSERVER = 32,
    TABLETPC = 33,
    SERVERADMINUI = 34,
    MEDIACENTER = 35,
    APPLIANCE = 36,
};
pub const OS_WINDOWS = OS.WINDOWS;
pub const OS_NT = OS.NT;
pub const OS_WIN95ORGREATER = OS.WIN95ORGREATER;
pub const OS_NT4ORGREATER = OS.NT4ORGREATER;
pub const OS_WIN98ORGREATER = OS.WIN98ORGREATER;
pub const OS_WIN98_GOLD = OS.WIN98_GOLD;
pub const OS_WIN2000ORGREATER = OS.WIN2000ORGREATER;
pub const OS_WIN2000PRO = OS.WIN2000PRO;
pub const OS_WIN2000SERVER = OS.WIN2000SERVER;
pub const OS_WIN2000ADVSERVER = OS.WIN2000ADVSERVER;
pub const OS_WIN2000DATACENTER = OS.WIN2000DATACENTER;
pub const OS_WIN2000TERMINAL = OS.WIN2000TERMINAL;
pub const OS_EMBEDDED = OS.EMBEDDED;
pub const OS_TERMINALCLIENT = OS.TERMINALCLIENT;
pub const OS_TERMINALREMOTEADMIN = OS.TERMINALREMOTEADMIN;
pub const OS_WIN95_GOLD = OS.WIN95_GOLD;
pub const OS_MEORGREATER = OS.MEORGREATER;
pub const OS_XPORGREATER = OS.XPORGREATER;
pub const OS_HOME = OS.HOME;
pub const OS_PROFESSIONAL = OS.PROFESSIONAL;
pub const OS_DATACENTER = OS.DATACENTER;
pub const OS_ADVSERVER = OS.ADVSERVER;
pub const OS_SERVER = OS.SERVER;
pub const OS_TERMINALSERVER = OS.TERMINALSERVER;
pub const OS_PERSONALTERMINALSERVER = OS.PERSONALTERMINALSERVER;
pub const OS_FASTUSERSWITCHING = OS.FASTUSERSWITCHING;
pub const OS_WELCOMELOGONUI = OS.WELCOMELOGONUI;
pub const OS_DOMAINMEMBER = OS.DOMAINMEMBER;
pub const OS_ANYSERVER = OS.ANYSERVER;
pub const OS_WOW6432 = OS.WOW6432;
pub const OS_WEBSERVER = OS.WEBSERVER;
pub const OS_SMALLBUSINESSSERVER = OS.SMALLBUSINESSSERVER;
pub const OS_TABLETPC = OS.TABLETPC;
pub const OS_SERVERADMINUI = OS.SERVERADMINUI;
pub const OS_MEDIACENTER = OS.MEDIACENTER;
pub const OS_APPLIANCE = OS.APPLIANCE;

pub const _APPSTATE_REGISTRATION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const _APPCONSTRAIN_REGISTRATION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

// TODO: this type has a FreeFunc 'SHChangeNotification_Unlock', what can Zig do with this information?
pub const ShFindChangeNotificationHandle = isize;

pub const HDROP = *opaque{};

pub const HPSXA = *opaque{};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INotifyReplica_Value = @import("../zig.zig").Guid.initString("99180163-da16-101a-935c-444553540000");
pub const IID_INotifyReplica = &IID_INotifyReplica_Value;
pub const INotifyReplica = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        YouAreAReplica: fn(
            self: *const INotifyReplica,
            ulcOtherReplicas: u32,
            rgpmkOtherReplicas: [*]?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INotifyReplica_YouAreAReplica(self: *const T, ulcOtherReplicas: u32, rgpmkOtherReplicas: [*]?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const INotifyReplica.VTable, self.vtable).YouAreAReplica(@ptrCast(*const INotifyReplica, self), ulcOtherReplicas, rgpmkOtherReplicas);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APPCATEGORYINFO = extern struct {
    Locale: u32,
    pszDescription: ?PWSTR,
    AppCategoryId: Guid,
};

pub const APPCATEGORYINFOLIST = extern struct {
    cCategory: u32,
    pCategoryInfo: ?*APPCATEGORYINFO,
};

pub const SUBCLASSPROC = fn(
    hWnd: ?HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    uIdSubclass: usize,
    dwRefData: usize,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const HELPINFO = extern struct {
    cbSize: u32,
    iContextType: i32,
    iCtrlId: i32,
    hItemHandle: ?HANDLE,
    dwContextId: usize,
    MousePos: POINT,
};

pub const MULTIKEYHELPA = extern struct {
    mkSize: u32,
    mkKeylist: CHAR,
    szKeyphrase: [1]CHAR,
};

pub const MULTIKEYHELPW = extern struct {
    mkSize: u32,
    mkKeylist: u16,
    szKeyphrase: [1]u16,
};

pub const HELPWININFOA = extern struct {
    wStructSize: i32,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    wMax: i32,
    rgchMember: [2]CHAR,
};

pub const HELPWININFOW = extern struct {
    wStructSize: i32,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    wMax: i32,
    rgchMember: [2]u16,
};

const CLSID_QueryCancelAutoPlay_Value = @import("../zig.zig").Guid.initString("331f1768-05a9-4ddd-b86e-dae34ddc998a");
pub const CLSID_QueryCancelAutoPlay = &CLSID_QueryCancelAutoPlay_Value;

const CLSID_TimeCategorizer_Value = @import("../zig.zig").Guid.initString("3bb4118f-ddfd-4d30-a348-9fb5d6bf1afe");
pub const CLSID_TimeCategorizer = &CLSID_TimeCategorizer_Value;

const CLSID_AlphabeticalCategorizer_Value = @import("../zig.zig").Guid.initString("3c2654c6-7372-4f6b-b310-55d6128f49d2");
pub const CLSID_AlphabeticalCategorizer = &CLSID_AlphabeticalCategorizer_Value;

const CLSID_MergedCategorizer_Value = @import("../zig.zig").Guid.initString("8e827c11-33e7-4bc1-b242-8cd9a1c2b304");
pub const CLSID_MergedCategorizer = &CLSID_MergedCategorizer_Value;

const CLSID_ImageProperties_Value = @import("../zig.zig").Guid.initString("7ab770c7-0e23-4d7a-8aa2-19bfad479829");
pub const CLSID_ImageProperties = &CLSID_ImageProperties_Value;

const CLSID_CDBurn_Value = @import("../zig.zig").Guid.initString("fbeb8a05-beee-4442-804e-409d6c4515e9");
pub const CLSID_CDBurn = &CLSID_CDBurn_Value;

const CLSID_StartMenuPin_Value = @import("../zig.zig").Guid.initString("a2a9545d-a0c2-42b4-9708-a0b2badd77c8");
pub const CLSID_StartMenuPin = &CLSID_StartMenuPin_Value;

const CLSID_WebWizardHost_Value = @import("../zig.zig").Guid.initString("c827f149-55c1-4d28-935e-57e47caed973");
pub const CLSID_WebWizardHost = &CLSID_WebWizardHost_Value;

const CLSID_PublishDropTarget_Value = @import("../zig.zig").Guid.initString("cc6eeffb-43f6-46c5-9619-51d571967f7d");
pub const CLSID_PublishDropTarget = &CLSID_PublishDropTarget_Value;

const CLSID_PublishingWizard_Value = @import("../zig.zig").Guid.initString("6b33163c-76a5-4b6c-bf21-45de9cd503a1");
pub const CLSID_PublishingWizard = &CLSID_PublishingWizard_Value;

const CLSID_InternetPrintOrdering_Value = @import("../zig.zig").Guid.initString("add36aa8-751a-4579-a266-d66f5202ccbb");
pub const CLSID_InternetPrintOrdering = &CLSID_InternetPrintOrdering_Value;

const CLSID_FolderViewHost_Value = @import("../zig.zig").Guid.initString("20b1cb23-6968-4eb9-b7d4-a66d00d07cee");
pub const CLSID_FolderViewHost = &CLSID_FolderViewHost_Value;

const CLSID_ExplorerBrowser_Value = @import("../zig.zig").Guid.initString("71f96385-ddd6-48d3-a0c1-ae06e8b055fb");
pub const CLSID_ExplorerBrowser = &CLSID_ExplorerBrowser_Value;

const CLSID_ImageRecompress_Value = @import("../zig.zig").Guid.initString("6e33091c-d2f8-4740-b55e-2e11d1477a2c");
pub const CLSID_ImageRecompress = &CLSID_ImageRecompress_Value;

const CLSID_TrayBandSiteService_Value = @import("../zig.zig").Guid.initString("f60ad0a0-e5e1-45cb-b51a-e15b9f8b2934");
pub const CLSID_TrayBandSiteService = &CLSID_TrayBandSiteService_Value;

const CLSID_TrayDeskBand_Value = @import("../zig.zig").Guid.initString("e6442437-6c68-4f52-94dd-2cfed267efb9");
pub const CLSID_TrayDeskBand = &CLSID_TrayDeskBand_Value;

const CLSID_AttachmentServices_Value = @import("../zig.zig").Guid.initString("4125dd96-e03a-4103-8f70-e0597d803b9c");
pub const CLSID_AttachmentServices = &CLSID_AttachmentServices_Value;

const CLSID_DocPropShellExtension_Value = @import("../zig.zig").Guid.initString("883373c3-bf89-11d1-be35-080036b11a03");
pub const CLSID_DocPropShellExtension = &CLSID_DocPropShellExtension_Value;

const CLSID_FSCopyHandler_Value = @import("../zig.zig").Guid.initString("d197380a-0a79-4dc8-a033-ed882c2fa14b");
pub const CLSID_FSCopyHandler = &CLSID_FSCopyHandler_Value;

const CLSID_PreviousVersions_Value = @import("../zig.zig").Guid.initString("596ab062-b4d2-4215-9f74-e9109b0a8153");
pub const CLSID_PreviousVersions = &CLSID_PreviousVersions_Value;

const CLSID_NamespaceTreeControl_Value = @import("../zig.zig").Guid.initString("ae054212-3535-4430-83ed-d501aa6680e6");
pub const CLSID_NamespaceTreeControl = &CLSID_NamespaceTreeControl_Value;

const CLSID_IENamespaceTreeControl_Value = @import("../zig.zig").Guid.initString("ace52d03-e5cd-4b20-82ff-e71b11beae1d");
pub const CLSID_IENamespaceTreeControl = &CLSID_IENamespaceTreeControl_Value;

const CLSID_ApplicationAssociationRegistrationUI_Value = @import("../zig.zig").Guid.initString("1968106d-f3b5-44cf-890e-116fcb9ecef1");
pub const CLSID_ApplicationAssociationRegistrationUI = &CLSID_ApplicationAssociationRegistrationUI_Value;

const CLSID_DesktopGadget_Value = @import("../zig.zig").Guid.initString("924ccc1b-6562-4c85-8657-d177925222b6");
pub const CLSID_DesktopGadget = &CLSID_DesktopGadget_Value;

const CLSID_AccessibilityDockingService_Value = @import("../zig.zig").Guid.initString("29ce1d46-b481-4aa0-a08a-d3ebc8aca402");
pub const CLSID_AccessibilityDockingService = &CLSID_AccessibilityDockingService_Value;

const CLSID_ExecuteFolder_Value = @import("../zig.zig").Guid.initString("11dbb47c-a525-400b-9e80-a54615a090c0");
pub const CLSID_ExecuteFolder = &CLSID_ExecuteFolder_Value;

const CLSID_VirtualDesktopManager_Value = @import("../zig.zig").Guid.initString("aa509086-5ca9-4c25-8f95-589d3c07b48a");
pub const CLSID_VirtualDesktopManager = &CLSID_VirtualDesktopManager_Value;

const CLSID_StorageProviderBanners_Value = @import("../zig.zig").Guid.initString("7ccdf9f4-e576-455a-8bc7-f6ec68d6f063");
pub const CLSID_StorageProviderBanners = &CLSID_StorageProviderBanners_Value;

const CLSID_DesktopWallpaper_Value = @import("../zig.zig").Guid.initString("c2cf3110-460e-4fc1-b9d0-8a1c0c9cc4bd");
pub const CLSID_DesktopWallpaper = &CLSID_DesktopWallpaper_Value;

const CLSID_ShellDesktop_Value = @import("../zig.zig").Guid.initString("00021400-0000-0000-c000-000000000046");
pub const CLSID_ShellDesktop = &CLSID_ShellDesktop_Value;

const CLSID_ShellFSFolder_Value = @import("../zig.zig").Guid.initString("f3364ba0-65b9-11ce-a9ba-00aa004ae837");
pub const CLSID_ShellFSFolder = &CLSID_ShellFSFolder_Value;

const CLSID_NetworkPlaces_Value = @import("../zig.zig").Guid.initString("208d2c60-3aea-1069-a2d7-08002b30309d");
pub const CLSID_NetworkPlaces = &CLSID_NetworkPlaces_Value;

const CLSID_ShellLink_Value = @import("../zig.zig").Guid.initString("00021401-0000-0000-c000-000000000046");
pub const CLSID_ShellLink = &CLSID_ShellLink_Value;

const CLSID_DriveSizeCategorizer_Value = @import("../zig.zig").Guid.initString("94357b53-ca29-4b78-83ae-e8fe7409134f");
pub const CLSID_DriveSizeCategorizer = &CLSID_DriveSizeCategorizer_Value;

const CLSID_DriveTypeCategorizer_Value = @import("../zig.zig").Guid.initString("b0a8f3cf-4333-4bab-8873-1ccb1cada48b");
pub const CLSID_DriveTypeCategorizer = &CLSID_DriveTypeCategorizer_Value;

const CLSID_FreeSpaceCategorizer_Value = @import("../zig.zig").Guid.initString("b5607793-24ac-44c7-82e2-831726aa6cb7");
pub const CLSID_FreeSpaceCategorizer = &CLSID_FreeSpaceCategorizer_Value;

const CLSID_SizeCategorizer_Value = @import("../zig.zig").Guid.initString("55d7b852-f6d1-42f2-aa75-8728a1b2d264");
pub const CLSID_SizeCategorizer = &CLSID_SizeCategorizer_Value;

const CLSID_PropertiesUI_Value = @import("../zig.zig").Guid.initString("d912f8cf-0396-4915-884e-fb425d32943b");
pub const CLSID_PropertiesUI = &CLSID_PropertiesUI_Value;

const CLSID_UserNotification_Value = @import("../zig.zig").Guid.initString("0010890e-8789-413c-adbc-48f5b511b3af");
pub const CLSID_UserNotification = &CLSID_UserNotification_Value;

const CLSID_TaskbarList_Value = @import("../zig.zig").Guid.initString("56fdf344-fd6d-11d0-958a-006097c9a090");
pub const CLSID_TaskbarList = &CLSID_TaskbarList_Value;

const CLSID_ShellItem_Value = @import("../zig.zig").Guid.initString("9ac9fbe1-e0a2-4ad6-b4ee-e212013ea917");
pub const CLSID_ShellItem = &CLSID_ShellItem_Value;

const CLSID_NamespaceWalker_Value = @import("../zig.zig").Guid.initString("72eb61e0-8672-4303-9175-f2e4c68b2e7c");
pub const CLSID_NamespaceWalker = &CLSID_NamespaceWalker_Value;

const CLSID_FileOperation_Value = @import("../zig.zig").Guid.initString("3ad05575-8857-4850-9277-11b85bdb8e09");
pub const CLSID_FileOperation = &CLSID_FileOperation_Value;

const CLSID_FileOpenDialog_Value = @import("../zig.zig").Guid.initString("dc1c5a9c-e88a-4dde-a5a1-60f82a20aef7");
pub const CLSID_FileOpenDialog = &CLSID_FileOpenDialog_Value;

const CLSID_FileSaveDialog_Value = @import("../zig.zig").Guid.initString("c0b4e2f3-ba21-4773-8dba-335ec946eb8b");
pub const CLSID_FileSaveDialog = &CLSID_FileSaveDialog_Value;

const CLSID_KnownFolderManager_Value = @import("../zig.zig").Guid.initString("4df0c730-df9d-4ae3-9153-aa6b82e9795a");
pub const CLSID_KnownFolderManager = &CLSID_KnownFolderManager_Value;

const CLSID_SharingConfigurationManager_Value = @import("../zig.zig").Guid.initString("49f371e1-8c5c-4d9c-9a3b-54a6827f513c");
pub const CLSID_SharingConfigurationManager = &CLSID_SharingConfigurationManager_Value;

const CLSID_NetworkConnections_Value = @import("../zig.zig").Guid.initString("7007acc7-3202-11d1-aad2-00805fc1270e");
pub const CLSID_NetworkConnections = &CLSID_NetworkConnections_Value;

const CLSID_ScheduledTasks_Value = @import("../zig.zig").Guid.initString("d6277990-4c6a-11cf-8d87-00aa0060f5bf");
pub const CLSID_ScheduledTasks = &CLSID_ScheduledTasks_Value;

const CLSID_ApplicationAssociationRegistration_Value = @import("../zig.zig").Guid.initString("591209c7-767b-42b2-9fba-44ee4615f2c7");
pub const CLSID_ApplicationAssociationRegistration = &CLSID_ApplicationAssociationRegistration_Value;

const CLSID_SearchFolderItemFactory_Value = @import("../zig.zig").Guid.initString("14010e02-bbbd-41f0-88e3-eda371216584");
pub const CLSID_SearchFolderItemFactory = &CLSID_SearchFolderItemFactory_Value;

const CLSID_OpenControlPanel_Value = @import("../zig.zig").Guid.initString("06622d85-6856-4460-8de1-a81921b41c4b");
pub const CLSID_OpenControlPanel = &CLSID_OpenControlPanel_Value;

const CLSID_MailRecipient_Value = @import("../zig.zig").Guid.initString("9e56be60-c50f-11cf-9a2c-00a0c90a90ce");
pub const CLSID_MailRecipient = &CLSID_MailRecipient_Value;

const CLSID_NetworkExplorerFolder_Value = @import("../zig.zig").Guid.initString("f02c1a0d-be21-4350-88b0-7367fc96ef3c");
pub const CLSID_NetworkExplorerFolder = &CLSID_NetworkExplorerFolder_Value;

const CLSID_DestinationList_Value = @import("../zig.zig").Guid.initString("77f10cf0-3db5-4966-b520-b7c54fd35ed6");
pub const CLSID_DestinationList = &CLSID_DestinationList_Value;

const CLSID_ApplicationDestinations_Value = @import("../zig.zig").Guid.initString("86c14003-4d6b-4ef3-a7b4-0506663b2e68");
pub const CLSID_ApplicationDestinations = &CLSID_ApplicationDestinations_Value;

const CLSID_ApplicationDocumentLists_Value = @import("../zig.zig").Guid.initString("86bec222-30f2-47e0-9f25-60d11cd75c28");
pub const CLSID_ApplicationDocumentLists = &CLSID_ApplicationDocumentLists_Value;

const CLSID_HomeGroup_Value = @import("../zig.zig").Guid.initString("de77ba04-3c92-4d11-a1a5-42352a53e0e3");
pub const CLSID_HomeGroup = &CLSID_HomeGroup_Value;

const CLSID_ShellLibrary_Value = @import("../zig.zig").Guid.initString("d9b3211d-e57f-4426-aaef-30a806add397");
pub const CLSID_ShellLibrary = &CLSID_ShellLibrary_Value;

const CLSID_AppStartupLink_Value = @import("../zig.zig").Guid.initString("273eb5e7-88b0-4843-bfef-e2c81d43aae5");
pub const CLSID_AppStartupLink = &CLSID_AppStartupLink_Value;

const CLSID_EnumerableObjectCollection_Value = @import("../zig.zig").Guid.initString("2d3468c1-36a7-43b6-ac24-d3f02fd9607a");
pub const CLSID_EnumerableObjectCollection = &CLSID_EnumerableObjectCollection_Value;

const CLSID_FrameworkInputPane_Value = @import("../zig.zig").Guid.initString("d5120aa3-46ba-44c5-822d-ca8092c1fc72");
pub const CLSID_FrameworkInputPane = &CLSID_FrameworkInputPane_Value;

const CLSID_DefFolderMenu_Value = @import("../zig.zig").Guid.initString("c63382be-7933-48d0-9ac8-85fb46be2fdd");
pub const CLSID_DefFolderMenu = &CLSID_DefFolderMenu_Value;

const CLSID_AppVisibility_Value = @import("../zig.zig").Guid.initString("7e5fe3d9-985f-4908-91f9-ee19f9fd1514");
pub const CLSID_AppVisibility = &CLSID_AppVisibility_Value;

const CLSID_AppShellVerbHandler_Value = @import("../zig.zig").Guid.initString("4ed3a719-cea8-4bd9-910d-e252f997afc2");
pub const CLSID_AppShellVerbHandler = &CLSID_AppShellVerbHandler_Value;

const CLSID_ExecuteUnknown_Value = @import("../zig.zig").Guid.initString("e44e9428-bdbc-4987-a099-40dc8fd255e7");
pub const CLSID_ExecuteUnknown = &CLSID_ExecuteUnknown_Value;

const CLSID_PackageDebugSettings_Value = @import("../zig.zig").Guid.initString("b1aec16f-2383-4852-b0e9-8f0b1dc66b4d");
pub const CLSID_PackageDebugSettings = &CLSID_PackageDebugSettings_Value;

const CLSID_SuspensionDependencyManager_Value = @import("../zig.zig").Guid.initString("6b273fc5-61fd-4918-95a2-c3b5e9d7f581");
pub const CLSID_SuspensionDependencyManager = &CLSID_SuspensionDependencyManager_Value;

const CLSID_ApplicationActivationManager_Value = @import("../zig.zig").Guid.initString("45ba127d-10a8-46ea-8ab7-56ea9078943c");
pub const CLSID_ApplicationActivationManager = &CLSID_ApplicationActivationManager_Value;

const CLSID_ApplicationDesignModeSettings_Value = @import("../zig.zig").Guid.initString("958a6fb5-dcb2-4faf-aafd-7fb054ad1a3b");
pub const CLSID_ApplicationDesignModeSettings = &CLSID_ApplicationDesignModeSettings_Value;

pub const CMINVOKECOMMANDINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    hwnd: ?HWND,
    lpVerb: ?[*:0]const u8,
    lpParameters: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    nShow: i32,
    dwHotKey: u32,
    hIcon: ?HANDLE,
};

pub const CMINVOKECOMMANDINFOEX = extern struct {
    cbSize: u32,
    fMask: u32,
    hwnd: ?HWND,
    lpVerb: ?[*:0]const u8,
    lpParameters: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    nShow: i32,
    dwHotKey: u32,
    hIcon: ?HANDLE,
    lpTitle: ?[*:0]const u8,
    lpVerbW: ?[*:0]const u16,
    lpParametersW: ?[*:0]const u16,
    lpDirectoryW: ?[*:0]const u16,
    lpTitleW: ?[*:0]const u16,
    ptInvoke: POINT,
};

pub const CMINVOKECOMMANDINFOEX_REMOTE = extern struct {
    cbSize: u32,
    fMask: u32,
    hwnd: ?HWND,
    lpVerbString: ?[*:0]const u8,
    lpParameters: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    nShow: i32,
    dwHotKey: u32,
    lpTitle: ?[*:0]const u8,
    lpVerbWString: ?[*:0]const u16,
    lpParametersW: ?[*:0]const u16,
    lpDirectoryW: ?[*:0]const u16,
    lpTitleW: ?[*:0]const u16,
    ptInvoke: POINT,
    lpVerbInt: u32,
    lpVerbWInt: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IContextMenu_Value = @import("../zig.zig").Guid.initString("000214e4-0000-0000-c000-000000000046");
pub const IID_IContextMenu = &IID_IContextMenu_Value;
pub const IContextMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContextMenu: fn(
            self: *const IContextMenu,
            hmenu: ?HMENU,
            indexMenu: u32,
            idCmdFirst: u32,
            idCmdLast: u32,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeCommand: fn(
            self: *const IContextMenu,
            pici: ?*CMINVOKECOMMANDINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCommandString: fn(
            self: *const IContextMenu,
            idCmd: usize,
            uType: u32,
            pReserved: ?*u32,
            pszName: ?PSTR,
            cchMax: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenu_QueryContextMenu(self: *const T, hmenu: ?HMENU, indexMenu: u32, idCmdFirst: u32, idCmdLast: u32, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenu.VTable, self.vtable).QueryContextMenu(@ptrCast(*const IContextMenu, self), hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenu_InvokeCommand(self: *const T, pici: ?*CMINVOKECOMMANDINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenu.VTable, self.vtable).InvokeCommand(@ptrCast(*const IContextMenu, self), pici);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenu_GetCommandString(self: *const T, idCmd: usize, uType: u32, pReserved: ?*u32, pszName: ?PSTR, cchMax: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenu.VTable, self.vtable).GetCommandString(@ptrCast(*const IContextMenu, self), idCmd, uType, pReserved, pszName, cchMax);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IContextMenu2_Value = @import("../zig.zig").Guid.initString("000214f4-0000-0000-c000-000000000046");
pub const IID_IContextMenu2 = &IID_IContextMenu2_Value;
pub const IContextMenu2 = extern struct {
    pub const VTable = extern struct {
        base: IContextMenu.VTable,
        HandleMenuMsg: fn(
            self: *const IContextMenu2,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IContextMenu.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenu2_HandleMenuMsg(self: *const T, uMsg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenu2.VTable, self.vtable).HandleMenuMsg(@ptrCast(*const IContextMenu2, self), uMsg, wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IContextMenu3_Value = @import("../zig.zig").Guid.initString("bcfce0a0-ec17-11d0-8d10-00a0c90f2719");
pub const IID_IContextMenu3 = &IID_IContextMenu3_Value;
pub const IContextMenu3 = extern struct {
    pub const VTable = extern struct {
        base: IContextMenu2.VTable,
        HandleMenuMsg2: fn(
            self: *const IContextMenu3,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            plResult: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IContextMenu2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenu3_HandleMenuMsg2(self: *const T, uMsg: u32, wParam: WPARAM, lParam: LPARAM, plResult: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenu3.VTable, self.vtable).HandleMenuMsg2(@ptrCast(*const IContextMenu3, self), uMsg, wParam, lParam, plResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IExecuteCommand_Value = @import("../zig.zig").Guid.initString("7f9185b0-cb92-43c5-80a9-92277a4f7b54");
pub const IID_IExecuteCommand = &IID_IExecuteCommand_Value;
pub const IExecuteCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetKeyState: fn(
            self: *const IExecuteCommand,
            grfKeyState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameters: fn(
            self: *const IExecuteCommand,
            pszParameters: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPosition: fn(
            self: *const IExecuteCommand,
            pt: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShowWindow: fn(
            self: *const IExecuteCommand,
            nShow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNoShowUI: fn(
            self: *const IExecuteCommand,
            fNoShowUI: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectory: fn(
            self: *const IExecuteCommand,
            pszDirectory: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IExecuteCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecuteCommand_SetKeyState(self: *const T, grfKeyState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecuteCommand.VTable, self.vtable).SetKeyState(@ptrCast(*const IExecuteCommand, self), grfKeyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecuteCommand_SetParameters(self: *const T, pszParameters: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecuteCommand.VTable, self.vtable).SetParameters(@ptrCast(*const IExecuteCommand, self), pszParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecuteCommand_SetPosition(self: *const T, pt: POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecuteCommand.VTable, self.vtable).SetPosition(@ptrCast(*const IExecuteCommand, self), pt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecuteCommand_SetShowWindow(self: *const T, nShow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecuteCommand.VTable, self.vtable).SetShowWindow(@ptrCast(*const IExecuteCommand, self), nShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecuteCommand_SetNoShowUI(self: *const T, fNoShowUI: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecuteCommand.VTable, self.vtable).SetNoShowUI(@ptrCast(*const IExecuteCommand, self), fNoShowUI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecuteCommand_SetDirectory(self: *const T, pszDirectory: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecuteCommand.VTable, self.vtable).SetDirectory(@ptrCast(*const IExecuteCommand, self), pszDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecuteCommand_Execute(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecuteCommand.VTable, self.vtable).Execute(@ptrCast(*const IExecuteCommand, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPersistFolder_Value = @import("../zig.zig").Guid.initString("000214ea-0000-0000-c000-000000000046");
pub const IID_IPersistFolder = &IID_IPersistFolder_Value;
pub const IPersistFolder = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        Initialize: fn(
            self: *const IPersistFolder,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFolder_Initialize(self: *const T, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFolder.VTable, self.vtable).Initialize(@ptrCast(*const IPersistFolder, self), pidl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunnableTask_Value = @import("../zig.zig").Guid.initString("85788d00-6807-11d0-b810-00c04fd706ec");
pub const IID_IRunnableTask = &IID_IRunnableTask_Value;
pub const IRunnableTask = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Run: fn(
            self: *const IRunnableTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Kill: fn(
            self: *const IRunnableTask,
            bWait: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const IRunnableTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IRunnableTask,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRunning: fn(
            self: *const IRunnableTask,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableTask_Run(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableTask.VTable, self.vtable).Run(@ptrCast(*const IRunnableTask, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableTask_Kill(self: *const T, bWait: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableTask.VTable, self.vtable).Kill(@ptrCast(*const IRunnableTask, self), bWait);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableTask_Suspend(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableTask.VTable, self.vtable).Suspend(@ptrCast(*const IRunnableTask, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableTask_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRunnableTask.VTable, self.vtable).Resume(@ptrCast(*const IRunnableTask, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRunnableTask_IsRunning(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IRunnableTask.VTable, self.vtable).IsRunning(@ptrCast(*const IRunnableTask, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellTaskScheduler_Value = @import("../zig.zig").Guid.initString("6ccb7be0-6807-11d0-b810-00c04fd706ec");
pub const IID_IShellTaskScheduler = &IID_IShellTaskScheduler_Value;
pub const IShellTaskScheduler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddTask: fn(
            self: *const IShellTaskScheduler,
            prt: ?*IRunnableTask,
            rtoid: ?*const Guid,
            lParam: usize,
            dwPriority: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTasks: fn(
            self: *const IShellTaskScheduler,
            rtoid: ?*const Guid,
            lParam: usize,
            bWaitIfRunning: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CountTasks: fn(
            self: *const IShellTaskScheduler,
            rtoid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Status: fn(
            self: *const IShellTaskScheduler,
            dwReleaseStatus: u32,
            dwThreadTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellTaskScheduler_AddTask(self: *const T, prt: ?*IRunnableTask, rtoid: ?*const Guid, lParam: usize, dwPriority: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellTaskScheduler.VTable, self.vtable).AddTask(@ptrCast(*const IShellTaskScheduler, self), prt, rtoid, lParam, dwPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellTaskScheduler_RemoveTasks(self: *const T, rtoid: ?*const Guid, lParam: usize, bWaitIfRunning: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellTaskScheduler.VTable, self.vtable).RemoveTasks(@ptrCast(*const IShellTaskScheduler, self), rtoid, lParam, bWaitIfRunning);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellTaskScheduler_CountTasks(self: *const T, rtoid: ?*const Guid) callconv(.Inline) u32 {
            return @ptrCast(*const IShellTaskScheduler.VTable, self.vtable).CountTasks(@ptrCast(*const IShellTaskScheduler, self), rtoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellTaskScheduler_Status(self: *const T, dwReleaseStatus: u32, dwThreadTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellTaskScheduler.VTable, self.vtable).Status(@ptrCast(*const IShellTaskScheduler, self), dwReleaseStatus, dwThreadTimeout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistFolder2_Value = @import("../zig.zig").Guid.initString("1ac3d9f0-175c-11d1-95be-00609797ea4f");
pub const IID_IPersistFolder2 = &IID_IPersistFolder2_Value;
pub const IPersistFolder2 = extern struct {
    pub const VTable = extern struct {
        base: IPersistFolder.VTable,
        GetCurFolder: fn(
            self: *const IPersistFolder2,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistFolder.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFolder2_GetCurFolder(self: *const T, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFolder2.VTable, self.vtable).GetCurFolder(@ptrCast(*const IPersistFolder2, self), ppidl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PERSIST_FOLDER_TARGET_INFO = extern struct {
    pidlTargetFolder: ?*ITEMIDLIST,
    szTargetParsingName: [260]u16,
    szNetworkProvider: [260]u16,
    dwAttributes: u32,
    csidl: i32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistFolder3_Value = @import("../zig.zig").Guid.initString("cef04fdf-fe72-11d2-87a5-00c04f6837cf");
pub const IID_IPersistFolder3 = &IID_IPersistFolder3_Value;
pub const IPersistFolder3 = extern struct {
    pub const VTable = extern struct {
        base: IPersistFolder2.VTable,
        InitializeEx: fn(
            self: *const IPersistFolder3,
            pbc: ?*IBindCtx,
            pidlRoot: ?*ITEMIDLIST,
            ppfti: ?*const PERSIST_FOLDER_TARGET_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolderTargetInfo: fn(
            self: *const IPersistFolder3,
            ppfti: ?*PERSIST_FOLDER_TARGET_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistFolder2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFolder3_InitializeEx(self: *const T, pbc: ?*IBindCtx, pidlRoot: ?*ITEMIDLIST, ppfti: ?*const PERSIST_FOLDER_TARGET_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFolder3.VTable, self.vtable).InitializeEx(@ptrCast(*const IPersistFolder3, self), pbc, pidlRoot, ppfti);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistFolder3_GetFolderTargetInfo(self: *const T, ppfti: ?*PERSIST_FOLDER_TARGET_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistFolder3.VTable, self.vtable).GetFolderTargetInfo(@ptrCast(*const IPersistFolder3, self), ppfti);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPersistIDList_Value = @import("../zig.zig").Guid.initString("1079acfc-29bd-11d3-8e0d-00c04f6837d5");
pub const IID_IPersistIDList = &IID_IPersistIDList_Value;
pub const IPersistIDList = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        SetIDList: fn(
            self: *const IPersistIDList,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDList: fn(
            self: *const IPersistIDList,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistIDList_SetIDList(self: *const T, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistIDList.VTable, self.vtable).SetIDList(@ptrCast(*const IPersistIDList, self), pidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistIDList_GetIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistIDList.VTable, self.vtable).GetIDList(@ptrCast(*const IPersistIDList, self), ppidl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumIDList_Value = @import("../zig.zig").Guid.initString("000214f2-0000-0000-c000-000000000046");
pub const IID_IEnumIDList = &IID_IEnumIDList_Value;
pub const IEnumIDList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumIDList,
            celt: u32,
            rgelt: [*]?*ITEMIDLIST,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumIDList,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumIDList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumIDList,
            ppenum: ?*?*IEnumIDList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumIDList_Next(self: *const T, celt: u32, rgelt: [*]?*ITEMIDLIST, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumIDList.VTable, self.vtable).Next(@ptrCast(*const IEnumIDList, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumIDList_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumIDList.VTable, self.vtable).Skip(@ptrCast(*const IEnumIDList, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumIDList_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumIDList.VTable, self.vtable).Reset(@ptrCast(*const IEnumIDList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumIDList_Clone(self: *const T, ppenum: ?*?*IEnumIDList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumIDList.VTable, self.vtable).Clone(@ptrCast(*const IEnumIDList, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumFullIDList_Value = @import("../zig.zig").Guid.initString("d0191542-7954-4908-bc06-b2360bbe45ba");
pub const IID_IEnumFullIDList = &IID_IEnumFullIDList_Value;
pub const IEnumFullIDList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumFullIDList,
            celt: u32,
            rgelt: [*]?*ITEMIDLIST,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumFullIDList,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumFullIDList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumFullIDList,
            ppenum: ?*?*IEnumFullIDList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFullIDList_Next(self: *const T, celt: u32, rgelt: [*]?*ITEMIDLIST, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFullIDList.VTable, self.vtable).Next(@ptrCast(*const IEnumFullIDList, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFullIDList_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFullIDList.VTable, self.vtable).Skip(@ptrCast(*const IEnumFullIDList, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFullIDList_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFullIDList.VTable, self.vtable).Reset(@ptrCast(*const IEnumFullIDList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFullIDList_Clone(self: *const T, ppenum: ?*?*IEnumFullIDList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumFullIDList.VTable, self.vtable).Clone(@ptrCast(*const IEnumFullIDList, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _SHGDNF = enum(i32) {
    NORMAL = 0,
    INFOLDER = 1,
    FOREDITING = 4096,
    FORADDRESSBAR = 16384,
    FORPARSING = 32768,
};
pub const SHGDN_NORMAL = _SHGDNF.NORMAL;
pub const SHGDN_INFOLDER = _SHGDNF.INFOLDER;
pub const SHGDN_FOREDITING = _SHGDNF.FOREDITING;
pub const SHGDN_FORADDRESSBAR = _SHGDNF.FORADDRESSBAR;
pub const SHGDN_FORPARSING = _SHGDNF.FORPARSING;

pub const _SHCONTF = enum(i32) {
    CHECKING_FOR_CHILDREN = 16,
    FOLDERS = 32,
    NONFOLDERS = 64,
    INCLUDEHIDDEN = 128,
    INIT_ON_FIRST_NEXT = 256,
    NETPRINTERSRCH = 512,
    SHAREABLE = 1024,
    STORAGE = 2048,
    NAVIGATION_ENUM = 4096,
    FASTITEMS = 8192,
    FLATLIST = 16384,
    ENABLE_ASYNC = 32768,
    INCLUDESUPERHIDDEN = 65536,
};
pub const SHCONTF_CHECKING_FOR_CHILDREN = _SHCONTF.CHECKING_FOR_CHILDREN;
pub const SHCONTF_FOLDERS = _SHCONTF.FOLDERS;
pub const SHCONTF_NONFOLDERS = _SHCONTF.NONFOLDERS;
pub const SHCONTF_INCLUDEHIDDEN = _SHCONTF.INCLUDEHIDDEN;
pub const SHCONTF_INIT_ON_FIRST_NEXT = _SHCONTF.INIT_ON_FIRST_NEXT;
pub const SHCONTF_NETPRINTERSRCH = _SHCONTF.NETPRINTERSRCH;
pub const SHCONTF_SHAREABLE = _SHCONTF.SHAREABLE;
pub const SHCONTF_STORAGE = _SHCONTF.STORAGE;
pub const SHCONTF_NAVIGATION_ENUM = _SHCONTF.NAVIGATION_ENUM;
pub const SHCONTF_FASTITEMS = _SHCONTF.FASTITEMS;
pub const SHCONTF_FLATLIST = _SHCONTF.FLATLIST;
pub const SHCONTF_ENABLE_ASYNC = _SHCONTF.ENABLE_ASYNC;
pub const SHCONTF_INCLUDESUPERHIDDEN = _SHCONTF.INCLUDESUPERHIDDEN;

pub const STORAGE_PROVIDER_FILE_FLAGS = enum(i32) {
    NONE = 0,
    DOWNLOAD_BY_DEFAULT = 1,
    CREATED_ON_THIS_DEVICE = 2,
};
pub const SPFF_NONE = STORAGE_PROVIDER_FILE_FLAGS.NONE;
pub const SPFF_DOWNLOAD_BY_DEFAULT = STORAGE_PROVIDER_FILE_FLAGS.DOWNLOAD_BY_DEFAULT;
pub const SPFF_CREATED_ON_THIS_DEVICE = STORAGE_PROVIDER_FILE_FLAGS.CREATED_ON_THIS_DEVICE;

pub const MERGE_UPDATE_STATUS = enum(i32) {
    COMPLETE = 0,
    USERINPUTNEEDED = 1,
    FAILED = 2,
};
pub const MUS_COMPLETE = MERGE_UPDATE_STATUS.COMPLETE;
pub const MUS_USERINPUTNEEDED = MERGE_UPDATE_STATUS.USERINPUTNEEDED;
pub const MUS_FAILED = MERGE_UPDATE_STATUS.FAILED;

// TODO: this type is limited to platform 'windows8.1'
const IID_IFileSyncMergeHandler_Value = @import("../zig.zig").Guid.initString("d97b5aac-c792-433c-975d-35c4eadc7a9d");
pub const IID_IFileSyncMergeHandler = &IID_IFileSyncMergeHandler_Value;
pub const IFileSyncMergeHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Merge: fn(
            self: *const IFileSyncMergeHandler,
            localFilePath: ?[*:0]const u16,
            serverFilePath: ?[*:0]const u16,
            updateStatus: ?*MERGE_UPDATE_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowResolveConflictUIAsync: fn(
            self: *const IFileSyncMergeHandler,
            localFilePath: ?[*:0]const u16,
            monitorToDisplayOn: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSyncMergeHandler_Merge(self: *const T, localFilePath: ?[*:0]const u16, serverFilePath: ?[*:0]const u16, updateStatus: ?*MERGE_UPDATE_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSyncMergeHandler.VTable, self.vtable).Merge(@ptrCast(*const IFileSyncMergeHandler, self), localFilePath, serverFilePath, updateStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSyncMergeHandler_ShowResolveConflictUIAsync(self: *const T, localFilePath: ?[*:0]const u16, monitorToDisplayOn: ?HMONITOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSyncMergeHandler.VTable, self.vtable).ShowResolveConflictUIAsync(@ptrCast(*const IFileSyncMergeHandler, self), localFilePath, monitorToDisplayOn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FOLDER_ENUM_MODE = enum(i32) {
    VIEWRESULT = 0,
    NAVIGATION = 1,
};
pub const FEM_VIEWRESULT = FOLDER_ENUM_MODE.VIEWRESULT;
pub const FEM_NAVIGATION = FOLDER_ENUM_MODE.NAVIGATION;

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithFolderEnumMode_Value = @import("../zig.zig").Guid.initString("6a9d9026-0e6e-464c-b000-42ecc07de673");
pub const IID_IObjectWithFolderEnumMode = &IID_IObjectWithFolderEnumMode_Value;
pub const IObjectWithFolderEnumMode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMode: fn(
            self: *const IObjectWithFolderEnumMode,
            feMode: FOLDER_ENUM_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMode: fn(
            self: *const IObjectWithFolderEnumMode,
            pfeMode: ?*FOLDER_ENUM_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithFolderEnumMode_SetMode(self: *const T, feMode: FOLDER_ENUM_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithFolderEnumMode.VTable, self.vtable).SetMode(@ptrCast(*const IObjectWithFolderEnumMode, self), feMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithFolderEnumMode_GetMode(self: *const T, pfeMode: ?*FOLDER_ENUM_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithFolderEnumMode.VTable, self.vtable).GetMode(@ptrCast(*const IObjectWithFolderEnumMode, self), pfeMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IParseAndCreateItem_Value = @import("../zig.zig").Guid.initString("67efed0e-e827-4408-b493-78f3982b685c");
pub const IID_IParseAndCreateItem = &IID_IParseAndCreateItem_Value;
pub const IParseAndCreateItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetItem: fn(
            self: *const IParseAndCreateItem,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const IParseAndCreateItem,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IParseAndCreateItem_SetItem(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IParseAndCreateItem.VTable, self.vtable).SetItem(@ptrCast(*const IParseAndCreateItem, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IParseAndCreateItem_GetItem(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IParseAndCreateItem.VTable, self.vtable).GetItem(@ptrCast(*const IParseAndCreateItem, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolder_Value = @import("../zig.zig").Guid.initString("000214e6-0000-0000-c000-000000000046");
pub const IID_IShellFolder = &IID_IShellFolder_Value;
pub const IShellFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseDisplayName: fn(
            self: *const IShellFolder,
            hwnd: ?HWND,
            pbc: ?*IBindCtx,
            pszDisplayName: ?PWSTR,
            pchEaten: ?*u32,
            ppidl: ?*?*ITEMIDLIST,
            pdwAttributes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumObjects: fn(
            self: *const IShellFolder,
            hwnd: ?HWND,
            grfFlags: u32,
            ppenumIDList: ?*?*IEnumIDList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToObject: fn(
            self: *const IShellFolder,
            pidl: ?*ITEMIDLIST,
            pbc: ?*IBindCtx,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToStorage: fn(
            self: *const IShellFolder,
            pidl: ?*ITEMIDLIST,
            pbc: ?*IBindCtx,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareIDs: fn(
            self: *const IShellFolder,
            lParam: LPARAM,
            pidl1: ?*ITEMIDLIST,
            pidl2: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateViewObject: fn(
            self: *const IShellFolder,
            hwndOwner: ?HWND,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributesOf: fn(
            self: *const IShellFolder,
            cidl: u32,
            apidl: [*]?*ITEMIDLIST,
            rgfInOut: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUIObjectOf: fn(
            self: *const IShellFolder,
            hwndOwner: ?HWND,
            cidl: u32,
            apidl: [*]?*ITEMIDLIST,
            riid: ?*const Guid,
            rgfReserved: ?*u32,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayNameOf: fn(
            self: *const IShellFolder,
            pidl: ?*ITEMIDLIST,
            uFlags: u32,
            pName: ?*STRRET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNameOf: fn(
            self: *const IShellFolder,
            hwnd: ?HWND,
            pidl: ?*ITEMIDLIST,
            pszName: ?[*:0]const u16,
            uFlags: u32,
            ppidlOut: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_ParseDisplayName(self: *const T, hwnd: ?HWND, pbc: ?*IBindCtx, pszDisplayName: ?PWSTR, pchEaten: ?*u32, ppidl: ?*?*ITEMIDLIST, pdwAttributes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).ParseDisplayName(@ptrCast(*const IShellFolder, self), hwnd, pbc, pszDisplayName, pchEaten, ppidl, pdwAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_EnumObjects(self: *const T, hwnd: ?HWND, grfFlags: u32, ppenumIDList: ?*?*IEnumIDList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).EnumObjects(@ptrCast(*const IShellFolder, self), hwnd, grfFlags, ppenumIDList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_BindToObject(self: *const T, pidl: ?*ITEMIDLIST, pbc: ?*IBindCtx, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).BindToObject(@ptrCast(*const IShellFolder, self), pidl, pbc, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_BindToStorage(self: *const T, pidl: ?*ITEMIDLIST, pbc: ?*IBindCtx, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).BindToStorage(@ptrCast(*const IShellFolder, self), pidl, pbc, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_CompareIDs(self: *const T, lParam: LPARAM, pidl1: ?*ITEMIDLIST, pidl2: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).CompareIDs(@ptrCast(*const IShellFolder, self), lParam, pidl1, pidl2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_CreateViewObject(self: *const T, hwndOwner: ?HWND, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).CreateViewObject(@ptrCast(*const IShellFolder, self), hwndOwner, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_GetAttributesOf(self: *const T, cidl: u32, apidl: [*]?*ITEMIDLIST, rgfInOut: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).GetAttributesOf(@ptrCast(*const IShellFolder, self), cidl, apidl, rgfInOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_GetUIObjectOf(self: *const T, hwndOwner: ?HWND, cidl: u32, apidl: [*]?*ITEMIDLIST, riid: ?*const Guid, rgfReserved: ?*u32, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).GetUIObjectOf(@ptrCast(*const IShellFolder, self), hwndOwner, cidl, apidl, riid, rgfReserved, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_GetDisplayNameOf(self: *const T, pidl: ?*ITEMIDLIST, uFlags: u32, pName: ?*STRRET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).GetDisplayNameOf(@ptrCast(*const IShellFolder, self), pidl, uFlags, pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder_SetNameOf(self: *const T, hwnd: ?HWND, pidl: ?*ITEMIDLIST, pszName: ?[*:0]const u16, uFlags: u32, ppidlOut: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder.VTable, self.vtable).SetNameOf(@ptrCast(*const IShellFolder, self), hwnd, pidl, pszName, uFlags, ppidlOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EXTRASEARCH = extern struct {
    guidSearch: Guid,
    wszFriendlyName: [80]u16,
    wszUrl: [2084]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumExtraSearch_Value = @import("../zig.zig").Guid.initString("0e700be1-9db6-11d1-a1ce-00c04fd75d13");
pub const IID_IEnumExtraSearch = &IID_IEnumExtraSearch_Value;
pub const IEnumExtraSearch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumExtraSearch,
            celt: u32,
            rgelt: [*]EXTRASEARCH,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumExtraSearch,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumExtraSearch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumExtraSearch,
            ppenum: ?*?*IEnumExtraSearch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumExtraSearch_Next(self: *const T, celt: u32, rgelt: [*]EXTRASEARCH, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumExtraSearch.VTable, self.vtable).Next(@ptrCast(*const IEnumExtraSearch, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumExtraSearch_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumExtraSearch.VTable, self.vtable).Skip(@ptrCast(*const IEnumExtraSearch, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumExtraSearch_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumExtraSearch.VTable, self.vtable).Reset(@ptrCast(*const IEnumExtraSearch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumExtraSearch_Clone(self: *const T, ppenum: ?*?*IEnumExtraSearch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumExtraSearch.VTable, self.vtable).Clone(@ptrCast(*const IEnumExtraSearch, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellFolder2_Value = @import("../zig.zig").Guid.initString("93f2f68c-1d1b-11d3-a30e-00c04f79abd1");
pub const IID_IShellFolder2 = &IID_IShellFolder2_Value;
pub const IShellFolder2 = extern struct {
    pub const VTable = extern struct {
        base: IShellFolder.VTable,
        GetDefaultSearchGUID: fn(
            self: *const IShellFolder2,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumSearches: fn(
            self: *const IShellFolder2,
            ppenum: ?*?*IEnumExtraSearch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultColumn: fn(
            self: *const IShellFolder2,
            dwRes: u32,
            pSort: ?*u32,
            pDisplay: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultColumnState: fn(
            self: *const IShellFolder2,
            iColumn: u32,
            pcsFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsEx: fn(
            self: *const IShellFolder2,
            pidl: ?*ITEMIDLIST,
            pscid: ?*const PROPERTYKEY,
            pv: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsOf: fn(
            self: *const IShellFolder2,
            pidl: ?*ITEMIDLIST,
            iColumn: u32,
            psd: ?*SHELLDETAILS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapColumnToSCID: fn(
            self: *const IShellFolder2,
            iColumn: u32,
            pscid: ?*PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellFolder.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder2_GetDefaultSearchGUID(self: *const T, pguid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder2.VTable, self.vtable).GetDefaultSearchGUID(@ptrCast(*const IShellFolder2, self), pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder2_EnumSearches(self: *const T, ppenum: ?*?*IEnumExtraSearch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder2.VTable, self.vtable).EnumSearches(@ptrCast(*const IShellFolder2, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder2_GetDefaultColumn(self: *const T, dwRes: u32, pSort: ?*u32, pDisplay: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder2.VTable, self.vtable).GetDefaultColumn(@ptrCast(*const IShellFolder2, self), dwRes, pSort, pDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder2_GetDefaultColumnState(self: *const T, iColumn: u32, pcsFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder2.VTable, self.vtable).GetDefaultColumnState(@ptrCast(*const IShellFolder2, self), iColumn, pcsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder2_GetDetailsEx(self: *const T, pidl: ?*ITEMIDLIST, pscid: ?*const PROPERTYKEY, pv: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder2.VTable, self.vtable).GetDetailsEx(@ptrCast(*const IShellFolder2, self), pidl, pscid, pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder2_GetDetailsOf(self: *const T, pidl: ?*ITEMIDLIST, iColumn: u32, psd: ?*SHELLDETAILS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder2.VTable, self.vtable).GetDetailsOf(@ptrCast(*const IShellFolder2, self), pidl, iColumn, psd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolder2_MapColumnToSCID(self: *const T, iColumn: u32, pscid: ?*PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolder2.VTable, self.vtable).MapColumnToSCID(@ptrCast(*const IShellFolder2, self), iColumn, pscid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FOLDERFLAGS = enum(i32) {
    NONE = 0,
    AUTOARRANGE = 1,
    ABBREVIATEDNAMES = 2,
    SNAPTOGRID = 4,
    OWNERDATA = 8,
    BESTFITWINDOW = 16,
    DESKTOP = 32,
    SINGLESEL = 64,
    NOSUBFOLDERS = 128,
    TRANSPARENT = 256,
    NOCLIENTEDGE = 512,
    NOSCROLL = 1024,
    ALIGNLEFT = 2048,
    NOICONS = 4096,
    SHOWSELALWAYS = 8192,
    NOVISIBLE = 16384,
    SINGLECLICKACTIVATE = 32768,
    NOWEBVIEW = 65536,
    HIDEFILENAMES = 131072,
    CHECKSELECT = 262144,
    NOENUMREFRESH = 524288,
    NOGROUPING = 1048576,
    FULLROWSELECT = 2097152,
    NOFILTERS = 4194304,
    NOCOLUMNHEADER = 8388608,
    NOHEADERINALLVIEWS = 16777216,
    EXTENDEDTILES = 33554432,
    TRICHECKSELECT = 67108864,
    AUTOCHECKSELECT = 134217728,
    NOBROWSERVIEWSTATE = 268435456,
    SUBSETGROUPS = 536870912,
    USESEARCHFOLDER = 1073741824,
    ALLOWRTLREADING = -2147483648,
};
pub const FWF_NONE = FOLDERFLAGS.NONE;
pub const FWF_AUTOARRANGE = FOLDERFLAGS.AUTOARRANGE;
pub const FWF_ABBREVIATEDNAMES = FOLDERFLAGS.ABBREVIATEDNAMES;
pub const FWF_SNAPTOGRID = FOLDERFLAGS.SNAPTOGRID;
pub const FWF_OWNERDATA = FOLDERFLAGS.OWNERDATA;
pub const FWF_BESTFITWINDOW = FOLDERFLAGS.BESTFITWINDOW;
pub const FWF_DESKTOP = FOLDERFLAGS.DESKTOP;
pub const FWF_SINGLESEL = FOLDERFLAGS.SINGLESEL;
pub const FWF_NOSUBFOLDERS = FOLDERFLAGS.NOSUBFOLDERS;
pub const FWF_TRANSPARENT = FOLDERFLAGS.TRANSPARENT;
pub const FWF_NOCLIENTEDGE = FOLDERFLAGS.NOCLIENTEDGE;
pub const FWF_NOSCROLL = FOLDERFLAGS.NOSCROLL;
pub const FWF_ALIGNLEFT = FOLDERFLAGS.ALIGNLEFT;
pub const FWF_NOICONS = FOLDERFLAGS.NOICONS;
pub const FWF_SHOWSELALWAYS = FOLDERFLAGS.SHOWSELALWAYS;
pub const FWF_NOVISIBLE = FOLDERFLAGS.NOVISIBLE;
pub const FWF_SINGLECLICKACTIVATE = FOLDERFLAGS.SINGLECLICKACTIVATE;
pub const FWF_NOWEBVIEW = FOLDERFLAGS.NOWEBVIEW;
pub const FWF_HIDEFILENAMES = FOLDERFLAGS.HIDEFILENAMES;
pub const FWF_CHECKSELECT = FOLDERFLAGS.CHECKSELECT;
pub const FWF_NOENUMREFRESH = FOLDERFLAGS.NOENUMREFRESH;
pub const FWF_NOGROUPING = FOLDERFLAGS.NOGROUPING;
pub const FWF_FULLROWSELECT = FOLDERFLAGS.FULLROWSELECT;
pub const FWF_NOFILTERS = FOLDERFLAGS.NOFILTERS;
pub const FWF_NOCOLUMNHEADER = FOLDERFLAGS.NOCOLUMNHEADER;
pub const FWF_NOHEADERINALLVIEWS = FOLDERFLAGS.NOHEADERINALLVIEWS;
pub const FWF_EXTENDEDTILES = FOLDERFLAGS.EXTENDEDTILES;
pub const FWF_TRICHECKSELECT = FOLDERFLAGS.TRICHECKSELECT;
pub const FWF_AUTOCHECKSELECT = FOLDERFLAGS.AUTOCHECKSELECT;
pub const FWF_NOBROWSERVIEWSTATE = FOLDERFLAGS.NOBROWSERVIEWSTATE;
pub const FWF_SUBSETGROUPS = FOLDERFLAGS.SUBSETGROUPS;
pub const FWF_USESEARCHFOLDER = FOLDERFLAGS.USESEARCHFOLDER;
pub const FWF_ALLOWRTLREADING = FOLDERFLAGS.ALLOWRTLREADING;

pub const FOLDERVIEWMODE = enum(i32) {
    AUTO = -1,
    FIRST = 1,
    // ICON = 1, this enum value conflicts with FIRST
    SMALLICON = 2,
    LIST = 3,
    DETAILS = 4,
    THUMBNAIL = 5,
    TILE = 6,
    THUMBSTRIP = 7,
    CONTENT = 8,
    // LAST = 8, this enum value conflicts with CONTENT
};
pub const FVM_AUTO = FOLDERVIEWMODE.AUTO;
pub const FVM_FIRST = FOLDERVIEWMODE.FIRST;
pub const FVM_ICON = FOLDERVIEWMODE.FIRST;
pub const FVM_SMALLICON = FOLDERVIEWMODE.SMALLICON;
pub const FVM_LIST = FOLDERVIEWMODE.LIST;
pub const FVM_DETAILS = FOLDERVIEWMODE.DETAILS;
pub const FVM_THUMBNAIL = FOLDERVIEWMODE.THUMBNAIL;
pub const FVM_TILE = FOLDERVIEWMODE.TILE;
pub const FVM_THUMBSTRIP = FOLDERVIEWMODE.THUMBSTRIP;
pub const FVM_CONTENT = FOLDERVIEWMODE.CONTENT;
pub const FVM_LAST = FOLDERVIEWMODE.CONTENT;

pub const FOLDERLOGICALVIEWMODE = enum(i32) {
    UNSPECIFIED = -1,
    FIRST = 1,
    // DETAILS = 1, this enum value conflicts with FIRST
    TILES = 2,
    ICONS = 3,
    LIST = 4,
    CONTENT = 5,
    // LAST = 5, this enum value conflicts with CONTENT
};
pub const FLVM_UNSPECIFIED = FOLDERLOGICALVIEWMODE.UNSPECIFIED;
pub const FLVM_FIRST = FOLDERLOGICALVIEWMODE.FIRST;
pub const FLVM_DETAILS = FOLDERLOGICALVIEWMODE.FIRST;
pub const FLVM_TILES = FOLDERLOGICALVIEWMODE.TILES;
pub const FLVM_ICONS = FOLDERLOGICALVIEWMODE.ICONS;
pub const FLVM_LIST = FOLDERLOGICALVIEWMODE.LIST;
pub const FLVM_CONTENT = FOLDERLOGICALVIEWMODE.CONTENT;
pub const FLVM_LAST = FOLDERLOGICALVIEWMODE.CONTENT;

pub const FOLDERSETTINGS = extern struct {
    ViewMode: u32,
    fFlags: u32,
};

pub const _SVSIF = enum(i32) {
    DESELECT = 0,
    SELECT = 1,
    EDIT = 3,
    DESELECTOTHERS = 4,
    ENSUREVISIBLE = 8,
    FOCUSED = 16,
    TRANSLATEPT = 32,
    SELECTIONMARK = 64,
    POSITIONITEM = 128,
    CHECK = 256,
    CHECK2 = 512,
    KEYBOARDSELECT = 1025,
    NOTAKEFOCUS = 1073741824,
};
pub const SVSI_DESELECT = _SVSIF.DESELECT;
pub const SVSI_SELECT = _SVSIF.SELECT;
pub const SVSI_EDIT = _SVSIF.EDIT;
pub const SVSI_DESELECTOTHERS = _SVSIF.DESELECTOTHERS;
pub const SVSI_ENSUREVISIBLE = _SVSIF.ENSUREVISIBLE;
pub const SVSI_FOCUSED = _SVSIF.FOCUSED;
pub const SVSI_TRANSLATEPT = _SVSIF.TRANSLATEPT;
pub const SVSI_SELECTIONMARK = _SVSIF.SELECTIONMARK;
pub const SVSI_POSITIONITEM = _SVSIF.POSITIONITEM;
pub const SVSI_CHECK = _SVSIF.CHECK;
pub const SVSI_CHECK2 = _SVSIF.CHECK2;
pub const SVSI_KEYBOARDSELECT = _SVSIF.KEYBOARDSELECT;
pub const SVSI_NOTAKEFOCUS = _SVSIF.NOTAKEFOCUS;

pub const _SVGIO = enum(i32) {
    BACKGROUND = 0,
    SELECTION = 1,
    ALLVIEW = 2,
    CHECKED = 3,
    TYPE_MASK = 15,
    FLAG_VIEWORDER = -2147483648,
};
pub const SVGIO_BACKGROUND = _SVGIO.BACKGROUND;
pub const SVGIO_SELECTION = _SVGIO.SELECTION;
pub const SVGIO_ALLVIEW = _SVGIO.ALLVIEW;
pub const SVGIO_CHECKED = _SVGIO.CHECKED;
pub const SVGIO_TYPE_MASK = _SVGIO.TYPE_MASK;
pub const SVGIO_FLAG_VIEWORDER = _SVGIO.FLAG_VIEWORDER;

pub const SVUIA_STATUS = enum(i32) {
    DEACTIVATE = 0,
    ACTIVATE_NOFOCUS = 1,
    ACTIVATE_FOCUS = 2,
    INPLACEACTIVATE = 3,
};
pub const SVUIA_DEACTIVATE = SVUIA_STATUS.DEACTIVATE;
pub const SVUIA_ACTIVATE_NOFOCUS = SVUIA_STATUS.ACTIVATE_NOFOCUS;
pub const SVUIA_ACTIVATE_FOCUS = SVUIA_STATUS.ACTIVATE_FOCUS;
pub const SVUIA_INPLACEACTIVATE = SVUIA_STATUS.INPLACEACTIVATE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellView_Value = @import("../zig.zig").Guid.initString("000214e3-0000-0000-c000-000000000046");
pub const IID_IShellView = &IID_IShellView_Value;
pub const IShellView = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        TranslateAccelerator: fn(
            self: *const IShellView,
            pmsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableModeless: fn(
            self: *const IShellView,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UIActivate: fn(
            self: *const IShellView,
            uState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IShellView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateViewWindow: fn(
            self: *const IShellView,
            psvPrevious: ?*IShellView,
            pfs: ?*FOLDERSETTINGS,
            psb: ?*IShellBrowser,
            prcView: ?*RECT,
            phWnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyViewWindow: fn(
            self: *const IShellView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentInfo: fn(
            self: *const IShellView,
            pfs: ?*FOLDERSETTINGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertySheetPages: fn(
            self: *const IShellView,
            dwReserved: u32,
            pfn: ?LPFNSVADDPROPSHEETPAGE,
            lparam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveViewState: fn(
            self: *const IShellView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectItem: fn(
            self: *const IShellView,
            pidlItem: ?*ITEMIDLIST,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemObject: fn(
            self: *const IShellView,
            uItem: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_TranslateAccelerator(self: *const T, pmsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).TranslateAccelerator(@ptrCast(*const IShellView, self), pmsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_EnableModeless(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).EnableModeless(@ptrCast(*const IShellView, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_UIActivate(self: *const T, uState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).UIActivate(@ptrCast(*const IShellView, self), uState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).Refresh(@ptrCast(*const IShellView, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_CreateViewWindow(self: *const T, psvPrevious: ?*IShellView, pfs: ?*FOLDERSETTINGS, psb: ?*IShellBrowser, prcView: ?*RECT, phWnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).CreateViewWindow(@ptrCast(*const IShellView, self), psvPrevious, pfs, psb, prcView, phWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_DestroyViewWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).DestroyViewWindow(@ptrCast(*const IShellView, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_GetCurrentInfo(self: *const T, pfs: ?*FOLDERSETTINGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).GetCurrentInfo(@ptrCast(*const IShellView, self), pfs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_AddPropertySheetPages(self: *const T, dwReserved: u32, pfn: ?LPFNSVADDPROPSHEETPAGE, lparam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).AddPropertySheetPages(@ptrCast(*const IShellView, self), dwReserved, pfn, lparam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_SaveViewState(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).SaveViewState(@ptrCast(*const IShellView, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_SelectItem(self: *const T, pidlItem: ?*ITEMIDLIST, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).SelectItem(@ptrCast(*const IShellView, self), pidlItem, uFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView_GetItemObject(self: *const T, uItem: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView.VTable, self.vtable).GetItemObject(@ptrCast(*const IShellView, self), uItem, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SV2CVW2_PARAMS = extern struct {
    cbSize: u32,
    psvPrev: ?*IShellView,
    pfs: ?*FOLDERSETTINGS,
    psbOwner: ?*IShellBrowser,
    prcView: ?*RECT,
    pvid: ?*const Guid,
    hwndView: ?HWND,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellView2_Value = @import("../zig.zig").Guid.initString("88e39e80-3578-11cf-ae69-08002b2e1262");
pub const IID_IShellView2 = &IID_IShellView2_Value;
pub const IShellView2 = extern struct {
    pub const VTable = extern struct {
        base: IShellView.VTable,
        GetView: fn(
            self: *const IShellView2,
            pvid: ?*Guid,
            uView: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateViewWindow2: fn(
            self: *const IShellView2,
            lpParams: ?*SV2CVW2_PARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleRename: fn(
            self: *const IShellView2,
            pidlNew: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAndPositionItem: fn(
            self: *const IShellView2,
            pidlItem: ?*ITEMIDLIST,
            uFlags: u32,
            ppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellView.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView2_GetView(self: *const T, pvid: ?*Guid, uView: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView2.VTable, self.vtable).GetView(@ptrCast(*const IShellView2, self), pvid, uView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView2_CreateViewWindow2(self: *const T, lpParams: ?*SV2CVW2_PARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView2.VTable, self.vtable).CreateViewWindow2(@ptrCast(*const IShellView2, self), lpParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView2_HandleRename(self: *const T, pidlNew: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView2.VTable, self.vtable).HandleRename(@ptrCast(*const IShellView2, self), pidlNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView2_SelectAndPositionItem(self: *const T, pidlItem: ?*ITEMIDLIST, uFlags: u32, ppt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView2.VTable, self.vtable).SelectAndPositionItem(@ptrCast(*const IShellView2, self), pidlItem, uFlags, ppt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderView_Value = @import("../zig.zig").Guid.initString("cde725b0-ccc9-4519-917e-325d72fab4ce");
pub const IID_IFolderView = &IID_IFolderView_Value;
pub const IFolderView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentViewMode: fn(
            self: *const IFolderView,
            pViewMode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentViewMode: fn(
            self: *const IFolderView,
            ViewMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolder: fn(
            self: *const IFolderView,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IFolderView,
            iItemIndex: i32,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ItemCount: fn(
            self: *const IFolderView,
            uFlags: u32,
            pcItems: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Items: fn(
            self: *const IFolderView,
            uFlags: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectionMarkedItem: fn(
            self: *const IFolderView,
            piItem: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocusedItem: fn(
            self: *const IFolderView,
            piItem: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemPosition: fn(
            self: *const IFolderView,
            pidl: ?*ITEMIDLIST,
            ppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpacing: fn(
            self: *const IFolderView,
            ppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultSpacing: fn(
            self: *const IFolderView,
            ppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutoArrange: fn(
            self: *const IFolderView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectItem: fn(
            self: *const IFolderView,
            iItem: i32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAndPositionItems: fn(
            self: *const IFolderView,
            cidl: u32,
            apidl: [*]?*ITEMIDLIST,
            apt: ?[*]POINT,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_GetCurrentViewMode(self: *const T, pViewMode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).GetCurrentViewMode(@ptrCast(*const IFolderView, self), pViewMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_SetCurrentViewMode(self: *const T, ViewMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).SetCurrentViewMode(@ptrCast(*const IFolderView, self), ViewMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_GetFolder(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).GetFolder(@ptrCast(*const IFolderView, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_Item(self: *const T, iItemIndex: i32, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).Item(@ptrCast(*const IFolderView, self), iItemIndex, ppidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_ItemCount(self: *const T, uFlags: u32, pcItems: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).ItemCount(@ptrCast(*const IFolderView, self), uFlags, pcItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_Items(self: *const T, uFlags: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).Items(@ptrCast(*const IFolderView, self), uFlags, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_GetSelectionMarkedItem(self: *const T, piItem: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).GetSelectionMarkedItem(@ptrCast(*const IFolderView, self), piItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_GetFocusedItem(self: *const T, piItem: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).GetFocusedItem(@ptrCast(*const IFolderView, self), piItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_GetItemPosition(self: *const T, pidl: ?*ITEMIDLIST, ppt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).GetItemPosition(@ptrCast(*const IFolderView, self), pidl, ppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_GetSpacing(self: *const T, ppt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).GetSpacing(@ptrCast(*const IFolderView, self), ppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_GetDefaultSpacing(self: *const T, ppt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).GetDefaultSpacing(@ptrCast(*const IFolderView, self), ppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_GetAutoArrange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).GetAutoArrange(@ptrCast(*const IFolderView, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_SelectItem(self: *const T, iItem: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).SelectItem(@ptrCast(*const IFolderView, self), iItem, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView_SelectAndPositionItems(self: *const T, cidl: u32, apidl: [*]?*ITEMIDLIST, apt: ?[*]POINT, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView.VTable, self.vtable).SelectAndPositionItems(@ptrCast(*const IFolderView, self), cidl, apidl, apt, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SORTDIRECTION = enum(i32) {
    DESCENDING = -1,
    ASCENDING = 1,
};
pub const SORT_DESCENDING = SORTDIRECTION.DESCENDING;
pub const SORT_ASCENDING = SORTDIRECTION.ASCENDING;

pub const SORTCOLUMN = extern struct {
    propkey: PROPERTYKEY,
    direction: SORTDIRECTION,
};

pub const FVTEXTTYPE = enum(i32) {
    T = 0,
};
pub const FVST_EMPTYTEXT = FVTEXTTYPE.T;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFolderView2_Value = @import("../zig.zig").Guid.initString("1af3a467-214f-4298-908e-06b03e0b39f9");
pub const IID_IFolderView2 = &IID_IFolderView2_Value;
pub const IFolderView2 = extern struct {
    pub const VTable = extern struct {
        base: IFolderView.VTable,
        SetGroupBy: fn(
            self: *const IFolderView2,
            key: ?*const PROPERTYKEY,
            fAscending: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroupBy: fn(
            self: *const IFolderView2,
            pkey: ?*PROPERTYKEY,
            pfAscending: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetViewProperty: fn(
            self: *const IFolderView2,
            pidl: ?*ITEMIDLIST,
            propkey: ?*const PROPERTYKEY,
            propvar: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewProperty: fn(
            self: *const IFolderView2,
            pidl: ?*ITEMIDLIST,
            propkey: ?*const PROPERTYKEY,
            ppropvar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTileViewProperties: fn(
            self: *const IFolderView2,
            pidl: ?*ITEMIDLIST,
            pszPropList: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExtendedTileViewProperties: fn(
            self: *const IFolderView2,
            pidl: ?*ITEMIDLIST,
            pszPropList: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const IFolderView2,
            iType: FVTEXTTYPE,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentFolderFlags: fn(
            self: *const IFolderView2,
            dwMask: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentFolderFlags: fn(
            self: *const IFolderView2,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSortColumnCount: fn(
            self: *const IFolderView2,
            pcColumns: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSortColumns: fn(
            self: *const IFolderView2,
            rgSortColumns: [*]const SORTCOLUMN,
            cColumns: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSortColumns: fn(
            self: *const IFolderView2,
            rgSortColumns: [*]SORTCOLUMN,
            cColumns: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const IFolderView2,
            iItem: i32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVisibleItem: fn(
            self: *const IFolderView2,
            iStart: i32,
            fPrevious: BOOL,
            piItem: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedItem: fn(
            self: *const IFolderView2,
            iStart: i32,
            piItem: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const IFolderView2,
            fNoneImpliesFolder: BOOL,
            ppsia: ?*?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectionState: fn(
            self: *const IFolderView2,
            pidl: ?*ITEMIDLIST,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeVerbOnSelection: fn(
            self: *const IFolderView2,
            pszVerb: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetViewModeAndIconSize: fn(
            self: *const IFolderView2,
            uViewMode: FOLDERVIEWMODE,
            iImageSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewModeAndIconSize: fn(
            self: *const IFolderView2,
            puViewMode: ?*FOLDERVIEWMODE,
            piImageSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGroupSubsetCount: fn(
            self: *const IFolderView2,
            cVisibleRows: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroupSubsetCount: fn(
            self: *const IFolderView2,
            pcVisibleRows: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRedraw: fn(
            self: *const IFolderView2,
            fRedrawOn: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMoveInSameFolder: fn(
            self: *const IFolderView2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoRename: fn(
            self: *const IFolderView2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFolderView.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetGroupBy(self: *const T, key: ?*const PROPERTYKEY, fAscending: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetGroupBy(@ptrCast(*const IFolderView2, self), key, fAscending);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetGroupBy(self: *const T, pkey: ?*PROPERTYKEY, pfAscending: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetGroupBy(@ptrCast(*const IFolderView2, self), pkey, pfAscending);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetViewProperty(self: *const T, pidl: ?*ITEMIDLIST, propkey: ?*const PROPERTYKEY, propvar: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetViewProperty(@ptrCast(*const IFolderView2, self), pidl, propkey, propvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetViewProperty(self: *const T, pidl: ?*ITEMIDLIST, propkey: ?*const PROPERTYKEY, ppropvar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetViewProperty(@ptrCast(*const IFolderView2, self), pidl, propkey, ppropvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetTileViewProperties(self: *const T, pidl: ?*ITEMIDLIST, pszPropList: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetTileViewProperties(@ptrCast(*const IFolderView2, self), pidl, pszPropList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetExtendedTileViewProperties(self: *const T, pidl: ?*ITEMIDLIST, pszPropList: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetExtendedTileViewProperties(@ptrCast(*const IFolderView2, self), pidl, pszPropList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetText(self: *const T, iType: FVTEXTTYPE, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetText(@ptrCast(*const IFolderView2, self), iType, pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetCurrentFolderFlags(self: *const T, dwMask: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetCurrentFolderFlags(@ptrCast(*const IFolderView2, self), dwMask, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetCurrentFolderFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetCurrentFolderFlags(@ptrCast(*const IFolderView2, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetSortColumnCount(self: *const T, pcColumns: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetSortColumnCount(@ptrCast(*const IFolderView2, self), pcColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetSortColumns(self: *const T, rgSortColumns: [*]const SORTCOLUMN, cColumns: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetSortColumns(@ptrCast(*const IFolderView2, self), rgSortColumns, cColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetSortColumns(self: *const T, rgSortColumns: [*]SORTCOLUMN, cColumns: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetSortColumns(@ptrCast(*const IFolderView2, self), rgSortColumns, cColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetItem(self: *const T, iItem: i32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetItem(@ptrCast(*const IFolderView2, self), iItem, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetVisibleItem(self: *const T, iStart: i32, fPrevious: BOOL, piItem: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetVisibleItem(@ptrCast(*const IFolderView2, self), iStart, fPrevious, piItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetSelectedItem(self: *const T, iStart: i32, piItem: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetSelectedItem(@ptrCast(*const IFolderView2, self), iStart, piItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetSelection(self: *const T, fNoneImpliesFolder: BOOL, ppsia: ?*?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetSelection(@ptrCast(*const IFolderView2, self), fNoneImpliesFolder, ppsia);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetSelectionState(self: *const T, pidl: ?*ITEMIDLIST, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetSelectionState(@ptrCast(*const IFolderView2, self), pidl, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_InvokeVerbOnSelection(self: *const T, pszVerb: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).InvokeVerbOnSelection(@ptrCast(*const IFolderView2, self), pszVerb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetViewModeAndIconSize(self: *const T, uViewMode: FOLDERVIEWMODE, iImageSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetViewModeAndIconSize(@ptrCast(*const IFolderView2, self), uViewMode, iImageSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetViewModeAndIconSize(self: *const T, puViewMode: ?*FOLDERVIEWMODE, piImageSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetViewModeAndIconSize(@ptrCast(*const IFolderView2, self), puViewMode, piImageSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetGroupSubsetCount(self: *const T, cVisibleRows: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetGroupSubsetCount(@ptrCast(*const IFolderView2, self), cVisibleRows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_GetGroupSubsetCount(self: *const T, pcVisibleRows: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).GetGroupSubsetCount(@ptrCast(*const IFolderView2, self), pcVisibleRows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_SetRedraw(self: *const T, fRedrawOn: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).SetRedraw(@ptrCast(*const IFolderView2, self), fRedrawOn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_IsMoveInSameFolder(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).IsMoveInSameFolder(@ptrCast(*const IFolderView2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderView2_DoRename(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderView2.VTable, self.vtable).DoRename(@ptrCast(*const IFolderView2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFolderViewSettings_Value = @import("../zig.zig").Guid.initString("ae8c987d-8797-4ed3-be72-2a47dd938db0");
pub const IID_IFolderViewSettings = &IID_IFolderViewSettings_Value;
pub const IFolderViewSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnPropertyList: fn(
            self: *const IFolderViewSettings,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroupByProperty: fn(
            self: *const IFolderViewSettings,
            pkey: ?*PROPERTYKEY,
            pfGroupAscending: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewMode: fn(
            self: *const IFolderViewSettings,
            plvm: ?*FOLDERLOGICALVIEWMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconSize: fn(
            self: *const IFolderViewSettings,
            puIconSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolderFlags: fn(
            self: *const IFolderViewSettings,
            pfolderMask: ?*FOLDERFLAGS,
            pfolderFlags: ?*FOLDERFLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSortColumns: fn(
            self: *const IFolderViewSettings,
            rgSortColumns: [*]SORTCOLUMN,
            cColumnsIn: u32,
            pcColumnsOut: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroupSubsetCount: fn(
            self: *const IFolderViewSettings,
            pcVisibleRows: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewSettings_GetColumnPropertyList(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewSettings.VTable, self.vtable).GetColumnPropertyList(@ptrCast(*const IFolderViewSettings, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewSettings_GetGroupByProperty(self: *const T, pkey: ?*PROPERTYKEY, pfGroupAscending: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewSettings.VTable, self.vtable).GetGroupByProperty(@ptrCast(*const IFolderViewSettings, self), pkey, pfGroupAscending);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewSettings_GetViewMode(self: *const T, plvm: ?*FOLDERLOGICALVIEWMODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewSettings.VTable, self.vtable).GetViewMode(@ptrCast(*const IFolderViewSettings, self), plvm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewSettings_GetIconSize(self: *const T, puIconSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewSettings.VTable, self.vtable).GetIconSize(@ptrCast(*const IFolderViewSettings, self), puIconSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewSettings_GetFolderFlags(self: *const T, pfolderMask: ?*FOLDERFLAGS, pfolderFlags: ?*FOLDERFLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewSettings.VTable, self.vtable).GetFolderFlags(@ptrCast(*const IFolderViewSettings, self), pfolderMask, pfolderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewSettings_GetSortColumns(self: *const T, rgSortColumns: [*]SORTCOLUMN, cColumnsIn: u32, pcColumnsOut: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewSettings.VTable, self.vtable).GetSortColumns(@ptrCast(*const IFolderViewSettings, self), rgSortColumns, cColumnsIn, pcColumnsOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewSettings_GetGroupSubsetCount(self: *const T, pcVisibleRows: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewSettings.VTable, self.vtable).GetGroupSubsetCount(@ptrCast(*const IFolderViewSettings, self), pcVisibleRows);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IInitializeNetworkFolder_Value = @import("../zig.zig").Guid.initString("6e0f9881-42a8-4f2a-97f8-8af4e026d92d");
pub const IID_IInitializeNetworkFolder = &IID_IInitializeNetworkFolder_Value;
pub const IInitializeNetworkFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IInitializeNetworkFolder,
            pidl: ?*ITEMIDLIST,
            pidlTarget: ?*ITEMIDLIST,
            uDisplayType: u32,
            pszResName: ?[*:0]const u16,
            pszProvider: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeNetworkFolder_Initialize(self: *const T, pidl: ?*ITEMIDLIST, pidlTarget: ?*ITEMIDLIST, uDisplayType: u32, pszResName: ?[*:0]const u16, pszProvider: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeNetworkFolder.VTable, self.vtable).Initialize(@ptrCast(*const IInitializeNetworkFolder, self), pidl, pidlTarget, uDisplayType, pszResName, pszProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_INetworkFolderInternal_Value = @import("../zig.zig").Guid.initString("ceb38218-c971-47bb-a703-f0bc99ccdb81");
pub const IID_INetworkFolderInternal = &IID_INetworkFolderInternal_Value;
pub const INetworkFolderInternal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResourceDisplayType: fn(
            self: *const INetworkFolderInternal,
            displayType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDList: fn(
            self: *const INetworkFolderInternal,
            idList: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProvider: fn(
            self: *const INetworkFolderInternal,
            itemIdCount: u32,
            itemIds: [*]?*ITEMIDLIST,
            providerMaxLength: u32,
            provider: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkFolderInternal_GetResourceDisplayType(self: *const T, displayType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkFolderInternal.VTable, self.vtable).GetResourceDisplayType(@ptrCast(*const INetworkFolderInternal, self), displayType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkFolderInternal_GetIDList(self: *const T, idList: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkFolderInternal.VTable, self.vtable).GetIDList(@ptrCast(*const INetworkFolderInternal, self), idList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INetworkFolderInternal_GetProvider(self: *const T, itemIdCount: u32, itemIds: [*]?*ITEMIDLIST, providerMaxLength: u32, provider: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INetworkFolderInternal.VTable, self.vtable).GetProvider(@ptrCast(*const INetworkFolderInternal, self), itemIdCount, itemIds, providerMaxLength, provider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPreviewHandlerVisuals_Value = @import("../zig.zig").Guid.initString("196bf9a5-b346-4ef0-aa1e-5dcdb76768b1");
pub const IID_IPreviewHandlerVisuals = &IID_IPreviewHandlerVisuals_Value;
pub const IPreviewHandlerVisuals = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBackgroundColor: fn(
            self: *const IPreviewHandlerVisuals,
            color: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont: fn(
            self: *const IPreviewHandlerVisuals,
            plf: ?*const LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextColor: fn(
            self: *const IPreviewHandlerVisuals,
            color: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandlerVisuals_SetBackgroundColor(self: *const T, color: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandlerVisuals.VTable, self.vtable).SetBackgroundColor(@ptrCast(*const IPreviewHandlerVisuals, self), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandlerVisuals_SetFont(self: *const T, plf: ?*const LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandlerVisuals.VTable, self.vtable).SetFont(@ptrCast(*const IPreviewHandlerVisuals, self), plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandlerVisuals_SetTextColor(self: *const T, color: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandlerVisuals.VTable, self.vtable).SetTextColor(@ptrCast(*const IPreviewHandlerVisuals, self), color);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICommDlgBrowser_Value = @import("../zig.zig").Guid.initString("000214f1-0000-0000-c000-000000000046");
pub const IID_ICommDlgBrowser = &IID_ICommDlgBrowser_Value;
pub const ICommDlgBrowser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDefaultCommand: fn(
            self: *const ICommDlgBrowser,
            ppshv: ?*IShellView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStateChange: fn(
            self: *const ICommDlgBrowser,
            ppshv: ?*IShellView,
            uChange: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IncludeObject: fn(
            self: *const ICommDlgBrowser,
            ppshv: ?*IShellView,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommDlgBrowser_OnDefaultCommand(self: *const T, ppshv: ?*IShellView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommDlgBrowser.VTable, self.vtable).OnDefaultCommand(@ptrCast(*const ICommDlgBrowser, self), ppshv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommDlgBrowser_OnStateChange(self: *const T, ppshv: ?*IShellView, uChange: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommDlgBrowser.VTable, self.vtable).OnStateChange(@ptrCast(*const ICommDlgBrowser, self), ppshv, uChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommDlgBrowser_IncludeObject(self: *const T, ppshv: ?*IShellView, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommDlgBrowser.VTable, self.vtable).IncludeObject(@ptrCast(*const ICommDlgBrowser, self), ppshv, pidl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICommDlgBrowser2_Value = @import("../zig.zig").Guid.initString("10339516-2894-11d2-9039-00c04f8eeb3e");
pub const IID_ICommDlgBrowser2 = &IID_ICommDlgBrowser2_Value;
pub const ICommDlgBrowser2 = extern struct {
    pub const VTable = extern struct {
        base: ICommDlgBrowser.VTable,
        Notify: fn(
            self: *const ICommDlgBrowser2,
            ppshv: ?*IShellView,
            dwNotifyType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultMenuText: fn(
            self: *const ICommDlgBrowser2,
            ppshv: ?*IShellView,
            pszText: [*:0]u16,
            cchMax: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewFlags: fn(
            self: *const ICommDlgBrowser2,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICommDlgBrowser.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommDlgBrowser2_Notify(self: *const T, ppshv: ?*IShellView, dwNotifyType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommDlgBrowser2.VTable, self.vtable).Notify(@ptrCast(*const ICommDlgBrowser2, self), ppshv, dwNotifyType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommDlgBrowser2_GetDefaultMenuText(self: *const T, ppshv: ?*IShellView, pszText: [*:0]u16, cchMax: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommDlgBrowser2.VTable, self.vtable).GetDefaultMenuText(@ptrCast(*const ICommDlgBrowser2, self), ppshv, pszText, cchMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommDlgBrowser2_GetViewFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommDlgBrowser2.VTable, self.vtable).GetViewFlags(@ptrCast(*const ICommDlgBrowser2, self), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CM_MASK = enum(i32) {
    WIDTH = 1,
    DEFAULTWIDTH = 2,
    IDEALWIDTH = 4,
    NAME = 8,
    STATE = 16,
};
pub const CM_MASK_WIDTH = CM_MASK.WIDTH;
pub const CM_MASK_DEFAULTWIDTH = CM_MASK.DEFAULTWIDTH;
pub const CM_MASK_IDEALWIDTH = CM_MASK.IDEALWIDTH;
pub const CM_MASK_NAME = CM_MASK.NAME;
pub const CM_MASK_STATE = CM_MASK.STATE;

pub const CM_STATE = enum(i32) {
    NONE = 0,
    VISIBLE = 1,
    FIXEDWIDTH = 2,
    NOSORTBYFOLDERNESS = 4,
    ALWAYSVISIBLE = 8,
};
pub const CM_STATE_NONE = CM_STATE.NONE;
pub const CM_STATE_VISIBLE = CM_STATE.VISIBLE;
pub const CM_STATE_FIXEDWIDTH = CM_STATE.FIXEDWIDTH;
pub const CM_STATE_NOSORTBYFOLDERNESS = CM_STATE.NOSORTBYFOLDERNESS;
pub const CM_STATE_ALWAYSVISIBLE = CM_STATE.ALWAYSVISIBLE;

pub const CM_ENUM_FLAGS = enum(i32) {
    ALL = 1,
    VISIBLE = 2,
};
pub const CM_ENUM_ALL = CM_ENUM_FLAGS.ALL;
pub const CM_ENUM_VISIBLE = CM_ENUM_FLAGS.VISIBLE;

pub const CM_SET_WIDTH_VALUE = enum(i32) {
    USEDEFAULT = -1,
    AUTOSIZE = -2,
};
pub const CM_WIDTH_USEDEFAULT = CM_SET_WIDTH_VALUE.USEDEFAULT;
pub const CM_WIDTH_AUTOSIZE = CM_SET_WIDTH_VALUE.AUTOSIZE;

pub const CM_COLUMNINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwState: u32,
    uWidth: u32,
    uDefaultWidth: u32,
    uIdealWidth: u32,
    wszName: [80]u16,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IColumnManager_Value = @import("../zig.zig").Guid.initString("d8ec27bb-3f3b-4042-b10a-4acfd924d453");
pub const IID_IColumnManager = &IID_IColumnManager_Value;
pub const IColumnManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumnInfo: fn(
            self: *const IColumnManager,
            propkey: ?*const PROPERTYKEY,
            pcmci: ?*const CM_COLUMNINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnInfo: fn(
            self: *const IColumnManager,
            propkey: ?*const PROPERTYKEY,
            pcmci: ?*CM_COLUMNINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnCount: fn(
            self: *const IColumnManager,
            dwFlags: CM_ENUM_FLAGS,
            puCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumns: fn(
            self: *const IColumnManager,
            dwFlags: CM_ENUM_FLAGS,
            rgkeyOrder: [*]PROPERTYKEY,
            cColumns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumns: fn(
            self: *const IColumnManager,
            rgkeyOrder: [*]const PROPERTYKEY,
            cVisible: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnManager_SetColumnInfo(self: *const T, propkey: ?*const PROPERTYKEY, pcmci: ?*const CM_COLUMNINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnManager.VTable, self.vtable).SetColumnInfo(@ptrCast(*const IColumnManager, self), propkey, pcmci);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnManager_GetColumnInfo(self: *const T, propkey: ?*const PROPERTYKEY, pcmci: ?*CM_COLUMNINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnManager.VTable, self.vtable).GetColumnInfo(@ptrCast(*const IColumnManager, self), propkey, pcmci);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnManager_GetColumnCount(self: *const T, dwFlags: CM_ENUM_FLAGS, puCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnManager.VTable, self.vtable).GetColumnCount(@ptrCast(*const IColumnManager, self), dwFlags, puCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnManager_GetColumns(self: *const T, dwFlags: CM_ENUM_FLAGS, rgkeyOrder: [*]PROPERTYKEY, cColumns: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnManager.VTable, self.vtable).GetColumns(@ptrCast(*const IColumnManager, self), dwFlags, rgkeyOrder, cColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnManager_SetColumns(self: *const T, rgkeyOrder: [*]const PROPERTYKEY, cVisible: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnManager.VTable, self.vtable).SetColumns(@ptrCast(*const IColumnManager, self), rgkeyOrder, cVisible);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderFilterSite_Value = @import("../zig.zig").Guid.initString("c0a651f5-b48b-11d2-b5ed-006097c686f6");
pub const IID_IFolderFilterSite = &IID_IFolderFilterSite_Value;
pub const IFolderFilterSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFilter: fn(
            self: *const IFolderFilterSite,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderFilterSite_SetFilter(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderFilterSite.VTable, self.vtable).SetFilter(@ptrCast(*const IFolderFilterSite, self), punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderFilter_Value = @import("../zig.zig").Guid.initString("9cc22886-dc8e-11d2-b1d0-00c04f8eeb3e");
pub const IID_IFolderFilter = &IID_IFolderFilter_Value;
pub const IFolderFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShouldShow: fn(
            self: *const IFolderFilter,
            psf: ?*IShellFolder,
            pidlFolder: ?*ITEMIDLIST,
            pidlItem: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumFlags: fn(
            self: *const IFolderFilter,
            psf: ?*IShellFolder,
            pidlFolder: ?*ITEMIDLIST,
            phwnd: ?*?HWND,
            pgrfFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderFilter_ShouldShow(self: *const T, psf: ?*IShellFolder, pidlFolder: ?*ITEMIDLIST, pidlItem: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderFilter.VTable, self.vtable).ShouldShow(@ptrCast(*const IFolderFilter, self), psf, pidlFolder, pidlItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderFilter_GetEnumFlags(self: *const T, psf: ?*IShellFolder, pidlFolder: ?*ITEMIDLIST, phwnd: ?*?HWND, pgrfFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderFilter.VTable, self.vtable).GetEnumFlags(@ptrCast(*const IFolderFilter, self), psf, pidlFolder, phwnd, pgrfFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IInputObjectSite_Value = @import("../zig.zig").Guid.initString("f1db8392-7331-11d0-8c99-00a0c92dbfe8");
pub const IID_IInputObjectSite = &IID_IInputObjectSite_Value;
pub const IInputObjectSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFocusChangeIS: fn(
            self: *const IInputObjectSite,
            punkObj: ?*IUnknown,
            fSetFocus: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputObjectSite_OnFocusChangeIS(self: *const T, punkObj: ?*IUnknown, fSetFocus: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputObjectSite.VTable, self.vtable).OnFocusChangeIS(@ptrCast(*const IInputObjectSite, self), punkObj, fSetFocus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IInputObject_Value = @import("../zig.zig").Guid.initString("68284faa-6a48-11d0-8c78-00c04fd918b4");
pub const IID_IInputObject = &IID_IInputObject_Value;
pub const IInputObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UIActivateIO: fn(
            self: *const IInputObject,
            fActivate: BOOL,
            pMsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasFocusIO: fn(
            self: *const IInputObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAcceleratorIO: fn(
            self: *const IInputObject,
            pMsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputObject_UIActivateIO(self: *const T, fActivate: BOOL, pMsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputObject.VTable, self.vtable).UIActivateIO(@ptrCast(*const IInputObject, self), fActivate, pMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputObject_HasFocusIO(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputObject.VTable, self.vtable).HasFocusIO(@ptrCast(*const IInputObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputObject_TranslateAcceleratorIO(self: *const T, pMsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputObject.VTable, self.vtable).TranslateAcceleratorIO(@ptrCast(*const IInputObject, self), pMsg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IInputObject2_Value = @import("../zig.zig").Guid.initString("6915c085-510b-44cd-94af-28dfa56cf92b");
pub const IID_IInputObject2 = &IID_IInputObject2_Value;
pub const IInputObject2 = extern struct {
    pub const VTable = extern struct {
        base: IInputObject.VTable,
        TranslateAcceleratorGlobal: fn(
            self: *const IInputObject2,
            pMsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInputObject.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputObject2_TranslateAcceleratorGlobal(self: *const T, pMsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputObject2.VTable, self.vtable).TranslateAcceleratorGlobal(@ptrCast(*const IInputObject2, self), pMsg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellIcon_Value = @import("../zig.zig").Guid.initString("000214e5-0000-0000-c000-000000000046");
pub const IID_IShellIcon = &IID_IShellIcon_Value;
pub const IShellIcon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIconOf: fn(
            self: *const IShellIcon,
            pidl: ?*ITEMIDLIST,
            flags: u32,
            pIconIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIcon_GetIconOf(self: *const T, pidl: ?*ITEMIDLIST, flags: u32, pIconIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIcon.VTable, self.vtable).GetIconOf(@ptrCast(*const IShellIcon, self), pidl, flags, pIconIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellBrowser_Value = @import("../zig.zig").Guid.initString("000214e2-0000-0000-c000-000000000046");
pub const IID_IShellBrowser = &IID_IShellBrowser_Value;
pub const IShellBrowser = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        InsertMenusSB: fn(
            self: *const IShellBrowser,
            hmenuShared: ?HMENU,
            lpMenuWidths: ?*OleMenuGroupWidths,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMenuSB: fn(
            self: *const IShellBrowser,
            hmenuShared: ?HMENU,
            holemenuRes: isize,
            hwndActiveObject: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveMenusSB: fn(
            self: *const IShellBrowser,
            hmenuShared: ?HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatusTextSB: fn(
            self: *const IShellBrowser,
            pszStatusText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableModelessSB: fn(
            self: *const IShellBrowser,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAcceleratorSB: fn(
            self: *const IShellBrowser,
            pmsg: ?*MSG,
            wID: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BrowseObject: fn(
            self: *const IShellBrowser,
            pidl: ?*ITEMIDLIST,
            wFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewStateStream: fn(
            self: *const IShellBrowser,
            grfMode: u32,
            ppStrm: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlWindow: fn(
            self: *const IShellBrowser,
            id: u32,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendControlMsg: fn(
            self: *const IShellBrowser,
            id: u32,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
            pret: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryActiveShellView: fn(
            self: *const IShellBrowser,
            ppshv: ?*?*IShellView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnViewWindowActive: fn(
            self: *const IShellBrowser,
            pshv: ?*IShellView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetToolbarItems: fn(
            self: *const IShellBrowser,
            lpButtons: ?[*]TBBUTTON,
            nButtons: u32,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_InsertMenusSB(self: *const T, hmenuShared: ?HMENU, lpMenuWidths: ?*OleMenuGroupWidths) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).InsertMenusSB(@ptrCast(*const IShellBrowser, self), hmenuShared, lpMenuWidths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_SetMenuSB(self: *const T, hmenuShared: ?HMENU, holemenuRes: isize, hwndActiveObject: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).SetMenuSB(@ptrCast(*const IShellBrowser, self), hmenuShared, holemenuRes, hwndActiveObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_RemoveMenusSB(self: *const T, hmenuShared: ?HMENU) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).RemoveMenusSB(@ptrCast(*const IShellBrowser, self), hmenuShared);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_SetStatusTextSB(self: *const T, pszStatusText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).SetStatusTextSB(@ptrCast(*const IShellBrowser, self), pszStatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_EnableModelessSB(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).EnableModelessSB(@ptrCast(*const IShellBrowser, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_TranslateAcceleratorSB(self: *const T, pmsg: ?*MSG, wID: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).TranslateAcceleratorSB(@ptrCast(*const IShellBrowser, self), pmsg, wID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_BrowseObject(self: *const T, pidl: ?*ITEMIDLIST, wFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).BrowseObject(@ptrCast(*const IShellBrowser, self), pidl, wFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_GetViewStateStream(self: *const T, grfMode: u32, ppStrm: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).GetViewStateStream(@ptrCast(*const IShellBrowser, self), grfMode, ppStrm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_GetControlWindow(self: *const T, id: u32, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).GetControlWindow(@ptrCast(*const IShellBrowser, self), id, phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_SendControlMsg(self: *const T, id: u32, uMsg: u32, wParam: WPARAM, lParam: LPARAM, pret: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).SendControlMsg(@ptrCast(*const IShellBrowser, self), id, uMsg, wParam, lParam, pret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_QueryActiveShellView(self: *const T, ppshv: ?*?*IShellView) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).QueryActiveShellView(@ptrCast(*const IShellBrowser, self), ppshv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_OnViewWindowActive(self: *const T, pshv: ?*IShellView) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).OnViewWindowActive(@ptrCast(*const IShellBrowser, self), pshv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellBrowser_SetToolbarItems(self: *const T, lpButtons: ?[*]TBBUTTON, nButtons: u32, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellBrowser.VTable, self.vtable).SetToolbarItems(@ptrCast(*const IShellBrowser, self), lpButtons, nButtons, uFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IProfferService_Value = @import("../zig.zig").Guid.initString("cb728b20-f786-11ce-92ad-00aa00a74cd0");
pub const IID_IProfferService = &IID_IProfferService_Value;
pub const IProfferService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProfferService: fn(
            self: *const IProfferService,
            serviceId: ?*const Guid,
            serviceProvider: ?*IServiceProvider,
            cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeService: fn(
            self: *const IProfferService,
            cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProfferService_ProfferService(self: *const T, serviceId: ?*const Guid, serviceProvider: ?*IServiceProvider, cookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProfferService.VTable, self.vtable).ProfferService(@ptrCast(*const IProfferService, self), serviceId, serviceProvider, cookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProfferService_RevokeService(self: *const T, cookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProfferService.VTable, self.vtable).RevokeService(@ptrCast(*const IProfferService, self), cookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetServiceIds_Value = @import("../zig.zig").Guid.initString("4a073526-6103-4e21-b7bc-f519d1524e5d");
pub const IID_IGetServiceIds = &IID_IGetServiceIds_Value;
pub const IGetServiceIds = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetServiceIds: fn(
            self: *const IGetServiceIds,
            serviceIdCount: ?*u32,
            serviceIds: [*]?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetServiceIds_GetServiceIds(self: *const T, serviceIdCount: ?*u32, serviceIds: [*]?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetServiceIds.VTable, self.vtable).GetServiceIds(@ptrCast(*const IGetServiceIds, self), serviceIdCount, serviceIds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SIGDN = enum(i32) {
    NORMALDISPLAY = 0,
    PARENTRELATIVEPARSING = -2147385343,
    DESKTOPABSOLUTEPARSING = -2147319808,
    PARENTRELATIVEEDITING = -2147282943,
    DESKTOPABSOLUTEEDITING = -2147172352,
    FILESYSPATH = -2147123200,
    URL = -2147057664,
    PARENTRELATIVEFORADDRESSBAR = -2146975743,
    PARENTRELATIVE = -2146959359,
    PARENTRELATIVEFORUI = -2146877439,
};
pub const SIGDN_NORMALDISPLAY = SIGDN.NORMALDISPLAY;
pub const SIGDN_PARENTRELATIVEPARSING = SIGDN.PARENTRELATIVEPARSING;
pub const SIGDN_DESKTOPABSOLUTEPARSING = SIGDN.DESKTOPABSOLUTEPARSING;
pub const SIGDN_PARENTRELATIVEEDITING = SIGDN.PARENTRELATIVEEDITING;
pub const SIGDN_DESKTOPABSOLUTEEDITING = SIGDN.DESKTOPABSOLUTEEDITING;
pub const SIGDN_FILESYSPATH = SIGDN.FILESYSPATH;
pub const SIGDN_URL = SIGDN.URL;
pub const SIGDN_PARENTRELATIVEFORADDRESSBAR = SIGDN.PARENTRELATIVEFORADDRESSBAR;
pub const SIGDN_PARENTRELATIVE = SIGDN.PARENTRELATIVE;
pub const SIGDN_PARENTRELATIVEFORUI = SIGDN.PARENTRELATIVEFORUI;

pub const _SICHINTF = enum(i32) {
    DISPLAY = 0,
    ALLFIELDS = -2147483648,
    CANONICAL = 268435456,
    TEST_FILESYSPATH_IF_NOT_EQUAL = 536870912,
};
pub const SICHINT_DISPLAY = _SICHINTF.DISPLAY;
pub const SICHINT_ALLFIELDS = _SICHINTF.ALLFIELDS;
pub const SICHINT_CANONICAL = _SICHINTF.CANONICAL;
pub const SICHINT_TEST_FILESYSPATH_IF_NOT_EQUAL = _SICHINTF.TEST_FILESYSPATH_IF_NOT_EQUAL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellItem_Value = @import("../zig.zig").Guid.initString("43826d1e-e718-42ee-bc55-a1e261c37bfe");
pub const IID_IShellItem = &IID_IShellItem_Value;
pub const IShellItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindToHandler: fn(
            self: *const IShellItem,
            pbc: ?*IBindCtx,
            bhid: ?*const Guid,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParent: fn(
            self: *const IShellItem,
            ppsi: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const IShellItem,
            sigdnName: SIGDN,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributes: fn(
            self: *const IShellItem,
            sfgaoMask: u32,
            psfgaoAttribs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Compare: fn(
            self: *const IShellItem,
            psi: ?*IShellItem,
            hint: u32,
            piOrder: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem_BindToHandler(self: *const T, pbc: ?*IBindCtx, bhid: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem.VTable, self.vtable).BindToHandler(@ptrCast(*const IShellItem, self), pbc, bhid, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem_GetParent(self: *const T, ppsi: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem.VTable, self.vtable).GetParent(@ptrCast(*const IShellItem, self), ppsi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem_GetDisplayName(self: *const T, sigdnName: SIGDN, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem.VTable, self.vtable).GetDisplayName(@ptrCast(*const IShellItem, self), sigdnName, ppszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem_GetAttributes(self: *const T, sfgaoMask: u32, psfgaoAttribs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem.VTable, self.vtable).GetAttributes(@ptrCast(*const IShellItem, self), sfgaoMask, psfgaoAttribs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem_Compare(self: *const T, psi: ?*IShellItem, hint: u32, piOrder: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem.VTable, self.vtable).Compare(@ptrCast(*const IShellItem, self), psi, hint, piOrder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DATAOBJ_GET_ITEM_FLAGS = enum(i32) {
    DEFAULT = 0,
    TRAVERSE_LINK = 1,
    NO_HDROP = 2,
    NO_URL = 4,
    ONLY_IF_ONE = 8,
};
pub const DOGIF_DEFAULT = DATAOBJ_GET_ITEM_FLAGS.DEFAULT;
pub const DOGIF_TRAVERSE_LINK = DATAOBJ_GET_ITEM_FLAGS.TRAVERSE_LINK;
pub const DOGIF_NO_HDROP = DATAOBJ_GET_ITEM_FLAGS.NO_HDROP;
pub const DOGIF_NO_URL = DATAOBJ_GET_ITEM_FLAGS.NO_URL;
pub const DOGIF_ONLY_IF_ONE = DATAOBJ_GET_ITEM_FLAGS.ONLY_IF_ONE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItem2_Value = @import("../zig.zig").Guid.initString("7e9fb0d3-919f-4307-ab2e-9b1860310c93");
pub const IID_IShellItem2 = &IID_IShellItem2_Value;
pub const IShellItem2 = extern struct {
    pub const VTable = extern struct {
        base: IShellItem.VTable,
        GetPropertyStore: fn(
            self: *const IShellItem2,
            flags: GETPROPERTYSTOREFLAGS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyStoreWithCreateObject: fn(
            self: *const IShellItem2,
            flags: GETPROPERTYSTOREFLAGS,
            punkCreateObject: ?*IUnknown,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyStoreForKeys: fn(
            self: *const IShellItem2,
            rgKeys: [*]const PROPERTYKEY,
            cKeys: u32,
            flags: GETPROPERTYSTOREFLAGS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyDescriptionList: fn(
            self: *const IShellItem2,
            keyType: ?*const PROPERTYKEY,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const IShellItem2,
            pbc: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IShellItem2,
            key: ?*const PROPERTYKEY,
            ppropvar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCLSID: fn(
            self: *const IShellItem2,
            key: ?*const PROPERTYKEY,
            pclsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileTime: fn(
            self: *const IShellItem2,
            key: ?*const PROPERTYKEY,
            pft: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInt32: fn(
            self: *const IShellItem2,
            key: ?*const PROPERTYKEY,
            pi: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: fn(
            self: *const IShellItem2,
            key: ?*const PROPERTYKEY,
            ppsz: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUInt32: fn(
            self: *const IShellItem2,
            key: ?*const PROPERTYKEY,
            pui: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUInt64: fn(
            self: *const IShellItem2,
            key: ?*const PROPERTYKEY,
            pull: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBool: fn(
            self: *const IShellItem2,
            key: ?*const PROPERTYKEY,
            pf: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetPropertyStore(self: *const T, flags: GETPROPERTYSTOREFLAGS, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetPropertyStore(@ptrCast(*const IShellItem2, self), flags, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetPropertyStoreWithCreateObject(self: *const T, flags: GETPROPERTYSTOREFLAGS, punkCreateObject: ?*IUnknown, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetPropertyStoreWithCreateObject(@ptrCast(*const IShellItem2, self), flags, punkCreateObject, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetPropertyStoreForKeys(self: *const T, rgKeys: [*]const PROPERTYKEY, cKeys: u32, flags: GETPROPERTYSTOREFLAGS, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetPropertyStoreForKeys(@ptrCast(*const IShellItem2, self), rgKeys, cKeys, flags, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetPropertyDescriptionList(self: *const T, keyType: ?*const PROPERTYKEY, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetPropertyDescriptionList(@ptrCast(*const IShellItem2, self), keyType, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_Update(self: *const T, pbc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).Update(@ptrCast(*const IShellItem2, self), pbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetProperty(self: *const T, key: ?*const PROPERTYKEY, ppropvar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetProperty(@ptrCast(*const IShellItem2, self), key, ppropvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetCLSID(self: *const T, key: ?*const PROPERTYKEY, pclsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetCLSID(@ptrCast(*const IShellItem2, self), key, pclsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetFileTime(self: *const T, key: ?*const PROPERTYKEY, pft: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetFileTime(@ptrCast(*const IShellItem2, self), key, pft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetInt32(self: *const T, key: ?*const PROPERTYKEY, pi: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetInt32(@ptrCast(*const IShellItem2, self), key, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetString(self: *const T, key: ?*const PROPERTYKEY, ppsz: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetString(@ptrCast(*const IShellItem2, self), key, ppsz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetUInt32(self: *const T, key: ?*const PROPERTYKEY, pui: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetUInt32(@ptrCast(*const IShellItem2, self), key, pui);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetUInt64(self: *const T, key: ?*const PROPERTYKEY, pull: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetUInt64(@ptrCast(*const IShellItem2, self), key, pull);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItem2_GetBool(self: *const T, key: ?*const PROPERTYKEY, pf: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItem2.VTable, self.vtable).GetBool(@ptrCast(*const IShellItem2, self), key, pf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SIIGBF = enum(i32) {
    RESIZETOFIT = 0,
    BIGGERSIZEOK = 1,
    MEMORYONLY = 2,
    ICONONLY = 4,
    THUMBNAILONLY = 8,
    INCACHEONLY = 16,
    CROPTOSQUARE = 32,
    WIDETHUMBNAILS = 64,
    ICONBACKGROUND = 128,
    SCALEUP = 256,
    _,
    pub fn initFlags(o: struct {
        RESIZETOFIT: u1 = 0,
        BIGGERSIZEOK: u1 = 0,
        MEMORYONLY: u1 = 0,
        ICONONLY: u1 = 0,
        THUMBNAILONLY: u1 = 0,
        INCACHEONLY: u1 = 0,
        CROPTOSQUARE: u1 = 0,
        WIDETHUMBNAILS: u1 = 0,
        ICONBACKGROUND: u1 = 0,
        SCALEUP: u1 = 0,
    }) SIIGBF {
        return @intToEnum(SIIGBF,
              (if (o.RESIZETOFIT == 1) @enumToInt(SIIGBF.RESIZETOFIT) else 0)
            | (if (o.BIGGERSIZEOK == 1) @enumToInt(SIIGBF.BIGGERSIZEOK) else 0)
            | (if (o.MEMORYONLY == 1) @enumToInt(SIIGBF.MEMORYONLY) else 0)
            | (if (o.ICONONLY == 1) @enumToInt(SIIGBF.ICONONLY) else 0)
            | (if (o.THUMBNAILONLY == 1) @enumToInt(SIIGBF.THUMBNAILONLY) else 0)
            | (if (o.INCACHEONLY == 1) @enumToInt(SIIGBF.INCACHEONLY) else 0)
            | (if (o.CROPTOSQUARE == 1) @enumToInt(SIIGBF.CROPTOSQUARE) else 0)
            | (if (o.WIDETHUMBNAILS == 1) @enumToInt(SIIGBF.WIDETHUMBNAILS) else 0)
            | (if (o.ICONBACKGROUND == 1) @enumToInt(SIIGBF.ICONBACKGROUND) else 0)
            | (if (o.SCALEUP == 1) @enumToInt(SIIGBF.SCALEUP) else 0)
        );
    }
};
pub const SIIGBF_RESIZETOFIT = SIIGBF.RESIZETOFIT;
pub const SIIGBF_BIGGERSIZEOK = SIIGBF.BIGGERSIZEOK;
pub const SIIGBF_MEMORYONLY = SIIGBF.MEMORYONLY;
pub const SIIGBF_ICONONLY = SIIGBF.ICONONLY;
pub const SIIGBF_THUMBNAILONLY = SIIGBF.THUMBNAILONLY;
pub const SIIGBF_INCACHEONLY = SIIGBF.INCACHEONLY;
pub const SIIGBF_CROPTOSQUARE = SIIGBF.CROPTOSQUARE;
pub const SIIGBF_WIDETHUMBNAILS = SIIGBF.WIDETHUMBNAILS;
pub const SIIGBF_ICONBACKGROUND = SIIGBF.ICONBACKGROUND;
pub const SIIGBF_SCALEUP = SIIGBF.SCALEUP;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItemImageFactory_Value = @import("../zig.zig").Guid.initString("bcc18b79-ba16-442f-80c4-8a59c30c463b");
pub const IID_IShellItemImageFactory = &IID_IShellItemImageFactory_Value;
pub const IShellItemImageFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetImage: fn(
            self: *const IShellItemImageFactory,
            size: SIZE,
            flags: SIIGBF,
            phbm: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemImageFactory_GetImage(self: *const T, size: SIZE, flags: SIIGBF, phbm: ?*?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemImageFactory.VTable, self.vtable).GetImage(@ptrCast(*const IShellItemImageFactory, self), size, flags, phbm);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumShellItems_Value = @import("../zig.zig").Guid.initString("70629033-e363-4a28-a567-0db78006e6d7");
pub const IID_IEnumShellItems = &IID_IEnumShellItems_Value;
pub const IEnumShellItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumShellItems,
            celt: u32,
            rgelt: [*]?*IShellItem,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumShellItems,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumShellItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumShellItems,
            ppenum: ?*?*IEnumShellItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumShellItems_Next(self: *const T, celt: u32, rgelt: [*]?*IShellItem, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumShellItems.VTable, self.vtable).Next(@ptrCast(*const IEnumShellItems, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumShellItems_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumShellItems.VTable, self.vtable).Skip(@ptrCast(*const IEnumShellItems, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumShellItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumShellItems.VTable, self.vtable).Reset(@ptrCast(*const IEnumShellItems, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumShellItems_Clone(self: *const T, ppenum: ?*?*IEnumShellItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumShellItems.VTable, self.vtable).Clone(@ptrCast(*const IEnumShellItems, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STGOP = enum(i32) {
    MOVE = 1,
    COPY = 2,
    SYNC = 3,
    REMOVE = 5,
    RENAME = 6,
    APPLYPROPERTIES = 8,
    NEW = 10,
};
pub const STGOP_MOVE = STGOP.MOVE;
pub const STGOP_COPY = STGOP.COPY;
pub const STGOP_SYNC = STGOP.SYNC;
pub const STGOP_REMOVE = STGOP.REMOVE;
pub const STGOP_RENAME = STGOP.RENAME;
pub const STGOP_APPLYPROPERTIES = STGOP.APPLYPROPERTIES;
pub const STGOP_NEW = STGOP.NEW;

pub const _TRANSFER_SOURCE_FLAGS = enum(i32) {
    NORMAL = 0,
    // FAIL_EXIST = 0, this enum value conflicts with NORMAL
    RENAME_EXIST = 1,
    OVERWRITE_EXIST = 2,
    ALLOW_DECRYPTION = 4,
    NO_SECURITY = 8,
    COPY_CREATION_TIME = 16,
    COPY_WRITE_TIME = 32,
    USE_FULL_ACCESS = 64,
    DELETE_RECYCLE_IF_POSSIBLE = 128,
    COPY_HARD_LINK = 256,
    COPY_LOCALIZED_NAME = 512,
    MOVE_AS_COPY_DELETE = 1024,
    SUSPEND_SHELLEVENTS = 2048,
};
pub const TSF_NORMAL = _TRANSFER_SOURCE_FLAGS.NORMAL;
pub const TSF_FAIL_EXIST = _TRANSFER_SOURCE_FLAGS.NORMAL;
pub const TSF_RENAME_EXIST = _TRANSFER_SOURCE_FLAGS.RENAME_EXIST;
pub const TSF_OVERWRITE_EXIST = _TRANSFER_SOURCE_FLAGS.OVERWRITE_EXIST;
pub const TSF_ALLOW_DECRYPTION = _TRANSFER_SOURCE_FLAGS.ALLOW_DECRYPTION;
pub const TSF_NO_SECURITY = _TRANSFER_SOURCE_FLAGS.NO_SECURITY;
pub const TSF_COPY_CREATION_TIME = _TRANSFER_SOURCE_FLAGS.COPY_CREATION_TIME;
pub const TSF_COPY_WRITE_TIME = _TRANSFER_SOURCE_FLAGS.COPY_WRITE_TIME;
pub const TSF_USE_FULL_ACCESS = _TRANSFER_SOURCE_FLAGS.USE_FULL_ACCESS;
pub const TSF_DELETE_RECYCLE_IF_POSSIBLE = _TRANSFER_SOURCE_FLAGS.DELETE_RECYCLE_IF_POSSIBLE;
pub const TSF_COPY_HARD_LINK = _TRANSFER_SOURCE_FLAGS.COPY_HARD_LINK;
pub const TSF_COPY_LOCALIZED_NAME = _TRANSFER_SOURCE_FLAGS.COPY_LOCALIZED_NAME;
pub const TSF_MOVE_AS_COPY_DELETE = _TRANSFER_SOURCE_FLAGS.MOVE_AS_COPY_DELETE;
pub const TSF_SUSPEND_SHELLEVENTS = _TRANSFER_SOURCE_FLAGS.SUSPEND_SHELLEVENTS;

pub const _TRANSFER_ADVISE_STATE = enum(i32) {
    NONE = 0,
    PERFORMING = 1,
    PREPARING = 2,
    INDETERMINATE = 4,
};
pub const TS_NONE = _TRANSFER_ADVISE_STATE.NONE;
pub const TS_PERFORMING = _TRANSFER_ADVISE_STATE.PERFORMING;
pub const TS_PREPARING = _TRANSFER_ADVISE_STATE.PREPARING;
pub const TS_INDETERMINATE = _TRANSFER_ADVISE_STATE.INDETERMINATE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITransferAdviseSink_Value = @import("../zig.zig").Guid.initString("d594d0d8-8da7-457b-b3b4-ce5dbaac0b88");
pub const IID_ITransferAdviseSink = &IID_ITransferAdviseSink_Value;
pub const ITransferAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateProgress: fn(
            self: *const ITransferAdviseSink,
            ullSizeCurrent: u64,
            ullSizeTotal: u64,
            nFilesCurrent: i32,
            nFilesTotal: i32,
            nFoldersCurrent: i32,
            nFoldersTotal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateTransferState: fn(
            self: *const ITransferAdviseSink,
            ts: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfirmOverwrite: fn(
            self: *const ITransferAdviseSink,
            psiSource: ?*IShellItem,
            psiDestParent: ?*IShellItem,
            pszName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfirmEncryptionLoss: fn(
            self: *const ITransferAdviseSink,
            psiSource: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FileFailure: fn(
            self: *const ITransferAdviseSink,
            psi: ?*IShellItem,
            pszItem: ?[*:0]const u16,
            hrError: HRESULT,
            pszRename: [*:0]u16,
            cchRename: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubStreamFailure: fn(
            self: *const ITransferAdviseSink,
            psi: ?*IShellItem,
            pszStreamName: ?[*:0]const u16,
            hrError: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PropertyFailure: fn(
            self: *const ITransferAdviseSink,
            psi: ?*IShellItem,
            pkey: ?*const PROPERTYKEY,
            hrError: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferAdviseSink_UpdateProgress(self: *const T, ullSizeCurrent: u64, ullSizeTotal: u64, nFilesCurrent: i32, nFilesTotal: i32, nFoldersCurrent: i32, nFoldersTotal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferAdviseSink.VTable, self.vtable).UpdateProgress(@ptrCast(*const ITransferAdviseSink, self), ullSizeCurrent, ullSizeTotal, nFilesCurrent, nFilesTotal, nFoldersCurrent, nFoldersTotal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferAdviseSink_UpdateTransferState(self: *const T, ts: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferAdviseSink.VTable, self.vtable).UpdateTransferState(@ptrCast(*const ITransferAdviseSink, self), ts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferAdviseSink_ConfirmOverwrite(self: *const T, psiSource: ?*IShellItem, psiDestParent: ?*IShellItem, pszName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferAdviseSink.VTable, self.vtable).ConfirmOverwrite(@ptrCast(*const ITransferAdviseSink, self), psiSource, psiDestParent, pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferAdviseSink_ConfirmEncryptionLoss(self: *const T, psiSource: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferAdviseSink.VTable, self.vtable).ConfirmEncryptionLoss(@ptrCast(*const ITransferAdviseSink, self), psiSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferAdviseSink_FileFailure(self: *const T, psi: ?*IShellItem, pszItem: ?[*:0]const u16, hrError: HRESULT, pszRename: [*:0]u16, cchRename: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferAdviseSink.VTable, self.vtable).FileFailure(@ptrCast(*const ITransferAdviseSink, self), psi, pszItem, hrError, pszRename, cchRename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferAdviseSink_SubStreamFailure(self: *const T, psi: ?*IShellItem, pszStreamName: ?[*:0]const u16, hrError: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferAdviseSink.VTable, self.vtable).SubStreamFailure(@ptrCast(*const ITransferAdviseSink, self), psi, pszStreamName, hrError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferAdviseSink_PropertyFailure(self: *const T, psi: ?*IShellItem, pkey: ?*const PROPERTYKEY, hrError: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferAdviseSink.VTable, self.vtable).PropertyFailure(@ptrCast(*const ITransferAdviseSink, self), psi, pkey, hrError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITransferSource_Value = @import("../zig.zig").Guid.initString("00adb003-bde9-45c6-8e29-d09f9353e108");
pub const IID_ITransferSource = &IID_ITransferSource_Value;
pub const ITransferSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: fn(
            self: *const ITransferSource,
            psink: ?*ITransferAdviseSink,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const ITransferSource,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const ITransferSource,
            pproparray: ?*IPropertyChangeArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenItem: fn(
            self: *const ITransferSource,
            psi: ?*IShellItem,
            flags: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveItem: fn(
            self: *const ITransferSource,
            psi: ?*IShellItem,
            psiParentDst: ?*IShellItem,
            pszNameDst: ?[*:0]const u16,
            flags: u32,
            ppsiNew: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecycleItem: fn(
            self: *const ITransferSource,
            psiSource: ?*IShellItem,
            psiParentDest: ?*IShellItem,
            flags: u32,
            ppsiNewDest: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveItem: fn(
            self: *const ITransferSource,
            psiSource: ?*IShellItem,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenameItem: fn(
            self: *const ITransferSource,
            psiSource: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
            flags: u32,
            ppsiNewDest: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LinkItem: fn(
            self: *const ITransferSource,
            psiSource: ?*IShellItem,
            psiParentDest: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
            flags: u32,
            ppsiNewDest: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyPropertiesToItem: fn(
            self: *const ITransferSource,
            psiSource: ?*IShellItem,
            ppsiNew: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultDestinationName: fn(
            self: *const ITransferSource,
            psiSource: ?*IShellItem,
            psiParentDest: ?*IShellItem,
            ppszDestinationName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnterFolder: fn(
            self: *const ITransferSource,
            psiChildFolderDest: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LeaveFolder: fn(
            self: *const ITransferSource,
            psiChildFolderDest: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_Advise(self: *const T, psink: ?*ITransferAdviseSink, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).Advise(@ptrCast(*const ITransferSource, self), psink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).Unadvise(@ptrCast(*const ITransferSource, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_SetProperties(self: *const T, pproparray: ?*IPropertyChangeArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).SetProperties(@ptrCast(*const ITransferSource, self), pproparray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_OpenItem(self: *const T, psi: ?*IShellItem, flags: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).OpenItem(@ptrCast(*const ITransferSource, self), psi, flags, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_MoveItem(self: *const T, psi: ?*IShellItem, psiParentDst: ?*IShellItem, pszNameDst: ?[*:0]const u16, flags: u32, ppsiNew: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).MoveItem(@ptrCast(*const ITransferSource, self), psi, psiParentDst, pszNameDst, flags, ppsiNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_RecycleItem(self: *const T, psiSource: ?*IShellItem, psiParentDest: ?*IShellItem, flags: u32, ppsiNewDest: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).RecycleItem(@ptrCast(*const ITransferSource, self), psiSource, psiParentDest, flags, ppsiNewDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_RemoveItem(self: *const T, psiSource: ?*IShellItem, flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).RemoveItem(@ptrCast(*const ITransferSource, self), psiSource, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_RenameItem(self: *const T, psiSource: ?*IShellItem, pszNewName: ?[*:0]const u16, flags: u32, ppsiNewDest: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).RenameItem(@ptrCast(*const ITransferSource, self), psiSource, pszNewName, flags, ppsiNewDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_LinkItem(self: *const T, psiSource: ?*IShellItem, psiParentDest: ?*IShellItem, pszNewName: ?[*:0]const u16, flags: u32, ppsiNewDest: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).LinkItem(@ptrCast(*const ITransferSource, self), psiSource, psiParentDest, pszNewName, flags, ppsiNewDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_ApplyPropertiesToItem(self: *const T, psiSource: ?*IShellItem, ppsiNew: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).ApplyPropertiesToItem(@ptrCast(*const ITransferSource, self), psiSource, ppsiNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_GetDefaultDestinationName(self: *const T, psiSource: ?*IShellItem, psiParentDest: ?*IShellItem, ppszDestinationName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).GetDefaultDestinationName(@ptrCast(*const ITransferSource, self), psiSource, psiParentDest, ppszDestinationName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_EnterFolder(self: *const T, psiChildFolderDest: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).EnterFolder(@ptrCast(*const ITransferSource, self), psiChildFolderDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferSource_LeaveFolder(self: *const T, psiChildFolderDest: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferSource.VTable, self.vtable).LeaveFolder(@ptrCast(*const ITransferSource, self), psiChildFolderDest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHELL_ITEM_RESOURCE = extern struct {
    guidType: Guid,
    szName: [260]u16,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumResources_Value = @import("../zig.zig").Guid.initString("2dd81fe3-a83c-4da9-a330-47249d345ba1");
pub const IID_IEnumResources = &IID_IEnumResources_Value;
pub const IEnumResources = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumResources,
            celt: u32,
            psir: [*]SHELL_ITEM_RESOURCE,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumResources,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumResources,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumResources,
            ppenumr: ?*?*IEnumResources,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumResources_Next(self: *const T, celt: u32, psir: [*]SHELL_ITEM_RESOURCE, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumResources.VTable, self.vtable).Next(@ptrCast(*const IEnumResources, self), celt, psir, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumResources_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumResources.VTable, self.vtable).Skip(@ptrCast(*const IEnumResources, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumResources_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumResources.VTable, self.vtable).Reset(@ptrCast(*const IEnumResources, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumResources_Clone(self: *const T, ppenumr: ?*?*IEnumResources) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumResources.VTable, self.vtable).Clone(@ptrCast(*const IEnumResources, self), ppenumr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItemResources_Value = @import("../zig.zig").Guid.initString("ff5693be-2ce0-4d48-b5c5-40817d1acdb9");
pub const IID_IShellItemResources = &IID_IShellItemResources_Value;
pub const IShellItemResources = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAttributes: fn(
            self: *const IShellItemResources,
            pdwAttributes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IShellItemResources,
            pullSize: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimes: fn(
            self: *const IShellItemResources,
            pftCreation: ?*FILETIME,
            pftWrite: ?*FILETIME,
            pftAccess: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimes: fn(
            self: *const IShellItemResources,
            pftCreation: ?*const FILETIME,
            pftWrite: ?*const FILETIME,
            pftAccess: ?*const FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResourceDescription: fn(
            self: *const IShellItemResources,
            pcsir: ?*const SHELL_ITEM_RESOURCE,
            ppszDescription: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumResources: fn(
            self: *const IShellItemResources,
            ppenumr: ?*?*IEnumResources,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupportsResource: fn(
            self: *const IShellItemResources,
            pcsir: ?*const SHELL_ITEM_RESOURCE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenResource: fn(
            self: *const IShellItemResources,
            pcsir: ?*const SHELL_ITEM_RESOURCE,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateResource: fn(
            self: *const IShellItemResources,
            pcsir: ?*const SHELL_ITEM_RESOURCE,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MarkForDelete: fn(
            self: *const IShellItemResources,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_GetAttributes(self: *const T, pdwAttributes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).GetAttributes(@ptrCast(*const IShellItemResources, self), pdwAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_GetSize(self: *const T, pullSize: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).GetSize(@ptrCast(*const IShellItemResources, self), pullSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_GetTimes(self: *const T, pftCreation: ?*FILETIME, pftWrite: ?*FILETIME, pftAccess: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).GetTimes(@ptrCast(*const IShellItemResources, self), pftCreation, pftWrite, pftAccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_SetTimes(self: *const T, pftCreation: ?*const FILETIME, pftWrite: ?*const FILETIME, pftAccess: ?*const FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).SetTimes(@ptrCast(*const IShellItemResources, self), pftCreation, pftWrite, pftAccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_GetResourceDescription(self: *const T, pcsir: ?*const SHELL_ITEM_RESOURCE, ppszDescription: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).GetResourceDescription(@ptrCast(*const IShellItemResources, self), pcsir, ppszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_EnumResources(self: *const T, ppenumr: ?*?*IEnumResources) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).EnumResources(@ptrCast(*const IShellItemResources, self), ppenumr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_SupportsResource(self: *const T, pcsir: ?*const SHELL_ITEM_RESOURCE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).SupportsResource(@ptrCast(*const IShellItemResources, self), pcsir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_OpenResource(self: *const T, pcsir: ?*const SHELL_ITEM_RESOURCE, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).OpenResource(@ptrCast(*const IShellItemResources, self), pcsir, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_CreateResource(self: *const T, pcsir: ?*const SHELL_ITEM_RESOURCE, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).CreateResource(@ptrCast(*const IShellItemResources, self), pcsir, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemResources_MarkForDelete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemResources.VTable, self.vtable).MarkForDelete(@ptrCast(*const IShellItemResources, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITransferDestination_Value = @import("../zig.zig").Guid.initString("48addd32-3ca5-4124-abe3-b5a72531b207");
pub const IID_ITransferDestination = &IID_ITransferDestination_Value;
pub const ITransferDestination = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: fn(
            self: *const ITransferDestination,
            psink: ?*ITransferAdviseSink,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const ITransferDestination,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateItem: fn(
            self: *const ITransferDestination,
            pszName: ?[*:0]const u16,
            dwAttributes: u32,
            ullSize: u64,
            flags: u32,
            riidItem: ?*const Guid,
            ppvItem: ?*?*anyopaque,
            riidResources: ?*const Guid,
            ppvResources: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferDestination_Advise(self: *const T, psink: ?*ITransferAdviseSink, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferDestination.VTable, self.vtable).Advise(@ptrCast(*const ITransferDestination, self), psink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferDestination_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferDestination.VTable, self.vtable).Unadvise(@ptrCast(*const ITransferDestination, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransferDestination_CreateItem(self: *const T, pszName: ?[*:0]const u16, dwAttributes: u32, ullSize: u64, flags: u32, riidItem: ?*const Guid, ppvItem: ?*?*anyopaque, riidResources: ?*const Guid, ppvResources: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransferDestination.VTable, self.vtable).CreateItem(@ptrCast(*const ITransferDestination, self), pszName, dwAttributes, ullSize, flags, riidItem, ppvItem, riidResources, ppvResources);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileOperationProgressSink_Value = @import("../zig.zig").Guid.initString("04b0f1a7-9490-44bc-96e1-4296a31252e2");
pub const IID_IFileOperationProgressSink = &IID_IFileOperationProgressSink_Value;
pub const IFileOperationProgressSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartOperations: fn(
            self: *const IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FinishOperations: fn(
            self: *const IFileOperationProgressSink,
            hrResult: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreRenameItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiItem: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostRenameItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiItem: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
            hrRename: HRESULT,
            psiNewlyCreated: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreMoveItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiItem: ?*IShellItem,
            psiDestinationFolder: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostMoveItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiItem: ?*IShellItem,
            psiDestinationFolder: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
            hrMove: HRESULT,
            psiNewlyCreated: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreCopyItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiItem: ?*IShellItem,
            psiDestinationFolder: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostCopyItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiItem: ?*IShellItem,
            psiDestinationFolder: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
            hrCopy: HRESULT,
            psiNewlyCreated: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreDeleteItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiItem: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostDeleteItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiItem: ?*IShellItem,
            hrDelete: HRESULT,
            psiNewlyCreated: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreNewItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiDestinationFolder: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostNewItem: fn(
            self: *const IFileOperationProgressSink,
            dwFlags: u32,
            psiDestinationFolder: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
            pszTemplateName: ?[*:0]const u16,
            dwFileAttributes: u32,
            hrNew: HRESULT,
            psiNewItem: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateProgress: fn(
            self: *const IFileOperationProgressSink,
            iWorkTotal: u32,
            iWorkSoFar: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetTimer: fn(
            self: *const IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseTimer: fn(
            self: *const IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumeTimer: fn(
            self: *const IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_StartOperations(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).StartOperations(@ptrCast(*const IFileOperationProgressSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_FinishOperations(self: *const T, hrResult: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).FinishOperations(@ptrCast(*const IFileOperationProgressSink, self), hrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PreRenameItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, pszNewName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PreRenameItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiItem, pszNewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PostRenameItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, pszNewName: ?[*:0]const u16, hrRename: HRESULT, psiNewlyCreated: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PostRenameItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiItem, pszNewName, hrRename, psiNewlyCreated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PreMoveItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PreMoveItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiItem, psiDestinationFolder, pszNewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PostMoveItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16, hrMove: HRESULT, psiNewlyCreated: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PostMoveItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiItem, psiDestinationFolder, pszNewName, hrMove, psiNewlyCreated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PreCopyItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PreCopyItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiItem, psiDestinationFolder, pszNewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PostCopyItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16, hrCopy: HRESULT, psiNewlyCreated: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PostCopyItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiItem, psiDestinationFolder, pszNewName, hrCopy, psiNewlyCreated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PreDeleteItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PreDeleteItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PostDeleteItem(self: *const T, dwFlags: u32, psiItem: ?*IShellItem, hrDelete: HRESULT, psiNewlyCreated: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PostDeleteItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiItem, hrDelete, psiNewlyCreated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PreNewItem(self: *const T, dwFlags: u32, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PreNewItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiDestinationFolder, pszNewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PostNewItem(self: *const T, dwFlags: u32, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16, pszTemplateName: ?[*:0]const u16, dwFileAttributes: u32, hrNew: HRESULT, psiNewItem: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PostNewItem(@ptrCast(*const IFileOperationProgressSink, self), dwFlags, psiDestinationFolder, pszNewName, pszTemplateName, dwFileAttributes, hrNew, psiNewItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_UpdateProgress(self: *const T, iWorkTotal: u32, iWorkSoFar: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).UpdateProgress(@ptrCast(*const IFileOperationProgressSink, self), iWorkTotal, iWorkSoFar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_ResetTimer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).ResetTimer(@ptrCast(*const IFileOperationProgressSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_PauseTimer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).PauseTimer(@ptrCast(*const IFileOperationProgressSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperationProgressSink_ResumeTimer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperationProgressSink.VTable, self.vtable).ResumeTimer(@ptrCast(*const IFileOperationProgressSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SIATTRIBFLAGS = enum(i32) {
    AND = 1,
    OR = 2,
    APPCOMPAT = 3,
    // MASK = 3, this enum value conflicts with APPCOMPAT
    ALLITEMS = 16384,
};
pub const SIATTRIBFLAGS_AND = SIATTRIBFLAGS.AND;
pub const SIATTRIBFLAGS_OR = SIATTRIBFLAGS.OR;
pub const SIATTRIBFLAGS_APPCOMPAT = SIATTRIBFLAGS.APPCOMPAT;
pub const SIATTRIBFLAGS_MASK = SIATTRIBFLAGS.APPCOMPAT;
pub const SIATTRIBFLAGS_ALLITEMS = SIATTRIBFLAGS.ALLITEMS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItemArray_Value = @import("../zig.zig").Guid.initString("b63ea76d-1f85-456f-a19c-48159efa858b");
pub const IID_IShellItemArray = &IID_IShellItemArray_Value;
pub const IShellItemArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindToHandler: fn(
            self: *const IShellItemArray,
            pbc: ?*IBindCtx,
            bhid: ?*const Guid,
            riid: ?*const Guid,
            ppvOut: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyStore: fn(
            self: *const IShellItemArray,
            flags: GETPROPERTYSTOREFLAGS,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyDescriptionList: fn(
            self: *const IShellItemArray,
            keyType: ?*const PROPERTYKEY,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributes: fn(
            self: *const IShellItemArray,
            AttribFlags: SIATTRIBFLAGS,
            sfgaoMask: u32,
            psfgaoAttribs: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const IShellItemArray,
            pdwNumItems: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemAt: fn(
            self: *const IShellItemArray,
            dwIndex: u32,
            ppsi: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumItems: fn(
            self: *const IShellItemArray,
            ppenumShellItems: ?*?*IEnumShellItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemArray_BindToHandler(self: *const T, pbc: ?*IBindCtx, bhid: ?*const Guid, riid: ?*const Guid, ppvOut: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemArray.VTable, self.vtable).BindToHandler(@ptrCast(*const IShellItemArray, self), pbc, bhid, riid, ppvOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemArray_GetPropertyStore(self: *const T, flags: GETPROPERTYSTOREFLAGS, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemArray.VTable, self.vtable).GetPropertyStore(@ptrCast(*const IShellItemArray, self), flags, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemArray_GetPropertyDescriptionList(self: *const T, keyType: ?*const PROPERTYKEY, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemArray.VTable, self.vtable).GetPropertyDescriptionList(@ptrCast(*const IShellItemArray, self), keyType, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemArray_GetAttributes(self: *const T, AttribFlags: SIATTRIBFLAGS, sfgaoMask: u32, psfgaoAttribs: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemArray.VTable, self.vtable).GetAttributes(@ptrCast(*const IShellItemArray, self), AttribFlags, sfgaoMask, psfgaoAttribs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemArray_GetCount(self: *const T, pdwNumItems: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemArray.VTable, self.vtable).GetCount(@ptrCast(*const IShellItemArray, self), pdwNumItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemArray_GetItemAt(self: *const T, dwIndex: u32, ppsi: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemArray.VTable, self.vtable).GetItemAt(@ptrCast(*const IShellItemArray, self), dwIndex, ppsi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemArray_EnumItems(self: *const T, ppenumShellItems: ?*?*IEnumShellItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemArray.VTable, self.vtable).EnumItems(@ptrCast(*const IShellItemArray, self), ppenumShellItems);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IInitializeWithItem_Value = @import("../zig.zig").Guid.initString("7f73be3f-fb79-493c-a6c7-7ee14e245841");
pub const IID_IInitializeWithItem = &IID_IInitializeWithItem_Value;
pub const IInitializeWithItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IInitializeWithItem,
            psi: ?*IShellItem,
            grfMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeWithItem_Initialize(self: *const T, psi: ?*IShellItem, grfMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeWithItem.VTable, self.vtable).Initialize(@ptrCast(*const IInitializeWithItem, self), psi, grfMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithSelection_Value = @import("../zig.zig").Guid.initString("1c9cd5bb-98e9-4491-a60f-31aacc72b83c");
pub const IID_IObjectWithSelection = &IID_IObjectWithSelection_Value;
pub const IObjectWithSelection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSelection: fn(
            self: *const IObjectWithSelection,
            psia: ?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const IObjectWithSelection,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithSelection_SetSelection(self: *const T, psia: ?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithSelection.VTable, self.vtable).SetSelection(@ptrCast(*const IObjectWithSelection, self), psia);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithSelection_GetSelection(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithSelection.VTable, self.vtable).GetSelection(@ptrCast(*const IObjectWithSelection, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IObjectWithBackReferences_Value = @import("../zig.zig").Guid.initString("321a6a6a-d61f-4bf3-97ae-14be2986bb36");
pub const IID_IObjectWithBackReferences = &IID_IObjectWithBackReferences_Value;
pub const IObjectWithBackReferences = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RemoveBackReferences: fn(
            self: *const IObjectWithBackReferences,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithBackReferences_RemoveBackReferences(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithBackReferences.VTable, self.vtable).RemoveBackReferences(@ptrCast(*const IObjectWithBackReferences, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICategoryProvider_Value = @import("../zig.zig").Guid.initString("9af64809-5864-4c26-a720-c1f78c086ee3");
pub const IID_ICategoryProvider = &IID_ICategoryProvider_Value;
pub const ICategoryProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanCategorizeOnSCID: fn(
            self: *const ICategoryProvider,
            pscid: ?*const PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultCategory: fn(
            self: *const ICategoryProvider,
            pguid: ?*Guid,
            pscid: ?*PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategoryForSCID: fn(
            self: *const ICategoryProvider,
            pscid: ?*const PROPERTYKEY,
            pguid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCategories: fn(
            self: *const ICategoryProvider,
            penum: ?*?*IEnumGUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategoryName: fn(
            self: *const ICategoryProvider,
            pguid: ?*const Guid,
            pszName: [*:0]u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCategory: fn(
            self: *const ICategoryProvider,
            pguid: ?*const Guid,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategoryProvider_CanCategorizeOnSCID(self: *const T, pscid: ?*const PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategoryProvider.VTable, self.vtable).CanCategorizeOnSCID(@ptrCast(*const ICategoryProvider, self), pscid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategoryProvider_GetDefaultCategory(self: *const T, pguid: ?*Guid, pscid: ?*PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategoryProvider.VTable, self.vtable).GetDefaultCategory(@ptrCast(*const ICategoryProvider, self), pguid, pscid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategoryProvider_GetCategoryForSCID(self: *const T, pscid: ?*const PROPERTYKEY, pguid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategoryProvider.VTable, self.vtable).GetCategoryForSCID(@ptrCast(*const ICategoryProvider, self), pscid, pguid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategoryProvider_EnumCategories(self: *const T, penum: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategoryProvider.VTable, self.vtable).EnumCategories(@ptrCast(*const ICategoryProvider, self), penum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategoryProvider_GetCategoryName(self: *const T, pguid: ?*const Guid, pszName: [*:0]u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategoryProvider.VTable, self.vtable).GetCategoryName(@ptrCast(*const ICategoryProvider, self), pguid, pszName, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategoryProvider_CreateCategory(self: *const T, pguid: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategoryProvider.VTable, self.vtable).CreateCategory(@ptrCast(*const ICategoryProvider, self), pguid, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CATEGORYINFO_FLAGS = enum(i32) {
    NORMAL = 0,
    COLLAPSED = 1,
    HIDDEN = 2,
    EXPANDED = 4,
    NOHEADER = 8,
    NOTCOLLAPSIBLE = 16,
    NOHEADERCOUNT = 32,
    SUBSETTED = 64,
    SEPARATE_IMAGES = 128,
    SHOWEMPTY = 256,
};
pub const CATINFO_NORMAL = CATEGORYINFO_FLAGS.NORMAL;
pub const CATINFO_COLLAPSED = CATEGORYINFO_FLAGS.COLLAPSED;
pub const CATINFO_HIDDEN = CATEGORYINFO_FLAGS.HIDDEN;
pub const CATINFO_EXPANDED = CATEGORYINFO_FLAGS.EXPANDED;
pub const CATINFO_NOHEADER = CATEGORYINFO_FLAGS.NOHEADER;
pub const CATINFO_NOTCOLLAPSIBLE = CATEGORYINFO_FLAGS.NOTCOLLAPSIBLE;
pub const CATINFO_NOHEADERCOUNT = CATEGORYINFO_FLAGS.NOHEADERCOUNT;
pub const CATINFO_SUBSETTED = CATEGORYINFO_FLAGS.SUBSETTED;
pub const CATINFO_SEPARATE_IMAGES = CATEGORYINFO_FLAGS.SEPARATE_IMAGES;
pub const CATINFO_SHOWEMPTY = CATEGORYINFO_FLAGS.SHOWEMPTY;

pub const CATSORT_FLAGS = enum(i32) {
    DEFAULT = 0,
    NAME = 1,
};
pub const CATSORT_DEFAULT = CATSORT_FLAGS.DEFAULT;
pub const CATSORT_NAME = CATSORT_FLAGS.NAME;

pub const CATEGORY_INFO = extern struct {
    cif: CATEGORYINFO_FLAGS,
    wszName: [260]u16,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICategorizer_Value = @import("../zig.zig").Guid.initString("a3b14589-9174-49a8-89a3-06a1ae2b9ba7");
pub const IID_ICategorizer = &IID_ICategorizer_Value;
pub const ICategorizer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDescription: fn(
            self: *const ICategorizer,
            pszDesc: [*:0]u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategory: fn(
            self: *const ICategorizer,
            cidl: u32,
            apidl: [*]?*ITEMIDLIST,
            rgCategoryIds: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategoryInfo: fn(
            self: *const ICategorizer,
            dwCategoryId: u32,
            pci: ?*CATEGORY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareCategory: fn(
            self: *const ICategorizer,
            csfFlags: CATSORT_FLAGS,
            dwCategoryId1: u32,
            dwCategoryId2: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategorizer_GetDescription(self: *const T, pszDesc: [*:0]u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategorizer.VTable, self.vtable).GetDescription(@ptrCast(*const ICategorizer, self), pszDesc, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategorizer_GetCategory(self: *const T, cidl: u32, apidl: [*]?*ITEMIDLIST, rgCategoryIds: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategorizer.VTable, self.vtable).GetCategory(@ptrCast(*const ICategorizer, self), cidl, apidl, rgCategoryIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategorizer_GetCategoryInfo(self: *const T, dwCategoryId: u32, pci: ?*CATEGORY_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategorizer.VTable, self.vtable).GetCategoryInfo(@ptrCast(*const ICategorizer, self), dwCategoryId, pci);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICategorizer_CompareCategory(self: *const T, csfFlags: CATSORT_FLAGS, dwCategoryId1: u32, dwCategoryId2: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICategorizer.VTable, self.vtable).CompareCategory(@ptrCast(*const ICategorizer, self), csfFlags, dwCategoryId1, dwCategoryId2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHDRAGIMAGE = extern struct {
    sizeDragImage: SIZE,
    ptOffset: POINT,
    hbmpDragImage: ?HBITMAP,
    crColorKey: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDropTargetHelper_Value = @import("../zig.zig").Guid.initString("4657278b-411b-11d2-839a-00c04fd918d0");
pub const IID_IDropTargetHelper = &IID_IDropTargetHelper_Value;
pub const IDropTargetHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DragEnter: fn(
            self: *const IDropTargetHelper,
            hwndTarget: ?HWND,
            pDataObject: ?*IDataObject,
            ppt: ?*POINT,
            dwEffect: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragLeave: fn(
            self: *const IDropTargetHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragOver: fn(
            self: *const IDropTargetHelper,
            ppt: ?*POINT,
            dwEffect: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Drop: fn(
            self: *const IDropTargetHelper,
            pDataObject: ?*IDataObject,
            ppt: ?*POINT,
            dwEffect: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const IDropTargetHelper,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTargetHelper_DragEnter(self: *const T, hwndTarget: ?HWND, pDataObject: ?*IDataObject, ppt: ?*POINT, dwEffect: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTargetHelper.VTable, self.vtable).DragEnter(@ptrCast(*const IDropTargetHelper, self), hwndTarget, pDataObject, ppt, dwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTargetHelper_DragLeave(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTargetHelper.VTable, self.vtable).DragLeave(@ptrCast(*const IDropTargetHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTargetHelper_DragOver(self: *const T, ppt: ?*POINT, dwEffect: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTargetHelper.VTable, self.vtable).DragOver(@ptrCast(*const IDropTargetHelper, self), ppt, dwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTargetHelper_Drop(self: *const T, pDataObject: ?*IDataObject, ppt: ?*POINT, dwEffect: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTargetHelper.VTable, self.vtable).Drop(@ptrCast(*const IDropTargetHelper, self), pDataObject, ppt, dwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTargetHelper_Show(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTargetHelper.VTable, self.vtable).Show(@ptrCast(*const IDropTargetHelper, self), fShow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDragSourceHelper_Value = @import("../zig.zig").Guid.initString("de5bf786-477a-11d2-839d-00c04fd918d0");
pub const IID_IDragSourceHelper = &IID_IDragSourceHelper_Value;
pub const IDragSourceHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeFromBitmap: fn(
            self: *const IDragSourceHelper,
            pshdi: ?*SHDRAGIMAGE,
            pDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFromWindow: fn(
            self: *const IDragSourceHelper,
            hwnd: ?HWND,
            ppt: ?*POINT,
            pDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragSourceHelper_InitializeFromBitmap(self: *const T, pshdi: ?*SHDRAGIMAGE, pDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragSourceHelper.VTable, self.vtable).InitializeFromBitmap(@ptrCast(*const IDragSourceHelper, self), pshdi, pDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragSourceHelper_InitializeFromWindow(self: *const T, hwnd: ?HWND, ppt: ?*POINT, pDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragSourceHelper.VTable, self.vtable).InitializeFromWindow(@ptrCast(*const IDragSourceHelper, self), hwnd, ppt, pDataObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SLR_FLAGS = enum(i32) {
    NONE = 0,
    NO_UI = 1,
    ANY_MATCH = 2,
    UPDATE = 4,
    NOUPDATE = 8,
    NOSEARCH = 16,
    NOTRACK = 32,
    NOLINKINFO = 64,
    INVOKE_MSI = 128,
    NO_UI_WITH_MSG_PUMP = 257,
    OFFER_DELETE_WITHOUT_FILE = 512,
    KNOWNFOLDER = 1024,
    MACHINE_IN_LOCAL_TARGET = 2048,
    UPDATE_MACHINE_AND_SID = 4096,
    NO_OBJECT_ID = 8192,
};
pub const SLR_NONE = SLR_FLAGS.NONE;
pub const SLR_NO_UI = SLR_FLAGS.NO_UI;
pub const SLR_ANY_MATCH = SLR_FLAGS.ANY_MATCH;
pub const SLR_UPDATE = SLR_FLAGS.UPDATE;
pub const SLR_NOUPDATE = SLR_FLAGS.NOUPDATE;
pub const SLR_NOSEARCH = SLR_FLAGS.NOSEARCH;
pub const SLR_NOTRACK = SLR_FLAGS.NOTRACK;
pub const SLR_NOLINKINFO = SLR_FLAGS.NOLINKINFO;
pub const SLR_INVOKE_MSI = SLR_FLAGS.INVOKE_MSI;
pub const SLR_NO_UI_WITH_MSG_PUMP = SLR_FLAGS.NO_UI_WITH_MSG_PUMP;
pub const SLR_OFFER_DELETE_WITHOUT_FILE = SLR_FLAGS.OFFER_DELETE_WITHOUT_FILE;
pub const SLR_KNOWNFOLDER = SLR_FLAGS.KNOWNFOLDER;
pub const SLR_MACHINE_IN_LOCAL_TARGET = SLR_FLAGS.MACHINE_IN_LOCAL_TARGET;
pub const SLR_UPDATE_MACHINE_AND_SID = SLR_FLAGS.UPDATE_MACHINE_AND_SID;
pub const SLR_NO_OBJECT_ID = SLR_FLAGS.NO_OBJECT_ID;

pub const SLGP_FLAGS = enum(i32) {
    SHORTPATH = 1,
    UNCPRIORITY = 2,
    RAWPATH = 4,
    RELATIVEPRIORITY = 8,
};
pub const SLGP_SHORTPATH = SLGP_FLAGS.SHORTPATH;
pub const SLGP_UNCPRIORITY = SLGP_FLAGS.UNCPRIORITY;
pub const SLGP_RAWPATH = SLGP_FLAGS.RAWPATH;
pub const SLGP_RELATIVEPRIORITY = SLGP_FLAGS.RELATIVEPRIORITY;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellLinkA_Value = @import("../zig.zig").Guid.initString("000214ee-0000-0000-c000-000000000046");
pub const IID_IShellLinkA = &IID_IShellLinkA_Value;
pub const IShellLinkA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPath: fn(
            self: *const IShellLinkA,
            pszFile: [*:0]u8,
            cch: i32,
            pfd: ?*WIN32_FIND_DATAA,
            fFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDList: fn(
            self: *const IShellLinkA,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIDList: fn(
            self: *const IShellLinkA,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IShellLinkA,
            pszName: [*:0]u8,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescription: fn(
            self: *const IShellLinkA,
            pszName: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWorkingDirectory: fn(
            self: *const IShellLinkA,
            pszDir: [*:0]u8,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWorkingDirectory: fn(
            self: *const IShellLinkA,
            pszDir: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetArguments: fn(
            self: *const IShellLinkA,
            pszArgs: [*:0]u8,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetArguments: fn(
            self: *const IShellLinkA,
            pszArgs: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHotkey: fn(
            self: *const IShellLinkA,
            pwHotkey: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHotkey: fn(
            self: *const IShellLinkA,
            wHotkey: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShowCmd: fn(
            self: *const IShellLinkA,
            piShowCmd: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShowCmd: fn(
            self: *const IShellLinkA,
            iShowCmd: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconLocation: fn(
            self: *const IShellLinkA,
            pszIconPath: [*:0]u8,
            cch: i32,
            piIcon: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconLocation: fn(
            self: *const IShellLinkA,
            pszIconPath: ?[*:0]const u8,
            iIcon: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRelativePath: fn(
            self: *const IShellLinkA,
            pszPathRel: ?[*:0]const u8,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resolve: fn(
            self: *const IShellLinkA,
            hwnd: ?HWND,
            fFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPath: fn(
            self: *const IShellLinkA,
            pszFile: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_GetPath(self: *const T, pszFile: [*:0]u8, cch: i32, pfd: ?*WIN32_FIND_DATAA, fFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).GetPath(@ptrCast(*const IShellLinkA, self), pszFile, cch, pfd, fFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_GetIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).GetIDList(@ptrCast(*const IShellLinkA, self), ppidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_SetIDList(self: *const T, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).SetIDList(@ptrCast(*const IShellLinkA, self), pidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_GetDescription(self: *const T, pszName: [*:0]u8, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).GetDescription(@ptrCast(*const IShellLinkA, self), pszName, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_SetDescription(self: *const T, pszName: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).SetDescription(@ptrCast(*const IShellLinkA, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_GetWorkingDirectory(self: *const T, pszDir: [*:0]u8, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).GetWorkingDirectory(@ptrCast(*const IShellLinkA, self), pszDir, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_SetWorkingDirectory(self: *const T, pszDir: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).SetWorkingDirectory(@ptrCast(*const IShellLinkA, self), pszDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_GetArguments(self: *const T, pszArgs: [*:0]u8, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).GetArguments(@ptrCast(*const IShellLinkA, self), pszArgs, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_SetArguments(self: *const T, pszArgs: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).SetArguments(@ptrCast(*const IShellLinkA, self), pszArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_GetHotkey(self: *const T, pwHotkey: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).GetHotkey(@ptrCast(*const IShellLinkA, self), pwHotkey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_SetHotkey(self: *const T, wHotkey: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).SetHotkey(@ptrCast(*const IShellLinkA, self), wHotkey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_GetShowCmd(self: *const T, piShowCmd: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).GetShowCmd(@ptrCast(*const IShellLinkA, self), piShowCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_SetShowCmd(self: *const T, iShowCmd: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).SetShowCmd(@ptrCast(*const IShellLinkA, self), iShowCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_GetIconLocation(self: *const T, pszIconPath: [*:0]u8, cch: i32, piIcon: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).GetIconLocation(@ptrCast(*const IShellLinkA, self), pszIconPath, cch, piIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_SetIconLocation(self: *const T, pszIconPath: ?[*:0]const u8, iIcon: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).SetIconLocation(@ptrCast(*const IShellLinkA, self), pszIconPath, iIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_SetRelativePath(self: *const T, pszPathRel: ?[*:0]const u8, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).SetRelativePath(@ptrCast(*const IShellLinkA, self), pszPathRel, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_Resolve(self: *const T, hwnd: ?HWND, fFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).Resolve(@ptrCast(*const IShellLinkA, self), hwnd, fFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkA_SetPath(self: *const T, pszFile: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkA.VTable, self.vtable).SetPath(@ptrCast(*const IShellLinkA, self), pszFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellLinkW_Value = @import("../zig.zig").Guid.initString("000214f9-0000-0000-c000-000000000046");
pub const IID_IShellLinkW = &IID_IShellLinkW_Value;
pub const IShellLinkW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPath: fn(
            self: *const IShellLinkW,
            pszFile: [*:0]u16,
            cch: i32,
            pfd: ?*WIN32_FIND_DATAW,
            fFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDList: fn(
            self: *const IShellLinkW,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIDList: fn(
            self: *const IShellLinkW,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IShellLinkW,
            pszName: [*:0]u16,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescription: fn(
            self: *const IShellLinkW,
            pszName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWorkingDirectory: fn(
            self: *const IShellLinkW,
            pszDir: [*:0]u16,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWorkingDirectory: fn(
            self: *const IShellLinkW,
            pszDir: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetArguments: fn(
            self: *const IShellLinkW,
            pszArgs: [*:0]u16,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetArguments: fn(
            self: *const IShellLinkW,
            pszArgs: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHotkey: fn(
            self: *const IShellLinkW,
            pwHotkey: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHotkey: fn(
            self: *const IShellLinkW,
            wHotkey: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShowCmd: fn(
            self: *const IShellLinkW,
            piShowCmd: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShowCmd: fn(
            self: *const IShellLinkW,
            iShowCmd: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconLocation: fn(
            self: *const IShellLinkW,
            pszIconPath: [*:0]u16,
            cch: i32,
            piIcon: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconLocation: fn(
            self: *const IShellLinkW,
            pszIconPath: ?[*:0]const u16,
            iIcon: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRelativePath: fn(
            self: *const IShellLinkW,
            pszPathRel: ?[*:0]const u16,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resolve: fn(
            self: *const IShellLinkW,
            hwnd: ?HWND,
            fFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPath: fn(
            self: *const IShellLinkW,
            pszFile: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_GetPath(self: *const T, pszFile: [*:0]u16, cch: i32, pfd: ?*WIN32_FIND_DATAW, fFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).GetPath(@ptrCast(*const IShellLinkW, self), pszFile, cch, pfd, fFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_GetIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).GetIDList(@ptrCast(*const IShellLinkW, self), ppidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_SetIDList(self: *const T, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).SetIDList(@ptrCast(*const IShellLinkW, self), pidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_GetDescription(self: *const T, pszName: [*:0]u16, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).GetDescription(@ptrCast(*const IShellLinkW, self), pszName, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_SetDescription(self: *const T, pszName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).SetDescription(@ptrCast(*const IShellLinkW, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_GetWorkingDirectory(self: *const T, pszDir: [*:0]u16, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).GetWorkingDirectory(@ptrCast(*const IShellLinkW, self), pszDir, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_SetWorkingDirectory(self: *const T, pszDir: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).SetWorkingDirectory(@ptrCast(*const IShellLinkW, self), pszDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_GetArguments(self: *const T, pszArgs: [*:0]u16, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).GetArguments(@ptrCast(*const IShellLinkW, self), pszArgs, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_SetArguments(self: *const T, pszArgs: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).SetArguments(@ptrCast(*const IShellLinkW, self), pszArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_GetHotkey(self: *const T, pwHotkey: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).GetHotkey(@ptrCast(*const IShellLinkW, self), pwHotkey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_SetHotkey(self: *const T, wHotkey: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).SetHotkey(@ptrCast(*const IShellLinkW, self), wHotkey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_GetShowCmd(self: *const T, piShowCmd: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).GetShowCmd(@ptrCast(*const IShellLinkW, self), piShowCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_SetShowCmd(self: *const T, iShowCmd: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).SetShowCmd(@ptrCast(*const IShellLinkW, self), iShowCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_GetIconLocation(self: *const T, pszIconPath: [*:0]u16, cch: i32, piIcon: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).GetIconLocation(@ptrCast(*const IShellLinkW, self), pszIconPath, cch, piIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_SetIconLocation(self: *const T, pszIconPath: ?[*:0]const u16, iIcon: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).SetIconLocation(@ptrCast(*const IShellLinkW, self), pszIconPath, iIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_SetRelativePath(self: *const T, pszPathRel: ?[*:0]const u16, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).SetRelativePath(@ptrCast(*const IShellLinkW, self), pszPathRel, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_Resolve(self: *const T, hwnd: ?HWND, fFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).Resolve(@ptrCast(*const IShellLinkW, self), hwnd, fFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkW_SetPath(self: *const T, pszFile: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkW.VTable, self.vtable).SetPath(@ptrCast(*const IShellLinkW, self), pszFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellLinkDataList_Value = @import("../zig.zig").Guid.initString("45e2b4ae-b1c3-11d0-b92f-00a0c90312e1");
pub const IID_IShellLinkDataList = &IID_IShellLinkDataList_Value;
pub const IShellLinkDataList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDataBlock: fn(
            self: *const IShellLinkDataList,
            pDataBlock: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyDataBlock: fn(
            self: *const IShellLinkDataList,
            dwSig: u32,
            ppDataBlock: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveDataBlock: fn(
            self: *const IShellLinkDataList,
            dwSig: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IShellLinkDataList,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IShellLinkDataList,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDataList_AddDataBlock(self: *const T, pDataBlock: ?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDataList.VTable, self.vtable).AddDataBlock(@ptrCast(*const IShellLinkDataList, self), pDataBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDataList_CopyDataBlock(self: *const T, dwSig: u32, ppDataBlock: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDataList.VTable, self.vtable).CopyDataBlock(@ptrCast(*const IShellLinkDataList, self), dwSig, ppDataBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDataList_RemoveDataBlock(self: *const T, dwSig: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDataList.VTable, self.vtable).RemoveDataBlock(@ptrCast(*const IShellLinkDataList, self), dwSig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDataList_GetFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDataList.VTable, self.vtable).GetFlags(@ptrCast(*const IShellLinkDataList, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDataList_SetFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDataList.VTable, self.vtable).SetFlags(@ptrCast(*const IShellLinkDataList, self), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IResolveShellLink_Value = @import("../zig.zig").Guid.initString("5cd52983-9449-11d2-963a-00c04f79adf0");
pub const IID_IResolveShellLink = &IID_IResolveShellLink_Value;
pub const IResolveShellLink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResolveShellLink: fn(
            self: *const IResolveShellLink,
            punkLink: ?*IUnknown,
            hwnd: ?HWND,
            fFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResolveShellLink_ResolveShellLink(self: *const T, punkLink: ?*IUnknown, hwnd: ?HWND, fFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResolveShellLink.VTable, self.vtable).ResolveShellLink(@ptrCast(*const IResolveShellLink, self), punkLink, hwnd, fFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _SPINITF = enum(i32) {
    NORMAL = 0,
    MODAL = 1,
    NOMINIMIZE = 8,
};
pub const SPINITF_NORMAL = _SPINITF.NORMAL;
pub const SPINITF_MODAL = _SPINITF.MODAL;
pub const SPINITF_NOMINIMIZE = _SPINITF.NOMINIMIZE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IActionProgressDialog_Value = @import("../zig.zig").Guid.initString("49ff1172-eadc-446d-9285-156453a6431c");
pub const IID_IActionProgressDialog = &IID_IActionProgressDialog_Value;
pub const IActionProgressDialog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IActionProgressDialog,
            flags: u32,
            pszTitle: ?[*:0]const u16,
            pszCancel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IActionProgressDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionProgressDialog_Initialize(self: *const T, flags: u32, pszTitle: ?[*:0]const u16, pszCancel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionProgressDialog.VTable, self.vtable).Initialize(@ptrCast(*const IActionProgressDialog, self), flags, pszTitle, pszCancel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionProgressDialog_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionProgressDialog.VTable, self.vtable).Stop(@ptrCast(*const IActionProgressDialog, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _SPBEGINF = enum(i32) {
    NORMAL = 0,
    AUTOTIME = 2,
    NOPROGRESSBAR = 16,
    MARQUEEPROGRESS = 32,
    NOCANCELBUTTON = 64,
};
pub const SPBEGINF_NORMAL = _SPBEGINF.NORMAL;
pub const SPBEGINF_AUTOTIME = _SPBEGINF.AUTOTIME;
pub const SPBEGINF_NOPROGRESSBAR = _SPBEGINF.NOPROGRESSBAR;
pub const SPBEGINF_MARQUEEPROGRESS = _SPBEGINF.MARQUEEPROGRESS;
pub const SPBEGINF_NOCANCELBUTTON = _SPBEGINF.NOCANCELBUTTON;

pub const SPACTION = enum(i32) {
    NONE = 0,
    MOVING = 1,
    COPYING = 2,
    RECYCLING = 3,
    APPLYINGATTRIBS = 4,
    DOWNLOADING = 5,
    SEARCHING_INTERNET = 6,
    CALCULATING = 7,
    UPLOADING = 8,
    SEARCHING_FILES = 9,
    DELETING = 10,
    RENAMING = 11,
    FORMATTING = 12,
    COPY_MOVING = 13,
};
pub const SPACTION_NONE = SPACTION.NONE;
pub const SPACTION_MOVING = SPACTION.MOVING;
pub const SPACTION_COPYING = SPACTION.COPYING;
pub const SPACTION_RECYCLING = SPACTION.RECYCLING;
pub const SPACTION_APPLYINGATTRIBS = SPACTION.APPLYINGATTRIBS;
pub const SPACTION_DOWNLOADING = SPACTION.DOWNLOADING;
pub const SPACTION_SEARCHING_INTERNET = SPACTION.SEARCHING_INTERNET;
pub const SPACTION_CALCULATING = SPACTION.CALCULATING;
pub const SPACTION_UPLOADING = SPACTION.UPLOADING;
pub const SPACTION_SEARCHING_FILES = SPACTION.SEARCHING_FILES;
pub const SPACTION_DELETING = SPACTION.DELETING;
pub const SPACTION_RENAMING = SPACTION.RENAMING;
pub const SPACTION_FORMATTING = SPACTION.FORMATTING;
pub const SPACTION_COPY_MOVING = SPACTION.COPY_MOVING;

pub const SPTEXT = enum(i32) {
    SCRIPTION = 1,
    TAIL = 2,
};
pub const SPTEXT_ACTIONDESCRIPTION = SPTEXT.SCRIPTION;
pub const SPTEXT_ACTIONDETAIL = SPTEXT.TAIL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IActionProgress_Value = @import("../zig.zig").Guid.initString("49ff1173-eadc-446d-9285-156453a6431c");
pub const IID_IActionProgress = &IID_IActionProgress_Value;
pub const IActionProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin: fn(
            self: *const IActionProgress,
            action: SPACTION,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateProgress: fn(
            self: *const IActionProgress,
            ulCompleted: u64,
            ulTotal: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateText: fn(
            self: *const IActionProgress,
            sptext: SPTEXT,
            pszText: ?[*:0]const u16,
            fMayCompact: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryCancel: fn(
            self: *const IActionProgress,
            pfCancelled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetCancel: fn(
            self: *const IActionProgress,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: fn(
            self: *const IActionProgress,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionProgress_Begin(self: *const T, action: SPACTION, flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionProgress.VTable, self.vtable).Begin(@ptrCast(*const IActionProgress, self), action, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionProgress_UpdateProgress(self: *const T, ulCompleted: u64, ulTotal: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionProgress.VTable, self.vtable).UpdateProgress(@ptrCast(*const IActionProgress, self), ulCompleted, ulTotal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionProgress_UpdateText(self: *const T, sptext: SPTEXT, pszText: ?[*:0]const u16, fMayCompact: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionProgress.VTable, self.vtable).UpdateText(@ptrCast(*const IActionProgress, self), sptext, pszText, fMayCompact);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionProgress_QueryCancel(self: *const T, pfCancelled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionProgress.VTable, self.vtable).QueryCancel(@ptrCast(*const IActionProgress, self), pfCancelled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionProgress_ResetCancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionProgress.VTable, self.vtable).ResetCancel(@ptrCast(*const IActionProgress, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionProgress_End(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActionProgress.VTable, self.vtable).End(@ptrCast(*const IActionProgress, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellExtInit_Value = @import("../zig.zig").Guid.initString("000214e8-0000-0000-c000-000000000046");
pub const IID_IShellExtInit = &IID_IShellExtInit_Value;
pub const IShellExtInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IShellExtInit,
            pidlFolder: ?*ITEMIDLIST,
            pdtobj: ?*IDataObject,
            hkeyProgID: ?HKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellExtInit_Initialize(self: *const T, pidlFolder: ?*ITEMIDLIST, pdtobj: ?*IDataObject, hkeyProgID: ?HKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellExtInit.VTable, self.vtable).Initialize(@ptrCast(*const IShellExtInit, self), pidlFolder, pdtobj, hkeyProgID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _EXPPS = enum(i32) {
    S = 1,
};
pub const EXPPS_FILETYPES = _EXPPS.S;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellPropSheetExt_Value = @import("../zig.zig").Guid.initString("000214e9-0000-0000-c000-000000000046");
pub const IID_IShellPropSheetExt = &IID_IShellPropSheetExt_Value;
pub const IShellPropSheetExt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPages: fn(
            self: *const IShellPropSheetExt,
            pfnAddPage: ?LPFNSVADDPROPSHEETPAGE,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplacePage: fn(
            self: *const IShellPropSheetExt,
            uPageID: u32,
            pfnReplaceWith: ?LPFNSVADDPROPSHEETPAGE,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellPropSheetExt_AddPages(self: *const T, pfnAddPage: ?LPFNSVADDPROPSHEETPAGE, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellPropSheetExt.VTable, self.vtable).AddPages(@ptrCast(*const IShellPropSheetExt, self), pfnAddPage, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellPropSheetExt_ReplacePage(self: *const T, uPageID: u32, pfnReplaceWith: ?LPFNSVADDPROPSHEETPAGE, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellPropSheetExt.VTable, self.vtable).ReplacePage(@ptrCast(*const IShellPropSheetExt, self), uPageID, pfnReplaceWith, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRemoteComputer_Value = @import("../zig.zig").Guid.initString("000214fe-0000-0000-c000-000000000046");
pub const IID_IRemoteComputer = &IID_IRemoteComputer_Value;
pub const IRemoteComputer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IRemoteComputer,
            pszMachine: ?[*:0]const u16,
            bEnumerating: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteComputer_Initialize(self: *const T, pszMachine: ?[*:0]const u16, bEnumerating: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteComputer.VTable, self.vtable).Initialize(@ptrCast(*const IRemoteComputer, self), pszMachine, bEnumerating);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryContinue_Value = @import("../zig.zig").Guid.initString("7307055c-b24a-486b-9f25-163e597a28a9");
pub const IID_IQueryContinue = &IID_IQueryContinue_Value;
pub const IQueryContinue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContinue: fn(
            self: *const IQueryContinue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryContinue_QueryContinue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryContinue.VTable, self.vtable).QueryContinue(@ptrCast(*const IQueryContinue, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithCancelEvent_Value = @import("../zig.zig").Guid.initString("f279b885-0ae9-4b85-ac06-ddecf9408941");
pub const IID_IObjectWithCancelEvent = &IID_IObjectWithCancelEvent_Value;
pub const IObjectWithCancelEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCancelEvent: fn(
            self: *const IObjectWithCancelEvent,
            phEvent: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithCancelEvent_GetCancelEvent(self: *const T, phEvent: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithCancelEvent.VTable, self.vtable).GetCancelEvent(@ptrCast(*const IObjectWithCancelEvent, self), phEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IUserNotification_Value = @import("../zig.zig").Guid.initString("ba9711ba-5893-4787-a7e1-41277151550b");
pub const IID_IUserNotification = &IID_IUserNotification_Value;
pub const IUserNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBalloonInfo: fn(
            self: *const IUserNotification,
            pszTitle: ?[*:0]const u16,
            pszText: ?[*:0]const u16,
            dwInfoFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBalloonRetry: fn(
            self: *const IUserNotification,
            dwShowTime: u32,
            dwInterval: u32,
            cRetryCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconInfo: fn(
            self: *const IUserNotification,
            hIcon: ?HICON,
            pszToolTip: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const IUserNotification,
            pqc: ?*IQueryContinue,
            dwContinuePollInterval: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlaySound: fn(
            self: *const IUserNotification,
            pszSoundName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification_SetBalloonInfo(self: *const T, pszTitle: ?[*:0]const u16, pszText: ?[*:0]const u16, dwInfoFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification.VTable, self.vtable).SetBalloonInfo(@ptrCast(*const IUserNotification, self), pszTitle, pszText, dwInfoFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification_SetBalloonRetry(self: *const T, dwShowTime: u32, dwInterval: u32, cRetryCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification.VTable, self.vtable).SetBalloonRetry(@ptrCast(*const IUserNotification, self), dwShowTime, dwInterval, cRetryCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification_SetIconInfo(self: *const T, hIcon: ?HICON, pszToolTip: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification.VTable, self.vtable).SetIconInfo(@ptrCast(*const IUserNotification, self), hIcon, pszToolTip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification_Show(self: *const T, pqc: ?*IQueryContinue, dwContinuePollInterval: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification.VTable, self.vtable).Show(@ptrCast(*const IUserNotification, self), pqc, dwContinuePollInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification_PlaySound(self: *const T, pszSoundName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification.VTable, self.vtable).PlaySound(@ptrCast(*const IUserNotification, self), pszSoundName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IItemNameLimits_Value = @import("../zig.zig").Guid.initString("1df0d7f1-b267-4d28-8b10-12e23202a5c4");
pub const IID_IItemNameLimits = &IID_IItemNameLimits_Value;
pub const IItemNameLimits = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValidCharacters: fn(
            self: *const IItemNameLimits,
            ppwszValidChars: ?*?PWSTR,
            ppwszInvalidChars: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxLength: fn(
            self: *const IItemNameLimits,
            pszName: ?[*:0]const u16,
            piMaxNameLen: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IItemNameLimits_GetValidCharacters(self: *const T, ppwszValidChars: ?*?PWSTR, ppwszInvalidChars: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IItemNameLimits.VTable, self.vtable).GetValidCharacters(@ptrCast(*const IItemNameLimits, self), ppwszValidChars, ppwszInvalidChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IItemNameLimits_GetMaxLength(self: *const T, pszName: ?[*:0]const u16, piMaxNameLen: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IItemNameLimits.VTable, self.vtable).GetMaxLength(@ptrCast(*const IItemNameLimits, self), pszName, piMaxNameLen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISearchFolderItemFactory_Value = @import("../zig.zig").Guid.initString("a0ffbc28-5482-4366-be27-3e81e78e06c2");
pub const IID_ISearchFolderItemFactory = &IID_ISearchFolderItemFactory_Value;
pub const ISearchFolderItemFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDisplayName: fn(
            self: *const ISearchFolderItemFactory,
            pszDisplayName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFolderTypeID: fn(
            self: *const ISearchFolderItemFactory,
            ftid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFolderLogicalViewMode: fn(
            self: *const ISearchFolderItemFactory,
            flvm: FOLDERLOGICALVIEWMODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconSize: fn(
            self: *const ISearchFolderItemFactory,
            iIconSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVisibleColumns: fn(
            self: *const ISearchFolderItemFactory,
            cVisibleColumns: u32,
            rgKey: [*]const PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSortColumns: fn(
            self: *const ISearchFolderItemFactory,
            cSortColumns: u32,
            rgSortColumns: [*]SORTCOLUMN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGroupColumn: fn(
            self: *const ISearchFolderItemFactory,
            keyGroup: ?*const PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStacks: fn(
            self: *const ISearchFolderItemFactory,
            cStackKeys: u32,
            rgStackKeys: [*]PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScope: fn(
            self: *const ISearchFolderItemFactory,
            psiaScope: ?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCondition: fn(
            self: *const ISearchFolderItemFactory,
            pCondition: ?*ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShellItem: fn(
            self: *const ISearchFolderItemFactory,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDList: fn(
            self: *const ISearchFolderItemFactory,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetDisplayName(self: *const T, pszDisplayName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetDisplayName(@ptrCast(*const ISearchFolderItemFactory, self), pszDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetFolderTypeID(self: *const T, ftid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetFolderTypeID(@ptrCast(*const ISearchFolderItemFactory, self), ftid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetFolderLogicalViewMode(self: *const T, flvm: FOLDERLOGICALVIEWMODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetFolderLogicalViewMode(@ptrCast(*const ISearchFolderItemFactory, self), flvm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetIconSize(self: *const T, iIconSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetIconSize(@ptrCast(*const ISearchFolderItemFactory, self), iIconSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetVisibleColumns(self: *const T, cVisibleColumns: u32, rgKey: [*]const PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetVisibleColumns(@ptrCast(*const ISearchFolderItemFactory, self), cVisibleColumns, rgKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetSortColumns(self: *const T, cSortColumns: u32, rgSortColumns: [*]SORTCOLUMN) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetSortColumns(@ptrCast(*const ISearchFolderItemFactory, self), cSortColumns, rgSortColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetGroupColumn(self: *const T, keyGroup: ?*const PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetGroupColumn(@ptrCast(*const ISearchFolderItemFactory, self), keyGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetStacks(self: *const T, cStackKeys: u32, rgStackKeys: [*]PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetStacks(@ptrCast(*const ISearchFolderItemFactory, self), cStackKeys, rgStackKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetScope(self: *const T, psiaScope: ?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetScope(@ptrCast(*const ISearchFolderItemFactory, self), psiaScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_SetCondition(self: *const T, pCondition: ?*ICondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).SetCondition(@ptrCast(*const ISearchFolderItemFactory, self), pCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_GetShellItem(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).GetShellItem(@ptrCast(*const ISearchFolderItemFactory, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchFolderItemFactory_GetIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchFolderItemFactory.VTable, self.vtable).GetIDList(@ptrCast(*const ISearchFolderItemFactory, self), ppidl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IExtractImage_Value = @import("../zig.zig").Guid.initString("bb2e617c-0920-11d1-9a0b-00c04fc2d6c1");
pub const IID_IExtractImage = &IID_IExtractImage_Value;
pub const IExtractImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLocation: fn(
            self: *const IExtractImage,
            pszPathBuffer: [*:0]u16,
            cch: u32,
            pdwPriority: ?*u32,
            prgSize: ?*const SIZE,
            dwRecClrDepth: u32,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Extract: fn(
            self: *const IExtractImage,
            phBmpThumbnail: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtractImage_GetLocation(self: *const T, pszPathBuffer: [*:0]u16, cch: u32, pdwPriority: ?*u32, prgSize: ?*const SIZE, dwRecClrDepth: u32, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtractImage.VTable, self.vtable).GetLocation(@ptrCast(*const IExtractImage, self), pszPathBuffer, cch, pdwPriority, prgSize, dwRecClrDepth, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtractImage_Extract(self: *const T, phBmpThumbnail: ?*?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtractImage.VTable, self.vtable).Extract(@ptrCast(*const IExtractImage, self), phBmpThumbnail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IExtractImage2_Value = @import("../zig.zig").Guid.initString("953bb1ee-93b4-11d1-98a3-00c04fb687da");
pub const IID_IExtractImage2 = &IID_IExtractImage2_Value;
pub const IExtractImage2 = extern struct {
    pub const VTable = extern struct {
        base: IExtractImage.VTable,
        GetDateStamp: fn(
            self: *const IExtractImage2,
            pDateStamp: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IExtractImage.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtractImage2_GetDateStamp(self: *const T, pDateStamp: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtractImage2.VTable, self.vtable).GetDateStamp(@ptrCast(*const IExtractImage2, self), pDateStamp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IThumbnailHandlerFactory_Value = @import("../zig.zig").Guid.initString("e35b4b2e-00da-4bc1-9f13-38bc11f5d417");
pub const IID_IThumbnailHandlerFactory = &IID_IThumbnailHandlerFactory_Value;
pub const IThumbnailHandlerFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThumbnailHandler: fn(
            self: *const IThumbnailHandlerFactory,
            pidlChild: ?*ITEMIDLIST,
            pbc: ?*IBindCtx,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailHandlerFactory_GetThumbnailHandler(self: *const T, pidlChild: ?*ITEMIDLIST, pbc: ?*IBindCtx, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailHandlerFactory.VTable, self.vtable).GetThumbnailHandler(@ptrCast(*const IThumbnailHandlerFactory, self), pidlChild, pbc, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IParentAndItem_Value = @import("../zig.zig").Guid.initString("b3a4b685-b685-4805-99d9-5dead2873236");
pub const IID_IParentAndItem = &IID_IParentAndItem_Value;
pub const IParentAndItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetParentAndItem: fn(
            self: *const IParentAndItem,
            pidlParent: ?*ITEMIDLIST,
            psf: ?*IShellFolder,
            pidlChild: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentAndItem: fn(
            self: *const IParentAndItem,
            ppidlParent: ?*?*ITEMIDLIST,
            ppsf: ?*?*IShellFolder,
            ppidlChild: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IParentAndItem_SetParentAndItem(self: *const T, pidlParent: ?*ITEMIDLIST, psf: ?*IShellFolder, pidlChild: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IParentAndItem.VTable, self.vtable).SetParentAndItem(@ptrCast(*const IParentAndItem, self), pidlParent, psf, pidlChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IParentAndItem_GetParentAndItem(self: *const T, ppidlParent: ?*?*ITEMIDLIST, ppsf: ?*?*IShellFolder, ppidlChild: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IParentAndItem.VTable, self.vtable).GetParentAndItem(@ptrCast(*const IParentAndItem, self), ppidlParent, ppsf, ppidlChild);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDockingWindow_Value = @import("../zig.zig").Guid.initString("012dd920-7b26-11d0-8ca9-00a0c92dbfe8");
pub const IID_IDockingWindow = &IID_IDockingWindow_Value;
pub const IDockingWindow = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        ShowDW: fn(
            self: *const IDockingWindow,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDW: fn(
            self: *const IDockingWindow,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResizeBorderDW: fn(
            self: *const IDockingWindow,
            prcBorder: ?*RECT,
            punkToolbarSite: ?*IUnknown,
            fReserved: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockingWindow_ShowDW(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockingWindow.VTable, self.vtable).ShowDW(@ptrCast(*const IDockingWindow, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockingWindow_CloseDW(self: *const T, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockingWindow.VTable, self.vtable).CloseDW(@ptrCast(*const IDockingWindow, self), dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockingWindow_ResizeBorderDW(self: *const T, prcBorder: ?*RECT, punkToolbarSite: ?*IUnknown, fReserved: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockingWindow.VTable, self.vtable).ResizeBorderDW(@ptrCast(*const IDockingWindow, self), prcBorder, punkToolbarSite, fReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DESKBANDINFO = extern struct {
    dwMask: u32,
    ptMinSize: POINTL,
    ptMaxSize: POINTL,
    ptIntegral: POINTL,
    ptActual: POINTL,
    wszTitle: [256]u16,
    dwModeFlags: u32,
    crBkgnd: u32,
};

pub const DESKBANDCID = enum(i32) {
    BANDINFOCHANGED = 0,
    SHOWONLY = 1,
    MAXIMIZEBAND = 2,
    PUSHCHEVRON = 3,
    DELAYINIT = 4,
    FINISHINIT = 5,
    SETWINDOWTHEME = 6,
    PERMITAUTOHIDE = 7,
};
pub const DBID_BANDINFOCHANGED = DESKBANDCID.BANDINFOCHANGED;
pub const DBID_SHOWONLY = DESKBANDCID.SHOWONLY;
pub const DBID_MAXIMIZEBAND = DESKBANDCID.MAXIMIZEBAND;
pub const DBID_PUSHCHEVRON = DESKBANDCID.PUSHCHEVRON;
pub const DBID_DELAYINIT = DESKBANDCID.DELAYINIT;
pub const DBID_FINISHINIT = DESKBANDCID.FINISHINIT;
pub const DBID_SETWINDOWTHEME = DESKBANDCID.SETWINDOWTHEME;
pub const DBID_PERMITAUTOHIDE = DESKBANDCID.PERMITAUTOHIDE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDeskBand_Value = @import("../zig.zig").Guid.initString("eb0fe172-1a3a-11d0-89b3-00a0c90a90ac");
pub const IID_IDeskBand = &IID_IDeskBand_Value;
pub const IDeskBand = extern struct {
    pub const VTable = extern struct {
        base: IDockingWindow.VTable,
        GetBandInfo: fn(
            self: *const IDeskBand,
            dwBandID: u32,
            dwViewMode: u32,
            pdbi: ?*DESKBANDINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDockingWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBand_GetBandInfo(self: *const T, dwBandID: u32, dwViewMode: u32, pdbi: ?*DESKBANDINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBand.VTable, self.vtable).GetBandInfo(@ptrCast(*const IDeskBand, self), dwBandID, dwViewMode, pdbi);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeskBandInfo_Value = @import("../zig.zig").Guid.initString("77e425fc-cbf9-4307-ba6a-bb5727745661");
pub const IID_IDeskBandInfo = &IID_IDeskBandInfo_Value;
pub const IDeskBandInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDefaultBandWidth: fn(
            self: *const IDeskBandInfo,
            dwBandID: u32,
            dwViewMode: u32,
            pnWidth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBandInfo_GetDefaultBandWidth(self: *const T, dwBandID: u32, dwViewMode: u32, pnWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBandInfo.VTable, self.vtable).GetDefaultBandWidth(@ptrCast(*const IDeskBandInfo, self), dwBandID, dwViewMode, pnWidth);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ITaskbarList_Value = @import("../zig.zig").Guid.initString("56fdf342-fd6d-11d0-958a-006097c9a090");
pub const IID_ITaskbarList = &IID_ITaskbarList_Value;
pub const ITaskbarList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HrInit: fn(
            self: *const ITaskbarList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTab: fn(
            self: *const ITaskbarList,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTab: fn(
            self: *const ITaskbarList,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateTab: fn(
            self: *const ITaskbarList,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveAlt: fn(
            self: *const ITaskbarList,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList_HrInit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList.VTable, self.vtable).HrInit(@ptrCast(*const ITaskbarList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList_AddTab(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList.VTable, self.vtable).AddTab(@ptrCast(*const ITaskbarList, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList_DeleteTab(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList.VTable, self.vtable).DeleteTab(@ptrCast(*const ITaskbarList, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList_ActivateTab(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList.VTable, self.vtable).ActivateTab(@ptrCast(*const ITaskbarList, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList_SetActiveAlt(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList.VTable, self.vtable).SetActiveAlt(@ptrCast(*const ITaskbarList, self), hwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITaskbarList2_Value = @import("../zig.zig").Guid.initString("602d4995-b13a-429b-a66e-1935e44f4317");
pub const IID_ITaskbarList2 = &IID_ITaskbarList2_Value;
pub const ITaskbarList2 = extern struct {
    pub const VTable = extern struct {
        base: ITaskbarList.VTable,
        MarkFullscreenWindow: fn(
            self: *const ITaskbarList2,
            hwnd: ?HWND,
            fFullscreen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITaskbarList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList2_MarkFullscreenWindow(self: *const T, hwnd: ?HWND, fFullscreen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList2.VTable, self.vtable).MarkFullscreenWindow(@ptrCast(*const ITaskbarList2, self), hwnd, fFullscreen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const THUMBBUTTONFLAGS = enum(i32) {
    ENABLED = 0,
    DISABLED = 1,
    DISMISSONCLICK = 2,
    NOBACKGROUND = 4,
    HIDDEN = 8,
    NONINTERACTIVE = 16,
};
pub const THBF_ENABLED = THUMBBUTTONFLAGS.ENABLED;
pub const THBF_DISABLED = THUMBBUTTONFLAGS.DISABLED;
pub const THBF_DISMISSONCLICK = THUMBBUTTONFLAGS.DISMISSONCLICK;
pub const THBF_NOBACKGROUND = THUMBBUTTONFLAGS.NOBACKGROUND;
pub const THBF_HIDDEN = THUMBBUTTONFLAGS.HIDDEN;
pub const THBF_NONINTERACTIVE = THUMBBUTTONFLAGS.NONINTERACTIVE;

pub const THUMBBUTTONMASK = enum(i32) {
    BITMAP = 1,
    ICON = 2,
    TOOLTIP = 4,
    FLAGS = 8,
};
pub const THB_BITMAP = THUMBBUTTONMASK.BITMAP;
pub const THB_ICON = THUMBBUTTONMASK.ICON;
pub const THB_TOOLTIP = THUMBBUTTONMASK.TOOLTIP;
pub const THB_FLAGS = THUMBBUTTONMASK.FLAGS;

pub const THUMBBUTTON = extern struct {
    dwMask: THUMBBUTTONMASK,
    iId: u32,
    iBitmap: u32,
    hIcon: ?HICON,
    szTip: [260]u16,
    dwFlags: THUMBBUTTONFLAGS,
};

pub const TBPFLAG = enum(i32) {
    NOPROGRESS = 0,
    INDETERMINATE = 1,
    NORMAL = 2,
    ERROR = 4,
    PAUSED = 8,
};
pub const TBPF_NOPROGRESS = TBPFLAG.NOPROGRESS;
pub const TBPF_INDETERMINATE = TBPFLAG.INDETERMINATE;
pub const TBPF_NORMAL = TBPFLAG.NORMAL;
pub const TBPF_ERROR = TBPFLAG.ERROR;
pub const TBPF_PAUSED = TBPFLAG.PAUSED;

// TODO: this type is limited to platform 'windows6.1'
const IID_ITaskbarList3_Value = @import("../zig.zig").Guid.initString("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf");
pub const IID_ITaskbarList3 = &IID_ITaskbarList3_Value;
pub const ITaskbarList3 = extern struct {
    pub const VTable = extern struct {
        base: ITaskbarList2.VTable,
        SetProgressValue: fn(
            self: *const ITaskbarList3,
            hwnd: ?HWND,
            ullCompleted: u64,
            ullTotal: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProgressState: fn(
            self: *const ITaskbarList3,
            hwnd: ?HWND,
            tbpFlags: TBPFLAG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterTab: fn(
            self: *const ITaskbarList3,
            hwndTab: ?HWND,
            hwndMDI: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterTab: fn(
            self: *const ITaskbarList3,
            hwndTab: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTabOrder: fn(
            self: *const ITaskbarList3,
            hwndTab: ?HWND,
            hwndInsertBefore: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTabActive: fn(
            self: *const ITaskbarList3,
            hwndTab: ?HWND,
            hwndMDI: ?HWND,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ThumbBarAddButtons: fn(
            self: *const ITaskbarList3,
            hwnd: ?HWND,
            cButtons: u32,
            pButton: [*]THUMBBUTTON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ThumbBarUpdateButtons: fn(
            self: *const ITaskbarList3,
            hwnd: ?HWND,
            cButtons: u32,
            pButton: [*]THUMBBUTTON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ThumbBarSetImageList: fn(
            self: *const ITaskbarList3,
            hwnd: ?HWND,
            himl: ?HIMAGELIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlayIcon: fn(
            self: *const ITaskbarList3,
            hwnd: ?HWND,
            hIcon: ?HICON,
            pszDescription: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetThumbnailTooltip: fn(
            self: *const ITaskbarList3,
            hwnd: ?HWND,
            pszTip: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetThumbnailClip: fn(
            self: *const ITaskbarList3,
            hwnd: ?HWND,
            prcClip: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITaskbarList2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_SetProgressValue(self: *const T, hwnd: ?HWND, ullCompleted: u64, ullTotal: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).SetProgressValue(@ptrCast(*const ITaskbarList3, self), hwnd, ullCompleted, ullTotal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_SetProgressState(self: *const T, hwnd: ?HWND, tbpFlags: TBPFLAG) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).SetProgressState(@ptrCast(*const ITaskbarList3, self), hwnd, tbpFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_RegisterTab(self: *const T, hwndTab: ?HWND, hwndMDI: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).RegisterTab(@ptrCast(*const ITaskbarList3, self), hwndTab, hwndMDI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_UnregisterTab(self: *const T, hwndTab: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).UnregisterTab(@ptrCast(*const ITaskbarList3, self), hwndTab);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_SetTabOrder(self: *const T, hwndTab: ?HWND, hwndInsertBefore: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).SetTabOrder(@ptrCast(*const ITaskbarList3, self), hwndTab, hwndInsertBefore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_SetTabActive(self: *const T, hwndTab: ?HWND, hwndMDI: ?HWND, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).SetTabActive(@ptrCast(*const ITaskbarList3, self), hwndTab, hwndMDI, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_ThumbBarAddButtons(self: *const T, hwnd: ?HWND, cButtons: u32, pButton: [*]THUMBBUTTON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).ThumbBarAddButtons(@ptrCast(*const ITaskbarList3, self), hwnd, cButtons, pButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_ThumbBarUpdateButtons(self: *const T, hwnd: ?HWND, cButtons: u32, pButton: [*]THUMBBUTTON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).ThumbBarUpdateButtons(@ptrCast(*const ITaskbarList3, self), hwnd, cButtons, pButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_ThumbBarSetImageList(self: *const T, hwnd: ?HWND, himl: ?HIMAGELIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).ThumbBarSetImageList(@ptrCast(*const ITaskbarList3, self), hwnd, himl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_SetOverlayIcon(self: *const T, hwnd: ?HWND, hIcon: ?HICON, pszDescription: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).SetOverlayIcon(@ptrCast(*const ITaskbarList3, self), hwnd, hIcon, pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_SetThumbnailTooltip(self: *const T, hwnd: ?HWND, pszTip: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).SetThumbnailTooltip(@ptrCast(*const ITaskbarList3, self), hwnd, pszTip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList3_SetThumbnailClip(self: *const T, hwnd: ?HWND, prcClip: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList3.VTable, self.vtable).SetThumbnailClip(@ptrCast(*const ITaskbarList3, self), hwnd, prcClip);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STPFLAG = enum(i32) {
    NONE = 0,
    USEAPPTHUMBNAILALWAYS = 1,
    USEAPPTHUMBNAILWHENACTIVE = 2,
    USEAPPPEEKALWAYS = 4,
    USEAPPPEEKWHENACTIVE = 8,
};
pub const STPF_NONE = STPFLAG.NONE;
pub const STPF_USEAPPTHUMBNAILALWAYS = STPFLAG.USEAPPTHUMBNAILALWAYS;
pub const STPF_USEAPPTHUMBNAILWHENACTIVE = STPFLAG.USEAPPTHUMBNAILWHENACTIVE;
pub const STPF_USEAPPPEEKALWAYS = STPFLAG.USEAPPPEEKALWAYS;
pub const STPF_USEAPPPEEKWHENACTIVE = STPFLAG.USEAPPPEEKWHENACTIVE;

// TODO: this type is limited to platform 'windows6.1'
const IID_ITaskbarList4_Value = @import("../zig.zig").Guid.initString("c43dc798-95d1-4bea-9030-bb99e2983a1a");
pub const IID_ITaskbarList4 = &IID_ITaskbarList4_Value;
pub const ITaskbarList4 = extern struct {
    pub const VTable = extern struct {
        base: ITaskbarList3.VTable,
        SetTabProperties: fn(
            self: *const ITaskbarList4,
            hwndTab: ?HWND,
            stpFlags: STPFLAG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITaskbarList3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITaskbarList4_SetTabProperties(self: *const T, hwndTab: ?HWND, stpFlags: STPFLAG) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITaskbarList4.VTable, self.vtable).SetTabProperties(@ptrCast(*const ITaskbarList4, self), hwndTab, stpFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerBrowserEvents_Value = @import("../zig.zig").Guid.initString("361bbdc7-e6ee-4e13-be58-58e2240c810f");
pub const IID_IExplorerBrowserEvents = &IID_IExplorerBrowserEvents_Value;
pub const IExplorerBrowserEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNavigationPending: fn(
            self: *const IExplorerBrowserEvents,
            pidlFolder: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnViewCreated: fn(
            self: *const IExplorerBrowserEvents,
            psv: ?*IShellView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnNavigationComplete: fn(
            self: *const IExplorerBrowserEvents,
            pidlFolder: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnNavigationFailed: fn(
            self: *const IExplorerBrowserEvents,
            pidlFolder: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowserEvents_OnNavigationPending(self: *const T, pidlFolder: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowserEvents.VTable, self.vtable).OnNavigationPending(@ptrCast(*const IExplorerBrowserEvents, self), pidlFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowserEvents_OnViewCreated(self: *const T, psv: ?*IShellView) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowserEvents.VTable, self.vtable).OnViewCreated(@ptrCast(*const IExplorerBrowserEvents, self), psv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowserEvents_OnNavigationComplete(self: *const T, pidlFolder: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowserEvents.VTable, self.vtable).OnNavigationComplete(@ptrCast(*const IExplorerBrowserEvents, self), pidlFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowserEvents_OnNavigationFailed(self: *const T, pidlFolder: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowserEvents.VTable, self.vtable).OnNavigationFailed(@ptrCast(*const IExplorerBrowserEvents, self), pidlFolder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EXPLORER_BROWSER_OPTIONS = enum(i32) {
    NONE = 0,
    NAVIGATEONCE = 1,
    SHOWFRAMES = 2,
    ALWAYSNAVIGATE = 4,
    NOTRAVELLOG = 8,
    NOWRAPPERWINDOW = 16,
    HTMLSHAREPOINTVIEW = 32,
    NOBORDER = 64,
    NOPERSISTVIEWSTATE = 128,
};
pub const EBO_NONE = EXPLORER_BROWSER_OPTIONS.NONE;
pub const EBO_NAVIGATEONCE = EXPLORER_BROWSER_OPTIONS.NAVIGATEONCE;
pub const EBO_SHOWFRAMES = EXPLORER_BROWSER_OPTIONS.SHOWFRAMES;
pub const EBO_ALWAYSNAVIGATE = EXPLORER_BROWSER_OPTIONS.ALWAYSNAVIGATE;
pub const EBO_NOTRAVELLOG = EXPLORER_BROWSER_OPTIONS.NOTRAVELLOG;
pub const EBO_NOWRAPPERWINDOW = EXPLORER_BROWSER_OPTIONS.NOWRAPPERWINDOW;
pub const EBO_HTMLSHAREPOINTVIEW = EXPLORER_BROWSER_OPTIONS.HTMLSHAREPOINTVIEW;
pub const EBO_NOBORDER = EXPLORER_BROWSER_OPTIONS.NOBORDER;
pub const EBO_NOPERSISTVIEWSTATE = EXPLORER_BROWSER_OPTIONS.NOPERSISTVIEWSTATE;

pub const EXPLORER_BROWSER_FILL_FLAGS = enum(i32) {
    NONE = 0,
    SELECTFROMDATAOBJECT = 256,
    NODROPTARGET = 512,
};
pub const EBF_NONE = EXPLORER_BROWSER_FILL_FLAGS.NONE;
pub const EBF_SELECTFROMDATAOBJECT = EXPLORER_BROWSER_FILL_FLAGS.SELECTFROMDATAOBJECT;
pub const EBF_NODROPTARGET = EXPLORER_BROWSER_FILL_FLAGS.NODROPTARGET;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerBrowser_Value = @import("../zig.zig").Guid.initString("dfd3b6b5-c10c-4be9-85f6-a66969f402f6");
pub const IID_IExplorerBrowser = &IID_IExplorerBrowser_Value;
pub const IExplorerBrowser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IExplorerBrowser,
            hwndParent: ?HWND,
            prc: ?*const RECT,
            pfs: ?*const FOLDERSETTINGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Destroy: fn(
            self: *const IExplorerBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRect: fn(
            self: *const IExplorerBrowser,
            phdwp: ?*isize,
            rcBrowser: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPropertyBag: fn(
            self: *const IExplorerBrowser,
            pszPropertyBag: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEmptyText: fn(
            self: *const IExplorerBrowser,
            pszEmptyText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFolderSettings: fn(
            self: *const IExplorerBrowser,
            pfs: ?*const FOLDERSETTINGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IExplorerBrowser,
            psbe: ?*IExplorerBrowserEvents,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IExplorerBrowser,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOptions: fn(
            self: *const IExplorerBrowser,
            dwFlag: EXPLORER_BROWSER_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptions: fn(
            self: *const IExplorerBrowser,
            pdwFlag: ?*EXPLORER_BROWSER_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BrowseToIDList: fn(
            self: *const IExplorerBrowser,
            pidl: ?*ITEMIDLIST,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BrowseToObject: fn(
            self: *const IExplorerBrowser,
            punk: ?*IUnknown,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillFromObject: fn(
            self: *const IExplorerBrowser,
            punk: ?*IUnknown,
            dwFlags: EXPLORER_BROWSER_FILL_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAll: fn(
            self: *const IExplorerBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentView: fn(
            self: *const IExplorerBrowser,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_Initialize(self: *const T, hwndParent: ?HWND, prc: ?*const RECT, pfs: ?*const FOLDERSETTINGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).Initialize(@ptrCast(*const IExplorerBrowser, self), hwndParent, prc, pfs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_Destroy(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).Destroy(@ptrCast(*const IExplorerBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_SetRect(self: *const T, phdwp: ?*isize, rcBrowser: RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).SetRect(@ptrCast(*const IExplorerBrowser, self), phdwp, rcBrowser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_SetPropertyBag(self: *const T, pszPropertyBag: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).SetPropertyBag(@ptrCast(*const IExplorerBrowser, self), pszPropertyBag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_SetEmptyText(self: *const T, pszEmptyText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).SetEmptyText(@ptrCast(*const IExplorerBrowser, self), pszEmptyText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_SetFolderSettings(self: *const T, pfs: ?*const FOLDERSETTINGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).SetFolderSettings(@ptrCast(*const IExplorerBrowser, self), pfs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_Advise(self: *const T, psbe: ?*IExplorerBrowserEvents, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).Advise(@ptrCast(*const IExplorerBrowser, self), psbe, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).Unadvise(@ptrCast(*const IExplorerBrowser, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_SetOptions(self: *const T, dwFlag: EXPLORER_BROWSER_OPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).SetOptions(@ptrCast(*const IExplorerBrowser, self), dwFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_GetOptions(self: *const T, pdwFlag: ?*EXPLORER_BROWSER_OPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).GetOptions(@ptrCast(*const IExplorerBrowser, self), pdwFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_BrowseToIDList(self: *const T, pidl: ?*ITEMIDLIST, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).BrowseToIDList(@ptrCast(*const IExplorerBrowser, self), pidl, uFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_BrowseToObject(self: *const T, punk: ?*IUnknown, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).BrowseToObject(@ptrCast(*const IExplorerBrowser, self), punk, uFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_FillFromObject(self: *const T, punk: ?*IUnknown, dwFlags: EXPLORER_BROWSER_FILL_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).FillFromObject(@ptrCast(*const IExplorerBrowser, self), punk, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_RemoveAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).RemoveAll(@ptrCast(*const IExplorerBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerBrowser_GetCurrentView(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerBrowser.VTable, self.vtable).GetCurrentView(@ptrCast(*const IExplorerBrowser, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumObjects_Value = @import("../zig.zig").Guid.initString("2c1c7e2e-2d0e-4059-831e-1e6f82335c2e");
pub const IID_IEnumObjects = &IID_IEnumObjects_Value;
pub const IEnumObjects = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumObjects,
            celt: u32,
            riid: ?*const Guid,
            rgelt: [*]?*anyopaque,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumObjects,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumObjects,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumObjects,
            ppenum: ?*?*IEnumObjects,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumObjects_Next(self: *const T, celt: u32, riid: ?*const Guid, rgelt: [*]?*anyopaque, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumObjects.VTable, self.vtable).Next(@ptrCast(*const IEnumObjects, self), celt, riid, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumObjects_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumObjects.VTable, self.vtable).Skip(@ptrCast(*const IEnumObjects, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumObjects_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumObjects.VTable, self.vtable).Reset(@ptrCast(*const IEnumObjects, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumObjects_Clone(self: *const T, ppenum: ?*?*IEnumObjects) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumObjects.VTable, self.vtable).Clone(@ptrCast(*const IEnumObjects, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _OPPROGDLGF = enum(i32) {
    DEFAULT = 0,
    ENABLEPAUSE = 128,
    ALLOWUNDO = 256,
    DONTDISPLAYSOURCEPATH = 512,
    DONTDISPLAYDESTPATH = 1024,
    NOMULTIDAYESTIMATES = 2048,
    DONTDISPLAYLOCATIONS = 4096,
};
pub const OPPROGDLG_DEFAULT = _OPPROGDLGF.DEFAULT;
pub const OPPROGDLG_ENABLEPAUSE = _OPPROGDLGF.ENABLEPAUSE;
pub const OPPROGDLG_ALLOWUNDO = _OPPROGDLGF.ALLOWUNDO;
pub const OPPROGDLG_DONTDISPLAYSOURCEPATH = _OPPROGDLGF.DONTDISPLAYSOURCEPATH;
pub const OPPROGDLG_DONTDISPLAYDESTPATH = _OPPROGDLGF.DONTDISPLAYDESTPATH;
pub const OPPROGDLG_NOMULTIDAYESTIMATES = _OPPROGDLGF.NOMULTIDAYESTIMATES;
pub const OPPROGDLG_DONTDISPLAYLOCATIONS = _OPPROGDLGF.DONTDISPLAYLOCATIONS;

pub const _PDMODE = enum(i32) {
    DEFAULT = 0,
    RUN = 1,
    PREFLIGHT = 2,
    UNDOING = 4,
    ERRORSBLOCKING = 8,
    INDETERMINATE = 16,
};
pub const PDM_DEFAULT = _PDMODE.DEFAULT;
pub const PDM_RUN = _PDMODE.RUN;
pub const PDM_PREFLIGHT = _PDMODE.PREFLIGHT;
pub const PDM_UNDOING = _PDMODE.UNDOING;
pub const PDM_ERRORSBLOCKING = _PDMODE.ERRORSBLOCKING;
pub const PDM_INDETERMINATE = _PDMODE.INDETERMINATE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOperationsProgressDialog_Value = @import("../zig.zig").Guid.initString("0c9fb851-e5c9-43eb-a370-f0677b13874c");
pub const IID_IOperationsProgressDialog = &IID_IOperationsProgressDialog_Value;
pub const IOperationsProgressDialog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartProgressDialog: fn(
            self: *const IOperationsProgressDialog,
            hwndOwner: ?HWND,
            flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopProgressDialog: fn(
            self: *const IOperationsProgressDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOperation: fn(
            self: *const IOperationsProgressDialog,
            action: SPACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMode: fn(
            self: *const IOperationsProgressDialog,
            mode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateProgress: fn(
            self: *const IOperationsProgressDialog,
            ullPointsCurrent: u64,
            ullPointsTotal: u64,
            ullSizeCurrent: u64,
            ullSizeTotal: u64,
            ullItemsCurrent: u64,
            ullItemsTotal: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateLocations: fn(
            self: *const IOperationsProgressDialog,
            psiSource: ?*IShellItem,
            psiTarget: ?*IShellItem,
            psiItem: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetTimer: fn(
            self: *const IOperationsProgressDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PauseTimer: fn(
            self: *const IOperationsProgressDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumeTimer: fn(
            self: *const IOperationsProgressDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMilliseconds: fn(
            self: *const IOperationsProgressDialog,
            pullElapsed: ?*u64,
            pullRemaining: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOperationStatus: fn(
            self: *const IOperationsProgressDialog,
            popstatus: ?*PDOPSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_StartProgressDialog(self: *const T, hwndOwner: ?HWND, flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).StartProgressDialog(@ptrCast(*const IOperationsProgressDialog, self), hwndOwner, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_StopProgressDialog(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).StopProgressDialog(@ptrCast(*const IOperationsProgressDialog, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_SetOperation(self: *const T, action: SPACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).SetOperation(@ptrCast(*const IOperationsProgressDialog, self), action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_SetMode(self: *const T, mode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).SetMode(@ptrCast(*const IOperationsProgressDialog, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_UpdateProgress(self: *const T, ullPointsCurrent: u64, ullPointsTotal: u64, ullSizeCurrent: u64, ullSizeTotal: u64, ullItemsCurrent: u64, ullItemsTotal: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).UpdateProgress(@ptrCast(*const IOperationsProgressDialog, self), ullPointsCurrent, ullPointsTotal, ullSizeCurrent, ullSizeTotal, ullItemsCurrent, ullItemsTotal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_UpdateLocations(self: *const T, psiSource: ?*IShellItem, psiTarget: ?*IShellItem, psiItem: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).UpdateLocations(@ptrCast(*const IOperationsProgressDialog, self), psiSource, psiTarget, psiItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_ResetTimer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).ResetTimer(@ptrCast(*const IOperationsProgressDialog, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_PauseTimer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).PauseTimer(@ptrCast(*const IOperationsProgressDialog, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_ResumeTimer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).ResumeTimer(@ptrCast(*const IOperationsProgressDialog, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_GetMilliseconds(self: *const T, pullElapsed: ?*u64, pullRemaining: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).GetMilliseconds(@ptrCast(*const IOperationsProgressDialog, self), pullElapsed, pullRemaining);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOperationsProgressDialog_GetOperationStatus(self: *const T, popstatus: ?*PDOPSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOperationsProgressDialog.VTable, self.vtable).GetOperationStatus(@ptrCast(*const IOperationsProgressDialog, self), popstatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IIOCancelInformation_Value = @import("../zig.zig").Guid.initString("f5b0bf81-8cb5-4b1b-9449-1a159e0c733c");
pub const IID_IIOCancelInformation = &IID_IIOCancelInformation_Value;
pub const IIOCancelInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCancelInformation: fn(
            self: *const IIOCancelInformation,
            dwThreadID: u32,
            uMsgCancel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCancelInformation: fn(
            self: *const IIOCancelInformation,
            pdwThreadID: ?*u32,
            puMsgCancel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIOCancelInformation_SetCancelInformation(self: *const T, dwThreadID: u32, uMsgCancel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIOCancelInformation.VTable, self.vtable).SetCancelInformation(@ptrCast(*const IIOCancelInformation, self), dwThreadID, uMsgCancel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIOCancelInformation_GetCancelInformation(self: *const T, pdwThreadID: ?*u32, puMsgCancel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIOCancelInformation.VTable, self.vtable).GetCancelInformation(@ptrCast(*const IIOCancelInformation, self), pdwThreadID, puMsgCancel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileOperation_Value = @import("../zig.zig").Guid.initString("947aab5f-0a5c-4c13-b4d6-4bf7836fc9f8");
pub const IID_IFileOperation = &IID_IFileOperation_Value;
pub const IFileOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: fn(
            self: *const IFileOperation,
            pfops: ?*IFileOperationProgressSink,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IFileOperation,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOperationFlags: fn(
            self: *const IFileOperation,
            dwOperationFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProgressMessage: fn(
            self: *const IFileOperation,
            pszMessage: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProgressDialog: fn(
            self: *const IFileOperation,
            popd: ?*IOperationsProgressDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const IFileOperation,
            pproparray: ?*IPropertyChangeArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOwnerWindow: fn(
            self: *const IFileOperation,
            hwndOwner: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyPropertiesToItem: fn(
            self: *const IFileOperation,
            psiItem: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyPropertiesToItems: fn(
            self: *const IFileOperation,
            punkItems: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenameItem: fn(
            self: *const IFileOperation,
            psiItem: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
            pfopsItem: ?*IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RenameItems: fn(
            self: *const IFileOperation,
            pUnkItems: ?*IUnknown,
            pszNewName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveItem: fn(
            self: *const IFileOperation,
            psiItem: ?*IShellItem,
            psiDestinationFolder: ?*IShellItem,
            pszNewName: ?[*:0]const u16,
            pfopsItem: ?*IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveItems: fn(
            self: *const IFileOperation,
            punkItems: ?*IUnknown,
            psiDestinationFolder: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyItem: fn(
            self: *const IFileOperation,
            psiItem: ?*IShellItem,
            psiDestinationFolder: ?*IShellItem,
            pszCopyName: ?[*:0]const u16,
            pfopsItem: ?*IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyItems: fn(
            self: *const IFileOperation,
            punkItems: ?*IUnknown,
            psiDestinationFolder: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteItem: fn(
            self: *const IFileOperation,
            psiItem: ?*IShellItem,
            pfopsItem: ?*IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteItems: fn(
            self: *const IFileOperation,
            punkItems: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewItem: fn(
            self: *const IFileOperation,
            psiDestinationFolder: ?*IShellItem,
            dwFileAttributes: u32,
            pszName: ?[*:0]const u16,
            pszTemplateName: ?[*:0]const u16,
            pfopsItem: ?*IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PerformOperations: fn(
            self: *const IFileOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnyOperationsAborted: fn(
            self: *const IFileOperation,
            pfAnyOperationsAborted: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_Advise(self: *const T, pfops: ?*IFileOperationProgressSink, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).Advise(@ptrCast(*const IFileOperation, self), pfops, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).Unadvise(@ptrCast(*const IFileOperation, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_SetOperationFlags(self: *const T, dwOperationFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).SetOperationFlags(@ptrCast(*const IFileOperation, self), dwOperationFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_SetProgressMessage(self: *const T, pszMessage: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).SetProgressMessage(@ptrCast(*const IFileOperation, self), pszMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_SetProgressDialog(self: *const T, popd: ?*IOperationsProgressDialog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).SetProgressDialog(@ptrCast(*const IFileOperation, self), popd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_SetProperties(self: *const T, pproparray: ?*IPropertyChangeArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).SetProperties(@ptrCast(*const IFileOperation, self), pproparray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_SetOwnerWindow(self: *const T, hwndOwner: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).SetOwnerWindow(@ptrCast(*const IFileOperation, self), hwndOwner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_ApplyPropertiesToItem(self: *const T, psiItem: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).ApplyPropertiesToItem(@ptrCast(*const IFileOperation, self), psiItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_ApplyPropertiesToItems(self: *const T, punkItems: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).ApplyPropertiesToItems(@ptrCast(*const IFileOperation, self), punkItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_RenameItem(self: *const T, psiItem: ?*IShellItem, pszNewName: ?[*:0]const u16, pfopsItem: ?*IFileOperationProgressSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).RenameItem(@ptrCast(*const IFileOperation, self), psiItem, pszNewName, pfopsItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_RenameItems(self: *const T, pUnkItems: ?*IUnknown, pszNewName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).RenameItems(@ptrCast(*const IFileOperation, self), pUnkItems, pszNewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_MoveItem(self: *const T, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszNewName: ?[*:0]const u16, pfopsItem: ?*IFileOperationProgressSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).MoveItem(@ptrCast(*const IFileOperation, self), psiItem, psiDestinationFolder, pszNewName, pfopsItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_MoveItems(self: *const T, punkItems: ?*IUnknown, psiDestinationFolder: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).MoveItems(@ptrCast(*const IFileOperation, self), punkItems, psiDestinationFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_CopyItem(self: *const T, psiItem: ?*IShellItem, psiDestinationFolder: ?*IShellItem, pszCopyName: ?[*:0]const u16, pfopsItem: ?*IFileOperationProgressSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).CopyItem(@ptrCast(*const IFileOperation, self), psiItem, psiDestinationFolder, pszCopyName, pfopsItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_CopyItems(self: *const T, punkItems: ?*IUnknown, psiDestinationFolder: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).CopyItems(@ptrCast(*const IFileOperation, self), punkItems, psiDestinationFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_DeleteItem(self: *const T, psiItem: ?*IShellItem, pfopsItem: ?*IFileOperationProgressSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).DeleteItem(@ptrCast(*const IFileOperation, self), psiItem, pfopsItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_DeleteItems(self: *const T, punkItems: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).DeleteItems(@ptrCast(*const IFileOperation, self), punkItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_NewItem(self: *const T, psiDestinationFolder: ?*IShellItem, dwFileAttributes: u32, pszName: ?[*:0]const u16, pszTemplateName: ?[*:0]const u16, pfopsItem: ?*IFileOperationProgressSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).NewItem(@ptrCast(*const IFileOperation, self), psiDestinationFolder, dwFileAttributes, pszName, pszTemplateName, pfopsItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_PerformOperations(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).PerformOperations(@ptrCast(*const IFileOperation, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation_GetAnyOperationsAborted(self: *const T, pfAnyOperationsAborted: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation.VTable, self.vtable).GetAnyOperationsAborted(@ptrCast(*const IFileOperation, self), pfAnyOperationsAborted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FILE_OPERATION_FLAGS2 = enum(i32) {
    NONE = 0,
    MERGEFOLDERSONCOLLISION = 1,
};
pub const FOF2_NONE = FILE_OPERATION_FLAGS2.NONE;
pub const FOF2_MERGEFOLDERSONCOLLISION = FILE_OPERATION_FLAGS2.MERGEFOLDERSONCOLLISION;

const IID_IFileOperation2_Value = @import("../zig.zig").Guid.initString("cd8f23c1-8f61-4916-909d-55bdd0918753");
pub const IID_IFileOperation2 = &IID_IFileOperation2_Value;
pub const IFileOperation2 = extern struct {
    pub const VTable = extern struct {
        base: IFileOperation.VTable,
        SetOperationFlags2: fn(
            self: *const IFileOperation2,
            operationFlags2: FILE_OPERATION_FLAGS2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileOperation.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOperation2_SetOperationFlags2(self: *const T, operationFlags2: FILE_OPERATION_FLAGS2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOperation2.VTable, self.vtable).SetOperationFlags2(@ptrCast(*const IFileOperation2, self), operationFlags2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IObjectProvider_Value = @import("../zig.zig").Guid.initString("a6087428-3be3-4d73-b308-7c04a540bf1a");
pub const IID_IObjectProvider = &IID_IObjectProvider_Value;
pub const IObjectProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryObject: fn(
            self: *const IObjectProvider,
            guidObject: ?*const Guid,
            riid: ?*const Guid,
            ppvOut: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectProvider_QueryObject(self: *const T, guidObject: ?*const Guid, riid: ?*const Guid, ppvOut: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectProvider.VTable, self.vtable).QueryObject(@ptrCast(*const IObjectProvider, self), guidObject, riid, ppvOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamespaceWalkCB_Value = @import("../zig.zig").Guid.initString("d92995f8-cf5e-4a76-bf59-ead39ea2b97e");
pub const IID_INamespaceWalkCB = &IID_INamespaceWalkCB_Value;
pub const INamespaceWalkCB = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FoundItem: fn(
            self: *const INamespaceWalkCB,
            psf: ?*IShellFolder,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnterFolder: fn(
            self: *const INamespaceWalkCB,
            psf: ?*IShellFolder,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LeaveFolder: fn(
            self: *const INamespaceWalkCB,
            psf: ?*IShellFolder,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeProgressDialog: fn(
            self: *const INamespaceWalkCB,
            ppszTitle: ?*?PWSTR,
            ppszCancel: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamespaceWalkCB_FoundItem(self: *const T, psf: ?*IShellFolder, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamespaceWalkCB.VTable, self.vtable).FoundItem(@ptrCast(*const INamespaceWalkCB, self), psf, pidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamespaceWalkCB_EnterFolder(self: *const T, psf: ?*IShellFolder, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamespaceWalkCB.VTable, self.vtable).EnterFolder(@ptrCast(*const INamespaceWalkCB, self), psf, pidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamespaceWalkCB_LeaveFolder(self: *const T, psf: ?*IShellFolder, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamespaceWalkCB.VTable, self.vtable).LeaveFolder(@ptrCast(*const INamespaceWalkCB, self), psf, pidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamespaceWalkCB_InitializeProgressDialog(self: *const T, ppszTitle: ?*?PWSTR, ppszCancel: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamespaceWalkCB.VTable, self.vtable).InitializeProgressDialog(@ptrCast(*const INamespaceWalkCB, self), ppszTitle, ppszCancel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INamespaceWalkCB2_Value = @import("../zig.zig").Guid.initString("7ac7492b-c38e-438a-87db-68737844ff70");
pub const IID_INamespaceWalkCB2 = &IID_INamespaceWalkCB2_Value;
pub const INamespaceWalkCB2 = extern struct {
    pub const VTable = extern struct {
        base: INamespaceWalkCB.VTable,
        WalkComplete: fn(
            self: *const INamespaceWalkCB2,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace INamespaceWalkCB.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamespaceWalkCB2_WalkComplete(self: *const T, hr: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamespaceWalkCB2.VTable, self.vtable).WalkComplete(@ptrCast(*const INamespaceWalkCB2, self), hr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NAMESPACEWALKFLAG = enum(i32) {
    DEFAULT = 0,
    NONE_IMPLIES_ALL = 1,
    ONE_IMPLIES_ALL = 2,
    DONT_TRAVERSE_LINKS = 4,
    DONT_ACCUMULATE_RESULT = 8,
    TRAVERSE_STREAM_JUNCTIONS = 16,
    FILESYSTEM_ONLY = 32,
    SHOW_PROGRESS = 64,
    FLAG_VIEWORDER = 128,
    IGNORE_AUTOPLAY_HIDA = 256,
    ASYNC = 512,
    DONT_RESOLVE_LINKS = 1024,
    ACCUMULATE_FOLDERS = 2048,
    DONT_SORT = 4096,
    USE_TRANSFER_MEDIUM = 8192,
    DONT_TRAVERSE_STREAM_JUNCTIONS = 16384,
    ANY_IMPLIES_ALL = 32768,
};
pub const NSWF_DEFAULT = NAMESPACEWALKFLAG.DEFAULT;
pub const NSWF_NONE_IMPLIES_ALL = NAMESPACEWALKFLAG.NONE_IMPLIES_ALL;
pub const NSWF_ONE_IMPLIES_ALL = NAMESPACEWALKFLAG.ONE_IMPLIES_ALL;
pub const NSWF_DONT_TRAVERSE_LINKS = NAMESPACEWALKFLAG.DONT_TRAVERSE_LINKS;
pub const NSWF_DONT_ACCUMULATE_RESULT = NAMESPACEWALKFLAG.DONT_ACCUMULATE_RESULT;
pub const NSWF_TRAVERSE_STREAM_JUNCTIONS = NAMESPACEWALKFLAG.TRAVERSE_STREAM_JUNCTIONS;
pub const NSWF_FILESYSTEM_ONLY = NAMESPACEWALKFLAG.FILESYSTEM_ONLY;
pub const NSWF_SHOW_PROGRESS = NAMESPACEWALKFLAG.SHOW_PROGRESS;
pub const NSWF_FLAG_VIEWORDER = NAMESPACEWALKFLAG.FLAG_VIEWORDER;
pub const NSWF_IGNORE_AUTOPLAY_HIDA = NAMESPACEWALKFLAG.IGNORE_AUTOPLAY_HIDA;
pub const NSWF_ASYNC = NAMESPACEWALKFLAG.ASYNC;
pub const NSWF_DONT_RESOLVE_LINKS = NAMESPACEWALKFLAG.DONT_RESOLVE_LINKS;
pub const NSWF_ACCUMULATE_FOLDERS = NAMESPACEWALKFLAG.ACCUMULATE_FOLDERS;
pub const NSWF_DONT_SORT = NAMESPACEWALKFLAG.DONT_SORT;
pub const NSWF_USE_TRANSFER_MEDIUM = NAMESPACEWALKFLAG.USE_TRANSFER_MEDIUM;
pub const NSWF_DONT_TRAVERSE_STREAM_JUNCTIONS = NAMESPACEWALKFLAG.DONT_TRAVERSE_STREAM_JUNCTIONS;
pub const NSWF_ANY_IMPLIES_ALL = NAMESPACEWALKFLAG.ANY_IMPLIES_ALL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamespaceWalk_Value = @import("../zig.zig").Guid.initString("57ced8a7-3f4a-432c-9350-30f24483f74f");
pub const IID_INamespaceWalk = &IID_INamespaceWalk_Value;
pub const INamespaceWalk = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Walk: fn(
            self: *const INamespaceWalk,
            punkToWalk: ?*IUnknown,
            dwFlags: u32,
            cDepth: i32,
            pnswcb: ?*INamespaceWalkCB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDArrayResult: fn(
            self: *const INamespaceWalk,
            pcItems: ?*u32,
            prgpidl: [*]?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamespaceWalk_Walk(self: *const T, punkToWalk: ?*IUnknown, dwFlags: u32, cDepth: i32, pnswcb: ?*INamespaceWalkCB) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamespaceWalk.VTable, self.vtable).Walk(@ptrCast(*const INamespaceWalk, self), punkToWalk, dwFlags, cDepth, pnswcb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamespaceWalk_GetIDArrayResult(self: *const T, pcItems: ?*u32, prgpidl: [*]?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamespaceWalk.VTable, self.vtable).GetIDArrayResult(@ptrCast(*const INamespaceWalk, self), pcItems, prgpidl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BANDSITEINFO = extern struct {
    dwMask: u32,
    dwState: u32,
    dwStyle: u32,
};

pub const BANDSITECID = enum(i32) {
    ADDED = 0,
    REMOVED = 1,
};
pub const BSID_BANDADDED = BANDSITECID.ADDED;
pub const BSID_BANDREMOVED = BANDSITECID.REMOVED;

// TODO: this type is limited to platform 'windows5.0'
const IID_IBandSite_Value = @import("../zig.zig").Guid.initString("4cf504b0-de96-11d0-8b3f-00a0c911e8e5");
pub const IID_IBandSite = &IID_IBandSite_Value;
pub const IBandSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddBand: fn(
            self: *const IBandSite,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumBands: fn(
            self: *const IBandSite,
            uBand: u32,
            pdwBandID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryBand: fn(
            self: *const IBandSite,
            dwBandID: u32,
            ppstb: ?*?*IDeskBand,
            pdwState: ?*u32,
            pszName: ?[*:0]u16,
            cchName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBandState: fn(
            self: *const IBandSite,
            dwBandID: u32,
            dwMask: u32,
            dwState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBand: fn(
            self: *const IBandSite,
            dwBandID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBandObject: fn(
            self: *const IBandSite,
            dwBandID: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBandSiteInfo: fn(
            self: *const IBandSite,
            pbsinfo: ?*const BANDSITEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBandSiteInfo: fn(
            self: *const IBandSite,
            pbsinfo: ?*BANDSITEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandSite_AddBand(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandSite.VTable, self.vtable).AddBand(@ptrCast(*const IBandSite, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandSite_EnumBands(self: *const T, uBand: u32, pdwBandID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandSite.VTable, self.vtable).EnumBands(@ptrCast(*const IBandSite, self), uBand, pdwBandID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandSite_QueryBand(self: *const T, dwBandID: u32, ppstb: ?*?*IDeskBand, pdwState: ?*u32, pszName: ?[*:0]u16, cchName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandSite.VTable, self.vtable).QueryBand(@ptrCast(*const IBandSite, self), dwBandID, ppstb, pdwState, pszName, cchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandSite_SetBandState(self: *const T, dwBandID: u32, dwMask: u32, dwState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandSite.VTable, self.vtable).SetBandState(@ptrCast(*const IBandSite, self), dwBandID, dwMask, dwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandSite_RemoveBand(self: *const T, dwBandID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandSite.VTable, self.vtable).RemoveBand(@ptrCast(*const IBandSite, self), dwBandID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandSite_GetBandObject(self: *const T, dwBandID: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandSite.VTable, self.vtable).GetBandObject(@ptrCast(*const IBandSite, self), dwBandID, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandSite_SetBandSiteInfo(self: *const T, pbsinfo: ?*const BANDSITEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandSite.VTable, self.vtable).SetBandSiteInfo(@ptrCast(*const IBandSite, self), pbsinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandSite_GetBandSiteInfo(self: *const T, pbsinfo: ?*BANDSITEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandSite.VTable, self.vtable).GetBandSiteInfo(@ptrCast(*const IBandSite, self), pbsinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IModalWindow_Value = @import("../zig.zig").Guid.initString("b4db1657-70d7-485e-8e3e-6fcb5a5c1802");
pub const IID_IModalWindow = &IID_IModalWindow_Value;
pub const IModalWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Show: fn(
            self: *const IModalWindow,
            hwndOwner: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModalWindow_Show(self: *const T, hwndOwner: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModalWindow.VTable, self.vtable).Show(@ptrCast(*const IModalWindow, self), hwndOwner);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IContextMenuSite_Value = @import("../zig.zig").Guid.initString("0811aebe-0b87-4c54-9e72-548cf649016b");
pub const IID_IContextMenuSite = &IID_IContextMenuSite_Value;
pub const IContextMenuSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoContextMenuPopup: fn(
            self: *const IContextMenuSite,
            punkContextMenu: ?*IUnknown,
            fFlags: u32,
            pt: POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuSite_DoContextMenuPopup(self: *const T, punkContextMenu: ?*IUnknown, fFlags: u32, pt: POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuSite.VTable, self.vtable).DoContextMenuPopup(@ptrCast(*const IContextMenuSite, self), punkContextMenu, fFlags, pt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MENUBANDHANDLERCID = enum(i32) {
    T = 0,
};
pub const MBHANDCID_PIDLSELECT = MENUBANDHANDLERCID.T;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMenuBand_Value = @import("../zig.zig").Guid.initString("568804cd-cbd7-11d0-9816-00c04fd91972");
pub const IID_IMenuBand = &IID_IMenuBand_Value;
pub const IMenuBand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMenuMessage: fn(
            self: *const IMenuBand,
            pmsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateMenuMessage: fn(
            self: *const IMenuBand,
            pmsg: ?*MSG,
            plRet: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuBand_IsMenuMessage(self: *const T, pmsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuBand.VTable, self.vtable).IsMenuMessage(@ptrCast(*const IMenuBand, self), pmsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuBand_TranslateMenuMessage(self: *const T, pmsg: ?*MSG, plRet: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuBand.VTable, self.vtable).TranslateMenuMessage(@ptrCast(*const IMenuBand, self), pmsg, plRet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRegTreeItem_Value = @import("../zig.zig").Guid.initString("a9521922-0812-4d44-9ec3-7fd38c726f3d");
pub const IID_IRegTreeItem = &IID_IRegTreeItem_Value;
pub const IRegTreeItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCheckState: fn(
            self: *const IRegTreeItem,
            pbCheck: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCheckState: fn(
            self: *const IRegTreeItem,
            bCheck: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegTreeItem_GetCheckState(self: *const T, pbCheck: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegTreeItem.VTable, self.vtable).GetCheckState(@ptrCast(*const IRegTreeItem, self), pbCheck);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegTreeItem_SetCheckState(self: *const T, bCheck: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegTreeItem.VTable, self.vtable).SetCheckState(@ptrCast(*const IRegTreeItem, self), bCheck);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDeskBar_Value = @import("../zig.zig").Guid.initString("eb0fe173-1a3a-11d0-89b3-00a0c90a90ac");
pub const IID_IDeskBar = &IID_IDeskBar_Value;
pub const IDeskBar = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        SetClient: fn(
            self: *const IDeskBar,
            punkClient: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClient: fn(
            self: *const IDeskBar,
            ppunkClient: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPosRectChangeDB: fn(
            self: *const IDeskBar,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBar_SetClient(self: *const T, punkClient: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBar.VTable, self.vtable).SetClient(@ptrCast(*const IDeskBar, self), punkClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBar_GetClient(self: *const T, ppunkClient: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBar.VTable, self.vtable).GetClient(@ptrCast(*const IDeskBar, self), ppunkClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBar_OnPosRectChangeDB(self: *const T, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBar.VTable, self.vtable).OnPosRectChangeDB(@ptrCast(*const IDeskBar, self), prc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MENUPOPUPSELECT = enum(i32) {
    EXECUTE = 0,
    FULLCANCEL = 1,
    CANCELLEVEL = 2,
    SELECTLEFT = 3,
    SELECTRIGHT = 4,
    CHILDTRACKING = 5,
};
pub const MPOS_EXECUTE = MENUPOPUPSELECT.EXECUTE;
pub const MPOS_FULLCANCEL = MENUPOPUPSELECT.FULLCANCEL;
pub const MPOS_CANCELLEVEL = MENUPOPUPSELECT.CANCELLEVEL;
pub const MPOS_SELECTLEFT = MENUPOPUPSELECT.SELECTLEFT;
pub const MPOS_SELECTRIGHT = MENUPOPUPSELECT.SELECTRIGHT;
pub const MPOS_CHILDTRACKING = MENUPOPUPSELECT.CHILDTRACKING;

pub const MENUPOPUPPOPUPFLAGS = enum(i32) {
    SETFOCUS = 1,
    INITIALSELECT = 2,
    NOANIMATE = 4,
    KEYBOARD = 16,
    REPOSITION = 32,
    FORCEZORDER = 64,
    FINALSELECT = 128,
    TOP = 536870912,
    LEFT = 1073741824,
    RIGHT = 1610612736,
    BOTTOM = -2147483648,
    POS_MASK = -536870912,
    ALIGN_LEFT = 33554432,
    ALIGN_RIGHT = 67108864,
};
pub const MPPF_SETFOCUS = MENUPOPUPPOPUPFLAGS.SETFOCUS;
pub const MPPF_INITIALSELECT = MENUPOPUPPOPUPFLAGS.INITIALSELECT;
pub const MPPF_NOANIMATE = MENUPOPUPPOPUPFLAGS.NOANIMATE;
pub const MPPF_KEYBOARD = MENUPOPUPPOPUPFLAGS.KEYBOARD;
pub const MPPF_REPOSITION = MENUPOPUPPOPUPFLAGS.REPOSITION;
pub const MPPF_FORCEZORDER = MENUPOPUPPOPUPFLAGS.FORCEZORDER;
pub const MPPF_FINALSELECT = MENUPOPUPPOPUPFLAGS.FINALSELECT;
pub const MPPF_TOP = MENUPOPUPPOPUPFLAGS.TOP;
pub const MPPF_LEFT = MENUPOPUPPOPUPFLAGS.LEFT;
pub const MPPF_RIGHT = MENUPOPUPPOPUPFLAGS.RIGHT;
pub const MPPF_BOTTOM = MENUPOPUPPOPUPFLAGS.BOTTOM;
pub const MPPF_POS_MASK = MENUPOPUPPOPUPFLAGS.POS_MASK;
pub const MPPF_ALIGN_LEFT = MENUPOPUPPOPUPFLAGS.ALIGN_LEFT;
pub const MPPF_ALIGN_RIGHT = MENUPOPUPPOPUPFLAGS.ALIGN_RIGHT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMenuPopup_Value = @import("../zig.zig").Guid.initString("d1e7afeb-6a2e-11d0-8c78-00c04fd918b4");
pub const IID_IMenuPopup = &IID_IMenuPopup_Value;
pub const IMenuPopup = extern struct {
    pub const VTable = extern struct {
        base: IDeskBar.VTable,
        Popup: fn(
            self: *const IMenuPopup,
            ppt: ?*POINTL,
            prcExclude: ?*RECTL,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelect: fn(
            self: *const IMenuPopup,
            dwSelectType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubMenu: fn(
            self: *const IMenuPopup,
            pmp: ?*IMenuPopup,
            fSet: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDeskBar.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuPopup_Popup(self: *const T, ppt: ?*POINTL, prcExclude: ?*RECTL, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuPopup.VTable, self.vtable).Popup(@ptrCast(*const IMenuPopup, self), ppt, prcExclude, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuPopup_OnSelect(self: *const T, dwSelectType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuPopup.VTable, self.vtable).OnSelect(@ptrCast(*const IMenuPopup, self), dwSelectType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuPopup_SetSubMenu(self: *const T, pmp: ?*IMenuPopup, fSet: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuPopup.VTable, self.vtable).SetSubMenu(@ptrCast(*const IMenuPopup, self), pmp, fSet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FILE_USAGE_TYPE = enum(i32) {
    PLAYING = 0,
    EDITING = 1,
    GENERIC = 2,
};
pub const FUT_PLAYING = FILE_USAGE_TYPE.PLAYING;
pub const FUT_EDITING = FILE_USAGE_TYPE.EDITING;
pub const FUT_GENERIC = FILE_USAGE_TYPE.GENERIC;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileIsInUse_Value = @import("../zig.zig").Guid.initString("64a1cbf0-3a1a-4461-9158-376969693950");
pub const IID_IFileIsInUse = &IID_IFileIsInUse_Value;
pub const IFileIsInUse = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppName: fn(
            self: *const IFileIsInUse,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUsage: fn(
            self: *const IFileIsInUse,
            pfut: ?*FILE_USAGE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCapabilities: fn(
            self: *const IFileIsInUse,
            pdwCapFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSwitchToHWND: fn(
            self: *const IFileIsInUse,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseFile: fn(
            self: *const IFileIsInUse,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIsInUse_GetAppName(self: *const T, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIsInUse.VTable, self.vtable).GetAppName(@ptrCast(*const IFileIsInUse, self), ppszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIsInUse_GetUsage(self: *const T, pfut: ?*FILE_USAGE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIsInUse.VTable, self.vtable).GetUsage(@ptrCast(*const IFileIsInUse, self), pfut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIsInUse_GetCapabilities(self: *const T, pdwCapFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIsInUse.VTable, self.vtable).GetCapabilities(@ptrCast(*const IFileIsInUse, self), pdwCapFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIsInUse_GetSwitchToHWND(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIsInUse.VTable, self.vtable).GetSwitchToHWND(@ptrCast(*const IFileIsInUse, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIsInUse_CloseFile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIsInUse.VTable, self.vtable).CloseFile(@ptrCast(*const IFileIsInUse, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FDE_OVERWRITE_RESPONSE = enum(i32) {
    DEFAULT = 0,
    ACCEPT = 1,
    REFUSE = 2,
};
pub const FDEOR_DEFAULT = FDE_OVERWRITE_RESPONSE.DEFAULT;
pub const FDEOR_ACCEPT = FDE_OVERWRITE_RESPONSE.ACCEPT;
pub const FDEOR_REFUSE = FDE_OVERWRITE_RESPONSE.REFUSE;

pub const FDE_SHAREVIOLATION_RESPONSE = enum(i32) {
    DEFAULT = 0,
    ACCEPT = 1,
    REFUSE = 2,
};
pub const FDESVR_DEFAULT = FDE_SHAREVIOLATION_RESPONSE.DEFAULT;
pub const FDESVR_ACCEPT = FDE_SHAREVIOLATION_RESPONSE.ACCEPT;
pub const FDESVR_REFUSE = FDE_SHAREVIOLATION_RESPONSE.REFUSE;

pub const FDAP = enum(i32) {
    BOTTOM = 0,
    TOP = 1,
};
pub const FDAP_BOTTOM = FDAP.BOTTOM;
pub const FDAP_TOP = FDAP.TOP;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileDialogEvents_Value = @import("../zig.zig").Guid.initString("973510db-7d7f-452b-8975-74a85828d354");
pub const IID_IFileDialogEvents = &IID_IFileDialogEvents_Value;
pub const IFileDialogEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFileOk: fn(
            self: *const IFileDialogEvents,
            pfd: ?*IFileDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFolderChanging: fn(
            self: *const IFileDialogEvents,
            pfd: ?*IFileDialog,
            psiFolder: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFolderChange: fn(
            self: *const IFileDialogEvents,
            pfd: ?*IFileDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelectionChange: fn(
            self: *const IFileDialogEvents,
            pfd: ?*IFileDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnShareViolation: fn(
            self: *const IFileDialogEvents,
            pfd: ?*IFileDialog,
            psi: ?*IShellItem,
            pResponse: ?*FDE_SHAREVIOLATION_RESPONSE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTypeChange: fn(
            self: *const IFileDialogEvents,
            pfd: ?*IFileDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnOverwrite: fn(
            self: *const IFileDialogEvents,
            pfd: ?*IFileDialog,
            psi: ?*IShellItem,
            pResponse: ?*FDE_OVERWRITE_RESPONSE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogEvents_OnFileOk(self: *const T, pfd: ?*IFileDialog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogEvents.VTable, self.vtable).OnFileOk(@ptrCast(*const IFileDialogEvents, self), pfd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogEvents_OnFolderChanging(self: *const T, pfd: ?*IFileDialog, psiFolder: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogEvents.VTable, self.vtable).OnFolderChanging(@ptrCast(*const IFileDialogEvents, self), pfd, psiFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogEvents_OnFolderChange(self: *const T, pfd: ?*IFileDialog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogEvents.VTable, self.vtable).OnFolderChange(@ptrCast(*const IFileDialogEvents, self), pfd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogEvents_OnSelectionChange(self: *const T, pfd: ?*IFileDialog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogEvents.VTable, self.vtable).OnSelectionChange(@ptrCast(*const IFileDialogEvents, self), pfd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogEvents_OnShareViolation(self: *const T, pfd: ?*IFileDialog, psi: ?*IShellItem, pResponse: ?*FDE_SHAREVIOLATION_RESPONSE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogEvents.VTable, self.vtable).OnShareViolation(@ptrCast(*const IFileDialogEvents, self), pfd, psi, pResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogEvents_OnTypeChange(self: *const T, pfd: ?*IFileDialog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogEvents.VTable, self.vtable).OnTypeChange(@ptrCast(*const IFileDialogEvents, self), pfd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogEvents_OnOverwrite(self: *const T, pfd: ?*IFileDialog, psi: ?*IShellItem, pResponse: ?*FDE_OVERWRITE_RESPONSE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogEvents.VTable, self.vtable).OnOverwrite(@ptrCast(*const IFileDialogEvents, self), pfd, psi, pResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _FILEOPENDIALOGOPTIONS = enum(i32) {
    OVERWRITEPROMPT = 2,
    STRICTFILETYPES = 4,
    NOCHANGEDIR = 8,
    PICKFOLDERS = 32,
    FORCEFILESYSTEM = 64,
    ALLNONSTORAGEITEMS = 128,
    NOVALIDATE = 256,
    ALLOWMULTISELECT = 512,
    PATHMUSTEXIST = 2048,
    FILEMUSTEXIST = 4096,
    CREATEPROMPT = 8192,
    SHAREAWARE = 16384,
    NOREADONLYRETURN = 32768,
    NOTESTFILECREATE = 65536,
    HIDEMRUPLACES = 131072,
    HIDEPINNEDPLACES = 262144,
    NODEREFERENCELINKS = 1048576,
    OKBUTTONNEEDSINTERACTION = 2097152,
    DONTADDTORECENT = 33554432,
    FORCESHOWHIDDEN = 268435456,
    DEFAULTNOMINIMODE = 536870912,
    FORCEPREVIEWPANEON = 1073741824,
    SUPPORTSTREAMABLEITEMS = -2147483648,
};
pub const FOS_OVERWRITEPROMPT = _FILEOPENDIALOGOPTIONS.OVERWRITEPROMPT;
pub const FOS_STRICTFILETYPES = _FILEOPENDIALOGOPTIONS.STRICTFILETYPES;
pub const FOS_NOCHANGEDIR = _FILEOPENDIALOGOPTIONS.NOCHANGEDIR;
pub const FOS_PICKFOLDERS = _FILEOPENDIALOGOPTIONS.PICKFOLDERS;
pub const FOS_FORCEFILESYSTEM = _FILEOPENDIALOGOPTIONS.FORCEFILESYSTEM;
pub const FOS_ALLNONSTORAGEITEMS = _FILEOPENDIALOGOPTIONS.ALLNONSTORAGEITEMS;
pub const FOS_NOVALIDATE = _FILEOPENDIALOGOPTIONS.NOVALIDATE;
pub const FOS_ALLOWMULTISELECT = _FILEOPENDIALOGOPTIONS.ALLOWMULTISELECT;
pub const FOS_PATHMUSTEXIST = _FILEOPENDIALOGOPTIONS.PATHMUSTEXIST;
pub const FOS_FILEMUSTEXIST = _FILEOPENDIALOGOPTIONS.FILEMUSTEXIST;
pub const FOS_CREATEPROMPT = _FILEOPENDIALOGOPTIONS.CREATEPROMPT;
pub const FOS_SHAREAWARE = _FILEOPENDIALOGOPTIONS.SHAREAWARE;
pub const FOS_NOREADONLYRETURN = _FILEOPENDIALOGOPTIONS.NOREADONLYRETURN;
pub const FOS_NOTESTFILECREATE = _FILEOPENDIALOGOPTIONS.NOTESTFILECREATE;
pub const FOS_HIDEMRUPLACES = _FILEOPENDIALOGOPTIONS.HIDEMRUPLACES;
pub const FOS_HIDEPINNEDPLACES = _FILEOPENDIALOGOPTIONS.HIDEPINNEDPLACES;
pub const FOS_NODEREFERENCELINKS = _FILEOPENDIALOGOPTIONS.NODEREFERENCELINKS;
pub const FOS_OKBUTTONNEEDSINTERACTION = _FILEOPENDIALOGOPTIONS.OKBUTTONNEEDSINTERACTION;
pub const FOS_DONTADDTORECENT = _FILEOPENDIALOGOPTIONS.DONTADDTORECENT;
pub const FOS_FORCESHOWHIDDEN = _FILEOPENDIALOGOPTIONS.FORCESHOWHIDDEN;
pub const FOS_DEFAULTNOMINIMODE = _FILEOPENDIALOGOPTIONS.DEFAULTNOMINIMODE;
pub const FOS_FORCEPREVIEWPANEON = _FILEOPENDIALOGOPTIONS.FORCEPREVIEWPANEON;
pub const FOS_SUPPORTSTREAMABLEITEMS = _FILEOPENDIALOGOPTIONS.SUPPORTSTREAMABLEITEMS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileDialog_Value = @import("../zig.zig").Guid.initString("42f85136-db7e-439c-85f1-e4075d135fc8");
pub const IID_IFileDialog = &IID_IFileDialog_Value;
pub const IFileDialog = extern struct {
    pub const VTable = extern struct {
        base: IModalWindow.VTable,
        SetFileTypes: fn(
            self: *const IFileDialog,
            cFileTypes: u32,
            rgFilterSpec: [*]const COMDLG_FILTERSPEC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFileTypeIndex: fn(
            self: *const IFileDialog,
            iFileType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileTypeIndex: fn(
            self: *const IFileDialog,
            piFileType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IFileDialog,
            pfde: ?*IFileDialogEvents,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IFileDialog,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOptions: fn(
            self: *const IFileDialog,
            fos: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptions: fn(
            self: *const IFileDialog,
            pfos: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultFolder: fn(
            self: *const IFileDialog,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFolder: fn(
            self: *const IFileDialog,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolder: fn(
            self: *const IFileDialog,
            ppsi: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSelection: fn(
            self: *const IFileDialog,
            ppsi: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFileName: fn(
            self: *const IFileDialog,
            pszName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: fn(
            self: *const IFileDialog,
            pszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTitle: fn(
            self: *const IFileDialog,
            pszTitle: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOkButtonLabel: fn(
            self: *const IFileDialog,
            pszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFileNameLabel: fn(
            self: *const IFileDialog,
            pszLabel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResult: fn(
            self: *const IFileDialog,
            ppsi: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPlace: fn(
            self: *const IFileDialog,
            psi: ?*IShellItem,
            fdap: FDAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultExtension: fn(
            self: *const IFileDialog,
            pszDefaultExtension: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IFileDialog,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClientGuid: fn(
            self: *const IFileDialog,
            guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearClientData: fn(
            self: *const IFileDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilter: fn(
            self: *const IFileDialog,
            pFilter: ?*IShellItemFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IModalWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetFileTypes(self: *const T, cFileTypes: u32, rgFilterSpec: [*]const COMDLG_FILTERSPEC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetFileTypes(@ptrCast(*const IFileDialog, self), cFileTypes, rgFilterSpec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetFileTypeIndex(self: *const T, iFileType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetFileTypeIndex(@ptrCast(*const IFileDialog, self), iFileType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_GetFileTypeIndex(self: *const T, piFileType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).GetFileTypeIndex(@ptrCast(*const IFileDialog, self), piFileType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_Advise(self: *const T, pfde: ?*IFileDialogEvents, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).Advise(@ptrCast(*const IFileDialog, self), pfde, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).Unadvise(@ptrCast(*const IFileDialog, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetOptions(self: *const T, fos: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetOptions(@ptrCast(*const IFileDialog, self), fos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_GetOptions(self: *const T, pfos: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).GetOptions(@ptrCast(*const IFileDialog, self), pfos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetDefaultFolder(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetDefaultFolder(@ptrCast(*const IFileDialog, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetFolder(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetFolder(@ptrCast(*const IFileDialog, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_GetFolder(self: *const T, ppsi: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).GetFolder(@ptrCast(*const IFileDialog, self), ppsi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_GetCurrentSelection(self: *const T, ppsi: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).GetCurrentSelection(@ptrCast(*const IFileDialog, self), ppsi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetFileName(self: *const T, pszName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetFileName(@ptrCast(*const IFileDialog, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_GetFileName(self: *const T, pszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).GetFileName(@ptrCast(*const IFileDialog, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetTitle(self: *const T, pszTitle: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetTitle(@ptrCast(*const IFileDialog, self), pszTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetOkButtonLabel(self: *const T, pszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetOkButtonLabel(@ptrCast(*const IFileDialog, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetFileNameLabel(self: *const T, pszLabel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetFileNameLabel(@ptrCast(*const IFileDialog, self), pszLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_GetResult(self: *const T, ppsi: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).GetResult(@ptrCast(*const IFileDialog, self), ppsi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_AddPlace(self: *const T, psi: ?*IShellItem, fdap: FDAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).AddPlace(@ptrCast(*const IFileDialog, self), psi, fdap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetDefaultExtension(self: *const T, pszDefaultExtension: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetDefaultExtension(@ptrCast(*const IFileDialog, self), pszDefaultExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_Close(self: *const T, hr: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).Close(@ptrCast(*const IFileDialog, self), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetClientGuid(self: *const T, guid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetClientGuid(@ptrCast(*const IFileDialog, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_ClearClientData(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).ClearClientData(@ptrCast(*const IFileDialog, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog_SetFilter(self: *const T, pFilter: ?*IShellItemFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog.VTable, self.vtable).SetFilter(@ptrCast(*const IFileDialog, self), pFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSaveDialog_Value = @import("../zig.zig").Guid.initString("84bccd23-5fde-4cdb-aea4-af64b83d78ab");
pub const IID_IFileSaveDialog = &IID_IFileSaveDialog_Value;
pub const IFileSaveDialog = extern struct {
    pub const VTable = extern struct {
        base: IFileDialog.VTable,
        SetSaveAsItem: fn(
            self: *const IFileSaveDialog,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const IFileSaveDialog,
            pStore: ?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCollectedProperties: fn(
            self: *const IFileSaveDialog,
            pList: ?*IPropertyDescriptionList,
            fAppendDefault: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const IFileSaveDialog,
            ppStore: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyProperties: fn(
            self: *const IFileSaveDialog,
            psi: ?*IShellItem,
            pStore: ?*IPropertyStore,
            hwnd: ?HWND,
            pSink: ?*IFileOperationProgressSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileDialog.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSaveDialog_SetSaveAsItem(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSaveDialog.VTable, self.vtable).SetSaveAsItem(@ptrCast(*const IFileSaveDialog, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSaveDialog_SetProperties(self: *const T, pStore: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSaveDialog.VTable, self.vtable).SetProperties(@ptrCast(*const IFileSaveDialog, self), pStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSaveDialog_SetCollectedProperties(self: *const T, pList: ?*IPropertyDescriptionList, fAppendDefault: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSaveDialog.VTable, self.vtable).SetCollectedProperties(@ptrCast(*const IFileSaveDialog, self), pList, fAppendDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSaveDialog_GetProperties(self: *const T, ppStore: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSaveDialog.VTable, self.vtable).GetProperties(@ptrCast(*const IFileSaveDialog, self), ppStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSaveDialog_ApplyProperties(self: *const T, psi: ?*IShellItem, pStore: ?*IPropertyStore, hwnd: ?HWND, pSink: ?*IFileOperationProgressSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSaveDialog.VTable, self.vtable).ApplyProperties(@ptrCast(*const IFileSaveDialog, self), psi, pStore, hwnd, pSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileOpenDialog_Value = @import("../zig.zig").Guid.initString("d57c7288-d4ad-4768-be02-9d969532d960");
pub const IID_IFileOpenDialog = &IID_IFileOpenDialog_Value;
pub const IFileOpenDialog = extern struct {
    pub const VTable = extern struct {
        base: IFileDialog.VTable,
        GetResults: fn(
            self: *const IFileOpenDialog,
            ppenum: ?*?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedItems: fn(
            self: *const IFileOpenDialog,
            ppsai: ?*?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileDialog.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOpenDialog_GetResults(self: *const T, ppenum: ?*?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOpenDialog.VTable, self.vtable).GetResults(@ptrCast(*const IFileOpenDialog, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileOpenDialog_GetSelectedItems(self: *const T, ppsai: ?*?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileOpenDialog.VTable, self.vtable).GetSelectedItems(@ptrCast(*const IFileOpenDialog, self), ppsai);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CDCONTROLSTATEF = enum(i32) {
    INACTIVE = 0,
    ENABLED = 1,
    VISIBLE = 2,
    ENABLEDVISIBLE = 3,
};
pub const CDCS_INACTIVE = CDCONTROLSTATEF.INACTIVE;
pub const CDCS_ENABLED = CDCONTROLSTATEF.ENABLED;
pub const CDCS_VISIBLE = CDCONTROLSTATEF.VISIBLE;
pub const CDCS_ENABLEDVISIBLE = CDCONTROLSTATEF.ENABLEDVISIBLE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileDialogCustomize_Value = @import("../zig.zig").Guid.initString("e6fdd21a-163f-4975-9c8c-a69f1ba37034");
pub const IID_IFileDialogCustomize = &IID_IFileDialogCustomize_Value;
pub const IFileDialogCustomize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableOpenDropDown: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMenu: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pszLabel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPushButton: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pszLabel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComboBox: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRadioButtonList: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddCheckButton: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pszLabel: ?[*:0]const u16,
            bChecked: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEditBox: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSeparator: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddText: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControlLabel: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pszLabel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlState: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pdwState: ?*CDCONTROLSTATEF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControlState: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            dwState: CDCONTROLSTATEF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEditBoxText: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            ppszText: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEditBoxText: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCheckButtonState: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pbChecked: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCheckButtonState: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            bChecked: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddControlItem: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            dwIDItem: u32,
            pszLabel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveControlItem: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            dwIDItem: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllControlItems: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlItemState: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            dwIDItem: u32,
            pdwState: ?*CDCONTROLSTATEF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControlItemState: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            dwIDItem: u32,
            dwState: CDCONTROLSTATEF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedControlItem: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pdwIDItem: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelectedControlItem: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            dwIDItem: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartVisualGroup: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            pszLabel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndVisualGroup: fn(
            self: *const IFileDialogCustomize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeProminent: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControlItemText: fn(
            self: *const IFileDialogCustomize,
            dwIDCtl: u32,
            dwIDItem: u32,
            pszLabel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_EnableOpenDropDown(self: *const T, dwIDCtl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).EnableOpenDropDown(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_AddMenu(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).AddMenu(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pszLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_AddPushButton(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).AddPushButton(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pszLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_AddComboBox(self: *const T, dwIDCtl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).AddComboBox(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_AddRadioButtonList(self: *const T, dwIDCtl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).AddRadioButtonList(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_AddCheckButton(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16, bChecked: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).AddCheckButton(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pszLabel, bChecked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_AddEditBox(self: *const T, dwIDCtl: u32, pszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).AddEditBox(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_AddSeparator(self: *const T, dwIDCtl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).AddSeparator(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_AddText(self: *const T, dwIDCtl: u32, pszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).AddText(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_SetControlLabel(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).SetControlLabel(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pszLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_GetControlState(self: *const T, dwIDCtl: u32, pdwState: ?*CDCONTROLSTATEF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).GetControlState(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_SetControlState(self: *const T, dwIDCtl: u32, dwState: CDCONTROLSTATEF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).SetControlState(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, dwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_GetEditBoxText(self: *const T, dwIDCtl: u32, ppszText: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).GetEditBoxText(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, ppszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_SetEditBoxText(self: *const T, dwIDCtl: u32, pszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).SetEditBoxText(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_GetCheckButtonState(self: *const T, dwIDCtl: u32, pbChecked: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).GetCheckButtonState(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pbChecked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_SetCheckButtonState(self: *const T, dwIDCtl: u32, bChecked: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).SetCheckButtonState(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, bChecked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_AddControlItem(self: *const T, dwIDCtl: u32, dwIDItem: u32, pszLabel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).AddControlItem(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, dwIDItem, pszLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_RemoveControlItem(self: *const T, dwIDCtl: u32, dwIDItem: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).RemoveControlItem(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, dwIDItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_RemoveAllControlItems(self: *const T, dwIDCtl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).RemoveAllControlItems(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_GetControlItemState(self: *const T, dwIDCtl: u32, dwIDItem: u32, pdwState: ?*CDCONTROLSTATEF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).GetControlItemState(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, dwIDItem, pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_SetControlItemState(self: *const T, dwIDCtl: u32, dwIDItem: u32, dwState: CDCONTROLSTATEF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).SetControlItemState(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, dwIDItem, dwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_GetSelectedControlItem(self: *const T, dwIDCtl: u32, pdwIDItem: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).GetSelectedControlItem(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pdwIDItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_SetSelectedControlItem(self: *const T, dwIDCtl: u32, dwIDItem: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).SetSelectedControlItem(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, dwIDItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_StartVisualGroup(self: *const T, dwIDCtl: u32, pszLabel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).StartVisualGroup(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, pszLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_EndVisualGroup(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).EndVisualGroup(@ptrCast(*const IFileDialogCustomize, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_MakeProminent(self: *const T, dwIDCtl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).MakeProminent(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogCustomize_SetControlItemText(self: *const T, dwIDCtl: u32, dwIDItem: u32, pszLabel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogCustomize.VTable, self.vtable).SetControlItemText(@ptrCast(*const IFileDialogCustomize, self), dwIDCtl, dwIDItem, pszLabel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ASSOCIATIONLEVEL = enum(i32) {
    MACHINE = 0,
    EFFECTIVE = 1,
    USER = 2,
};
pub const AL_MACHINE = ASSOCIATIONLEVEL.MACHINE;
pub const AL_EFFECTIVE = ASSOCIATIONLEVEL.EFFECTIVE;
pub const AL_USER = ASSOCIATIONLEVEL.USER;

pub const ASSOCIATIONTYPE = enum(i32) {
    FILEEXTENSION = 0,
    URLPROTOCOL = 1,
    STARTMENUCLIENT = 2,
    MIMETYPE = 3,
};
pub const AT_FILEEXTENSION = ASSOCIATIONTYPE.FILEEXTENSION;
pub const AT_URLPROTOCOL = ASSOCIATIONTYPE.URLPROTOCOL;
pub const AT_STARTMENUCLIENT = ASSOCIATIONTYPE.STARTMENUCLIENT;
pub const AT_MIMETYPE = ASSOCIATIONTYPE.MIMETYPE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IApplicationAssociationRegistration_Value = @import("../zig.zig").Guid.initString("4e530b0a-e611-4c77-a3ac-9031d022281b");
pub const IID_IApplicationAssociationRegistration = &IID_IApplicationAssociationRegistration_Value;
pub const IApplicationAssociationRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCurrentDefault: fn(
            self: *const IApplicationAssociationRegistration,
            pszQuery: ?[*:0]const u16,
            atQueryType: ASSOCIATIONTYPE,
            alQueryLevel: ASSOCIATIONLEVEL,
            ppszAssociation: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAppIsDefault: fn(
            self: *const IApplicationAssociationRegistration,
            pszQuery: ?[*:0]const u16,
            atQueryType: ASSOCIATIONTYPE,
            alQueryLevel: ASSOCIATIONLEVEL,
            pszAppRegistryName: ?[*:0]const u16,
            pfDefault: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAppIsDefaultAll: fn(
            self: *const IApplicationAssociationRegistration,
            alQueryLevel: ASSOCIATIONLEVEL,
            pszAppRegistryName: ?[*:0]const u16,
            pfDefault: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAppAsDefault: fn(
            self: *const IApplicationAssociationRegistration,
            pszAppRegistryName: ?[*:0]const u16,
            pszSet: ?[*:0]const u16,
            atSetType: ASSOCIATIONTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAppAsDefaultAll: fn(
            self: *const IApplicationAssociationRegistration,
            pszAppRegistryName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearUserAssociations: fn(
            self: *const IApplicationAssociationRegistration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationAssociationRegistration_QueryCurrentDefault(self: *const T, pszQuery: ?[*:0]const u16, atQueryType: ASSOCIATIONTYPE, alQueryLevel: ASSOCIATIONLEVEL, ppszAssociation: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationAssociationRegistration.VTable, self.vtable).QueryCurrentDefault(@ptrCast(*const IApplicationAssociationRegistration, self), pszQuery, atQueryType, alQueryLevel, ppszAssociation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationAssociationRegistration_QueryAppIsDefault(self: *const T, pszQuery: ?[*:0]const u16, atQueryType: ASSOCIATIONTYPE, alQueryLevel: ASSOCIATIONLEVEL, pszAppRegistryName: ?[*:0]const u16, pfDefault: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationAssociationRegistration.VTable, self.vtable).QueryAppIsDefault(@ptrCast(*const IApplicationAssociationRegistration, self), pszQuery, atQueryType, alQueryLevel, pszAppRegistryName, pfDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationAssociationRegistration_QueryAppIsDefaultAll(self: *const T, alQueryLevel: ASSOCIATIONLEVEL, pszAppRegistryName: ?[*:0]const u16, pfDefault: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationAssociationRegistration.VTable, self.vtable).QueryAppIsDefaultAll(@ptrCast(*const IApplicationAssociationRegistration, self), alQueryLevel, pszAppRegistryName, pfDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationAssociationRegistration_SetAppAsDefault(self: *const T, pszAppRegistryName: ?[*:0]const u16, pszSet: ?[*:0]const u16, atSetType: ASSOCIATIONTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationAssociationRegistration.VTable, self.vtable).SetAppAsDefault(@ptrCast(*const IApplicationAssociationRegistration, self), pszAppRegistryName, pszSet, atSetType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationAssociationRegistration_SetAppAsDefaultAll(self: *const T, pszAppRegistryName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationAssociationRegistration.VTable, self.vtable).SetAppAsDefaultAll(@ptrCast(*const IApplicationAssociationRegistration, self), pszAppRegistryName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationAssociationRegistration_ClearUserAssociations(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationAssociationRegistration.VTable, self.vtable).ClearUserAssociations(@ptrCast(*const IApplicationAssociationRegistration, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DELEGATEITEMID = packed struct {
    cbSize: u16,
    wOuter: u16,
    cbInner: u16,
    rgb: [1]u8,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDelegateFolder_Value = @import("../zig.zig").Guid.initString("add8ba80-002b-11d0-8f0f-00c04fd7d062");
pub const IID_IDelegateFolder = &IID_IDelegateFolder_Value;
pub const IDelegateFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetItemAlloc: fn(
            self: *const IDelegateFolder,
            pmalloc: ?*IMalloc,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDelegateFolder_SetItemAlloc(self: *const T, pmalloc: ?*IMalloc) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDelegateFolder.VTable, self.vtable).SetItemAlloc(@ptrCast(*const IDelegateFolder, self), pmalloc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _BROWSERFRAMEOPTIONS = enum(i32) {
    FO_NONE = 0,
    FO_BROWSER_PERSIST_SETTINGS = 1,
    FO_RENAME_FOLDER_OPTIONS_TOINTERNET = 2,
    FO_BOTH_OPTIONS = 4,
    IF_PREFER_INTERNET_SHORTCUT = 8,
    FO_BROWSE_NO_IN_NEW_PROCESS = 16,
    FO_ENABLE_HYPERLINK_TRACKING = 32,
    FO_USE_IE_OFFLINE_SUPPORT = 64,
    FO_SUBSTITUE_INTERNET_START_PAGE = 128,
    FO_USE_IE_LOGOBANDING = 256,
    FO_ADD_IE_TOCAPTIONBAR = 512,
    FO_USE_DIALUP_REF = 1024,
    FO_USE_IE_TOOLBAR = 2048,
    FO_NO_PARENT_FOLDER_SUPPORT = 4096,
    FO_NO_REOPEN_NEXT_RESTART = 8192,
    FO_GO_HOME_PAGE = 16384,
    FO_PREFER_IEPROCESS = 32768,
    FO_SHOW_NAVIGATION_CANCELLED = 65536,
    FO_USE_IE_STATUSBAR = 131072,
    FO_QUERY_ALL = -1,
};
pub const BFO_NONE = _BROWSERFRAMEOPTIONS.FO_NONE;
pub const BFO_BROWSER_PERSIST_SETTINGS = _BROWSERFRAMEOPTIONS.FO_BROWSER_PERSIST_SETTINGS;
pub const BFO_RENAME_FOLDER_OPTIONS_TOINTERNET = _BROWSERFRAMEOPTIONS.FO_RENAME_FOLDER_OPTIONS_TOINTERNET;
pub const BFO_BOTH_OPTIONS = _BROWSERFRAMEOPTIONS.FO_BOTH_OPTIONS;
pub const BIF_PREFER_INTERNET_SHORTCUT = _BROWSERFRAMEOPTIONS.IF_PREFER_INTERNET_SHORTCUT;
pub const BFO_BROWSE_NO_IN_NEW_PROCESS = _BROWSERFRAMEOPTIONS.FO_BROWSE_NO_IN_NEW_PROCESS;
pub const BFO_ENABLE_HYPERLINK_TRACKING = _BROWSERFRAMEOPTIONS.FO_ENABLE_HYPERLINK_TRACKING;
pub const BFO_USE_IE_OFFLINE_SUPPORT = _BROWSERFRAMEOPTIONS.FO_USE_IE_OFFLINE_SUPPORT;
pub const BFO_SUBSTITUE_INTERNET_START_PAGE = _BROWSERFRAMEOPTIONS.FO_SUBSTITUE_INTERNET_START_PAGE;
pub const BFO_USE_IE_LOGOBANDING = _BROWSERFRAMEOPTIONS.FO_USE_IE_LOGOBANDING;
pub const BFO_ADD_IE_TOCAPTIONBAR = _BROWSERFRAMEOPTIONS.FO_ADD_IE_TOCAPTIONBAR;
pub const BFO_USE_DIALUP_REF = _BROWSERFRAMEOPTIONS.FO_USE_DIALUP_REF;
pub const BFO_USE_IE_TOOLBAR = _BROWSERFRAMEOPTIONS.FO_USE_IE_TOOLBAR;
pub const BFO_NO_PARENT_FOLDER_SUPPORT = _BROWSERFRAMEOPTIONS.FO_NO_PARENT_FOLDER_SUPPORT;
pub const BFO_NO_REOPEN_NEXT_RESTART = _BROWSERFRAMEOPTIONS.FO_NO_REOPEN_NEXT_RESTART;
pub const BFO_GO_HOME_PAGE = _BROWSERFRAMEOPTIONS.FO_GO_HOME_PAGE;
pub const BFO_PREFER_IEPROCESS = _BROWSERFRAMEOPTIONS.FO_PREFER_IEPROCESS;
pub const BFO_SHOW_NAVIGATION_CANCELLED = _BROWSERFRAMEOPTIONS.FO_SHOW_NAVIGATION_CANCELLED;
pub const BFO_USE_IE_STATUSBAR = _BROWSERFRAMEOPTIONS.FO_USE_IE_STATUSBAR;
pub const BFO_QUERY_ALL = _BROWSERFRAMEOPTIONS.FO_QUERY_ALL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBrowserFrameOptions_Value = @import("../zig.zig").Guid.initString("10df43c8-1dbe-11d3-8b34-006097df5bd4");
pub const IID_IBrowserFrameOptions = &IID_IBrowserFrameOptions_Value;
pub const IBrowserFrameOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameOptions: fn(
            self: *const IBrowserFrameOptions,
            dwMask: u32,
            pdwOptions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserFrameOptions_GetFrameOptions(self: *const T, dwMask: u32, pdwOptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserFrameOptions.VTable, self.vtable).GetFrameOptions(@ptrCast(*const IBrowserFrameOptions, self), dwMask, pdwOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NWMF = enum(i32) {
    UNLOADING = 1,
    USERINITED = 2,
    FIRST = 4,
    OVERRIDEKEY = 8,
    SHOWHELP = 16,
    HTMLDIALOG = 32,
    FROMDIALOGCHILD = 64,
    USERREQUESTED = 128,
    USERALLOWED = 256,
    FORCEWINDOW = 65536,
    FORCETAB = 131072,
    SUGGESTWINDOW = 262144,
    SUGGESTTAB = 524288,
    INACTIVETAB = 1048576,
};
pub const NWMF_UNLOADING = NWMF.UNLOADING;
pub const NWMF_USERINITED = NWMF.USERINITED;
pub const NWMF_FIRST = NWMF.FIRST;
pub const NWMF_OVERRIDEKEY = NWMF.OVERRIDEKEY;
pub const NWMF_SHOWHELP = NWMF.SHOWHELP;
pub const NWMF_HTMLDIALOG = NWMF.HTMLDIALOG;
pub const NWMF_FROMDIALOGCHILD = NWMF.FROMDIALOGCHILD;
pub const NWMF_USERREQUESTED = NWMF.USERREQUESTED;
pub const NWMF_USERALLOWED = NWMF.USERALLOWED;
pub const NWMF_FORCEWINDOW = NWMF.FORCEWINDOW;
pub const NWMF_FORCETAB = NWMF.FORCETAB;
pub const NWMF_SUGGESTWINDOW = NWMF.SUGGESTWINDOW;
pub const NWMF_SUGGESTTAB = NWMF.SUGGESTTAB;
pub const NWMF_INACTIVETAB = NWMF.INACTIVETAB;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INewWindowManager_Value = @import("../zig.zig").Guid.initString("d2bc4c84-3f72-4a52-a604-7bcbf3982cbb");
pub const IID_INewWindowManager = &IID_INewWindowManager_Value;
pub const INewWindowManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EvaluateNewWindow: fn(
            self: *const INewWindowManager,
            pszUrl: ?[*:0]const u16,
            pszName: ?[*:0]const u16,
            pszUrlContext: ?[*:0]const u16,
            pszFeatures: ?[*:0]const u16,
            fReplace: BOOL,
            dwFlags: u32,
            dwUserActionTime: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewWindowManager_EvaluateNewWindow(self: *const T, pszUrl: ?[*:0]const u16, pszName: ?[*:0]const u16, pszUrlContext: ?[*:0]const u16, pszFeatures: ?[*:0]const u16, fReplace: BOOL, dwFlags: u32, dwUserActionTime: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewWindowManager.VTable, self.vtable).EvaluateNewWindow(@ptrCast(*const INewWindowManager, self), pszUrl, pszName, pszUrlContext, pszFeatures, fReplace, dwFlags, dwUserActionTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ATTACHMENT_PROMPT = enum(i32) {
    NONE = 0,
    SAVE = 1,
    EXEC = 2,
    EXEC_OR_SAVE = 3,
};
pub const ATTACHMENT_PROMPT_NONE = ATTACHMENT_PROMPT.NONE;
pub const ATTACHMENT_PROMPT_SAVE = ATTACHMENT_PROMPT.SAVE;
pub const ATTACHMENT_PROMPT_EXEC = ATTACHMENT_PROMPT.EXEC;
pub const ATTACHMENT_PROMPT_EXEC_OR_SAVE = ATTACHMENT_PROMPT.EXEC_OR_SAVE;

pub const ATTACHMENT_ACTION = enum(i32) {
    CANCEL = 0,
    SAVE = 1,
    EXEC = 2,
};
pub const ATTACHMENT_ACTION_CANCEL = ATTACHMENT_ACTION.CANCEL;
pub const ATTACHMENT_ACTION_SAVE = ATTACHMENT_ACTION.SAVE;
pub const ATTACHMENT_ACTION_EXEC = ATTACHMENT_ACTION.EXEC;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAttachmentExecute_Value = @import("../zig.zig").Guid.initString("73db1241-1e85-4581-8e4f-a81e1d0f8c57");
pub const IID_IAttachmentExecute = &IID_IAttachmentExecute_Value;
pub const IAttachmentExecute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetClientTitle: fn(
            self: *const IAttachmentExecute,
            pszTitle: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClientGuid: fn(
            self: *const IAttachmentExecute,
            guid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLocalPath: fn(
            self: *const IAttachmentExecute,
            pszLocalPath: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFileName: fn(
            self: *const IAttachmentExecute,
            pszFileName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSource: fn(
            self: *const IAttachmentExecute,
            pszSource: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReferrer: fn(
            self: *const IAttachmentExecute,
            pszReferrer: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckPolicy: fn(
            self: *const IAttachmentExecute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Prompt: fn(
            self: *const IAttachmentExecute,
            hwnd: ?HWND,
            prompt: ATTACHMENT_PROMPT,
            paction: ?*ATTACHMENT_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IAttachmentExecute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IAttachmentExecute,
            hwnd: ?HWND,
            pszVerb: ?[*:0]const u16,
            phProcess: ?*?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveWithUI: fn(
            self: *const IAttachmentExecute,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearClientState: fn(
            self: *const IAttachmentExecute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_SetClientTitle(self: *const T, pszTitle: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).SetClientTitle(@ptrCast(*const IAttachmentExecute, self), pszTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_SetClientGuid(self: *const T, guid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).SetClientGuid(@ptrCast(*const IAttachmentExecute, self), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_SetLocalPath(self: *const T, pszLocalPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).SetLocalPath(@ptrCast(*const IAttachmentExecute, self), pszLocalPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_SetFileName(self: *const T, pszFileName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).SetFileName(@ptrCast(*const IAttachmentExecute, self), pszFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_SetSource(self: *const T, pszSource: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).SetSource(@ptrCast(*const IAttachmentExecute, self), pszSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_SetReferrer(self: *const T, pszReferrer: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).SetReferrer(@ptrCast(*const IAttachmentExecute, self), pszReferrer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_CheckPolicy(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).CheckPolicy(@ptrCast(*const IAttachmentExecute, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_Prompt(self: *const T, hwnd: ?HWND, prompt: ATTACHMENT_PROMPT, paction: ?*ATTACHMENT_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).Prompt(@ptrCast(*const IAttachmentExecute, self), hwnd, prompt, paction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_Save(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).Save(@ptrCast(*const IAttachmentExecute, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_Execute(self: *const T, hwnd: ?HWND, pszVerb: ?[*:0]const u16, phProcess: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).Execute(@ptrCast(*const IAttachmentExecute, self), hwnd, pszVerb, phProcess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_SaveWithUI(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).SaveWithUI(@ptrCast(*const IAttachmentExecute, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttachmentExecute_ClearClientState(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAttachmentExecute.VTable, self.vtable).ClearClientState(@ptrCast(*const IAttachmentExecute, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SMDATA = extern struct {
    dwMask: u32,
    dwFlags: u32,
    hmenu: ?HMENU,
    hwnd: ?HWND,
    uId: u32,
    uIdParent: u32,
    uIdAncestor: u32,
    punk: ?*IUnknown,
    pidlFolder: ?*ITEMIDLIST,
    pidlItem: ?*ITEMIDLIST,
    psf: ?*IShellFolder,
    pvUserData: ?*anyopaque,
};

pub const SMINFO = extern struct {
    dwMask: u32,
    dwType: u32,
    dwFlags: u32,
    iIcon: i32,
};

pub const SMCSHCHANGENOTIFYSTRUCT = extern struct {
    lEvent: i32,
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
};

pub const SMINFOMASK = enum(i32) {
    TYPE = 1,
    FLAGS = 2,
    ICON = 4,
};
pub const SMIM_TYPE = SMINFOMASK.TYPE;
pub const SMIM_FLAGS = SMINFOMASK.FLAGS;
pub const SMIM_ICON = SMINFOMASK.ICON;

pub const SMINFOTYPE = enum(i32) {
    EPARATOR = 1,
    TRING = 2,
};
pub const SMIT_SEPARATOR = SMINFOTYPE.EPARATOR;
pub const SMIT_STRING = SMINFOTYPE.TRING;

pub const SMINFOFLAGS = enum(i32) {
    ICON = 1,
    ACCELERATOR = 2,
    DROPTARGET = 4,
    SUBMENU = 8,
    CHECKED = 32,
    DROPCASCADE = 64,
    HIDDEN = 128,
    DISABLED = 256,
    TRACKPOPUP = 512,
    DEMOTED = 1024,
    ALTSTATE = 2048,
    DRAGNDROP = 4096,
    NEW = 8192,
};
pub const SMIF_ICON = SMINFOFLAGS.ICON;
pub const SMIF_ACCELERATOR = SMINFOFLAGS.ACCELERATOR;
pub const SMIF_DROPTARGET = SMINFOFLAGS.DROPTARGET;
pub const SMIF_SUBMENU = SMINFOFLAGS.SUBMENU;
pub const SMIF_CHECKED = SMINFOFLAGS.CHECKED;
pub const SMIF_DROPCASCADE = SMINFOFLAGS.DROPCASCADE;
pub const SMIF_HIDDEN = SMINFOFLAGS.HIDDEN;
pub const SMIF_DISABLED = SMINFOFLAGS.DISABLED;
pub const SMIF_TRACKPOPUP = SMINFOFLAGS.TRACKPOPUP;
pub const SMIF_DEMOTED = SMINFOFLAGS.DEMOTED;
pub const SMIF_ALTSTATE = SMINFOFLAGS.ALTSTATE;
pub const SMIF_DRAGNDROP = SMINFOFLAGS.DRAGNDROP;
pub const SMIF_NEW = SMINFOFLAGS.NEW;

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellMenuCallback_Value = @import("../zig.zig").Guid.initString("4ca300a1-9b8d-11d1-8b22-00c04fd918d0");
pub const IID_IShellMenuCallback = &IID_IShellMenuCallback_Value;
pub const IShellMenuCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CallbackSM: fn(
            self: *const IShellMenuCallback,
            psmd: ?*SMDATA,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenuCallback_CallbackSM(self: *const T, psmd: ?*SMDATA, uMsg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenuCallback.VTable, self.vtable).CallbackSM(@ptrCast(*const IShellMenuCallback, self), psmd, uMsg, wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellMenu_Value = @import("../zig.zig").Guid.initString("ee1f7637-e138-11d1-8379-00c04fd918d0");
pub const IID_IShellMenu = &IID_IShellMenu_Value;
pub const IShellMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IShellMenu,
            psmc: ?*IShellMenuCallback,
            uId: u32,
            uIdAncestor: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMenuInfo: fn(
            self: *const IShellMenu,
            ppsmc: ?*?*IShellMenuCallback,
            puId: ?*u32,
            puIdAncestor: ?*u32,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShellFolder: fn(
            self: *const IShellMenu,
            psf: ?*IShellFolder,
            pidlFolder: ?*ITEMIDLIST,
            hKey: ?HKEY,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShellFolder: fn(
            self: *const IShellMenu,
            pdwFlags: ?*u32,
            ppidl: ?*?*ITEMIDLIST,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMenu: fn(
            self: *const IShellMenu,
            hmenu: ?HMENU,
            hwnd: ?HWND,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMenu: fn(
            self: *const IShellMenu,
            phmenu: ?*?HMENU,
            phwnd: ?*?HWND,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateItem: fn(
            self: *const IShellMenu,
            psmd: ?*SMDATA,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IShellMenu,
            psmd: ?*SMDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMenuToolbar: fn(
            self: *const IShellMenu,
            punk: ?*IUnknown,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenu_Initialize(self: *const T, psmc: ?*IShellMenuCallback, uId: u32, uIdAncestor: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenu.VTable, self.vtable).Initialize(@ptrCast(*const IShellMenu, self), psmc, uId, uIdAncestor, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenu_GetMenuInfo(self: *const T, ppsmc: ?*?*IShellMenuCallback, puId: ?*u32, puIdAncestor: ?*u32, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenu.VTable, self.vtable).GetMenuInfo(@ptrCast(*const IShellMenu, self), ppsmc, puId, puIdAncestor, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenu_SetShellFolder(self: *const T, psf: ?*IShellFolder, pidlFolder: ?*ITEMIDLIST, hKey: ?HKEY, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenu.VTable, self.vtable).SetShellFolder(@ptrCast(*const IShellMenu, self), psf, pidlFolder, hKey, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenu_GetShellFolder(self: *const T, pdwFlags: ?*u32, ppidl: ?*?*ITEMIDLIST, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenu.VTable, self.vtable).GetShellFolder(@ptrCast(*const IShellMenu, self), pdwFlags, ppidl, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenu_SetMenu(self: *const T, hmenu: ?HMENU, hwnd: ?HWND, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenu.VTable, self.vtable).SetMenu(@ptrCast(*const IShellMenu, self), hmenu, hwnd, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenu_GetMenu(self: *const T, phmenu: ?*?HMENU, phwnd: ?*?HWND, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenu.VTable, self.vtable).GetMenu(@ptrCast(*const IShellMenu, self), phmenu, phwnd, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenu_InvalidateItem(self: *const T, psmd: ?*SMDATA, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenu.VTable, self.vtable).InvalidateItem(@ptrCast(*const IShellMenu, self), psmd, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenu_GetState(self: *const T, psmd: ?*SMDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenu.VTable, self.vtable).GetState(@ptrCast(*const IShellMenu, self), psmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellMenu_SetMenuToolbar(self: *const T, punk: ?*IUnknown, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellMenu.VTable, self.vtable).SetMenuToolbar(@ptrCast(*const IShellMenu, self), punk, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const KF_CATEGORY = enum(i32) {
    VIRTUAL = 1,
    FIXED = 2,
    COMMON = 3,
    PERUSER = 4,
};
pub const KF_CATEGORY_VIRTUAL = KF_CATEGORY.VIRTUAL;
pub const KF_CATEGORY_FIXED = KF_CATEGORY.FIXED;
pub const KF_CATEGORY_COMMON = KF_CATEGORY.COMMON;
pub const KF_CATEGORY_PERUSER = KF_CATEGORY.PERUSER;

pub const _KF_DEFINITION_FLAGS = enum(i32) {
    LOCAL_REDIRECT_ONLY = 2,
    ROAMABLE = 4,
    PRECREATE = 8,
    STREAM = 16,
    PUBLISHEXPANDEDPATH = 32,
    NO_REDIRECT_UI = 64,
};
pub const KFDF_LOCAL_REDIRECT_ONLY = _KF_DEFINITION_FLAGS.LOCAL_REDIRECT_ONLY;
pub const KFDF_ROAMABLE = _KF_DEFINITION_FLAGS.ROAMABLE;
pub const KFDF_PRECREATE = _KF_DEFINITION_FLAGS.PRECREATE;
pub const KFDF_STREAM = _KF_DEFINITION_FLAGS.STREAM;
pub const KFDF_PUBLISHEXPANDEDPATH = _KF_DEFINITION_FLAGS.PUBLISHEXPANDEDPATH;
pub const KFDF_NO_REDIRECT_UI = _KF_DEFINITION_FLAGS.NO_REDIRECT_UI;

pub const _KF_REDIRECT_FLAGS = enum(i32) {
    USER_EXCLUSIVE = 1,
    COPY_SOURCE_DACL = 2,
    OWNER_USER = 4,
    SET_OWNER_EXPLICIT = 8,
    CHECK_ONLY = 16,
    WITH_UI = 32,
    UNPIN = 64,
    PIN = 128,
    COPY_CONTENTS = 512,
    DEL_SOURCE_CONTENTS = 1024,
    EXCLUDE_ALL_KNOWN_SUBFOLDERS = 2048,
};
pub const KF_REDIRECT_USER_EXCLUSIVE = _KF_REDIRECT_FLAGS.USER_EXCLUSIVE;
pub const KF_REDIRECT_COPY_SOURCE_DACL = _KF_REDIRECT_FLAGS.COPY_SOURCE_DACL;
pub const KF_REDIRECT_OWNER_USER = _KF_REDIRECT_FLAGS.OWNER_USER;
pub const KF_REDIRECT_SET_OWNER_EXPLICIT = _KF_REDIRECT_FLAGS.SET_OWNER_EXPLICIT;
pub const KF_REDIRECT_CHECK_ONLY = _KF_REDIRECT_FLAGS.CHECK_ONLY;
pub const KF_REDIRECT_WITH_UI = _KF_REDIRECT_FLAGS.WITH_UI;
pub const KF_REDIRECT_UNPIN = _KF_REDIRECT_FLAGS.UNPIN;
pub const KF_REDIRECT_PIN = _KF_REDIRECT_FLAGS.PIN;
pub const KF_REDIRECT_COPY_CONTENTS = _KF_REDIRECT_FLAGS.COPY_CONTENTS;
pub const KF_REDIRECT_DEL_SOURCE_CONTENTS = _KF_REDIRECT_FLAGS.DEL_SOURCE_CONTENTS;
pub const KF_REDIRECT_EXCLUDE_ALL_KNOWN_SUBFOLDERS = _KF_REDIRECT_FLAGS.EXCLUDE_ALL_KNOWN_SUBFOLDERS;

pub const _KF_REDIRECTION_CAPABILITIES = enum(i32) {
    ALLOW_ALL = 255,
    REDIRECTABLE = 1,
    DENY_ALL = 1048320,
    DENY_POLICY_REDIRECTED = 256,
    DENY_POLICY = 512,
    DENY_PERMISSIONS = 1024,
};
pub const KF_REDIRECTION_CAPABILITIES_ALLOW_ALL = _KF_REDIRECTION_CAPABILITIES.ALLOW_ALL;
pub const KF_REDIRECTION_CAPABILITIES_REDIRECTABLE = _KF_REDIRECTION_CAPABILITIES.REDIRECTABLE;
pub const KF_REDIRECTION_CAPABILITIES_DENY_ALL = _KF_REDIRECTION_CAPABILITIES.DENY_ALL;
pub const KF_REDIRECTION_CAPABILITIES_DENY_POLICY_REDIRECTED = _KF_REDIRECTION_CAPABILITIES.DENY_POLICY_REDIRECTED;
pub const KF_REDIRECTION_CAPABILITIES_DENY_POLICY = _KF_REDIRECTION_CAPABILITIES.DENY_POLICY;
pub const KF_REDIRECTION_CAPABILITIES_DENY_PERMISSIONS = _KF_REDIRECTION_CAPABILITIES.DENY_PERMISSIONS;

pub const KNOWNFOLDER_DEFINITION = extern struct {
    category: KF_CATEGORY,
    pszName: ?PWSTR,
    pszDescription: ?PWSTR,
    fidParent: Guid,
    pszRelativePath: ?PWSTR,
    pszParsingName: ?PWSTR,
    pszTooltip: ?PWSTR,
    pszLocalizedName: ?PWSTR,
    pszIcon: ?PWSTR,
    pszSecurity: ?PWSTR,
    dwAttributes: u32,
    kfdFlags: u32,
    ftidType: Guid,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IKnownFolder_Value = @import("../zig.zig").Guid.initString("3aa7af7e-9b36-420c-a8e3-f77d4674a488");
pub const IID_IKnownFolder = &IID_IKnownFolder_Value;
pub const IKnownFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IKnownFolder,
            pkfid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategory: fn(
            self: *const IKnownFolder,
            pCategory: ?*KF_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShellItem: fn(
            self: *const IKnownFolder,
            dwFlags: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: fn(
            self: *const IKnownFolder,
            dwFlags: u32,
            ppszPath: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPath: fn(
            self: *const IKnownFolder,
            dwFlags: u32,
            pszPath: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDList: fn(
            self: *const IKnownFolder,
            dwFlags: u32,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolderType: fn(
            self: *const IKnownFolder,
            pftid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRedirectionCapabilities: fn(
            self: *const IKnownFolder,
            pCapabilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolderDefinition: fn(
            self: *const IKnownFolder,
            pKFD: ?*KNOWNFOLDER_DEFINITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolder_GetId(self: *const T, pkfid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolder.VTable, self.vtable).GetId(@ptrCast(*const IKnownFolder, self), pkfid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolder_GetCategory(self: *const T, pCategory: ?*KF_CATEGORY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolder.VTable, self.vtable).GetCategory(@ptrCast(*const IKnownFolder, self), pCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolder_GetShellItem(self: *const T, dwFlags: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolder.VTable, self.vtable).GetShellItem(@ptrCast(*const IKnownFolder, self), dwFlags, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolder_GetPath(self: *const T, dwFlags: u32, ppszPath: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolder.VTable, self.vtable).GetPath(@ptrCast(*const IKnownFolder, self), dwFlags, ppszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolder_SetPath(self: *const T, dwFlags: u32, pszPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolder.VTable, self.vtable).SetPath(@ptrCast(*const IKnownFolder, self), dwFlags, pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolder_GetIDList(self: *const T, dwFlags: u32, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolder.VTable, self.vtable).GetIDList(@ptrCast(*const IKnownFolder, self), dwFlags, ppidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolder_GetFolderType(self: *const T, pftid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolder.VTable, self.vtable).GetFolderType(@ptrCast(*const IKnownFolder, self), pftid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolder_GetRedirectionCapabilities(self: *const T, pCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolder.VTable, self.vtable).GetRedirectionCapabilities(@ptrCast(*const IKnownFolder, self), pCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolder_GetFolderDefinition(self: *const T, pKFD: ?*KNOWNFOLDER_DEFINITION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolder.VTable, self.vtable).GetFolderDefinition(@ptrCast(*const IKnownFolder, self), pKFD);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FFFP_MODE = enum(i32) {
    EXACTMATCH = 0,
    NEARESTPARENTMATCH = 1,
};
pub const FFFP_EXACTMATCH = FFFP_MODE.EXACTMATCH;
pub const FFFP_NEARESTPARENTMATCH = FFFP_MODE.NEARESTPARENTMATCH;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IKnownFolderManager_Value = @import("../zig.zig").Guid.initString("8be2d872-86aa-4d47-b776-32cca40c7018");
pub const IID_IKnownFolderManager = &IID_IKnownFolderManager_Value;
pub const IKnownFolderManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FolderIdFromCsidl: fn(
            self: *const IKnownFolderManager,
            nCsidl: i32,
            pfid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FolderIdToCsidl: fn(
            self: *const IKnownFolderManager,
            rfid: ?*const Guid,
            pnCsidl: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolderIds: fn(
            self: *const IKnownFolderManager,
            ppKFId: [*]?*Guid,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolder: fn(
            self: *const IKnownFolderManager,
            rfid: ?*const Guid,
            ppkf: ?*?*IKnownFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolderByName: fn(
            self: *const IKnownFolderManager,
            pszCanonicalName: ?[*:0]const u16,
            ppkf: ?*?*IKnownFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterFolder: fn(
            self: *const IKnownFolderManager,
            rfid: ?*const Guid,
            pKFD: ?*const KNOWNFOLDER_DEFINITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterFolder: fn(
            self: *const IKnownFolderManager,
            rfid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindFolderFromPath: fn(
            self: *const IKnownFolderManager,
            pszPath: ?[*:0]const u16,
            mode: FFFP_MODE,
            ppkf: ?*?*IKnownFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindFolderFromIDList: fn(
            self: *const IKnownFolderManager,
            pidl: ?*ITEMIDLIST,
            ppkf: ?*?*IKnownFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Redirect: fn(
            self: *const IKnownFolderManager,
            rfid: ?*const Guid,
            hwnd: ?HWND,
            flags: u32,
            pszTargetPath: ?[*:0]const u16,
            cFolders: u32,
            pExclusion: ?[*]const Guid,
            ppszError: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_FolderIdFromCsidl(self: *const T, nCsidl: i32, pfid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).FolderIdFromCsidl(@ptrCast(*const IKnownFolderManager, self), nCsidl, pfid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_FolderIdToCsidl(self: *const T, rfid: ?*const Guid, pnCsidl: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).FolderIdToCsidl(@ptrCast(*const IKnownFolderManager, self), rfid, pnCsidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_GetFolderIds(self: *const T, ppKFId: [*]?*Guid, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).GetFolderIds(@ptrCast(*const IKnownFolderManager, self), ppKFId, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_GetFolder(self: *const T, rfid: ?*const Guid, ppkf: ?*?*IKnownFolder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).GetFolder(@ptrCast(*const IKnownFolderManager, self), rfid, ppkf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_GetFolderByName(self: *const T, pszCanonicalName: ?[*:0]const u16, ppkf: ?*?*IKnownFolder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).GetFolderByName(@ptrCast(*const IKnownFolderManager, self), pszCanonicalName, ppkf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_RegisterFolder(self: *const T, rfid: ?*const Guid, pKFD: ?*const KNOWNFOLDER_DEFINITION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).RegisterFolder(@ptrCast(*const IKnownFolderManager, self), rfid, pKFD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_UnregisterFolder(self: *const T, rfid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).UnregisterFolder(@ptrCast(*const IKnownFolderManager, self), rfid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_FindFolderFromPath(self: *const T, pszPath: ?[*:0]const u16, mode: FFFP_MODE, ppkf: ?*?*IKnownFolder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).FindFolderFromPath(@ptrCast(*const IKnownFolderManager, self), pszPath, mode, ppkf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_FindFolderFromIDList(self: *const T, pidl: ?*ITEMIDLIST, ppkf: ?*?*IKnownFolder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).FindFolderFromIDList(@ptrCast(*const IKnownFolderManager, self), pidl, ppkf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKnownFolderManager_Redirect(self: *const T, rfid: ?*const Guid, hwnd: ?HWND, flags: u32, pszTargetPath: ?[*:0]const u16, cFolders: u32, pExclusion: ?[*]const Guid, ppszError: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKnownFolderManager.VTable, self.vtable).Redirect(@ptrCast(*const IKnownFolderManager, self), rfid, hwnd, flags, pszTargetPath, cFolders, pExclusion, ppszError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHARE_ROLE = enum(i32) {
    INVALID = -1,
    READER = 0,
    CONTRIBUTOR = 1,
    CO_OWNER = 2,
    OWNER = 3,
    CUSTOM = 4,
    MIXED = 5,
};
pub const SHARE_ROLE_INVALID = SHARE_ROLE.INVALID;
pub const SHARE_ROLE_READER = SHARE_ROLE.READER;
pub const SHARE_ROLE_CONTRIBUTOR = SHARE_ROLE.CONTRIBUTOR;
pub const SHARE_ROLE_CO_OWNER = SHARE_ROLE.CO_OWNER;
pub const SHARE_ROLE_OWNER = SHARE_ROLE.OWNER;
pub const SHARE_ROLE_CUSTOM = SHARE_ROLE.CUSTOM;
pub const SHARE_ROLE_MIXED = SHARE_ROLE.MIXED;

pub const DEF_SHARE_ID = enum(i32) {
    USERS = 1,
    PUBLIC = 2,
};
pub const DEFSHAREID_USERS = DEF_SHARE_ID.USERS;
pub const DEFSHAREID_PUBLIC = DEF_SHARE_ID.PUBLIC;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISharingConfigurationManager_Value = @import("../zig.zig").Guid.initString("b4cd448a-9c86-4466-9201-2e62105b87ae");
pub const IID_ISharingConfigurationManager = &IID_ISharingConfigurationManager_Value;
pub const ISharingConfigurationManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateShare: fn(
            self: *const ISharingConfigurationManager,
            dsid: DEF_SHARE_ID,
            role: SHARE_ROLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteShare: fn(
            self: *const ISharingConfigurationManager,
            dsid: DEF_SHARE_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShareExists: fn(
            self: *const ISharingConfigurationManager,
            dsid: DEF_SHARE_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSharePermissions: fn(
            self: *const ISharingConfigurationManager,
            dsid: DEF_SHARE_ID,
            pRole: ?*SHARE_ROLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SharePrinters: fn(
            self: *const ISharingConfigurationManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopSharingPrinters: fn(
            self: *const ISharingConfigurationManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ArePrintersShared: fn(
            self: *const ISharingConfigurationManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharingConfigurationManager_CreateShare(self: *const T, dsid: DEF_SHARE_ID, role: SHARE_ROLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharingConfigurationManager.VTable, self.vtable).CreateShare(@ptrCast(*const ISharingConfigurationManager, self), dsid, role);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharingConfigurationManager_DeleteShare(self: *const T, dsid: DEF_SHARE_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharingConfigurationManager.VTable, self.vtable).DeleteShare(@ptrCast(*const ISharingConfigurationManager, self), dsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharingConfigurationManager_ShareExists(self: *const T, dsid: DEF_SHARE_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharingConfigurationManager.VTable, self.vtable).ShareExists(@ptrCast(*const ISharingConfigurationManager, self), dsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharingConfigurationManager_GetSharePermissions(self: *const T, dsid: DEF_SHARE_ID, pRole: ?*SHARE_ROLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharingConfigurationManager.VTable, self.vtable).GetSharePermissions(@ptrCast(*const ISharingConfigurationManager, self), dsid, pRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharingConfigurationManager_SharePrinters(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharingConfigurationManager.VTable, self.vtable).SharePrinters(@ptrCast(*const ISharingConfigurationManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharingConfigurationManager_StopSharingPrinters(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharingConfigurationManager.VTable, self.vtable).StopSharingPrinters(@ptrCast(*const ISharingConfigurationManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharingConfigurationManager_ArePrintersShared(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharingConfigurationManager.VTable, self.vtable).ArePrintersShared(@ptrCast(*const ISharingConfigurationManager, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRelatedItem_Value = @import("../zig.zig").Guid.initString("a73ce67a-8ab1-44f1-8d43-d2fcbf6b1cd0");
pub const IID_IRelatedItem = &IID_IRelatedItem_Value;
pub const IRelatedItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemIDList: fn(
            self: *const IRelatedItem,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const IRelatedItem,
            ppsi: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRelatedItem_GetItemIDList(self: *const T, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRelatedItem.VTable, self.vtable).GetItemIDList(@ptrCast(*const IRelatedItem, self), ppidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRelatedItem_GetItem(self: *const T, ppsi: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRelatedItem.VTable, self.vtable).GetItem(@ptrCast(*const IRelatedItem, self), ppsi);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IIdentityName_Value = @import("../zig.zig").Guid.initString("7d903fca-d6f9-4810-8332-946c0177e247");
pub const IID_IIdentityName = &IID_IIdentityName_Value;
pub const IIdentityName = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRelatedItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDelegateItem_Value = @import("../zig.zig").Guid.initString("3c5a1c94-c951-4cb7-bb6d-3b93f30cce93");
pub const IID_IDelegateItem = &IID_IDelegateItem_Value;
pub const IDelegateItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRelatedItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICurrentItem_Value = @import("../zig.zig").Guid.initString("240a7174-d653-4a1d-a6d3-d4943cfbfe3d");
pub const IID_ICurrentItem = &IID_ICurrentItem_Value;
pub const ICurrentItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRelatedItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITransferMediumItem_Value = @import("../zig.zig").Guid.initString("77f295d5-2d6f-4e19-b8ae-322f3e721ab5");
pub const IID_ITransferMediumItem = &IID_ITransferMediumItem_Value;
pub const ITransferMediumItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRelatedItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDisplayItem_Value = @import("../zig.zig").Guid.initString("c6fd5997-9f6b-4888-8703-94e80e8cde3f");
pub const IID_IDisplayItem = &IID_IDisplayItem_Value;
pub const IDisplayItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRelatedItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IViewStateIdentityItem_Value = @import("../zig.zig").Guid.initString("9d264146-a94f-4195-9f9f-3bb12ce0c955");
pub const IID_IViewStateIdentityItem = &IID_IViewStateIdentityItem_Value;
pub const IViewStateIdentityItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRelatedItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPreviewItem_Value = @import("../zig.zig").Guid.initString("36149969-0a8f-49c8-8b00-4aecb20222fb");
pub const IID_IPreviewItem = &IID_IPreviewItem_Value;
pub const IPreviewItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRelatedItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDestinationStreamFactory_Value = @import("../zig.zig").Guid.initString("8a87781b-39a7-4a1f-aab3-a39b9c34a7d9");
pub const IID_IDestinationStreamFactory = &IID_IDestinationStreamFactory_Value;
pub const IDestinationStreamFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDestinationStream: fn(
            self: *const IDestinationStreamFactory,
            ppstm: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDestinationStreamFactory_GetDestinationStream(self: *const T, ppstm: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDestinationStreamFactory.VTable, self.vtable).GetDestinationStream(@ptrCast(*const IDestinationStreamFactory, self), ppstm);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICreateProcessInputs_Value = @import("../zig.zig").Guid.initString("f6ef6140-e26f-4d82-bac4-e9ba5fd239a8");
pub const IID_ICreateProcessInputs = &IID_ICreateProcessInputs_Value;
pub const ICreateProcessInputs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCreateFlags: fn(
            self: *const ICreateProcessInputs,
            pdwCreationFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCreateFlags: fn(
            self: *const ICreateProcessInputs,
            dwCreationFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddCreateFlags: fn(
            self: *const ICreateProcessInputs,
            dwCreationFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHotKey: fn(
            self: *const ICreateProcessInputs,
            wHotKey: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStartupFlags: fn(
            self: *const ICreateProcessInputs,
            dwStartupInfoFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTitle: fn(
            self: *const ICreateProcessInputs,
            pszTitle: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnvironmentVariable: fn(
            self: *const ICreateProcessInputs,
            pszName: ?[*:0]const u16,
            pszValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateProcessInputs_GetCreateFlags(self: *const T, pdwCreationFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateProcessInputs.VTable, self.vtable).GetCreateFlags(@ptrCast(*const ICreateProcessInputs, self), pdwCreationFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateProcessInputs_SetCreateFlags(self: *const T, dwCreationFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateProcessInputs.VTable, self.vtable).SetCreateFlags(@ptrCast(*const ICreateProcessInputs, self), dwCreationFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateProcessInputs_AddCreateFlags(self: *const T, dwCreationFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateProcessInputs.VTable, self.vtable).AddCreateFlags(@ptrCast(*const ICreateProcessInputs, self), dwCreationFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateProcessInputs_SetHotKey(self: *const T, wHotKey: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateProcessInputs.VTable, self.vtable).SetHotKey(@ptrCast(*const ICreateProcessInputs, self), wHotKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateProcessInputs_AddStartupFlags(self: *const T, dwStartupInfoFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateProcessInputs.VTable, self.vtable).AddStartupFlags(@ptrCast(*const ICreateProcessInputs, self), dwStartupInfoFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateProcessInputs_SetTitle(self: *const T, pszTitle: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateProcessInputs.VTable, self.vtable).SetTitle(@ptrCast(*const ICreateProcessInputs, self), pszTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateProcessInputs_SetEnvironmentVariable(self: *const T, pszName: ?[*:0]const u16, pszValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateProcessInputs.VTable, self.vtable).SetEnvironmentVariable(@ptrCast(*const ICreateProcessInputs, self), pszName, pszValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICreatingProcess_Value = @import("../zig.zig").Guid.initString("c2b937a9-3110-4398-8a56-f34c6342d244");
pub const IID_ICreatingProcess = &IID_ICreatingProcess_Value;
pub const ICreatingProcess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCreating: fn(
            self: *const ICreatingProcess,
            pcpi: ?*ICreateProcessInputs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreatingProcess_OnCreating(self: *const T, pcpi: ?*ICreateProcessInputs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreatingProcess.VTable, self.vtable).OnCreating(@ptrCast(*const ICreatingProcess, self), pcpi);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ILaunchUIContext_Value = @import("../zig.zig").Guid.initString("1791e8f6-21c7-4340-882a-a6a93e3fd73b");
pub const IID_ILaunchUIContext = &IID_ILaunchUIContext_Value;
pub const ILaunchUIContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAssociatedWindow: fn(
            self: *const ILaunchUIContext,
            value: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTabGroupingPreference: fn(
            self: *const ILaunchUIContext,
            value: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILaunchUIContext_SetAssociatedWindow(self: *const T, value: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILaunchUIContext.VTable, self.vtable).SetAssociatedWindow(@ptrCast(*const ILaunchUIContext, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILaunchUIContext_SetTabGroupingPreference(self: *const T, value: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILaunchUIContext.VTable, self.vtable).SetTabGroupingPreference(@ptrCast(*const ILaunchUIContext, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ILaunchUIContextProvider_Value = @import("../zig.zig").Guid.initString("0d12c4c8-a3d9-4e24-94c1-0e20c5a956c4");
pub const IID_ILaunchUIContextProvider = &IID_ILaunchUIContextProvider_Value;
pub const ILaunchUIContextProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateContext: fn(
            self: *const ILaunchUIContextProvider,
            context: ?*ILaunchUIContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILaunchUIContextProvider_UpdateContext(self: *const T, context: ?*ILaunchUIContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILaunchUIContextProvider.VTable, self.vtable).UpdateContext(@ptrCast(*const ILaunchUIContextProvider, self), context);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _NMCII_FLAGS = enum(i32) {
    NONE = 0,
    ITEMS = 1,
    FOLDERS = 2,
};
pub const NMCII_NONE = _NMCII_FLAGS.NONE;
pub const NMCII_ITEMS = _NMCII_FLAGS.ITEMS;
pub const NMCII_FOLDERS = _NMCII_FLAGS.FOLDERS;

pub const _NMCSAEI_FLAGS = enum(i32) {
    SELECT = 0,
    EDIT = 1,
};
pub const NMCSAEI_SELECT = _NMCSAEI_FLAGS.SELECT;
pub const NMCSAEI_EDIT = _NMCSAEI_FLAGS.EDIT;

// TODO: this type is limited to platform 'windows6.1'
const IID_INewMenuClient_Value = @import("../zig.zig").Guid.initString("dcb07fdc-3bb5-451c-90be-966644fed7b0");
pub const IID_INewMenuClient = &IID_INewMenuClient_Value;
pub const INewMenuClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IncludeItems: fn(
            self: *const INewMenuClient,
            pflags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectAndEditItem: fn(
            self: *const INewMenuClient,
            pidlItem: ?*ITEMIDLIST,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewMenuClient_IncludeItems(self: *const T, pflags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewMenuClient.VTable, self.vtable).IncludeItems(@ptrCast(*const INewMenuClient, self), pflags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewMenuClient_SelectAndEditItem(self: *const T, pidlItem: ?*ITEMIDLIST, flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewMenuClient.VTable, self.vtable).SelectAndEditItem(@ptrCast(*const INewMenuClient, self), pidlItem, flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInitializeWithBindCtx_Value = @import("../zig.zig").Guid.initString("71c0d2bc-726d-45cc-a6c0-2e31c1db2159");
pub const IID_IInitializeWithBindCtx = &IID_IInitializeWithBindCtx_Value;
pub const IInitializeWithBindCtx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IInitializeWithBindCtx,
            pbc: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeWithBindCtx_Initialize(self: *const T, pbc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeWithBindCtx.VTable, self.vtable).Initialize(@ptrCast(*const IInitializeWithBindCtx, self), pbc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellItemFilter_Value = @import("../zig.zig").Guid.initString("2659b475-eeb8-48b7-8f07-b378810f48cf");
pub const IID_IShellItemFilter = &IID_IShellItemFilter_Value;
pub const IShellItemFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IncludeItem: fn(
            self: *const IShellItemFilter,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumFlagsForItem: fn(
            self: *const IShellItemFilter,
            psi: ?*IShellItem,
            pgrfFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemFilter_IncludeItem(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemFilter.VTable, self.vtable).IncludeItem(@ptrCast(*const IShellItemFilter, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellItemFilter_GetEnumFlagsForItem(self: *const T, psi: ?*IShellItem, pgrfFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellItemFilter.VTable, self.vtable).GetEnumFlagsForItem(@ptrCast(*const IShellItemFilter, self), psi, pgrfFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _NSTCSTYLE = enum(i32) {
    HASEXPANDOS = 1,
    HASLINES = 2,
    SINGLECLICKEXPAND = 4,
    FULLROWSELECT = 8,
    SPRINGEXPAND = 16,
    HORIZONTALSCROLL = 32,
    ROOTHASEXPANDO = 64,
    SHOWSELECTIONALWAYS = 128,
    NOINFOTIP = 512,
    EVENHEIGHT = 1024,
    NOREPLACEOPEN = 2048,
    DISABLEDRAGDROP = 4096,
    NOORDERSTREAM = 8192,
    RICHTOOLTIP = 16384,
    BORDER = 32768,
    NOEDITLABELS = 65536,
    TABSTOP = 131072,
    FAVORITESMODE = 524288,
    AUTOHSCROLL = 1048576,
    FADEINOUTEXPANDOS = 2097152,
    EMPTYTEXT = 4194304,
    CHECKBOXES = 8388608,
    PARTIALCHECKBOXES = 16777216,
    EXCLUSIONCHECKBOXES = 33554432,
    DIMMEDCHECKBOXES = 67108864,
    NOINDENTCHECKS = 134217728,
    ALLOWJUNCTIONS = 268435456,
    SHOWTABSBUTTON = 536870912,
    SHOWDELETEBUTTON = 1073741824,
    SHOWREFRESHBUTTON = -2147483648,
};
pub const NSTCS_HASEXPANDOS = _NSTCSTYLE.HASEXPANDOS;
pub const NSTCS_HASLINES = _NSTCSTYLE.HASLINES;
pub const NSTCS_SINGLECLICKEXPAND = _NSTCSTYLE.SINGLECLICKEXPAND;
pub const NSTCS_FULLROWSELECT = _NSTCSTYLE.FULLROWSELECT;
pub const NSTCS_SPRINGEXPAND = _NSTCSTYLE.SPRINGEXPAND;
pub const NSTCS_HORIZONTALSCROLL = _NSTCSTYLE.HORIZONTALSCROLL;
pub const NSTCS_ROOTHASEXPANDO = _NSTCSTYLE.ROOTHASEXPANDO;
pub const NSTCS_SHOWSELECTIONALWAYS = _NSTCSTYLE.SHOWSELECTIONALWAYS;
pub const NSTCS_NOINFOTIP = _NSTCSTYLE.NOINFOTIP;
pub const NSTCS_EVENHEIGHT = _NSTCSTYLE.EVENHEIGHT;
pub const NSTCS_NOREPLACEOPEN = _NSTCSTYLE.NOREPLACEOPEN;
pub const NSTCS_DISABLEDRAGDROP = _NSTCSTYLE.DISABLEDRAGDROP;
pub const NSTCS_NOORDERSTREAM = _NSTCSTYLE.NOORDERSTREAM;
pub const NSTCS_RICHTOOLTIP = _NSTCSTYLE.RICHTOOLTIP;
pub const NSTCS_BORDER = _NSTCSTYLE.BORDER;
pub const NSTCS_NOEDITLABELS = _NSTCSTYLE.NOEDITLABELS;
pub const NSTCS_TABSTOP = _NSTCSTYLE.TABSTOP;
pub const NSTCS_FAVORITESMODE = _NSTCSTYLE.FAVORITESMODE;
pub const NSTCS_AUTOHSCROLL = _NSTCSTYLE.AUTOHSCROLL;
pub const NSTCS_FADEINOUTEXPANDOS = _NSTCSTYLE.FADEINOUTEXPANDOS;
pub const NSTCS_EMPTYTEXT = _NSTCSTYLE.EMPTYTEXT;
pub const NSTCS_CHECKBOXES = _NSTCSTYLE.CHECKBOXES;
pub const NSTCS_PARTIALCHECKBOXES = _NSTCSTYLE.PARTIALCHECKBOXES;
pub const NSTCS_EXCLUSIONCHECKBOXES = _NSTCSTYLE.EXCLUSIONCHECKBOXES;
pub const NSTCS_DIMMEDCHECKBOXES = _NSTCSTYLE.DIMMEDCHECKBOXES;
pub const NSTCS_NOINDENTCHECKS = _NSTCSTYLE.NOINDENTCHECKS;
pub const NSTCS_ALLOWJUNCTIONS = _NSTCSTYLE.ALLOWJUNCTIONS;
pub const NSTCS_SHOWTABSBUTTON = _NSTCSTYLE.SHOWTABSBUTTON;
pub const NSTCS_SHOWDELETEBUTTON = _NSTCSTYLE.SHOWDELETEBUTTON;
pub const NSTCS_SHOWREFRESHBUTTON = _NSTCSTYLE.SHOWREFRESHBUTTON;

pub const _NSTCROOTSTYLE = enum(i32) {
    VISIBLE = 0,
    HIDDEN = 1,
    EXPANDED = 2,
};
pub const NSTCRS_VISIBLE = _NSTCROOTSTYLE.VISIBLE;
pub const NSTCRS_HIDDEN = _NSTCROOTSTYLE.HIDDEN;
pub const NSTCRS_EXPANDED = _NSTCROOTSTYLE.EXPANDED;

pub const _NSTCITEMSTATE = enum(i32) {
    NONE = 0,
    SELECTED = 1,
    EXPANDED = 2,
    BOLD = 4,
    DISABLED = 8,
    SELECTEDNOEXPAND = 16,
};
pub const NSTCIS_NONE = _NSTCITEMSTATE.NONE;
pub const NSTCIS_SELECTED = _NSTCITEMSTATE.SELECTED;
pub const NSTCIS_EXPANDED = _NSTCITEMSTATE.EXPANDED;
pub const NSTCIS_BOLD = _NSTCITEMSTATE.BOLD;
pub const NSTCIS_DISABLED = _NSTCITEMSTATE.DISABLED;
pub const NSTCIS_SELECTEDNOEXPAND = _NSTCITEMSTATE.SELECTEDNOEXPAND;

pub const NSTCGNI = enum(i32) {
    NEXT = 0,
    NEXTVISIBLE = 1,
    PREV = 2,
    PREVVISIBLE = 3,
    PARENT = 4,
    CHILD = 5,
    FIRSTVISIBLE = 6,
    LASTVISIBLE = 7,
};
pub const NSTCGNI_NEXT = NSTCGNI.NEXT;
pub const NSTCGNI_NEXTVISIBLE = NSTCGNI.NEXTVISIBLE;
pub const NSTCGNI_PREV = NSTCGNI.PREV;
pub const NSTCGNI_PREVVISIBLE = NSTCGNI.PREVVISIBLE;
pub const NSTCGNI_PARENT = NSTCGNI.PARENT;
pub const NSTCGNI_CHILD = NSTCGNI.CHILD;
pub const NSTCGNI_FIRSTVISIBLE = NSTCGNI.FIRSTVISIBLE;
pub const NSTCGNI_LASTVISIBLE = NSTCGNI.LASTVISIBLE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeControl_Value = @import("../zig.zig").Guid.initString("028212a3-b627-47e9-8856-c14265554e4f");
pub const IID_INameSpaceTreeControl = &IID_INameSpaceTreeControl_Value;
pub const INameSpaceTreeControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const INameSpaceTreeControl,
            hwndParent: ?HWND,
            prc: ?*RECT,
            nsctsFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TreeAdvise: fn(
            self: *const INameSpaceTreeControl,
            punk: ?*IUnknown,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TreeUnadvise: fn(
            self: *const INameSpaceTreeControl,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendRoot: fn(
            self: *const INameSpaceTreeControl,
            psiRoot: ?*IShellItem,
            grfEnumFlags: u32,
            grfRootStyle: u32,
            pif: ?*IShellItemFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertRoot: fn(
            self: *const INameSpaceTreeControl,
            iIndex: i32,
            psiRoot: ?*IShellItem,
            grfEnumFlags: u32,
            grfRootStyle: u32,
            pif: ?*IShellItemFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveRoot: fn(
            self: *const INameSpaceTreeControl,
            psiRoot: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllRoots: fn(
            self: *const INameSpaceTreeControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootItems: fn(
            self: *const INameSpaceTreeControl,
            ppsiaRootItems: ?*?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItemState: fn(
            self: *const INameSpaceTreeControl,
            psi: ?*IShellItem,
            nstcisMask: u32,
            nstcisFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemState: fn(
            self: *const INameSpaceTreeControl,
            psi: ?*IShellItem,
            nstcisMask: u32,
            pnstcisFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedItems: fn(
            self: *const INameSpaceTreeControl,
            psiaItems: ?*?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemCustomState: fn(
            self: *const INameSpaceTreeControl,
            psi: ?*IShellItem,
            piStateNumber: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItemCustomState: fn(
            self: *const INameSpaceTreeControl,
            psi: ?*IShellItem,
            iStateNumber: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnsureItemVisible: fn(
            self: *const INameSpaceTreeControl,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTheme: fn(
            self: *const INameSpaceTreeControl,
            pszTheme: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextItem: fn(
            self: *const INameSpaceTreeControl,
            psi: ?*IShellItem,
            nstcgi: NSTCGNI,
            ppsiNext: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HitTest: fn(
            self: *const INameSpaceTreeControl,
            ppt: ?*POINT,
            ppsiOut: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemRect: fn(
            self: *const INameSpaceTreeControl,
            psi: ?*IShellItem,
            prect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CollapseAll: fn(
            self: *const INameSpaceTreeControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_Initialize(self: *const T, hwndParent: ?HWND, prc: ?*RECT, nsctsFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).Initialize(@ptrCast(*const INameSpaceTreeControl, self), hwndParent, prc, nsctsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_TreeAdvise(self: *const T, punk: ?*IUnknown, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).TreeAdvise(@ptrCast(*const INameSpaceTreeControl, self), punk, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_TreeUnadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).TreeUnadvise(@ptrCast(*const INameSpaceTreeControl, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_AppendRoot(self: *const T, psiRoot: ?*IShellItem, grfEnumFlags: u32, grfRootStyle: u32, pif: ?*IShellItemFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).AppendRoot(@ptrCast(*const INameSpaceTreeControl, self), psiRoot, grfEnumFlags, grfRootStyle, pif);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_InsertRoot(self: *const T, iIndex: i32, psiRoot: ?*IShellItem, grfEnumFlags: u32, grfRootStyle: u32, pif: ?*IShellItemFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).InsertRoot(@ptrCast(*const INameSpaceTreeControl, self), iIndex, psiRoot, grfEnumFlags, grfRootStyle, pif);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_RemoveRoot(self: *const T, psiRoot: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).RemoveRoot(@ptrCast(*const INameSpaceTreeControl, self), psiRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_RemoveAllRoots(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).RemoveAllRoots(@ptrCast(*const INameSpaceTreeControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_GetRootItems(self: *const T, ppsiaRootItems: ?*?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).GetRootItems(@ptrCast(*const INameSpaceTreeControl, self), ppsiaRootItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_SetItemState(self: *const T, psi: ?*IShellItem, nstcisMask: u32, nstcisFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).SetItemState(@ptrCast(*const INameSpaceTreeControl, self), psi, nstcisMask, nstcisFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_GetItemState(self: *const T, psi: ?*IShellItem, nstcisMask: u32, pnstcisFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).GetItemState(@ptrCast(*const INameSpaceTreeControl, self), psi, nstcisMask, pnstcisFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_GetSelectedItems(self: *const T, psiaItems: ?*?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).GetSelectedItems(@ptrCast(*const INameSpaceTreeControl, self), psiaItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_GetItemCustomState(self: *const T, psi: ?*IShellItem, piStateNumber: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).GetItemCustomState(@ptrCast(*const INameSpaceTreeControl, self), psi, piStateNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_SetItemCustomState(self: *const T, psi: ?*IShellItem, iStateNumber: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).SetItemCustomState(@ptrCast(*const INameSpaceTreeControl, self), psi, iStateNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_EnsureItemVisible(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).EnsureItemVisible(@ptrCast(*const INameSpaceTreeControl, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_SetTheme(self: *const T, pszTheme: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).SetTheme(@ptrCast(*const INameSpaceTreeControl, self), pszTheme);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_GetNextItem(self: *const T, psi: ?*IShellItem, nstcgi: NSTCGNI, ppsiNext: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).GetNextItem(@ptrCast(*const INameSpaceTreeControl, self), psi, nstcgi, ppsiNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_HitTest(self: *const T, ppt: ?*POINT, ppsiOut: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).HitTest(@ptrCast(*const INameSpaceTreeControl, self), ppt, ppsiOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_GetItemRect(self: *const T, psi: ?*IShellItem, prect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).GetItemRect(@ptrCast(*const INameSpaceTreeControl, self), psi, prect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl_CollapseAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl.VTable, self.vtable).CollapseAll(@ptrCast(*const INameSpaceTreeControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NSTCFOLDERCAPABILITIES = enum(i32) {
    NONE = 0,
    PINNEDITEMFILTERING = 1,
    DELAY_REGISTER_NOTIFY = 2,
};
pub const NSTCFC_NONE = NSTCFOLDERCAPABILITIES.NONE;
pub const NSTCFC_PINNEDITEMFILTERING = NSTCFOLDERCAPABILITIES.PINNEDITEMFILTERING;
pub const NSTCFC_DELAY_REGISTER_NOTIFY = NSTCFOLDERCAPABILITIES.DELAY_REGISTER_NOTIFY;

// TODO: this type is limited to platform 'windows6.1'
const IID_INameSpaceTreeControlFolderCapabilities_Value = @import("../zig.zig").Guid.initString("e9701183-e6b3-4ff2-8568-813615fec7be");
pub const IID_INameSpaceTreeControlFolderCapabilities = &IID_INameSpaceTreeControlFolderCapabilities_Value;
pub const INameSpaceTreeControlFolderCapabilities = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFolderCapabilities: fn(
            self: *const INameSpaceTreeControlFolderCapabilities,
            nfcMask: NSTCFOLDERCAPABILITIES,
            pnfcValue: ?*NSTCFOLDERCAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlFolderCapabilities_GetFolderCapabilities(self: *const T, nfcMask: NSTCFOLDERCAPABILITIES, pnfcValue: ?*NSTCFOLDERCAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlFolderCapabilities.VTable, self.vtable).GetFolderCapabilities(@ptrCast(*const INameSpaceTreeControlFolderCapabilities, self), nfcMask, pnfcValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPreviewHandler_Value = @import("../zig.zig").Guid.initString("8895b1c6-b41f-4c1c-a562-0d564250836f");
pub const IID_IPreviewHandler = &IID_IPreviewHandler_Value;
pub const IPreviewHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetWindow: fn(
            self: *const IPreviewHandler,
            hwnd: ?HWND,
            prc: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRect: fn(
            self: *const IPreviewHandler,
            prc: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoPreview: fn(
            self: *const IPreviewHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unload: fn(
            self: *const IPreviewHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocus: fn(
            self: *const IPreviewHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryFocus: fn(
            self: *const IPreviewHandler,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAccelerator: fn(
            self: *const IPreviewHandler,
            pmsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandler_SetWindow(self: *const T, hwnd: ?HWND, prc: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandler.VTable, self.vtable).SetWindow(@ptrCast(*const IPreviewHandler, self), hwnd, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandler_SetRect(self: *const T, prc: ?*const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandler.VTable, self.vtable).SetRect(@ptrCast(*const IPreviewHandler, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandler_DoPreview(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandler.VTable, self.vtable).DoPreview(@ptrCast(*const IPreviewHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandler_Unload(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandler.VTable, self.vtable).Unload(@ptrCast(*const IPreviewHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandler_SetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandler.VTable, self.vtable).SetFocus(@ptrCast(*const IPreviewHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandler_QueryFocus(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandler.VTable, self.vtable).QueryFocus(@ptrCast(*const IPreviewHandler, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandler_TranslateAccelerator(self: *const T, pmsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandler.VTable, self.vtable).TranslateAccelerator(@ptrCast(*const IPreviewHandler, self), pmsg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PREVIEWHANDLERFRAMEINFO = extern struct {
    haccel: ?HACCEL,
    cAccelEntries: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPreviewHandlerFrame_Value = @import("../zig.zig").Guid.initString("fec87aaf-35f9-447a-adb7-20234491401a");
pub const IID_IPreviewHandlerFrame = &IID_IPreviewHandlerFrame_Value;
pub const IPreviewHandlerFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindowContext: fn(
            self: *const IPreviewHandlerFrame,
            pinfo: ?*PREVIEWHANDLERFRAMEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAccelerator: fn(
            self: *const IPreviewHandlerFrame,
            pmsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandlerFrame_GetWindowContext(self: *const T, pinfo: ?*PREVIEWHANDLERFRAMEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandlerFrame.VTable, self.vtable).GetWindowContext(@ptrCast(*const IPreviewHandlerFrame, self), pinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviewHandlerFrame_TranslateAccelerator(self: *const T, pmsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviewHandlerFrame.VTable, self.vtable).TranslateAccelerator(@ptrCast(*const IPreviewHandlerFrame, self), pmsg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _EXPLORERPANESTATE = enum(i32) {
    DONTCARE = 0,
    DEFAULT_ON = 1,
    DEFAULT_OFF = 2,
    STATEMASK = 65535,
    INITIALSTATE = 65536,
    FORCE = 131072,
};
pub const EPS_DONTCARE = _EXPLORERPANESTATE.DONTCARE;
pub const EPS_DEFAULT_ON = _EXPLORERPANESTATE.DEFAULT_ON;
pub const EPS_DEFAULT_OFF = _EXPLORERPANESTATE.DEFAULT_OFF;
pub const EPS_STATEMASK = _EXPLORERPANESTATE.STATEMASK;
pub const EPS_INITIALSTATE = _EXPLORERPANESTATE.INITIALSTATE;
pub const EPS_FORCE = _EXPLORERPANESTATE.FORCE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerPaneVisibility_Value = @import("../zig.zig").Guid.initString("e07010ec-bc17-44c0-97b0-46c7c95b9edc");
pub const IID_IExplorerPaneVisibility = &IID_IExplorerPaneVisibility_Value;
pub const IExplorerPaneVisibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPaneState: fn(
            self: *const IExplorerPaneVisibility,
            ep: ?*const Guid,
            peps: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerPaneVisibility_GetPaneState(self: *const T, ep: ?*const Guid, peps: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerPaneVisibility.VTable, self.vtable).GetPaneState(@ptrCast(*const IExplorerPaneVisibility, self), ep, peps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IContextMenuCB_Value = @import("../zig.zig").Guid.initString("3409e930-5a39-11d1-83fa-00a0c90dc849");
pub const IID_IContextMenuCB = &IID_IContextMenuCB_Value;
pub const IContextMenuCB = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CallBack: fn(
            self: *const IContextMenuCB,
            psf: ?*IShellFolder,
            hwndOwner: ?HWND,
            pdtobj: ?*IDataObject,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuCB_CallBack(self: *const T, psf: ?*IShellFolder, hwndOwner: ?HWND, pdtobj: ?*IDataObject, uMsg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuCB.VTable, self.vtable).CallBack(@ptrCast(*const IContextMenuCB, self), psf, hwndOwner, pdtobj, uMsg, wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDefaultExtractIconInit_Value = @import("../zig.zig").Guid.initString("41ded17d-d6b3-4261-997d-88c60e4b1d58");
pub const IID_IDefaultExtractIconInit = &IID_IDefaultExtractIconInit_Value;
pub const IDefaultExtractIconInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFlags: fn(
            self: *const IDefaultExtractIconInit,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKey: fn(
            self: *const IDefaultExtractIconInit,
            hkey: ?HKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNormalIcon: fn(
            self: *const IDefaultExtractIconInit,
            pszFile: ?[*:0]const u16,
            iIcon: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpenIcon: fn(
            self: *const IDefaultExtractIconInit,
            pszFile: ?[*:0]const u16,
            iIcon: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShortcutIcon: fn(
            self: *const IDefaultExtractIconInit,
            pszFile: ?[*:0]const u16,
            iIcon: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultIcon: fn(
            self: *const IDefaultExtractIconInit,
            pszFile: ?[*:0]const u16,
            iIcon: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultExtractIconInit_SetFlags(self: *const T, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultExtractIconInit.VTable, self.vtable).SetFlags(@ptrCast(*const IDefaultExtractIconInit, self), uFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultExtractIconInit_SetKey(self: *const T, hkey: ?HKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultExtractIconInit.VTable, self.vtable).SetKey(@ptrCast(*const IDefaultExtractIconInit, self), hkey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultExtractIconInit_SetNormalIcon(self: *const T, pszFile: ?[*:0]const u16, iIcon: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultExtractIconInit.VTable, self.vtable).SetNormalIcon(@ptrCast(*const IDefaultExtractIconInit, self), pszFile, iIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultExtractIconInit_SetOpenIcon(self: *const T, pszFile: ?[*:0]const u16, iIcon: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultExtractIconInit.VTable, self.vtable).SetOpenIcon(@ptrCast(*const IDefaultExtractIconInit, self), pszFile, iIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultExtractIconInit_SetShortcutIcon(self: *const T, pszFile: ?[*:0]const u16, iIcon: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultExtractIconInit.VTable, self.vtable).SetShortcutIcon(@ptrCast(*const IDefaultExtractIconInit, self), pszFile, iIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultExtractIconInit_SetDefaultIcon(self: *const T, pszFile: ?[*:0]const u16, iIcon: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultExtractIconInit.VTable, self.vtable).SetDefaultIcon(@ptrCast(*const IDefaultExtractIconInit, self), pszFile, iIcon);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _EXPCMDSTATE = enum(i32) {
    ENABLED = 0,
    DISABLED = 1,
    HIDDEN = 2,
    CHECKBOX = 4,
    CHECKED = 8,
    RADIOCHECK = 16,
};
pub const ECS_ENABLED = _EXPCMDSTATE.ENABLED;
pub const ECS_DISABLED = _EXPCMDSTATE.DISABLED;
pub const ECS_HIDDEN = _EXPCMDSTATE.HIDDEN;
pub const ECS_CHECKBOX = _EXPCMDSTATE.CHECKBOX;
pub const ECS_CHECKED = _EXPCMDSTATE.CHECKED;
pub const ECS_RADIOCHECK = _EXPCMDSTATE.RADIOCHECK;

pub const _EXPCMDFLAGS = enum(i32) {
    DEFAULT = 0,
    HASSUBCOMMANDS = 1,
    HASSPLITBUTTON = 2,
    HIDELABEL = 4,
    ISSEPARATOR = 8,
    HASLUASHIELD = 16,
    SEPARATORBEFORE = 32,
    SEPARATORAFTER = 64,
    ISDROPDOWN = 128,
    TOGGLEABLE = 256,
    AUTOMENUICONS = 512,
};
pub const ECF_DEFAULT = _EXPCMDFLAGS.DEFAULT;
pub const ECF_HASSUBCOMMANDS = _EXPCMDFLAGS.HASSUBCOMMANDS;
pub const ECF_HASSPLITBUTTON = _EXPCMDFLAGS.HASSPLITBUTTON;
pub const ECF_HIDELABEL = _EXPCMDFLAGS.HIDELABEL;
pub const ECF_ISSEPARATOR = _EXPCMDFLAGS.ISSEPARATOR;
pub const ECF_HASLUASHIELD = _EXPCMDFLAGS.HASLUASHIELD;
pub const ECF_SEPARATORBEFORE = _EXPCMDFLAGS.SEPARATORBEFORE;
pub const ECF_SEPARATORAFTER = _EXPCMDFLAGS.SEPARATORAFTER;
pub const ECF_ISDROPDOWN = _EXPCMDFLAGS.ISDROPDOWN;
pub const ECF_TOGGLEABLE = _EXPCMDFLAGS.TOGGLEABLE;
pub const ECF_AUTOMENUICONS = _EXPCMDFLAGS.AUTOMENUICONS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerCommand_Value = @import("../zig.zig").Guid.initString("a08ce4d0-fa25-44ab-b57c-c7b1c323e0b9");
pub const IID_IExplorerCommand = &IID_IExplorerCommand_Value;
pub const IExplorerCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTitle: fn(
            self: *const IExplorerCommand,
            psiItemArray: ?*IShellItemArray,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIcon: fn(
            self: *const IExplorerCommand,
            psiItemArray: ?*IShellItemArray,
            ppszIcon: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetToolTip: fn(
            self: *const IExplorerCommand,
            psiItemArray: ?*IShellItemArray,
            ppszInfotip: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCanonicalName: fn(
            self: *const IExplorerCommand,
            pguidCommandName: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IExplorerCommand,
            psiItemArray: ?*IShellItemArray,
            fOkToBeSlow: BOOL,
            pCmdState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const IExplorerCommand,
            psiItemArray: ?*IShellItemArray,
            pbc: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IExplorerCommand,
            pFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumSubCommands: fn(
            self: *const IExplorerCommand,
            ppEnum: ?*?*IEnumExplorerCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommand_GetTitle(self: *const T, psiItemArray: ?*IShellItemArray, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommand.VTable, self.vtable).GetTitle(@ptrCast(*const IExplorerCommand, self), psiItemArray, ppszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommand_GetIcon(self: *const T, psiItemArray: ?*IShellItemArray, ppszIcon: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommand.VTable, self.vtable).GetIcon(@ptrCast(*const IExplorerCommand, self), psiItemArray, ppszIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommand_GetToolTip(self: *const T, psiItemArray: ?*IShellItemArray, ppszInfotip: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommand.VTable, self.vtable).GetToolTip(@ptrCast(*const IExplorerCommand, self), psiItemArray, ppszInfotip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommand_GetCanonicalName(self: *const T, pguidCommandName: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommand.VTable, self.vtable).GetCanonicalName(@ptrCast(*const IExplorerCommand, self), pguidCommandName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommand_GetState(self: *const T, psiItemArray: ?*IShellItemArray, fOkToBeSlow: BOOL, pCmdState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommand.VTable, self.vtable).GetState(@ptrCast(*const IExplorerCommand, self), psiItemArray, fOkToBeSlow, pCmdState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommand_Invoke(self: *const T, psiItemArray: ?*IShellItemArray, pbc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommand.VTable, self.vtable).Invoke(@ptrCast(*const IExplorerCommand, self), psiItemArray, pbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommand_GetFlags(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommand.VTable, self.vtable).GetFlags(@ptrCast(*const IExplorerCommand, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommand_EnumSubCommands(self: *const T, ppEnum: ?*?*IEnumExplorerCommand) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommand.VTable, self.vtable).EnumSubCommands(@ptrCast(*const IExplorerCommand, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IExplorerCommandState_Value = @import("../zig.zig").Guid.initString("bddacb60-7657-47ae-8445-d23e1acf82ae");
pub const IID_IExplorerCommandState = &IID_IExplorerCommandState_Value;
pub const IExplorerCommandState = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetState: fn(
            self: *const IExplorerCommandState,
            psiItemArray: ?*IShellItemArray,
            fOkToBeSlow: BOOL,
            pCmdState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommandState_GetState(self: *const T, psiItemArray: ?*IShellItemArray, fOkToBeSlow: BOOL, pCmdState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommandState.VTable, self.vtable).GetState(@ptrCast(*const IExplorerCommandState, self), psiItemArray, fOkToBeSlow, pCmdState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInitializeCommand_Value = @import("../zig.zig").Guid.initString("85075acf-231f-40ea-9610-d26b7b58f638");
pub const IID_IInitializeCommand = &IID_IInitializeCommand_Value;
pub const IInitializeCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IInitializeCommand,
            pszCommandName: ?[*:0]const u16,
            ppb: ?*IPropertyBag,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeCommand_Initialize(self: *const T, pszCommandName: ?[*:0]const u16, ppb: ?*IPropertyBag) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeCommand.VTable, self.vtable).Initialize(@ptrCast(*const IInitializeCommand, self), pszCommandName, ppb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumExplorerCommand_Value = @import("../zig.zig").Guid.initString("a88826f8-186f-4987-aade-ea0cef8fbfe8");
pub const IID_IEnumExplorerCommand = &IID_IEnumExplorerCommand_Value;
pub const IEnumExplorerCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumExplorerCommand,
            celt: u32,
            pUICommand: [*]?*IExplorerCommand,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumExplorerCommand,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumExplorerCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumExplorerCommand,
            ppenum: ?*?*IEnumExplorerCommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumExplorerCommand_Next(self: *const T, celt: u32, pUICommand: [*]?*IExplorerCommand, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumExplorerCommand.VTable, self.vtable).Next(@ptrCast(*const IEnumExplorerCommand, self), celt, pUICommand, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumExplorerCommand_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumExplorerCommand.VTable, self.vtable).Skip(@ptrCast(*const IEnumExplorerCommand, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumExplorerCommand_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumExplorerCommand.VTable, self.vtable).Reset(@ptrCast(*const IEnumExplorerCommand, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumExplorerCommand_Clone(self: *const T, ppenum: ?*?*IEnumExplorerCommand) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumExplorerCommand.VTable, self.vtable).Clone(@ptrCast(*const IEnumExplorerCommand, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExplorerCommandProvider_Value = @import("../zig.zig").Guid.initString("64961751-0835-43c0-8ffe-d57686530e64");
pub const IID_IExplorerCommandProvider = &IID_IExplorerCommandProvider_Value;
pub const IExplorerCommandProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCommands: fn(
            self: *const IExplorerCommandProvider,
            punkSite: ?*IUnknown,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCommand: fn(
            self: *const IExplorerCommandProvider,
            rguidCommandId: ?*const Guid,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommandProvider_GetCommands(self: *const T, punkSite: ?*IUnknown, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommandProvider.VTable, self.vtable).GetCommands(@ptrCast(*const IExplorerCommandProvider, self), punkSite, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExplorerCommandProvider_GetCommand(self: *const T, rguidCommandId: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExplorerCommandProvider.VTable, self.vtable).GetCommand(@ptrCast(*const IExplorerCommandProvider, self), rguidCommandId, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CPVIEW = enum(i32) {
    CLASSIC = 0,
    // ALLITEMS = 0, this enum value conflicts with CLASSIC
    CATEGORY = 1,
    // HOME = 1, this enum value conflicts with CATEGORY
};
pub const CPVIEW_CLASSIC = CPVIEW.CLASSIC;
pub const CPVIEW_ALLITEMS = CPVIEW.CLASSIC;
pub const CPVIEW_CATEGORY = CPVIEW.CATEGORY;
pub const CPVIEW_HOME = CPVIEW.CATEGORY;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOpenControlPanel_Value = @import("../zig.zig").Guid.initString("d11ad862-66de-4df4-bf6c-1f5621996af1");
pub const IID_IOpenControlPanel = &IID_IOpenControlPanel_Value;
pub const IOpenControlPanel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IOpenControlPanel,
            pszName: ?[*:0]const u16,
            pszPage: ?[*:0]const u16,
            punkSite: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPath: fn(
            self: *const IOpenControlPanel,
            pszName: ?[*:0]const u16,
            pszPath: [*:0]u16,
            cchPath: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentView: fn(
            self: *const IOpenControlPanel,
            pView: ?*CPVIEW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenControlPanel_Open(self: *const T, pszName: ?[*:0]const u16, pszPage: ?[*:0]const u16, punkSite: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpenControlPanel.VTable, self.vtable).Open(@ptrCast(*const IOpenControlPanel, self), pszName, pszPage, punkSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenControlPanel_GetPath(self: *const T, pszName: ?[*:0]const u16, pszPath: [*:0]u16, cchPath: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpenControlPanel.VTable, self.vtable).GetPath(@ptrCast(*const IOpenControlPanel, self), pszName, pszPath, cchPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenControlPanel_GetCurrentView(self: *const T, pView: ?*CPVIEW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpenControlPanel.VTable, self.vtable).GetCurrentView(@ptrCast(*const IOpenControlPanel, self), pView);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSystemBindData_Value = @import("../zig.zig").Guid.initString("01e18d10-4d8b-11d2-855d-006008059367");
pub const IID_IFileSystemBindData = &IID_IFileSystemBindData_Value;
pub const IFileSystemBindData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFindData: fn(
            self: *const IFileSystemBindData,
            pfd: ?*const WIN32_FIND_DATAW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFindData: fn(
            self: *const IFileSystemBindData,
            pfd: ?*WIN32_FIND_DATAW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemBindData_SetFindData(self: *const T, pfd: ?*const WIN32_FIND_DATAW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemBindData.VTable, self.vtable).SetFindData(@ptrCast(*const IFileSystemBindData, self), pfd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemBindData_GetFindData(self: *const T, pfd: ?*WIN32_FIND_DATAW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemBindData.VTable, self.vtable).GetFindData(@ptrCast(*const IFileSystemBindData, self), pfd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemBindData2_Value = @import("../zig.zig").Guid.initString("3acf075f-71db-4afa-81f0-3fc4fdf2a5b8");
pub const IID_IFileSystemBindData2 = &IID_IFileSystemBindData2_Value;
pub const IFileSystemBindData2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemBindData.VTable,
        SetFileID: fn(
            self: *const IFileSystemBindData2,
            liFileID: LARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileID: fn(
            self: *const IFileSystemBindData2,
            pliFileID: ?*LARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetJunctionCLSID: fn(
            self: *const IFileSystemBindData2,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetJunctionCLSID: fn(
            self: *const IFileSystemBindData2,
            pclsid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileSystemBindData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemBindData2_SetFileID(self: *const T, liFileID: LARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemBindData2.VTable, self.vtable).SetFileID(@ptrCast(*const IFileSystemBindData2, self), liFileID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemBindData2_GetFileID(self: *const T, pliFileID: ?*LARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemBindData2.VTable, self.vtable).GetFileID(@ptrCast(*const IFileSystemBindData2, self), pliFileID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemBindData2_SetJunctionCLSID(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemBindData2.VTable, self.vtable).SetJunctionCLSID(@ptrCast(*const IFileSystemBindData2, self), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemBindData2_GetJunctionCLSID(self: *const T, pclsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSystemBindData2.VTable, self.vtable).GetJunctionCLSID(@ptrCast(*const IFileSystemBindData2, self), pclsid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const KNOWNDESTCATEGORY = enum(i32) {
    FREQUENT = 1,
    RECENT = 2,
};
pub const KDC_FREQUENT = KNOWNDESTCATEGORY.FREQUENT;
pub const KDC_RECENT = KNOWNDESTCATEGORY.RECENT;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICustomDestinationList_Value = @import("../zig.zig").Guid.initString("6332debf-87b5-4670-90c0-5e57b408a49e");
pub const IID_ICustomDestinationList = &IID_ICustomDestinationList_Value;
pub const ICustomDestinationList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAppID: fn(
            self: *const ICustomDestinationList,
            pszAppID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginList: fn(
            self: *const ICustomDestinationList,
            pcMinSlots: ?*u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendCategory: fn(
            self: *const ICustomDestinationList,
            pszCategory: ?[*:0]const u16,
            poa: ?*IObjectArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendKnownCategory: fn(
            self: *const ICustomDestinationList,
            category: KNOWNDESTCATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUserTasks: fn(
            self: *const ICustomDestinationList,
            poa: ?*IObjectArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitList: fn(
            self: *const ICustomDestinationList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRemovedDestinations: fn(
            self: *const ICustomDestinationList,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteList: fn(
            self: *const ICustomDestinationList,
            pszAppID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortList: fn(
            self: *const ICustomDestinationList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomDestinationList_SetAppID(self: *const T, pszAppID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomDestinationList.VTable, self.vtable).SetAppID(@ptrCast(*const ICustomDestinationList, self), pszAppID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomDestinationList_BeginList(self: *const T, pcMinSlots: ?*u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomDestinationList.VTable, self.vtable).BeginList(@ptrCast(*const ICustomDestinationList, self), pcMinSlots, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomDestinationList_AppendCategory(self: *const T, pszCategory: ?[*:0]const u16, poa: ?*IObjectArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomDestinationList.VTable, self.vtable).AppendCategory(@ptrCast(*const ICustomDestinationList, self), pszCategory, poa);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomDestinationList_AppendKnownCategory(self: *const T, category: KNOWNDESTCATEGORY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomDestinationList.VTable, self.vtable).AppendKnownCategory(@ptrCast(*const ICustomDestinationList, self), category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomDestinationList_AddUserTasks(self: *const T, poa: ?*IObjectArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomDestinationList.VTable, self.vtable).AddUserTasks(@ptrCast(*const ICustomDestinationList, self), poa);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomDestinationList_CommitList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomDestinationList.VTable, self.vtable).CommitList(@ptrCast(*const ICustomDestinationList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomDestinationList_GetRemovedDestinations(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomDestinationList.VTable, self.vtable).GetRemovedDestinations(@ptrCast(*const ICustomDestinationList, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomDestinationList_DeleteList(self: *const T, pszAppID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomDestinationList.VTable, self.vtable).DeleteList(@ptrCast(*const ICustomDestinationList, self), pszAppID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomDestinationList_AbortList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomDestinationList.VTable, self.vtable).AbortList(@ptrCast(*const ICustomDestinationList, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IApplicationDestinations_Value = @import("../zig.zig").Guid.initString("12337d35-94c6-48a0-bce7-6a9c69d4d600");
pub const IID_IApplicationDestinations = &IID_IApplicationDestinations_Value;
pub const IApplicationDestinations = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAppID: fn(
            self: *const IApplicationDestinations,
            pszAppID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveDestination: fn(
            self: *const IApplicationDestinations,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllDestinations: fn(
            self: *const IApplicationDestinations,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDestinations_SetAppID(self: *const T, pszAppID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDestinations.VTable, self.vtable).SetAppID(@ptrCast(*const IApplicationDestinations, self), pszAppID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDestinations_RemoveDestination(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDestinations.VTable, self.vtable).RemoveDestination(@ptrCast(*const IApplicationDestinations, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDestinations_RemoveAllDestinations(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDestinations.VTable, self.vtable).RemoveAllDestinations(@ptrCast(*const IApplicationDestinations, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APPDOCLISTTYPE = enum(i32) {
    RECENT = 0,
    FREQUENT = 1,
};
pub const ADLT_RECENT = APPDOCLISTTYPE.RECENT;
pub const ADLT_FREQUENT = APPDOCLISTTYPE.FREQUENT;

// TODO: this type is limited to platform 'windows6.1'
const IID_IApplicationDocumentLists_Value = @import("../zig.zig").Guid.initString("3c594f9f-9f30-47a1-979a-c9e83d3d0a06");
pub const IID_IApplicationDocumentLists = &IID_IApplicationDocumentLists_Value;
pub const IApplicationDocumentLists = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAppID: fn(
            self: *const IApplicationDocumentLists,
            pszAppID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetList: fn(
            self: *const IApplicationDocumentLists,
            listtype: APPDOCLISTTYPE,
            cItemsDesired: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDocumentLists_SetAppID(self: *const T, pszAppID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDocumentLists.VTable, self.vtable).SetAppID(@ptrCast(*const IApplicationDocumentLists, self), pszAppID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDocumentLists_GetList(self: *const T, listtype: APPDOCLISTTYPE, cItemsDesired: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDocumentLists.VTable, self.vtable).GetList(@ptrCast(*const IApplicationDocumentLists, self), listtype, cItemsDesired, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithAppUserModelID_Value = @import("../zig.zig").Guid.initString("36db0196-9665-46d1-9ba7-d3709eecf9ed");
pub const IID_IObjectWithAppUserModelID = &IID_IObjectWithAppUserModelID_Value;
pub const IObjectWithAppUserModelID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAppID: fn(
            self: *const IObjectWithAppUserModelID,
            pszAppID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppID: fn(
            self: *const IObjectWithAppUserModelID,
            ppszAppID: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithAppUserModelID_SetAppID(self: *const T, pszAppID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithAppUserModelID.VTable, self.vtable).SetAppID(@ptrCast(*const IObjectWithAppUserModelID, self), pszAppID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithAppUserModelID_GetAppID(self: *const T, ppszAppID: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithAppUserModelID.VTable, self.vtable).GetAppID(@ptrCast(*const IObjectWithAppUserModelID, self), ppszAppID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IObjectWithProgID_Value = @import("../zig.zig").Guid.initString("71e806fb-8dee-46fc-bf8c-7748a8a1ae13");
pub const IID_IObjectWithProgID = &IID_IObjectWithProgID_Value;
pub const IObjectWithProgID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProgID: fn(
            self: *const IObjectWithProgID,
            pszProgID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgID: fn(
            self: *const IObjectWithProgID,
            ppszProgID: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithProgID_SetProgID(self: *const T, pszProgID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithProgID.VTable, self.vtable).SetProgID(@ptrCast(*const IObjectWithProgID, self), pszProgID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectWithProgID_GetProgID(self: *const T, ppszProgID: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectWithProgID.VTable, self.vtable).GetProgID(@ptrCast(*const IObjectWithProgID, self), ppszProgID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUpdateIDList_Value = @import("../zig.zig").Guid.initString("6589b6d2-5f8d-4b9e-b7e0-23cdd9717d8c");
pub const IID_IUpdateIDList = &IID_IUpdateIDList_Value;
pub const IUpdateIDList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Update: fn(
            self: *const IUpdateIDList,
            pbc: ?*IBindCtx,
            pidlIn: ?*ITEMIDLIST,
            ppidlOut: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUpdateIDList_Update(self: *const T, pbc: ?*IBindCtx, pidlIn: ?*ITEMIDLIST, ppidlOut: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUpdateIDList.VTable, self.vtable).Update(@ptrCast(*const IUpdateIDList, self), pbc, pidlIn, ppidlOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DESKTOP_SLIDESHOW_OPTIONS = enum(i32) {
    S = 1,
};
pub const DSO_SHUFFLEIMAGES = DESKTOP_SLIDESHOW_OPTIONS.S;

pub const DESKTOP_SLIDESHOW_STATE = enum(i32) {
    ENABLED = 1,
    SLIDESHOW = 2,
    DISABLED_BY_REMOTE_SESSION = 4,
};
pub const DSS_ENABLED = DESKTOP_SLIDESHOW_STATE.ENABLED;
pub const DSS_SLIDESHOW = DESKTOP_SLIDESHOW_STATE.SLIDESHOW;
pub const DSS_DISABLED_BY_REMOTE_SESSION = DESKTOP_SLIDESHOW_STATE.DISABLED_BY_REMOTE_SESSION;

pub const DESKTOP_SLIDESHOW_DIRECTION = enum(i32) {
    FORWARD = 0,
    BACKWARD = 1,
};
pub const DSD_FORWARD = DESKTOP_SLIDESHOW_DIRECTION.FORWARD;
pub const DSD_BACKWARD = DESKTOP_SLIDESHOW_DIRECTION.BACKWARD;

pub const DESKTOP_WALLPAPER_POSITION = enum(i32) {
    CENTER = 0,
    TILE = 1,
    STRETCH = 2,
    FIT = 3,
    FILL = 4,
    SPAN = 5,
};
pub const DWPOS_CENTER = DESKTOP_WALLPAPER_POSITION.CENTER;
pub const DWPOS_TILE = DESKTOP_WALLPAPER_POSITION.TILE;
pub const DWPOS_STRETCH = DESKTOP_WALLPAPER_POSITION.STRETCH;
pub const DWPOS_FIT = DESKTOP_WALLPAPER_POSITION.FIT;
pub const DWPOS_FILL = DESKTOP_WALLPAPER_POSITION.FILL;
pub const DWPOS_SPAN = DESKTOP_WALLPAPER_POSITION.SPAN;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDesktopWallpaper_Value = @import("../zig.zig").Guid.initString("b92b56a9-8b55-4e14-9a89-0199bbb6f93b");
pub const IID_IDesktopWallpaper = &IID_IDesktopWallpaper_Value;
pub const IDesktopWallpaper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetWallpaper: fn(
            self: *const IDesktopWallpaper,
            monitorID: ?[*:0]const u16,
            wallpaper: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWallpaper: fn(
            self: *const IDesktopWallpaper,
            monitorID: ?[*:0]const u16,
            wallpaper: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonitorDevicePathAt: fn(
            self: *const IDesktopWallpaper,
            monitorIndex: u32,
            monitorID: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonitorDevicePathCount: fn(
            self: *const IDesktopWallpaper,
            count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonitorRECT: fn(
            self: *const IDesktopWallpaper,
            monitorID: ?[*:0]const u16,
            displayRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundColor: fn(
            self: *const IDesktopWallpaper,
            color: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: fn(
            self: *const IDesktopWallpaper,
            color: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPosition: fn(
            self: *const IDesktopWallpaper,
            position: DESKTOP_WALLPAPER_POSITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const IDesktopWallpaper,
            position: ?*DESKTOP_WALLPAPER_POSITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSlideshow: fn(
            self: *const IDesktopWallpaper,
            items: ?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSlideshow: fn(
            self: *const IDesktopWallpaper,
            items: ?*?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSlideshowOptions: fn(
            self: *const IDesktopWallpaper,
            options: DESKTOP_SLIDESHOW_OPTIONS,
            slideshowTick: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSlideshowOptions: fn(
            self: *const IDesktopWallpaper,
            options: ?*DESKTOP_SLIDESHOW_OPTIONS,
            slideshowTick: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdvanceSlideshow: fn(
            self: *const IDesktopWallpaper,
            monitorID: ?[*:0]const u16,
            direction: DESKTOP_SLIDESHOW_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const IDesktopWallpaper,
            state: ?*DESKTOP_SLIDESHOW_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const IDesktopWallpaper,
            enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_SetWallpaper(self: *const T, monitorID: ?[*:0]const u16, wallpaper: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).SetWallpaper(@ptrCast(*const IDesktopWallpaper, self), monitorID, wallpaper);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_GetWallpaper(self: *const T, monitorID: ?[*:0]const u16, wallpaper: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).GetWallpaper(@ptrCast(*const IDesktopWallpaper, self), monitorID, wallpaper);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_GetMonitorDevicePathAt(self: *const T, monitorIndex: u32, monitorID: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).GetMonitorDevicePathAt(@ptrCast(*const IDesktopWallpaper, self), monitorIndex, monitorID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_GetMonitorDevicePathCount(self: *const T, count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).GetMonitorDevicePathCount(@ptrCast(*const IDesktopWallpaper, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_GetMonitorRECT(self: *const T, monitorID: ?[*:0]const u16, displayRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).GetMonitorRECT(@ptrCast(*const IDesktopWallpaper, self), monitorID, displayRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_SetBackgroundColor(self: *const T, color: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).SetBackgroundColor(@ptrCast(*const IDesktopWallpaper, self), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_GetBackgroundColor(self: *const T, color: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).GetBackgroundColor(@ptrCast(*const IDesktopWallpaper, self), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_SetPosition(self: *const T, position: DESKTOP_WALLPAPER_POSITION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).SetPosition(@ptrCast(*const IDesktopWallpaper, self), position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_GetPosition(self: *const T, position: ?*DESKTOP_WALLPAPER_POSITION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).GetPosition(@ptrCast(*const IDesktopWallpaper, self), position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_SetSlideshow(self: *const T, items: ?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).SetSlideshow(@ptrCast(*const IDesktopWallpaper, self), items);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_GetSlideshow(self: *const T, items: ?*?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).GetSlideshow(@ptrCast(*const IDesktopWallpaper, self), items);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_SetSlideshowOptions(self: *const T, options: DESKTOP_SLIDESHOW_OPTIONS, slideshowTick: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).SetSlideshowOptions(@ptrCast(*const IDesktopWallpaper, self), options, slideshowTick);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_GetSlideshowOptions(self: *const T, options: ?*DESKTOP_SLIDESHOW_OPTIONS, slideshowTick: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).GetSlideshowOptions(@ptrCast(*const IDesktopWallpaper, self), options, slideshowTick);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_AdvanceSlideshow(self: *const T, monitorID: ?[*:0]const u16, direction: DESKTOP_SLIDESHOW_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).AdvanceSlideshow(@ptrCast(*const IDesktopWallpaper, self), monitorID, direction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_GetStatus(self: *const T, state: ?*DESKTOP_SLIDESHOW_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).GetStatus(@ptrCast(*const IDesktopWallpaper, self), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopWallpaper_Enable(self: *const T, enable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopWallpaper.VTable, self.vtable).Enable(@ptrCast(*const IDesktopWallpaper, self), enable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HOMEGROUPSHARINGCHOICES = enum(i32) {
    NONE = 0,
    MUSICLIBRARY = 1,
    PICTURESLIBRARY = 2,
    VIDEOSLIBRARY = 4,
    DOCUMENTSLIBRARY = 8,
    PRINTERS = 16,
};
pub const HGSC_NONE = HOMEGROUPSHARINGCHOICES.NONE;
pub const HGSC_MUSICLIBRARY = HOMEGROUPSHARINGCHOICES.MUSICLIBRARY;
pub const HGSC_PICTURESLIBRARY = HOMEGROUPSHARINGCHOICES.PICTURESLIBRARY;
pub const HGSC_VIDEOSLIBRARY = HOMEGROUPSHARINGCHOICES.VIDEOSLIBRARY;
pub const HGSC_DOCUMENTSLIBRARY = HOMEGROUPSHARINGCHOICES.DOCUMENTSLIBRARY;
pub const HGSC_PRINTERS = HOMEGROUPSHARINGCHOICES.PRINTERS;

// TODO: this type is limited to platform 'windows6.1'
const IID_IHomeGroup_Value = @import("../zig.zig").Guid.initString("7a3bd1d9-35a9-4fb3-a467-f48cac35e2d0");
pub const IID_IHomeGroup = &IID_IHomeGroup_Value;
pub const IHomeGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMember: fn(
            self: *const IHomeGroup,
            member: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowSharingWizard: fn(
            self: *const IHomeGroup,
            owner: ?HWND,
            sharingchoices: ?*HOMEGROUPSHARINGCHOICES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHomeGroup_IsMember(self: *const T, member: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHomeGroup.VTable, self.vtable).IsMember(@ptrCast(*const IHomeGroup, self), member);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHomeGroup_ShowSharingWizard(self: *const T, owner: ?HWND, sharingchoices: ?*HOMEGROUPSHARINGCHOICES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHomeGroup.VTable, self.vtable).ShowSharingWizard(@ptrCast(*const IHomeGroup, self), owner, sharingchoices);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IInitializeWithPropertyStore_Value = @import("../zig.zig").Guid.initString("c3e12eb5-7d8d-44f8-b6dd-0e77b34d6de4");
pub const IID_IInitializeWithPropertyStore = &IID_IInitializeWithPropertyStore_Value;
pub const IInitializeWithPropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IInitializeWithPropertyStore,
            pps: ?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeWithPropertyStore_Initialize(self: *const T, pps: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeWithPropertyStore.VTable, self.vtable).Initialize(@ptrCast(*const IInitializeWithPropertyStore, self), pps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IOpenSearchSource_Value = @import("../zig.zig").Guid.initString("f0ee7333-e6fc-479b-9f25-a860c234a38e");
pub const IID_IOpenSearchSource = &IID_IOpenSearchSource_Value;
pub const IOpenSearchSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResults: fn(
            self: *const IOpenSearchSource,
            hwnd: ?HWND,
            pszQuery: ?[*:0]const u16,
            dwStartIndex: u32,
            dwCount: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenSearchSource_GetResults(self: *const T, hwnd: ?HWND, pszQuery: ?[*:0]const u16, dwStartIndex: u32, dwCount: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpenSearchSource.VTable, self.vtable).GetResults(@ptrCast(*const IOpenSearchSource, self), hwnd, pszQuery, dwStartIndex, dwCount, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const LIBRARYFOLDERFILTER = enum(i32) {
    FORCEFILESYSTEM = 1,
    STORAGEITEMS = 2,
    ALLITEMS = 3,
};
pub const LFF_FORCEFILESYSTEM = LIBRARYFOLDERFILTER.FORCEFILESYSTEM;
pub const LFF_STORAGEITEMS = LIBRARYFOLDERFILTER.STORAGEITEMS;
pub const LFF_ALLITEMS = LIBRARYFOLDERFILTER.ALLITEMS;

pub const LIBRARYOPTIONFLAGS = enum(i32) {
    DEFAULT = 0,
    PINNEDTONAVPANE = 1,
    // MASK_ALL = 1, this enum value conflicts with PINNEDTONAVPANE
};
pub const LOF_DEFAULT = LIBRARYOPTIONFLAGS.DEFAULT;
pub const LOF_PINNEDTONAVPANE = LIBRARYOPTIONFLAGS.PINNEDTONAVPANE;
pub const LOF_MASK_ALL = LIBRARYOPTIONFLAGS.PINNEDTONAVPANE;

pub const DEFAULTSAVEFOLDERTYPE = enum(i32) {
    DETECT = 1,
    PRIVATE = 2,
    PUBLIC = 3,
};
pub const DSFT_DETECT = DEFAULTSAVEFOLDERTYPE.DETECT;
pub const DSFT_PRIVATE = DEFAULTSAVEFOLDERTYPE.PRIVATE;
pub const DSFT_PUBLIC = DEFAULTSAVEFOLDERTYPE.PUBLIC;

pub const LIBRARYSAVEFLAGS = enum(i32) {
    FAILIFTHERE = 0,
    OVERRIDEEXISTING = 1,
    MAKEUNIQUENAME = 2,
};
pub const LSF_FAILIFTHERE = LIBRARYSAVEFLAGS.FAILIFTHERE;
pub const LSF_OVERRIDEEXISTING = LIBRARYSAVEFLAGS.OVERRIDEEXISTING;
pub const LSF_MAKEUNIQUENAME = LIBRARYSAVEFLAGS.MAKEUNIQUENAME;

// TODO: this type is limited to platform 'windows6.1'
const IID_IShellLibrary_Value = @import("../zig.zig").Guid.initString("11a66efa-382e-451a-9234-1e0e12ef3085");
pub const IID_IShellLibrary = &IID_IShellLibrary_Value;
pub const IShellLibrary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadLibraryFromItem: fn(
            self: *const IShellLibrary,
            psiLibrary: ?*IShellItem,
            grfMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadLibraryFromKnownFolder: fn(
            self: *const IShellLibrary,
            kfidLibrary: ?*const Guid,
            grfMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFolder: fn(
            self: *const IShellLibrary,
            psiLocation: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFolder: fn(
            self: *const IShellLibrary,
            psiLocation: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolders: fn(
            self: *const IShellLibrary,
            lff: LIBRARYFOLDERFILTER,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveFolder: fn(
            self: *const IShellLibrary,
            psiFolderToResolve: ?*IShellItem,
            dwTimeout: u32,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultSaveFolder: fn(
            self: *const IShellLibrary,
            dsft: DEFAULTSAVEFOLDERTYPE,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultSaveFolder: fn(
            self: *const IShellLibrary,
            dsft: DEFAULTSAVEFOLDERTYPE,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptions: fn(
            self: *const IShellLibrary,
            plofOptions: ?*LIBRARYOPTIONFLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOptions: fn(
            self: *const IShellLibrary,
            lofMask: LIBRARYOPTIONFLAGS,
            lofOptions: LIBRARYOPTIONFLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolderType: fn(
            self: *const IShellLibrary,
            pftid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFolderType: fn(
            self: *const IShellLibrary,
            ftid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIcon: fn(
            self: *const IShellLibrary,
            ppszIcon: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIcon: fn(
            self: *const IShellLibrary,
            pszIcon: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IShellLibrary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IShellLibrary,
            psiFolderToSaveIn: ?*IShellItem,
            pszLibraryName: ?[*:0]const u16,
            lsf: LIBRARYSAVEFLAGS,
            ppsiSavedTo: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveInKnownFolder: fn(
            self: *const IShellLibrary,
            kfidToSaveIn: ?*const Guid,
            pszLibraryName: ?[*:0]const u16,
            lsf: LIBRARYSAVEFLAGS,
            ppsiSavedTo: ?*?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_LoadLibraryFromItem(self: *const T, psiLibrary: ?*IShellItem, grfMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).LoadLibraryFromItem(@ptrCast(*const IShellLibrary, self), psiLibrary, grfMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_LoadLibraryFromKnownFolder(self: *const T, kfidLibrary: ?*const Guid, grfMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).LoadLibraryFromKnownFolder(@ptrCast(*const IShellLibrary, self), kfidLibrary, grfMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_AddFolder(self: *const T, psiLocation: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).AddFolder(@ptrCast(*const IShellLibrary, self), psiLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_RemoveFolder(self: *const T, psiLocation: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).RemoveFolder(@ptrCast(*const IShellLibrary, self), psiLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_GetFolders(self: *const T, lff: LIBRARYFOLDERFILTER, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).GetFolders(@ptrCast(*const IShellLibrary, self), lff, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_ResolveFolder(self: *const T, psiFolderToResolve: ?*IShellItem, dwTimeout: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).ResolveFolder(@ptrCast(*const IShellLibrary, self), psiFolderToResolve, dwTimeout, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_GetDefaultSaveFolder(self: *const T, dsft: DEFAULTSAVEFOLDERTYPE, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).GetDefaultSaveFolder(@ptrCast(*const IShellLibrary, self), dsft, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_SetDefaultSaveFolder(self: *const T, dsft: DEFAULTSAVEFOLDERTYPE, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).SetDefaultSaveFolder(@ptrCast(*const IShellLibrary, self), dsft, psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_GetOptions(self: *const T, plofOptions: ?*LIBRARYOPTIONFLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).GetOptions(@ptrCast(*const IShellLibrary, self), plofOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_SetOptions(self: *const T, lofMask: LIBRARYOPTIONFLAGS, lofOptions: LIBRARYOPTIONFLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).SetOptions(@ptrCast(*const IShellLibrary, self), lofMask, lofOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_GetFolderType(self: *const T, pftid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).GetFolderType(@ptrCast(*const IShellLibrary, self), pftid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_SetFolderType(self: *const T, ftid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).SetFolderType(@ptrCast(*const IShellLibrary, self), ftid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_GetIcon(self: *const T, ppszIcon: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).GetIcon(@ptrCast(*const IShellLibrary, self), ppszIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_SetIcon(self: *const T, pszIcon: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).SetIcon(@ptrCast(*const IShellLibrary, self), pszIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_Commit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).Commit(@ptrCast(*const IShellLibrary, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_Save(self: *const T, psiFolderToSaveIn: ?*IShellItem, pszLibraryName: ?[*:0]const u16, lsf: LIBRARYSAVEFLAGS, ppsiSavedTo: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).Save(@ptrCast(*const IShellLibrary, self), psiFolderToSaveIn, pszLibraryName, lsf, ppsiSavedTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLibrary_SaveInKnownFolder(self: *const T, kfidToSaveIn: ?*const Guid, pszLibraryName: ?[*:0]const u16, lsf: LIBRARYSAVEFLAGS, ppsiSavedTo: ?*?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLibrary.VTable, self.vtable).SaveInKnownFolder(@ptrCast(*const IShellLibrary, self), kfidToSaveIn, pszLibraryName, lsf, ppsiSavedTo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEFAULT_FOLDER_MENU_RESTRICTIONS = enum(i32) {
    DEFAULT = 0,
    NO_STATIC_VERBS = 8,
    STATIC_VERBS_ONLY = 16,
    NO_RESOURCE_VERBS = 32,
    OPTIN_HANDLERS_ONLY = 64,
    RESOURCE_AND_FOLDER_VERBS_ONLY = 128,
    USE_SPECIFIED_HANDLERS = 256,
    USE_SPECIFIED_VERBS = 512,
    NO_ASYNC_VERBS = 1024,
    NO_NATIVECPU_VERBS = 2048,
    NO_NONWOW_VERBS = 4096,
};
pub const DFMR_DEFAULT = DEFAULT_FOLDER_MENU_RESTRICTIONS.DEFAULT;
pub const DFMR_NO_STATIC_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_STATIC_VERBS;
pub const DFMR_STATIC_VERBS_ONLY = DEFAULT_FOLDER_MENU_RESTRICTIONS.STATIC_VERBS_ONLY;
pub const DFMR_NO_RESOURCE_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_RESOURCE_VERBS;
pub const DFMR_OPTIN_HANDLERS_ONLY = DEFAULT_FOLDER_MENU_RESTRICTIONS.OPTIN_HANDLERS_ONLY;
pub const DFMR_RESOURCE_AND_FOLDER_VERBS_ONLY = DEFAULT_FOLDER_MENU_RESTRICTIONS.RESOURCE_AND_FOLDER_VERBS_ONLY;
pub const DFMR_USE_SPECIFIED_HANDLERS = DEFAULT_FOLDER_MENU_RESTRICTIONS.USE_SPECIFIED_HANDLERS;
pub const DFMR_USE_SPECIFIED_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.USE_SPECIFIED_VERBS;
pub const DFMR_NO_ASYNC_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_ASYNC_VERBS;
pub const DFMR_NO_NATIVECPU_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_NATIVECPU_VERBS;
pub const DFMR_NO_NONWOW_VERBS = DEFAULT_FOLDER_MENU_RESTRICTIONS.NO_NONWOW_VERBS;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDefaultFolderMenuInitialize_Value = @import("../zig.zig").Guid.initString("7690aa79-f8fc-4615-a327-36f7d18f5d91");
pub const IID_IDefaultFolderMenuInitialize = &IID_IDefaultFolderMenuInitialize_Value;
pub const IDefaultFolderMenuInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDefaultFolderMenuInitialize,
            hwnd: ?HWND,
            pcmcb: ?*IContextMenuCB,
            pidlFolder: ?*ITEMIDLIST,
            psf: ?*IShellFolder,
            cidl: u32,
            apidl: [*]?*ITEMIDLIST,
            punkAssociation: ?*IUnknown,
            cKeys: u32,
            aKeys: ?*const ?HKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMenuRestrictions: fn(
            self: *const IDefaultFolderMenuInitialize,
            dfmrValues: DEFAULT_FOLDER_MENU_RESTRICTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMenuRestrictions: fn(
            self: *const IDefaultFolderMenuInitialize,
            dfmrMask: DEFAULT_FOLDER_MENU_RESTRICTIONS,
            pdfmrValues: ?*DEFAULT_FOLDER_MENU_RESTRICTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHandlerClsid: fn(
            self: *const IDefaultFolderMenuInitialize,
            rclsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultFolderMenuInitialize_Initialize(self: *const T, hwnd: ?HWND, pcmcb: ?*IContextMenuCB, pidlFolder: ?*ITEMIDLIST, psf: ?*IShellFolder, cidl: u32, apidl: [*]?*ITEMIDLIST, punkAssociation: ?*IUnknown, cKeys: u32, aKeys: ?*const ?HKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultFolderMenuInitialize.VTable, self.vtable).Initialize(@ptrCast(*const IDefaultFolderMenuInitialize, self), hwnd, pcmcb, pidlFolder, psf, cidl, apidl, punkAssociation, cKeys, aKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultFolderMenuInitialize_SetMenuRestrictions(self: *const T, dfmrValues: DEFAULT_FOLDER_MENU_RESTRICTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultFolderMenuInitialize.VTable, self.vtable).SetMenuRestrictions(@ptrCast(*const IDefaultFolderMenuInitialize, self), dfmrValues);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultFolderMenuInitialize_GetMenuRestrictions(self: *const T, dfmrMask: DEFAULT_FOLDER_MENU_RESTRICTIONS, pdfmrValues: ?*DEFAULT_FOLDER_MENU_RESTRICTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultFolderMenuInitialize.VTable, self.vtable).GetMenuRestrictions(@ptrCast(*const IDefaultFolderMenuInitialize, self), dfmrMask, pdfmrValues);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultFolderMenuInitialize_SetHandlerClsid(self: *const T, rclsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDefaultFolderMenuInitialize.VTable, self.vtable).SetHandlerClsid(@ptrCast(*const IDefaultFolderMenuInitialize, self), rclsid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ACTIVATEOPTIONS = enum(i32) {
    NONE = 0,
    DESIGNMODE = 1,
    NOERRORUI = 2,
    NOSPLASHSCREEN = 4,
    PRELAUNCH = 33554432,
};
pub const AO_NONE = ACTIVATEOPTIONS.NONE;
pub const AO_DESIGNMODE = ACTIVATEOPTIONS.DESIGNMODE;
pub const AO_NOERRORUI = ACTIVATEOPTIONS.NOERRORUI;
pub const AO_NOSPLASHSCREEN = ACTIVATEOPTIONS.NOSPLASHSCREEN;
pub const AO_PRELAUNCH = ACTIVATEOPTIONS.PRELAUNCH;

// TODO: this type is limited to platform 'windows8.0'
const IID_IApplicationActivationManager_Value = @import("../zig.zig").Guid.initString("2e941141-7f97-4756-ba1d-9decde894a3d");
pub const IID_IApplicationActivationManager = &IID_IApplicationActivationManager_Value;
pub const IApplicationActivationManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateApplication: fn(
            self: *const IApplicationActivationManager,
            appUserModelId: ?[*:0]const u16,
            arguments: ?[*:0]const u16,
            options: ACTIVATEOPTIONS,
            processId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateForFile: fn(
            self: *const IApplicationActivationManager,
            appUserModelId: ?[*:0]const u16,
            itemArray: ?*IShellItemArray,
            verb: ?[*:0]const u16,
            processId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateForProtocol: fn(
            self: *const IApplicationActivationManager,
            appUserModelId: ?[*:0]const u16,
            itemArray: ?*IShellItemArray,
            processId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationActivationManager_ActivateApplication(self: *const T, appUserModelId: ?[*:0]const u16, arguments: ?[*:0]const u16, options: ACTIVATEOPTIONS, processId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationActivationManager.VTable, self.vtable).ActivateApplication(@ptrCast(*const IApplicationActivationManager, self), appUserModelId, arguments, options, processId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationActivationManager_ActivateForFile(self: *const T, appUserModelId: ?[*:0]const u16, itemArray: ?*IShellItemArray, verb: ?[*:0]const u16, processId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationActivationManager.VTable, self.vtable).ActivateForFile(@ptrCast(*const IApplicationActivationManager, self), appUserModelId, itemArray, verb, processId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationActivationManager_ActivateForProtocol(self: *const T, appUserModelId: ?[*:0]const u16, itemArray: ?*IShellItemArray, processId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationActivationManager.VTable, self.vtable).ActivateForProtocol(@ptrCast(*const IApplicationActivationManager, self), appUserModelId, itemArray, processId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IVirtualDesktopManager_Value = @import("../zig.zig").Guid.initString("a5cd92ff-29be-454c-8d04-d82879fb3f1b");
pub const IID_IVirtualDesktopManager = &IID_IVirtualDesktopManager_Value;
pub const IVirtualDesktopManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsWindowOnCurrentVirtualDesktop: fn(
            self: *const IVirtualDesktopManager,
            topLevelWindow: ?HWND,
            onCurrentDesktop: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindowDesktopId: fn(
            self: *const IVirtualDesktopManager,
            topLevelWindow: ?HWND,
            desktopId: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveWindowToDesktop: fn(
            self: *const IVirtualDesktopManager,
            topLevelWindow: ?HWND,
            desktopId: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualDesktopManager_IsWindowOnCurrentVirtualDesktop(self: *const T, topLevelWindow: ?HWND, onCurrentDesktop: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualDesktopManager.VTable, self.vtable).IsWindowOnCurrentVirtualDesktop(@ptrCast(*const IVirtualDesktopManager, self), topLevelWindow, onCurrentDesktop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualDesktopManager_GetWindowDesktopId(self: *const T, topLevelWindow: ?HWND, desktopId: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualDesktopManager.VTable, self.vtable).GetWindowDesktopId(@ptrCast(*const IVirtualDesktopManager, self), topLevelWindow, desktopId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualDesktopManager_MoveWindowToDesktop(self: *const T, topLevelWindow: ?HWND, desktopId: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualDesktopManager.VTable, self.vtable).MoveWindowToDesktop(@ptrCast(*const IVirtualDesktopManager, self), topLevelWindow, desktopId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const LIBRARYMANAGEDIALOGOPTIONS = enum(i32) {
    DEFAULT = 0,
    ALLOWUNINDEXABLENETWORKLOCATIONS = 1,
};
pub const LMD_DEFAULT = LIBRARYMANAGEDIALOGOPTIONS.DEFAULT;
pub const LMD_ALLOWUNINDEXABLENETWORKLOCATIONS = LIBRARYMANAGEDIALOGOPTIONS.ALLOWUNINDEXABLENETWORKLOCATIONS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssocHandlerInvoker_Value = @import("../zig.zig").Guid.initString("92218cab-ecaa-4335-8133-807fd234c2ee");
pub const IID_IAssocHandlerInvoker = &IID_IAssocHandlerInvoker_Value;
pub const IAssocHandlerInvoker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SupportsSelection: fn(
            self: *const IAssocHandlerInvoker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const IAssocHandlerInvoker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssocHandlerInvoker_SupportsSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssocHandlerInvoker.VTable, self.vtable).SupportsSelection(@ptrCast(*const IAssocHandlerInvoker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssocHandlerInvoker_Invoke(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssocHandlerInvoker.VTable, self.vtable).Invoke(@ptrCast(*const IAssocHandlerInvoker, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AHTYPE = enum(i32) {
    UNDEFINED = 0,
    USER_APPLICATION = 8,
    ANY_APPLICATION = 16,
    MACHINEDEFAULT = 32,
    PROGID = 64,
    APPLICATION = 128,
    CLASS_APPLICATION = 256,
    ANY_PROGID = 512,
};
pub const AHTYPE_UNDEFINED = AHTYPE.UNDEFINED;
pub const AHTYPE_USER_APPLICATION = AHTYPE.USER_APPLICATION;
pub const AHTYPE_ANY_APPLICATION = AHTYPE.ANY_APPLICATION;
pub const AHTYPE_MACHINEDEFAULT = AHTYPE.MACHINEDEFAULT;
pub const AHTYPE_PROGID = AHTYPE.PROGID;
pub const AHTYPE_APPLICATION = AHTYPE.APPLICATION;
pub const AHTYPE_CLASS_APPLICATION = AHTYPE.CLASS_APPLICATION;
pub const AHTYPE_ANY_PROGID = AHTYPE.ANY_PROGID;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssocHandler_Value = @import("../zig.zig").Guid.initString("f04061ac-1659-4a3f-a954-775aa57fc083");
pub const IID_IAssocHandler = &IID_IAssocHandler_Value;
pub const IAssocHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IAssocHandler,
            ppsz: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUIName: fn(
            self: *const IAssocHandler,
            ppsz: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconLocation: fn(
            self: *const IAssocHandler,
            ppszPath: ?*?PWSTR,
            pIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRecommended: fn(
            self: *const IAssocHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeDefault: fn(
            self: *const IAssocHandler,
            pszDescription: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const IAssocHandler,
            pdo: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInvoker: fn(
            self: *const IAssocHandler,
            pdo: ?*IDataObject,
            ppInvoker: ?*?*IAssocHandlerInvoker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssocHandler_GetName(self: *const T, ppsz: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssocHandler.VTable, self.vtable).GetName(@ptrCast(*const IAssocHandler, self), ppsz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssocHandler_GetUIName(self: *const T, ppsz: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssocHandler.VTable, self.vtable).GetUIName(@ptrCast(*const IAssocHandler, self), ppsz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssocHandler_GetIconLocation(self: *const T, ppszPath: ?*?PWSTR, pIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssocHandler.VTable, self.vtable).GetIconLocation(@ptrCast(*const IAssocHandler, self), ppszPath, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssocHandler_IsRecommended(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssocHandler.VTable, self.vtable).IsRecommended(@ptrCast(*const IAssocHandler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssocHandler_MakeDefault(self: *const T, pszDescription: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssocHandler.VTable, self.vtable).MakeDefault(@ptrCast(*const IAssocHandler, self), pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssocHandler_Invoke(self: *const T, pdo: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssocHandler.VTable, self.vtable).Invoke(@ptrCast(*const IAssocHandler, self), pdo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssocHandler_CreateInvoker(self: *const T, pdo: ?*IDataObject, ppInvoker: ?*?*IAssocHandlerInvoker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssocHandler.VTable, self.vtable).CreateInvoker(@ptrCast(*const IAssocHandler, self), pdo, ppInvoker);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumAssocHandlers_Value = @import("../zig.zig").Guid.initString("973810ae-9599-4b88-9e4d-6ee98c9552da");
pub const IID_IEnumAssocHandlers = &IID_IEnumAssocHandlers_Value;
pub const IEnumAssocHandlers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumAssocHandlers,
            celt: u32,
            rgelt: [*]?*IAssocHandler,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumAssocHandlers_Next(self: *const T, celt: u32, rgelt: [*]?*IAssocHandler, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumAssocHandlers.VTable, self.vtable).Next(@ptrCast(*const IEnumAssocHandlers, self), celt, rgelt, pceltFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ASSOC_FILTER = enum(i32) {
    NONE = 0,
    RECOMMENDED = 1,
};
pub const ASSOC_FILTER_NONE = ASSOC_FILTER.NONE;
pub const ASSOC_FILTER_RECOMMENDED = ASSOC_FILTER.RECOMMENDED;

// TODO: this type is limited to platform 'windows8.0'
const IID_IDataObjectProvider_Value = @import("../zig.zig").Guid.initString("3d25f6d6-4b2a-433c-9184-7c33ad35d001");
pub const IID_IDataObjectProvider = &IID_IDataObjectProvider_Value;
pub const IDataObjectProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataObject: fn(
            self: *const IDataObjectProvider,
            dataObject: ?*?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDataObject: fn(
            self: *const IDataObjectProvider,
            dataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObjectProvider_GetDataObject(self: *const T, dataObject: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObjectProvider.VTable, self.vtable).GetDataObject(@ptrCast(*const IDataObjectProvider, self), dataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObjectProvider_SetDataObject(self: *const T, dataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObjectProvider.VTable, self.vtable).SetDataObject(@ptrCast(*const IDataObjectProvider, self), dataObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDataTransferManagerInterop_Value = @import("../zig.zig").Guid.initString("3a3dcd6c-3eab-43dc-bcde-45671ce800c8");
pub const IID_IDataTransferManagerInterop = &IID_IDataTransferManagerInterop_Value;
pub const IDataTransferManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetForWindow: fn(
            self: *const IDataTransferManagerInterop,
            appWindow: ?HWND,
            riid: ?*const Guid,
            dataTransferManager: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowShareUIForWindow: fn(
            self: *const IDataTransferManagerInterop,
            appWindow: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataTransferManagerInterop_GetForWindow(self: *const T, appWindow: ?HWND, riid: ?*const Guid, dataTransferManager: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataTransferManagerInterop.VTable, self.vtable).GetForWindow(@ptrCast(*const IDataTransferManagerInterop, self), appWindow, riid, dataTransferManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataTransferManagerInterop_ShowShareUIForWindow(self: *const T, appWindow: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataTransferManagerInterop.VTable, self.vtable).ShowShareUIForWindow(@ptrCast(*const IDataTransferManagerInterop, self), appWindow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFrameworkInputPaneHandler_Value = @import("../zig.zig").Guid.initString("226c537b-1e76-4d9e-a760-33db29922f18");
pub const IID_IFrameworkInputPaneHandler = &IID_IFrameworkInputPaneHandler_Value;
pub const IFrameworkInputPaneHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Showing: fn(
            self: *const IFrameworkInputPaneHandler,
            prcInputPaneScreenLocation: ?*RECT,
            fEnsureFocusedElementInView: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hiding: fn(
            self: *const IFrameworkInputPaneHandler,
            fEnsureFocusedElementInView: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrameworkInputPaneHandler_Showing(self: *const T, prcInputPaneScreenLocation: ?*RECT, fEnsureFocusedElementInView: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrameworkInputPaneHandler.VTable, self.vtable).Showing(@ptrCast(*const IFrameworkInputPaneHandler, self), prcInputPaneScreenLocation, fEnsureFocusedElementInView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrameworkInputPaneHandler_Hiding(self: *const T, fEnsureFocusedElementInView: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrameworkInputPaneHandler.VTable, self.vtable).Hiding(@ptrCast(*const IFrameworkInputPaneHandler, self), fEnsureFocusedElementInView);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFrameworkInputPane_Value = @import("../zig.zig").Guid.initString("5752238b-24f0-495a-82f1-2fd593056796");
pub const IID_IFrameworkInputPane = &IID_IFrameworkInputPane_Value;
pub const IFrameworkInputPane = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: fn(
            self: *const IFrameworkInputPane,
            pWindow: ?*IUnknown,
            pHandler: ?*IFrameworkInputPaneHandler,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseWithHWND: fn(
            self: *const IFrameworkInputPane,
            hwnd: ?HWND,
            pHandler: ?*IFrameworkInputPaneHandler,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IFrameworkInputPane,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Location: fn(
            self: *const IFrameworkInputPane,
            prcInputPaneScreenLocation: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrameworkInputPane_Advise(self: *const T, pWindow: ?*IUnknown, pHandler: ?*IFrameworkInputPaneHandler, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrameworkInputPane.VTable, self.vtable).Advise(@ptrCast(*const IFrameworkInputPane, self), pWindow, pHandler, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrameworkInputPane_AdviseWithHWND(self: *const T, hwnd: ?HWND, pHandler: ?*IFrameworkInputPaneHandler, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrameworkInputPane.VTable, self.vtable).AdviseWithHWND(@ptrCast(*const IFrameworkInputPane, self), hwnd, pHandler, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrameworkInputPane_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrameworkInputPane.VTable, self.vtable).Unadvise(@ptrCast(*const IFrameworkInputPane, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrameworkInputPane_Location(self: *const T, prcInputPaneScreenLocation: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFrameworkInputPane.VTable, self.vtable).Location(@ptrCast(*const IFrameworkInputPane, self), prcInputPaneScreenLocation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MONITOR_APP_VISIBILITY = enum(i32) {
    UNKNOWN = 0,
    NO_APP_VISIBLE = 1,
    APP_VISIBLE = 2,
};
pub const MAV_UNKNOWN = MONITOR_APP_VISIBILITY.UNKNOWN;
pub const MAV_NO_APP_VISIBLE = MONITOR_APP_VISIBILITY.NO_APP_VISIBLE;
pub const MAV_APP_VISIBLE = MONITOR_APP_VISIBILITY.APP_VISIBLE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppVisibilityEvents_Value = @import("../zig.zig").Guid.initString("6584ce6b-7d82-49c2-89c9-c6bc02ba8c38");
pub const IID_IAppVisibilityEvents = &IID_IAppVisibilityEvents_Value;
pub const IAppVisibilityEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AppVisibilityOnMonitorChanged: fn(
            self: *const IAppVisibilityEvents,
            hMonitor: ?HMONITOR,
            previousMode: MONITOR_APP_VISIBILITY,
            currentMode: MONITOR_APP_VISIBILITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LauncherVisibilityChange: fn(
            self: *const IAppVisibilityEvents,
            currentVisibleState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppVisibilityEvents_AppVisibilityOnMonitorChanged(self: *const T, hMonitor: ?HMONITOR, previousMode: MONITOR_APP_VISIBILITY, currentMode: MONITOR_APP_VISIBILITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppVisibilityEvents.VTable, self.vtable).AppVisibilityOnMonitorChanged(@ptrCast(*const IAppVisibilityEvents, self), hMonitor, previousMode, currentMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppVisibilityEvents_LauncherVisibilityChange(self: *const T, currentVisibleState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppVisibilityEvents.VTable, self.vtable).LauncherVisibilityChange(@ptrCast(*const IAppVisibilityEvents, self), currentVisibleState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAppVisibility_Value = @import("../zig.zig").Guid.initString("2246ea2d-caea-4444-a3c4-6de827e44313");
pub const IID_IAppVisibility = &IID_IAppVisibility_Value;
pub const IAppVisibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppVisibilityOnMonitor: fn(
            self: *const IAppVisibility,
            hMonitor: ?HMONITOR,
            pMode: ?*MONITOR_APP_VISIBILITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsLauncherVisible: fn(
            self: *const IAppVisibility,
            pfVisible: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IAppVisibility,
            pCallback: ?*IAppVisibilityEvents,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IAppVisibility,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppVisibility_GetAppVisibilityOnMonitor(self: *const T, hMonitor: ?HMONITOR, pMode: ?*MONITOR_APP_VISIBILITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppVisibility.VTable, self.vtable).GetAppVisibilityOnMonitor(@ptrCast(*const IAppVisibility, self), hMonitor, pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppVisibility_IsLauncherVisible(self: *const T, pfVisible: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppVisibility.VTable, self.vtable).IsLauncherVisible(@ptrCast(*const IAppVisibility, self), pfVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppVisibility_Advise(self: *const T, pCallback: ?*IAppVisibilityEvents, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppVisibility.VTable, self.vtable).Advise(@ptrCast(*const IAppVisibility, self), pCallback, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppVisibility_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppVisibility.VTable, self.vtable).Unadvise(@ptrCast(*const IAppVisibility, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PACKAGE_EXECUTION_STATE = enum(i32) {
    UNKNOWN = 0,
    RUNNING = 1,
    SUSPENDING = 2,
    SUSPENDED = 3,
    TERMINATED = 4,
};
pub const PES_UNKNOWN = PACKAGE_EXECUTION_STATE.UNKNOWN;
pub const PES_RUNNING = PACKAGE_EXECUTION_STATE.RUNNING;
pub const PES_SUSPENDING = PACKAGE_EXECUTION_STATE.SUSPENDING;
pub const PES_SUSPENDED = PACKAGE_EXECUTION_STATE.SUSPENDED;
pub const PES_TERMINATED = PACKAGE_EXECUTION_STATE.TERMINATED;

// TODO: this type is limited to platform 'windows8.0'
const IID_IPackageExecutionStateChangeNotification_Value = @import("../zig.zig").Guid.initString("1bb12a62-2ad8-432b-8ccf-0c2c52afcd5b");
pub const IID_IPackageExecutionStateChangeNotification = &IID_IPackageExecutionStateChangeNotification_Value;
pub const IPackageExecutionStateChangeNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStateChanged: fn(
            self: *const IPackageExecutionStateChangeNotification,
            pszPackageFullName: ?[*:0]const u16,
            pesNewState: PACKAGE_EXECUTION_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageExecutionStateChangeNotification_OnStateChanged(self: *const T, pszPackageFullName: ?[*:0]const u16, pesNewState: PACKAGE_EXECUTION_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageExecutionStateChangeNotification.VTable, self.vtable).OnStateChanged(@ptrCast(*const IPackageExecutionStateChangeNotification, self), pszPackageFullName, pesNewState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IPackageDebugSettings_Value = @import("../zig.zig").Guid.initString("f27c3930-8029-4ad1-94e3-3dba417810c1");
pub const IID_IPackageDebugSettings = &IID_IPackageDebugSettings_Value;
pub const IPackageDebugSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableDebugging: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
            debuggerCommandLine: ?[*:0]const u16,
            environment: ?[*]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableDebugging: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateAllProcesses: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTargetSessionId: fn(
            self: *const IPackageDebugSettings,
            sessionId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateBackgroundTasks: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
            taskCount: ?*u32,
            taskIds: ?*?*Guid,
            taskNames: ?*?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateBackgroundTask: fn(
            self: *const IPackageDebugSettings,
            taskId: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServicing: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopServicing: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSessionRedirection: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
            sessionId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopSessionRedirection: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPackageExecutionState: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
            packageExecutionState: ?*PACKAGE_EXECUTION_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForPackageStateChanges: fn(
            self: *const IPackageDebugSettings,
            packageFullName: ?[*:0]const u16,
            pPackageExecutionStateChangeNotification: ?*IPackageExecutionStateChangeNotification,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterForPackageStateChanges: fn(
            self: *const IPackageDebugSettings,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_EnableDebugging(self: *const T, packageFullName: ?[*:0]const u16, debuggerCommandLine: ?[*:0]const u16, environment: ?[*]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).EnableDebugging(@ptrCast(*const IPackageDebugSettings, self), packageFullName, debuggerCommandLine, environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_DisableDebugging(self: *const T, packageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).DisableDebugging(@ptrCast(*const IPackageDebugSettings, self), packageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_Suspend(self: *const T, packageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).Suspend(@ptrCast(*const IPackageDebugSettings, self), packageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_Resume(self: *const T, packageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).Resume(@ptrCast(*const IPackageDebugSettings, self), packageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_TerminateAllProcesses(self: *const T, packageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).TerminateAllProcesses(@ptrCast(*const IPackageDebugSettings, self), packageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_SetTargetSessionId(self: *const T, sessionId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).SetTargetSessionId(@ptrCast(*const IPackageDebugSettings, self), sessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_EnumerateBackgroundTasks(self: *const T, packageFullName: ?[*:0]const u16, taskCount: ?*u32, taskIds: ?*?*Guid, taskNames: ?*?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).EnumerateBackgroundTasks(@ptrCast(*const IPackageDebugSettings, self), packageFullName, taskCount, taskIds, taskNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_ActivateBackgroundTask(self: *const T, taskId: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).ActivateBackgroundTask(@ptrCast(*const IPackageDebugSettings, self), taskId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_StartServicing(self: *const T, packageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).StartServicing(@ptrCast(*const IPackageDebugSettings, self), packageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_StopServicing(self: *const T, packageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).StopServicing(@ptrCast(*const IPackageDebugSettings, self), packageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_StartSessionRedirection(self: *const T, packageFullName: ?[*:0]const u16, sessionId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).StartSessionRedirection(@ptrCast(*const IPackageDebugSettings, self), packageFullName, sessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_StopSessionRedirection(self: *const T, packageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).StopSessionRedirection(@ptrCast(*const IPackageDebugSettings, self), packageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_GetPackageExecutionState(self: *const T, packageFullName: ?[*:0]const u16, packageExecutionState: ?*PACKAGE_EXECUTION_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).GetPackageExecutionState(@ptrCast(*const IPackageDebugSettings, self), packageFullName, packageExecutionState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_RegisterForPackageStateChanges(self: *const T, packageFullName: ?[*:0]const u16, pPackageExecutionStateChangeNotification: ?*IPackageExecutionStateChangeNotification, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).RegisterForPackageStateChanges(@ptrCast(*const IPackageDebugSettings, self), packageFullName, pPackageExecutionStateChangeNotification, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings_UnregisterForPackageStateChanges(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings.VTable, self.vtable).UnregisterForPackageStateChanges(@ptrCast(*const IPackageDebugSettings, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPackageDebugSettings2_Value = @import("../zig.zig").Guid.initString("6e3194bb-ab82-4d22-93f5-fabda40e7b16");
pub const IID_IPackageDebugSettings2 = &IID_IPackageDebugSettings2_Value;
pub const IPackageDebugSettings2 = extern struct {
    pub const VTable = extern struct {
        base: IPackageDebugSettings.VTable,
        EnumerateApps: fn(
            self: *const IPackageDebugSettings2,
            packageFullName: ?[*:0]const u16,
            appCount: ?*u32,
            appUserModelIds: ?*?*?PWSTR,
            appDisplayNames: ?*?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPackageDebugSettings.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPackageDebugSettings2_EnumerateApps(self: *const T, packageFullName: ?[*:0]const u16, appCount: ?*u32, appUserModelIds: ?*?*?PWSTR, appDisplayNames: ?*?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPackageDebugSettings2.VTable, self.vtable).EnumerateApps(@ptrCast(*const IPackageDebugSettings2, self), packageFullName, appCount, appUserModelIds, appDisplayNames);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ISuspensionDependencyManager_Value = @import("../zig.zig").Guid.initString("52b83a42-2543-416a-81d9-c0de7969c8b3");
pub const IID_ISuspensionDependencyManager = &IID_ISuspensionDependencyManager_Value;
pub const ISuspensionDependencyManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterAsChild: fn(
            self: *const ISuspensionDependencyManager,
            processHandle: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GroupChildWithParent: fn(
            self: *const ISuspensionDependencyManager,
            childProcessHandle: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UngroupChildFromParent: fn(
            self: *const ISuspensionDependencyManager,
            childProcessHandle: ?HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISuspensionDependencyManager_RegisterAsChild(self: *const T, processHandle: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISuspensionDependencyManager.VTable, self.vtable).RegisterAsChild(@ptrCast(*const ISuspensionDependencyManager, self), processHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISuspensionDependencyManager_GroupChildWithParent(self: *const T, childProcessHandle: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISuspensionDependencyManager.VTable, self.vtable).GroupChildWithParent(@ptrCast(*const ISuspensionDependencyManager, self), childProcessHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISuspensionDependencyManager_UngroupChildFromParent(self: *const T, childProcessHandle: ?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISuspensionDependencyManager.VTable, self.vtable).UngroupChildFromParent(@ptrCast(*const ISuspensionDependencyManager, self), childProcessHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AHE_TYPE = enum(i32) {
    DESKTOP = 0,
    IMMERSIVE = 1,
};
pub const AHE_DESKTOP = AHE_TYPE.DESKTOP;
pub const AHE_IMMERSIVE = AHE_TYPE.IMMERSIVE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IExecuteCommandApplicationHostEnvironment_Value = @import("../zig.zig").Guid.initString("18b21aa9-e184-4ff0-9f5e-f882d03771b3");
pub const IID_IExecuteCommandApplicationHostEnvironment = &IID_IExecuteCommandApplicationHostEnvironment_Value;
pub const IExecuteCommandApplicationHostEnvironment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: fn(
            self: *const IExecuteCommandApplicationHostEnvironment,
            pahe: ?*AHE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecuteCommandApplicationHostEnvironment_GetValue(self: *const T, pahe: ?*AHE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecuteCommandApplicationHostEnvironment.VTable, self.vtable).GetValue(@ptrCast(*const IExecuteCommandApplicationHostEnvironment, self), pahe);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EC_HOST_UI_MODE = enum(i32) {
    DESKTOP = 0,
    IMMERSIVE = 1,
    SYSTEM_LAUNCHER = 2,
};
pub const ECHUIM_DESKTOP = EC_HOST_UI_MODE.DESKTOP;
pub const ECHUIM_IMMERSIVE = EC_HOST_UI_MODE.IMMERSIVE;
pub const ECHUIM_SYSTEM_LAUNCHER = EC_HOST_UI_MODE.SYSTEM_LAUNCHER;

// TODO: this type is limited to platform 'windows8.0'
const IID_IExecuteCommandHost_Value = @import("../zig.zig").Guid.initString("4b6832a2-5f04-4c9d-b89d-727a15d103e7");
pub const IID_IExecuteCommandHost = &IID_IExecuteCommandHost_Value;
pub const IExecuteCommandHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUIMode: fn(
            self: *const IExecuteCommandHost,
            pUIMode: ?*EC_HOST_UI_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExecuteCommandHost_GetUIMode(self: *const T, pUIMode: ?*EC_HOST_UI_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExecuteCommandHost.VTable, self.vtable).GetUIMode(@ptrCast(*const IExecuteCommandHost, self), pUIMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APPLICATION_VIEW_STATE = enum(i32) {
    FULLSCREEN_LANDSCAPE = 0,
    FILLED = 1,
    SNAPPED = 2,
    FULLSCREEN_PORTRAIT = 3,
};
pub const AVS_FULLSCREEN_LANDSCAPE = APPLICATION_VIEW_STATE.FULLSCREEN_LANDSCAPE;
pub const AVS_FILLED = APPLICATION_VIEW_STATE.FILLED;
pub const AVS_SNAPPED = APPLICATION_VIEW_STATE.SNAPPED;
pub const AVS_FULLSCREEN_PORTRAIT = APPLICATION_VIEW_STATE.FULLSCREEN_PORTRAIT;

pub const EDGE_GESTURE_KIND = enum(i32) {
    TOUCH = 0,
    KEYBOARD = 1,
    MOUSE = 2,
};
pub const EGK_TOUCH = EDGE_GESTURE_KIND.TOUCH;
pub const EGK_KEYBOARD = EDGE_GESTURE_KIND.KEYBOARD;
pub const EGK_MOUSE = EDGE_GESTURE_KIND.MOUSE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IApplicationDesignModeSettings_Value = @import("../zig.zig").Guid.initString("2a3dee9a-e31d-46d6-8508-bcc597db3557");
pub const IID_IApplicationDesignModeSettings = &IID_IApplicationDesignModeSettings_Value;
pub const IApplicationDesignModeSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNativeDisplaySize: fn(
            self: *const IApplicationDesignModeSettings,
            nativeDisplaySizePixels: SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScaleFactor: fn(
            self: *const IApplicationDesignModeSettings,
            scaleFactor: DEVICE_SCALE_FACTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationViewState: fn(
            self: *const IApplicationDesignModeSettings,
            viewState: APPLICATION_VIEW_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComputeApplicationSize: fn(
            self: *const IApplicationDesignModeSettings,
            applicationSizePixels: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsApplicationViewStateSupported: fn(
            self: *const IApplicationDesignModeSettings,
            viewState: APPLICATION_VIEW_STATE,
            nativeDisplaySizePixels: SIZE,
            scaleFactor: DEVICE_SCALE_FACTOR,
            supported: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TriggerEdgeGesture: fn(
            self: *const IApplicationDesignModeSettings,
            edgeGestureKind: EDGE_GESTURE_KIND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings_SetNativeDisplaySize(self: *const T, nativeDisplaySizePixels: SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings.VTable, self.vtable).SetNativeDisplaySize(@ptrCast(*const IApplicationDesignModeSettings, self), nativeDisplaySizePixels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings_SetScaleFactor(self: *const T, scaleFactor: DEVICE_SCALE_FACTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings.VTable, self.vtable).SetScaleFactor(@ptrCast(*const IApplicationDesignModeSettings, self), scaleFactor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings_SetApplicationViewState(self: *const T, viewState: APPLICATION_VIEW_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings.VTable, self.vtable).SetApplicationViewState(@ptrCast(*const IApplicationDesignModeSettings, self), viewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings_ComputeApplicationSize(self: *const T, applicationSizePixels: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings.VTable, self.vtable).ComputeApplicationSize(@ptrCast(*const IApplicationDesignModeSettings, self), applicationSizePixels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings_IsApplicationViewStateSupported(self: *const T, viewState: APPLICATION_VIEW_STATE, nativeDisplaySizePixels: SIZE, scaleFactor: DEVICE_SCALE_FACTOR, supported: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings.VTable, self.vtable).IsApplicationViewStateSupported(@ptrCast(*const IApplicationDesignModeSettings, self), viewState, nativeDisplaySizePixels, scaleFactor, supported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings_TriggerEdgeGesture(self: *const T, edgeGestureKind: EDGE_GESTURE_KIND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings.VTable, self.vtable).TriggerEdgeGesture(@ptrCast(*const IApplicationDesignModeSettings, self), edgeGestureKind);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NATIVE_DISPLAY_ORIENTATION = enum(i32) {
    LANDSCAPE = 0,
    PORTRAIT = 1,
};
pub const NDO_LANDSCAPE = NATIVE_DISPLAY_ORIENTATION.LANDSCAPE;
pub const NDO_PORTRAIT = NATIVE_DISPLAY_ORIENTATION.PORTRAIT;

pub const APPLICATION_VIEW_ORIENTATION = enum(i32) {
    LANDSCAPE = 0,
    PORTRAIT = 1,
};
pub const AVO_LANDSCAPE = APPLICATION_VIEW_ORIENTATION.LANDSCAPE;
pub const AVO_PORTRAIT = APPLICATION_VIEW_ORIENTATION.PORTRAIT;

pub const ADJACENT_DISPLAY_EDGES = enum(i32) {
    NONE = 0,
    LEFT = 1,
    RIGHT = 2,
};
pub const ADE_NONE = ADJACENT_DISPLAY_EDGES.NONE;
pub const ADE_LEFT = ADJACENT_DISPLAY_EDGES.LEFT;
pub const ADE_RIGHT = ADJACENT_DISPLAY_EDGES.RIGHT;

pub const APPLICATION_VIEW_MIN_WIDTH = enum(i32) {
    DEFAULT = 0,
    @"320" = 1,
    @"500" = 2,
};
pub const AVMW_DEFAULT = APPLICATION_VIEW_MIN_WIDTH.DEFAULT;
pub const AVMW_320 = APPLICATION_VIEW_MIN_WIDTH.@"320";
pub const AVMW_500 = APPLICATION_VIEW_MIN_WIDTH.@"500";

// TODO: this type is limited to platform 'windows8.1'
const IID_IApplicationDesignModeSettings2_Value = @import("../zig.zig").Guid.initString("490514e1-675a-4d6e-a58d-e54901b4ca2f");
pub const IID_IApplicationDesignModeSettings2 = &IID_IApplicationDesignModeSettings2_Value;
pub const IApplicationDesignModeSettings2 = extern struct {
    pub const VTable = extern struct {
        base: IApplicationDesignModeSettings.VTable,
        SetNativeDisplayOrientation: fn(
            self: *const IApplicationDesignModeSettings2,
            nativeDisplayOrientation: NATIVE_DISPLAY_ORIENTATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationViewOrientation: fn(
            self: *const IApplicationDesignModeSettings2,
            viewOrientation: APPLICATION_VIEW_ORIENTATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAdjacentDisplayEdges: fn(
            self: *const IApplicationDesignModeSettings2,
            adjacentDisplayEdges: ADJACENT_DISPLAY_EDGES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIsOnLockScreen: fn(
            self: *const IApplicationDesignModeSettings2,
            isOnLockScreen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationViewMinWidth: fn(
            self: *const IApplicationDesignModeSettings2,
            viewMinWidth: APPLICATION_VIEW_MIN_WIDTH,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplicationSizeBounds: fn(
            self: *const IApplicationDesignModeSettings2,
            minApplicationSizePixels: ?*SIZE,
            maxApplicationSizePixels: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplicationViewOrientation: fn(
            self: *const IApplicationDesignModeSettings2,
            applicationSizePixels: SIZE,
            viewOrientation: ?*APPLICATION_VIEW_ORIENTATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IApplicationDesignModeSettings.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings2_SetNativeDisplayOrientation(self: *const T, nativeDisplayOrientation: NATIVE_DISPLAY_ORIENTATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings2.VTable, self.vtable).SetNativeDisplayOrientation(@ptrCast(*const IApplicationDesignModeSettings2, self), nativeDisplayOrientation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings2_SetApplicationViewOrientation(self: *const T, viewOrientation: APPLICATION_VIEW_ORIENTATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings2.VTable, self.vtable).SetApplicationViewOrientation(@ptrCast(*const IApplicationDesignModeSettings2, self), viewOrientation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings2_SetAdjacentDisplayEdges(self: *const T, adjacentDisplayEdges: ADJACENT_DISPLAY_EDGES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings2.VTable, self.vtable).SetAdjacentDisplayEdges(@ptrCast(*const IApplicationDesignModeSettings2, self), adjacentDisplayEdges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings2_SetIsOnLockScreen(self: *const T, isOnLockScreen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings2.VTable, self.vtable).SetIsOnLockScreen(@ptrCast(*const IApplicationDesignModeSettings2, self), isOnLockScreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings2_SetApplicationViewMinWidth(self: *const T, viewMinWidth: APPLICATION_VIEW_MIN_WIDTH) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings2.VTable, self.vtable).SetApplicationViewMinWidth(@ptrCast(*const IApplicationDesignModeSettings2, self), viewMinWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings2_GetApplicationSizeBounds(self: *const T, minApplicationSizePixels: ?*SIZE, maxApplicationSizePixels: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings2.VTable, self.vtable).GetApplicationSizeBounds(@ptrCast(*const IApplicationDesignModeSettings2, self), minApplicationSizePixels, maxApplicationSizePixels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDesignModeSettings2_GetApplicationViewOrientation(self: *const T, applicationSizePixels: SIZE, viewOrientation: ?*APPLICATION_VIEW_ORIENTATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDesignModeSettings2.VTable, self.vtable).GetApplicationViewOrientation(@ptrCast(*const IApplicationDesignModeSettings2, self), applicationSizePixels, viewOrientation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ILaunchTargetMonitor_Value = @import("../zig.zig").Guid.initString("266fbc7e-490d-46ed-a96b-2274db252003");
pub const IID_ILaunchTargetMonitor = &IID_ILaunchTargetMonitor_Value;
pub const ILaunchTargetMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMonitor: fn(
            self: *const ILaunchTargetMonitor,
            monitor: ?*?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILaunchTargetMonitor_GetMonitor(self: *const T, monitor: ?*?HMONITOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILaunchTargetMonitor.VTable, self.vtable).GetMonitor(@ptrCast(*const ILaunchTargetMonitor, self), monitor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APPLICATION_VIEW_SIZE_PREFERENCE = enum(i32) {
    DEFAULT = 0,
    USE_LESS = 1,
    USE_HALF = 2,
    USE_MORE = 3,
    USE_MINIMUM = 4,
    USE_NONE = 5,
    CUSTOM = 6,
};
pub const AVSP_DEFAULT = APPLICATION_VIEW_SIZE_PREFERENCE.DEFAULT;
pub const AVSP_USE_LESS = APPLICATION_VIEW_SIZE_PREFERENCE.USE_LESS;
pub const AVSP_USE_HALF = APPLICATION_VIEW_SIZE_PREFERENCE.USE_HALF;
pub const AVSP_USE_MORE = APPLICATION_VIEW_SIZE_PREFERENCE.USE_MORE;
pub const AVSP_USE_MINIMUM = APPLICATION_VIEW_SIZE_PREFERENCE.USE_MINIMUM;
pub const AVSP_USE_NONE = APPLICATION_VIEW_SIZE_PREFERENCE.USE_NONE;
pub const AVSP_CUSTOM = APPLICATION_VIEW_SIZE_PREFERENCE.CUSTOM;

// TODO: this type is limited to platform 'windows8.1'
const IID_ILaunchSourceViewSizePreference_Value = @import("../zig.zig").Guid.initString("e5aa01f7-1fb8-4830-8720-4e6734cbd5f3");
pub const IID_ILaunchSourceViewSizePreference = &IID_ILaunchSourceViewSizePreference_Value;
pub const ILaunchSourceViewSizePreference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceViewToPosition: fn(
            self: *const ILaunchSourceViewSizePreference,
            hwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceViewSizePreference: fn(
            self: *const ILaunchSourceViewSizePreference,
            sourceSizeAfterLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILaunchSourceViewSizePreference_GetSourceViewToPosition(self: *const T, hwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILaunchSourceViewSizePreference.VTable, self.vtable).GetSourceViewToPosition(@ptrCast(*const ILaunchSourceViewSizePreference, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILaunchSourceViewSizePreference_GetSourceViewSizePreference(self: *const T, sourceSizeAfterLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILaunchSourceViewSizePreference.VTable, self.vtable).GetSourceViewSizePreference(@ptrCast(*const ILaunchSourceViewSizePreference, self), sourceSizeAfterLaunch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ILaunchTargetViewSizePreference_Value = @import("../zig.zig").Guid.initString("2f0666c6-12f7-4360-b511-a394a0553725");
pub const IID_ILaunchTargetViewSizePreference = &IID_ILaunchTargetViewSizePreference_Value;
pub const ILaunchTargetViewSizePreference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTargetViewSizePreference: fn(
            self: *const ILaunchTargetViewSizePreference,
            targetSizeOnLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILaunchTargetViewSizePreference_GetTargetViewSizePreference(self: *const T, targetSizeOnLaunch: ?*APPLICATION_VIEW_SIZE_PREFERENCE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILaunchTargetViewSizePreference.VTable, self.vtable).GetTargetViewSizePreference(@ptrCast(*const ILaunchTargetViewSizePreference, self), targetSizeOnLaunch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ILaunchSourceAppUserModelId_Value = @import("../zig.zig").Guid.initString("989191ac-28ff-4cf0-9584-e0d078bc2396");
pub const IID_ILaunchSourceAppUserModelId = &IID_ILaunchSourceAppUserModelId_Value;
pub const ILaunchSourceAppUserModelId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppUserModelId: fn(
            self: *const ILaunchSourceAppUserModelId,
            launchingApp: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILaunchSourceAppUserModelId_GetAppUserModelId(self: *const T, launchingApp: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILaunchSourceAppUserModelId.VTable, self.vtable).GetAppUserModelId(@ptrCast(*const ILaunchSourceAppUserModelId, self), launchingApp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IInitializeWithWindow_Value = @import("../zig.zig").Guid.initString("3e68d4bd-7135-4d10-8018-9fb6d9f33fa1");
pub const IID_IInitializeWithWindow = &IID_IInitializeWithWindow_Value;
pub const IInitializeWithWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IInitializeWithWindow,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeWithWindow_Initialize(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeWithWindow.VTable, self.vtable).Initialize(@ptrCast(*const IInitializeWithWindow, self), hwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IHandlerInfo_Value = @import("../zig.zig").Guid.initString("997706ef-f880-453b-8118-39e1a2d2655a");
pub const IID_IHandlerInfo = &IID_IHandlerInfo_Value;
pub const IHandlerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetApplicationDisplayName: fn(
            self: *const IHandlerInfo,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplicationPublisher: fn(
            self: *const IHandlerInfo,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplicationIconReference: fn(
            self: *const IHandlerInfo,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHandlerInfo_GetApplicationDisplayName(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHandlerInfo.VTable, self.vtable).GetApplicationDisplayName(@ptrCast(*const IHandlerInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHandlerInfo_GetApplicationPublisher(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHandlerInfo.VTable, self.vtable).GetApplicationPublisher(@ptrCast(*const IHandlerInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHandlerInfo_GetApplicationIconReference(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHandlerInfo.VTable, self.vtable).GetApplicationIconReference(@ptrCast(*const IHandlerInfo, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHandlerInfo2_Value = @import("../zig.zig").Guid.initString("31cca04c-04d3-4ea9-90de-97b15e87a532");
pub const IID_IHandlerInfo2 = &IID_IHandlerInfo2_Value;
pub const IHandlerInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IHandlerInfo.VTable,
        GetApplicationId: fn(
            self: *const IHandlerInfo2,
            value: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHandlerInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHandlerInfo2_GetApplicationId(self: *const T, value: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHandlerInfo2.VTable, self.vtable).GetApplicationId(@ptrCast(*const IHandlerInfo2, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IHandlerActivationHost_Value = @import("../zig.zig").Guid.initString("35094a87-8bb1-4237-96c6-c417eebdb078");
pub const IID_IHandlerActivationHost = &IID_IHandlerActivationHost_Value;
pub const IHandlerActivationHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeforeCoCreateInstance: fn(
            self: *const IHandlerActivationHost,
            clsidHandler: ?*const Guid,
            itemsBeingActivated: ?*IShellItemArray,
            handlerInfo: ?*IHandlerInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeforeCreateProcess: fn(
            self: *const IHandlerActivationHost,
            applicationPath: ?[*:0]const u16,
            commandLine: ?[*:0]const u16,
            handlerInfo: ?*IHandlerInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHandlerActivationHost_BeforeCoCreateInstance(self: *const T, clsidHandler: ?*const Guid, itemsBeingActivated: ?*IShellItemArray, handlerInfo: ?*IHandlerInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHandlerActivationHost.VTable, self.vtable).BeforeCoCreateInstance(@ptrCast(*const IHandlerActivationHost, self), clsidHandler, itemsBeingActivated, handlerInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHandlerActivationHost_BeforeCreateProcess(self: *const T, applicationPath: ?[*:0]const u16, commandLine: ?[*:0]const u16, handlerInfo: ?*IHandlerInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHandlerActivationHost.VTable, self.vtable).BeforeCreateProcess(@ptrCast(*const IHandlerActivationHost, self), applicationPath, commandLine, handlerInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppActivationUIInfo_Value = @import("../zig.zig").Guid.initString("abad189d-9fa3-4278-b3ca-8ca448a88dcb");
pub const IID_IAppActivationUIInfo = &IID_IAppActivationUIInfo_Value;
pub const IAppActivationUIInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMonitor: fn(
            self: *const IAppActivationUIInfo,
            value: ?*?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInvokePoint: fn(
            self: *const IAppActivationUIInfo,
            value: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShowCommand: fn(
            self: *const IAppActivationUIInfo,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShowUI: fn(
            self: *const IAppActivationUIInfo,
            value: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyState: fn(
            self: *const IAppActivationUIInfo,
            value: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppActivationUIInfo_GetMonitor(self: *const T, value: ?*?HMONITOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppActivationUIInfo.VTable, self.vtable).GetMonitor(@ptrCast(*const IAppActivationUIInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppActivationUIInfo_GetInvokePoint(self: *const T, value: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppActivationUIInfo.VTable, self.vtable).GetInvokePoint(@ptrCast(*const IAppActivationUIInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppActivationUIInfo_GetShowCommand(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppActivationUIInfo.VTable, self.vtable).GetShowCommand(@ptrCast(*const IAppActivationUIInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppActivationUIInfo_GetShowUI(self: *const T, value: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppActivationUIInfo.VTable, self.vtable).GetShowUI(@ptrCast(*const IAppActivationUIInfo, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppActivationUIInfo_GetKeyState(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppActivationUIInfo.VTable, self.vtable).GetKeyState(@ptrCast(*const IAppActivationUIInfo, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FLYOUT_PLACEMENT = enum(i32) {
    DEFAULT = 0,
    ABOVE = 1,
    BELOW = 2,
    LEFT = 3,
    RIGHT = 4,
};
pub const FP_DEFAULT = FLYOUT_PLACEMENT.DEFAULT;
pub const FP_ABOVE = FLYOUT_PLACEMENT.ABOVE;
pub const FP_BELOW = FLYOUT_PLACEMENT.BELOW;
pub const FP_LEFT = FLYOUT_PLACEMENT.LEFT;
pub const FP_RIGHT = FLYOUT_PLACEMENT.RIGHT;

// TODO: this type is limited to platform 'windows8.1'
const IID_IContactManagerInterop_Value = @import("../zig.zig").Guid.initString("99eacba7-e073-43b6-a896-55afe48a0833");
pub const IID_IContactManagerInterop = &IID_IContactManagerInterop_Value;
pub const IContactManagerInterop = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowContactCardForWindow: fn(
            self: *const IContactManagerInterop,
            appWindow: ?HWND,
            contact: ?*IUnknown,
            selection: ?*const RECT,
            preferredPlacement: FLYOUT_PLACEMENT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContactManagerInterop_ShowContactCardForWindow(self: *const T, appWindow: ?HWND, contact: ?*IUnknown, selection: ?*const RECT, preferredPlacement: FLYOUT_PLACEMENT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContactManagerInterop.VTable, self.vtable).ShowContactCardForWindow(@ptrCast(*const IContactManagerInterop, self), appWindow, contact, selection, preferredPlacement);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellIconOverlayIdentifier_Value = @import("../zig.zig").Guid.initString("0c6c4200-c589-11d0-999a-00c04fd655e1");
pub const IID_IShellIconOverlayIdentifier = &IID_IShellIconOverlayIdentifier_Value;
pub const IShellIconOverlayIdentifier = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMemberOf: fn(
            self: *const IShellIconOverlayIdentifier,
            pwszPath: ?[*:0]const u16,
            dwAttrib: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlayInfo: fn(
            self: *const IShellIconOverlayIdentifier,
            pwszIconFile: [*:0]u16,
            cchMax: i32,
            pIndex: ?*i32,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPriority: fn(
            self: *const IShellIconOverlayIdentifier,
            pPriority: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlayIdentifier_IsMemberOf(self: *const T, pwszPath: ?[*:0]const u16, dwAttrib: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlayIdentifier.VTable, self.vtable).IsMemberOf(@ptrCast(*const IShellIconOverlayIdentifier, self), pwszPath, dwAttrib);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlayIdentifier_GetOverlayInfo(self: *const T, pwszIconFile: [*:0]u16, cchMax: i32, pIndex: ?*i32, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlayIdentifier.VTable, self.vtable).GetOverlayInfo(@ptrCast(*const IShellIconOverlayIdentifier, self), pwszIconFile, cchMax, pIndex, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlayIdentifier_GetPriority(self: *const T, pPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlayIdentifier.VTable, self.vtable).GetPriority(@ptrCast(*const IShellIconOverlayIdentifier, self), pPriority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BANNER_NOTIFICATION_EVENT = enum(i32) {
    Rendered = 0,
    Hovered = 1,
    Closed = 2,
    Dismissed = 3,
    Button1Clicked = 4,
    Button2Clicked = 5,
};
pub const BNE_Rendered = BANNER_NOTIFICATION_EVENT.Rendered;
pub const BNE_Hovered = BANNER_NOTIFICATION_EVENT.Hovered;
pub const BNE_Closed = BANNER_NOTIFICATION_EVENT.Closed;
pub const BNE_Dismissed = BANNER_NOTIFICATION_EVENT.Dismissed;
pub const BNE_Button1Clicked = BANNER_NOTIFICATION_EVENT.Button1Clicked;
pub const BNE_Button2Clicked = BANNER_NOTIFICATION_EVENT.Button2Clicked;

pub const BANNER_NOTIFICATION = extern struct {
    event: BANNER_NOTIFICATION_EVENT,
    providerIdentity: ?[*:0]const u16,
    contentId: ?[*:0]const u16,
};

const IID_IBannerNotificationHandler_Value = @import("../zig.zig").Guid.initString("8d7b2ba7-db05-46a8-823c-d2b6de08ee91");
pub const IID_IBannerNotificationHandler = &IID_IBannerNotificationHandler_Value;
pub const IBannerNotificationHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnBannerEvent: fn(
            self: *const IBannerNotificationHandler,
            notification: ?*const BANNER_NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBannerNotificationHandler_OnBannerEvent(self: *const T, notification: ?*const BANNER_NOTIFICATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBannerNotificationHandler.VTable, self.vtable).OnBannerEvent(@ptrCast(*const IBannerNotificationHandler, self), notification);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SORT_ORDER_TYPE = enum(i32) {
    DEFAULT = 0,
    IGNORE_FOLDERNESS = 1,
};
pub const SOT_DEFAULT = SORT_ORDER_TYPE.DEFAULT;
pub const SOT_IGNORE_FOLDERNESS = SORT_ORDER_TYPE.IGNORE_FOLDERNESS;

const IID_ISortColumnArray_Value = @import("../zig.zig").Guid.initString("6dfc60fb-f2e9-459b-beb5-288f1a7c7d54");
pub const IID_ISortColumnArray = &IID_ISortColumnArray_Value;
pub const ISortColumnArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const ISortColumnArray,
            columnCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAt: fn(
            self: *const ISortColumnArray,
            index: u32,
            sortcolumn: ?*SORTCOLUMN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSortType: fn(
            self: *const ISortColumnArray,
            type: ?*SORT_ORDER_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISortColumnArray_GetCount(self: *const T, columnCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISortColumnArray.VTable, self.vtable).GetCount(@ptrCast(*const ISortColumnArray, self), columnCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISortColumnArray_GetAt(self: *const T, index: u32, sortcolumn: ?*SORTCOLUMN) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISortColumnArray.VTable, self.vtable).GetAt(@ptrCast(*const ISortColumnArray, self), index, sortcolumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISortColumnArray_GetSortType(self: *const T, type_: ?*SORT_ORDER_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISortColumnArray.VTable, self.vtable).GetSortType(@ptrCast(*const ISortColumnArray, self), type_);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPropertyKeyStore_Value = @import("../zig.zig").Guid.initString("75bd59aa-f23b-4963-aba4-0b355752a91b");
pub const IID_IPropertyKeyStore = &IID_IPropertyKeyStore_Value;
pub const IPropertyKeyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKeyCount: fn(
            self: *const IPropertyKeyStore,
            keyCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyAt: fn(
            self: *const IPropertyKeyStore,
            index: i32,
            pkey: ?*PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendKey: fn(
            self: *const IPropertyKeyStore,
            key: ?*const PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteKey: fn(
            self: *const IPropertyKeyStore,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsKeyInStore: fn(
            self: *const IPropertyKeyStore,
            key: ?*const PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveKey: fn(
            self: *const IPropertyKeyStore,
            key: ?*const PROPERTYKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyKeyStore_GetKeyCount(self: *const T, keyCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyKeyStore.VTable, self.vtable).GetKeyCount(@ptrCast(*const IPropertyKeyStore, self), keyCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyKeyStore_GetKeyAt(self: *const T, index: i32, pkey: ?*PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyKeyStore.VTable, self.vtable).GetKeyAt(@ptrCast(*const IPropertyKeyStore, self), index, pkey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyKeyStore_AppendKey(self: *const T, key: ?*const PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyKeyStore.VTable, self.vtable).AppendKey(@ptrCast(*const IPropertyKeyStore, self), key);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyKeyStore_DeleteKey(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyKeyStore.VTable, self.vtable).DeleteKey(@ptrCast(*const IPropertyKeyStore, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyKeyStore_IsKeyInStore(self: *const T, key: ?*const PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyKeyStore.VTable, self.vtable).IsKeyInStore(@ptrCast(*const IPropertyKeyStore, self), key);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyKeyStore_RemoveKey(self: *const T, key: ?*const PROPERTYKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertyKeyStore.VTable, self.vtable).RemoveKey(@ptrCast(*const IPropertyKeyStore, self), key);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IQueryCodePage_Value = @import("../zig.zig").Guid.initString("c7b236ce-ee80-11d0-985f-006008059382");
pub const IID_IQueryCodePage = &IID_IQueryCodePage_Value;
pub const IQueryCodePage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCodePage: fn(
            self: *const IQueryCodePage,
            puiCodePage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCodePage: fn(
            self: *const IQueryCodePage,
            uiCodePage: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryCodePage_GetCodePage(self: *const T, puiCodePage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryCodePage.VTable, self.vtable).GetCodePage(@ptrCast(*const IQueryCodePage, self), puiCodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryCodePage_SetCodePage(self: *const T, uiCodePage: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryCodePage.VTable, self.vtable).SetCodePage(@ptrCast(*const IQueryCodePage, self), uiCodePage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FOLDERVIEWOPTIONS = enum(i32) {
    DEFAULT = 0,
    VISTALAYOUT = 1,
    CUSTOMPOSITION = 2,
    CUSTOMORDERING = 4,
    SUPPORTHYPERLINKS = 8,
    NOANIMATIONS = 16,
    NOSCROLLTIPS = 32,
};
pub const FVO_DEFAULT = FOLDERVIEWOPTIONS.DEFAULT;
pub const FVO_VISTALAYOUT = FOLDERVIEWOPTIONS.VISTALAYOUT;
pub const FVO_CUSTOMPOSITION = FOLDERVIEWOPTIONS.CUSTOMPOSITION;
pub const FVO_CUSTOMORDERING = FOLDERVIEWOPTIONS.CUSTOMORDERING;
pub const FVO_SUPPORTHYPERLINKS = FOLDERVIEWOPTIONS.SUPPORTHYPERLINKS;
pub const FVO_NOANIMATIONS = FOLDERVIEWOPTIONS.NOANIMATIONS;
pub const FVO_NOSCROLLTIPS = FOLDERVIEWOPTIONS.NOSCROLLTIPS;

// TODO: this type is limited to platform 'windows6.1'
const IID_IFolderViewOptions_Value = @import("../zig.zig").Guid.initString("3cc974d2-b302-4d36-ad3e-06d93f695d3f");
pub const IID_IFolderViewOptions = &IID_IFolderViewOptions_Value;
pub const IFolderViewOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFolderViewOptions: fn(
            self: *const IFolderViewOptions,
            fvoMask: FOLDERVIEWOPTIONS,
            fvoFlags: FOLDERVIEWOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolderViewOptions: fn(
            self: *const IFolderViewOptions,
            pfvoFlags: ?*FOLDERVIEWOPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewOptions_SetFolderViewOptions(self: *const T, fvoMask: FOLDERVIEWOPTIONS, fvoFlags: FOLDERVIEWOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewOptions.VTable, self.vtable).SetFolderViewOptions(@ptrCast(*const IFolderViewOptions, self), fvoMask, fvoFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewOptions_GetFolderViewOptions(self: *const T, pfvoFlags: ?*FOLDERVIEWOPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewOptions.VTable, self.vtable).GetFolderViewOptions(@ptrCast(*const IFolderViewOptions, self), pfvoFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _SV3CVW3_FLAGS = enum(i32) {
    DEFAULT = 0,
    NONINTERACTIVE = 1,
    FORCEVIEWMODE = 2,
    FORCEFOLDERFLAGS = 4,
};
pub const SV3CVW3_DEFAULT = _SV3CVW3_FLAGS.DEFAULT;
pub const SV3CVW3_NONINTERACTIVE = _SV3CVW3_FLAGS.NONINTERACTIVE;
pub const SV3CVW3_FORCEVIEWMODE = _SV3CVW3_FLAGS.FORCEVIEWMODE;
pub const SV3CVW3_FORCEFOLDERFLAGS = _SV3CVW3_FLAGS.FORCEFOLDERFLAGS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellView3_Value = @import("../zig.zig").Guid.initString("ec39fa88-f8af-41c5-8421-38bed28f4673");
pub const IID_IShellView3 = &IID_IShellView3_Value;
pub const IShellView3 = extern struct {
    pub const VTable = extern struct {
        base: IShellView2.VTable,
        CreateViewWindow3: fn(
            self: *const IShellView3,
            psbOwner: ?*IShellBrowser,
            psvPrev: ?*IShellView,
            dwViewFlags: u32,
            dwMask: FOLDERFLAGS,
            dwFlags: FOLDERFLAGS,
            fvMode: FOLDERVIEWMODE,
            pvid: ?*const Guid,
            prcView: ?*const RECT,
            phwndView: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellView2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellView3_CreateViewWindow3(self: *const T, psbOwner: ?*IShellBrowser, psvPrev: ?*IShellView, dwViewFlags: u32, dwMask: FOLDERFLAGS, dwFlags: FOLDERFLAGS, fvMode: FOLDERVIEWMODE, pvid: ?*const Guid, prcView: ?*const RECT, phwndView: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellView3.VTable, self.vtable).CreateViewWindow3(@ptrCast(*const IShellView3, self), psbOwner, psvPrev, dwViewFlags, dwMask, dwFlags, fvMode, pvid, prcView, phwndView);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISearchBoxInfo_Value = @import("../zig.zig").Guid.initString("6af6e03f-d664-4ef4-9626-f7e0ed36755e");
pub const IID_ISearchBoxInfo = &IID_ISearchBoxInfo_Value;
pub const ISearchBoxInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCondition: fn(
            self: *const ISearchBoxInfo,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ISearchBoxInfo,
            ppsz: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchBoxInfo_GetCondition(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchBoxInfo.VTable, self.vtable).GetCondition(@ptrCast(*const ISearchBoxInfo, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchBoxInfo_GetText(self: *const T, ppsz: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchBoxInfo.VTable, self.vtable).GetText(@ptrCast(*const ISearchBoxInfo, self), ppsz);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VPWATERMARKFLAGS = enum(i32) {
    DEFAULT = 0,
    ALPHABLEND = 1,
};
pub const VPWF_DEFAULT = VPWATERMARKFLAGS.DEFAULT;
pub const VPWF_ALPHABLEND = VPWATERMARKFLAGS.ALPHABLEND;

pub const VPCOLORFLAGS = enum(i32) {
    TEXT = 1,
    BACKGROUND = 2,
    SORTCOLUMN = 3,
    SUBTEXT = 4,
    TEXTBACKGROUND = 5,
};
pub const VPCF_TEXT = VPCOLORFLAGS.TEXT;
pub const VPCF_BACKGROUND = VPCOLORFLAGS.BACKGROUND;
pub const VPCF_SORTCOLUMN = VPCOLORFLAGS.SORTCOLUMN;
pub const VPCF_SUBTEXT = VPCOLORFLAGS.SUBTEXT;
pub const VPCF_TEXTBACKGROUND = VPCOLORFLAGS.TEXTBACKGROUND;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IVisualProperties_Value = @import("../zig.zig").Guid.initString("e693cf68-d967-4112-8763-99172aee5e5a");
pub const IID_IVisualProperties = &IID_IVisualProperties_Value;
pub const IVisualProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetWatermark: fn(
            self: *const IVisualProperties,
            hbmp: ?HBITMAP,
            vpwf: VPWATERMARKFLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColor: fn(
            self: *const IVisualProperties,
            vpcf: VPCOLORFLAGS,
            cr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColor: fn(
            self: *const IVisualProperties,
            vpcf: VPCOLORFLAGS,
            pcr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItemHeight: fn(
            self: *const IVisualProperties,
            cyItemInPixels: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemHeight: fn(
            self: *const IVisualProperties,
            cyItemInPixels: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont: fn(
            self: *const IVisualProperties,
            plf: ?*const LOGFONTW,
            bRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont: fn(
            self: *const IVisualProperties,
            plf: ?*LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTheme: fn(
            self: *const IVisualProperties,
            pszSubAppName: ?[*:0]const u16,
            pszSubIdList: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVisualProperties_SetWatermark(self: *const T, hbmp: ?HBITMAP, vpwf: VPWATERMARKFLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVisualProperties.VTable, self.vtable).SetWatermark(@ptrCast(*const IVisualProperties, self), hbmp, vpwf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVisualProperties_SetColor(self: *const T, vpcf: VPCOLORFLAGS, cr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVisualProperties.VTable, self.vtable).SetColor(@ptrCast(*const IVisualProperties, self), vpcf, cr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVisualProperties_GetColor(self: *const T, vpcf: VPCOLORFLAGS, pcr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVisualProperties.VTable, self.vtable).GetColor(@ptrCast(*const IVisualProperties, self), vpcf, pcr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVisualProperties_SetItemHeight(self: *const T, cyItemInPixels: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVisualProperties.VTable, self.vtable).SetItemHeight(@ptrCast(*const IVisualProperties, self), cyItemInPixels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVisualProperties_GetItemHeight(self: *const T, cyItemInPixels: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVisualProperties.VTable, self.vtable).GetItemHeight(@ptrCast(*const IVisualProperties, self), cyItemInPixels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVisualProperties_SetFont(self: *const T, plf: ?*const LOGFONTW, bRedraw: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVisualProperties.VTable, self.vtable).SetFont(@ptrCast(*const IVisualProperties, self), plf, bRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVisualProperties_GetFont(self: *const T, plf: ?*LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVisualProperties.VTable, self.vtable).GetFont(@ptrCast(*const IVisualProperties, self), plf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVisualProperties_SetTheme(self: *const T, pszSubAppName: ?[*:0]const u16, pszSubIdList: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVisualProperties.VTable, self.vtable).SetTheme(@ptrCast(*const IVisualProperties, self), pszSubAppName, pszSubIdList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICommDlgBrowser3_Value = @import("../zig.zig").Guid.initString("c8ad25a1-3294-41ee-8165-71174bd01c57");
pub const IID_ICommDlgBrowser3 = &IID_ICommDlgBrowser3_Value;
pub const ICommDlgBrowser3 = extern struct {
    pub const VTable = extern struct {
        base: ICommDlgBrowser2.VTable,
        OnColumnClicked: fn(
            self: *const ICommDlgBrowser3,
            ppshv: ?*IShellView,
            iColumn: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentFilter: fn(
            self: *const ICommDlgBrowser3,
            pszFileSpec: [*:0]u16,
            cchFileSpec: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPreViewCreated: fn(
            self: *const ICommDlgBrowser3,
            ppshv: ?*IShellView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICommDlgBrowser2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommDlgBrowser3_OnColumnClicked(self: *const T, ppshv: ?*IShellView, iColumn: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommDlgBrowser3.VTable, self.vtable).OnColumnClicked(@ptrCast(*const ICommDlgBrowser3, self), ppshv, iColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommDlgBrowser3_GetCurrentFilter(self: *const T, pszFileSpec: [*:0]u16, cchFileSpec: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommDlgBrowser3.VTable, self.vtable).GetCurrentFilter(@ptrCast(*const ICommDlgBrowser3, self), pszFileSpec, cchFileSpec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommDlgBrowser3_OnPreViewCreated(self: *const T, ppshv: ?*IShellView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommDlgBrowser3.VTable, self.vtable).OnPreViewCreated(@ptrCast(*const ICommDlgBrowser3, self), ppshv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IUserAccountChangeCallback_Value = @import("../zig.zig").Guid.initString("a561e69a-b4b8-4113-91a5-64c6bcca3430");
pub const IID_IUserAccountChangeCallback = &IID_IUserAccountChangeCallback_Value;
pub const IUserAccountChangeCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPictureChange: fn(
            self: *const IUserAccountChangeCallback,
            pszUserName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserAccountChangeCallback_OnPictureChange(self: *const T, pszUserName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserAccountChangeCallback.VTable, self.vtable).OnPictureChange(@ptrCast(*const IUserAccountChangeCallback, self), pszUserName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamAsync_Value = @import("../zig.zig").Guid.initString("fe0b6665-e0ca-49b9-a178-2b5cb48d92a5");
pub const IID_IStreamAsync = &IID_IStreamAsync_Value;
pub const IStreamAsync = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        ReadAsync: fn(
            self: *const IStreamAsync,
            // TODO: what to do with BytesParamIndex 1?
            pv: ?*anyopaque,
            cb: u32,
            pcbRead: ?*u32,
            lpOverlapped: ?*OVERLAPPED,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAsync: fn(
            self: *const IStreamAsync,
            // TODO: what to do with BytesParamIndex 1?
            lpBuffer: ?*const anyopaque,
            cb: u32,
            pcbWritten: ?*u32,
            lpOverlapped: ?*OVERLAPPED,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OverlappedResult: fn(
            self: *const IStreamAsync,
            lpOverlapped: ?*OVERLAPPED,
            lpNumberOfBytesTransferred: ?*u32,
            bWait: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelIo: fn(
            self: *const IStreamAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamAsync_ReadAsync(self: *const T, pv: ?*anyopaque, cb: u32, pcbRead: ?*u32, lpOverlapped: ?*OVERLAPPED) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamAsync.VTable, self.vtable).ReadAsync(@ptrCast(*const IStreamAsync, self), pv, cb, pcbRead, lpOverlapped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamAsync_WriteAsync(self: *const T, lpBuffer: ?*const anyopaque, cb: u32, pcbWritten: ?*u32, lpOverlapped: ?*OVERLAPPED) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamAsync.VTable, self.vtable).WriteAsync(@ptrCast(*const IStreamAsync, self), lpBuffer, cb, pcbWritten, lpOverlapped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamAsync_OverlappedResult(self: *const T, lpOverlapped: ?*OVERLAPPED, lpNumberOfBytesTransferred: ?*u32, bWait: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamAsync.VTable, self.vtable).OverlappedResult(@ptrCast(*const IStreamAsync, self), lpOverlapped, lpNumberOfBytesTransferred, bWait);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamAsync_CancelIo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamAsync.VTable, self.vtable).CancelIo(@ptrCast(*const IStreamAsync, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamUnbufferedInfo_Value = @import("../zig.zig").Guid.initString("8a68fdda-1fdc-4c20-8ceb-416643b5a625");
pub const IID_IStreamUnbufferedInfo = &IID_IStreamUnbufferedInfo_Value;
pub const IStreamUnbufferedInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSectorSize: fn(
            self: *const IStreamUnbufferedInfo,
            pcbSectorSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamUnbufferedInfo_GetSectorSize(self: *const T, pcbSectorSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStreamUnbufferedInfo.VTable, self.vtable).GetSectorSize(@ptrCast(*const IStreamUnbufferedInfo, self), pcbSectorSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DSH_FLAGS = enum(i32) {
    T = 1,
};
pub const DSH_ALLOWDROPDESCRIPTIONTEXT = DSH_FLAGS.T;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDragSourceHelper2_Value = @import("../zig.zig").Guid.initString("83e07d0d-0c5f-4163-bf1a-60b274051e40");
pub const IID_IDragSourceHelper2 = &IID_IDragSourceHelper2_Value;
pub const IDragSourceHelper2 = extern struct {
    pub const VTable = extern struct {
        base: IDragSourceHelper.VTable,
        SetFlags: fn(
            self: *const IDragSourceHelper2,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDragSourceHelper.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragSourceHelper2_SetFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragSourceHelper2.VTable, self.vtable).SetFlags(@ptrCast(*const IDragSourceHelper2, self), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IHWEventHandler_Value = @import("../zig.zig").Guid.initString("c1fb73d0-ec3a-4ba2-b512-8cdb9187b6d1");
pub const IID_IHWEventHandler = &IID_IHWEventHandler_Value;
pub const IHWEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IHWEventHandler,
            pszParams: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleEvent: fn(
            self: *const IHWEventHandler,
            pszDeviceID: ?[*:0]const u16,
            pszAltDeviceID: ?[*:0]const u16,
            pszEventType: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleEventWithContent: fn(
            self: *const IHWEventHandler,
            pszDeviceID: ?[*:0]const u16,
            pszAltDeviceID: ?[*:0]const u16,
            pszEventType: ?[*:0]const u16,
            pszContentTypeHandler: ?[*:0]const u16,
            pdataobject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHWEventHandler_Initialize(self: *const T, pszParams: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHWEventHandler.VTable, self.vtable).Initialize(@ptrCast(*const IHWEventHandler, self), pszParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHWEventHandler_HandleEvent(self: *const T, pszDeviceID: ?[*:0]const u16, pszAltDeviceID: ?[*:0]const u16, pszEventType: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHWEventHandler.VTable, self.vtable).HandleEvent(@ptrCast(*const IHWEventHandler, self), pszDeviceID, pszAltDeviceID, pszEventType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHWEventHandler_HandleEventWithContent(self: *const T, pszDeviceID: ?[*:0]const u16, pszAltDeviceID: ?[*:0]const u16, pszEventType: ?[*:0]const u16, pszContentTypeHandler: ?[*:0]const u16, pdataobject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHWEventHandler.VTable, self.vtable).HandleEventWithContent(@ptrCast(*const IHWEventHandler, self), pszDeviceID, pszAltDeviceID, pszEventType, pszContentTypeHandler, pdataobject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IHWEventHandler2_Value = @import("../zig.zig").Guid.initString("cfcc809f-295d-42e8-9ffc-424b33c487e6");
pub const IID_IHWEventHandler2 = &IID_IHWEventHandler2_Value;
pub const IHWEventHandler2 = extern struct {
    pub const VTable = extern struct {
        base: IHWEventHandler.VTable,
        HandleEventWithHWND: fn(
            self: *const IHWEventHandler2,
            pszDeviceID: ?[*:0]const u16,
            pszAltDeviceID: ?[*:0]const u16,
            pszEventType: ?[*:0]const u16,
            hwndOwner: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHWEventHandler.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHWEventHandler2_HandleEventWithHWND(self: *const T, pszDeviceID: ?[*:0]const u16, pszAltDeviceID: ?[*:0]const u16, pszEventType: ?[*:0]const u16, hwndOwner: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHWEventHandler2.VTable, self.vtable).HandleEventWithHWND(@ptrCast(*const IHWEventHandler2, self), pszDeviceID, pszAltDeviceID, pszEventType, hwndOwner);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IQueryCancelAutoPlay_Value = @import("../zig.zig").Guid.initString("ddefe873-6997-4e68-be26-39b633adbe12");
pub const IID_IQueryCancelAutoPlay = &IID_IQueryCancelAutoPlay_Value;
pub const IQueryCancelAutoPlay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllowAutoPlay: fn(
            self: *const IQueryCancelAutoPlay,
            pszPath: ?[*:0]const u16,
            dwContentType: u32,
            pszLabel: ?[*:0]const u16,
            dwSerialNumber: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryCancelAutoPlay_AllowAutoPlay(self: *const T, pszPath: ?[*:0]const u16, dwContentType: u32, pszLabel: ?[*:0]const u16, dwSerialNumber: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryCancelAutoPlay.VTable, self.vtable).AllowAutoPlay(@ptrCast(*const IQueryCancelAutoPlay, self), pszPath, dwContentType, pszLabel, dwSerialNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDynamicHWHandler_Value = @import("../zig.zig").Guid.initString("dc2601d7-059e-42fc-a09d-2afd21b6d5f7");
pub const IID_IDynamicHWHandler = &IID_IDynamicHWHandler_Value;
pub const IDynamicHWHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDynamicInfo: fn(
            self: *const IDynamicHWHandler,
            pszDeviceID: ?[*:0]const u16,
            dwContentType: u32,
            ppszAction: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicHWHandler_GetDynamicInfo(self: *const T, pszDeviceID: ?[*:0]const u16, dwContentType: u32, ppszAction: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicHWHandler.VTable, self.vtable).GetDynamicInfo(@ptrCast(*const IDynamicHWHandler, self), pszDeviceID, dwContentType, ppszAction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUserNotificationCallback_Value = @import("../zig.zig").Guid.initString("19108294-0441-4aff-8013-fa0a730b0bea");
pub const IID_IUserNotificationCallback = &IID_IUserNotificationCallback_Value;
pub const IUserNotificationCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnBalloonUserClick: fn(
            self: *const IUserNotificationCallback,
            pt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLeftClick: fn(
            self: *const IUserNotificationCallback,
            pt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnContextMenu: fn(
            self: *const IUserNotificationCallback,
            pt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotificationCallback_OnBalloonUserClick(self: *const T, pt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotificationCallback.VTable, self.vtable).OnBalloonUserClick(@ptrCast(*const IUserNotificationCallback, self), pt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotificationCallback_OnLeftClick(self: *const T, pt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotificationCallback.VTable, self.vtable).OnLeftClick(@ptrCast(*const IUserNotificationCallback, self), pt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotificationCallback_OnContextMenu(self: *const T, pt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotificationCallback.VTable, self.vtable).OnContextMenu(@ptrCast(*const IUserNotificationCallback, self), pt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUserNotification2_Value = @import("../zig.zig").Guid.initString("215913cc-57eb-4fab-ab5a-e5fa7bea2a6c");
pub const IID_IUserNotification2 = &IID_IUserNotification2_Value;
pub const IUserNotification2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBalloonInfo: fn(
            self: *const IUserNotification2,
            pszTitle: ?[*:0]const u16,
            pszText: ?[*:0]const u16,
            dwInfoFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBalloonRetry: fn(
            self: *const IUserNotification2,
            dwShowTime: u32,
            dwInterval: u32,
            cRetryCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconInfo: fn(
            self: *const IUserNotification2,
            hIcon: ?HICON,
            pszToolTip: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const IUserNotification2,
            pqc: ?*IQueryContinue,
            dwContinuePollInterval: u32,
            pSink: ?*IUserNotificationCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlaySound: fn(
            self: *const IUserNotification2,
            pszSoundName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification2_SetBalloonInfo(self: *const T, pszTitle: ?[*:0]const u16, pszText: ?[*:0]const u16, dwInfoFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification2.VTable, self.vtable).SetBalloonInfo(@ptrCast(*const IUserNotification2, self), pszTitle, pszText, dwInfoFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification2_SetBalloonRetry(self: *const T, dwShowTime: u32, dwInterval: u32, cRetryCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification2.VTable, self.vtable).SetBalloonRetry(@ptrCast(*const IUserNotification2, self), dwShowTime, dwInterval, cRetryCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification2_SetIconInfo(self: *const T, hIcon: ?HICON, pszToolTip: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification2.VTable, self.vtable).SetIconInfo(@ptrCast(*const IUserNotification2, self), hIcon, pszToolTip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification2_Show(self: *const T, pqc: ?*IQueryContinue, dwContinuePollInterval: u32, pSink: ?*IUserNotificationCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification2.VTable, self.vtable).Show(@ptrCast(*const IUserNotification2, self), pqc, dwContinuePollInterval, pSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUserNotification2_PlaySound(self: *const T, pszSoundName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUserNotification2.VTable, self.vtable).PlaySound(@ptrCast(*const IUserNotification2, self), pszSoundName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeskBand2_Value = @import("../zig.zig").Guid.initString("79d16de4-abee-4021-8d9d-9169b261d657");
pub const IID_IDeskBand2 = &IID_IDeskBand2_Value;
pub const IDeskBand2 = extern struct {
    pub const VTable = extern struct {
        base: IDeskBand.VTable,
        CanRenderComposited: fn(
            self: *const IDeskBand2,
            pfCanRenderComposited: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionState: fn(
            self: *const IDeskBand2,
            fCompositionEnabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompositionState: fn(
            self: *const IDeskBand2,
            pfCompositionEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDeskBand.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBand2_CanRenderComposited(self: *const T, pfCanRenderComposited: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBand2.VTable, self.vtable).CanRenderComposited(@ptrCast(*const IDeskBand2, self), pfCanRenderComposited);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBand2_SetCompositionState(self: *const T, fCompositionEnabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBand2.VTable, self.vtable).SetCompositionState(@ptrCast(*const IDeskBand2, self), fCompositionEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBand2_GetCompositionState(self: *const T, pfCompositionEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBand2.VTable, self.vtable).GetCompositionState(@ptrCast(*const IDeskBand2, self), pfCompositionEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStartMenuPinnedList_Value = @import("../zig.zig").Guid.initString("4cd19ada-25a5-4a32-b3b7-347bee5be36b");
pub const IID_IStartMenuPinnedList = &IID_IStartMenuPinnedList_Value;
pub const IStartMenuPinnedList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RemoveFromList: fn(
            self: *const IStartMenuPinnedList,
            pitem: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStartMenuPinnedList_RemoveFromList(self: *const T, pitem: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStartMenuPinnedList.VTable, self.vtable).RemoveFromList(@ptrCast(*const IStartMenuPinnedList, self), pitem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICDBurn_Value = @import("../zig.zig").Guid.initString("3d73a659-e5d0-4d42-afc0-5121ba425c8d");
pub const IID_ICDBurn = &IID_ICDBurn_Value;
pub const ICDBurn = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRecorderDriveLetter: fn(
            self: *const ICDBurn,
            pszDrive: [*:0]u16,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Burn: fn(
            self: *const ICDBurn,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasRecordableDrive: fn(
            self: *const ICDBurn,
            pfHasRecorder: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICDBurn_GetRecorderDriveLetter(self: *const T, pszDrive: [*:0]u16, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICDBurn.VTable, self.vtable).GetRecorderDriveLetter(@ptrCast(*const ICDBurn, self), pszDrive, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICDBurn_Burn(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICDBurn.VTable, self.vtable).Burn(@ptrCast(*const ICDBurn, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICDBurn_HasRecordableDrive(self: *const T, pfHasRecorder: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICDBurn.VTable, self.vtable).HasRecordableDrive(@ptrCast(*const ICDBurn, self), pfHasRecorder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWizardSite_Value = @import("../zig.zig").Guid.initString("88960f5b-422f-4e7b-8013-73415381c3c3");
pub const IID_IWizardSite = &IID_IWizardSite_Value;
pub const IWizardSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPreviousPage: fn(
            self: *const IWizardSite,
            phpage: ?*?HPROPSHEETPAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextPage: fn(
            self: *const IWizardSite,
            phpage: ?*?HPROPSHEETPAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCancelledPage: fn(
            self: *const IWizardSite,
            phpage: ?*?HPROPSHEETPAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWizardSite_GetPreviousPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWizardSite.VTable, self.vtable).GetPreviousPage(@ptrCast(*const IWizardSite, self), phpage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWizardSite_GetNextPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWizardSite.VTable, self.vtable).GetNextPage(@ptrCast(*const IWizardSite, self), phpage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWizardSite_GetCancelledPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWizardSite.VTable, self.vtable).GetCancelledPage(@ptrCast(*const IWizardSite, self), phpage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWizardExtension_Value = @import("../zig.zig").Guid.initString("c02ea696-86cc-491e-9b23-74394a0444a8");
pub const IID_IWizardExtension = &IID_IWizardExtension_Value;
pub const IWizardExtension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPages: fn(
            self: *const IWizardExtension,
            aPages: [*]?HPROPSHEETPAGE,
            cPages: u32,
            pnPagesAdded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstPage: fn(
            self: *const IWizardExtension,
            phpage: ?*?HPROPSHEETPAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastPage: fn(
            self: *const IWizardExtension,
            phpage: ?*?HPROPSHEETPAGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWizardExtension_AddPages(self: *const T, aPages: [*]?HPROPSHEETPAGE, cPages: u32, pnPagesAdded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWizardExtension.VTable, self.vtable).AddPages(@ptrCast(*const IWizardExtension, self), aPages, cPages, pnPagesAdded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWizardExtension_GetFirstPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWizardExtension.VTable, self.vtable).GetFirstPage(@ptrCast(*const IWizardExtension, self), phpage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWizardExtension_GetLastPage(self: *const T, phpage: ?*?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWizardExtension.VTable, self.vtable).GetLastPage(@ptrCast(*const IWizardExtension, self), phpage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWebWizardExtension_Value = @import("../zig.zig").Guid.initString("0e6b3f66-98d1-48c0-a222-fbde74e2fbc5");
pub const IID_IWebWizardExtension = &IID_IWebWizardExtension_Value;
pub const IWebWizardExtension = extern struct {
    pub const VTable = extern struct {
        base: IWizardExtension.VTable,
        SetInitialURL: fn(
            self: *const IWebWizardExtension,
            pszURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetErrorURL: fn(
            self: *const IWebWizardExtension,
            pszErrorURL: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWizardExtension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardExtension_SetInitialURL(self: *const T, pszURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardExtension.VTable, self.vtable).SetInitialURL(@ptrCast(*const IWebWizardExtension, self), pszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardExtension_SetErrorURL(self: *const T, pszErrorURL: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardExtension.VTable, self.vtable).SetErrorURL(@ptrCast(*const IWebWizardExtension, self), pszErrorURL);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPublishingWizard_Value = @import("../zig.zig").Guid.initString("aa9198bb-ccec-472d-beed-19a4f6733f7a");
pub const IID_IPublishingWizard = &IID_IPublishingWizard_Value;
pub const IPublishingWizard = extern struct {
    pub const VTable = extern struct {
        base: IWizardExtension.VTable,
        Initialize: fn(
            self: *const IPublishingWizard,
            pdo: ?*IDataObject,
            dwOptions: u32,
            pszServiceScope: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransferManifest: fn(
            self: *const IPublishingWizard,
            phrFromTransfer: ?*HRESULT,
            pdocManifest: ?*?*IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWizardExtension.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPublishingWizard_Initialize(self: *const T, pdo: ?*IDataObject, dwOptions: u32, pszServiceScope: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPublishingWizard.VTable, self.vtable).Initialize(@ptrCast(*const IPublishingWizard, self), pdo, dwOptions, pszServiceScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPublishingWizard_GetTransferManifest(self: *const T, phrFromTransfer: ?*HRESULT, pdocManifest: ?*?*IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPublishingWizard.VTable, self.vtable).GetTransferManifest(@ptrCast(*const IPublishingWizard, self), phrFromTransfer, pdocManifest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderViewHost_Value = @import("../zig.zig").Guid.initString("1ea58f02-d55a-411d-b09e-9e65ac21605b");
pub const IID_IFolderViewHost = &IID_IFolderViewHost_Value;
pub const IFolderViewHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IFolderViewHost,
            hwndParent: ?HWND,
            pdo: ?*IDataObject,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewHost_Initialize(self: *const T, hwndParent: ?HWND, pdo: ?*IDataObject, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewHost.VTable, self.vtable).Initialize(@ptrCast(*const IFolderViewHost, self), hwndParent, pdo, prc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAccessibleObject_Value = @import("../zig.zig").Guid.initString("95a391c5-9ed4-4c28-8401-ab9e06719e11");
pub const IID_IAccessibleObject = &IID_IAccessibleObject_Value;
pub const IAccessibleObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAccessibleName: fn(
            self: *const IAccessibleObject,
            pszName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleObject_SetAccessibleName(self: *const T, pszName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleObject.VTable, self.vtable).SetAccessibleName(@ptrCast(*const IAccessibleObject, self), pszName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultsFolder_Value = @import("../zig.zig").Guid.initString("96e5ae6d-6ae1-4b1c-900c-c6480eaa8828");
pub const IID_IResultsFolder = &IID_IResultsFolder_Value;
pub const IResultsFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddItem: fn(
            self: *const IResultsFolder,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddIDList: fn(
            self: *const IResultsFolder,
            pidl: ?*ITEMIDLIST,
            ppidlAdded: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveItem: fn(
            self: *const IResultsFolder,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveIDList: fn(
            self: *const IResultsFolder,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAll: fn(
            self: *const IResultsFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultsFolder_AddItem(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultsFolder.VTable, self.vtable).AddItem(@ptrCast(*const IResultsFolder, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultsFolder_AddIDList(self: *const T, pidl: ?*ITEMIDLIST, ppidlAdded: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultsFolder.VTable, self.vtable).AddIDList(@ptrCast(*const IResultsFolder, self), pidl, ppidlAdded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultsFolder_RemoveItem(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultsFolder.VTable, self.vtable).RemoveItem(@ptrCast(*const IResultsFolder, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultsFolder_RemoveIDList(self: *const T, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultsFolder.VTable, self.vtable).RemoveIDList(@ptrCast(*const IResultsFolder, self), pidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultsFolder_RemoveAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultsFolder.VTable, self.vtable).RemoveAll(@ptrCast(*const IResultsFolder, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAutoCompleteDropDown_Value = @import("../zig.zig").Guid.initString("3cd141f4-3c6a-11d2-bcaa-00c04fd929db");
pub const IID_IAutoCompleteDropDown = &IID_IAutoCompleteDropDown_Value;
pub const IAutoCompleteDropDown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDropDownStatus: fn(
            self: *const IAutoCompleteDropDown,
            pdwFlags: ?*u32,
            ppwszString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetEnumerator: fn(
            self: *const IAutoCompleteDropDown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutoCompleteDropDown_GetDropDownStatus(self: *const T, pdwFlags: ?*u32, ppwszString: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAutoCompleteDropDown.VTable, self.vtable).GetDropDownStatus(@ptrCast(*const IAutoCompleteDropDown, self), pdwFlags, ppwszString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutoCompleteDropDown_ResetEnumerator(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAutoCompleteDropDown.VTable, self.vtable).ResetEnumerator(@ptrCast(*const IAutoCompleteDropDown, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CDBURNINGEXTENSIONRET = enum(i32) {
    DEFAULT = 0,
    DONTRUNOTHEREXTS = 1,
    STOPWIZARD = 2,
};
pub const CDBE_RET_DEFAULT = CDBURNINGEXTENSIONRET.DEFAULT;
pub const CDBE_RET_DONTRUNOTHEREXTS = CDBURNINGEXTENSIONRET.DONTRUNOTHEREXTS;
pub const CDBE_RET_STOPWIZARD = CDBURNINGEXTENSIONRET.STOPWIZARD;

pub const _CDBE_ACTIONS = enum(i32) {
    MUSIC = 1,
    DATA = 2,
    ALL = -1,
};
pub const CDBE_TYPE_MUSIC = _CDBE_ACTIONS.MUSIC;
pub const CDBE_TYPE_DATA = _CDBE_ACTIONS.DATA;
pub const CDBE_TYPE_ALL = _CDBE_ACTIONS.ALL;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICDBurnExt_Value = @import("../zig.zig").Guid.initString("2271dcca-74fc-4414-8fb7-c56b05ace2d7");
pub const IID_ICDBurnExt = &IID_ICDBurnExt_Value;
pub const ICDBurnExt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSupportedActionTypes: fn(
            self: *const ICDBurnExt,
            pdwActions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICDBurnExt_GetSupportedActionTypes(self: *const T, pdwActions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICDBurnExt.VTable, self.vtable).GetSupportedActionTypes(@ptrCast(*const ICDBurnExt, self), pdwActions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumReadyCallback_Value = @import("../zig.zig").Guid.initString("61e00d45-8fff-4e60-924e-6537b61612dd");
pub const IID_IEnumReadyCallback = &IID_IEnumReadyCallback_Value;
pub const IEnumReadyCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumReady: fn(
            self: *const IEnumReadyCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumReadyCallback_EnumReady(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumReadyCallback.VTable, self.vtable).EnumReady(@ptrCast(*const IEnumReadyCallback, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumerableView_Value = @import("../zig.zig").Guid.initString("8c8bf236-1aec-495f-9894-91d57c3c686f");
pub const IID_IEnumerableView = &IID_IEnumerableView_Value;
pub const IEnumerableView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetEnumReadyCallback: fn(
            self: *const IEnumerableView,
            percb: ?*IEnumReadyCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEnumIDListFromContents: fn(
            self: *const IEnumerableView,
            pidlFolder: ?*ITEMIDLIST,
            dwEnumFlags: u32,
            ppEnumIDList: ?*?*IEnumIDList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumerableView_SetEnumReadyCallback(self: *const T, percb: ?*IEnumReadyCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumerableView.VTable, self.vtable).SetEnumReadyCallback(@ptrCast(*const IEnumerableView, self), percb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumerableView_CreateEnumIDListFromContents(self: *const T, pidlFolder: ?*ITEMIDLIST, dwEnumFlags: u32, ppEnumIDList: ?*?*IEnumIDList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumerableView.VTable, self.vtable).CreateEnumIDListFromContents(@ptrCast(*const IEnumerableView, self), pidlFolder, dwEnumFlags, ppEnumIDList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInsertItem_Value = @import("../zig.zig").Guid.initString("d2b57227-3d23-4b95-93c0-492bd454c356");
pub const IID_IInsertItem = &IID_IInsertItem_Value;
pub const IInsertItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertItem: fn(
            self: *const IInsertItem,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInsertItem_InsertItem(self: *const T, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInsertItem.VTable, self.vtable).InsertItem(@ptrCast(*const IInsertItem, self), pidl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFolderBandPriv_Value = @import("../zig.zig").Guid.initString("47c01f95-e185-412c-b5c5-4f27df965aea");
pub const IID_IFolderBandPriv = &IID_IFolderBandPriv_Value;
pub const IFolderBandPriv = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCascade: fn(
            self: *const IFolderBandPriv,
            fCascade: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAccelerators: fn(
            self: *const IFolderBandPriv,
            fAccelerators: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNoIcons: fn(
            self: *const IFolderBandPriv,
            fNoIcons: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNoText: fn(
            self: *const IFolderBandPriv,
            fNoText: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderBandPriv_SetCascade(self: *const T, fCascade: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderBandPriv.VTable, self.vtable).SetCascade(@ptrCast(*const IFolderBandPriv, self), fCascade);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderBandPriv_SetAccelerators(self: *const T, fAccelerators: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderBandPriv.VTable, self.vtable).SetAccelerators(@ptrCast(*const IFolderBandPriv, self), fAccelerators);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderBandPriv_SetNoIcons(self: *const T, fNoIcons: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderBandPriv.VTable, self.vtable).SetNoIcons(@ptrCast(*const IFolderBandPriv, self), fNoIcons);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderBandPriv_SetNoText(self: *const T, fNoText: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderBandPriv.VTable, self.vtable).SetNoText(@ptrCast(*const IFolderBandPriv, self), fNoText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IImageRecompress_Value = @import("../zig.zig").Guid.initString("505f1513-6b3e-4892-a272-59f8889a4d3e");
pub const IID_IImageRecompress = &IID_IImageRecompress_Value;
pub const IImageRecompress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RecompressImage: fn(
            self: *const IImageRecompress,
            psi: ?*IShellItem,
            cx: i32,
            cy: i32,
            iQuality: i32,
            pstg: ?*IStorage,
            ppstrmOut: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageRecompress_RecompressImage(self: *const T, psi: ?*IShellItem, cx: i32, cy: i32, iQuality: i32, pstg: ?*IStorage, ppstrmOut: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageRecompress.VTable, self.vtable).RecompressImage(@ptrCast(*const IImageRecompress, self), psi, cx, cy, iQuality, pstg, ppstrmOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileDialogControlEvents_Value = @import("../zig.zig").Guid.initString("36116642-d713-4b97-9b83-7484a9d00433");
pub const IID_IFileDialogControlEvents = &IID_IFileDialogControlEvents_Value;
pub const IFileDialogControlEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnItemSelected: fn(
            self: *const IFileDialogControlEvents,
            pfdc: ?*IFileDialogCustomize,
            dwIDCtl: u32,
            dwIDItem: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnButtonClicked: fn(
            self: *const IFileDialogControlEvents,
            pfdc: ?*IFileDialogCustomize,
            dwIDCtl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCheckButtonToggled: fn(
            self: *const IFileDialogControlEvents,
            pfdc: ?*IFileDialogCustomize,
            dwIDCtl: u32,
            bChecked: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnControlActivating: fn(
            self: *const IFileDialogControlEvents,
            pfdc: ?*IFileDialogCustomize,
            dwIDCtl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogControlEvents_OnItemSelected(self: *const T, pfdc: ?*IFileDialogCustomize, dwIDCtl: u32, dwIDItem: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogControlEvents.VTable, self.vtable).OnItemSelected(@ptrCast(*const IFileDialogControlEvents, self), pfdc, dwIDCtl, dwIDItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogControlEvents_OnButtonClicked(self: *const T, pfdc: ?*IFileDialogCustomize, dwIDCtl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogControlEvents.VTable, self.vtable).OnButtonClicked(@ptrCast(*const IFileDialogControlEvents, self), pfdc, dwIDCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogControlEvents_OnCheckButtonToggled(self: *const T, pfdc: ?*IFileDialogCustomize, dwIDCtl: u32, bChecked: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogControlEvents.VTable, self.vtable).OnCheckButtonToggled(@ptrCast(*const IFileDialogControlEvents, self), pfdc, dwIDCtl, bChecked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialogControlEvents_OnControlActivating(self: *const T, pfdc: ?*IFileDialogCustomize, dwIDCtl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialogControlEvents.VTable, self.vtable).OnControlActivating(@ptrCast(*const IFileDialogControlEvents, self), pfdc, dwIDCtl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IFileDialog2_Value = @import("../zig.zig").Guid.initString("61744fc7-85b5-4791-a9b0-272276309b13");
pub const IID_IFileDialog2 = &IID_IFileDialog2_Value;
pub const IFileDialog2 = extern struct {
    pub const VTable = extern struct {
        base: IFileDialog.VTable,
        SetCancelButtonLabel: fn(
            self: *const IFileDialog2,
            pszLabel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNavigationRoot: fn(
            self: *const IFileDialog2,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileDialog.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog2_SetCancelButtonLabel(self: *const T, pszLabel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog2.VTable, self.vtable).SetCancelButtonLabel(@ptrCast(*const IFileDialog2, self), pszLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileDialog2_SetNavigationRoot(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileDialog2.VTable, self.vtable).SetNavigationRoot(@ptrCast(*const IFileDialog2, self), psi);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IApplicationAssociationRegistrationUI_Value = @import("../zig.zig").Guid.initString("1f76a169-f994-40ac-8fc8-0959e8874710");
pub const IID_IApplicationAssociationRegistrationUI = &IID_IApplicationAssociationRegistrationUI_Value;
pub const IApplicationAssociationRegistrationUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchAdvancedAssociationUI: fn(
            self: *const IApplicationAssociationRegistrationUI,
            pszAppRegistryName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationAssociationRegistrationUI_LaunchAdvancedAssociationUI(self: *const T, pszAppRegistryName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationAssociationRegistrationUI.VTable, self.vtable).LaunchAdvancedAssociationUI(@ptrCast(*const IApplicationAssociationRegistrationUI, self), pszAppRegistryName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellRunDll_Value = @import("../zig.zig").Guid.initString("fce4bde0-4b68-4b80-8e9c-7426315a7388");
pub const IID_IShellRunDll = &IID_IShellRunDll_Value;
pub const IShellRunDll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Run: fn(
            self: *const IShellRunDll,
            pszArgs: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellRunDll_Run(self: *const T, pszArgs: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellRunDll.VTable, self.vtable).Run(@ptrCast(*const IShellRunDll, self), pszArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPreviousVersionsInfo_Value = @import("../zig.zig").Guid.initString("76e54780-ad74-48e3-a695-3ba9a0aff10d");
pub const IID_IPreviousVersionsInfo = &IID_IPreviousVersionsInfo_Value;
pub const IPreviousVersionsInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AreSnapshotsAvailable: fn(
            self: *const IPreviousVersionsInfo,
            pszPath: ?[*:0]const u16,
            fOkToBeSlow: BOOL,
            pfAvailable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreviousVersionsInfo_AreSnapshotsAvailable(self: *const T, pszPath: ?[*:0]const u16, fOkToBeSlow: BOOL, pfAvailable: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreviousVersionsInfo.VTable, self.vtable).AreSnapshotsAvailable(@ptrCast(*const IPreviousVersionsInfo, self), pszPath, fOkToBeSlow, pfAvailable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IUseToBrowseItem_Value = @import("../zig.zig").Guid.initString("05edda5c-98a3-4717-8adb-c5e7da991eb1");
pub const IID_IUseToBrowseItem = &IID_IUseToBrowseItem_Value;
pub const IUseToBrowseItem = extern struct {
    pub const VTable = extern struct {
        base: IRelatedItem.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRelatedItem.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NSTCSTYLE2 = enum(i32) {
    STCS2_DEFAULT = 0,
    STCS2_INTERRUPTNOTIFICATIONS = 1,
    STCS2_SHOWNULLSPACEMENU = 2,
    STCS2_DISPLAYPADDING = 4,
    STCS2_DISPLAYPINNEDONLY = 8,
    TSCS2_NOSINGLETONAUTOEXPAND = 16,
    TSCS2_NEVERINSERTNONENUMERATED = 32,
};
pub const NSTCS2_DEFAULT = NSTCSTYLE2.STCS2_DEFAULT;
pub const NSTCS2_INTERRUPTNOTIFICATIONS = NSTCSTYLE2.STCS2_INTERRUPTNOTIFICATIONS;
pub const NSTCS2_SHOWNULLSPACEMENU = NSTCSTYLE2.STCS2_SHOWNULLSPACEMENU;
pub const NSTCS2_DISPLAYPADDING = NSTCSTYLE2.STCS2_DISPLAYPADDING;
pub const NSTCS2_DISPLAYPINNEDONLY = NSTCSTYLE2.STCS2_DISPLAYPINNEDONLY;
pub const NTSCS2_NOSINGLETONAUTOEXPAND = NSTCSTYLE2.TSCS2_NOSINGLETONAUTOEXPAND;
pub const NTSCS2_NEVERINSERTNONENUMERATED = NSTCSTYLE2.TSCS2_NEVERINSERTNONENUMERATED;

// TODO: this type is limited to platform 'windows6.1'
const IID_INameSpaceTreeControl2_Value = @import("../zig.zig").Guid.initString("7cc7aed8-290e-49bc-8945-c1401cc9306c");
pub const IID_INameSpaceTreeControl2 = &IID_INameSpaceTreeControl2_Value;
pub const INameSpaceTreeControl2 = extern struct {
    pub const VTable = extern struct {
        base: INameSpaceTreeControl.VTable,
        SetControlStyle: fn(
            self: *const INameSpaceTreeControl2,
            nstcsMask: u32,
            nstcsStyle: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlStyle: fn(
            self: *const INameSpaceTreeControl2,
            nstcsMask: u32,
            pnstcsStyle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControlStyle2: fn(
            self: *const INameSpaceTreeControl2,
            nstcsMask: NSTCSTYLE2,
            nstcsStyle: NSTCSTYLE2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlStyle2: fn(
            self: *const INameSpaceTreeControl2,
            nstcsMask: NSTCSTYLE2,
            pnstcsStyle: ?*NSTCSTYLE2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace INameSpaceTreeControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl2_SetControlStyle(self: *const T, nstcsMask: u32, nstcsStyle: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl2.VTable, self.vtable).SetControlStyle(@ptrCast(*const INameSpaceTreeControl2, self), nstcsMask, nstcsStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl2_GetControlStyle(self: *const T, nstcsMask: u32, pnstcsStyle: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl2.VTable, self.vtable).GetControlStyle(@ptrCast(*const INameSpaceTreeControl2, self), nstcsMask, pnstcsStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl2_SetControlStyle2(self: *const T, nstcsMask: NSTCSTYLE2, nstcsStyle: NSTCSTYLE2) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl2.VTable, self.vtable).SetControlStyle2(@ptrCast(*const INameSpaceTreeControl2, self), nstcsMask, nstcsStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControl2_GetControlStyle2(self: *const T, nstcsMask: NSTCSTYLE2, pnstcsStyle: ?*NSTCSTYLE2) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControl2.VTable, self.vtable).GetControlStyle2(@ptrCast(*const INameSpaceTreeControl2, self), nstcsMask, pnstcsStyle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _NSTCEHITTEST = enum(i32) {
    NOWHERE = 1,
    ONITEMICON = 2,
    ONITEMLABEL = 4,
    ONITEMINDENT = 8,
    ONITEMBUTTON = 16,
    ONITEMRIGHT = 32,
    ONITEMSTATEICON = 64,
    ONITEM = 70,
    ONITEMTABBUTTON = 4096,
};
pub const NSTCEHT_NOWHERE = _NSTCEHITTEST.NOWHERE;
pub const NSTCEHT_ONITEMICON = _NSTCEHITTEST.ONITEMICON;
pub const NSTCEHT_ONITEMLABEL = _NSTCEHITTEST.ONITEMLABEL;
pub const NSTCEHT_ONITEMINDENT = _NSTCEHITTEST.ONITEMINDENT;
pub const NSTCEHT_ONITEMBUTTON = _NSTCEHITTEST.ONITEMBUTTON;
pub const NSTCEHT_ONITEMRIGHT = _NSTCEHITTEST.ONITEMRIGHT;
pub const NSTCEHT_ONITEMSTATEICON = _NSTCEHITTEST.ONITEMSTATEICON;
pub const NSTCEHT_ONITEM = _NSTCEHITTEST.ONITEM;
pub const NSTCEHT_ONITEMTABBUTTON = _NSTCEHITTEST.ONITEMTABBUTTON;

pub const _NSTCECLICKTYPE = enum(i32) {
    LBUTTON = 1,
    MBUTTON = 2,
    RBUTTON = 3,
    // BUTTON = 3, this enum value conflicts with RBUTTON
    DBLCLICK = 4,
};
pub const NSTCECT_LBUTTON = _NSTCECLICKTYPE.LBUTTON;
pub const NSTCECT_MBUTTON = _NSTCECLICKTYPE.MBUTTON;
pub const NSTCECT_RBUTTON = _NSTCECLICKTYPE.RBUTTON;
pub const NSTCECT_BUTTON = _NSTCECLICKTYPE.RBUTTON;
pub const NSTCECT_DBLCLICK = _NSTCECLICKTYPE.DBLCLICK;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeControlEvents_Value = @import("../zig.zig").Guid.initString("93d77985-b3d8-4484-8318-672cdda002ce");
pub const IID_INameSpaceTreeControlEvents = &IID_INameSpaceTreeControlEvents_Value;
pub const INameSpaceTreeControlEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnItemClick: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
            nstceHitTest: u32,
            nstceClickType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnPropertyItemCommit: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemStateChanging: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
            nstcisMask: u32,
            nstcisState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemStateChanged: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
            nstcisMask: u32,
            nstcisState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelectionChanged: fn(
            self: *const INameSpaceTreeControlEvents,
            psiaSelection: ?*IShellItemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnKeyboardInput: fn(
            self: *const INameSpaceTreeControlEvents,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBeforeExpand: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAfterExpand: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBeginLabelEdit: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEndLabelEdit: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnGetToolTip: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
            pszTip: [*:0]u16,
            cchTip: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBeforeItemDelete: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemAdded: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
            fIsRoot: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemDeleted: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
            fIsRoot: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBeforeContextMenu: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAfterContextMenu: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
            pcmIn: ?*IContextMenu,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBeforeStateImageChange: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnGetDefaultIconIndex: fn(
            self: *const INameSpaceTreeControlEvents,
            psi: ?*IShellItem,
            piDefaultIcon: ?*i32,
            piOpenIcon: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnItemClick(self: *const T, psi: ?*IShellItem, nstceHitTest: u32, nstceClickType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnItemClick(@ptrCast(*const INameSpaceTreeControlEvents, self), psi, nstceHitTest, nstceClickType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnPropertyItemCommit(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnPropertyItemCommit(@ptrCast(*const INameSpaceTreeControlEvents, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnItemStateChanging(self: *const T, psi: ?*IShellItem, nstcisMask: u32, nstcisState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnItemStateChanging(@ptrCast(*const INameSpaceTreeControlEvents, self), psi, nstcisMask, nstcisState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnItemStateChanged(self: *const T, psi: ?*IShellItem, nstcisMask: u32, nstcisState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnItemStateChanged(@ptrCast(*const INameSpaceTreeControlEvents, self), psi, nstcisMask, nstcisState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnSelectionChanged(self: *const T, psiaSelection: ?*IShellItemArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnSelectionChanged(@ptrCast(*const INameSpaceTreeControlEvents, self), psiaSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnKeyboardInput(self: *const T, uMsg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnKeyboardInput(@ptrCast(*const INameSpaceTreeControlEvents, self), uMsg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnBeforeExpand(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnBeforeExpand(@ptrCast(*const INameSpaceTreeControlEvents, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnAfterExpand(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnAfterExpand(@ptrCast(*const INameSpaceTreeControlEvents, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnBeginLabelEdit(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnBeginLabelEdit(@ptrCast(*const INameSpaceTreeControlEvents, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnEndLabelEdit(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnEndLabelEdit(@ptrCast(*const INameSpaceTreeControlEvents, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnGetToolTip(self: *const T, psi: ?*IShellItem, pszTip: [*:0]u16, cchTip: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnGetToolTip(@ptrCast(*const INameSpaceTreeControlEvents, self), psi, pszTip, cchTip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnBeforeItemDelete(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnBeforeItemDelete(@ptrCast(*const INameSpaceTreeControlEvents, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnItemAdded(self: *const T, psi: ?*IShellItem, fIsRoot: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnItemAdded(@ptrCast(*const INameSpaceTreeControlEvents, self), psi, fIsRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnItemDeleted(self: *const T, psi: ?*IShellItem, fIsRoot: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnItemDeleted(@ptrCast(*const INameSpaceTreeControlEvents, self), psi, fIsRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnBeforeContextMenu(self: *const T, psi: ?*IShellItem, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnBeforeContextMenu(@ptrCast(*const INameSpaceTreeControlEvents, self), psi, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnAfterContextMenu(self: *const T, psi: ?*IShellItem, pcmIn: ?*IContextMenu, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnAfterContextMenu(@ptrCast(*const INameSpaceTreeControlEvents, self), psi, pcmIn, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnBeforeStateImageChange(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnBeforeStateImageChange(@ptrCast(*const INameSpaceTreeControlEvents, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlEvents_OnGetDefaultIconIndex(self: *const T, psi: ?*IShellItem, piDefaultIcon: ?*i32, piOpenIcon: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlEvents.VTable, self.vtable).OnGetDefaultIconIndex(@ptrCast(*const INameSpaceTreeControlEvents, self), psi, piDefaultIcon, piOpenIcon);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeControlDropHandler_Value = @import("../zig.zig").Guid.initString("f9c665d6-c2f2-4c19-bf33-8322d7352f51");
pub const IID_INameSpaceTreeControlDropHandler = &IID_INameSpaceTreeControlDropHandler_Value;
pub const INameSpaceTreeControlDropHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDragEnter: fn(
            self: *const INameSpaceTreeControlDropHandler,
            psiOver: ?*IShellItem,
            psiaData: ?*IShellItemArray,
            fOutsideSource: BOOL,
            grfKeyState: u32,
            pdwEffect: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDragOver: fn(
            self: *const INameSpaceTreeControlDropHandler,
            psiOver: ?*IShellItem,
            psiaData: ?*IShellItemArray,
            grfKeyState: u32,
            pdwEffect: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDragPosition: fn(
            self: *const INameSpaceTreeControlDropHandler,
            psiOver: ?*IShellItem,
            psiaData: ?*IShellItemArray,
            iNewPosition: i32,
            iOldPosition: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDrop: fn(
            self: *const INameSpaceTreeControlDropHandler,
            psiOver: ?*IShellItem,
            psiaData: ?*IShellItemArray,
            iPosition: i32,
            grfKeyState: u32,
            pdwEffect: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDropPosition: fn(
            self: *const INameSpaceTreeControlDropHandler,
            psiOver: ?*IShellItem,
            psiaData: ?*IShellItemArray,
            iNewPosition: i32,
            iOldPosition: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDragLeave: fn(
            self: *const INameSpaceTreeControlDropHandler,
            psiOver: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlDropHandler_OnDragEnter(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, fOutsideSource: BOOL, grfKeyState: u32, pdwEffect: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlDropHandler.VTable, self.vtable).OnDragEnter(@ptrCast(*const INameSpaceTreeControlDropHandler, self), psiOver, psiaData, fOutsideSource, grfKeyState, pdwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlDropHandler_OnDragOver(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, grfKeyState: u32, pdwEffect: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlDropHandler.VTable, self.vtable).OnDragOver(@ptrCast(*const INameSpaceTreeControlDropHandler, self), psiOver, psiaData, grfKeyState, pdwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlDropHandler_OnDragPosition(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, iNewPosition: i32, iOldPosition: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlDropHandler.VTable, self.vtable).OnDragPosition(@ptrCast(*const INameSpaceTreeControlDropHandler, self), psiOver, psiaData, iNewPosition, iOldPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlDropHandler_OnDrop(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, iPosition: i32, grfKeyState: u32, pdwEffect: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlDropHandler.VTable, self.vtable).OnDrop(@ptrCast(*const INameSpaceTreeControlDropHandler, self), psiOver, psiaData, iPosition, grfKeyState, pdwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlDropHandler_OnDropPosition(self: *const T, psiOver: ?*IShellItem, psiaData: ?*IShellItemArray, iNewPosition: i32, iOldPosition: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlDropHandler.VTable, self.vtable).OnDropPosition(@ptrCast(*const INameSpaceTreeControlDropHandler, self), psiOver, psiaData, iNewPosition, iOldPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlDropHandler_OnDragLeave(self: *const T, psiOver: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlDropHandler.VTable, self.vtable).OnDragLeave(@ptrCast(*const INameSpaceTreeControlDropHandler, self), psiOver);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeAccessible_Value = @import("../zig.zig").Guid.initString("71f312de-43ed-4190-8477-e9536b82350b");
pub const IID_INameSpaceTreeAccessible = &IID_INameSpaceTreeAccessible_Value;
pub const INameSpaceTreeAccessible = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnGetDefaultAccessibilityAction: fn(
            self: *const INameSpaceTreeAccessible,
            psi: ?*IShellItem,
            pbstrDefaultAction: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDoDefaultAccessibilityAction: fn(
            self: *const INameSpaceTreeAccessible,
            psi: ?*IShellItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnGetAccessibilityRole: fn(
            self: *const INameSpaceTreeAccessible,
            psi: ?*IShellItem,
            pvarRole: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeAccessible_OnGetDefaultAccessibilityAction(self: *const T, psi: ?*IShellItem, pbstrDefaultAction: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeAccessible.VTable, self.vtable).OnGetDefaultAccessibilityAction(@ptrCast(*const INameSpaceTreeAccessible, self), psi, pbstrDefaultAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeAccessible_OnDoDefaultAccessibilityAction(self: *const T, psi: ?*IShellItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeAccessible.VTable, self.vtable).OnDoDefaultAccessibilityAction(@ptrCast(*const INameSpaceTreeAccessible, self), psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeAccessible_OnGetAccessibilityRole(self: *const T, psi: ?*IShellItem, pvarRole: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeAccessible.VTable, self.vtable).OnGetAccessibilityRole(@ptrCast(*const INameSpaceTreeAccessible, self), psi, pvarRole);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NSTCCUSTOMDRAW = extern struct {
    psi: ?*IShellItem,
    uItemState: u32,
    nstcis: u32,
    pszText: ?[*:0]const u16,
    iImage: i32,
    himl: ?HIMAGELIST,
    iLevel: i32,
    iIndent: i32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INameSpaceTreeControlCustomDraw_Value = @import("../zig.zig").Guid.initString("2d3ba758-33ee-42d5-bb7b-5f3431d86c78");
pub const IID_INameSpaceTreeControlCustomDraw = &IID_INameSpaceTreeControlCustomDraw_Value;
pub const INameSpaceTreeControlCustomDraw = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PrePaint: fn(
            self: *const INameSpaceTreeControlCustomDraw,
            hdc: ?HDC,
            prc: ?*RECT,
            plres: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostPaint: fn(
            self: *const INameSpaceTreeControlCustomDraw,
            hdc: ?HDC,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ItemPrePaint: fn(
            self: *const INameSpaceTreeControlCustomDraw,
            hdc: ?HDC,
            prc: ?*RECT,
            pnstccdItem: ?*NSTCCUSTOMDRAW,
            pclrText: ?*u32,
            pclrTextBk: ?*u32,
            plres: ?*LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ItemPostPaint: fn(
            self: *const INameSpaceTreeControlCustomDraw,
            hdc: ?HDC,
            prc: ?*RECT,
            pnstccdItem: ?*NSTCCUSTOMDRAW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlCustomDraw_PrePaint(self: *const T, hdc: ?HDC, prc: ?*RECT, plres: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlCustomDraw.VTable, self.vtable).PrePaint(@ptrCast(*const INameSpaceTreeControlCustomDraw, self), hdc, prc, plres);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlCustomDraw_PostPaint(self: *const T, hdc: ?HDC, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlCustomDraw.VTable, self.vtable).PostPaint(@ptrCast(*const INameSpaceTreeControlCustomDraw, self), hdc, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlCustomDraw_ItemPrePaint(self: *const T, hdc: ?HDC, prc: ?*RECT, pnstccdItem: ?*NSTCCUSTOMDRAW, pclrText: ?*u32, pclrTextBk: ?*u32, plres: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlCustomDraw.VTable, self.vtable).ItemPrePaint(@ptrCast(*const INameSpaceTreeControlCustomDraw, self), hdc, prc, pnstccdItem, pclrText, pclrTextBk, plres);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INameSpaceTreeControlCustomDraw_ItemPostPaint(self: *const T, hdc: ?HDC, prc: ?*RECT, pnstccdItem: ?*NSTCCUSTOMDRAW) callconv(.Inline) HRESULT {
            return @ptrCast(*const INameSpaceTreeControlCustomDraw.VTable, self.vtable).ItemPostPaint(@ptrCast(*const INameSpaceTreeControlCustomDraw, self), hdc, prc, pnstccdItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITrayDeskBand_Value = @import("../zig.zig").Guid.initString("6d67e846-5b9c-4db8-9cbc-dde12f4254f1");
pub const IID_ITrayDeskBand = &IID_ITrayDeskBand_Value;
pub const ITrayDeskBand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowDeskBand: fn(
            self: *const ITrayDeskBand,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HideDeskBand: fn(
            self: *const ITrayDeskBand,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDeskBandShown: fn(
            self: *const ITrayDeskBand,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeskBandRegistrationChanged: fn(
            self: *const ITrayDeskBand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrayDeskBand_ShowDeskBand(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrayDeskBand.VTable, self.vtable).ShowDeskBand(@ptrCast(*const ITrayDeskBand, self), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrayDeskBand_HideDeskBand(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrayDeskBand.VTable, self.vtable).HideDeskBand(@ptrCast(*const ITrayDeskBand, self), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrayDeskBand_IsDeskBandShown(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrayDeskBand.VTable, self.vtable).IsDeskBandShown(@ptrCast(*const ITrayDeskBand, self), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrayDeskBand_DeskBandRegistrationChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrayDeskBand.VTable, self.vtable).DeskBandRegistrationChanged(@ptrCast(*const ITrayDeskBand, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBandHost_Value = @import("../zig.zig").Guid.initString("b9075c7c-d48e-403f-ab99-d6c77a1084ac");
pub const IID_IBandHost = &IID_IBandHost_Value;
pub const IBandHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateBand: fn(
            self: *const IBandHost,
            rclsidBand: ?*const Guid,
            fAvailable: BOOL,
            fVisible: BOOL,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBandAvailability: fn(
            self: *const IBandHost,
            rclsidBand: ?*const Guid,
            fAvailable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyBand: fn(
            self: *const IBandHost,
            rclsidBand: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandHost_CreateBand(self: *const T, rclsidBand: ?*const Guid, fAvailable: BOOL, fVisible: BOOL, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandHost.VTable, self.vtable).CreateBand(@ptrCast(*const IBandHost, self), rclsidBand, fAvailable, fVisible, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandHost_SetBandAvailability(self: *const T, rclsidBand: ?*const Guid, fAvailable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandHost.VTable, self.vtable).SetBandAvailability(@ptrCast(*const IBandHost, self), rclsidBand, fAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBandHost_DestroyBand(self: *const T, rclsidBand: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBandHost.VTable, self.vtable).DestroyBand(@ptrCast(*const IBandHost, self), rclsidBand);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComputerInfoChangeNotify_Value = @import("../zig.zig").Guid.initString("0df60d92-6818-46d6-b358-d66170dde466");
pub const IID_IComputerInfoChangeNotify = &IID_IComputerInfoChangeNotify_Value;
pub const IComputerInfoChangeNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ComputerInfoChanged: fn(
            self: *const IComputerInfoChangeNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComputerInfoChangeNotify_ComputerInfoChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComputerInfoChangeNotify.VTable, self.vtable).ComputerInfoChanged(@ptrCast(*const IComputerInfoChangeNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDesktopGadget_Value = @import("../zig.zig").Guid.initString("c1646bc4-f298-4f91-a204-eb2dd1709d1a");
pub const IID_IDesktopGadget = &IID_IDesktopGadget_Value;
pub const IDesktopGadget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RunGadget: fn(
            self: *const IDesktopGadget,
            gadgetPath: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDesktopGadget_RunGadget(self: *const T, gadgetPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDesktopGadget.VTable, self.vtable).RunGadget(@ptrCast(*const IDesktopGadget, self), gadgetPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const UNDOCK_REASON = enum(i32) {
    RESOLUTION_CHANGE = 0,
    MONITOR_DISCONNECT = 1,
};
pub const UR_RESOLUTION_CHANGE = UNDOCK_REASON.RESOLUTION_CHANGE;
pub const UR_MONITOR_DISCONNECT = UNDOCK_REASON.MONITOR_DISCONNECT;

const IID_IAccessibilityDockingServiceCallback_Value = @import("../zig.zig").Guid.initString("157733fd-a592-42e5-b594-248468c5a81b");
pub const IID_IAccessibilityDockingServiceCallback = &IID_IAccessibilityDockingServiceCallback_Value;
pub const IAccessibilityDockingServiceCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Undocked: fn(
            self: *const IAccessibilityDockingServiceCallback,
            undockReason: UNDOCK_REASON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibilityDockingServiceCallback_Undocked(self: *const T, undockReason: UNDOCK_REASON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibilityDockingServiceCallback.VTable, self.vtable).Undocked(@ptrCast(*const IAccessibilityDockingServiceCallback, self), undockReason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccessibilityDockingService_Value = @import("../zig.zig").Guid.initString("8849dc22-cedf-4c95-998d-051419dd3f76");
pub const IID_IAccessibilityDockingService = &IID_IAccessibilityDockingService_Value;
pub const IAccessibilityDockingService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableSize: fn(
            self: *const IAccessibilityDockingService,
            hMonitor: ?HMONITOR,
            pcxFixed: ?*u32,
            pcyMax: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DockWindow: fn(
            self: *const IAccessibilityDockingService,
            hwnd: ?HWND,
            hMonitor: ?HMONITOR,
            cyRequested: u32,
            pCallback: ?*IAccessibilityDockingServiceCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UndockWindow: fn(
            self: *const IAccessibilityDockingService,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibilityDockingService_GetAvailableSize(self: *const T, hMonitor: ?HMONITOR, pcxFixed: ?*u32, pcyMax: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibilityDockingService.VTable, self.vtable).GetAvailableSize(@ptrCast(*const IAccessibilityDockingService, self), hMonitor, pcxFixed, pcyMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibilityDockingService_DockWindow(self: *const T, hwnd: ?HWND, hMonitor: ?HMONITOR, cyRequested: u32, pCallback: ?*IAccessibilityDockingServiceCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibilityDockingService.VTable, self.vtable).DockWindow(@ptrCast(*const IAccessibilityDockingService, self), hwnd, hMonitor, cyRequested, pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibilityDockingService_UndockWindow(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibilityDockingService.VTable, self.vtable).UndockWindow(@ptrCast(*const IAccessibilityDockingService, self), hwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStorageProviderBanners_Value = @import("../zig.zig").Guid.initString("5efb46d7-47c0-4b68-acda-ded47c90ec91");
pub const IID_IStorageProviderBanners = &IID_IStorageProviderBanners_Value;
pub const IStorageProviderBanners = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBanner: fn(
            self: *const IStorageProviderBanners,
            providerIdentity: ?[*:0]const u16,
            subscriptionId: ?[*:0]const u16,
            contentId: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearBanner: fn(
            self: *const IStorageProviderBanners,
            providerIdentity: ?[*:0]const u16,
            subscriptionId: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearAllBanners: fn(
            self: *const IStorageProviderBanners,
            providerIdentity: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBanner: fn(
            self: *const IStorageProviderBanners,
            providerIdentity: ?[*:0]const u16,
            subscriptionId: ?[*:0]const u16,
            contentId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderBanners_SetBanner(self: *const T, providerIdentity: ?[*:0]const u16, subscriptionId: ?[*:0]const u16, contentId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderBanners.VTable, self.vtable).SetBanner(@ptrCast(*const IStorageProviderBanners, self), providerIdentity, subscriptionId, contentId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderBanners_ClearBanner(self: *const T, providerIdentity: ?[*:0]const u16, subscriptionId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderBanners.VTable, self.vtable).ClearBanner(@ptrCast(*const IStorageProviderBanners, self), providerIdentity, subscriptionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderBanners_ClearAllBanners(self: *const T, providerIdentity: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderBanners.VTable, self.vtable).ClearAllBanners(@ptrCast(*const IStorageProviderBanners, self), providerIdentity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderBanners_GetBanner(self: *const T, providerIdentity: ?[*:0]const u16, subscriptionId: ?[*:0]const u16, contentId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderBanners.VTable, self.vtable).GetBanner(@ptrCast(*const IStorageProviderBanners, self), providerIdentity, subscriptionId, contentId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStorageProviderCopyHook_Value = @import("../zig.zig").Guid.initString("7bf992a9-af7a-4dba-b2e5-4d080b1ecbc6");
pub const IID_IStorageProviderCopyHook = &IID_IStorageProviderCopyHook_Value;
pub const IStorageProviderCopyHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CopyCallback: fn(
            self: *const IStorageProviderCopyHook,
            hwnd: ?HWND,
            operation: u32,
            flags: u32,
            srcFile: ?[*:0]const u16,
            srcAttribs: u32,
            destFile: ?[*:0]const u16,
            destAttribs: u32,
            result: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderCopyHook_CopyCallback(self: *const T, hwnd: ?HWND, operation: u32, flags: u32, srcFile: ?[*:0]const u16, srcAttribs: u32, destFile: ?[*:0]const u16, destAttribs: u32, result: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderCopyHook.VTable, self.vtable).CopyCallback(@ptrCast(*const IStorageProviderCopyHook, self), hwnd, operation, flags, srcFile, srcAttribs, destFile, destAttribs, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_WebBrowser_V1_Value = @import("../zig.zig").Guid.initString("eab22ac3-30c1-11cf-a7eb-0000c05bae0b");
pub const CLSID_WebBrowser_V1 = &CLSID_WebBrowser_V1_Value;

const CLSID_WebBrowser_Value = @import("../zig.zig").Guid.initString("8856f961-340a-11d0-a96b-00c04fd705a2");
pub const CLSID_WebBrowser = &CLSID_WebBrowser_Value;

const CLSID_InternetExplorer_Value = @import("../zig.zig").Guid.initString("0002df01-0000-0000-c000-000000000046");
pub const CLSID_InternetExplorer = &CLSID_InternetExplorer_Value;

const CLSID_InternetExplorerMedium_Value = @import("../zig.zig").Guid.initString("d5e8041d-920f-45e9-b8fb-b1deb82c6e5e");
pub const CLSID_InternetExplorerMedium = &CLSID_InternetExplorerMedium_Value;

const CLSID_ShellBrowserWindow_Value = @import("../zig.zig").Guid.initString("c08afd90-f2a1-11d1-8455-00a0c91f3880");
pub const CLSID_ShellBrowserWindow = &CLSID_ShellBrowserWindow_Value;

const CLSID_ShellWindows_Value = @import("../zig.zig").Guid.initString("9ba05972-f6a8-11cf-a442-00a0c90a8f39");
pub const CLSID_ShellWindows = &CLSID_ShellWindows_Value;

const CLSID_ShellUIHelper_Value = @import("../zig.zig").Guid.initString("64ab4bb7-111e-11d1-8f79-00c04fc2fbe1");
pub const CLSID_ShellUIHelper = &CLSID_ShellUIHelper_Value;

const CLSID_ShellNameSpace_Value = @import("../zig.zig").Guid.initString("55136805-b2de-11d1-b9f2-00a0c98bc547");
pub const CLSID_ShellNameSpace = &CLSID_ShellNameSpace_Value;

const CLSID_CScriptErrorList_Value = @import("../zig.zig").Guid.initString("efd01300-160f-11d2-bb2e-00805ff7efca");
pub const CLSID_CScriptErrorList = &CLSID_CScriptErrorList_Value;

pub const CommandStateChangeConstants = enum(i32) {
    UPDATECOMMANDS = -1,
    NAVIGATEFORWARD = 1,
    NAVIGATEBACK = 2,
};
pub const CSC_UPDATECOMMANDS = CommandStateChangeConstants.UPDATECOMMANDS;
pub const CSC_NAVIGATEFORWARD = CommandStateChangeConstants.NAVIGATEFORWARD;
pub const CSC_NAVIGATEBACK = CommandStateChangeConstants.NAVIGATEBACK;

pub const SecureLockIconConstants = enum(i32) {
    Unsecure = 0,
    Mixed = 1,
    SecureUnknownBits = 2,
    Secure40Bit = 3,
    Secure56Bit = 4,
    SecureFortezza = 5,
    Secure128Bit = 6,
};
pub const secureLockIconUnsecure = SecureLockIconConstants.Unsecure;
pub const secureLockIconMixed = SecureLockIconConstants.Mixed;
pub const secureLockIconSecureUnknownBits = SecureLockIconConstants.SecureUnknownBits;
pub const secureLockIconSecure40Bit = SecureLockIconConstants.Secure40Bit;
pub const secureLockIconSecure56Bit = SecureLockIconConstants.Secure56Bit;
pub const secureLockIconSecureFortezza = SecureLockIconConstants.SecureFortezza;
pub const secureLockIconSecure128Bit = SecureLockIconConstants.Secure128Bit;

pub const NewProcessCauseConstants = enum(i32) {
    t = 1,
};
pub const ProtectedModeRedirect = NewProcessCauseConstants.t;

pub const ShellWindowTypeConstants = enum(i32) {
    EXPLORER = 0,
    BROWSER = 1,
    @"3RDPARTY" = 2,
    CALLBACK = 4,
    DESKTOP = 8,
};
pub const SWC_EXPLORER = ShellWindowTypeConstants.EXPLORER;
pub const SWC_BROWSER = ShellWindowTypeConstants.BROWSER;
pub const SWC_3RDPARTY = ShellWindowTypeConstants.@"3RDPARTY";
pub const SWC_CALLBACK = ShellWindowTypeConstants.CALLBACK;
pub const SWC_DESKTOP = ShellWindowTypeConstants.DESKTOP;

pub const ShellWindowFindWindowOptions = enum(i32) {
    NEEDDISPATCH = 1,
    INCLUDEPENDING = 2,
    COOKIEPASSED = 4,
};
pub const SWFO_NEEDDISPATCH = ShellWindowFindWindowOptions.NEEDDISPATCH;
pub const SWFO_INCLUDEPENDING = ShellWindowFindWindowOptions.INCLUDEPENDING;
pub const SWFO_COOKIEPASSED = ShellWindowFindWindowOptions.COOKIEPASSED;

pub const BrowserNavConstants = enum(i32) {
    OpenInNewWindow = 1,
    NoHistory = 2,
    NoReadFromCache = 4,
    NoWriteToCache = 8,
    AllowAutosearch = 16,
    BrowserBar = 32,
    Hyperlink = 64,
    EnforceRestricted = 128,
    NewWindowsManaged = 256,
    UntrustedForDownload = 512,
    TrustedForActiveX = 1024,
    OpenInNewTab = 2048,
    OpenInBackgroundTab = 4096,
    KeepWordWheelText = 8192,
    VirtualTab = 16384,
    BlockRedirectsXDomain = 32768,
    OpenNewForegroundTab = 65536,
    TravelLogScreenshot = 131072,
    DeferUnload = 262144,
    Speculative = 524288,
    SuggestNewWindow = 1048576,
    SuggestNewTab = 2097152,
    Reserved1 = 4194304,
    HomepageNavigate = 8388608,
    Refresh = 16777216,
    HostNavigation = 33554432,
    Reserved2 = 67108864,
    Reserved3 = 134217728,
    Reserved4 = 268435456,
    Reserved5 = 536870912,
    Reserved6 = 1073741824,
    Reserved7 = -2147483648,
};
pub const navOpenInNewWindow = BrowserNavConstants.OpenInNewWindow;
pub const navNoHistory = BrowserNavConstants.NoHistory;
pub const navNoReadFromCache = BrowserNavConstants.NoReadFromCache;
pub const navNoWriteToCache = BrowserNavConstants.NoWriteToCache;
pub const navAllowAutosearch = BrowserNavConstants.AllowAutosearch;
pub const navBrowserBar = BrowserNavConstants.BrowserBar;
pub const navHyperlink = BrowserNavConstants.Hyperlink;
pub const navEnforceRestricted = BrowserNavConstants.EnforceRestricted;
pub const navNewWindowsManaged = BrowserNavConstants.NewWindowsManaged;
pub const navUntrustedForDownload = BrowserNavConstants.UntrustedForDownload;
pub const navTrustedForActiveX = BrowserNavConstants.TrustedForActiveX;
pub const navOpenInNewTab = BrowserNavConstants.OpenInNewTab;
pub const navOpenInBackgroundTab = BrowserNavConstants.OpenInBackgroundTab;
pub const navKeepWordWheelText = BrowserNavConstants.KeepWordWheelText;
pub const navVirtualTab = BrowserNavConstants.VirtualTab;
pub const navBlockRedirectsXDomain = BrowserNavConstants.BlockRedirectsXDomain;
pub const navOpenNewForegroundTab = BrowserNavConstants.OpenNewForegroundTab;
pub const navTravelLogScreenshot = BrowserNavConstants.TravelLogScreenshot;
pub const navDeferUnload = BrowserNavConstants.DeferUnload;
pub const navSpeculative = BrowserNavConstants.Speculative;
pub const navSuggestNewWindow = BrowserNavConstants.SuggestNewWindow;
pub const navSuggestNewTab = BrowserNavConstants.SuggestNewTab;
pub const navReserved1 = BrowserNavConstants.Reserved1;
pub const navHomepageNavigate = BrowserNavConstants.HomepageNavigate;
pub const navRefresh = BrowserNavConstants.Refresh;
pub const navHostNavigation = BrowserNavConstants.HostNavigation;
pub const navReserved2 = BrowserNavConstants.Reserved2;
pub const navReserved3 = BrowserNavConstants.Reserved3;
pub const navReserved4 = BrowserNavConstants.Reserved4;
pub const navReserved5 = BrowserNavConstants.Reserved5;
pub const navReserved6 = BrowserNavConstants.Reserved6;
pub const navReserved7 = BrowserNavConstants.Reserved7;

pub const RefreshConstants = enum(i32) {
    NORMAL = 0,
    IFEXPIRED = 1,
    COMPLETELY = 3,
};
pub const REFRESH_NORMAL = RefreshConstants.NORMAL;
pub const REFRESH_IFEXPIRED = RefreshConstants.IFEXPIRED;
pub const REFRESH_COMPLETELY = RefreshConstants.COMPLETELY;

const IID_IWebBrowser_Value = @import("../zig.zig").Guid.initString("eab22ac1-30c1-11cf-a7eb-0000c05bae0b");
pub const IID_IWebBrowser = &IID_IWebBrowser_Value;
pub const IWebBrowser = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GoBack: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoForward: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoHome: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoSearch: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Navigate: fn(
            self: *const IWebBrowser,
            URL: ?BSTR,
            Flags: ?*VARIANT,
            TargetFrameName: ?*VARIANT,
            PostData: ?*VARIANT,
            Headers: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh2: fn(
            self: *const IWebBrowser,
            Level: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const IWebBrowser,
            ppDisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: fn(
            self: *const IWebBrowser,
            ppDisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Container: fn(
            self: *const IWebBrowser,
            ppDisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Document: fn(
            self: *const IWebBrowser,
            ppDisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TopLevelContainer: fn(
            self: *const IWebBrowser,
            pBool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IWebBrowser,
            Type: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: fn(
            self: *const IWebBrowser,
            pl: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: fn(
            self: *const IWebBrowser,
            Left: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: fn(
            self: *const IWebBrowser,
            pl: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: fn(
            self: *const IWebBrowser,
            Top: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: fn(
            self: *const IWebBrowser,
            pl: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: fn(
            self: *const IWebBrowser,
            Width: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: fn(
            self: *const IWebBrowser,
            pl: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: fn(
            self: *const IWebBrowser,
            Height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocationName: fn(
            self: *const IWebBrowser,
            LocationName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocationURL: fn(
            self: *const IWebBrowser,
            LocationURL: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Busy: fn(
            self: *const IWebBrowser,
            pBool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoBack(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoBack(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoForward(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoForward(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoHome(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoHome(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoSearch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoSearch(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Navigate(self: *const T, URL: ?BSTR, Flags: ?*VARIANT, TargetFrameName: ?*VARIANT, PostData: ?*VARIANT, Headers: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Navigate(@ptrCast(*const IWebBrowser, self), URL, Flags, TargetFrameName, PostData, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Refresh(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Refresh2(self: *const T, Level: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Refresh2(@ptrCast(*const IWebBrowser, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Stop(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Application(self: *const T, ppDisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Application(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Parent(self: *const T, ppDisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Parent(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Container(self: *const T, ppDisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Container(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Document(self: *const T, ppDisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Document(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_TopLevelContainer(self: *const T, pBool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_TopLevelContainer(@ptrCast(*const IWebBrowser, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Type(self: *const T, Type: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Type(@ptrCast(*const IWebBrowser, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Left(self: *const T, pl: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Left(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Left(self: *const T, Left: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Left(@ptrCast(*const IWebBrowser, self), Left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Top(self: *const T, pl: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Top(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Top(self: *const T, Top: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Top(@ptrCast(*const IWebBrowser, self), Top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Width(self: *const T, pl: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Width(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Width(self: *const T, Width: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Width(@ptrCast(*const IWebBrowser, self), Width);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Height(self: *const T, pl: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Height(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Height(self: *const T, Height: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Height(@ptrCast(*const IWebBrowser, self), Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_LocationName(self: *const T, LocationName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_LocationName(@ptrCast(*const IWebBrowser, self), LocationName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_LocationURL(self: *const T, LocationURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_LocationURL(@ptrCast(*const IWebBrowser, self), LocationURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Busy(self: *const T, pBool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Busy(@ptrCast(*const IWebBrowser, self), pBool);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBrowserEvents_Value = @import("../zig.zig").Guid.initString("eab22ac2-30c1-11cf-a7eb-0000c05bae0b");
pub const IID_DWebBrowserEvents = &IID_DWebBrowserEvents_Value;
pub const DWebBrowserEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebBrowserApp_Value = @import("../zig.zig").Guid.initString("0002df05-0000-0000-c000-000000000046");
pub const IID_IWebBrowserApp = &IID_IWebBrowserApp_Value;
pub const IWebBrowserApp = extern struct {
    pub const VTable = extern struct {
        base: IWebBrowser.VTable,
        Quit: fn(
            self: *const IWebBrowserApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClientToWindow: fn(
            self: *const IWebBrowserApp,
            pcx: ?*i32,
            pcy: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutProperty: fn(
            self: *const IWebBrowserApp,
            Property: ?BSTR,
            vtValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IWebBrowserApp,
            Property: ?BSTR,
            pvtValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const IWebBrowserApp,
            Name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWND: fn(
            self: *const IWebBrowserApp,
            pHWND: ?*SHANDLE_PTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullName: fn(
            self: *const IWebBrowserApp,
            FullName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IWebBrowserApp,
            Path: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: fn(
            self: *const IWebBrowserApp,
            pBool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: fn(
            self: *const IWebBrowserApp,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusBar: fn(
            self: *const IWebBrowserApp,
            pBool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StatusBar: fn(
            self: *const IWebBrowserApp,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StatusText: fn(
            self: *const IWebBrowserApp,
            StatusText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StatusText: fn(
            self: *const IWebBrowserApp,
            StatusText: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ToolBar: fn(
            self: *const IWebBrowserApp,
            Value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ToolBar: fn(
            self: *const IWebBrowserApp,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MenuBar: fn(
            self: *const IWebBrowserApp,
            Value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MenuBar: fn(
            self: *const IWebBrowserApp,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullScreen: fn(
            self: *const IWebBrowserApp,
            pbFullScreen: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FullScreen: fn(
            self: *const IWebBrowserApp,
            bFullScreen: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWebBrowser.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_Quit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).Quit(@ptrCast(*const IWebBrowserApp, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_ClientToWindow(self: *const T, pcx: ?*i32, pcy: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).ClientToWindow(@ptrCast(*const IWebBrowserApp, self), pcx, pcy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_PutProperty(self: *const T, Property: ?BSTR, vtValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).PutProperty(@ptrCast(*const IWebBrowserApp, self), Property, vtValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_GetProperty(self: *const T, Property: ?BSTR, pvtValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).GetProperty(@ptrCast(*const IWebBrowserApp, self), Property, pvtValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_Name(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_Name(@ptrCast(*const IWebBrowserApp, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_HWND(self: *const T, pHWND: ?*SHANDLE_PTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_HWND(@ptrCast(*const IWebBrowserApp, self), pHWND);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_FullName(self: *const T, FullName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_FullName(@ptrCast(*const IWebBrowserApp, self), FullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_Path(self: *const T, Path: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_Path(@ptrCast(*const IWebBrowserApp, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_Visible(self: *const T, pBool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_Visible(@ptrCast(*const IWebBrowserApp, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_Visible(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_Visible(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_StatusBar(self: *const T, pBool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_StatusBar(@ptrCast(*const IWebBrowserApp, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_StatusBar(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_StatusBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_StatusText(self: *const T, StatusText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_StatusText(@ptrCast(*const IWebBrowserApp, self), StatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_StatusText(self: *const T, StatusText: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_StatusText(@ptrCast(*const IWebBrowserApp, self), StatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_ToolBar(self: *const T, Value: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_ToolBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_ToolBar(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_ToolBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_MenuBar(self: *const T, Value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_MenuBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_MenuBar(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_MenuBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_FullScreen(self: *const T, pbFullScreen: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_FullScreen(@ptrCast(*const IWebBrowserApp, self), pbFullScreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_FullScreen(self: *const T, bFullScreen: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_FullScreen(@ptrCast(*const IWebBrowserApp, self), bFullScreen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWebBrowser2_Value = @import("../zig.zig").Guid.initString("d30c1661-cdaf-11d0-8a3e-00c04fc9e26e");
pub const IID_IWebBrowser2 = &IID_IWebBrowser2_Value;
pub const IWebBrowser2 = extern struct {
    pub const VTable = extern struct {
        base: IWebBrowserApp.VTable,
        Navigate2: fn(
            self: *const IWebBrowser2,
            URL: ?*VARIANT,
            Flags: ?*VARIANT,
            TargetFrameName: ?*VARIANT,
            PostData: ?*VARIANT,
            Headers: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryStatusWB: fn(
            self: *const IWebBrowser2,
            cmdID: OLECMDID,
            pcmdf: ?*OLECMDF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecWB: fn(
            self: *const IWebBrowser2,
            cmdID: OLECMDID,
            cmdexecopt: OLECMDEXECOPT,
            pvaIn: ?*VARIANT,
            pvaOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowBrowserBar: fn(
            self: *const IWebBrowser2,
            pvaClsid: ?*VARIANT,
            pvarShow: ?*VARIANT,
            pvarSize: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReadyState: fn(
            self: *const IWebBrowser2,
            plReadyState: ?*READYSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Offline: fn(
            self: *const IWebBrowser2,
            pbOffline: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Offline: fn(
            self: *const IWebBrowser2,
            bOffline: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Silent: fn(
            self: *const IWebBrowser2,
            pbSilent: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Silent: fn(
            self: *const IWebBrowser2,
            bSilent: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegisterAsBrowser: fn(
            self: *const IWebBrowser2,
            pbRegister: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RegisterAsBrowser: fn(
            self: *const IWebBrowser2,
            bRegister: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegisterAsDropTarget: fn(
            self: *const IWebBrowser2,
            pbRegister: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RegisterAsDropTarget: fn(
            self: *const IWebBrowser2,
            bRegister: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TheaterMode: fn(
            self: *const IWebBrowser2,
            pbRegister: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TheaterMode: fn(
            self: *const IWebBrowser2,
            bRegister: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AddressBar: fn(
            self: *const IWebBrowser2,
            Value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AddressBar: fn(
            self: *const IWebBrowser2,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Resizable: fn(
            self: *const IWebBrowser2,
            Value: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Resizable: fn(
            self: *const IWebBrowser2,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWebBrowserApp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_Navigate2(self: *const T, URL: ?*VARIANT, Flags: ?*VARIANT, TargetFrameName: ?*VARIANT, PostData: ?*VARIANT, Headers: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).Navigate2(@ptrCast(*const IWebBrowser2, self), URL, Flags, TargetFrameName, PostData, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_QueryStatusWB(self: *const T, cmdID: OLECMDID, pcmdf: ?*OLECMDF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).QueryStatusWB(@ptrCast(*const IWebBrowser2, self), cmdID, pcmdf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_ExecWB(self: *const T, cmdID: OLECMDID, cmdexecopt: OLECMDEXECOPT, pvaIn: ?*VARIANT, pvaOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).ExecWB(@ptrCast(*const IWebBrowser2, self), cmdID, cmdexecopt, pvaIn, pvaOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_ShowBrowserBar(self: *const T, pvaClsid: ?*VARIANT, pvarShow: ?*VARIANT, pvarSize: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).ShowBrowserBar(@ptrCast(*const IWebBrowser2, self), pvaClsid, pvarShow, pvarSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_ReadyState(self: *const T, plReadyState: ?*READYSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_ReadyState(@ptrCast(*const IWebBrowser2, self), plReadyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_Offline(self: *const T, pbOffline: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_Offline(@ptrCast(*const IWebBrowser2, self), pbOffline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_Offline(self: *const T, bOffline: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_Offline(@ptrCast(*const IWebBrowser2, self), bOffline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_Silent(self: *const T, pbSilent: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_Silent(@ptrCast(*const IWebBrowser2, self), pbSilent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_Silent(self: *const T, bSilent: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_Silent(@ptrCast(*const IWebBrowser2, self), bSilent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_RegisterAsBrowser(self: *const T, pbRegister: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_RegisterAsBrowser(@ptrCast(*const IWebBrowser2, self), pbRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_RegisterAsBrowser(self: *const T, bRegister: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_RegisterAsBrowser(@ptrCast(*const IWebBrowser2, self), bRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_RegisterAsDropTarget(self: *const T, pbRegister: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_RegisterAsDropTarget(@ptrCast(*const IWebBrowser2, self), pbRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_RegisterAsDropTarget(self: *const T, bRegister: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_RegisterAsDropTarget(@ptrCast(*const IWebBrowser2, self), bRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_TheaterMode(self: *const T, pbRegister: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_TheaterMode(@ptrCast(*const IWebBrowser2, self), pbRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_TheaterMode(self: *const T, bRegister: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_TheaterMode(@ptrCast(*const IWebBrowser2, self), bRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_AddressBar(self: *const T, Value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_AddressBar(@ptrCast(*const IWebBrowser2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_AddressBar(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_AddressBar(@ptrCast(*const IWebBrowser2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_Resizable(self: *const T, Value: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_Resizable(@ptrCast(*const IWebBrowser2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_Resizable(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_Resizable(@ptrCast(*const IWebBrowser2, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBrowserEvents2_Value = @import("../zig.zig").Guid.initString("34a715a0-6587-11d0-924a-0020afc7ac4d");
pub const IID_DWebBrowserEvents2 = &IID_DWebBrowserEvents2_Value;
pub const DWebBrowserEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellWindowsEvents_Value = @import("../zig.zig").Guid.initString("fe4106e0-399a-11d0-a48c-00a0c90a8f39");
pub const IID_DShellWindowsEvents = &IID_DShellWindowsEvents_Value;
pub const DShellWindowsEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellWindows_Value = @import("../zig.zig").Guid.initString("85cb6900-4d95-11cf-960c-0080c7f4ee85");
pub const IID_IShellWindows = &IID_IShellWindows_Value;
pub const IShellWindows = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IShellWindows,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IShellWindows,
            index: VARIANT,
            Folder: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _NewEnum: fn(
            self: *const IShellWindows,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Register: fn(
            self: *const IShellWindows,
            pid: ?*IDispatch,
            hwnd: i32,
            swClass: i32,
            plCookie: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterPending: fn(
            self: *const IShellWindows,
            lThreadId: i32,
            pvarloc: ?*VARIANT,
            pvarlocRoot: ?*VARIANT,
            swClass: i32,
            plCookie: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revoke: fn(
            self: *const IShellWindows,
            lCookie: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnNavigate: fn(
            self: *const IShellWindows,
            lCookie: i32,
            pvarLoc: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnActivated: fn(
            self: *const IShellWindows,
            lCookie: i32,
            fActive: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindWindowSW: fn(
            self: *const IShellWindows,
            pvarLoc: ?*VARIANT,
            pvarLocRoot: ?*VARIANT,
            swClass: i32,
            phwnd: ?*i32,
            swfwOptions: i32,
            ppdispOut: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCreated: fn(
            self: *const IShellWindows,
            lCookie: i32,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessAttachDetach: fn(
            self: *const IShellWindows,
            fAttach: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).get_Count(@ptrCast(*const IShellWindows, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_Item(self: *const T, index: VARIANT, _param_Folder: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).Item(@ptrCast(*const IShellWindows, self), index, _param_Folder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows__NewEnum(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable)._NewEnum(@ptrCast(*const IShellWindows, self), ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_Register(self: *const T, pid: ?*IDispatch, hwnd: i32, swClass: i32, plCookie: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).Register(@ptrCast(*const IShellWindows, self), pid, hwnd, swClass, plCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_RegisterPending(self: *const T, lThreadId: i32, pvarloc: ?*VARIANT, pvarlocRoot: ?*VARIANT, swClass: i32, plCookie: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).RegisterPending(@ptrCast(*const IShellWindows, self), lThreadId, pvarloc, pvarlocRoot, swClass, plCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_Revoke(self: *const T, lCookie: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).Revoke(@ptrCast(*const IShellWindows, self), lCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_OnNavigate(self: *const T, lCookie: i32, pvarLoc: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).OnNavigate(@ptrCast(*const IShellWindows, self), lCookie, pvarLoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_OnActivated(self: *const T, lCookie: i32, fActive: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).OnActivated(@ptrCast(*const IShellWindows, self), lCookie, fActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_FindWindowSW(self: *const T, pvarLoc: ?*VARIANT, pvarLocRoot: ?*VARIANT, swClass: i32, phwnd: ?*i32, swfwOptions: i32, ppdispOut: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).FindWindowSW(@ptrCast(*const IShellWindows, self), pvarLoc, pvarLocRoot, swClass, phwnd, swfwOptions, ppdispOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_OnCreated(self: *const T, lCookie: i32, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).OnCreated(@ptrCast(*const IShellWindows, self), lCookie, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellWindows_ProcessAttachDetach(self: *const T, fAttach: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellWindows.VTable, self.vtable).ProcessAttachDetach(@ptrCast(*const IShellWindows, self), fAttach);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper_Value = @import("../zig.zig").Guid.initString("729fe2f8-1ea8-11d1-8f85-00c04fc2fbe1");
pub const IID_IShellUIHelper = &IID_IShellUIHelper_Value;
pub const IShellUIHelper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ResetFirstBootMode: fn(
            self: *const IShellUIHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetSafeMode: fn(
            self: *const IShellUIHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RefreshOfflineDesktop: fn(
            self: *const IShellUIHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFavorite: fn(
            self: *const IShellUIHelper,
            URL: ?BSTR,
            Title: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddChannel: fn(
            self: *const IShellUIHelper,
            URL: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDesktopComponent: fn(
            self: *const IShellUIHelper,
            URL: ?BSTR,
            Type: ?BSTR,
            Left: ?*VARIANT,
            Top: ?*VARIANT,
            Width: ?*VARIANT,
            Height: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubscribed: fn(
            self: *const IShellUIHelper,
            URL: ?BSTR,
            pBool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateAndFind: fn(
            self: *const IShellUIHelper,
            URL: ?BSTR,
            strQuery: ?BSTR,
            varTargetFrame: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportExportFavorites: fn(
            self: *const IShellUIHelper,
            fImport: i16,
            strImpExpPath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoCompleteSaveForm: fn(
            self: *const IShellUIHelper,
            Form: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoScan: fn(
            self: *const IShellUIHelper,
            strSearch: ?BSTR,
            strFailureUrl: ?BSTR,
            pvarTargetFrame: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoCompleteAttach: fn(
            self: *const IShellUIHelper,
            Reserved: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowBrowserUI: fn(
            self: *const IShellUIHelper,
            bstrName: ?BSTR,
            pvarIn: ?*VARIANT,
            pvarOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ResetFirstBootMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ResetFirstBootMode(@ptrCast(*const IShellUIHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ResetSafeMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ResetSafeMode(@ptrCast(*const IShellUIHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_RefreshOfflineDesktop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).RefreshOfflineDesktop(@ptrCast(*const IShellUIHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AddFavorite(self: *const T, URL: ?BSTR, Title: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AddFavorite(@ptrCast(*const IShellUIHelper, self), URL, Title);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AddChannel(self: *const T, URL: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AddChannel(@ptrCast(*const IShellUIHelper, self), URL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AddDesktopComponent(self: *const T, URL: ?BSTR, Type: ?BSTR, Left: ?*VARIANT, Top: ?*VARIANT, Width: ?*VARIANT, Height: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AddDesktopComponent(@ptrCast(*const IShellUIHelper, self), URL, Type, Left, Top, Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_IsSubscribed(self: *const T, URL: ?BSTR, pBool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).IsSubscribed(@ptrCast(*const IShellUIHelper, self), URL, pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_NavigateAndFind(self: *const T, URL: ?BSTR, strQuery: ?BSTR, varTargetFrame: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).NavigateAndFind(@ptrCast(*const IShellUIHelper, self), URL, strQuery, varTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ImportExportFavorites(self: *const T, fImport: i16, strImpExpPath: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ImportExportFavorites(@ptrCast(*const IShellUIHelper, self), fImport, strImpExpPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AutoCompleteSaveForm(self: *const T, Form: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AutoCompleteSaveForm(@ptrCast(*const IShellUIHelper, self), Form);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AutoScan(self: *const T, strSearch: ?BSTR, strFailureUrl: ?BSTR, pvarTargetFrame: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AutoScan(@ptrCast(*const IShellUIHelper, self), strSearch, strFailureUrl, pvarTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AutoCompleteAttach(self: *const T, Reserved: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AutoCompleteAttach(@ptrCast(*const IShellUIHelper, self), Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ShowBrowserUI(self: *const T, bstrName: ?BSTR, pvarIn: ?*VARIANT, pvarOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ShowBrowserUI(@ptrCast(*const IShellUIHelper, self), bstrName, pvarIn, pvarOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper2_Value = @import("../zig.zig").Guid.initString("a7fe6eda-1932-4281-b881-87b31b8bc52c");
pub const IID_IShellUIHelper2 = &IID_IShellUIHelper2_Value;
pub const IShellUIHelper2 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper.VTable,
        AddSearchProvider: fn(
            self: *const IShellUIHelper2,
            URL: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunOnceShown: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SkipRunOnce: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CustomizeSettings: fn(
            self: *const IShellUIHelper2,
            fSQM: i16,
            fPhishing: i16,
            bstrLocale: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SqmEnabled: fn(
            self: *const IShellUIHelper2,
            pfEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PhishingEnabled: fn(
            self: *const IShellUIHelper2,
            pfEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BrandImageUri: fn(
            self: *const IShellUIHelper2,
            pbstrUri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SkipTabsWelcome: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiagnoseConnection: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CustomizeClearType: fn(
            self: *const IShellUIHelper2,
            fSet: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSearchProviderInstalled: fn(
            self: *const IShellUIHelper2,
            URL: ?BSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSearchMigrated: fn(
            self: *const IShellUIHelper2,
            pfMigrated: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultSearchProvider: fn(
            self: *const IShellUIHelper2,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunOnceRequiredSettingsComplete: fn(
            self: *const IShellUIHelper2,
            fComplete: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunOnceHasShown: fn(
            self: *const IShellUIHelper2,
            pfShown: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SearchGuideUrl: fn(
            self: *const IShellUIHelper2,
            pbstrUrl: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_AddSearchProvider(self: *const T, URL: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).AddSearchProvider(@ptrCast(*const IShellUIHelper2, self), URL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_RunOnceShown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).RunOnceShown(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SkipRunOnce(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SkipRunOnce(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_CustomizeSettings(self: *const T, fSQM: i16, fPhishing: i16, bstrLocale: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).CustomizeSettings(@ptrCast(*const IShellUIHelper2, self), fSQM, fPhishing, bstrLocale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SqmEnabled(self: *const T, pfEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SqmEnabled(@ptrCast(*const IShellUIHelper2, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_PhishingEnabled(self: *const T, pfEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).PhishingEnabled(@ptrCast(*const IShellUIHelper2, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_BrandImageUri(self: *const T, pbstrUri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).BrandImageUri(@ptrCast(*const IShellUIHelper2, self), pbstrUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SkipTabsWelcome(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SkipTabsWelcome(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_DiagnoseConnection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).DiagnoseConnection(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_CustomizeClearType(self: *const T, fSet: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).CustomizeClearType(@ptrCast(*const IShellUIHelper2, self), fSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_IsSearchProviderInstalled(self: *const T, URL: ?BSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).IsSearchProviderInstalled(@ptrCast(*const IShellUIHelper2, self), URL, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_IsSearchMigrated(self: *const T, pfMigrated: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).IsSearchMigrated(@ptrCast(*const IShellUIHelper2, self), pfMigrated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_DefaultSearchProvider(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).DefaultSearchProvider(@ptrCast(*const IShellUIHelper2, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_RunOnceRequiredSettingsComplete(self: *const T, fComplete: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).RunOnceRequiredSettingsComplete(@ptrCast(*const IShellUIHelper2, self), fComplete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_RunOnceHasShown(self: *const T, pfShown: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).RunOnceHasShown(@ptrCast(*const IShellUIHelper2, self), pfShown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SearchGuideUrl(self: *const T, pbstrUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SearchGuideUrl(@ptrCast(*const IShellUIHelper2, self), pbstrUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper3_Value = @import("../zig.zig").Guid.initString("528df2ec-d419-40bc-9b6d-dcdbf9c1b25d");
pub const IID_IShellUIHelper3 = &IID_IShellUIHelper3_Value;
pub const IShellUIHelper3 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper2.VTable,
        AddService: fn(
            self: *const IShellUIHelper3,
            URL: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsServiceInstalled: fn(
            self: *const IShellUIHelper3,
            URL: ?BSTR,
            Verb: ?BSTR,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InPrivateFilteringEnabled: fn(
            self: *const IShellUIHelper3,
            pfEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddToFavoritesBar: fn(
            self: *const IShellUIHelper3,
            URL: ?BSTR,
            Title: ?BSTR,
            Type: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BuildNewTabPage: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRecentlyClosedVisible: fn(
            self: *const IShellUIHelper3,
            fVisible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActivitiesVisible: fn(
            self: *const IShellUIHelper3,
            fVisible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentDiscoveryReset: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSuggestedSitesEnabled: fn(
            self: *const IShellUIHelper3,
            pfEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableSuggestedSites: fn(
            self: *const IShellUIHelper3,
            fEnable: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateToSuggestedSites: fn(
            self: *const IShellUIHelper3,
            bstrRelativeUrl: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowTabsHelp: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowInPrivateHelp: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_AddService(self: *const T, URL: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).AddService(@ptrCast(*const IShellUIHelper3, self), URL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_IsServiceInstalled(self: *const T, URL: ?BSTR, Verb: ?BSTR, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).IsServiceInstalled(@ptrCast(*const IShellUIHelper3, self), URL, Verb, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_InPrivateFilteringEnabled(self: *const T, pfEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).InPrivateFilteringEnabled(@ptrCast(*const IShellUIHelper3, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_AddToFavoritesBar(self: *const T, URL: ?BSTR, Title: ?BSTR, Type: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).AddToFavoritesBar(@ptrCast(*const IShellUIHelper3, self), URL, Title, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_BuildNewTabPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).BuildNewTabPage(@ptrCast(*const IShellUIHelper3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_SetRecentlyClosedVisible(self: *const T, fVisible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).SetRecentlyClosedVisible(@ptrCast(*const IShellUIHelper3, self), fVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_SetActivitiesVisible(self: *const T, fVisible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).SetActivitiesVisible(@ptrCast(*const IShellUIHelper3, self), fVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_ContentDiscoveryReset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).ContentDiscoveryReset(@ptrCast(*const IShellUIHelper3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_IsSuggestedSitesEnabled(self: *const T, pfEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).IsSuggestedSitesEnabled(@ptrCast(*const IShellUIHelper3, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_EnableSuggestedSites(self: *const T, fEnable: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).EnableSuggestedSites(@ptrCast(*const IShellUIHelper3, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_NavigateToSuggestedSites(self: *const T, bstrRelativeUrl: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).NavigateToSuggestedSites(@ptrCast(*const IShellUIHelper3, self), bstrRelativeUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_ShowTabsHelp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).ShowTabsHelp(@ptrCast(*const IShellUIHelper3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_ShowInPrivateHelp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).ShowInPrivateHelp(@ptrCast(*const IShellUIHelper3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper4_Value = @import("../zig.zig").Guid.initString("b36e6a53-8073-499e-824c-d776330a333e");
pub const IID_IShellUIHelper4 = &IID_IShellUIHelper4_Value;
pub const IShellUIHelper4 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper3.VTable,
        msIsSiteMode: fn(
            self: *const IShellUIHelper4,
            pfSiteMode: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeShowThumbBar: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeAddThumbBarButton: fn(
            self: *const IShellUIHelper4,
            bstrIconURL: ?BSTR,
            bstrTooltip: ?BSTR,
            pvarButtonID: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeUpdateThumbBarButton: fn(
            self: *const IShellUIHelper4,
            ButtonID: VARIANT,
            fEnabled: i16,
            fVisible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeSetIconOverlay: fn(
            self: *const IShellUIHelper4,
            IconUrl: ?BSTR,
            pvarDescription: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeClearIconOverlay: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msAddSiteMode: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeCreateJumpList: fn(
            self: *const IShellUIHelper4,
            bstrHeader: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeAddJumpListItem: fn(
            self: *const IShellUIHelper4,
            bstrName: ?BSTR,
            bstrActionUri: ?BSTR,
            bstrIconUri: ?BSTR,
            pvarWindowType: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeClearJumpList: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeShowJumpList: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeAddButtonStyle: fn(
            self: *const IShellUIHelper4,
            uiButtonID: VARIANT,
            bstrIconUrl: ?BSTR,
            bstrTooltip: ?BSTR,
            pvarStyleID: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeShowButtonStyle: fn(
            self: *const IShellUIHelper4,
            uiButtonID: VARIANT,
            uiStyleID: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeActivate: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msIsSiteModeFirstRun: fn(
            self: *const IShellUIHelper4,
            fPreserveState: i16,
            puiFirstRun: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msAddTrackingProtectionList: fn(
            self: *const IShellUIHelper4,
            URL: ?BSTR,
            bstrFilterName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msTrackingProtectionEnabled: fn(
            self: *const IShellUIHelper4,
            pfEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msActiveXFilteringEnabled: fn(
            self: *const IShellUIHelper4,
            pfEnabled: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msIsSiteMode(self: *const T, pfSiteMode: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msIsSiteMode(@ptrCast(*const IShellUIHelper4, self), pfSiteMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeShowThumbBar(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeShowThumbBar(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeAddThumbBarButton(self: *const T, bstrIconURL: ?BSTR, bstrTooltip: ?BSTR, pvarButtonID: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeAddThumbBarButton(@ptrCast(*const IShellUIHelper4, self), bstrIconURL, bstrTooltip, pvarButtonID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeUpdateThumbBarButton(self: *const T, ButtonID: VARIANT, fEnabled: i16, fVisible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeUpdateThumbBarButton(@ptrCast(*const IShellUIHelper4, self), ButtonID, fEnabled, fVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeSetIconOverlay(self: *const T, IconUrl: ?BSTR, pvarDescription: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeSetIconOverlay(@ptrCast(*const IShellUIHelper4, self), IconUrl, pvarDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeClearIconOverlay(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeClearIconOverlay(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msAddSiteMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msAddSiteMode(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeCreateJumpList(self: *const T, bstrHeader: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeCreateJumpList(@ptrCast(*const IShellUIHelper4, self), bstrHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeAddJumpListItem(self: *const T, bstrName: ?BSTR, bstrActionUri: ?BSTR, bstrIconUri: ?BSTR, pvarWindowType: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeAddJumpListItem(@ptrCast(*const IShellUIHelper4, self), bstrName, bstrActionUri, bstrIconUri, pvarWindowType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeClearJumpList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeClearJumpList(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeShowJumpList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeShowJumpList(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeAddButtonStyle(self: *const T, uiButtonID: VARIANT, bstrIconUrl: ?BSTR, bstrTooltip: ?BSTR, pvarStyleID: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeAddButtonStyle(@ptrCast(*const IShellUIHelper4, self), uiButtonID, bstrIconUrl, bstrTooltip, pvarStyleID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeShowButtonStyle(self: *const T, uiButtonID: VARIANT, uiStyleID: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeShowButtonStyle(@ptrCast(*const IShellUIHelper4, self), uiButtonID, uiStyleID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeActivate(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msIsSiteModeFirstRun(self: *const T, fPreserveState: i16, puiFirstRun: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msIsSiteModeFirstRun(@ptrCast(*const IShellUIHelper4, self), fPreserveState, puiFirstRun);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msAddTrackingProtectionList(self: *const T, URL: ?BSTR, bstrFilterName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msAddTrackingProtectionList(@ptrCast(*const IShellUIHelper4, self), URL, bstrFilterName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msTrackingProtectionEnabled(self: *const T, pfEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msTrackingProtectionEnabled(@ptrCast(*const IShellUIHelper4, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msActiveXFilteringEnabled(self: *const T, pfEnabled: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msActiveXFilteringEnabled(@ptrCast(*const IShellUIHelper4, self), pfEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper5_Value = @import("../zig.zig").Guid.initString("a2a08b09-103d-4d3f-b91c-ea455ca82efa");
pub const IID_IShellUIHelper5 = &IID_IShellUIHelper5_Value;
pub const IShellUIHelper5 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper4.VTable,
        msProvisionNetworks: fn(
            self: *const IShellUIHelper5,
            bstrProvisioningXml: ?BSTR,
            puiResult: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msReportSafeUrl: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeRefreshBadge: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeClearBadge: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msDiagnoseConnectionUILess: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msLaunchNetworkClientHelp: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msChangeDefaultBrowser: fn(
            self: *const IShellUIHelper5,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msProvisionNetworks(self: *const T, bstrProvisioningXml: ?BSTR, puiResult: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msProvisionNetworks(@ptrCast(*const IShellUIHelper5, self), bstrProvisioningXml, puiResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msReportSafeUrl(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msReportSafeUrl(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msSiteModeRefreshBadge(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msSiteModeRefreshBadge(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msSiteModeClearBadge(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msSiteModeClearBadge(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msDiagnoseConnectionUILess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msDiagnoseConnectionUILess(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msLaunchNetworkClientHelp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msLaunchNetworkClientHelp(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msChangeDefaultBrowser(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msChangeDefaultBrowser(@ptrCast(*const IShellUIHelper5, self), fChange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper6_Value = @import("../zig.zig").Guid.initString("987a573e-46ee-4e89-96ab-ddf7f8fdc98c");
pub const IID_IShellUIHelper6 = &IID_IShellUIHelper6_Value;
pub const IShellUIHelper6 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper5.VTable,
        msStopPeriodicTileUpdate: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStartPeriodicTileUpdate: fn(
            self: *const IShellUIHelper6,
            pollingUris: VARIANT,
            startTime: VARIANT,
            uiUpdateRecurrence: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStartPeriodicTileUpdateBatch: fn(
            self: *const IShellUIHelper6,
            pollingUris: VARIANT,
            startTime: VARIANT,
            uiUpdateRecurrence: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msClearTile: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueue: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msPinnedSiteState: fn(
            self: *const IShellUIHelper6,
            pvarSiteState: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueueForSquare150x150: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueueForWide310x150: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueueForSquare310x310: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msScheduledTileNotification: fn(
            self: *const IShellUIHelper6,
            bstrNotificationXml: ?BSTR,
            bstrNotificationId: ?BSTR,
            bstrNotificationTag: ?BSTR,
            startTime: VARIANT,
            expirationTime: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msRemoveScheduledTileNotification: fn(
            self: *const IShellUIHelper6,
            bstrNotificationId: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStartPeriodicBadgeUpdate: fn(
            self: *const IShellUIHelper6,
            pollingUri: ?BSTR,
            startTime: VARIANT,
            uiUpdateRecurrence: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStopPeriodicBadgeUpdate: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msLaunchInternetOptions: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStopPeriodicTileUpdate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStopPeriodicTileUpdate(@ptrCast(*const IShellUIHelper6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStartPeriodicTileUpdate(self: *const T, pollingUris: VARIANT, startTime: VARIANT, uiUpdateRecurrence: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStartPeriodicTileUpdate(@ptrCast(*const IShellUIHelper6, self), pollingUris, startTime, uiUpdateRecurrence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStartPeriodicTileUpdateBatch(self: *const T, pollingUris: VARIANT, startTime: VARIANT, uiUpdateRecurrence: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStartPeriodicTileUpdateBatch(@ptrCast(*const IShellUIHelper6, self), pollingUris, startTime, uiUpdateRecurrence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msClearTile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msClearTile(@ptrCast(*const IShellUIHelper6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueue(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueue(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msPinnedSiteState(self: *const T, pvarSiteState: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msPinnedSiteState(@ptrCast(*const IShellUIHelper6, self), pvarSiteState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueueForSquare150x150(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueueForSquare150x150(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueueForWide310x150(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueueForWide310x150(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueueForSquare310x310(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueueForSquare310x310(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msScheduledTileNotification(self: *const T, bstrNotificationXml: ?BSTR, bstrNotificationId: ?BSTR, bstrNotificationTag: ?BSTR, startTime: VARIANT, expirationTime: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msScheduledTileNotification(@ptrCast(*const IShellUIHelper6, self), bstrNotificationXml, bstrNotificationId, bstrNotificationTag, startTime, expirationTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msRemoveScheduledTileNotification(self: *const T, bstrNotificationId: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msRemoveScheduledTileNotification(@ptrCast(*const IShellUIHelper6, self), bstrNotificationId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStartPeriodicBadgeUpdate(self: *const T, pollingUri: ?BSTR, startTime: VARIANT, uiUpdateRecurrence: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStartPeriodicBadgeUpdate(@ptrCast(*const IShellUIHelper6, self), pollingUri, startTime, uiUpdateRecurrence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStopPeriodicBadgeUpdate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStopPeriodicBadgeUpdate(@ptrCast(*const IShellUIHelper6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msLaunchInternetOptions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msLaunchInternetOptions(@ptrCast(*const IShellUIHelper6, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper7_Value = @import("../zig.zig").Guid.initString("60e567c8-9573-4ab2-a264-637c6c161cb1");
pub const IID_IShellUIHelper7 = &IID_IShellUIHelper7_Value;
pub const IShellUIHelper7 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper6.VTable,
        SetExperimentalFlag: fn(
            self: *const IShellUIHelper7,
            bstrFlagString: ?BSTR,
            vfFlag: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExperimentalFlag: fn(
            self: *const IShellUIHelper7,
            bstrFlagString: ?BSTR,
            vfFlag: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExperimentalValue: fn(
            self: *const IShellUIHelper7,
            bstrValueString: ?BSTR,
            dwValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExperimentalValue: fn(
            self: *const IShellUIHelper7,
            bstrValueString: ?BSTR,
            pdwValue: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetAllExperimentalFlagsAndValues: fn(
            self: *const IShellUIHelper7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNeedIEAutoLaunchFlag: fn(
            self: *const IShellUIHelper7,
            bstrUrl: ?BSTR,
            flag: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNeedIEAutoLaunchFlag: fn(
            self: *const IShellUIHelper7,
            bstrUrl: ?BSTR,
            flag: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasNeedIEAutoLaunchFlag: fn(
            self: *const IShellUIHelper7,
            bstrUrl: ?BSTR,
            exists: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LaunchIE: fn(
            self: *const IShellUIHelper7,
            bstrUrl: ?BSTR,
            automated: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_SetExperimentalFlag(self: *const T, bstrFlagString: ?BSTR, vfFlag: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).SetExperimentalFlag(@ptrCast(*const IShellUIHelper7, self), bstrFlagString, vfFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_GetExperimentalFlag(self: *const T, bstrFlagString: ?BSTR, vfFlag: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).GetExperimentalFlag(@ptrCast(*const IShellUIHelper7, self), bstrFlagString, vfFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_SetExperimentalValue(self: *const T, bstrValueString: ?BSTR, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).SetExperimentalValue(@ptrCast(*const IShellUIHelper7, self), bstrValueString, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_GetExperimentalValue(self: *const T, bstrValueString: ?BSTR, pdwValue: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).GetExperimentalValue(@ptrCast(*const IShellUIHelper7, self), bstrValueString, pdwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_ResetAllExperimentalFlagsAndValues(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).ResetAllExperimentalFlagsAndValues(@ptrCast(*const IShellUIHelper7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_GetNeedIEAutoLaunchFlag(self: *const T, bstrUrl: ?BSTR, flag: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).GetNeedIEAutoLaunchFlag(@ptrCast(*const IShellUIHelper7, self), bstrUrl, flag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_SetNeedIEAutoLaunchFlag(self: *const T, bstrUrl: ?BSTR, flag: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).SetNeedIEAutoLaunchFlag(@ptrCast(*const IShellUIHelper7, self), bstrUrl, flag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_HasNeedIEAutoLaunchFlag(self: *const T, bstrUrl: ?BSTR, exists: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).HasNeedIEAutoLaunchFlag(@ptrCast(*const IShellUIHelper7, self), bstrUrl, exists);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_LaunchIE(self: *const T, bstrUrl: ?BSTR, automated: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).LaunchIE(@ptrCast(*const IShellUIHelper7, self), bstrUrl, automated);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper8_Value = @import("../zig.zig").Guid.initString("66debcf2-05b0-4f07-b49b-b96241a65db2");
pub const IID_IShellUIHelper8 = &IID_IShellUIHelper8_Value;
pub const IShellUIHelper8 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper7.VTable,
        GetCVListData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCVListLocalData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEMIEListData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEMIEListLocalData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenFavoritesPane: fn(
            self: *const IShellUIHelper8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenFavoritesSettings: fn(
            self: *const IShellUIHelper8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LaunchInHVSI: fn(
            self: *const IShellUIHelper8,
            bstrUrl: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper7.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetCVListData(self: *const T, pbstrResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetCVListData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetCVListLocalData(self: *const T, pbstrResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetCVListLocalData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetEMIEListData(self: *const T, pbstrResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetEMIEListData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetEMIEListLocalData(self: *const T, pbstrResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetEMIEListLocalData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_OpenFavoritesPane(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).OpenFavoritesPane(@ptrCast(*const IShellUIHelper8, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_OpenFavoritesSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).OpenFavoritesSettings(@ptrCast(*const IShellUIHelper8, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_LaunchInHVSI(self: *const T, bstrUrl: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).LaunchInHVSI(@ptrCast(*const IShellUIHelper8, self), bstrUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper9_Value = @import("../zig.zig").Guid.initString("6cdf73b0-7f2f-451f-bc0f-63e0f3284e54");
pub const IID_IShellUIHelper9 = &IID_IShellUIHelper9_Value;
pub const IShellUIHelper9 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper8.VTable,
        GetOSSku: fn(
            self: *const IShellUIHelper9,
            pdwResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper8.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper9_GetOSSku(self: *const T, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper9.VTable, self.vtable).GetOSSku(@ptrCast(*const IShellUIHelper9, self), pdwResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellNameSpaceEvents_Value = @import("../zig.zig").Guid.initString("55136806-b2de-11d1-b9f2-00a0c98bc547");
pub const IID_DShellNameSpaceEvents = &IID_DShellNameSpaceEvents_Value;
pub const DShellNameSpaceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellFavoritesNameSpace_Value = @import("../zig.zig").Guid.initString("55136804-b2de-11d1-b9f2-00a0c98bc547");
pub const IID_IShellFavoritesNameSpace = &IID_IShellFavoritesNameSpace_Value;
pub const IShellFavoritesNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        MoveSelectionUp: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveSelectionDown: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetSort: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewFolder: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Synchronize: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Export: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeContextMenuCommand: fn(
            self: *const IShellFavoritesNameSpace,
            strCommand: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveSelectionTo: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubscriptionsEnabled: fn(
            self: *const IShellFavoritesNameSpace,
            pBool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSubscriptionForSelection: fn(
            self: *const IShellFavoritesNameSpace,
            pBool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSubscriptionForSelection: fn(
            self: *const IShellFavoritesNameSpace,
            pBool: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRoot: fn(
            self: *const IShellFavoritesNameSpace,
            bstrFullPath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_MoveSelectionUp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).MoveSelectionUp(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_MoveSelectionDown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).MoveSelectionDown(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_ResetSort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).ResetSort(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_NewFolder(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).NewFolder(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_Synchronize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).Synchronize(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_Import(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).Import(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_Export(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).Export(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_InvokeContextMenuCommand(self: *const T, strCommand: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).InvokeContextMenuCommand(@ptrCast(*const IShellFavoritesNameSpace, self), strCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_MoveSelectionTo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).MoveSelectionTo(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_get_SubscriptionsEnabled(self: *const T, pBool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).get_SubscriptionsEnabled(@ptrCast(*const IShellFavoritesNameSpace, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_CreateSubscriptionForSelection(self: *const T, pBool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).CreateSubscriptionForSelection(@ptrCast(*const IShellFavoritesNameSpace, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_DeleteSubscriptionForSelection(self: *const T, pBool: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).DeleteSubscriptionForSelection(@ptrCast(*const IShellFavoritesNameSpace, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_SetRoot(self: *const T, bstrFullPath: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).SetRoot(@ptrCast(*const IShellFavoritesNameSpace, self), bstrFullPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellNameSpace_Value = @import("../zig.zig").Guid.initString("e572d3c9-37be-4ae2-825d-d521763e3108");
pub const IID_IShellNameSpace = &IID_IShellNameSpace_Value;
pub const IShellNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IShellFavoritesNameSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumOptions: fn(
            self: *const IShellNameSpace,
            pgrfEnumFlags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnumOptions: fn(
            self: *const IShellNameSpace,
            lVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectedItem: fn(
            self: *const IShellNameSpace,
            pItem: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SelectedItem: fn(
            self: *const IShellNameSpace,
            pItem: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Root: fn(
            self: *const IShellNameSpace,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Root: fn(
            self: *const IShellNameSpace,
            @"var": VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Depth: fn(
            self: *const IShellNameSpace,
            piDepth: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Depth: fn(
            self: *const IShellNameSpace,
            iDepth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: fn(
            self: *const IShellNameSpace,
            puMode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: fn(
            self: *const IShellNameSpace,
            uMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Flags: fn(
            self: *const IShellNameSpace,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Flags: fn(
            self: *const IShellNameSpace,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVFlags: fn(
            self: *const IShellNameSpace,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFlags: fn(
            self: *const IShellNameSpace,
            dwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Columns: fn(
            self: *const IShellNameSpace,
            bstrColumns: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Columns: fn(
            self: *const IShellNameSpace,
            bstrColumns: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountViewTypes: fn(
            self: *const IShellNameSpace,
            piTypes: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetViewType: fn(
            self: *const IShellNameSpace,
            iType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectedItems: fn(
            self: *const IShellNameSpace,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Expand: fn(
            self: *const IShellNameSpace,
            @"var": VARIANT,
            iDepth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnselectAll: fn(
            self: *const IShellNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellFavoritesNameSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_EnumOptions(self: *const T, pgrfEnumFlags: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_EnumOptions(@ptrCast(*const IShellNameSpace, self), pgrfEnumFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_EnumOptions(self: *const T, lVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_EnumOptions(@ptrCast(*const IShellNameSpace, self), lVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_SelectedItem(self: *const T, pItem: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_SelectedItem(@ptrCast(*const IShellNameSpace, self), pItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_SelectedItem(self: *const T, pItem: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_SelectedItem(@ptrCast(*const IShellNameSpace, self), pItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Root(self: *const T, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Root(@ptrCast(*const IShellNameSpace, self), pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Root(self: *const T, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Root(@ptrCast(*const IShellNameSpace, self), @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Depth(self: *const T, piDepth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Depth(@ptrCast(*const IShellNameSpace, self), piDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Depth(self: *const T, iDepth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Depth(@ptrCast(*const IShellNameSpace, self), iDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Mode(self: *const T, puMode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Mode(@ptrCast(*const IShellNameSpace, self), puMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Mode(self: *const T, uMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Mode(@ptrCast(*const IShellNameSpace, self), uMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Flags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Flags(@ptrCast(*const IShellNameSpace, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Flags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Flags(@ptrCast(*const IShellNameSpace, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_TVFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_TVFlags(@ptrCast(*const IShellNameSpace, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_TVFlags(self: *const T, dwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_TVFlags(@ptrCast(*const IShellNameSpace, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Columns(self: *const T, bstrColumns: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Columns(@ptrCast(*const IShellNameSpace, self), bstrColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Columns(self: *const T, bstrColumns: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Columns(@ptrCast(*const IShellNameSpace, self), bstrColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_CountViewTypes(self: *const T, piTypes: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_CountViewTypes(@ptrCast(*const IShellNameSpace, self), piTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_SetViewType(self: *const T, iType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).SetViewType(@ptrCast(*const IShellNameSpace, self), iType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_SelectedItems(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).SelectedItems(@ptrCast(*const IShellNameSpace, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_Expand(self: *const T, @"var": VARIANT, iDepth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).Expand(@ptrCast(*const IShellNameSpace, self), @"var", iDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_UnselectAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).UnselectAll(@ptrCast(*const IShellNameSpace, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptErrorList_Value = @import("../zig.zig").Guid.initString("f3470f24-15fd-11d2-bb2e-00805ff7efca");
pub const IID_IScriptErrorList = &IID_IScriptErrorList_Value;
pub const IScriptErrorList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        advanceError: fn(
            self: *const IScriptErrorList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        retreatError: fn(
            self: *const IScriptErrorList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        canAdvanceError: fn(
            self: *const IScriptErrorList,
            pfCanAdvance: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        canRetreatError: fn(
            self: *const IScriptErrorList,
            pfCanRetreat: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorLine: fn(
            self: *const IScriptErrorList,
            plLine: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorChar: fn(
            self: *const IScriptErrorList,
            plChar: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorCode: fn(
            self: *const IScriptErrorList,
            plCode: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorMsg: fn(
            self: *const IScriptErrorList,
            pstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorUrl: fn(
            self: *const IScriptErrorList,
            pstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAlwaysShowLockState: fn(
            self: *const IScriptErrorList,
            pfAlwaysShowLocked: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDetailsPaneOpen: fn(
            self: *const IScriptErrorList,
            pfDetailsPaneOpen: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setDetailsPaneOpen: fn(
            self: *const IScriptErrorList,
            fDetailsPaneOpen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPerErrorDisplay: fn(
            self: *const IScriptErrorList,
            pfPerErrorDisplay: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setPerErrorDisplay: fn(
            self: *const IScriptErrorList,
            fPerErrorDisplay: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_advanceError(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).advanceError(@ptrCast(*const IScriptErrorList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_retreatError(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).retreatError(@ptrCast(*const IScriptErrorList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_canAdvanceError(self: *const T, pfCanAdvance: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).canAdvanceError(@ptrCast(*const IScriptErrorList, self), pfCanAdvance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_canRetreatError(self: *const T, pfCanRetreat: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).canRetreatError(@ptrCast(*const IScriptErrorList, self), pfCanRetreat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorLine(self: *const T, plLine: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorLine(@ptrCast(*const IScriptErrorList, self), plLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorChar(self: *const T, plChar: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorChar(@ptrCast(*const IScriptErrorList, self), plChar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorCode(self: *const T, plCode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorCode(@ptrCast(*const IScriptErrorList, self), plCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorMsg(self: *const T, pstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorMsg(@ptrCast(*const IScriptErrorList, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorUrl(self: *const T, pstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorUrl(@ptrCast(*const IScriptErrorList, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getAlwaysShowLockState(self: *const T, pfAlwaysShowLocked: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getAlwaysShowLockState(@ptrCast(*const IScriptErrorList, self), pfAlwaysShowLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getDetailsPaneOpen(self: *const T, pfDetailsPaneOpen: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getDetailsPaneOpen(@ptrCast(*const IScriptErrorList, self), pfDetailsPaneOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_setDetailsPaneOpen(self: *const T, fDetailsPaneOpen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).setDetailsPaneOpen(@ptrCast(*const IScriptErrorList, self), fDetailsPaneOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getPerErrorDisplay(self: *const T, pfPerErrorDisplay: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getPerErrorDisplay(@ptrCast(*const IScriptErrorList, self), pfPerErrorDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_setPerErrorDisplay(self: *const T, fPerErrorDisplay: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).setPerErrorDisplay(@ptrCast(*const IScriptErrorList, self), fPerErrorDisplay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ShellFolderViewOC_Value = @import("../zig.zig").Guid.initString("9ba05971-f6a8-11cf-a442-00a0c90a8f39");
pub const CLSID_ShellFolderViewOC = &CLSID_ShellFolderViewOC_Value;

const CLSID_ShellFolderItem_Value = @import("../zig.zig").Guid.initString("2fe352ea-fd1f-11d2-b1f4-00c04f8eeb3e");
pub const CLSID_ShellFolderItem = &CLSID_ShellFolderItem_Value;

const CLSID_ShellLinkObject_Value = @import("../zig.zig").Guid.initString("11219420-1768-11d1-95be-00609797ea4f");
pub const CLSID_ShellLinkObject = &CLSID_ShellLinkObject_Value;

const CLSID_ShellFolderView_Value = @import("../zig.zig").Guid.initString("62112aa1-ebe4-11cf-a5fb-0020afe7292d");
pub const CLSID_ShellFolderView = &CLSID_ShellFolderView_Value;

const CLSID_Shell_Value = @import("../zig.zig").Guid.initString("13709620-c279-11ce-a49e-444553540000");
pub const CLSID_Shell = &CLSID_Shell_Value;

const CLSID_ShellDispatchInproc_Value = @import("../zig.zig").Guid.initString("0a89a860-d7b1-11ce-8350-444553540000");
pub const CLSID_ShellDispatchInproc = &CLSID_ShellDispatchInproc_Value;

const CLSID_FileSearchBand_Value = @import("../zig.zig").Guid.initString("c4ee31f3-4768-11d2-be5c-00a0c9a83da1");
pub const CLSID_FileSearchBand = &CLSID_FileSearchBand_Value;

pub const OfflineFolderStatus = enum(i32) {
    INACTIVE = -1,
    ONLINE = 0,
    OFFLINE = 1,
    SERVERBACK = 2,
    DIRTYCACHE = 3,
};
pub const OFS_INACTIVE = OfflineFolderStatus.INACTIVE;
pub const OFS_ONLINE = OfflineFolderStatus.ONLINE;
pub const OFS_OFFLINE = OfflineFolderStatus.OFFLINE;
pub const OFS_SERVERBACK = OfflineFolderStatus.SERVERBACK;
pub const OFS_DIRTYCACHE = OfflineFolderStatus.DIRTYCACHE;

pub const ShellFolderViewOptions = enum(i32) {
    SHOWALLOBJECTS = 1,
    SHOWEXTENSIONS = 2,
    SHOWCOMPCOLOR = 8,
    SHOWSYSFILES = 32,
    WIN95CLASSIC = 64,
    DOUBLECLICKINWEBVIEW = 128,
    DESKTOPHTML = 512,
};
pub const SFVVO_SHOWALLOBJECTS = ShellFolderViewOptions.SHOWALLOBJECTS;
pub const SFVVO_SHOWEXTENSIONS = ShellFolderViewOptions.SHOWEXTENSIONS;
pub const SFVVO_SHOWCOMPCOLOR = ShellFolderViewOptions.SHOWCOMPCOLOR;
pub const SFVVO_SHOWSYSFILES = ShellFolderViewOptions.SHOWSYSFILES;
pub const SFVVO_WIN95CLASSIC = ShellFolderViewOptions.WIN95CLASSIC;
pub const SFVVO_DOUBLECLICKINWEBVIEW = ShellFolderViewOptions.DOUBLECLICKINWEBVIEW;
pub const SFVVO_DESKTOPHTML = ShellFolderViewOptions.DESKTOPHTML;

pub const ShellSpecialFolderConstants = enum(i32) {
    DESKTOP = 0,
    PROGRAMS = 2,
    CONTROLS = 3,
    PRINTERS = 4,
    PERSONAL = 5,
    FAVORITES = 6,
    STARTUP = 7,
    RECENT = 8,
    SENDTO = 9,
    BITBUCKET = 10,
    STARTMENU = 11,
    DESKTOPDIRECTORY = 16,
    DRIVES = 17,
    NETWORK = 18,
    NETHOOD = 19,
    FONTS = 20,
    TEMPLATES = 21,
    COMMONSTARTMENU = 22,
    COMMONPROGRAMS = 23,
    COMMONSTARTUP = 24,
    COMMONDESKTOPDIR = 25,
    APPDATA = 26,
    PRINTHOOD = 27,
    LOCALAPPDATA = 28,
    ALTSTARTUP = 29,
    COMMONALTSTARTUP = 30,
    COMMONFAVORITES = 31,
    INTERNETCACHE = 32,
    COOKIES = 33,
    HISTORY = 34,
    COMMONAPPDATA = 35,
    WINDOWS = 36,
    SYSTEM = 37,
    PROGRAMFILES = 38,
    MYPICTURES = 39,
    PROFILE = 40,
    SYSTEMx86 = 41,
    PROGRAMFILESx86 = 48,
};
pub const ssfDESKTOP = ShellSpecialFolderConstants.DESKTOP;
pub const ssfPROGRAMS = ShellSpecialFolderConstants.PROGRAMS;
pub const ssfCONTROLS = ShellSpecialFolderConstants.CONTROLS;
pub const ssfPRINTERS = ShellSpecialFolderConstants.PRINTERS;
pub const ssfPERSONAL = ShellSpecialFolderConstants.PERSONAL;
pub const ssfFAVORITES = ShellSpecialFolderConstants.FAVORITES;
pub const ssfSTARTUP = ShellSpecialFolderConstants.STARTUP;
pub const ssfRECENT = ShellSpecialFolderConstants.RECENT;
pub const ssfSENDTO = ShellSpecialFolderConstants.SENDTO;
pub const ssfBITBUCKET = ShellSpecialFolderConstants.BITBUCKET;
pub const ssfSTARTMENU = ShellSpecialFolderConstants.STARTMENU;
pub const ssfDESKTOPDIRECTORY = ShellSpecialFolderConstants.DESKTOPDIRECTORY;
pub const ssfDRIVES = ShellSpecialFolderConstants.DRIVES;
pub const ssfNETWORK = ShellSpecialFolderConstants.NETWORK;
pub const ssfNETHOOD = ShellSpecialFolderConstants.NETHOOD;
pub const ssfFONTS = ShellSpecialFolderConstants.FONTS;
pub const ssfTEMPLATES = ShellSpecialFolderConstants.TEMPLATES;
pub const ssfCOMMONSTARTMENU = ShellSpecialFolderConstants.COMMONSTARTMENU;
pub const ssfCOMMONPROGRAMS = ShellSpecialFolderConstants.COMMONPROGRAMS;
pub const ssfCOMMONSTARTUP = ShellSpecialFolderConstants.COMMONSTARTUP;
pub const ssfCOMMONDESKTOPDIR = ShellSpecialFolderConstants.COMMONDESKTOPDIR;
pub const ssfAPPDATA = ShellSpecialFolderConstants.APPDATA;
pub const ssfPRINTHOOD = ShellSpecialFolderConstants.PRINTHOOD;
pub const ssfLOCALAPPDATA = ShellSpecialFolderConstants.LOCALAPPDATA;
pub const ssfALTSTARTUP = ShellSpecialFolderConstants.ALTSTARTUP;
pub const ssfCOMMONALTSTARTUP = ShellSpecialFolderConstants.COMMONALTSTARTUP;
pub const ssfCOMMONFAVORITES = ShellSpecialFolderConstants.COMMONFAVORITES;
pub const ssfINTERNETCACHE = ShellSpecialFolderConstants.INTERNETCACHE;
pub const ssfCOOKIES = ShellSpecialFolderConstants.COOKIES;
pub const ssfHISTORY = ShellSpecialFolderConstants.HISTORY;
pub const ssfCOMMONAPPDATA = ShellSpecialFolderConstants.COMMONAPPDATA;
pub const ssfWINDOWS = ShellSpecialFolderConstants.WINDOWS;
pub const ssfSYSTEM = ShellSpecialFolderConstants.SYSTEM;
pub const ssfPROGRAMFILES = ShellSpecialFolderConstants.PROGRAMFILES;
pub const ssfMYPICTURES = ShellSpecialFolderConstants.MYPICTURES;
pub const ssfPROFILE = ShellSpecialFolderConstants.PROFILE;
pub const ssfSYSTEMx86 = ShellSpecialFolderConstants.SYSTEMx86;
pub const ssfPROGRAMFILESx86 = ShellSpecialFolderConstants.PROGRAMFILESx86;

const IID_IFolderViewOC_Value = @import("../zig.zig").Guid.initString("9ba05970-f6a8-11cf-a442-00a0c90a8f39");
pub const IID_IFolderViewOC = &IID_IFolderViewOC_Value;
pub const IFolderViewOC = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetFolderView: fn(
            self: *const IFolderViewOC,
            pdisp: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFolderViewOC_SetFolderView(self: *const T, pdisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFolderViewOC.VTable, self.vtable).SetFolderView(@ptrCast(*const IFolderViewOC, self), pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellFolderViewEvents_Value = @import("../zig.zig").Guid.initString("62112aa2-ebe4-11cf-a5fb-0020afe7292d");
pub const IID_DShellFolderViewEvents = &IID_DShellFolderViewEvents_Value;
pub const DShellFolderViewEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DFConstraint_Value = @import("../zig.zig").Guid.initString("4a3df050-23bd-11d2-939f-00a0c91eedba");
pub const IID_DFConstraint = &IID_DFConstraint_Value;
pub const DFConstraint = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const DFConstraint,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: fn(
            self: *const DFConstraint,
            pv: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DFConstraint_get_Name(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const DFConstraint.VTable, self.vtable).get_Name(@ptrCast(*const DFConstraint, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DFConstraint_get_Value(self: *const T, pv: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const DFConstraint.VTable, self.vtable).get_Value(@ptrCast(*const DFConstraint, self), pv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItem_Value = @import("../zig.zig").Guid.initString("fac32c80-cbe4-11ce-8350-444553540000");
pub const IID_FolderItem = &IID_FolderItem_Value;
pub const FolderItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const FolderItem,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: fn(
            self: *const FolderItem,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const FolderItem,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: fn(
            self: *const FolderItem,
            bs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const FolderItem,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GetLink: fn(
            self: *const FolderItem,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GetFolder: fn(
            self: *const FolderItem,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsLink: fn(
            self: *const FolderItem,
            pb: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFolder: fn(
            self: *const FolderItem,
            pb: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFileSystem: fn(
            self: *const FolderItem,
            pb: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBrowsable: fn(
            self: *const FolderItem,
            pb: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModifyDate: fn(
            self: *const FolderItem,
            pdt: ?*f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ModifyDate: fn(
            self: *const FolderItem,
            dt: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Size: fn(
            self: *const FolderItem,
            pul: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const FolderItem,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Verbs: fn(
            self: *const FolderItem,
            ppfic: ?*?*FolderItemVerbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeVerb: fn(
            self: *const FolderItem,
            vVerb: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_Application(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_Application(@ptrCast(*const FolderItem, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_Parent(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_Parent(@ptrCast(*const FolderItem, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_Name(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_Name(@ptrCast(*const FolderItem, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_put_Name(self: *const T, bs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).put_Name(@ptrCast(*const FolderItem, self), bs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_Path(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_Path(@ptrCast(*const FolderItem, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_GetLink(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_GetLink(@ptrCast(*const FolderItem, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_GetFolder(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_GetFolder(@ptrCast(*const FolderItem, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_IsLink(self: *const T, pb: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_IsLink(@ptrCast(*const FolderItem, self), pb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_IsFolder(self: *const T, pb: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_IsFolder(@ptrCast(*const FolderItem, self), pb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_IsFileSystem(self: *const T, pb: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_IsFileSystem(@ptrCast(*const FolderItem, self), pb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_IsBrowsable(self: *const T, pb: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_IsBrowsable(@ptrCast(*const FolderItem, self), pb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_ModifyDate(self: *const T, pdt: ?*f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_ModifyDate(@ptrCast(*const FolderItem, self), pdt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_put_ModifyDate(self: *const T, dt: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).put_ModifyDate(@ptrCast(*const FolderItem, self), dt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_Size(self: *const T, pul: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_Size(@ptrCast(*const FolderItem, self), pul);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_get_Type(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).get_Type(@ptrCast(*const FolderItem, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_Verbs(self: *const T, ppfic: ?*?*FolderItemVerbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).Verbs(@ptrCast(*const FolderItem, self), ppfic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem_InvokeVerb(self: *const T, vVerb: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem.VTable, self.vtable).InvokeVerb(@ptrCast(*const FolderItem, self), vVerb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItems_Value = @import("../zig.zig").Guid.initString("744129e0-cbe5-11ce-8350-444553540000");
pub const IID_FolderItems = &IID_FolderItems_Value;
pub const FolderItems = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const FolderItems,
            plCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const FolderItems,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: fn(
            self: *const FolderItems,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const FolderItems,
            index: VARIANT,
            ppid: ?*?*FolderItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _NewEnum: fn(
            self: *const FolderItems,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItems_get_Count(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItems.VTable, self.vtable).get_Count(@ptrCast(*const FolderItems, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItems_get_Application(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItems.VTable, self.vtable).get_Application(@ptrCast(*const FolderItems, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItems_get_Parent(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItems.VTable, self.vtable).get_Parent(@ptrCast(*const FolderItems, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItems_Item(self: *const T, index: VARIANT, ppid: ?*?*FolderItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItems.VTable, self.vtable).Item(@ptrCast(*const FolderItems, self), index, ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItems__NewEnum(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItems.VTable, self.vtable)._NewEnum(@ptrCast(*const FolderItems, self), ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItemVerb_Value = @import("../zig.zig").Guid.initString("08ec3e00-50b0-11cf-960c-0080c7f4ee85");
pub const IID_FolderItemVerb = &IID_FolderItemVerb_Value;
pub const FolderItemVerb = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const FolderItemVerb,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: fn(
            self: *const FolderItemVerb,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: fn(
            self: *const FolderItemVerb,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoIt: fn(
            self: *const FolderItemVerb,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItemVerb_get_Application(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItemVerb.VTable, self.vtable).get_Application(@ptrCast(*const FolderItemVerb, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItemVerb_get_Parent(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItemVerb.VTable, self.vtable).get_Parent(@ptrCast(*const FolderItemVerb, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItemVerb_get_Name(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItemVerb.VTable, self.vtable).get_Name(@ptrCast(*const FolderItemVerb, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItemVerb_DoIt(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItemVerb.VTable, self.vtable).DoIt(@ptrCast(*const FolderItemVerb, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItemVerbs_Value = @import("../zig.zig").Guid.initString("1f8352c0-50b0-11cf-960c-0080c7f4ee85");
pub const IID_FolderItemVerbs = &IID_FolderItemVerbs_Value;
pub const FolderItemVerbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const FolderItemVerbs,
            plCount: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const FolderItemVerbs,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: fn(
            self: *const FolderItemVerbs,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const FolderItemVerbs,
            index: VARIANT,
            ppid: ?*?*FolderItemVerb,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _NewEnum: fn(
            self: *const FolderItemVerbs,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItemVerbs_get_Count(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItemVerbs.VTable, self.vtable).get_Count(@ptrCast(*const FolderItemVerbs, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItemVerbs_get_Application(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItemVerbs.VTable, self.vtable).get_Application(@ptrCast(*const FolderItemVerbs, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItemVerbs_get_Parent(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItemVerbs.VTable, self.vtable).get_Parent(@ptrCast(*const FolderItemVerbs, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItemVerbs_Item(self: *const T, index: VARIANT, ppid: ?*?*FolderItemVerb) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItemVerbs.VTable, self.vtable).Item(@ptrCast(*const FolderItemVerbs, self), index, ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItemVerbs__NewEnum(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItemVerbs.VTable, self.vtable)._NewEnum(@ptrCast(*const FolderItemVerbs, self), ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Folder_Value = @import("../zig.zig").Guid.initString("bbcbde60-c3ff-11ce-8350-444553540000");
pub const IID_Folder = &IID_Folder_Value;
pub const Folder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: fn(
            self: *const Folder,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const Folder,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: fn(
            self: *const Folder,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentFolder: fn(
            self: *const Folder,
            ppsf: ?*?*Folder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Items: fn(
            self: *const Folder,
            ppid: ?*?*FolderItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseName: fn(
            self: *const Folder,
            bName: ?BSTR,
            ppid: ?*?*FolderItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewFolder: fn(
            self: *const Folder,
            bName: ?BSTR,
            vOptions: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveHere: fn(
            self: *const Folder,
            vItem: VARIANT,
            vOptions: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyHere: fn(
            self: *const Folder,
            vItem: VARIANT,
            vOptions: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDetailsOf: fn(
            self: *const Folder,
            vItem: VARIANT,
            iColumn: i32,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_get_Title(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).get_Title(@ptrCast(*const Folder, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_get_Application(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).get_Application(@ptrCast(*const Folder, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_get_Parent(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).get_Parent(@ptrCast(*const Folder, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_get_ParentFolder(self: *const T, ppsf: ?*?*Folder) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).get_ParentFolder(@ptrCast(*const Folder, self), ppsf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_Items(self: *const T, ppid: ?*?*FolderItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).Items(@ptrCast(*const Folder, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_ParseName(self: *const T, bName: ?BSTR, ppid: ?*?*FolderItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).ParseName(@ptrCast(*const Folder, self), bName, ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_NewFolder(self: *const T, bName: ?BSTR, vOptions: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).NewFolder(@ptrCast(*const Folder, self), bName, vOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_MoveHere(self: *const T, vItem: VARIANT, vOptions: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).MoveHere(@ptrCast(*const Folder, self), vItem, vOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_CopyHere(self: *const T, vItem: VARIANT, vOptions: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).CopyHere(@ptrCast(*const Folder, self), vItem, vOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder_GetDetailsOf(self: *const T, vItem: VARIANT, iColumn: i32, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder.VTable, self.vtable).GetDetailsOf(@ptrCast(*const Folder, self), vItem, iColumn, pbs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Folder2_Value = @import("../zig.zig").Guid.initString("f0d2d8ef-3890-11d2-bf8b-00c04fb93661");
pub const IID_Folder2 = &IID_Folder2_Value;
pub const Folder2 = extern struct {
    pub const VTable = extern struct {
        base: Folder.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Self: fn(
            self: *const Folder2,
            ppfi: ?*?*FolderItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OfflineStatus: fn(
            self: *const Folder2,
            pul: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Synchronize: fn(
            self: *const Folder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HaveToShowWebViewBarricade: fn(
            self: *const Folder2,
            pbHaveToShowWebViewBarricade: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DismissedWebViewBarricade: fn(
            self: *const Folder2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace Folder.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder2_get_Self(self: *const T, ppfi: ?*?*FolderItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder2.VTable, self.vtable).get_Self(@ptrCast(*const Folder2, self), ppfi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder2_get_OfflineStatus(self: *const T, pul: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder2.VTable, self.vtable).get_OfflineStatus(@ptrCast(*const Folder2, self), pul);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder2_Synchronize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder2.VTable, self.vtable).Synchronize(@ptrCast(*const Folder2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder2_get_HaveToShowWebViewBarricade(self: *const T, pbHaveToShowWebViewBarricade: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder2.VTable, self.vtable).get_HaveToShowWebViewBarricade(@ptrCast(*const Folder2, self), pbHaveToShowWebViewBarricade);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder2_DismissedWebViewBarricade(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder2.VTable, self.vtable).DismissedWebViewBarricade(@ptrCast(*const Folder2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Folder3_Value = @import("../zig.zig").Guid.initString("a7ae5f64-c4d7-4d7f-9307-4d24ee54b841");
pub const IID_Folder3 = &IID_Folder3_Value;
pub const Folder3 = extern struct {
    pub const VTable = extern struct {
        base: Folder2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ShowWebViewBarricade: fn(
            self: *const Folder3,
            pbShowWebViewBarricade: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ShowWebViewBarricade: fn(
            self: *const Folder3,
            bShowWebViewBarricade: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace Folder2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder3_get_ShowWebViewBarricade(self: *const T, pbShowWebViewBarricade: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder3.VTable, self.vtable).get_ShowWebViewBarricade(@ptrCast(*const Folder3, self), pbShowWebViewBarricade);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Folder3_put_ShowWebViewBarricade(self: *const T, bShowWebViewBarricade: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Folder3.VTable, self.vtable).put_ShowWebViewBarricade(@ptrCast(*const Folder3, self), bShowWebViewBarricade);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItem2_Value = @import("../zig.zig").Guid.initString("edc817aa-92b8-11d1-b075-00c04fc33aa5");
pub const IID_FolderItem2 = &IID_FolderItem2_Value;
pub const FolderItem2 = extern struct {
    pub const VTable = extern struct {
        base: FolderItem.VTable,
        InvokeVerbEx: fn(
            self: *const FolderItem2,
            vVerb: VARIANT,
            vArgs: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExtendedProperty: fn(
            self: *const FolderItem2,
            bstrPropName: ?BSTR,
            pvRet: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace FolderItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem2_InvokeVerbEx(self: *const T, vVerb: VARIANT, vArgs: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem2.VTable, self.vtable).InvokeVerbEx(@ptrCast(*const FolderItem2, self), vVerb, vArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItem2_ExtendedProperty(self: *const T, bstrPropName: ?BSTR, pvRet: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItem2.VTable, self.vtable).ExtendedProperty(@ptrCast(*const FolderItem2, self), bstrPropName, pvRet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItems2_Value = @import("../zig.zig").Guid.initString("c94f0ad0-f363-11d2-a327-00c04f8eec7f");
pub const IID_FolderItems2 = &IID_FolderItems2_Value;
pub const FolderItems2 = extern struct {
    pub const VTable = extern struct {
        base: FolderItems.VTable,
        InvokeVerbEx: fn(
            self: *const FolderItems2,
            vVerb: VARIANT,
            vArgs: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace FolderItems.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItems2_InvokeVerbEx(self: *const T, vVerb: VARIANT, vArgs: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItems2.VTable, self.vtable).InvokeVerbEx(@ptrCast(*const FolderItems2, self), vVerb, vArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_FolderItems3_Value = @import("../zig.zig").Guid.initString("eaa7c309-bbec-49d5-821d-64d966cb667f");
pub const IID_FolderItems3 = &IID_FolderItems3_Value;
pub const FolderItems3 = extern struct {
    pub const VTable = extern struct {
        base: FolderItems2.VTable,
        Filter: fn(
            self: *const FolderItems3,
            grfFlags: i32,
            bstrFileSpec: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Verbs: fn(
            self: *const FolderItems3,
            ppfic: ?*?*FolderItemVerbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace FolderItems2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItems3_Filter(self: *const T, grfFlags: i32, bstrFileSpec: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItems3.VTable, self.vtable).Filter(@ptrCast(*const FolderItems3, self), grfFlags, bstrFileSpec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn FolderItems3_get_Verbs(self: *const T, ppfic: ?*?*FolderItemVerbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const FolderItems3.VTable, self.vtable).get_Verbs(@ptrCast(*const FolderItems3, self), ppfic);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellLinkDual_Value = @import("../zig.zig").Guid.initString("88a05c00-f000-11ce-8350-444553540000");
pub const IID_IShellLinkDual = &IID_IShellLinkDual_Value;
pub const IShellLinkDual = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IShellLinkDual,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Path: fn(
            self: *const IShellLinkDual,
            bs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: fn(
            self: *const IShellLinkDual,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: fn(
            self: *const IShellLinkDual,
            bs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WorkingDirectory: fn(
            self: *const IShellLinkDual,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WorkingDirectory: fn(
            self: *const IShellLinkDual,
            bs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Arguments: fn(
            self: *const IShellLinkDual,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Arguments: fn(
            self: *const IShellLinkDual,
            bs: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hotkey: fn(
            self: *const IShellLinkDual,
            piHK: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Hotkey: fn(
            self: *const IShellLinkDual,
            iHK: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ShowCommand: fn(
            self: *const IShellLinkDual,
            piShowCommand: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ShowCommand: fn(
            self: *const IShellLinkDual,
            iShowCommand: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resolve: fn(
            self: *const IShellLinkDual,
            fFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconLocation: fn(
            self: *const IShellLinkDual,
            pbs: ?*?BSTR,
            piIcon: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconLocation: fn(
            self: *const IShellLinkDual,
            bs: ?BSTR,
            iIcon: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const IShellLinkDual,
            vWhere: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_get_Path(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).get_Path(@ptrCast(*const IShellLinkDual, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_put_Path(self: *const T, bs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).put_Path(@ptrCast(*const IShellLinkDual, self), bs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_get_Description(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).get_Description(@ptrCast(*const IShellLinkDual, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_put_Description(self: *const T, bs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).put_Description(@ptrCast(*const IShellLinkDual, self), bs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_get_WorkingDirectory(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).get_WorkingDirectory(@ptrCast(*const IShellLinkDual, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_put_WorkingDirectory(self: *const T, bs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).put_WorkingDirectory(@ptrCast(*const IShellLinkDual, self), bs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_get_Arguments(self: *const T, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).get_Arguments(@ptrCast(*const IShellLinkDual, self), pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_put_Arguments(self: *const T, bs: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).put_Arguments(@ptrCast(*const IShellLinkDual, self), bs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_get_Hotkey(self: *const T, piHK: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).get_Hotkey(@ptrCast(*const IShellLinkDual, self), piHK);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_put_Hotkey(self: *const T, iHK: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).put_Hotkey(@ptrCast(*const IShellLinkDual, self), iHK);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_get_ShowCommand(self: *const T, piShowCommand: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).get_ShowCommand(@ptrCast(*const IShellLinkDual, self), piShowCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_put_ShowCommand(self: *const T, iShowCommand: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).put_ShowCommand(@ptrCast(*const IShellLinkDual, self), iShowCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_Resolve(self: *const T, fFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).Resolve(@ptrCast(*const IShellLinkDual, self), fFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_GetIconLocation(self: *const T, pbs: ?*?BSTR, piIcon: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).GetIconLocation(@ptrCast(*const IShellLinkDual, self), pbs, piIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_SetIconLocation(self: *const T, bs: ?BSTR, iIcon: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).SetIconLocation(@ptrCast(*const IShellLinkDual, self), bs, iIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual_Save(self: *const T, vWhere: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual.VTable, self.vtable).Save(@ptrCast(*const IShellLinkDual, self), vWhere);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellLinkDual2_Value = @import("../zig.zig").Guid.initString("317ee249-f12e-11d2-b1e4-00c04f8eeb3e");
pub const IID_IShellLinkDual2 = &IID_IShellLinkDual2_Value;
pub const IShellLinkDual2 = extern struct {
    pub const VTable = extern struct {
        base: IShellLinkDual.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Target: fn(
            self: *const IShellLinkDual2,
            ppfi: ?*?*FolderItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellLinkDual.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellLinkDual2_get_Target(self: *const T, ppfi: ?*?*FolderItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellLinkDual2.VTable, self.vtable).get_Target(@ptrCast(*const IShellLinkDual2, self), ppfi);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolderViewDual_Value = @import("../zig.zig").Guid.initString("e7a1af80-4d96-11cf-960c-0080c7f4ee85");
pub const IID_IShellFolderViewDual = &IID_IShellFolderViewDual_Value;
pub const IShellFolderViewDual = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const IShellFolderViewDual,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: fn(
            self: *const IShellFolderViewDual,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Folder: fn(
            self: *const IShellFolderViewDual,
            ppid: ?*?*Folder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectedItems: fn(
            self: *const IShellFolderViewDual,
            ppid: ?*?*FolderItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FocusedItem: fn(
            self: *const IShellFolderViewDual,
            ppid: ?*?*FolderItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectItem: fn(
            self: *const IShellFolderViewDual,
            pvfi: ?*VARIANT,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PopupItemMenu: fn(
            self: *const IShellFolderViewDual,
            pfi: ?*FolderItem,
            vx: VARIANT,
            vy: VARIANT,
            pbs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Script: fn(
            self: *const IShellFolderViewDual,
            ppDisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ViewOptions: fn(
            self: *const IShellFolderViewDual,
            plViewOptions: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual_get_Application(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual.VTable, self.vtable).get_Application(@ptrCast(*const IShellFolderViewDual, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual_get_Parent(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual.VTable, self.vtable).get_Parent(@ptrCast(*const IShellFolderViewDual, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual_get_Folder(self: *const T, ppid: ?*?*Folder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual.VTable, self.vtable).get_Folder(@ptrCast(*const IShellFolderViewDual, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual_SelectedItems(self: *const T, ppid: ?*?*FolderItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual.VTable, self.vtable).SelectedItems(@ptrCast(*const IShellFolderViewDual, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual_get_FocusedItem(self: *const T, ppid: ?*?*FolderItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual.VTable, self.vtable).get_FocusedItem(@ptrCast(*const IShellFolderViewDual, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual_SelectItem(self: *const T, pvfi: ?*VARIANT, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual.VTable, self.vtable).SelectItem(@ptrCast(*const IShellFolderViewDual, self), pvfi, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual_PopupItemMenu(self: *const T, pfi: ?*FolderItem, vx: VARIANT, vy: VARIANT, pbs: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual.VTable, self.vtable).PopupItemMenu(@ptrCast(*const IShellFolderViewDual, self), pfi, vx, vy, pbs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual_get_Script(self: *const T, ppDisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual.VTable, self.vtable).get_Script(@ptrCast(*const IShellFolderViewDual, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual_get_ViewOptions(self: *const T, plViewOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual.VTable, self.vtable).get_ViewOptions(@ptrCast(*const IShellFolderViewDual, self), plViewOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolderViewDual2_Value = @import("../zig.zig").Guid.initString("31c147b6-0ade-4a3c-b514-ddf932ef6d17");
pub const IID_IShellFolderViewDual2 = &IID_IShellFolderViewDual2_Value;
pub const IShellFolderViewDual2 = extern struct {
    pub const VTable = extern struct {
        base: IShellFolderViewDual.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentViewMode: fn(
            self: *const IShellFolderViewDual2,
            pViewMode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentViewMode: fn(
            self: *const IShellFolderViewDual2,
            ViewMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectItemRelative: fn(
            self: *const IShellFolderViewDual2,
            iRelative: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellFolderViewDual.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual2_get_CurrentViewMode(self: *const T, pViewMode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual2.VTable, self.vtable).get_CurrentViewMode(@ptrCast(*const IShellFolderViewDual2, self), pViewMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual2_put_CurrentViewMode(self: *const T, ViewMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual2.VTable, self.vtable).put_CurrentViewMode(@ptrCast(*const IShellFolderViewDual2, self), ViewMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual2_SelectItemRelative(self: *const T, iRelative: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual2.VTable, self.vtable).SelectItemRelative(@ptrCast(*const IShellFolderViewDual2, self), iRelative);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IShellFolderViewDual3_Value = @import("../zig.zig").Guid.initString("29ec8e6c-46d3-411f-baaa-611a6c9cac66");
pub const IID_IShellFolderViewDual3 = &IID_IShellFolderViewDual3_Value;
pub const IShellFolderViewDual3 = extern struct {
    pub const VTable = extern struct {
        base: IShellFolderViewDual2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GroupBy: fn(
            self: *const IShellFolderViewDual3,
            pbstrGroupBy: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GroupBy: fn(
            self: *const IShellFolderViewDual3,
            bstrGroupBy: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FolderFlags: fn(
            self: *const IShellFolderViewDual3,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FolderFlags: fn(
            self: *const IShellFolderViewDual3,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SortColumns: fn(
            self: *const IShellFolderViewDual3,
            pbstrSortColumns: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SortColumns: fn(
            self: *const IShellFolderViewDual3,
            bstrSortColumns: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IconSize: fn(
            self: *const IShellFolderViewDual3,
            iIconSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IconSize: fn(
            self: *const IShellFolderViewDual3,
            piIconSize: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FilterView: fn(
            self: *const IShellFolderViewDual3,
            bstrFilterText: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellFolderViewDual2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual3_get_GroupBy(self: *const T, pbstrGroupBy: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual3.VTable, self.vtable).get_GroupBy(@ptrCast(*const IShellFolderViewDual3, self), pbstrGroupBy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual3_put_GroupBy(self: *const T, bstrGroupBy: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual3.VTable, self.vtable).put_GroupBy(@ptrCast(*const IShellFolderViewDual3, self), bstrGroupBy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual3_get_FolderFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual3.VTable, self.vtable).get_FolderFlags(@ptrCast(*const IShellFolderViewDual3, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual3_put_FolderFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual3.VTable, self.vtable).put_FolderFlags(@ptrCast(*const IShellFolderViewDual3, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual3_get_SortColumns(self: *const T, pbstrSortColumns: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual3.VTable, self.vtable).get_SortColumns(@ptrCast(*const IShellFolderViewDual3, self), pbstrSortColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual3_put_SortColumns(self: *const T, bstrSortColumns: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual3.VTable, self.vtable).put_SortColumns(@ptrCast(*const IShellFolderViewDual3, self), bstrSortColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual3_put_IconSize(self: *const T, iIconSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual3.VTable, self.vtable).put_IconSize(@ptrCast(*const IShellFolderViewDual3, self), iIconSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual3_get_IconSize(self: *const T, piIconSize: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual3.VTable, self.vtable).get_IconSize(@ptrCast(*const IShellFolderViewDual3, self), piIconSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewDual3_FilterView(self: *const T, bstrFilterText: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewDual3.VTable, self.vtable).FilterView(@ptrCast(*const IShellFolderViewDual3, self), bstrFilterText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch_Value = @import("../zig.zig").Guid.initString("d8f015c0-c278-11ce-a49e-444553540000");
pub const IID_IShellDispatch = &IID_IShellDispatch_Value;
pub const IShellDispatch = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: fn(
            self: *const IShellDispatch,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: fn(
            self: *const IShellDispatch,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NameSpace: fn(
            self: *const IShellDispatch,
            vDir: VARIANT,
            ppsdf: ?*?*Folder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BrowseForFolder: fn(
            self: *const IShellDispatch,
            Hwnd: i32,
            Title: ?BSTR,
            Options: i32,
            RootFolder: VARIANT,
            ppsdf: ?*?*Folder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Windows: fn(
            self: *const IShellDispatch,
            ppid: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: fn(
            self: *const IShellDispatch,
            vDir: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Explore: fn(
            self: *const IShellDispatch,
            vDir: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MinimizeAll: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UndoMinimizeALL: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FileRun: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CascadeWindows: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TileVertically: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TileHorizontally: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShutdownWindows: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EjectPC: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTime: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TrayProperties: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Help: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindFiles: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindComputer: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RefreshMenu: fn(
            self: *const IShellDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlPanelItem: fn(
            self: *const IShellDispatch,
            bstrDir: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_get_Application(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).get_Application(@ptrCast(*const IShellDispatch, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_get_Parent(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).get_Parent(@ptrCast(*const IShellDispatch, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_NameSpace(self: *const T, vDir: VARIANT, ppsdf: ?*?*Folder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).NameSpace(@ptrCast(*const IShellDispatch, self), vDir, ppsdf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_BrowseForFolder(self: *const T, Hwnd: i32, Title: ?BSTR, Options: i32, RootFolder: VARIANT, ppsdf: ?*?*Folder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).BrowseForFolder(@ptrCast(*const IShellDispatch, self), Hwnd, Title, Options, RootFolder, ppsdf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_Windows(self: *const T, ppid: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).Windows(@ptrCast(*const IShellDispatch, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_Open(self: *const T, vDir: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).Open(@ptrCast(*const IShellDispatch, self), vDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_Explore(self: *const T, vDir: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).Explore(@ptrCast(*const IShellDispatch, self), vDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_MinimizeAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).MinimizeAll(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_UndoMinimizeALL(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).UndoMinimizeALL(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_FileRun(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).FileRun(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_CascadeWindows(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).CascadeWindows(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_TileVertically(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).TileVertically(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_TileHorizontally(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).TileHorizontally(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_ShutdownWindows(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).ShutdownWindows(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_Suspend(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).Suspend(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_EjectPC(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).EjectPC(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_SetTime(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).SetTime(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_TrayProperties(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).TrayProperties(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_Help(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).Help(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_FindFiles(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).FindFiles(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_FindComputer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).FindComputer(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_RefreshMenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).RefreshMenu(@ptrCast(*const IShellDispatch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch_ControlPanelItem(self: *const T, bstrDir: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch.VTable, self.vtable).ControlPanelItem(@ptrCast(*const IShellDispatch, self), bstrDir);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch2_Value = @import("../zig.zig").Guid.initString("a4c6892c-3ba9-11d2-9dea-00c04fb16162");
pub const IID_IShellDispatch2 = &IID_IShellDispatch2_Value;
pub const IShellDispatch2 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch.VTable,
        IsRestricted: fn(
            self: *const IShellDispatch2,
            Group: ?BSTR,
            Restriction: ?BSTR,
            plRestrictValue: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShellExecute: fn(
            self: *const IShellDispatch2,
            File: ?BSTR,
            vArgs: VARIANT,
            vDir: VARIANT,
            vOperation: VARIANT,
            vShow: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindPrinter: fn(
            self: *const IShellDispatch2,
            name: ?BSTR,
            location: ?BSTR,
            model: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemInformation: fn(
            self: *const IShellDispatch2,
            name: ?BSTR,
            pv: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ServiceStart: fn(
            self: *const IShellDispatch2,
            ServiceName: ?BSTR,
            Persistent: VARIANT,
            pSuccess: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ServiceStop: fn(
            self: *const IShellDispatch2,
            ServiceName: ?BSTR,
            Persistent: VARIANT,
            pSuccess: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsServiceRunning: fn(
            self: *const IShellDispatch2,
            ServiceName: ?BSTR,
            pRunning: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanStartStopService: fn(
            self: *const IShellDispatch2,
            ServiceName: ?BSTR,
            pCanStartStop: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowBrowserBar: fn(
            self: *const IShellDispatch2,
            bstrClsid: ?BSTR,
            bShow: VARIANT,
            pSuccess: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch2_IsRestricted(self: *const T, Group: ?BSTR, Restriction: ?BSTR, plRestrictValue: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch2.VTable, self.vtable).IsRestricted(@ptrCast(*const IShellDispatch2, self), Group, Restriction, plRestrictValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch2_ShellExecute(self: *const T, File: ?BSTR, vArgs: VARIANT, vDir: VARIANT, vOperation: VARIANT, vShow: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch2.VTable, self.vtable).ShellExecute(@ptrCast(*const IShellDispatch2, self), File, vArgs, vDir, vOperation, vShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch2_FindPrinter(self: *const T, name: ?BSTR, location: ?BSTR, model: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch2.VTable, self.vtable).FindPrinter(@ptrCast(*const IShellDispatch2, self), name, location, model);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch2_GetSystemInformation(self: *const T, name: ?BSTR, pv: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch2.VTable, self.vtable).GetSystemInformation(@ptrCast(*const IShellDispatch2, self), name, pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch2_ServiceStart(self: *const T, ServiceName: ?BSTR, Persistent: VARIANT, pSuccess: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch2.VTable, self.vtable).ServiceStart(@ptrCast(*const IShellDispatch2, self), ServiceName, Persistent, pSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch2_ServiceStop(self: *const T, ServiceName: ?BSTR, Persistent: VARIANT, pSuccess: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch2.VTable, self.vtable).ServiceStop(@ptrCast(*const IShellDispatch2, self), ServiceName, Persistent, pSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch2_IsServiceRunning(self: *const T, ServiceName: ?BSTR, pRunning: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch2.VTable, self.vtable).IsServiceRunning(@ptrCast(*const IShellDispatch2, self), ServiceName, pRunning);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch2_CanStartStopService(self: *const T, ServiceName: ?BSTR, pCanStartStop: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch2.VTable, self.vtable).CanStartStopService(@ptrCast(*const IShellDispatch2, self), ServiceName, pCanStartStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch2_ShowBrowserBar(self: *const T, bstrClsid: ?BSTR, bShow: VARIANT, pSuccess: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch2.VTable, self.vtable).ShowBrowserBar(@ptrCast(*const IShellDispatch2, self), bstrClsid, bShow, pSuccess);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch3_Value = @import("../zig.zig").Guid.initString("177160ca-bb5a-411c-841d-bd38facdeaa0");
pub const IID_IShellDispatch3 = &IID_IShellDispatch3_Value;
pub const IShellDispatch3 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch2.VTable,
        AddToRecent: fn(
            self: *const IShellDispatch3,
            varFile: VARIANT,
            bstrCategory: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellDispatch2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch3_AddToRecent(self: *const T, varFile: VARIANT, bstrCategory: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch3.VTable, self.vtable).AddToRecent(@ptrCast(*const IShellDispatch3, self), varFile, bstrCategory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch4_Value = @import("../zig.zig").Guid.initString("efd84b2d-4bcf-4298-be25-eb542a59fbda");
pub const IID_IShellDispatch4 = &IID_IShellDispatch4_Value;
pub const IShellDispatch4 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch3.VTable,
        WindowsSecurity: fn(
            self: *const IShellDispatch4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ToggleDesktop: fn(
            self: *const IShellDispatch4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExplorerPolicy: fn(
            self: *const IShellDispatch4,
            bstrPolicyName: ?BSTR,
            pValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSetting: fn(
            self: *const IShellDispatch4,
            lSetting: i32,
            pResult: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellDispatch3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch4_WindowsSecurity(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch4.VTable, self.vtable).WindowsSecurity(@ptrCast(*const IShellDispatch4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch4_ToggleDesktop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch4.VTable, self.vtable).ToggleDesktop(@ptrCast(*const IShellDispatch4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch4_ExplorerPolicy(self: *const T, bstrPolicyName: ?BSTR, pValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch4.VTable, self.vtable).ExplorerPolicy(@ptrCast(*const IShellDispatch4, self), bstrPolicyName, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch4_GetSetting(self: *const T, lSetting: i32, pResult: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch4.VTable, self.vtable).GetSetting(@ptrCast(*const IShellDispatch4, self), lSetting, pResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch5_Value = @import("../zig.zig").Guid.initString("866738b9-6cf2-4de8-8767-f794ebe74f4e");
pub const IID_IShellDispatch5 = &IID_IShellDispatch5_Value;
pub const IShellDispatch5 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch4.VTable,
        WindowSwitcher: fn(
            self: *const IShellDispatch5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellDispatch4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch5_WindowSwitcher(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch5.VTable, self.vtable).WindowSwitcher(@ptrCast(*const IShellDispatch5, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellDispatch6_Value = @import("../zig.zig").Guid.initString("286e6f1b-7113-4355-9562-96b7e9d64c54");
pub const IID_IShellDispatch6 = &IID_IShellDispatch6_Value;
pub const IShellDispatch6 = extern struct {
    pub const VTable = extern struct {
        base: IShellDispatch5.VTable,
        SearchCommand: fn(
            self: *const IShellDispatch6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellDispatch5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDispatch6_SearchCommand(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDispatch6.VTable, self.vtable).SearchCommand(@ptrCast(*const IShellDispatch6, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFileSearchBand_Value = @import("../zig.zig").Guid.initString("2d91eea1-9932-11d2-be86-00a0c9a83da1");
pub const IID_IFileSearchBand = &IID_IFileSearchBand_Value;
pub const IFileSearchBand = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetFocus: fn(
            self: *const IFileSearchBand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSearchParameters: fn(
            self: *const IFileSearchBand,
            pbstrSearchID: ?*?BSTR,
            bNavToResults: i16,
            pvarScope: ?*VARIANT,
            pvarQueryFile: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SearchID: fn(
            self: *const IFileSearchBand,
            pbstrSearchID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Scope: fn(
            self: *const IFileSearchBand,
            pvarScope: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_QueryFile: fn(
            self: *const IFileSearchBand,
            pvarFile: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSearchBand_SetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSearchBand.VTable, self.vtable).SetFocus(@ptrCast(*const IFileSearchBand, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSearchBand_SetSearchParameters(self: *const T, pbstrSearchID: ?*?BSTR, bNavToResults: i16, pvarScope: ?*VARIANT, pvarQueryFile: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSearchBand.VTable, self.vtable).SetSearchParameters(@ptrCast(*const IFileSearchBand, self), pbstrSearchID, bNavToResults, pvarScope, pvarQueryFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSearchBand_get_SearchID(self: *const T, pbstrSearchID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSearchBand.VTable, self.vtable).get_SearchID(@ptrCast(*const IFileSearchBand, self), pbstrSearchID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSearchBand_get_Scope(self: *const T, pvarScope: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSearchBand.VTable, self.vtable).get_Scope(@ptrCast(*const IFileSearchBand, self), pvarScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSearchBand_get_QueryFile(self: *const T, pvarFile: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileSearchBand.VTable, self.vtable).get_QueryFile(@ptrCast(*const IFileSearchBand, self), pvarFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebWizardHost_Value = @import("../zig.zig").Guid.initString("18bcc359-4990-4bfb-b951-3c83702be5f9");
pub const IID_IWebWizardHost = &IID_IWebWizardHost_Value;
pub const IWebWizardHost = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        FinalBack: fn(
            self: *const IWebWizardHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FinalNext: fn(
            self: *const IWebWizardHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IWebWizardHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Caption: fn(
            self: *const IWebWizardHost,
            bstrCaption: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Caption: fn(
            self: *const IWebWizardHost,
            pbstrCaption: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Property: fn(
            self: *const IWebWizardHost,
            bstrPropertyName: ?BSTR,
            pvProperty: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Property: fn(
            self: *const IWebWizardHost,
            bstrPropertyName: ?BSTR,
            pvProperty: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWizardButtons: fn(
            self: *const IWebWizardHost,
            vfEnableBack: i16,
            vfEnableNext: i16,
            vfLastPage: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeaderText: fn(
            self: *const IWebWizardHost,
            bstrHeaderTitle: ?BSTR,
            bstrHeaderSubtitle: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost_FinalBack(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost.VTable, self.vtable).FinalBack(@ptrCast(*const IWebWizardHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost_FinalNext(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost.VTable, self.vtable).FinalNext(@ptrCast(*const IWebWizardHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost.VTable, self.vtable).Cancel(@ptrCast(*const IWebWizardHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost_put_Caption(self: *const T, bstrCaption: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost.VTable, self.vtable).put_Caption(@ptrCast(*const IWebWizardHost, self), bstrCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost_get_Caption(self: *const T, pbstrCaption: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost.VTable, self.vtable).get_Caption(@ptrCast(*const IWebWizardHost, self), pbstrCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost_put_Property(self: *const T, bstrPropertyName: ?BSTR, pvProperty: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost.VTable, self.vtable).put_Property(@ptrCast(*const IWebWizardHost, self), bstrPropertyName, pvProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost_get_Property(self: *const T, bstrPropertyName: ?BSTR, pvProperty: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost.VTable, self.vtable).get_Property(@ptrCast(*const IWebWizardHost, self), bstrPropertyName, pvProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost_SetWizardButtons(self: *const T, vfEnableBack: i16, vfEnableNext: i16, vfLastPage: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost.VTable, self.vtable).SetWizardButtons(@ptrCast(*const IWebWizardHost, self), vfEnableBack, vfEnableNext, vfLastPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost_SetHeaderText(self: *const T, bstrHeaderTitle: ?BSTR, bstrHeaderSubtitle: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost.VTable, self.vtable).SetHeaderText(@ptrCast(*const IWebWizardHost, self), bstrHeaderTitle, bstrHeaderSubtitle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebWizardHost2_Value = @import("../zig.zig").Guid.initString("f9c013dc-3c23-4041-8e39-cfb402f7ea59");
pub const IID_IWebWizardHost2 = &IID_IWebWizardHost2_Value;
pub const IWebWizardHost2 = extern struct {
    pub const VTable = extern struct {
        base: IWebWizardHost.VTable,
        SignString: fn(
            self: *const IWebWizardHost2,
            value: ?BSTR,
            signedValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWebWizardHost.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebWizardHost2_SignString(self: *const T, value: ?BSTR, signedValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebWizardHost2.VTable, self.vtable).SignString(@ptrCast(*const IWebWizardHost2, self), value, signedValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_INewWDEvents_Value = @import("../zig.zig").Guid.initString("0751c551-7568-41c9-8e5b-e22e38919236");
pub const IID_INewWDEvents = &IID_INewWDEvents_Value;
pub const INewWDEvents = extern struct {
    pub const VTable = extern struct {
        base: IWebWizardHost.VTable,
        PassportAuthenticate: fn(
            self: *const INewWDEvents,
            bstrSignInUrl: ?BSTR,
            pvfAuthenitcated: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWebWizardHost.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewWDEvents_PassportAuthenticate(self: *const T, bstrSignInUrl: ?BSTR, pvfAuthenitcated: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewWDEvents.VTable, self.vtable).PassportAuthenticate(@ptrCast(*const INewWDEvents, self), bstrSignInUrl, pvfAuthenitcated);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAutoComplete_Value = @import("../zig.zig").Guid.initString("00bb2762-6a77-11d0-a535-00c04fd7d062");
pub const IID_IAutoComplete = &IID_IAutoComplete_Value;
pub const IAutoComplete = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IAutoComplete,
            hwndEdit: ?HWND,
            punkACL: ?*IUnknown,
            pwszRegKeyPath: ?[*:0]const u16,
            pwszQuickComplete: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const IAutoComplete,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutoComplete_Init(self: *const T, hwndEdit: ?HWND, punkACL: ?*IUnknown, pwszRegKeyPath: ?[*:0]const u16, pwszQuickComplete: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAutoComplete.VTable, self.vtable).Init(@ptrCast(*const IAutoComplete, self), hwndEdit, punkACL, pwszRegKeyPath, pwszQuickComplete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutoComplete_Enable(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAutoComplete.VTable, self.vtable).Enable(@ptrCast(*const IAutoComplete, self), fEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AUTOCOMPLETEOPTIONS = enum(i32) {
    NONE = 0,
    AUTOSUGGEST = 1,
    AUTOAPPEND = 2,
    SEARCH = 4,
    FILTERPREFIXES = 8,
    USETAB = 16,
    UPDOWNKEYDROPSLIST = 32,
    RTLREADING = 64,
    WORD_FILTER = 128,
    NOPREFIXFILTERING = 256,
};
pub const ACO_NONE = AUTOCOMPLETEOPTIONS.NONE;
pub const ACO_AUTOSUGGEST = AUTOCOMPLETEOPTIONS.AUTOSUGGEST;
pub const ACO_AUTOAPPEND = AUTOCOMPLETEOPTIONS.AUTOAPPEND;
pub const ACO_SEARCH = AUTOCOMPLETEOPTIONS.SEARCH;
pub const ACO_FILTERPREFIXES = AUTOCOMPLETEOPTIONS.FILTERPREFIXES;
pub const ACO_USETAB = AUTOCOMPLETEOPTIONS.USETAB;
pub const ACO_UPDOWNKEYDROPSLIST = AUTOCOMPLETEOPTIONS.UPDOWNKEYDROPSLIST;
pub const ACO_RTLREADING = AUTOCOMPLETEOPTIONS.RTLREADING;
pub const ACO_WORD_FILTER = AUTOCOMPLETEOPTIONS.WORD_FILTER;
pub const ACO_NOPREFIXFILTERING = AUTOCOMPLETEOPTIONS.NOPREFIXFILTERING;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAutoComplete2_Value = @import("../zig.zig").Guid.initString("eac04bc0-3791-11d2-bb95-0060977b464c");
pub const IID_IAutoComplete2 = &IID_IAutoComplete2_Value;
pub const IAutoComplete2 = extern struct {
    pub const VTable = extern struct {
        base: IAutoComplete.VTable,
        SetOptions: fn(
            self: *const IAutoComplete2,
            dwFlag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptions: fn(
            self: *const IAutoComplete2,
            pdwFlag: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAutoComplete.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutoComplete2_SetOptions(self: *const T, dwFlag: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAutoComplete2.VTable, self.vtable).SetOptions(@ptrCast(*const IAutoComplete2, self), dwFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAutoComplete2_GetOptions(self: *const T, pdwFlag: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAutoComplete2.VTable, self.vtable).GetOptions(@ptrCast(*const IAutoComplete2, self), pdwFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ACENUMOPTION = enum(i32) {
    NONE = 0,
    MOSTRECENTFIRST = 1,
    FIRSTUNUSED = 65536,
};
pub const ACEO_NONE = ACENUMOPTION.NONE;
pub const ACEO_MOSTRECENTFIRST = ACENUMOPTION.MOSTRECENTFIRST;
pub const ACEO_FIRSTUNUSED = ACENUMOPTION.FIRSTUNUSED;

const IID_IEnumACString_Value = @import("../zig.zig").Guid.initString("8e74c210-cf9d-4eaf-a403-7356428f0a5a");
pub const IID_IEnumACString = &IID_IEnumACString_Value;
pub const IEnumACString = extern struct {
    pub const VTable = extern struct {
        base: IEnumString.VTable,
        NextItem: fn(
            self: *const IEnumACString,
            pszUrl: ?[*:0]u16,
            cchMax: u32,
            pulSortIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnumOptions: fn(
            self: *const IEnumACString,
            dwOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnumOptions: fn(
            self: *const IEnumACString,
            pdwOptions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEnumString.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumACString_NextItem(self: *const T, pszUrl: ?[*:0]u16, cchMax: u32, pulSortIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumACString.VTable, self.vtable).NextItem(@ptrCast(*const IEnumACString, self), pszUrl, cchMax, pulSortIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumACString_SetEnumOptions(self: *const T, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumACString.VTable, self.vtable).SetEnumOptions(@ptrCast(*const IEnumACString, self), dwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumACString_GetEnumOptions(self: *const T, pdwOptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumACString.VTable, self.vtable).GetEnumOptions(@ptrCast(*const IEnumACString, self), pdwOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IDataObjectAsyncCapability_Value = @import("../zig.zig").Guid.initString("3d8b0590-f691-11d2-8ea9-006097df5bd4");
pub const IID_IDataObjectAsyncCapability = &IID_IDataObjectAsyncCapability_Value;
pub const IDataObjectAsyncCapability = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAsyncMode: fn(
            self: *const IDataObjectAsyncCapability,
            fDoOpAsync: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAsyncMode: fn(
            self: *const IDataObjectAsyncCapability,
            pfIsOpAsync: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartOperation: fn(
            self: *const IDataObjectAsyncCapability,
            pbcReserved: ?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InOperation: fn(
            self: *const IDataObjectAsyncCapability,
            pfInAsyncOp: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOperation: fn(
            self: *const IDataObjectAsyncCapability,
            hResult: HRESULT,
            pbcReserved: ?*IBindCtx,
            dwEffects: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObjectAsyncCapability_SetAsyncMode(self: *const T, fDoOpAsync: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObjectAsyncCapability.VTable, self.vtable).SetAsyncMode(@ptrCast(*const IDataObjectAsyncCapability, self), fDoOpAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObjectAsyncCapability_GetAsyncMode(self: *const T, pfIsOpAsync: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObjectAsyncCapability.VTable, self.vtable).GetAsyncMode(@ptrCast(*const IDataObjectAsyncCapability, self), pfIsOpAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObjectAsyncCapability_StartOperation(self: *const T, pbcReserved: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObjectAsyncCapability.VTable, self.vtable).StartOperation(@ptrCast(*const IDataObjectAsyncCapability, self), pbcReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObjectAsyncCapability_InOperation(self: *const T, pfInAsyncOp: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObjectAsyncCapability.VTable, self.vtable).InOperation(@ptrCast(*const IDataObjectAsyncCapability, self), pfInAsyncOp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataObjectAsyncCapability_EndOperation(self: *const T, hResult: HRESULT, pbcReserved: ?*IBindCtx, dwEffects: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataObjectAsyncCapability.VTable, self.vtable).EndOperation(@ptrCast(*const IDataObjectAsyncCapability, self), hResult, pbcReserved, dwEffects);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IExtractIconA_Value = @import("../zig.zig").Guid.initString("000214eb-0000-0000-c000-000000000046");
pub const IID_IExtractIconA = &IID_IExtractIconA_Value;
pub const IExtractIconA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIconLocation: fn(
            self: *const IExtractIconA,
            uFlags: u32,
            pszIconFile: [*:0]u8,
            cchMax: u32,
            piIndex: ?*i32,
            pwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Extract: fn(
            self: *const IExtractIconA,
            pszFile: ?[*:0]const u8,
            nIconIndex: u32,
            phiconLarge: ?*?HICON,
            phiconSmall: ?*?HICON,
            nIconSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtractIconA_GetIconLocation(self: *const T, uFlags: u32, pszIconFile: [*:0]u8, cchMax: u32, piIndex: ?*i32, pwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtractIconA.VTable, self.vtable).GetIconLocation(@ptrCast(*const IExtractIconA, self), uFlags, pszIconFile, cchMax, piIndex, pwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtractIconA_Extract(self: *const T, pszFile: ?[*:0]const u8, nIconIndex: u32, phiconLarge: ?*?HICON, phiconSmall: ?*?HICON, nIconSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtractIconA.VTable, self.vtable).Extract(@ptrCast(*const IExtractIconA, self), pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IExtractIconW_Value = @import("../zig.zig").Guid.initString("000214fa-0000-0000-c000-000000000046");
pub const IID_IExtractIconW = &IID_IExtractIconW_Value;
pub const IExtractIconW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIconLocation: fn(
            self: *const IExtractIconW,
            uFlags: u32,
            pszIconFile: [*:0]u16,
            cchMax: u32,
            piIndex: ?*i32,
            pwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Extract: fn(
            self: *const IExtractIconW,
            pszFile: ?[*:0]const u16,
            nIconIndex: u32,
            phiconLarge: ?*?HICON,
            phiconSmall: ?*?HICON,
            nIconSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtractIconW_GetIconLocation(self: *const T, uFlags: u32, pszIconFile: [*:0]u16, cchMax: u32, piIndex: ?*i32, pwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtractIconW.VTable, self.vtable).GetIconLocation(@ptrCast(*const IExtractIconW, self), uFlags, pszIconFile, cchMax, piIndex, pwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtractIconW_Extract(self: *const T, pszFile: ?[*:0]const u16, nIconIndex: u32, phiconLarge: ?*?HICON, phiconSmall: ?*?HICON, nIconSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtractIconW.VTable, self.vtable).Extract(@ptrCast(*const IExtractIconW, self), pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellIconOverlayManager_Value = @import("../zig.zig").Guid.initString("f10b5e34-dd3b-42a7-aa7d-2f4ec54bb09b");
pub const IID_IShellIconOverlayManager = &IID_IShellIconOverlayManager_Value;
pub const IShellIconOverlayManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFileOverlayInfo: fn(
            self: *const IShellIconOverlayManager,
            pwszPath: ?[*:0]const u16,
            dwAttrib: u32,
            pIndex: ?*i32,
            dwflags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReservedOverlayInfo: fn(
            self: *const IShellIconOverlayManager,
            pwszPath: ?[*:0]const u16,
            dwAttrib: u32,
            pIndex: ?*i32,
            dwflags: u32,
            iReservedID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RefreshOverlayImages: fn(
            self: *const IShellIconOverlayManager,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadNonloadedOverlayIdentifiers: fn(
            self: *const IShellIconOverlayManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OverlayIndexFromImageIndex: fn(
            self: *const IShellIconOverlayManager,
            iImage: i32,
            piIndex: ?*i32,
            fAdd: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlayManager_GetFileOverlayInfo(self: *const T, pwszPath: ?[*:0]const u16, dwAttrib: u32, pIndex: ?*i32, dwflags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlayManager.VTable, self.vtable).GetFileOverlayInfo(@ptrCast(*const IShellIconOverlayManager, self), pwszPath, dwAttrib, pIndex, dwflags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlayManager_GetReservedOverlayInfo(self: *const T, pwszPath: ?[*:0]const u16, dwAttrib: u32, pIndex: ?*i32, dwflags: u32, iReservedID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlayManager.VTable, self.vtable).GetReservedOverlayInfo(@ptrCast(*const IShellIconOverlayManager, self), pwszPath, dwAttrib, pIndex, dwflags, iReservedID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlayManager_RefreshOverlayImages(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlayManager.VTable, self.vtable).RefreshOverlayImages(@ptrCast(*const IShellIconOverlayManager, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlayManager_LoadNonloadedOverlayIdentifiers(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlayManager.VTable, self.vtable).LoadNonloadedOverlayIdentifiers(@ptrCast(*const IShellIconOverlayManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlayManager_OverlayIndexFromImageIndex(self: *const T, iImage: i32, piIndex: ?*i32, fAdd: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlayManager.VTable, self.vtable).OverlayIndexFromImageIndex(@ptrCast(*const IShellIconOverlayManager, self), iImage, piIndex, fAdd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellIconOverlay_Value = @import("../zig.zig").Guid.initString("7d688a70-c613-11d0-999b-00c04fd655e1");
pub const IID_IShellIconOverlay = &IID_IShellIconOverlay_Value;
pub const IShellIconOverlay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOverlayIndex: fn(
            self: *const IShellIconOverlay,
            pidl: ?*ITEMIDLIST,
            pIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlayIconIndex: fn(
            self: *const IShellIconOverlay,
            pidl: ?*ITEMIDLIST,
            pIconIndex: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlay_GetOverlayIndex(self: *const T, pidl: ?*ITEMIDLIST, pIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlay.VTable, self.vtable).GetOverlayIndex(@ptrCast(*const IShellIconOverlay, self), pidl, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellIconOverlay_GetOverlayIconIndex(self: *const T, pidl: ?*ITEMIDLIST, pIconIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellIconOverlay.VTable, self.vtable).GetOverlayIconIndex(@ptrCast(*const IShellIconOverlay, self), pidl, pIconIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHELL_LINK_DATA_FLAGS = enum(i32) {
    DEFAULT = 0,
    HAS_ID_LIST = 1,
    HAS_LINK_INFO = 2,
    HAS_NAME = 4,
    HAS_RELPATH = 8,
    HAS_WORKINGDIR = 16,
    HAS_ARGS = 32,
    HAS_ICONLOCATION = 64,
    UNICODE = 128,
    FORCE_NO_LINKINFO = 256,
    HAS_EXP_SZ = 512,
    RUN_IN_SEPARATE = 1024,
    HAS_DARWINID = 4096,
    RUNAS_USER = 8192,
    HAS_EXP_ICON_SZ = 16384,
    NO_PIDL_ALIAS = 32768,
    FORCE_UNCNAME = 65536,
    RUN_WITH_SHIMLAYER = 131072,
    FORCE_NO_LINKTRACK = 262144,
    ENABLE_TARGET_METADATA = 524288,
    DISABLE_LINK_PATH_TRACKING = 1048576,
    DISABLE_KNOWNFOLDER_RELATIVE_TRACKING = 2097152,
    NO_KF_ALIAS = 4194304,
    ALLOW_LINK_TO_LINK = 8388608,
    UNALIAS_ON_SAVE = 16777216,
    PREFER_ENVIRONMENT_PATH = 33554432,
    KEEP_LOCAL_IDLIST_FOR_UNC_TARGET = 67108864,
    PERSIST_VOLUME_ID_RELATIVE = 134217728,
    VALID = 268433407,
    RESERVED = -2147483648,
};
pub const SLDF_DEFAULT = SHELL_LINK_DATA_FLAGS.DEFAULT;
pub const SLDF_HAS_ID_LIST = SHELL_LINK_DATA_FLAGS.HAS_ID_LIST;
pub const SLDF_HAS_LINK_INFO = SHELL_LINK_DATA_FLAGS.HAS_LINK_INFO;
pub const SLDF_HAS_NAME = SHELL_LINK_DATA_FLAGS.HAS_NAME;
pub const SLDF_HAS_RELPATH = SHELL_LINK_DATA_FLAGS.HAS_RELPATH;
pub const SLDF_HAS_WORKINGDIR = SHELL_LINK_DATA_FLAGS.HAS_WORKINGDIR;
pub const SLDF_HAS_ARGS = SHELL_LINK_DATA_FLAGS.HAS_ARGS;
pub const SLDF_HAS_ICONLOCATION = SHELL_LINK_DATA_FLAGS.HAS_ICONLOCATION;
pub const SLDF_UNICODE = SHELL_LINK_DATA_FLAGS.UNICODE;
pub const SLDF_FORCE_NO_LINKINFO = SHELL_LINK_DATA_FLAGS.FORCE_NO_LINKINFO;
pub const SLDF_HAS_EXP_SZ = SHELL_LINK_DATA_FLAGS.HAS_EXP_SZ;
pub const SLDF_RUN_IN_SEPARATE = SHELL_LINK_DATA_FLAGS.RUN_IN_SEPARATE;
pub const SLDF_HAS_DARWINID = SHELL_LINK_DATA_FLAGS.HAS_DARWINID;
pub const SLDF_RUNAS_USER = SHELL_LINK_DATA_FLAGS.RUNAS_USER;
pub const SLDF_HAS_EXP_ICON_SZ = SHELL_LINK_DATA_FLAGS.HAS_EXP_ICON_SZ;
pub const SLDF_NO_PIDL_ALIAS = SHELL_LINK_DATA_FLAGS.NO_PIDL_ALIAS;
pub const SLDF_FORCE_UNCNAME = SHELL_LINK_DATA_FLAGS.FORCE_UNCNAME;
pub const SLDF_RUN_WITH_SHIMLAYER = SHELL_LINK_DATA_FLAGS.RUN_WITH_SHIMLAYER;
pub const SLDF_FORCE_NO_LINKTRACK = SHELL_LINK_DATA_FLAGS.FORCE_NO_LINKTRACK;
pub const SLDF_ENABLE_TARGET_METADATA = SHELL_LINK_DATA_FLAGS.ENABLE_TARGET_METADATA;
pub const SLDF_DISABLE_LINK_PATH_TRACKING = SHELL_LINK_DATA_FLAGS.DISABLE_LINK_PATH_TRACKING;
pub const SLDF_DISABLE_KNOWNFOLDER_RELATIVE_TRACKING = SHELL_LINK_DATA_FLAGS.DISABLE_KNOWNFOLDER_RELATIVE_TRACKING;
pub const SLDF_NO_KF_ALIAS = SHELL_LINK_DATA_FLAGS.NO_KF_ALIAS;
pub const SLDF_ALLOW_LINK_TO_LINK = SHELL_LINK_DATA_FLAGS.ALLOW_LINK_TO_LINK;
pub const SLDF_UNALIAS_ON_SAVE = SHELL_LINK_DATA_FLAGS.UNALIAS_ON_SAVE;
pub const SLDF_PREFER_ENVIRONMENT_PATH = SHELL_LINK_DATA_FLAGS.PREFER_ENVIRONMENT_PATH;
pub const SLDF_KEEP_LOCAL_IDLIST_FOR_UNC_TARGET = SHELL_LINK_DATA_FLAGS.KEEP_LOCAL_IDLIST_FOR_UNC_TARGET;
pub const SLDF_PERSIST_VOLUME_ID_RELATIVE = SHELL_LINK_DATA_FLAGS.PERSIST_VOLUME_ID_RELATIVE;
pub const SLDF_VALID = SHELL_LINK_DATA_FLAGS.VALID;
pub const SLDF_RESERVED = SHELL_LINK_DATA_FLAGS.RESERVED;

pub const DATABLOCK_HEADER = packed struct {
    cbSize: u32,
    dwSignature: u32,
};

pub const NT_CONSOLE_PROPS = packed struct {
    dbh: DATABLOCK_HEADER,
    wFillAttribute: u16,
    wPopupFillAttribute: u16,
    dwScreenBufferSize: COORD,
    dwWindowSize: COORD,
    dwWindowOrigin: COORD,
    nFont: u32,
    nInputBufferSize: u32,
    dwFontSize: COORD,
    uFontFamily: u32,
    uFontWeight: u32,
    FaceName: [32]u16,
    uCursorSize: u32,
    bFullScreen: BOOL,
    bQuickEdit: BOOL,
    bInsertMode: BOOL,
    bAutoPosition: BOOL,
    uHistoryBufferSize: u32,
    uNumberOfHistoryBuffers: u32,
    bHistoryNoDup: BOOL,
    ColorTable: [16]u32,
};

pub const NT_FE_CONSOLE_PROPS = packed struct {
    dbh: DATABLOCK_HEADER,
    uCodePage: u32,
};

pub const EXP_DARWIN_LINK = packed struct {
    dbh: DATABLOCK_HEADER,
    szDarwinID: [260]CHAR,
    szwDarwinID: [260]u16,
};

pub const EXP_SPECIAL_FOLDER = packed struct {
    cbSize: u32,
    dwSignature: u32,
    idSpecialFolder: u32,
    cbOffset: u32,
};

pub const EXP_SZ_LINK = packed struct {
    cbSize: u32,
    dwSignature: u32,
    szTarget: [260]CHAR,
    swzTarget: [260]u16,
};

pub const EXP_PROPERTYSTORAGE = packed struct {
    cbSize: u32,
    dwSignature: u32,
    abPropertyStorage: [1]u8,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IURLSearchHook_Value = @import("../zig.zig").Guid.initString("ac60f6a0-0fd9-11d0-99cb-00c04fd64497");
pub const IID_IURLSearchHook = &IID_IURLSearchHook_Value;
pub const IURLSearchHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Translate: fn(
            self: *const IURLSearchHook,
            pwszSearchURL: [*:0]u16,
            cchBufferSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IURLSearchHook_Translate(self: *const T, pwszSearchURL: [*:0]u16, cchBufferSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IURLSearchHook.VTable, self.vtable).Translate(@ptrCast(*const IURLSearchHook, self), pwszSearchURL, cchBufferSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISearchContext_Value = @import("../zig.zig").Guid.initString("09f656a2-41af-480c-88f7-16cc0d164615");
pub const IID_ISearchContext = &IID_ISearchContext_Value;
pub const ISearchContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSearchUrl: fn(
            self: *const ISearchContext,
            pbstrSearchUrl: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSearchText: fn(
            self: *const ISearchContext,
            pbstrSearchText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSearchStyle: fn(
            self: *const ISearchContext,
            pdwSearchStyle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchContext_GetSearchUrl(self: *const T, pbstrSearchUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchContext.VTable, self.vtable).GetSearchUrl(@ptrCast(*const ISearchContext, self), pbstrSearchUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchContext_GetSearchText(self: *const T, pbstrSearchText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchContext.VTable, self.vtable).GetSearchText(@ptrCast(*const ISearchContext, self), pbstrSearchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchContext_GetSearchStyle(self: *const T, pdwSearchStyle: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchContext.VTable, self.vtable).GetSearchStyle(@ptrCast(*const ISearchContext, self), pdwSearchStyle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IURLSearchHook2_Value = @import("../zig.zig").Guid.initString("5ee44da4-6d32-46e3-86bc-07540dedd0e0");
pub const IID_IURLSearchHook2 = &IID_IURLSearchHook2_Value;
pub const IURLSearchHook2 = extern struct {
    pub const VTable = extern struct {
        base: IURLSearchHook.VTable,
        TranslateWithSearchContext: fn(
            self: *const IURLSearchHook2,
            pwszSearchURL: [*:0]u16,
            cchBufferSize: u32,
            pSearchContext: ?*ISearchContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IURLSearchHook.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IURLSearchHook2_TranslateWithSearchContext(self: *const T, pwszSearchURL: [*:0]u16, cchBufferSize: u32, pSearchContext: ?*ISearchContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IURLSearchHook2.VTable, self.vtable).TranslateWithSearchContext(@ptrCast(*const IURLSearchHook2, self), pwszSearchURL, cchBufferSize, pSearchContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHGFP_TYPE = enum(i32) {
    CURRENT = 0,
    DEFAULT = 1,
};
pub const SHGFP_TYPE_CURRENT = SHGFP_TYPE.CURRENT;
pub const SHGFP_TYPE_DEFAULT = SHGFP_TYPE.DEFAULT;

pub const KNOWN_FOLDER_FLAG = enum(i32) {
    DEFAULT = 0,
    FORCE_APP_DATA_REDIRECTION = 524288,
    RETURN_FILTER_REDIRECTION_TARGET = 262144,
    FORCE_PACKAGE_REDIRECTION = 131072,
    NO_PACKAGE_REDIRECTION = 65536,
    // FORCE_APPCONTAINER_REDIRECTION = 131072, this enum value conflicts with FORCE_PACKAGE_REDIRECTION
    // NO_APPCONTAINER_REDIRECTION = 65536, this enum value conflicts with NO_PACKAGE_REDIRECTION
    CREATE = 32768,
    DONT_VERIFY = 16384,
    DONT_UNEXPAND = 8192,
    NO_ALIAS = 4096,
    INIT = 2048,
    DEFAULT_PATH = 1024,
    NOT_PARENT_RELATIVE = 512,
    SIMPLE_IDLIST = 256,
    ALIAS_ONLY = -2147483648,
};
pub const KF_FLAG_DEFAULT = KNOWN_FOLDER_FLAG.DEFAULT;
pub const KF_FLAG_FORCE_APP_DATA_REDIRECTION = KNOWN_FOLDER_FLAG.FORCE_APP_DATA_REDIRECTION;
pub const KF_FLAG_RETURN_FILTER_REDIRECTION_TARGET = KNOWN_FOLDER_FLAG.RETURN_FILTER_REDIRECTION_TARGET;
pub const KF_FLAG_FORCE_PACKAGE_REDIRECTION = KNOWN_FOLDER_FLAG.FORCE_PACKAGE_REDIRECTION;
pub const KF_FLAG_NO_PACKAGE_REDIRECTION = KNOWN_FOLDER_FLAG.NO_PACKAGE_REDIRECTION;
pub const KF_FLAG_FORCE_APPCONTAINER_REDIRECTION = KNOWN_FOLDER_FLAG.FORCE_PACKAGE_REDIRECTION;
pub const KF_FLAG_NO_APPCONTAINER_REDIRECTION = KNOWN_FOLDER_FLAG.NO_PACKAGE_REDIRECTION;
pub const KF_FLAG_CREATE = KNOWN_FOLDER_FLAG.CREATE;
pub const KF_FLAG_DONT_VERIFY = KNOWN_FOLDER_FLAG.DONT_VERIFY;
pub const KF_FLAG_DONT_UNEXPAND = KNOWN_FOLDER_FLAG.DONT_UNEXPAND;
pub const KF_FLAG_NO_ALIAS = KNOWN_FOLDER_FLAG.NO_ALIAS;
pub const KF_FLAG_INIT = KNOWN_FOLDER_FLAG.INIT;
pub const KF_FLAG_DEFAULT_PATH = KNOWN_FOLDER_FLAG.DEFAULT_PATH;
pub const KF_FLAG_NOT_PARENT_RELATIVE = KNOWN_FOLDER_FLAG.NOT_PARENT_RELATIVE;
pub const KF_FLAG_SIMPLE_IDLIST = KNOWN_FOLDER_FLAG.SIMPLE_IDLIST;
pub const KF_FLAG_ALIAS_ONLY = KNOWN_FOLDER_FLAG.ALIAS_ONLY;

pub const SHFOLDERCUSTOMSETTINGS = extern struct {
    dwSize: u32,
    dwMask: u32,
    pvid: ?*Guid,
    pszWebViewTemplate: ?PWSTR,
    cchWebViewTemplate: u32,
    pszWebViewTemplateVersion: ?PWSTR,
    pszInfoTip: ?PWSTR,
    cchInfoTip: u32,
    pclsid: ?*Guid,
    dwFlags: u32,
    pszIconFile: ?PWSTR,
    cchIconFile: u32,
    iIconIndex: i32,
    pszLogo: ?PWSTR,
    cchLogo: u32,
};

pub const BFFCALLBACK = fn(
    hwnd: ?HWND,
    uMsg: u32,
    lParam: LPARAM,
    lpData: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const BROWSEINFOA = extern struct {
    hwndOwner: ?HWND,
    pidlRoot: ?*ITEMIDLIST,
    pszDisplayName: ?PSTR,
    lpszTitle: ?[*:0]const u8,
    ulFlags: u32,
    lpfn: ?BFFCALLBACK,
    lParam: LPARAM,
    iImage: i32,
};

pub const BROWSEINFOW = extern struct {
    hwndOwner: ?HWND,
    pidlRoot: ?*ITEMIDLIST,
    pszDisplayName: ?PWSTR,
    lpszTitle: ?[*:0]const u16,
    ulFlags: u32,
    lpfn: ?BFFCALLBACK,
    lParam: LPARAM,
    iImage: i32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellDetails_Value = @import("../zig.zig").Guid.initString("000214ec-0000-0000-c000-000000000046");
pub const IID_IShellDetails = &IID_IShellDetails_Value;
pub const IShellDetails = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDetailsOf: fn(
            self: *const IShellDetails,
            pidl: ?*ITEMIDLIST,
            iColumn: u32,
            pDetails: ?*SHELLDETAILS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ColumnClick: fn(
            self: *const IShellDetails,
            iColumn: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDetails_GetDetailsOf(self: *const T, pidl: ?*ITEMIDLIST, iColumn: u32, pDetails: ?*SHELLDETAILS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDetails.VTable, self.vtable).GetDetailsOf(@ptrCast(*const IShellDetails, self), pidl, iColumn, pDetails);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellDetails_ColumnClick(self: *const T, iColumn: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellDetails.VTable, self.vtable).ColumnClick(@ptrCast(*const IShellDetails, self), iColumn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IObjMgr_Value = @import("../zig.zig").Guid.initString("00bb2761-6a77-11d0-a535-00c04fd7d062");
pub const IID_IObjMgr = &IID_IObjMgr_Value;
pub const IObjMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Append: fn(
            self: *const IObjMgr,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IObjMgr,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjMgr_Append(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjMgr.VTable, self.vtable).Append(@ptrCast(*const IObjMgr, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjMgr_Remove(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjMgr.VTable, self.vtable).Remove(@ptrCast(*const IObjMgr, self), punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IACList_Value = @import("../zig.zig").Guid.initString("77a130b0-94fd-11d0-a544-00c04fd7d062");
pub const IID_IACList = &IID_IACList_Value;
pub const IACList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Expand: fn(
            self: *const IACList,
            pszExpand: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IACList_Expand(self: *const T, pszExpand: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IACList.VTable, self.vtable).Expand(@ptrCast(*const IACList, self), pszExpand);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AUTOCOMPLETELISTOPTIONS = enum(i32) {
    NONE = 0,
    CURRENTDIR = 1,
    MYCOMPUTER = 2,
    DESKTOP = 4,
    FAVORITES = 8,
    FILESYSONLY = 16,
    FILESYSDIRS = 32,
    VIRTUALNAMESPACE = 64,
};
pub const ACLO_NONE = AUTOCOMPLETELISTOPTIONS.NONE;
pub const ACLO_CURRENTDIR = AUTOCOMPLETELISTOPTIONS.CURRENTDIR;
pub const ACLO_MYCOMPUTER = AUTOCOMPLETELISTOPTIONS.MYCOMPUTER;
pub const ACLO_DESKTOP = AUTOCOMPLETELISTOPTIONS.DESKTOP;
pub const ACLO_FAVORITES = AUTOCOMPLETELISTOPTIONS.FAVORITES;
pub const ACLO_FILESYSONLY = AUTOCOMPLETELISTOPTIONS.FILESYSONLY;
pub const ACLO_FILESYSDIRS = AUTOCOMPLETELISTOPTIONS.FILESYSDIRS;
pub const ACLO_VIRTUALNAMESPACE = AUTOCOMPLETELISTOPTIONS.VIRTUALNAMESPACE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IACList2_Value = @import("../zig.zig").Guid.initString("470141a0-5186-11d2-bbb6-0060977b464c");
pub const IID_IACList2 = &IID_IACList2_Value;
pub const IACList2 = extern struct {
    pub const VTable = extern struct {
        base: IACList.VTable,
        SetOptions: fn(
            self: *const IACList2,
            dwFlag: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptions: fn(
            self: *const IACList2,
            pdwFlag: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IACList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IACList2_SetOptions(self: *const T, dwFlag: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IACList2.VTable, self.vtable).SetOptions(@ptrCast(*const IACList2, self), dwFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IACList2_GetOptions(self: *const T, pdwFlag: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IACList2.VTable, self.vtable).GetOptions(@ptrCast(*const IACList2, self), pdwFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProgressDialog_Value = @import("../zig.zig").Guid.initString("ebbc7c04-315e-11d2-b62f-006097df5bd4");
pub const IID_IProgressDialog = &IID_IProgressDialog_Value;
pub const IProgressDialog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartProgressDialog: fn(
            self: *const IProgressDialog,
            hwndParent: ?HWND,
            punkEnableModless: ?*IUnknown,
            dwFlags: u32,
            pvResevered: ?*const anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopProgressDialog: fn(
            self: *const IProgressDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTitle: fn(
            self: *const IProgressDialog,
            pwzTitle: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAnimation: fn(
            self: *const IProgressDialog,
            hInstAnimation: ?HINSTANCE,
            idAnimation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasUserCancelled: fn(
            self: *const IProgressDialog,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        SetProgress: fn(
            self: *const IProgressDialog,
            dwCompleted: u32,
            dwTotal: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProgress64: fn(
            self: *const IProgressDialog,
            ullCompleted: u64,
            ullTotal: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLine: fn(
            self: *const IProgressDialog,
            dwLineNum: u32,
            pwzString: ?[*:0]const u16,
            fCompactPath: BOOL,
            pvResevered: ?*const anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCancelMsg: fn(
            self: *const IProgressDialog,
            pwzCancelMsg: ?[*:0]const u16,
            pvResevered: ?*const anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Timer: fn(
            self: *const IProgressDialog,
            dwTimerAction: u32,
            pvResevered: ?*const anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_StartProgressDialog(self: *const T, hwndParent: ?HWND, punkEnableModless: ?*IUnknown, dwFlags: u32, pvResevered: ?*const anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).StartProgressDialog(@ptrCast(*const IProgressDialog, self), hwndParent, punkEnableModless, dwFlags, pvResevered);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_StopProgressDialog(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).StopProgressDialog(@ptrCast(*const IProgressDialog, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_SetTitle(self: *const T, pwzTitle: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).SetTitle(@ptrCast(*const IProgressDialog, self), pwzTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_SetAnimation(self: *const T, hInstAnimation: ?HINSTANCE, idAnimation: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).SetAnimation(@ptrCast(*const IProgressDialog, self), hInstAnimation, idAnimation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_HasUserCancelled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).HasUserCancelled(@ptrCast(*const IProgressDialog, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_SetProgress(self: *const T, dwCompleted: u32, dwTotal: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).SetProgress(@ptrCast(*const IProgressDialog, self), dwCompleted, dwTotal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_SetProgress64(self: *const T, ullCompleted: u64, ullTotal: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).SetProgress64(@ptrCast(*const IProgressDialog, self), ullCompleted, ullTotal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_SetLine(self: *const T, dwLineNum: u32, pwzString: ?[*:0]const u16, fCompactPath: BOOL, pvResevered: ?*const anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).SetLine(@ptrCast(*const IProgressDialog, self), dwLineNum, pwzString, fCompactPath, pvResevered);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_SetCancelMsg(self: *const T, pwzCancelMsg: ?[*:0]const u16, pvResevered: ?*const anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).SetCancelMsg(@ptrCast(*const IProgressDialog, self), pwzCancelMsg, pvResevered);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressDialog_Timer(self: *const T, dwTimerAction: u32, pvResevered: ?*const anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProgressDialog.VTable, self.vtable).Timer(@ptrCast(*const IProgressDialog, self), dwTimerAction, pvResevered);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDockingWindowSite_Value = @import("../zig.zig").Guid.initString("2a342fc2-7b26-11d0-8ca9-00a0c92dbfe8");
pub const IID_IDockingWindowSite = &IID_IDockingWindowSite_Value;
pub const IDockingWindowSite = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        GetBorderDW: fn(
            self: *const IDockingWindowSite,
            punkObj: ?*IUnknown,
            prcBorder: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestBorderSpaceDW: fn(
            self: *const IDockingWindowSite,
            punkObj: ?*IUnknown,
            pbw: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderSpaceDW: fn(
            self: *const IDockingWindowSite,
            punkObj: ?*IUnknown,
            pbw: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockingWindowSite_GetBorderDW(self: *const T, punkObj: ?*IUnknown, prcBorder: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockingWindowSite.VTable, self.vtable).GetBorderDW(@ptrCast(*const IDockingWindowSite, self), punkObj, prcBorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockingWindowSite_RequestBorderSpaceDW(self: *const T, punkObj: ?*IUnknown, pbw: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockingWindowSite.VTable, self.vtable).RequestBorderSpaceDW(@ptrCast(*const IDockingWindowSite, self), punkObj, pbw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockingWindowSite_SetBorderSpaceDW(self: *const T, punkObj: ?*IUnknown, pbw: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockingWindowSite.VTable, self.vtable).SetBorderSpaceDW(@ptrCast(*const IDockingWindowSite, self), punkObj, pbw);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NRESARRAY = extern struct {
    cItems: u32,
    nr: [1]NETRESOURCEA,
};

pub const CIDA = packed struct {
    cidl: u32,
    aoffset: [1]u32,
};

pub const FD_FLAGS = enum(i32) {
    CLSID = 1,
    SIZEPOINT = 2,
    ATTRIBUTES = 4,
    CREATETIME = 8,
    ACCESSTIME = 16,
    WRITESTIME = 32,
    FILESIZE = 64,
    PROGRESSUI = 16384,
    LINKUI = 32768,
    UNICODE = -2147483648,
};
pub const FD_CLSID = FD_FLAGS.CLSID;
pub const FD_SIZEPOINT = FD_FLAGS.SIZEPOINT;
pub const FD_ATTRIBUTES = FD_FLAGS.ATTRIBUTES;
pub const FD_CREATETIME = FD_FLAGS.CREATETIME;
pub const FD_ACCESSTIME = FD_FLAGS.ACCESSTIME;
pub const FD_WRITESTIME = FD_FLAGS.WRITESTIME;
pub const FD_FILESIZE = FD_FLAGS.FILESIZE;
pub const FD_PROGRESSUI = FD_FLAGS.PROGRESSUI;
pub const FD_LINKUI = FD_FLAGS.LINKUI;
pub const FD_UNICODE = FD_FLAGS.UNICODE;

pub const FILEDESCRIPTORA = packed struct {
    dwFlags: u32,
    clsid: Guid,
    sizel: SIZE,
    pointl: POINTL,
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    cFileName: [260]CHAR,
};

pub const FILEDESCRIPTORW = packed struct {
    dwFlags: u32,
    clsid: Guid,
    sizel: SIZE,
    pointl: POINTL,
    dwFileAttributes: u32,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: u32,
    nFileSizeLow: u32,
    cFileName: [260]u16,
};

// TODO: not generating this type because array of 'win32.ui.shell.FILEDESCRIPTORA' not allowed in packed struct due to padding bits
pub const FILEGROUPDESCRIPTORA = usize;

pub const FILEGROUPDESCRIPTORW = packed struct {
    cItems: u32,
    fgd: [1]FILEDESCRIPTORW,
};

pub const DROPFILES = packed struct {
    pFiles: u32,
    pt: POINT,
    fNC: BOOL,
    fWide: BOOL,
};

pub const FILE_ATTRIBUTES_ARRAY = packed struct {
    cItems: u32,
    dwSumFileAttributes: u32,
    dwProductFileAttributes: u32,
    rgdwFileAttributes: [1]u32,
};

pub const DROPIMAGETYPE = enum(i32) {
    INVALID = -1,
    NONE = 0,
    COPY = 1,
    MOVE = 2,
    LINK = 4,
    LABEL = 6,
    WARNING = 7,
    NOIMAGE = 8,
};
pub const DROPIMAGE_INVALID = DROPIMAGETYPE.INVALID;
pub const DROPIMAGE_NONE = DROPIMAGETYPE.NONE;
pub const DROPIMAGE_COPY = DROPIMAGETYPE.COPY;
pub const DROPIMAGE_MOVE = DROPIMAGETYPE.MOVE;
pub const DROPIMAGE_LINK = DROPIMAGETYPE.LINK;
pub const DROPIMAGE_LABEL = DROPIMAGETYPE.LABEL;
pub const DROPIMAGE_WARNING = DROPIMAGETYPE.WARNING;
pub const DROPIMAGE_NOIMAGE = DROPIMAGETYPE.NOIMAGE;

pub const DROPDESCRIPTION = packed struct {
    type: DROPIMAGETYPE,
    szMessage: [260]u16,
    szInsert: [260]u16,
};

pub const SHChangeNotifyEntry = packed struct {
    pidl: ?*ITEMIDLIST,
    fRecursive: BOOL,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellChangeNotify_Value = @import("../zig.zig").Guid.initString("d82be2b1-5764-11d0-a96e-00c04fd705a2");
pub const IID_IShellChangeNotify = &IID_IShellChangeNotify_Value;
pub const IShellChangeNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: fn(
            self: *const IShellChangeNotify,
            lEvent: i32,
            pidl1: ?*ITEMIDLIST,
            pidl2: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellChangeNotify_OnChange(self: *const T, lEvent: i32, pidl1: ?*ITEMIDLIST, pidl2: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellChangeNotify.VTable, self.vtable).OnChange(@ptrCast(*const IShellChangeNotify, self), lEvent, pidl1, pidl2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQueryInfo_Value = @import("../zig.zig").Guid.initString("00021500-0000-0000-c000-000000000046");
pub const IID_IQueryInfo = &IID_IQueryInfo_Value;
pub const IQueryInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfoTip: fn(
            self: *const IQueryInfo,
            dwFlags: QITIPF_FLAGS,
            ppwszTip: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInfoFlags: fn(
            self: *const IQueryInfo,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryInfo_GetInfoTip(self: *const T, dwFlags: QITIPF_FLAGS, ppwszTip: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryInfo.VTable, self.vtable).GetInfoTip(@ptrCast(*const IQueryInfo, self), dwFlags, ppwszTip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryInfo_GetInfoFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryInfo.VTable, self.vtable).GetInfoFlags(@ptrCast(*const IQueryInfo, self), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHARD = enum(i32) {
    PIDL = 1,
    PATHA = 2,
    PATHW = 3,
    APPIDINFO = 4,
    APPIDINFOIDLIST = 5,
    LINK = 6,
    APPIDINFOLINK = 7,
    SHELLITEM = 8,
};
pub const SHARD_PIDL = SHARD.PIDL;
pub const SHARD_PATHA = SHARD.PATHA;
pub const SHARD_PATHW = SHARD.PATHW;
pub const SHARD_APPIDINFO = SHARD.APPIDINFO;
pub const SHARD_APPIDINFOIDLIST = SHARD.APPIDINFOIDLIST;
pub const SHARD_LINK = SHARD.LINK;
pub const SHARD_APPIDINFOLINK = SHARD.APPIDINFOLINK;
pub const SHARD_SHELLITEM = SHARD.SHELLITEM;

pub const SHARDAPPIDINFO = packed struct {
    psi: ?*IShellItem,
    pszAppID: ?[*:0]const u16,
};

pub const SHARDAPPIDINFOIDLIST = packed struct {
    pidl: ?*ITEMIDLIST,
    pszAppID: ?[*:0]const u16,
};

pub const SHARDAPPIDINFOLINK = packed struct {
    psl: ?*IShellLinkA,
    pszAppID: ?[*:0]const u16,
};

pub const SHChangeDWORDAsIDList = packed struct {
    cb: u16,
    dwItem1: u32,
    dwItem2: u32,
    cbZero: u16,
};

pub const SHChangeUpdateImageIDList = packed struct {
    cb: u16,
    iIconIndex: i32,
    iCurIndex: i32,
    uFlags: u32,
    dwProcessID: u32,
    szName: [260]u16,
    cbZero: u16,
};

pub const SCNRT_STATUS = enum(i32) {
    ENABLE = 0,
    DISABLE = 1,
};
pub const SCNRT_ENABLE = SCNRT_STATUS.ENABLE;
pub const SCNRT_DISABLE = SCNRT_STATUS.DISABLE;

pub const SHDESCRIPTIONID = extern struct {
    dwDescriptionId: SHDID_ID,
    clsid: Guid,
};

pub const AUTO_SCROLL_DATA = packed struct {
    iNextSample: i32,
    dwLastScroll: u32,
    bFull: BOOL,
    pts: [3]POINT,
    dwTimes: [3]u32,
};

pub const CABINETSTATE = packed struct {
    cLength: u16,
    nVersion: u16,
    _bitfield: i32,
    fMenuEnumFilter: u32,
};

pub const RESTRICTIONS = enum(i32) {
    NONE = 0,
    NORUN = 1,
    NOCLOSE = 2,
    NOSAVESET = 4,
    NOFILEMENU = 8,
    NOSETFOLDERS = 16,
    NOSETTASKBAR = 32,
    NODESKTOP = 64,
    NOFIND = 128,
    NODRIVES = 256,
    NODRIVEAUTORUN = 512,
    NODRIVETYPEAUTORUN = 1024,
    NONETHOOD = 2048,
    STARTBANNER = 4096,
    RESTRICTRUN = 8192,
    NOPRINTERTABS = 16384,
    NOPRINTERDELETE = 32768,
    NOPRINTERADD = 65536,
    NOSTARTMENUSUBFOLDERS = 131072,
    MYDOCSONNET = 262144,
    NOEXITTODOS = 524288,
    ENFORCESHELLEXTSECURITY = 1048576,
    LINKRESOLVEIGNORELINKINFO = 2097152,
    NOCOMMONGROUPS = 4194304,
    SEPARATEDESKTOPPROCESS = 8388608,
    NOWEB = 16777216,
    NOTRAYCONTEXTMENU = 33554432,
    NOVIEWCONTEXTMENU = 67108864,
    NONETCONNECTDISCONNECT = 134217728,
    STARTMENULOGOFF = 268435456,
    NOSETTINGSASSIST = 536870912,
    NOINTERNETICON = 1073741825,
    NORECENTDOCSHISTORY = 1073741826,
    NORECENTDOCSMENU = 1073741827,
    NOACTIVEDESKTOP = 1073741828,
    NOACTIVEDESKTOPCHANGES = 1073741829,
    NOFAVORITESMENU = 1073741830,
    CLEARRECENTDOCSONEXIT = 1073741831,
    CLASSICSHELL = 1073741832,
    NOCUSTOMIZEWEBVIEW = 1073741833,
    NOHTMLWALLPAPER = 1073741840,
    NOCHANGINGWALLPAPER = 1073741841,
    NODESKCOMP = 1073741842,
    NOADDDESKCOMP = 1073741843,
    NODELDESKCOMP = 1073741844,
    NOCLOSEDESKCOMP = 1073741845,
    NOCLOSE_DRAGDROPBAND = 1073741846,
    NOMOVINGBAND = 1073741847,
    NOEDITDESKCOMP = 1073741848,
    NORESOLVESEARCH = 1073741849,
    NORESOLVETRACK = 1073741850,
    FORCECOPYACLWITHFILE = 1073741851,
    NOFORGETSOFTWAREUPDATE = 1073741853,
    NOSETACTIVEDESKTOP = 1073741854,
    NOUPDATEWINDOWS = 1073741855,
    NOCHANGESTARMENU = 1073741856,
    NOFOLDEROPTIONS = 1073741857,
    HASFINDCOMPUTERS = 1073741858,
    INTELLIMENUS = 1073741859,
    RUNDLGMEMCHECKBOX = 1073741860,
    ARP_ShowPostSetup = 1073741861,
    NOCSC = 1073741862,
    NOCONTROLPANEL = 1073741863,
    ENUMWORKGROUP = 1073741864,
    ARP_NOARP = 1073741865,
    ARP_NOREMOVEPAGE = 1073741866,
    ARP_NOADDPAGE = 1073741867,
    ARP_NOWINSETUPPAGE = 1073741868,
    GREYMSIADS = 1073741869,
    NOCHANGEMAPPEDDRIVELABEL = 1073741870,
    NOCHANGEMAPPEDDRIVECOMMENT = 1073741871,
    MaxRecentDocs = 1073741872,
    NONETWORKCONNECTIONS = 1073741873,
    FORCESTARTMENULOGOFF = 1073741874,
    NOWEBVIEW = 1073741875,
    NOCUSTOMIZETHISFOLDER = 1073741876,
    NOENCRYPTION = 1073741877,
    DONTSHOWSUPERHIDDEN = 1073741879,
    NOSHELLSEARCHBUTTON = 1073741880,
    NOHARDWARETAB = 1073741881,
    NORUNASINSTALLPROMPT = 1073741882,
    PROMPTRUNASINSTALLNETPATH = 1073741883,
    NOMANAGEMYCOMPUTERVERB = 1073741884,
    DISALLOWRUN = 1073741886,
    NOWELCOMESCREEN = 1073741887,
    RESTRICTCPL = 1073741888,
    DISALLOWCPL = 1073741889,
    NOSMBALLOONTIP = 1073741890,
    NOSMHELP = 1073741891,
    NOWINKEYS = 1073741892,
    NOENCRYPTONMOVE = 1073741893,
    NOLOCALMACHINERUN = 1073741894,
    NOCURRENTUSERRUN = 1073741895,
    NOLOCALMACHINERUNONCE = 1073741896,
    NOCURRENTUSERRUNONCE = 1073741897,
    FORCEACTIVEDESKTOPON = 1073741898,
    NOVIEWONDRIVE = 1073741900,
    NONETCRAWL = 1073741901,
    NOSHAREDDOCUMENTS = 1073741902,
    NOSMMYDOCS = 1073741903,
    NOSMMYPICS = 1073741904,
    ALLOWBITBUCKDRIVES = 1073741905,
    NONLEGACYSHELLMODE = 1073741906,
    NOCONTROLPANELBARRICADE = 1073741907,
    NOSTARTPAGE = 1073741908,
    NOAUTOTRAYNOTIFY = 1073741909,
    NOTASKGROUPING = 1073741910,
    NOCDBURNING = 1073741911,
    MYCOMPNOPROP = 1073741912,
    MYDOCSNOPROP = 1073741913,
    NOSTARTPANEL = 1073741914,
    NODISPLAYAPPEARANCEPAGE = 1073741915,
    NOTHEMESTAB = 1073741916,
    NOVISUALSTYLECHOICE = 1073741917,
    NOSIZECHOICE = 1073741918,
    NOCOLORCHOICE = 1073741919,
    SETVISUALSTYLE = 1073741920,
    STARTRUNNOHOMEPATH = 1073741921,
    NOUSERNAMEINSTARTPANEL = 1073741922,
    NOMYCOMPUTERICON = 1073741923,
    NOSMNETWORKPLACES = 1073741924,
    NOSMPINNEDLIST = 1073741925,
    NOSMMYMUSIC = 1073741926,
    NOSMEJECTPC = 1073741927,
    NOSMMOREPROGRAMS = 1073741928,
    NOSMMFUPROGRAMS = 1073741929,
    NOTRAYITEMSDISPLAY = 1073741930,
    NOTOOLBARSONTASKBAR = 1073741931,
    NOSMCONFIGUREPROGRAMS = 1073741935,
    HIDECLOCK = 1073741936,
    NOLOWDISKSPACECHECKS = 1073741937,
    NOENTIRENETWORK = 1073741938,
    NODESKTOPCLEANUP = 1073741939,
    BITBUCKNUKEONDELETE = 1073741940,
    BITBUCKCONFIRMDELETE = 1073741941,
    BITBUCKNOPROP = 1073741942,
    NODISPBACKGROUND = 1073741943,
    NODISPSCREENSAVEPG = 1073741944,
    NODISPSETTINGSPG = 1073741945,
    NODISPSCREENSAVEPREVIEW = 1073741946,
    NODISPLAYCPL = 1073741947,
    HIDERUNASVERB = 1073741948,
    NOTHUMBNAILCACHE = 1073741949,
    NOSTRCMPLOGICAL = 1073741950,
    NOPUBLISHWIZARD = 1073741951,
    NOONLINEPRINTSWIZARD = 1073741952,
    NOWEBSERVICES = 1073741953,
    ALLOWUNHASHEDWEBVIEW = 1073741954,
    ALLOWLEGACYWEBVIEW = 1073741955,
    REVERTWEBVIEWSECURITY = 1073741956,
    INHERITCONSOLEHANDLES = 1073741958,
    NOREMOTERECURSIVEEVENTS = 1073741961,
    NOREMOTECHANGENOTIFY = 1073741969,
    NOENUMENTIRENETWORK = 1073741971,
    NOINTERNETOPENWITH = 1073741973,
    DONTRETRYBADNETNAME = 1073741979,
    ALLOWFILECLSIDJUNCTIONS = 1073741980,
    NOUPNPINSTALL = 1073741981,
    ARP_DONTGROUPPATCHES = 1073741996,
    ARP_NOCHOOSEPROGRAMSPAGE = 1073741997,
    NODISCONNECT = 1090519041,
    NOSECURITY = 1090519042,
    NOFILEASSOCIATE = 1090519043,
    ALLOWCOMMENTTOGGLE = 1090519044,
};
pub const REST_NONE = RESTRICTIONS.NONE;
pub const REST_NORUN = RESTRICTIONS.NORUN;
pub const REST_NOCLOSE = RESTRICTIONS.NOCLOSE;
pub const REST_NOSAVESET = RESTRICTIONS.NOSAVESET;
pub const REST_NOFILEMENU = RESTRICTIONS.NOFILEMENU;
pub const REST_NOSETFOLDERS = RESTRICTIONS.NOSETFOLDERS;
pub const REST_NOSETTASKBAR = RESTRICTIONS.NOSETTASKBAR;
pub const REST_NODESKTOP = RESTRICTIONS.NODESKTOP;
pub const REST_NOFIND = RESTRICTIONS.NOFIND;
pub const REST_NODRIVES = RESTRICTIONS.NODRIVES;
pub const REST_NODRIVEAUTORUN = RESTRICTIONS.NODRIVEAUTORUN;
pub const REST_NODRIVETYPEAUTORUN = RESTRICTIONS.NODRIVETYPEAUTORUN;
pub const REST_NONETHOOD = RESTRICTIONS.NONETHOOD;
pub const REST_STARTBANNER = RESTRICTIONS.STARTBANNER;
pub const REST_RESTRICTRUN = RESTRICTIONS.RESTRICTRUN;
pub const REST_NOPRINTERTABS = RESTRICTIONS.NOPRINTERTABS;
pub const REST_NOPRINTERDELETE = RESTRICTIONS.NOPRINTERDELETE;
pub const REST_NOPRINTERADD = RESTRICTIONS.NOPRINTERADD;
pub const REST_NOSTARTMENUSUBFOLDERS = RESTRICTIONS.NOSTARTMENUSUBFOLDERS;
pub const REST_MYDOCSONNET = RESTRICTIONS.MYDOCSONNET;
pub const REST_NOEXITTODOS = RESTRICTIONS.NOEXITTODOS;
pub const REST_ENFORCESHELLEXTSECURITY = RESTRICTIONS.ENFORCESHELLEXTSECURITY;
pub const REST_LINKRESOLVEIGNORELINKINFO = RESTRICTIONS.LINKRESOLVEIGNORELINKINFO;
pub const REST_NOCOMMONGROUPS = RESTRICTIONS.NOCOMMONGROUPS;
pub const REST_SEPARATEDESKTOPPROCESS = RESTRICTIONS.SEPARATEDESKTOPPROCESS;
pub const REST_NOWEB = RESTRICTIONS.NOWEB;
pub const REST_NOTRAYCONTEXTMENU = RESTRICTIONS.NOTRAYCONTEXTMENU;
pub const REST_NOVIEWCONTEXTMENU = RESTRICTIONS.NOVIEWCONTEXTMENU;
pub const REST_NONETCONNECTDISCONNECT = RESTRICTIONS.NONETCONNECTDISCONNECT;
pub const REST_STARTMENULOGOFF = RESTRICTIONS.STARTMENULOGOFF;
pub const REST_NOSETTINGSASSIST = RESTRICTIONS.NOSETTINGSASSIST;
pub const REST_NOINTERNETICON = RESTRICTIONS.NOINTERNETICON;
pub const REST_NORECENTDOCSHISTORY = RESTRICTIONS.NORECENTDOCSHISTORY;
pub const REST_NORECENTDOCSMENU = RESTRICTIONS.NORECENTDOCSMENU;
pub const REST_NOACTIVEDESKTOP = RESTRICTIONS.NOACTIVEDESKTOP;
pub const REST_NOACTIVEDESKTOPCHANGES = RESTRICTIONS.NOACTIVEDESKTOPCHANGES;
pub const REST_NOFAVORITESMENU = RESTRICTIONS.NOFAVORITESMENU;
pub const REST_CLEARRECENTDOCSONEXIT = RESTRICTIONS.CLEARRECENTDOCSONEXIT;
pub const REST_CLASSICSHELL = RESTRICTIONS.CLASSICSHELL;
pub const REST_NOCUSTOMIZEWEBVIEW = RESTRICTIONS.NOCUSTOMIZEWEBVIEW;
pub const REST_NOHTMLWALLPAPER = RESTRICTIONS.NOHTMLWALLPAPER;
pub const REST_NOCHANGINGWALLPAPER = RESTRICTIONS.NOCHANGINGWALLPAPER;
pub const REST_NODESKCOMP = RESTRICTIONS.NODESKCOMP;
pub const REST_NOADDDESKCOMP = RESTRICTIONS.NOADDDESKCOMP;
pub const REST_NODELDESKCOMP = RESTRICTIONS.NODELDESKCOMP;
pub const REST_NOCLOSEDESKCOMP = RESTRICTIONS.NOCLOSEDESKCOMP;
pub const REST_NOCLOSE_DRAGDROPBAND = RESTRICTIONS.NOCLOSE_DRAGDROPBAND;
pub const REST_NOMOVINGBAND = RESTRICTIONS.NOMOVINGBAND;
pub const REST_NOEDITDESKCOMP = RESTRICTIONS.NOEDITDESKCOMP;
pub const REST_NORESOLVESEARCH = RESTRICTIONS.NORESOLVESEARCH;
pub const REST_NORESOLVETRACK = RESTRICTIONS.NORESOLVETRACK;
pub const REST_FORCECOPYACLWITHFILE = RESTRICTIONS.FORCECOPYACLWITHFILE;
pub const REST_NOFORGETSOFTWAREUPDATE = RESTRICTIONS.NOFORGETSOFTWAREUPDATE;
pub const REST_NOSETACTIVEDESKTOP = RESTRICTIONS.NOSETACTIVEDESKTOP;
pub const REST_NOUPDATEWINDOWS = RESTRICTIONS.NOUPDATEWINDOWS;
pub const REST_NOCHANGESTARMENU = RESTRICTIONS.NOCHANGESTARMENU;
pub const REST_NOFOLDEROPTIONS = RESTRICTIONS.NOFOLDEROPTIONS;
pub const REST_HASFINDCOMPUTERS = RESTRICTIONS.HASFINDCOMPUTERS;
pub const REST_INTELLIMENUS = RESTRICTIONS.INTELLIMENUS;
pub const REST_RUNDLGMEMCHECKBOX = RESTRICTIONS.RUNDLGMEMCHECKBOX;
pub const REST_ARP_ShowPostSetup = RESTRICTIONS.ARP_ShowPostSetup;
pub const REST_NOCSC = RESTRICTIONS.NOCSC;
pub const REST_NOCONTROLPANEL = RESTRICTIONS.NOCONTROLPANEL;
pub const REST_ENUMWORKGROUP = RESTRICTIONS.ENUMWORKGROUP;
pub const REST_ARP_NOARP = RESTRICTIONS.ARP_NOARP;
pub const REST_ARP_NOREMOVEPAGE = RESTRICTIONS.ARP_NOREMOVEPAGE;
pub const REST_ARP_NOADDPAGE = RESTRICTIONS.ARP_NOADDPAGE;
pub const REST_ARP_NOWINSETUPPAGE = RESTRICTIONS.ARP_NOWINSETUPPAGE;
pub const REST_GREYMSIADS = RESTRICTIONS.GREYMSIADS;
pub const REST_NOCHANGEMAPPEDDRIVELABEL = RESTRICTIONS.NOCHANGEMAPPEDDRIVELABEL;
pub const REST_NOCHANGEMAPPEDDRIVECOMMENT = RESTRICTIONS.NOCHANGEMAPPEDDRIVECOMMENT;
pub const REST_MaxRecentDocs = RESTRICTIONS.MaxRecentDocs;
pub const REST_NONETWORKCONNECTIONS = RESTRICTIONS.NONETWORKCONNECTIONS;
pub const REST_FORCESTARTMENULOGOFF = RESTRICTIONS.FORCESTARTMENULOGOFF;
pub const REST_NOWEBVIEW = RESTRICTIONS.NOWEBVIEW;
pub const REST_NOCUSTOMIZETHISFOLDER = RESTRICTIONS.NOCUSTOMIZETHISFOLDER;
pub const REST_NOENCRYPTION = RESTRICTIONS.NOENCRYPTION;
pub const REST_DONTSHOWSUPERHIDDEN = RESTRICTIONS.DONTSHOWSUPERHIDDEN;
pub const REST_NOSHELLSEARCHBUTTON = RESTRICTIONS.NOSHELLSEARCHBUTTON;
pub const REST_NOHARDWARETAB = RESTRICTIONS.NOHARDWARETAB;
pub const REST_NORUNASINSTALLPROMPT = RESTRICTIONS.NORUNASINSTALLPROMPT;
pub const REST_PROMPTRUNASINSTALLNETPATH = RESTRICTIONS.PROMPTRUNASINSTALLNETPATH;
pub const REST_NOMANAGEMYCOMPUTERVERB = RESTRICTIONS.NOMANAGEMYCOMPUTERVERB;
pub const REST_DISALLOWRUN = RESTRICTIONS.DISALLOWRUN;
pub const REST_NOWELCOMESCREEN = RESTRICTIONS.NOWELCOMESCREEN;
pub const REST_RESTRICTCPL = RESTRICTIONS.RESTRICTCPL;
pub const REST_DISALLOWCPL = RESTRICTIONS.DISALLOWCPL;
pub const REST_NOSMBALLOONTIP = RESTRICTIONS.NOSMBALLOONTIP;
pub const REST_NOSMHELP = RESTRICTIONS.NOSMHELP;
pub const REST_NOWINKEYS = RESTRICTIONS.NOWINKEYS;
pub const REST_NOENCRYPTONMOVE = RESTRICTIONS.NOENCRYPTONMOVE;
pub const REST_NOLOCALMACHINERUN = RESTRICTIONS.NOLOCALMACHINERUN;
pub const REST_NOCURRENTUSERRUN = RESTRICTIONS.NOCURRENTUSERRUN;
pub const REST_NOLOCALMACHINERUNONCE = RESTRICTIONS.NOLOCALMACHINERUNONCE;
pub const REST_NOCURRENTUSERRUNONCE = RESTRICTIONS.NOCURRENTUSERRUNONCE;
pub const REST_FORCEACTIVEDESKTOPON = RESTRICTIONS.FORCEACTIVEDESKTOPON;
pub const REST_NOVIEWONDRIVE = RESTRICTIONS.NOVIEWONDRIVE;
pub const REST_NONETCRAWL = RESTRICTIONS.NONETCRAWL;
pub const REST_NOSHAREDDOCUMENTS = RESTRICTIONS.NOSHAREDDOCUMENTS;
pub const REST_NOSMMYDOCS = RESTRICTIONS.NOSMMYDOCS;
pub const REST_NOSMMYPICS = RESTRICTIONS.NOSMMYPICS;
pub const REST_ALLOWBITBUCKDRIVES = RESTRICTIONS.ALLOWBITBUCKDRIVES;
pub const REST_NONLEGACYSHELLMODE = RESTRICTIONS.NONLEGACYSHELLMODE;
pub const REST_NOCONTROLPANELBARRICADE = RESTRICTIONS.NOCONTROLPANELBARRICADE;
pub const REST_NOSTARTPAGE = RESTRICTIONS.NOSTARTPAGE;
pub const REST_NOAUTOTRAYNOTIFY = RESTRICTIONS.NOAUTOTRAYNOTIFY;
pub const REST_NOTASKGROUPING = RESTRICTIONS.NOTASKGROUPING;
pub const REST_NOCDBURNING = RESTRICTIONS.NOCDBURNING;
pub const REST_MYCOMPNOPROP = RESTRICTIONS.MYCOMPNOPROP;
pub const REST_MYDOCSNOPROP = RESTRICTIONS.MYDOCSNOPROP;
pub const REST_NOSTARTPANEL = RESTRICTIONS.NOSTARTPANEL;
pub const REST_NODISPLAYAPPEARANCEPAGE = RESTRICTIONS.NODISPLAYAPPEARANCEPAGE;
pub const REST_NOTHEMESTAB = RESTRICTIONS.NOTHEMESTAB;
pub const REST_NOVISUALSTYLECHOICE = RESTRICTIONS.NOVISUALSTYLECHOICE;
pub const REST_NOSIZECHOICE = RESTRICTIONS.NOSIZECHOICE;
pub const REST_NOCOLORCHOICE = RESTRICTIONS.NOCOLORCHOICE;
pub const REST_SETVISUALSTYLE = RESTRICTIONS.SETVISUALSTYLE;
pub const REST_STARTRUNNOHOMEPATH = RESTRICTIONS.STARTRUNNOHOMEPATH;
pub const REST_NOUSERNAMEINSTARTPANEL = RESTRICTIONS.NOUSERNAMEINSTARTPANEL;
pub const REST_NOMYCOMPUTERICON = RESTRICTIONS.NOMYCOMPUTERICON;
pub const REST_NOSMNETWORKPLACES = RESTRICTIONS.NOSMNETWORKPLACES;
pub const REST_NOSMPINNEDLIST = RESTRICTIONS.NOSMPINNEDLIST;
pub const REST_NOSMMYMUSIC = RESTRICTIONS.NOSMMYMUSIC;
pub const REST_NOSMEJECTPC = RESTRICTIONS.NOSMEJECTPC;
pub const REST_NOSMMOREPROGRAMS = RESTRICTIONS.NOSMMOREPROGRAMS;
pub const REST_NOSMMFUPROGRAMS = RESTRICTIONS.NOSMMFUPROGRAMS;
pub const REST_NOTRAYITEMSDISPLAY = RESTRICTIONS.NOTRAYITEMSDISPLAY;
pub const REST_NOTOOLBARSONTASKBAR = RESTRICTIONS.NOTOOLBARSONTASKBAR;
pub const REST_NOSMCONFIGUREPROGRAMS = RESTRICTIONS.NOSMCONFIGUREPROGRAMS;
pub const REST_HIDECLOCK = RESTRICTIONS.HIDECLOCK;
pub const REST_NOLOWDISKSPACECHECKS = RESTRICTIONS.NOLOWDISKSPACECHECKS;
pub const REST_NOENTIRENETWORK = RESTRICTIONS.NOENTIRENETWORK;
pub const REST_NODESKTOPCLEANUP = RESTRICTIONS.NODESKTOPCLEANUP;
pub const REST_BITBUCKNUKEONDELETE = RESTRICTIONS.BITBUCKNUKEONDELETE;
pub const REST_BITBUCKCONFIRMDELETE = RESTRICTIONS.BITBUCKCONFIRMDELETE;
pub const REST_BITBUCKNOPROP = RESTRICTIONS.BITBUCKNOPROP;
pub const REST_NODISPBACKGROUND = RESTRICTIONS.NODISPBACKGROUND;
pub const REST_NODISPSCREENSAVEPG = RESTRICTIONS.NODISPSCREENSAVEPG;
pub const REST_NODISPSETTINGSPG = RESTRICTIONS.NODISPSETTINGSPG;
pub const REST_NODISPSCREENSAVEPREVIEW = RESTRICTIONS.NODISPSCREENSAVEPREVIEW;
pub const REST_NODISPLAYCPL = RESTRICTIONS.NODISPLAYCPL;
pub const REST_HIDERUNASVERB = RESTRICTIONS.HIDERUNASVERB;
pub const REST_NOTHUMBNAILCACHE = RESTRICTIONS.NOTHUMBNAILCACHE;
pub const REST_NOSTRCMPLOGICAL = RESTRICTIONS.NOSTRCMPLOGICAL;
pub const REST_NOPUBLISHWIZARD = RESTRICTIONS.NOPUBLISHWIZARD;
pub const REST_NOONLINEPRINTSWIZARD = RESTRICTIONS.NOONLINEPRINTSWIZARD;
pub const REST_NOWEBSERVICES = RESTRICTIONS.NOWEBSERVICES;
pub const REST_ALLOWUNHASHEDWEBVIEW = RESTRICTIONS.ALLOWUNHASHEDWEBVIEW;
pub const REST_ALLOWLEGACYWEBVIEW = RESTRICTIONS.ALLOWLEGACYWEBVIEW;
pub const REST_REVERTWEBVIEWSECURITY = RESTRICTIONS.REVERTWEBVIEWSECURITY;
pub const REST_INHERITCONSOLEHANDLES = RESTRICTIONS.INHERITCONSOLEHANDLES;
pub const REST_NOREMOTERECURSIVEEVENTS = RESTRICTIONS.NOREMOTERECURSIVEEVENTS;
pub const REST_NOREMOTECHANGENOTIFY = RESTRICTIONS.NOREMOTECHANGENOTIFY;
pub const REST_NOENUMENTIRENETWORK = RESTRICTIONS.NOENUMENTIRENETWORK;
pub const REST_NOINTERNETOPENWITH = RESTRICTIONS.NOINTERNETOPENWITH;
pub const REST_DONTRETRYBADNETNAME = RESTRICTIONS.DONTRETRYBADNETNAME;
pub const REST_ALLOWFILECLSIDJUNCTIONS = RESTRICTIONS.ALLOWFILECLSIDJUNCTIONS;
pub const REST_NOUPNPINSTALL = RESTRICTIONS.NOUPNPINSTALL;
pub const REST_ARP_DONTGROUPPATCHES = RESTRICTIONS.ARP_DONTGROUPPATCHES;
pub const REST_ARP_NOCHOOSEPROGRAMSPAGE = RESTRICTIONS.ARP_NOCHOOSEPROGRAMSPAGE;
pub const REST_NODISCONNECT = RESTRICTIONS.NODISCONNECT;
pub const REST_NOSECURITY = RESTRICTIONS.NOSECURITY;
pub const REST_NOFILEASSOCIATE = RESTRICTIONS.NOFILEASSOCIATE;
pub const REST_ALLOWCOMMENTTOGGLE = RESTRICTIONS.ALLOWCOMMENTTOGGLE;

pub const OPEN_AS_INFO_FLAGS = enum(u32) {
    ALLOW_REGISTRATION = 1,
    REGISTER_EXT = 2,
    EXEC = 4,
    FORCE_REGISTRATION = 8,
    HIDE_REGISTRATION = 32,
    URL_PROTOCOL = 64,
    FILE_IS_URI = 128,
    _,
    pub fn initFlags(o: struct {
        ALLOW_REGISTRATION: u1 = 0,
        REGISTER_EXT: u1 = 0,
        EXEC: u1 = 0,
        FORCE_REGISTRATION: u1 = 0,
        HIDE_REGISTRATION: u1 = 0,
        URL_PROTOCOL: u1 = 0,
        FILE_IS_URI: u1 = 0,
    }) OPEN_AS_INFO_FLAGS {
        return @intToEnum(OPEN_AS_INFO_FLAGS,
              (if (o.ALLOW_REGISTRATION == 1) @enumToInt(OPEN_AS_INFO_FLAGS.ALLOW_REGISTRATION) else 0)
            | (if (o.REGISTER_EXT == 1) @enumToInt(OPEN_AS_INFO_FLAGS.REGISTER_EXT) else 0)
            | (if (o.EXEC == 1) @enumToInt(OPEN_AS_INFO_FLAGS.EXEC) else 0)
            | (if (o.FORCE_REGISTRATION == 1) @enumToInt(OPEN_AS_INFO_FLAGS.FORCE_REGISTRATION) else 0)
            | (if (o.HIDE_REGISTRATION == 1) @enumToInt(OPEN_AS_INFO_FLAGS.HIDE_REGISTRATION) else 0)
            | (if (o.URL_PROTOCOL == 1) @enumToInt(OPEN_AS_INFO_FLAGS.URL_PROTOCOL) else 0)
            | (if (o.FILE_IS_URI == 1) @enumToInt(OPEN_AS_INFO_FLAGS.FILE_IS_URI) else 0)
        );
    }
};
pub const OAIF_ALLOW_REGISTRATION = OPEN_AS_INFO_FLAGS.ALLOW_REGISTRATION;
pub const OAIF_REGISTER_EXT = OPEN_AS_INFO_FLAGS.REGISTER_EXT;
pub const OAIF_EXEC = OPEN_AS_INFO_FLAGS.EXEC;
pub const OAIF_FORCE_REGISTRATION = OPEN_AS_INFO_FLAGS.FORCE_REGISTRATION;
pub const OAIF_HIDE_REGISTRATION = OPEN_AS_INFO_FLAGS.HIDE_REGISTRATION;
pub const OAIF_URL_PROTOCOL = OPEN_AS_INFO_FLAGS.URL_PROTOCOL;
pub const OAIF_FILE_IS_URI = OPEN_AS_INFO_FLAGS.FILE_IS_URI;

pub const OPENASINFO = extern struct {
    pcszFile: ?[*:0]const u16,
    pcszClass: ?[*:0]const u16,
    oaifInFlags: OPEN_AS_INFO_FLAGS,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IShellFolderViewCB_Value = @import("../zig.zig").Guid.initString("2047e320-f2a9-11ce-ae65-08002b2e1262");
pub const IID_IShellFolderViewCB = &IID_IShellFolderViewCB_Value;
pub const IShellFolderViewCB = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MessageSFVCB: fn(
            self: *const IShellFolderViewCB,
            uMsg: SFVM_MESSAGE_ID,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderViewCB_MessageSFVCB(self: *const T, uMsg: SFVM_MESSAGE_ID, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderViewCB.VTable, self.vtable).MessageSFVCB(@ptrCast(*const IShellFolderViewCB, self), uMsg, wParam, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const QCMINFO_IDMAP_PLACEMENT = extern struct {
    id: u32,
    fFlags: u32,
};

pub const QCMINFO_IDMAP = extern struct {
    nMaxIds: u32,
    pIdList: [1]QCMINFO_IDMAP_PLACEMENT,
};

pub const QCMINFO = extern struct {
    hmenu: ?HMENU,
    indexMenu: u32,
    idCmdFirst: u32,
    idCmdLast: u32,
    pIdMap: ?*const QCMINFO_IDMAP,
};

pub const DETAILSINFO = extern struct {
    pidl: ?*ITEMIDLIST,
    fmt: i32,
    cxChar: i32,
    str: STRRET,
    iImage: i32,
};

pub const SFVM_PROPPAGE_DATA = extern struct {
    dwReserved: u32,
    pfn: ?LPFNSVADDPROPSHEETPAGE,
    lParam: LPARAM,
};

pub const SFVM_HELPTOPIC_DATA = extern struct {
    wszHelpFile: [260]u16,
    wszHelpTopic: [260]u16,
};

pub const ITEMSPACING = extern struct {
    cxSmall: i32,
    cySmall: i32,
    cxLarge: i32,
    cyLarge: i32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolderView_Value = @import("../zig.zig").Guid.initString("37a378c0-f82d-11ce-ae65-08002b2e1262");
pub const IID_IShellFolderView = &IID_IShellFolderView_Value;
pub const IShellFolderView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Rearrange: fn(
            self: *const IShellFolderView,
            lParamSort: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetArrangeParam: fn(
            self: *const IShellFolderView,
            plParamSort: ?*LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ArrangeGrid: fn(
            self: *const IShellFolderView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoArrange: fn(
            self: *const IShellFolderView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutoArrange: fn(
            self: *const IShellFolderView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddObject: fn(
            self: *const IShellFolderView,
            pidl: ?*ITEMIDLIST,
            puItem: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const IShellFolderView,
            ppidl: ?*?*ITEMIDLIST,
            uItem: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveObject: fn(
            self: *const IShellFolderView,
            pidl: ?*ITEMIDLIST,
            puItem: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectCount: fn(
            self: *const IShellFolderView,
            puCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetObjectCount: fn(
            self: *const IShellFolderView,
            uCount: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateObject: fn(
            self: *const IShellFolderView,
            pidlOld: ?*ITEMIDLIST,
            pidlNew: ?*ITEMIDLIST,
            puItem: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RefreshObject: fn(
            self: *const IShellFolderView,
            pidl: ?*ITEMIDLIST,
            puItem: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRedraw: fn(
            self: *const IShellFolderView,
            bRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedCount: fn(
            self: *const IShellFolderView,
            puSelected: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedObjects: fn(
            self: *const IShellFolderView,
            pppidl: ?*?*?*ITEMIDLIST,
            puItems: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDropOnSource: fn(
            self: *const IShellFolderView,
            pDropTarget: ?*IDropTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDragPoint: fn(
            self: *const IShellFolderView,
            ppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropPoint: fn(
            self: *const IShellFolderView,
            ppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveIcons: fn(
            self: *const IShellFolderView,
            pDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItemPos: fn(
            self: *const IShellFolderView,
            pidl: ?*ITEMIDLIST,
            ppt: ?*POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsBkDropTarget: fn(
            self: *const IShellFolderView,
            pDropTarget: ?*IDropTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClipboard: fn(
            self: *const IShellFolderView,
            bMove: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPoints: fn(
            self: *const IShellFolderView,
            pDataObject: ?*IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemSpacing: fn(
            self: *const IShellFolderView,
            pSpacing: ?*ITEMSPACING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCallback: fn(
            self: *const IShellFolderView,
            pNewCB: ?*IShellFolderViewCB,
            ppOldCB: ?*?*IShellFolderViewCB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const IShellFolderView,
            dwFlags: SFVS_SELECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QuerySupport: fn(
            self: *const IShellFolderView,
            pdwSupport: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutomationObject: fn(
            self: *const IShellFolderView,
            pdisp: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_Rearrange(self: *const T, lParamSort: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).Rearrange(@ptrCast(*const IShellFolderView, self), lParamSort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_GetArrangeParam(self: *const T, plParamSort: ?*LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).GetArrangeParam(@ptrCast(*const IShellFolderView, self), plParamSort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_ArrangeGrid(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).ArrangeGrid(@ptrCast(*const IShellFolderView, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_AutoArrange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).AutoArrange(@ptrCast(*const IShellFolderView, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_GetAutoArrange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).GetAutoArrange(@ptrCast(*const IShellFolderView, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_AddObject(self: *const T, pidl: ?*ITEMIDLIST, puItem: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).AddObject(@ptrCast(*const IShellFolderView, self), pidl, puItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_GetObject(self: *const T, ppidl: ?*?*ITEMIDLIST, uItem: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).GetObject(@ptrCast(*const IShellFolderView, self), ppidl, uItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_RemoveObject(self: *const T, pidl: ?*ITEMIDLIST, puItem: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).RemoveObject(@ptrCast(*const IShellFolderView, self), pidl, puItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_GetObjectCount(self: *const T, puCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).GetObjectCount(@ptrCast(*const IShellFolderView, self), puCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_SetObjectCount(self: *const T, uCount: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).SetObjectCount(@ptrCast(*const IShellFolderView, self), uCount, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_UpdateObject(self: *const T, pidlOld: ?*ITEMIDLIST, pidlNew: ?*ITEMIDLIST, puItem: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).UpdateObject(@ptrCast(*const IShellFolderView, self), pidlOld, pidlNew, puItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_RefreshObject(self: *const T, pidl: ?*ITEMIDLIST, puItem: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).RefreshObject(@ptrCast(*const IShellFolderView, self), pidl, puItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_SetRedraw(self: *const T, bRedraw: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).SetRedraw(@ptrCast(*const IShellFolderView, self), bRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_GetSelectedCount(self: *const T, puSelected: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).GetSelectedCount(@ptrCast(*const IShellFolderView, self), puSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_GetSelectedObjects(self: *const T, pppidl: ?*?*?*ITEMIDLIST, puItems: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).GetSelectedObjects(@ptrCast(*const IShellFolderView, self), pppidl, puItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_IsDropOnSource(self: *const T, pDropTarget: ?*IDropTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).IsDropOnSource(@ptrCast(*const IShellFolderView, self), pDropTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_GetDragPoint(self: *const T, ppt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).GetDragPoint(@ptrCast(*const IShellFolderView, self), ppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_GetDropPoint(self: *const T, ppt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).GetDropPoint(@ptrCast(*const IShellFolderView, self), ppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_MoveIcons(self: *const T, pDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).MoveIcons(@ptrCast(*const IShellFolderView, self), pDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_SetItemPos(self: *const T, pidl: ?*ITEMIDLIST, ppt: ?*POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).SetItemPos(@ptrCast(*const IShellFolderView, self), pidl, ppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_IsBkDropTarget(self: *const T, pDropTarget: ?*IDropTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).IsBkDropTarget(@ptrCast(*const IShellFolderView, self), pDropTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_SetClipboard(self: *const T, bMove: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).SetClipboard(@ptrCast(*const IShellFolderView, self), bMove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_SetPoints(self: *const T, pDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).SetPoints(@ptrCast(*const IShellFolderView, self), pDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_GetItemSpacing(self: *const T, pSpacing: ?*ITEMSPACING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).GetItemSpacing(@ptrCast(*const IShellFolderView, self), pSpacing);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_SetCallback(self: *const T, pNewCB: ?*IShellFolderViewCB, ppOldCB: ?*?*IShellFolderViewCB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).SetCallback(@ptrCast(*const IShellFolderView, self), pNewCB, ppOldCB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_Select(self: *const T, dwFlags: SFVS_SELECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).Select(@ptrCast(*const IShellFolderView, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_QuerySupport(self: *const T, pdwSupport: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).QuerySupport(@ptrCast(*const IShellFolderView, self), pdwSupport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderView_SetAutomationObject(self: *const T, pdisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderView.VTable, self.vtable).SetAutomationObject(@ptrCast(*const IShellFolderView, self), pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SFV_CREATE = extern struct {
    cbSize: u32,
    pshf: ?*IShellFolder,
    psvOuter: ?*IShellView,
    psfvcb: ?*IShellFolderViewCB,
};

pub const LPFNDFMCALLBACK = fn(
    psf: ?*IShellFolder,
    hwnd: ?HWND,
    pdtobj: ?*IDataObject,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DEFCONTEXTMENU = extern struct {
    hwnd: ?HWND,
    pcmcb: ?*IContextMenuCB,
    pidlFolder: ?*ITEMIDLIST,
    psf: ?*IShellFolder,
    cidl: u32,
    apidl: ?*?*ITEMIDLIST,
    punkAssociationInfo: ?*IUnknown,
    cKeys: u32,
    aKeys: ?*const ?HKEY,
};

pub const DFMICS = extern struct {
    cbSize: u32,
    fMask: u32,
    lParam: LPARAM,
    idCmdFirst: u32,
    idDefMax: u32,
    pici: ?*CMINVOKECOMMANDINFO,
    punkSite: ?*IUnknown,
};

pub const LPFNVIEWCALLBACK = fn(
    psvOuter: ?*IShellView,
    psf: ?*IShellFolder,
    hwndMain: ?HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const CSFV = extern struct {
    cbSize: u32,
    pshf: ?*IShellFolder,
    psvOuter: ?*IShellView,
    pidl: ?*ITEMIDLIST,
    lEvents: i32,
    pfnCallback: ?LPFNVIEWCALLBACK,
    fvm: FOLDERVIEWMODE,
};

pub const SHELLSTATEA = packed struct {
    _bitfield1: i32,
    dwWin95Unused: u32,
    uWin95Unused: u32,
    lParamSort: i32,
    iSortDirection: i32,
    version: u32,
    uNotUsed: u32,
    _bitfield2: i32,
};

pub const SHELLSTATEW = packed struct {
    _bitfield1: i32,
    dwWin95Unused: u32,
    uWin95Unused: u32,
    lParamSort: i32,
    iSortDirection: i32,
    version: u32,
    uNotUsed: u32,
    _bitfield2: i32,
};

pub const SHELLFLAGSTATE = packed struct {
    _bitfield: i32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INamedPropertyBag_Value = @import("../zig.zig").Guid.initString("fb700430-952c-11d1-946f-000000000000");
pub const IID_INamedPropertyBag = &IID_INamedPropertyBag_Value;
pub const INamedPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadPropertyNPB: fn(
            self: *const INamedPropertyBag,
            pszBagname: ?[*:0]const u16,
            pszPropName: ?[*:0]const u16,
            pVar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePropertyNPB: fn(
            self: *const INamedPropertyBag,
            pszBagname: ?[*:0]const u16,
            pszPropName: ?[*:0]const u16,
            pVar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePropertyNPB: fn(
            self: *const INamedPropertyBag,
            pszBagname: ?[*:0]const u16,
            pszPropName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamedPropertyBag_ReadPropertyNPB(self: *const T, pszBagname: ?[*:0]const u16, pszPropName: ?[*:0]const u16, pVar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamedPropertyBag.VTable, self.vtable).ReadPropertyNPB(@ptrCast(*const INamedPropertyBag, self), pszBagname, pszPropName, pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamedPropertyBag_WritePropertyNPB(self: *const T, pszBagname: ?[*:0]const u16, pszPropName: ?[*:0]const u16, pVar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamedPropertyBag.VTable, self.vtable).WritePropertyNPB(@ptrCast(*const INamedPropertyBag, self), pszBagname, pszPropName, pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamedPropertyBag_RemovePropertyNPB(self: *const T, pszBagname: ?[*:0]const u16, pszPropName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamedPropertyBag.VTable, self.vtable).RemovePropertyNPB(@ptrCast(*const INamedPropertyBag, self), pszBagname, pszPropName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IESHORTCUTFLAGS = enum(i32) {
    NEWBROWSER = 1,
    OPENNEWTAB = 2,
    FORCENAVIGATE = 4,
    BACKGROUNDTAB = 8,
};
pub const IESHORTCUT_NEWBROWSER = IESHORTCUTFLAGS.NEWBROWSER;
pub const IESHORTCUT_OPENNEWTAB = IESHORTCUTFLAGS.OPENNEWTAB;
pub const IESHORTCUT_FORCENAVIGATE = IESHORTCUTFLAGS.FORCENAVIGATE;
pub const IESHORTCUT_BACKGROUNDTAB = IESHORTCUTFLAGS.BACKGROUNDTAB;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INewShortcutHookA_Value = @import("../zig.zig").Guid.initString("000214e1-0000-0000-c000-000000000046");
pub const IID_INewShortcutHookA = &IID_INewShortcutHookA_Value;
pub const INewShortcutHookA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetReferent: fn(
            self: *const INewShortcutHookA,
            pcszReferent: ?[*:0]const u8,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReferent: fn(
            self: *const INewShortcutHookA,
            pszReferent: [*:0]u8,
            cchReferent: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFolder: fn(
            self: *const INewShortcutHookA,
            pcszFolder: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolder: fn(
            self: *const INewShortcutHookA,
            pszFolder: [*:0]u8,
            cchFolder: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const INewShortcutHookA,
            pszName: [*:0]u8,
            cchName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtension: fn(
            self: *const INewShortcutHookA,
            pszExtension: [*:0]u8,
            cchExtension: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookA_SetReferent(self: *const T, pcszReferent: ?[*:0]const u8, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookA.VTable, self.vtable).SetReferent(@ptrCast(*const INewShortcutHookA, self), pcszReferent, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookA_GetReferent(self: *const T, pszReferent: [*:0]u8, cchReferent: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookA.VTable, self.vtable).GetReferent(@ptrCast(*const INewShortcutHookA, self), pszReferent, cchReferent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookA_SetFolder(self: *const T, pcszFolder: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookA.VTable, self.vtable).SetFolder(@ptrCast(*const INewShortcutHookA, self), pcszFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookA_GetFolder(self: *const T, pszFolder: [*:0]u8, cchFolder: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookA.VTable, self.vtable).GetFolder(@ptrCast(*const INewShortcutHookA, self), pszFolder, cchFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookA_GetName(self: *const T, pszName: [*:0]u8, cchName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookA.VTable, self.vtable).GetName(@ptrCast(*const INewShortcutHookA, self), pszName, cchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookA_GetExtension(self: *const T, pszExtension: [*:0]u8, cchExtension: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookA.VTable, self.vtable).GetExtension(@ptrCast(*const INewShortcutHookA, self), pszExtension, cchExtension);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_INewShortcutHookW_Value = @import("../zig.zig").Guid.initString("000214f7-0000-0000-c000-000000000046");
pub const IID_INewShortcutHookW = &IID_INewShortcutHookW_Value;
pub const INewShortcutHookW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetReferent: fn(
            self: *const INewShortcutHookW,
            pcszReferent: ?[*:0]const u16,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReferent: fn(
            self: *const INewShortcutHookW,
            pszReferent: [*:0]u16,
            cchReferent: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFolder: fn(
            self: *const INewShortcutHookW,
            pcszFolder: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolder: fn(
            self: *const INewShortcutHookW,
            pszFolder: [*:0]u16,
            cchFolder: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const INewShortcutHookW,
            pszName: [*:0]u16,
            cchName: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtension: fn(
            self: *const INewShortcutHookW,
            pszExtension: [*:0]u16,
            cchExtension: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookW_SetReferent(self: *const T, pcszReferent: ?[*:0]const u16, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookW.VTable, self.vtable).SetReferent(@ptrCast(*const INewShortcutHookW, self), pcszReferent, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookW_GetReferent(self: *const T, pszReferent: [*:0]u16, cchReferent: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookW.VTable, self.vtable).GetReferent(@ptrCast(*const INewShortcutHookW, self), pszReferent, cchReferent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookW_SetFolder(self: *const T, pcszFolder: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookW.VTable, self.vtable).SetFolder(@ptrCast(*const INewShortcutHookW, self), pcszFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookW_GetFolder(self: *const T, pszFolder: [*:0]u16, cchFolder: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookW.VTable, self.vtable).GetFolder(@ptrCast(*const INewShortcutHookW, self), pszFolder, cchFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookW_GetName(self: *const T, pszName: [*:0]u16, cchName: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookW.VTable, self.vtable).GetName(@ptrCast(*const INewShortcutHookW, self), pszName, cchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INewShortcutHookW_GetExtension(self: *const T, pszExtension: [*:0]u16, cchExtension: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const INewShortcutHookW.VTable, self.vtable).GetExtension(@ptrCast(*const INewShortcutHookW, self), pszExtension, cchExtension);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICopyHookA_Value = @import("../zig.zig").Guid.initString("000214ef-0000-0000-c000-000000000046");
pub const IID_ICopyHookA = &IID_ICopyHookA_Value;
pub const ICopyHookA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CopyCallback: fn(
            self: *const ICopyHookA,
            hwnd: ?HWND,
            wFunc: u32,
            wFlags: u32,
            pszSrcFile: ?[*:0]const u8,
            dwSrcAttribs: u32,
            pszDestFile: ?[*:0]const u8,
            dwDestAttribs: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICopyHookA_CopyCallback(self: *const T, hwnd: ?HWND, wFunc: u32, wFlags: u32, pszSrcFile: ?[*:0]const u8, dwSrcAttribs: u32, pszDestFile: ?[*:0]const u8, dwDestAttribs: u32) callconv(.Inline) u32 {
            return @ptrCast(*const ICopyHookA.VTable, self.vtable).CopyCallback(@ptrCast(*const ICopyHookA, self), hwnd, wFunc, wFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICopyHookW_Value = @import("../zig.zig").Guid.initString("000214fc-0000-0000-c000-000000000046");
pub const IID_ICopyHookW = &IID_ICopyHookW_Value;
pub const ICopyHookW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CopyCallback: fn(
            self: *const ICopyHookW,
            hwnd: ?HWND,
            wFunc: u32,
            wFlags: u32,
            pszSrcFile: ?[*:0]const u16,
            dwSrcAttribs: u32,
            pszDestFile: ?[*:0]const u16,
            dwDestAttribs: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICopyHookW_CopyCallback(self: *const T, hwnd: ?HWND, wFunc: u32, wFlags: u32, pszSrcFile: ?[*:0]const u16, dwSrcAttribs: u32, pszDestFile: ?[*:0]const u16, dwDestAttribs: u32) callconv(.Inline) u32 {
            return @ptrCast(*const ICopyHookW.VTable, self.vtable).CopyCallback(@ptrCast(*const ICopyHookW, self), hwnd, wFunc, wFlags, pszSrcFile, dwSrcAttribs, pszDestFile, dwDestAttribs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICurrentWorkingDirectory_Value = @import("../zig.zig").Guid.initString("91956d21-9276-11d1-921a-006097df5bd4");
pub const IID_ICurrentWorkingDirectory = &IID_ICurrentWorkingDirectory_Value;
pub const ICurrentWorkingDirectory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectory: fn(
            self: *const ICurrentWorkingDirectory,
            pwzPath: [*:0]u16,
            cchSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDirectory: fn(
            self: *const ICurrentWorkingDirectory,
            pwzPath: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICurrentWorkingDirectory_GetDirectory(self: *const T, pwzPath: [*:0]u16, cchSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICurrentWorkingDirectory.VTable, self.vtable).GetDirectory(@ptrCast(*const ICurrentWorkingDirectory, self), pwzPath, cchSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICurrentWorkingDirectory_SetDirectory(self: *const T, pwzPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICurrentWorkingDirectory.VTable, self.vtable).SetDirectory(@ptrCast(*const ICurrentWorkingDirectory, self), pwzPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDockingWindowFrame_Value = @import("../zig.zig").Guid.initString("47d2657a-7b27-11d0-8ca9-00a0c92dbfe8");
pub const IID_IDockingWindowFrame = &IID_IDockingWindowFrame_Value;
pub const IDockingWindowFrame = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        AddToolbar: fn(
            self: *const IDockingWindowFrame,
            punkSrc: ?*IUnknown,
            pwszItem: ?[*:0]const u16,
            dwAddFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveToolbar: fn(
            self: *const IDockingWindowFrame,
            punkSrc: ?*IUnknown,
            dwRemoveFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindToolbar: fn(
            self: *const IDockingWindowFrame,
            pwszItem: ?[*:0]const u16,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockingWindowFrame_AddToolbar(self: *const T, punkSrc: ?*IUnknown, pwszItem: ?[*:0]const u16, dwAddFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockingWindowFrame.VTable, self.vtable).AddToolbar(@ptrCast(*const IDockingWindowFrame, self), punkSrc, pwszItem, dwAddFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockingWindowFrame_RemoveToolbar(self: *const T, punkSrc: ?*IUnknown, dwRemoveFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockingWindowFrame.VTable, self.vtable).RemoveToolbar(@ptrCast(*const IDockingWindowFrame, self), punkSrc, dwRemoveFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockingWindowFrame_FindToolbar(self: *const T, pwszItem: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockingWindowFrame.VTable, self.vtable).FindToolbar(@ptrCast(*const IDockingWindowFrame, self), pwszItem, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IThumbnailCapture_Value = @import("../zig.zig").Guid.initString("4ea39266-7211-409f-b622-f63dbd16c533");
pub const IID_IThumbnailCapture = &IID_IThumbnailCapture_Value;
pub const IThumbnailCapture = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CaptureThumbnail: fn(
            self: *const IThumbnailCapture,
            pMaxSize: ?*const SIZE,
            pHTMLDoc2: ?*IUnknown,
            phbmThumbnail: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailCapture_CaptureThumbnail(self: *const T, pMaxSize: ?*const SIZE, pHTMLDoc2: ?*IUnknown, phbmThumbnail: ?*?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailCapture.VTable, self.vtable).CaptureThumbnail(@ptrCast(*const IThumbnailCapture, self), pMaxSize, pHTMLDoc2, phbmThumbnail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BANDINFOSFB = extern struct {
    dwMask: u32,
    dwStateMask: u32,
    dwState: u32,
    crBkgnd: u32,
    crBtnLt: u32,
    crBtnDk: u32,
    wViewMode: u16,
    wAlign: u16,
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellFolderBand_Value = @import("../zig.zig").Guid.initString("7fe80cc8-c247-11d0-b93a-00a0c90312e1");
pub const IID_IShellFolderBand = &IID_IShellFolderBand_Value;
pub const IShellFolderBand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeSFB: fn(
            self: *const IShellFolderBand,
            psf: ?*IShellFolder,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBandInfoSFB: fn(
            self: *const IShellFolderBand,
            pbi: ?*BANDINFOSFB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBandInfoSFB: fn(
            self: *const IShellFolderBand,
            pbi: ?*BANDINFOSFB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderBand_InitializeSFB(self: *const T, psf: ?*IShellFolder, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderBand.VTable, self.vtable).InitializeSFB(@ptrCast(*const IShellFolderBand, self), psf, pidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderBand_SetBandInfoSFB(self: *const T, pbi: ?*BANDINFOSFB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderBand.VTable, self.vtable).SetBandInfoSFB(@ptrCast(*const IShellFolderBand, self), pbi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFolderBand_GetBandInfoSFB(self: *const T, pbi: ?*BANDINFOSFB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFolderBand.VTable, self.vtable).GetBandInfoSFB(@ptrCast(*const IShellFolderBand, self), pbi);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDeskBarClient_Value = @import("../zig.zig").Guid.initString("eb0fe175-1a3a-11d0-89b3-00a0c90a90ac");
pub const IID_IDeskBarClient = &IID_IDeskBarClient_Value;
pub const IDeskBarClient = extern struct {
    pub const VTable = extern struct {
        base: IOleWindow.VTable,
        SetDeskBarSite: fn(
            self: *const IDeskBarClient,
            punkSite: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModeDBC: fn(
            self: *const IDeskBarClient,
            dwMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UIActivateDBC: fn(
            self: *const IDeskBarClient,
            dwState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IDeskBarClient,
            dwWhich: u32,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleWindow.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBarClient_SetDeskBarSite(self: *const T, punkSite: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBarClient.VTable, self.vtable).SetDeskBarSite(@ptrCast(*const IDeskBarClient, self), punkSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBarClient_SetModeDBC(self: *const T, dwMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBarClient.VTable, self.vtable).SetModeDBC(@ptrCast(*const IDeskBarClient, self), dwMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBarClient_UIActivateDBC(self: *const T, dwState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBarClient.VTable, self.vtable).UIActivateDBC(@ptrCast(*const IDeskBarClient, self), dwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeskBarClient_GetSize(self: *const T, dwWhich: u32, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeskBarClient.VTable, self.vtable).GetSize(@ptrCast(*const IDeskBarClient, self), dwWhich, prc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHCOLUMNINFO = packed struct {
    scid: PROPERTYKEY,
    vt: u16,
    fmt: u32,
    cChars: u32,
    csFlags: u32,
    wszTitle: [80]u16,
    wszDescription: [128]u16,
};

pub const SHCOLUMNINIT = extern struct {
    dwFlags: u32,
    dwReserved: u32,
    wszFolder: [260]u16,
};

pub const SHCOLUMNDATA = extern struct {
    dwFlags: u32,
    dwFileAttributes: u32,
    dwReserved: u32,
    pwszExt: ?PWSTR,
    wszFile: [260]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IColumnProvider_Value = @import("../zig.zig").Guid.initString("e8025004-1c42-11d2-be2c-00a0c9a83da1");
pub const IID_IColumnProvider = &IID_IColumnProvider_Value;
pub const IColumnProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IColumnProvider,
            psci: ?*SHCOLUMNINIT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnInfo: fn(
            self: *const IColumnProvider,
            dwIndex: u32,
            psci: ?*SHCOLUMNINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemData: fn(
            self: *const IColumnProvider,
            pscid: ?*PROPERTYKEY,
            pscd: ?*SHCOLUMNDATA,
            pvarData: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnProvider_Initialize(self: *const T, psci: ?*SHCOLUMNINIT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnProvider.VTable, self.vtable).Initialize(@ptrCast(*const IColumnProvider, self), psci);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnProvider_GetColumnInfo(self: *const T, dwIndex: u32, psci: ?*SHCOLUMNINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnProvider.VTable, self.vtable).GetColumnInfo(@ptrCast(*const IColumnProvider, self), dwIndex, psci);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnProvider_GetItemData(self: *const T, pscid: ?*PROPERTYKEY, pscd: ?*SHCOLUMNDATA, pvarData: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnProvider.VTable, self.vtable).GetItemData(@ptrCast(*const IColumnProvider, self), pscid, pscd, pvarData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHChangeProductKeyAsIDList = packed struct {
    cb: u16,
    wszProductKey: [39]u16,
    cbZero: u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDocViewSite_Value = @import("../zig.zig").Guid.initString("87d605e0-c511-11cf-89a9-00a0c9054129");
pub const IID_IDocViewSite = &IID_IDocViewSite_Value;
pub const IDocViewSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSetTitle: fn(
            self: *const IDocViewSite,
            pvTitle: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocViewSite_OnSetTitle(self: *const T, pvTitle: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocViewSite.VTable, self.vtable).OnSetTitle(@ptrCast(*const IDocViewSite, self), pvTitle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInitializeObject_Value = @import("../zig.zig").Guid.initString("4622ad16-ff23-11d0-8d34-00a0c90f2719");
pub const IID_IInitializeObject = &IID_IInitializeObject_Value;
pub const IInitializeObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IInitializeObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInitializeObject_Initialize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInitializeObject.VTable, self.vtable).Initialize(@ptrCast(*const IInitializeObject, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBanneredBar_Value = @import("../zig.zig").Guid.initString("596a9a94-013e-11d1-8d34-00a0c90f2719");
pub const IID_IBanneredBar = &IID_IBanneredBar_Value;
pub const IBanneredBar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIconSize: fn(
            self: *const IBanneredBar,
            iIcon: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconSize: fn(
            self: *const IBanneredBar,
            piIcon: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBitmap: fn(
            self: *const IBanneredBar,
            hBitmap: ?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBitmap: fn(
            self: *const IBanneredBar,
            phBitmap: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBanneredBar_SetIconSize(self: *const T, iIcon: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBanneredBar.VTable, self.vtable).SetIconSize(@ptrCast(*const IBanneredBar, self), iIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBanneredBar_GetIconSize(self: *const T, piIcon: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBanneredBar.VTable, self.vtable).GetIconSize(@ptrCast(*const IBanneredBar, self), piIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBanneredBar_SetBitmap(self: *const T, hBitmap: ?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBanneredBar.VTable, self.vtable).SetBitmap(@ptrCast(*const IBanneredBar, self), hBitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBanneredBar_GetBitmap(self: *const T, phBitmap: ?*?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBanneredBar.VTable, self.vtable).GetBitmap(@ptrCast(*const IBanneredBar, self), phBitmap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TBINFO = extern struct {
    cbuttons: u32,
    uFlags: u32,
};

pub const SFV_SETITEMPOS = extern struct {
    pidl: ?*ITEMIDLIST,
    pt: POINT,
};

pub const AASHELLMENUFILENAME = extern struct {
    cbTotal: i16,
    rgbReserved: [12]u8,
    szFileName: [1]u16,
};

pub const AASHELLMENUITEM = extern struct {
    lpReserved1: ?*anyopaque,
    iReserved: i32,
    uiReserved: u32,
    lpName: ?*AASHELLMENUFILENAME,
    psz: ?PWSTR,
};

pub const DISPLAY_DEVICE_TYPE = enum(i32) {
    PRIMARY = 0,
    IMMERSIVE = 1,
};
pub const DEVICE_PRIMARY = DISPLAY_DEVICE_TYPE.PRIMARY;
pub const DEVICE_IMMERSIVE = DISPLAY_DEVICE_TYPE.IMMERSIVE;

pub const SCALE_CHANGE_FLAGS = enum(u32) {
    VALUE_NONE = 0,
    SCALE = 1,
    PHYSICAL = 2,
    _,
    pub fn initFlags(o: struct {
        VALUE_NONE: u1 = 0,
        SCALE: u1 = 0,
        PHYSICAL: u1 = 0,
    }) SCALE_CHANGE_FLAGS {
        return @intToEnum(SCALE_CHANGE_FLAGS,
              (if (o.VALUE_NONE == 1) @enumToInt(SCALE_CHANGE_FLAGS.VALUE_NONE) else 0)
            | (if (o.SCALE == 1) @enumToInt(SCALE_CHANGE_FLAGS.SCALE) else 0)
            | (if (o.PHYSICAL == 1) @enumToInt(SCALE_CHANGE_FLAGS.PHYSICAL) else 0)
        );
    }
};
pub const SCF_VALUE_NONE = SCALE_CHANGE_FLAGS.VALUE_NONE;
pub const SCF_SCALE = SCALE_CHANGE_FLAGS.SCALE;
pub const SCF_PHYSICAL = SCALE_CHANGE_FLAGS.PHYSICAL;

pub const SHELL_UI_COMPONENT = enum(i32) {
    TASKBARS = 0,
    NOTIFICATIONAREA = 1,
    DESKBAND = 2,
};
pub const SHELL_UI_COMPONENT_TASKBARS = SHELL_UI_COMPONENT.TASKBARS;
pub const SHELL_UI_COMPONENT_NOTIFICATIONAREA = SHELL_UI_COMPONENT.NOTIFICATIONAREA;
pub const SHELL_UI_COMPONENT_DESKBAND = SHELL_UI_COMPONENT.DESKBAND;











pub const ASSOCCLASS = enum(i32) {
    SHELL_KEY = 0,
    PROGID_KEY = 1,
    PROGID_STR = 2,
    CLSID_KEY = 3,
    CLSID_STR = 4,
    APP_KEY = 5,
    APP_STR = 6,
    SYSTEM_STR = 7,
    FOLDER = 8,
    STAR = 9,
    FIXED_PROGID_STR = 10,
    PROTOCOL_STR = 11,
};
pub const ASSOCCLASS_SHELL_KEY = ASSOCCLASS.SHELL_KEY;
pub const ASSOCCLASS_PROGID_KEY = ASSOCCLASS.PROGID_KEY;
pub const ASSOCCLASS_PROGID_STR = ASSOCCLASS.PROGID_STR;
pub const ASSOCCLASS_CLSID_KEY = ASSOCCLASS.CLSID_KEY;
pub const ASSOCCLASS_CLSID_STR = ASSOCCLASS.CLSID_STR;
pub const ASSOCCLASS_APP_KEY = ASSOCCLASS.APP_KEY;
pub const ASSOCCLASS_APP_STR = ASSOCCLASS.APP_STR;
pub const ASSOCCLASS_SYSTEM_STR = ASSOCCLASS.SYSTEM_STR;
pub const ASSOCCLASS_FOLDER = ASSOCCLASS.FOLDER;
pub const ASSOCCLASS_STAR = ASSOCCLASS.STAR;
pub const ASSOCCLASS_FIXED_PROGID_STR = ASSOCCLASS.FIXED_PROGID_STR;
pub const ASSOCCLASS_PROTOCOL_STR = ASSOCCLASS.PROTOCOL_STR;



pub const QUERY_USER_NOTIFICATION_STATE = enum(i32) {
    NOT_PRESENT = 1,
    BUSY = 2,
    RUNNING_D3D_FULL_SCREEN = 3,
    PRESENTATION_MODE = 4,
    ACCEPTS_NOTIFICATIONS = 5,
    QUIET_TIME = 6,
    APP = 7,
};
pub const QUNS_NOT_PRESENT = QUERY_USER_NOTIFICATION_STATE.NOT_PRESENT;
pub const QUNS_BUSY = QUERY_USER_NOTIFICATION_STATE.BUSY;
pub const QUNS_RUNNING_D3D_FULL_SCREEN = QUERY_USER_NOTIFICATION_STATE.RUNNING_D3D_FULL_SCREEN;
pub const QUNS_PRESENTATION_MODE = QUERY_USER_NOTIFICATION_STATE.PRESENTATION_MODE;
pub const QUNS_ACCEPTS_NOTIFICATIONS = QUERY_USER_NOTIFICATION_STATE.ACCEPTS_NOTIFICATIONS;
pub const QUNS_QUIET_TIME = QUERY_USER_NOTIFICATION_STATE.QUIET_TIME;
pub const QUNS_APP = QUERY_USER_NOTIFICATION_STATE.APP;







pub const SHSTOCKICONID = enum(i32) {
    DOCNOASSOC = 0,
    DOCASSOC = 1,
    APPLICATION = 2,
    FOLDER = 3,
    FOLDEROPEN = 4,
    DRIVE525 = 5,
    DRIVE35 = 6,
    DRIVEREMOVE = 7,
    DRIVEFIXED = 8,
    DRIVENET = 9,
    DRIVENETDISABLED = 10,
    DRIVECD = 11,
    DRIVERAM = 12,
    WORLD = 13,
    SERVER = 15,
    PRINTER = 16,
    MYNETWORK = 17,
    FIND = 22,
    HELP = 23,
    SHARE = 28,
    LINK = 29,
    SLOWFILE = 30,
    RECYCLER = 31,
    RECYCLERFULL = 32,
    MEDIACDAUDIO = 40,
    LOCK = 47,
    AUTOLIST = 49,
    PRINTERNET = 50,
    SERVERSHARE = 51,
    PRINTERFAX = 52,
    PRINTERFAXNET = 53,
    PRINTERFILE = 54,
    STACK = 55,
    MEDIASVCD = 56,
    STUFFEDFOLDER = 57,
    DRIVEUNKNOWN = 58,
    DRIVEDVD = 59,
    MEDIADVD = 60,
    MEDIADVDRAM = 61,
    MEDIADVDRW = 62,
    MEDIADVDR = 63,
    MEDIADVDROM = 64,
    MEDIACDAUDIOPLUS = 65,
    MEDIACDRW = 66,
    MEDIACDR = 67,
    MEDIACDBURN = 68,
    MEDIABLANKCD = 69,
    MEDIACDROM = 70,
    AUDIOFILES = 71,
    IMAGEFILES = 72,
    VIDEOFILES = 73,
    MIXEDFILES = 74,
    FOLDERBACK = 75,
    FOLDERFRONT = 76,
    SHIELD = 77,
    WARNING = 78,
    INFO = 79,
    ERROR = 80,
    KEY = 81,
    SOFTWARE = 82,
    RENAME = 83,
    DELETE = 84,
    MEDIAAUDIODVD = 85,
    MEDIAMOVIEDVD = 86,
    MEDIAENHANCEDCD = 87,
    MEDIAENHANCEDDVD = 88,
    MEDIAHDDVD = 89,
    MEDIABLURAY = 90,
    MEDIAVCD = 91,
    MEDIADVDPLUSR = 92,
    MEDIADVDPLUSRW = 93,
    DESKTOPPC = 94,
    MOBILEPC = 95,
    USERS = 96,
    MEDIASMARTMEDIA = 97,
    MEDIACOMPACTFLASH = 98,
    DEVICECELLPHONE = 99,
    DEVICECAMERA = 100,
    DEVICEVIDEOCAMERA = 101,
    DEVICEAUDIOPLAYER = 102,
    NETWORKCONNECT = 103,
    INTERNET = 104,
    ZIPFILE = 105,
    SETTINGS = 106,
    DRIVEHDDVD = 132,
    DRIVEBD = 133,
    MEDIAHDDVDROM = 134,
    MEDIAHDDVDR = 135,
    MEDIAHDDVDRAM = 136,
    MEDIABDROM = 137,
    MEDIABDR = 138,
    MEDIABDRE = 139,
    CLUSTEREDDRIVE = 140,
    MAX_ICONS = 181,
};
pub const SIID_DOCNOASSOC = SHSTOCKICONID.DOCNOASSOC;
pub const SIID_DOCASSOC = SHSTOCKICONID.DOCASSOC;
pub const SIID_APPLICATION = SHSTOCKICONID.APPLICATION;
pub const SIID_FOLDER = SHSTOCKICONID.FOLDER;
pub const SIID_FOLDEROPEN = SHSTOCKICONID.FOLDEROPEN;
pub const SIID_DRIVE525 = SHSTOCKICONID.DRIVE525;
pub const SIID_DRIVE35 = SHSTOCKICONID.DRIVE35;
pub const SIID_DRIVEREMOVE = SHSTOCKICONID.DRIVEREMOVE;
pub const SIID_DRIVEFIXED = SHSTOCKICONID.DRIVEFIXED;
pub const SIID_DRIVENET = SHSTOCKICONID.DRIVENET;
pub const SIID_DRIVENETDISABLED = SHSTOCKICONID.DRIVENETDISABLED;
pub const SIID_DRIVECD = SHSTOCKICONID.DRIVECD;
pub const SIID_DRIVERAM = SHSTOCKICONID.DRIVERAM;
pub const SIID_WORLD = SHSTOCKICONID.WORLD;
pub const SIID_SERVER = SHSTOCKICONID.SERVER;
pub const SIID_PRINTER = SHSTOCKICONID.PRINTER;
pub const SIID_MYNETWORK = SHSTOCKICONID.MYNETWORK;
pub const SIID_FIND = SHSTOCKICONID.FIND;
pub const SIID_HELP = SHSTOCKICONID.HELP;
pub const SIID_SHARE = SHSTOCKICONID.SHARE;
pub const SIID_LINK = SHSTOCKICONID.LINK;
pub const SIID_SLOWFILE = SHSTOCKICONID.SLOWFILE;
pub const SIID_RECYCLER = SHSTOCKICONID.RECYCLER;
pub const SIID_RECYCLERFULL = SHSTOCKICONID.RECYCLERFULL;
pub const SIID_MEDIACDAUDIO = SHSTOCKICONID.MEDIACDAUDIO;
pub const SIID_LOCK = SHSTOCKICONID.LOCK;
pub const SIID_AUTOLIST = SHSTOCKICONID.AUTOLIST;
pub const SIID_PRINTERNET = SHSTOCKICONID.PRINTERNET;
pub const SIID_SERVERSHARE = SHSTOCKICONID.SERVERSHARE;
pub const SIID_PRINTERFAX = SHSTOCKICONID.PRINTERFAX;
pub const SIID_PRINTERFAXNET = SHSTOCKICONID.PRINTERFAXNET;
pub const SIID_PRINTERFILE = SHSTOCKICONID.PRINTERFILE;
pub const SIID_STACK = SHSTOCKICONID.STACK;
pub const SIID_MEDIASVCD = SHSTOCKICONID.MEDIASVCD;
pub const SIID_STUFFEDFOLDER = SHSTOCKICONID.STUFFEDFOLDER;
pub const SIID_DRIVEUNKNOWN = SHSTOCKICONID.DRIVEUNKNOWN;
pub const SIID_DRIVEDVD = SHSTOCKICONID.DRIVEDVD;
pub const SIID_MEDIADVD = SHSTOCKICONID.MEDIADVD;
pub const SIID_MEDIADVDRAM = SHSTOCKICONID.MEDIADVDRAM;
pub const SIID_MEDIADVDRW = SHSTOCKICONID.MEDIADVDRW;
pub const SIID_MEDIADVDR = SHSTOCKICONID.MEDIADVDR;
pub const SIID_MEDIADVDROM = SHSTOCKICONID.MEDIADVDROM;
pub const SIID_MEDIACDAUDIOPLUS = SHSTOCKICONID.MEDIACDAUDIOPLUS;
pub const SIID_MEDIACDRW = SHSTOCKICONID.MEDIACDRW;
pub const SIID_MEDIACDR = SHSTOCKICONID.MEDIACDR;
pub const SIID_MEDIACDBURN = SHSTOCKICONID.MEDIACDBURN;
pub const SIID_MEDIABLANKCD = SHSTOCKICONID.MEDIABLANKCD;
pub const SIID_MEDIACDROM = SHSTOCKICONID.MEDIACDROM;
pub const SIID_AUDIOFILES = SHSTOCKICONID.AUDIOFILES;
pub const SIID_IMAGEFILES = SHSTOCKICONID.IMAGEFILES;
pub const SIID_VIDEOFILES = SHSTOCKICONID.VIDEOFILES;
pub const SIID_MIXEDFILES = SHSTOCKICONID.MIXEDFILES;
pub const SIID_FOLDERBACK = SHSTOCKICONID.FOLDERBACK;
pub const SIID_FOLDERFRONT = SHSTOCKICONID.FOLDERFRONT;
pub const SIID_SHIELD = SHSTOCKICONID.SHIELD;
pub const SIID_WARNING = SHSTOCKICONID.WARNING;
pub const SIID_INFO = SHSTOCKICONID.INFO;
pub const SIID_ERROR = SHSTOCKICONID.ERROR;
pub const SIID_KEY = SHSTOCKICONID.KEY;
pub const SIID_SOFTWARE = SHSTOCKICONID.SOFTWARE;
pub const SIID_RENAME = SHSTOCKICONID.RENAME;
pub const SIID_DELETE = SHSTOCKICONID.DELETE;
pub const SIID_MEDIAAUDIODVD = SHSTOCKICONID.MEDIAAUDIODVD;
pub const SIID_MEDIAMOVIEDVD = SHSTOCKICONID.MEDIAMOVIEDVD;
pub const SIID_MEDIAENHANCEDCD = SHSTOCKICONID.MEDIAENHANCEDCD;
pub const SIID_MEDIAENHANCEDDVD = SHSTOCKICONID.MEDIAENHANCEDDVD;
pub const SIID_MEDIAHDDVD = SHSTOCKICONID.MEDIAHDDVD;
pub const SIID_MEDIABLURAY = SHSTOCKICONID.MEDIABLURAY;
pub const SIID_MEDIAVCD = SHSTOCKICONID.MEDIAVCD;
pub const SIID_MEDIADVDPLUSR = SHSTOCKICONID.MEDIADVDPLUSR;
pub const SIID_MEDIADVDPLUSRW = SHSTOCKICONID.MEDIADVDPLUSRW;
pub const SIID_DESKTOPPC = SHSTOCKICONID.DESKTOPPC;
pub const SIID_MOBILEPC = SHSTOCKICONID.MOBILEPC;
pub const SIID_USERS = SHSTOCKICONID.USERS;
pub const SIID_MEDIASMARTMEDIA = SHSTOCKICONID.MEDIASMARTMEDIA;
pub const SIID_MEDIACOMPACTFLASH = SHSTOCKICONID.MEDIACOMPACTFLASH;
pub const SIID_DEVICECELLPHONE = SHSTOCKICONID.DEVICECELLPHONE;
pub const SIID_DEVICECAMERA = SHSTOCKICONID.DEVICECAMERA;
pub const SIID_DEVICEVIDEOCAMERA = SHSTOCKICONID.DEVICEVIDEOCAMERA;
pub const SIID_DEVICEAUDIOPLAYER = SHSTOCKICONID.DEVICEAUDIOPLAYER;
pub const SIID_NETWORKCONNECT = SHSTOCKICONID.NETWORKCONNECT;
pub const SIID_INTERNET = SHSTOCKICONID.INTERNET;
pub const SIID_ZIPFILE = SHSTOCKICONID.ZIPFILE;
pub const SIID_SETTINGS = SHSTOCKICONID.SETTINGS;
pub const SIID_DRIVEHDDVD = SHSTOCKICONID.DRIVEHDDVD;
pub const SIID_DRIVEBD = SHSTOCKICONID.DRIVEBD;
pub const SIID_MEDIAHDDVDROM = SHSTOCKICONID.MEDIAHDDVDROM;
pub const SIID_MEDIAHDDVDR = SHSTOCKICONID.MEDIAHDDVDR;
pub const SIID_MEDIAHDDVDRAM = SHSTOCKICONID.MEDIAHDDVDRAM;
pub const SIID_MEDIABDROM = SHSTOCKICONID.MEDIABDROM;
pub const SIID_MEDIABDR = SHSTOCKICONID.MEDIABDR;
pub const SIID_MEDIABDRE = SHSTOCKICONID.MEDIABDRE;
pub const SIID_CLUSTEREDDRIVE = SHSTOCKICONID.CLUSTEREDDRIVE;
pub const SIID_MAX_ICONS = SHSTOCKICONID.MAX_ICONS;



pub const PFNCANSHAREFOLDERW = fn(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNSHOWSHAREFOLDERUIW = fn(
    hwndParent: ?HWND,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const NC_ADDRESS = extern struct {
    pub const NET_ADDRESS_INFO = extern struct {
        placeholder: usize, // TODO: why is this type empty?
    };
    pAddrInfo: ?*NET_ADDRESS_INFO,
    PortNumber: u16,
    PrefixLength: u8,
};

pub const SFBS_FLAGS = enum(i32) {
    ROUND_TO_NEAREST_DISPLAYED_DIGIT = 1,
    TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS = 2,
};
pub const SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT = SFBS_FLAGS.ROUND_TO_NEAREST_DISPLAYED_DIGIT;
pub const SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS = SFBS_FLAGS.TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS;

pub const URL_SCHEME = enum(i32) {
    INVALID = -1,
    UNKNOWN = 0,
    FTP = 1,
    HTTP = 2,
    GOPHER = 3,
    MAILTO = 4,
    NEWS = 5,
    NNTP = 6,
    TELNET = 7,
    WAIS = 8,
    FILE = 9,
    MK = 10,
    HTTPS = 11,
    SHELL = 12,
    SNEWS = 13,
    LOCAL = 14,
    JAVASCRIPT = 15,
    VBSCRIPT = 16,
    ABOUT = 17,
    RES = 18,
    MSSHELLROOTED = 19,
    MSSHELLIDLIST = 20,
    MSHELP = 21,
    MSSHELLDEVICE = 22,
    WILDCARD = 23,
    SEARCH_MS = 24,
    SEARCH = 25,
    KNOWNFOLDER = 26,
    MAXVALUE = 27,
};
pub const URL_SCHEME_INVALID = URL_SCHEME.INVALID;
pub const URL_SCHEME_UNKNOWN = URL_SCHEME.UNKNOWN;
pub const URL_SCHEME_FTP = URL_SCHEME.FTP;
pub const URL_SCHEME_HTTP = URL_SCHEME.HTTP;
pub const URL_SCHEME_GOPHER = URL_SCHEME.GOPHER;
pub const URL_SCHEME_MAILTO = URL_SCHEME.MAILTO;
pub const URL_SCHEME_NEWS = URL_SCHEME.NEWS;
pub const URL_SCHEME_NNTP = URL_SCHEME.NNTP;
pub const URL_SCHEME_TELNET = URL_SCHEME.TELNET;
pub const URL_SCHEME_WAIS = URL_SCHEME.WAIS;
pub const URL_SCHEME_FILE = URL_SCHEME.FILE;
pub const URL_SCHEME_MK = URL_SCHEME.MK;
pub const URL_SCHEME_HTTPS = URL_SCHEME.HTTPS;
pub const URL_SCHEME_SHELL = URL_SCHEME.SHELL;
pub const URL_SCHEME_SNEWS = URL_SCHEME.SNEWS;
pub const URL_SCHEME_LOCAL = URL_SCHEME.LOCAL;
pub const URL_SCHEME_JAVASCRIPT = URL_SCHEME.JAVASCRIPT;
pub const URL_SCHEME_VBSCRIPT = URL_SCHEME.VBSCRIPT;
pub const URL_SCHEME_ABOUT = URL_SCHEME.ABOUT;
pub const URL_SCHEME_RES = URL_SCHEME.RES;
pub const URL_SCHEME_MSSHELLROOTED = URL_SCHEME.MSSHELLROOTED;
pub const URL_SCHEME_MSSHELLIDLIST = URL_SCHEME.MSSHELLIDLIST;
pub const URL_SCHEME_MSHELP = URL_SCHEME.MSHELP;
pub const URL_SCHEME_MSSHELLDEVICE = URL_SCHEME.MSSHELLDEVICE;
pub const URL_SCHEME_WILDCARD = URL_SCHEME.WILDCARD;
pub const URL_SCHEME_SEARCH_MS = URL_SCHEME.SEARCH_MS;
pub const URL_SCHEME_SEARCH = URL_SCHEME.SEARCH;
pub const URL_SCHEME_KNOWNFOLDER = URL_SCHEME.KNOWNFOLDER;
pub const URL_SCHEME_MAXVALUE = URL_SCHEME.MAXVALUE;

pub const URL_PART = enum(i32) {
    NONE = 0,
    SCHEME = 1,
    HOSTNAME = 2,
    USERNAME = 3,
    PASSWORD = 4,
    PORT = 5,
    QUERY = 6,
};
pub const URL_PART_NONE = URL_PART.NONE;
pub const URL_PART_SCHEME = URL_PART.SCHEME;
pub const URL_PART_HOSTNAME = URL_PART.HOSTNAME;
pub const URL_PART_USERNAME = URL_PART.USERNAME;
pub const URL_PART_PASSWORD = URL_PART.PASSWORD;
pub const URL_PART_PORT = URL_PART.PORT;
pub const URL_PART_QUERY = URL_PART.QUERY;

pub const URLIS = enum(i32) {
    URL = 0,
    OPAQUE = 1,
    NOHISTORY = 2,
    FILEURL = 3,
    APPLIABLE = 4,
    DIRECTORY = 5,
    HASQUERY = 6,
};
pub const URLIS_URL = URLIS.URL;
pub const URLIS_OPAQUE = URLIS.OPAQUE;
pub const URLIS_NOHISTORY = URLIS.NOHISTORY;
pub const URLIS_FILEURL = URLIS.FILEURL;
pub const URLIS_APPLIABLE = URLIS.APPLIABLE;
pub const URLIS_DIRECTORY = URLIS.DIRECTORY;
pub const URLIS_HASQUERY = URLIS.HASQUERY;

pub const PARSEDURLA = extern struct {
    cbSize: u32,
    pszProtocol: ?[*:0]const u8,
    cchProtocol: u32,
    pszSuffix: ?[*:0]const u8,
    cchSuffix: u32,
    nScheme: u32,
};

pub const PARSEDURLW = extern struct {
    cbSize: u32,
    pszProtocol: ?[*:0]const u16,
    cchProtocol: u32,
    pszSuffix: ?[*:0]const u16,
    cchSuffix: u32,
    nScheme: u32,
};

pub const SHREGDEL_FLAGS = enum(i32) {
    DEFAULT = 0,
    HKCU = 1,
    HKLM = 16,
    BOTH = 17,
};
pub const SHREGDEL_DEFAULT = SHREGDEL_FLAGS.DEFAULT;
pub const SHREGDEL_HKCU = SHREGDEL_FLAGS.HKCU;
pub const SHREGDEL_HKLM = SHREGDEL_FLAGS.HKLM;
pub const SHREGDEL_BOTH = SHREGDEL_FLAGS.BOTH;

pub const SHREGENUM_FLAGS = enum(i32) {
    DEFAULT = 0,
    HKCU = 1,
    HKLM = 16,
    BOTH = 17,
};
pub const SHREGENUM_DEFAULT = SHREGENUM_FLAGS.DEFAULT;
pub const SHREGENUM_HKCU = SHREGENUM_FLAGS.HKCU;
pub const SHREGENUM_HKLM = SHREGENUM_FLAGS.HKLM;
pub const SHREGENUM_BOTH = SHREGENUM_FLAGS.BOTH;

pub const ASSOCSTR = enum(i32) {
    COMMAND = 1,
    EXECUTABLE = 2,
    FRIENDLYDOCNAME = 3,
    FRIENDLYAPPNAME = 4,
    NOOPEN = 5,
    SHELLNEWVALUE = 6,
    DDECOMMAND = 7,
    DDEIFEXEC = 8,
    DDEAPPLICATION = 9,
    DDETOPIC = 10,
    INFOTIP = 11,
    QUICKTIP = 12,
    TILEINFO = 13,
    CONTENTTYPE = 14,
    DEFAULTICON = 15,
    SHELLEXTENSION = 16,
    DROPTARGET = 17,
    DELEGATEEXECUTE = 18,
    SUPPORTED_URI_PROTOCOLS = 19,
    PROGID = 20,
    APPID = 21,
    APPPUBLISHER = 22,
    APPICONREFERENCE = 23,
    MAX = 24,
};
pub const ASSOCSTR_COMMAND = ASSOCSTR.COMMAND;
pub const ASSOCSTR_EXECUTABLE = ASSOCSTR.EXECUTABLE;
pub const ASSOCSTR_FRIENDLYDOCNAME = ASSOCSTR.FRIENDLYDOCNAME;
pub const ASSOCSTR_FRIENDLYAPPNAME = ASSOCSTR.FRIENDLYAPPNAME;
pub const ASSOCSTR_NOOPEN = ASSOCSTR.NOOPEN;
pub const ASSOCSTR_SHELLNEWVALUE = ASSOCSTR.SHELLNEWVALUE;
pub const ASSOCSTR_DDECOMMAND = ASSOCSTR.DDECOMMAND;
pub const ASSOCSTR_DDEIFEXEC = ASSOCSTR.DDEIFEXEC;
pub const ASSOCSTR_DDEAPPLICATION = ASSOCSTR.DDEAPPLICATION;
pub const ASSOCSTR_DDETOPIC = ASSOCSTR.DDETOPIC;
pub const ASSOCSTR_INFOTIP = ASSOCSTR.INFOTIP;
pub const ASSOCSTR_QUICKTIP = ASSOCSTR.QUICKTIP;
pub const ASSOCSTR_TILEINFO = ASSOCSTR.TILEINFO;
pub const ASSOCSTR_CONTENTTYPE = ASSOCSTR.CONTENTTYPE;
pub const ASSOCSTR_DEFAULTICON = ASSOCSTR.DEFAULTICON;
pub const ASSOCSTR_SHELLEXTENSION = ASSOCSTR.SHELLEXTENSION;
pub const ASSOCSTR_DROPTARGET = ASSOCSTR.DROPTARGET;
pub const ASSOCSTR_DELEGATEEXECUTE = ASSOCSTR.DELEGATEEXECUTE;
pub const ASSOCSTR_SUPPORTED_URI_PROTOCOLS = ASSOCSTR.SUPPORTED_URI_PROTOCOLS;
pub const ASSOCSTR_PROGID = ASSOCSTR.PROGID;
pub const ASSOCSTR_APPID = ASSOCSTR.APPID;
pub const ASSOCSTR_APPPUBLISHER = ASSOCSTR.APPPUBLISHER;
pub const ASSOCSTR_APPICONREFERENCE = ASSOCSTR.APPICONREFERENCE;
pub const ASSOCSTR_MAX = ASSOCSTR.MAX;

pub const ASSOCKEY = enum(i32) {
    SHELLEXECCLASS = 1,
    APP = 2,
    CLASS = 3,
    BASECLASS = 4,
    MAX = 5,
};
pub const ASSOCKEY_SHELLEXECCLASS = ASSOCKEY.SHELLEXECCLASS;
pub const ASSOCKEY_APP = ASSOCKEY.APP;
pub const ASSOCKEY_CLASS = ASSOCKEY.CLASS;
pub const ASSOCKEY_BASECLASS = ASSOCKEY.BASECLASS;
pub const ASSOCKEY_MAX = ASSOCKEY.MAX;

pub const ASSOCDATA = enum(i32) {
    MSIDESCRIPTOR = 1,
    NOACTIVATEHANDLER = 2,
    UNUSED1 = 3,
    HASPERUSERASSOC = 4,
    EDITFLAGS = 5,
    VALUE = 6,
    MAX = 7,
};
pub const ASSOCDATA_MSIDESCRIPTOR = ASSOCDATA.MSIDESCRIPTOR;
pub const ASSOCDATA_NOACTIVATEHANDLER = ASSOCDATA.NOACTIVATEHANDLER;
pub const ASSOCDATA_UNUSED1 = ASSOCDATA.UNUSED1;
pub const ASSOCDATA_HASPERUSERASSOC = ASSOCDATA.HASPERUSERASSOC;
pub const ASSOCDATA_EDITFLAGS = ASSOCDATA.EDITFLAGS;
pub const ASSOCDATA_VALUE = ASSOCDATA.VALUE;
pub const ASSOCDATA_MAX = ASSOCDATA.MAX;

pub const ASSOCENUM = enum(i32) {
    E = 0,
};
pub const ASSOCENUM_NONE = ASSOCENUM.E;

pub const FILETYPEATTRIBUTEFLAGS = enum(i32) {
    None = 0,
    Exclude = 1,
    Show = 2,
    HasExtension = 4,
    NoEdit = 8,
    NoRemove = 16,
    NoNewVerb = 32,
    NoEditVerb = 64,
    NoRemoveVerb = 128,
    NoEditDesc = 256,
    NoEditIcon = 512,
    NoEditDflt = 1024,
    NoEditVerbCmd = 2048,
    NoEditVerbExe = 4096,
    NoDDE = 8192,
    NoEditMIME = 32768,
    OpenIsSafe = 65536,
    AlwaysUnsafe = 131072,
    NoRecentDocs = 1048576,
    SafeForElevation = 2097152,
    AlwaysUseDirectInvoke = 4194304,
};
pub const FTA_None = FILETYPEATTRIBUTEFLAGS.None;
pub const FTA_Exclude = FILETYPEATTRIBUTEFLAGS.Exclude;
pub const FTA_Show = FILETYPEATTRIBUTEFLAGS.Show;
pub const FTA_HasExtension = FILETYPEATTRIBUTEFLAGS.HasExtension;
pub const FTA_NoEdit = FILETYPEATTRIBUTEFLAGS.NoEdit;
pub const FTA_NoRemove = FILETYPEATTRIBUTEFLAGS.NoRemove;
pub const FTA_NoNewVerb = FILETYPEATTRIBUTEFLAGS.NoNewVerb;
pub const FTA_NoEditVerb = FILETYPEATTRIBUTEFLAGS.NoEditVerb;
pub const FTA_NoRemoveVerb = FILETYPEATTRIBUTEFLAGS.NoRemoveVerb;
pub const FTA_NoEditDesc = FILETYPEATTRIBUTEFLAGS.NoEditDesc;
pub const FTA_NoEditIcon = FILETYPEATTRIBUTEFLAGS.NoEditIcon;
pub const FTA_NoEditDflt = FILETYPEATTRIBUTEFLAGS.NoEditDflt;
pub const FTA_NoEditVerbCmd = FILETYPEATTRIBUTEFLAGS.NoEditVerbCmd;
pub const FTA_NoEditVerbExe = FILETYPEATTRIBUTEFLAGS.NoEditVerbExe;
pub const FTA_NoDDE = FILETYPEATTRIBUTEFLAGS.NoDDE;
pub const FTA_NoEditMIME = FILETYPEATTRIBUTEFLAGS.NoEditMIME;
pub const FTA_OpenIsSafe = FILETYPEATTRIBUTEFLAGS.OpenIsSafe;
pub const FTA_AlwaysUnsafe = FILETYPEATTRIBUTEFLAGS.AlwaysUnsafe;
pub const FTA_NoRecentDocs = FILETYPEATTRIBUTEFLAGS.NoRecentDocs;
pub const FTA_SafeForElevation = FILETYPEATTRIBUTEFLAGS.SafeForElevation;
pub const FTA_AlwaysUseDirectInvoke = FILETYPEATTRIBUTEFLAGS.AlwaysUseDirectInvoke;

// TODO: this type is limited to platform 'windows5.0'
const IID_IQueryAssociations_Value = @import("../zig.zig").Guid.initString("c46ca590-3c3f-11d2-bee6-0000f805ca57");
pub const IID_IQueryAssociations = &IID_IQueryAssociations_Value;
pub const IQueryAssociations = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IQueryAssociations,
            flags: u32,
            pszAssoc: ?[*:0]const u16,
            hkProgid: ?HKEY,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: fn(
            self: *const IQueryAssociations,
            flags: u32,
            str: ASSOCSTR,
            pszExtra: ?[*:0]const u16,
            pszOut: ?[*:0]u16,
            pcchOut: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKey: fn(
            self: *const IQueryAssociations,
            flags: u32,
            key: ASSOCKEY,
            pszExtra: ?[*:0]const u16,
            phkeyOut: ?*?HKEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: fn(
            self: *const IQueryAssociations,
            flags: u32,
            data: ASSOCDATA,
            pszExtra: ?[*:0]const u16,
            // TODO: what to do with BytesParamIndex 4?
            pvOut: ?*anyopaque,
            pcbOut: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnum: fn(
            self: *const IQueryAssociations,
            flags: u32,
            assocenum: ASSOCENUM,
            pszExtra: ?[*:0]const u16,
            riid: ?*const Guid,
            ppvOut: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryAssociations_Init(self: *const T, flags: u32, pszAssoc: ?[*:0]const u16, hkProgid: ?HKEY, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryAssociations.VTable, self.vtable).Init(@ptrCast(*const IQueryAssociations, self), flags, pszAssoc, hkProgid, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryAssociations_GetString(self: *const T, flags: u32, str: ASSOCSTR, pszExtra: ?[*:0]const u16, pszOut: ?[*:0]u16, pcchOut: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryAssociations.VTable, self.vtable).GetString(@ptrCast(*const IQueryAssociations, self), flags, str, pszExtra, pszOut, pcchOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryAssociations_GetKey(self: *const T, flags: u32, key: ASSOCKEY, pszExtra: ?[*:0]const u16, phkeyOut: ?*?HKEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryAssociations.VTable, self.vtable).GetKey(@ptrCast(*const IQueryAssociations, self), flags, key, pszExtra, phkeyOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryAssociations_GetData(self: *const T, flags: u32, data: ASSOCDATA, pszExtra: ?[*:0]const u16, pvOut: ?*anyopaque, pcbOut: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryAssociations.VTable, self.vtable).GetData(@ptrCast(*const IQueryAssociations, self), flags, data, pszExtra, pvOut, pcbOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryAssociations_GetEnum(self: *const T, flags: u32, assocenum: ASSOCENUM, pszExtra: ?[*:0]const u16, riid: ?*const Guid, ppvOut: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryAssociations.VTable, self.vtable).GetEnum(@ptrCast(*const IQueryAssociations, self), flags, assocenum, pszExtra, riid, ppvOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SHGLOBALCOUNTER = enum(i32) {
    GLOBALCOUNTER_SEARCHMANAGER = 0,
    GLOBALCOUNTER_SEARCHOPTIONS = 1,
    GLOBALCOUNTER_FOLDERSETTINGSCHANGE = 2,
    GLOBALCOUNTER_RATINGS = 3,
    GLOBALCOUNTER_APPROVEDSITES = 4,
    GLOBALCOUNTER_RESTRICTIONS = 5,
    GLOBALCOUNTER_SHELLSETTINGSCHANGED = 6,
    GLOBALCOUNTER_SYSTEMPIDLCHANGE = 7,
    GLOBALCOUNTER_OVERLAYMANAGER = 8,
    GLOBALCOUNTER_QUERYASSOCIATIONS = 9,
    GLOBALCOUNTER_IESESSIONS = 10,
    GLOBALCOUNTER_IEONLY_SESSIONS = 11,
    GLOBALCOUNTER_APPLICATION_DESTINATIONS = 12,
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS = 13,
    GLOBALCOUNTER_BITBUCKETNUMDELETERS = 14,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES = 15,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A = 16,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B = 17,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C = 18,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D = 19,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E = 20,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F = 21,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G = 22,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H = 23,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I = 24,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J = 25,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K = 26,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L = 27,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M = 28,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N = 29,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O = 30,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P = 31,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q = 32,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R = 33,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S = 34,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T = 35,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U = 36,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V = 37,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W = 38,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X = 39,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y = 40,
    GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z = 41,
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE = 42,
    __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT = 43,
    GLOBALCOUNTER_RECYCLEBINENUM = 44,
    GLOBALCOUNTER_RECYCLEBINCORRUPTED = 45,
    GLOBALCOUNTER_RATINGS_STATECOUNTER = 46,
    GLOBALCOUNTER_PRIVATE_PROFILE_CACHE = 47,
    GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT = 48,
    GLOBALCOUNTER_FOLDERDEFINITION_CACHE = 49,
    GLOBALCOUNTER_COMMONPLACES_LIST_CACHE = 50,
    GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE = 51,
    GLOBALCOUNTER_ASSOCCHANGED = 52,
    GLOBALCOUNTER_APP_ITEMS_STATE_STORE_CACHE = 53,
    GLOBALCOUNTER_SETTINGSYNC_ENABLED = 54,
    GLOBALCOUNTER_APPSFOLDER_FILETYPEASSOCIATION_COUNTER = 55,
    GLOBALCOUNTER_USERINFOCHANGED = 56,
    GLOBALCOUNTER_SYNC_ENGINE_INFORMATION_CACHE_MACHINEWIDE = 57,
    GLOBALCOUNTER_BANNERS_DATAMODEL_CACHE_MACHINEWIDE = 58,
    GLOBALCOUNTER_MAXIMUMVALUE = 59,
};
pub const GLOBALCOUNTER_SEARCHMANAGER = SHGLOBALCOUNTER.GLOBALCOUNTER_SEARCHMANAGER;
pub const GLOBALCOUNTER_SEARCHOPTIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_SEARCHOPTIONS;
pub const GLOBALCOUNTER_FOLDERSETTINGSCHANGE = SHGLOBALCOUNTER.GLOBALCOUNTER_FOLDERSETTINGSCHANGE;
pub const GLOBALCOUNTER_RATINGS = SHGLOBALCOUNTER.GLOBALCOUNTER_RATINGS;
pub const GLOBALCOUNTER_APPROVEDSITES = SHGLOBALCOUNTER.GLOBALCOUNTER_APPROVEDSITES;
pub const GLOBALCOUNTER_RESTRICTIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_RESTRICTIONS;
pub const GLOBALCOUNTER_SHELLSETTINGSCHANGED = SHGLOBALCOUNTER.GLOBALCOUNTER_SHELLSETTINGSCHANGED;
pub const GLOBALCOUNTER_SYSTEMPIDLCHANGE = SHGLOBALCOUNTER.GLOBALCOUNTER_SYSTEMPIDLCHANGE;
pub const GLOBALCOUNTER_OVERLAYMANAGER = SHGLOBALCOUNTER.GLOBALCOUNTER_OVERLAYMANAGER;
pub const GLOBALCOUNTER_QUERYASSOCIATIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_QUERYASSOCIATIONS;
pub const GLOBALCOUNTER_IESESSIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_IESESSIONS;
pub const GLOBALCOUNTER_IEONLY_SESSIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_IEONLY_SESSIONS;
pub const GLOBALCOUNTER_APPLICATION_DESTINATIONS = SHGLOBALCOUNTER.GLOBALCOUNTER_APPLICATION_DESTINATIONS;
pub const __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS = SHGLOBALCOUNTER.__UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS;
pub const GLOBALCOUNTER_BITBUCKETNUMDELETERS = SHGLOBALCOUNTER.GLOBALCOUNTER_BITBUCKETNUMDELETERS;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y;
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z;
pub const __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE = SHGLOBALCOUNTER.__UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE;
pub const __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT = SHGLOBALCOUNTER.__UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT;
pub const GLOBALCOUNTER_RECYCLEBINENUM = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEBINENUM;
pub const GLOBALCOUNTER_RECYCLEBINCORRUPTED = SHGLOBALCOUNTER.GLOBALCOUNTER_RECYCLEBINCORRUPTED;
pub const GLOBALCOUNTER_RATINGS_STATECOUNTER = SHGLOBALCOUNTER.GLOBALCOUNTER_RATINGS_STATECOUNTER;
pub const GLOBALCOUNTER_PRIVATE_PROFILE_CACHE = SHGLOBALCOUNTER.GLOBALCOUNTER_PRIVATE_PROFILE_CACHE;
pub const GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT = SHGLOBALCOUNTER.GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT;
pub const GLOBALCOUNTER_FOLDERDEFINITION_CACHE = SHGLOBALCOUNTER.GLOBALCOUNTER_FOLDERDEFINITION_CACHE;
pub const GLOBALCOUNTER_COMMONPLACES_LIST_CACHE = SHGLOBALCOUNTER.GLOBALCOUNTER_COMMONPLACES_LIST_CACHE;
pub const GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE = SHGLOBALCOUNTER.GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE;
pub const GLOBALCOUNTER_ASSOCCHANGED = SHGLOBALCOUNTER.GLOBALCOUNTER_ASSOCCHANGED;
pub const GLOBALCOUNTER_APP_ITEMS_STATE_STORE_CACHE = SHGLOBALCOUNTER.GLOBALCOUNTER_APP_ITEMS_STATE_STORE_CACHE;
pub const GLOBALCOUNTER_SETTINGSYNC_ENABLED = SHGLOBALCOUNTER.GLOBALCOUNTER_SETTINGSYNC_ENABLED;
pub const GLOBALCOUNTER_APPSFOLDER_FILETYPEASSOCIATION_COUNTER = SHGLOBALCOUNTER.GLOBALCOUNTER_APPSFOLDER_FILETYPEASSOCIATION_COUNTER;
pub const GLOBALCOUNTER_USERINFOCHANGED = SHGLOBALCOUNTER.GLOBALCOUNTER_USERINFOCHANGED;
pub const GLOBALCOUNTER_SYNC_ENGINE_INFORMATION_CACHE_MACHINEWIDE = SHGLOBALCOUNTER.GLOBALCOUNTER_SYNC_ENGINE_INFORMATION_CACHE_MACHINEWIDE;
pub const GLOBALCOUNTER_BANNERS_DATAMODEL_CACHE_MACHINEWIDE = SHGLOBALCOUNTER.GLOBALCOUNTER_BANNERS_DATAMODEL_CACHE_MACHINEWIDE;
pub const GLOBALCOUNTER_MAXIMUMVALUE = SHGLOBALCOUNTER.GLOBALCOUNTER_MAXIMUMVALUE;

pub const QITAB = extern struct {
    piid: ?*const Guid,
    dwOffset: u32,
};

pub const DLLVERSIONINFO = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformID: u32,
};

pub const DLLVERSIONINFO2 = extern struct {
    info1: DLLVERSIONINFO,
    dwFlags: u32,
    ullVersion: u64,
};

pub const DLLGETVERSIONPROC = fn(
    param0: ?*DLLVERSIONINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const APPINFODATAFLAGS = enum(i32) {
    DISPLAYNAME = 1,
    VERSION = 2,
    PUBLISHER = 4,
    PRODUCTID = 8,
    REGISTEREDOWNER = 16,
    REGISTEREDCOMPANY = 32,
    LANGUAGE = 64,
    SUPPORTURL = 128,
    SUPPORTTELEPHONE = 256,
    HELPLINK = 512,
    INSTALLLOCATION = 1024,
    INSTALLSOURCE = 2048,
    INSTALLDATE = 4096,
    CONTACT = 16384,
    COMMENTS = 32768,
    IMAGE = 131072,
    READMEURL = 262144,
    UPDATEINFOURL = 524288,
};
pub const AIM_DISPLAYNAME = APPINFODATAFLAGS.DISPLAYNAME;
pub const AIM_VERSION = APPINFODATAFLAGS.VERSION;
pub const AIM_PUBLISHER = APPINFODATAFLAGS.PUBLISHER;
pub const AIM_PRODUCTID = APPINFODATAFLAGS.PRODUCTID;
pub const AIM_REGISTEREDOWNER = APPINFODATAFLAGS.REGISTEREDOWNER;
pub const AIM_REGISTEREDCOMPANY = APPINFODATAFLAGS.REGISTEREDCOMPANY;
pub const AIM_LANGUAGE = APPINFODATAFLAGS.LANGUAGE;
pub const AIM_SUPPORTURL = APPINFODATAFLAGS.SUPPORTURL;
pub const AIM_SUPPORTTELEPHONE = APPINFODATAFLAGS.SUPPORTTELEPHONE;
pub const AIM_HELPLINK = APPINFODATAFLAGS.HELPLINK;
pub const AIM_INSTALLLOCATION = APPINFODATAFLAGS.INSTALLLOCATION;
pub const AIM_INSTALLSOURCE = APPINFODATAFLAGS.INSTALLSOURCE;
pub const AIM_INSTALLDATE = APPINFODATAFLAGS.INSTALLDATE;
pub const AIM_CONTACT = APPINFODATAFLAGS.CONTACT;
pub const AIM_COMMENTS = APPINFODATAFLAGS.COMMENTS;
pub const AIM_IMAGE = APPINFODATAFLAGS.IMAGE;
pub const AIM_READMEURL = APPINFODATAFLAGS.READMEURL;
pub const AIM_UPDATEINFOURL = APPINFODATAFLAGS.UPDATEINFOURL;

pub const APPINFODATA = extern struct {
    cbSize: u32,
    dwMask: u32,
    pszDisplayName: ?PWSTR,
    pszVersion: ?PWSTR,
    pszPublisher: ?PWSTR,
    pszProductID: ?PWSTR,
    pszRegisteredOwner: ?PWSTR,
    pszRegisteredCompany: ?PWSTR,
    pszLanguage: ?PWSTR,
    pszSupportUrl: ?PWSTR,
    pszSupportTelephone: ?PWSTR,
    pszHelpLink: ?PWSTR,
    pszInstallLocation: ?PWSTR,
    pszInstallSource: ?PWSTR,
    pszInstallDate: ?PWSTR,
    pszContact: ?PWSTR,
    pszComments: ?PWSTR,
    pszImage: ?PWSTR,
    pszReadmeUrl: ?PWSTR,
    pszUpdateInfoUrl: ?PWSTR,
};

pub const APPACTIONFLAGS = enum(i32) {
    INSTALL = 1,
    UNINSTALL = 2,
    MODIFY = 4,
    REPAIR = 8,
    UPGRADE = 16,
    CANGETSIZE = 32,
    MODIFYREMOVE = 128,
    ADDLATER = 256,
    UNSCHEDULE = 512,
};
pub const APPACTION_INSTALL = APPACTIONFLAGS.INSTALL;
pub const APPACTION_UNINSTALL = APPACTIONFLAGS.UNINSTALL;
pub const APPACTION_MODIFY = APPACTIONFLAGS.MODIFY;
pub const APPACTION_REPAIR = APPACTIONFLAGS.REPAIR;
pub const APPACTION_UPGRADE = APPACTIONFLAGS.UPGRADE;
pub const APPACTION_CANGETSIZE = APPACTIONFLAGS.CANGETSIZE;
pub const APPACTION_MODIFYREMOVE = APPACTIONFLAGS.MODIFYREMOVE;
pub const APPACTION_ADDLATER = APPACTIONFLAGS.ADDLATER;
pub const APPACTION_UNSCHEDULE = APPACTIONFLAGS.UNSCHEDULE;

pub const SLOWAPPINFO = extern struct {
    ullSize: u64,
    ftLastUsed: FILETIME,
    iTimesUsed: i32,
    pszImage: ?PWSTR,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellApp_Value = @import("../zig.zig").Guid.initString("a3e14960-935f-11d1-b8b8-006008059382");
pub const IID_IShellApp = &IID_IShellApp_Value;
pub const IShellApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppInfo: fn(
            self: *const IShellApp,
            pai: ?*APPINFODATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPossibleActions: fn(
            self: *const IShellApp,
            pdwActions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSlowAppInfo: fn(
            self: *const IShellApp,
            psaid: ?*SLOWAPPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedSlowAppInfo: fn(
            self: *const IShellApp,
            psaid: ?*SLOWAPPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInstalled: fn(
            self: *const IShellApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellApp_GetAppInfo(self: *const T, pai: ?*APPINFODATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellApp.VTable, self.vtable).GetAppInfo(@ptrCast(*const IShellApp, self), pai);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellApp_GetPossibleActions(self: *const T, pdwActions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellApp.VTable, self.vtable).GetPossibleActions(@ptrCast(*const IShellApp, self), pdwActions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellApp_GetSlowAppInfo(self: *const T, psaid: ?*SLOWAPPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellApp.VTable, self.vtable).GetSlowAppInfo(@ptrCast(*const IShellApp, self), psaid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellApp_GetCachedSlowAppInfo(self: *const T, psaid: ?*SLOWAPPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellApp.VTable, self.vtable).GetCachedSlowAppInfo(@ptrCast(*const IShellApp, self), psaid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellApp_IsInstalled(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellApp.VTable, self.vtable).IsInstalled(@ptrCast(*const IShellApp, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PUBAPPINFOFLAGS = enum(i32) {
    SOURCE = 1,
    ASSIGNEDTIME = 2,
    PUBLISHEDTIME = 4,
    SCHEDULEDTIME = 8,
    EXPIRETIME = 16,
};
pub const PAI_SOURCE = PUBAPPINFOFLAGS.SOURCE;
pub const PAI_ASSIGNEDTIME = PUBAPPINFOFLAGS.ASSIGNEDTIME;
pub const PAI_PUBLISHEDTIME = PUBAPPINFOFLAGS.PUBLISHEDTIME;
pub const PAI_SCHEDULEDTIME = PUBAPPINFOFLAGS.SCHEDULEDTIME;
pub const PAI_EXPIRETIME = PUBAPPINFOFLAGS.EXPIRETIME;

pub const PUBAPPINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    pszSource: ?PWSTR,
    stAssigned: SYSTEMTIME,
    stPublished: SYSTEMTIME,
    stScheduled: SYSTEMTIME,
    stExpire: SYSTEMTIME,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPublishedApp_Value = @import("../zig.zig").Guid.initString("1bc752e0-9046-11d1-b8b3-006008059382");
pub const IID_IPublishedApp = &IID_IPublishedApp_Value;
pub const IPublishedApp = extern struct {
    pub const VTable = extern struct {
        base: IShellApp.VTable,
        Install: fn(
            self: *const IPublishedApp,
            pstInstall: ?*SYSTEMTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPublishedAppInfo: fn(
            self: *const IPublishedApp,
            ppai: ?*PUBAPPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unschedule: fn(
            self: *const IPublishedApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellApp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPublishedApp_Install(self: *const T, pstInstall: ?*SYSTEMTIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPublishedApp.VTable, self.vtable).Install(@ptrCast(*const IPublishedApp, self), pstInstall);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPublishedApp_GetPublishedAppInfo(self: *const T, ppai: ?*PUBAPPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPublishedApp.VTable, self.vtable).GetPublishedAppInfo(@ptrCast(*const IPublishedApp, self), ppai);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPublishedApp_Unschedule(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPublishedApp.VTable, self.vtable).Unschedule(@ptrCast(*const IPublishedApp, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPublishedApp2_Value = @import("../zig.zig").Guid.initString("12b81347-1b3a-4a04-aa61-3f768b67fd7e");
pub const IID_IPublishedApp2 = &IID_IPublishedApp2_Value;
pub const IPublishedApp2 = extern struct {
    pub const VTable = extern struct {
        base: IPublishedApp.VTable,
        Install2: fn(
            self: *const IPublishedApp2,
            pstInstall: ?*SYSTEMTIME,
            hwndParent: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPublishedApp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPublishedApp2_Install2(self: *const T, pstInstall: ?*SYSTEMTIME, hwndParent: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPublishedApp2.VTable, self.vtable).Install2(@ptrCast(*const IPublishedApp2, self), pstInstall, hwndParent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumPublishedApps_Value = @import("../zig.zig").Guid.initString("0b124f8c-91f0-11d1-b8b5-006008059382");
pub const IID_IEnumPublishedApps = &IID_IEnumPublishedApps_Value;
pub const IEnumPublishedApps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumPublishedApps,
            pia: ?*?*IPublishedApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumPublishedApps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPublishedApps_Next(self: *const T, pia: ?*?*IPublishedApp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPublishedApps.VTable, self.vtable).Next(@ptrCast(*const IEnumPublishedApps, self), pia);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPublishedApps_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPublishedApps.VTable, self.vtable).Reset(@ptrCast(*const IEnumPublishedApps, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAppPublisher_Value = @import("../zig.zig").Guid.initString("07250a10-9cf9-11d1-9076-006008059382");
pub const IID_IAppPublisher = &IID_IAppPublisher_Value;
pub const IAppPublisher = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfCategories: fn(
            self: *const IAppPublisher,
            pdwCat: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategories: fn(
            self: *const IAppPublisher,
            pAppCategoryList: ?*APPCATEGORYINFOLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfApps: fn(
            self: *const IAppPublisher,
            pdwApps: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumApps: fn(
            self: *const IAppPublisher,
            pAppCategoryId: ?*Guid,
            ppepa: ?*?*IEnumPublishedApps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppPublisher_GetNumberOfCategories(self: *const T, pdwCat: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppPublisher.VTable, self.vtable).GetNumberOfCategories(@ptrCast(*const IAppPublisher, self), pdwCat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppPublisher_GetCategories(self: *const T, pAppCategoryList: ?*APPCATEGORYINFOLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppPublisher.VTable, self.vtable).GetCategories(@ptrCast(*const IAppPublisher, self), pAppCategoryList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppPublisher_GetNumberOfApps(self: *const T, pdwApps: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppPublisher.VTable, self.vtable).GetNumberOfApps(@ptrCast(*const IAppPublisher, self), pdwApps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppPublisher_EnumApps(self: *const T, pAppCategoryId: ?*Guid, ppepa: ?*?*IEnumPublishedApps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAppPublisher.VTable, self.vtable).EnumApps(@ptrCast(*const IAppPublisher, self), pAppCategoryId, ppepa);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_PasswordCredentialProvider_Value = @import("../zig.zig").Guid.initString("60b78e88-ead8-445c-9cfd-0b87f74ea6cd");
pub const CLSID_PasswordCredentialProvider = &CLSID_PasswordCredentialProvider_Value;

const CLSID_V1PasswordCredentialProvider_Value = @import("../zig.zig").Guid.initString("6f45dc1e-5384-457a-bc13-2cd81b0d28ed");
pub const CLSID_V1PasswordCredentialProvider = &CLSID_V1PasswordCredentialProvider_Value;

const CLSID_PINLogonCredentialProvider_Value = @import("../zig.zig").Guid.initString("cb82ea12-9f71-446d-89e1-8d0924e1256e");
pub const CLSID_PINLogonCredentialProvider = &CLSID_PINLogonCredentialProvider_Value;

const CLSID_NPCredentialProvider_Value = @import("../zig.zig").Guid.initString("3dd6bec0-8193-4ffe-ae25-e08e39ea4063");
pub const CLSID_NPCredentialProvider = &CLSID_NPCredentialProvider_Value;

const CLSID_SmartcardCredentialProvider_Value = @import("../zig.zig").Guid.initString("8fd7e19c-3bf7-489b-a72c-846ab3678c96");
pub const CLSID_SmartcardCredentialProvider = &CLSID_SmartcardCredentialProvider_Value;

const CLSID_V1SmartcardCredentialProvider_Value = @import("../zig.zig").Guid.initString("8bf9a910-a8ff-457f-999f-a5ca10b4a885");
pub const CLSID_V1SmartcardCredentialProvider = &CLSID_V1SmartcardCredentialProvider_Value;

const CLSID_SmartcardPinProvider_Value = @import("../zig.zig").Guid.initString("94596c7e-3744-41ce-893e-bbf09122f76a");
pub const CLSID_SmartcardPinProvider = &CLSID_SmartcardPinProvider_Value;

const CLSID_SmartcardReaderSelectionProvider_Value = @import("../zig.zig").Guid.initString("1b283861-754f-4022-ad47-a5eaaa618894");
pub const CLSID_SmartcardReaderSelectionProvider = &CLSID_SmartcardReaderSelectionProvider_Value;

const CLSID_SmartcardWinRTProvider_Value = @import("../zig.zig").Guid.initString("1ee7337f-85ac-45e2-a23c-37c753209769");
pub const CLSID_SmartcardWinRTProvider = &CLSID_SmartcardWinRTProvider_Value;

const CLSID_GenericCredentialProvider_Value = @import("../zig.zig").Guid.initString("25cbb996-92ed-457e-b28c-4774084bd562");
pub const CLSID_GenericCredentialProvider = &CLSID_GenericCredentialProvider_Value;

const CLSID_RASProvider_Value = @import("../zig.zig").Guid.initString("5537e283-b1e7-4ef8-9c6e-7ab0afe5056d");
pub const CLSID_RASProvider = &CLSID_RASProvider_Value;

const CLSID_OnexCredentialProvider_Value = @import("../zig.zig").Guid.initString("07aa0886-cc8d-4e19-a410-1c75af686e62");
pub const CLSID_OnexCredentialProvider = &CLSID_OnexCredentialProvider_Value;

const CLSID_OnexPlapSmartcardCredentialProvider_Value = @import("../zig.zig").Guid.initString("33c86cd6-705f-4ba1-9adb-67070b837775");
pub const CLSID_OnexPlapSmartcardCredentialProvider = &CLSID_OnexPlapSmartcardCredentialProvider_Value;

const CLSID_VaultProvider_Value = @import("../zig.zig").Guid.initString("503739d0-4c5e-4cfd-b3ba-d881334f0df2");
pub const CLSID_VaultProvider = &CLSID_VaultProvider_Value;

const CLSID_WinBioCredentialProvider_Value = @import("../zig.zig").Guid.initString("bec09223-b018-416d-a0ac-523971b639f5");
pub const CLSID_WinBioCredentialProvider = &CLSID_WinBioCredentialProvider_Value;

const CLSID_V1WinBioCredentialProvider_Value = @import("../zig.zig").Guid.initString("ac3ac249-e820-4343-a65b-377ac634dc09");
pub const CLSID_V1WinBioCredentialProvider = &CLSID_V1WinBioCredentialProvider_Value;

pub const CREDENTIAL_PROVIDER_USAGE_SCENARIO = enum(i32) {
    INVALID = 0,
    LOGON = 1,
    UNLOCK_WORKSTATION = 2,
    CHANGE_PASSWORD = 3,
    CREDUI = 4,
    PLAP = 5,
};
pub const CPUS_INVALID = CREDENTIAL_PROVIDER_USAGE_SCENARIO.INVALID;
pub const CPUS_LOGON = CREDENTIAL_PROVIDER_USAGE_SCENARIO.LOGON;
pub const CPUS_UNLOCK_WORKSTATION = CREDENTIAL_PROVIDER_USAGE_SCENARIO.UNLOCK_WORKSTATION;
pub const CPUS_CHANGE_PASSWORD = CREDENTIAL_PROVIDER_USAGE_SCENARIO.CHANGE_PASSWORD;
pub const CPUS_CREDUI = CREDENTIAL_PROVIDER_USAGE_SCENARIO.CREDUI;
pub const CPUS_PLAP = CREDENTIAL_PROVIDER_USAGE_SCENARIO.PLAP;

pub const CREDENTIAL_PROVIDER_FIELD_TYPE = enum(i32) {
    INVALID = 0,
    LARGE_TEXT = 1,
    SMALL_TEXT = 2,
    COMMAND_LINK = 3,
    EDIT_TEXT = 4,
    PASSWORD_TEXT = 5,
    TILE_IMAGE = 6,
    CHECKBOX = 7,
    COMBOBOX = 8,
    SUBMIT_BUTTON = 9,
};
pub const CPFT_INVALID = CREDENTIAL_PROVIDER_FIELD_TYPE.INVALID;
pub const CPFT_LARGE_TEXT = CREDENTIAL_PROVIDER_FIELD_TYPE.LARGE_TEXT;
pub const CPFT_SMALL_TEXT = CREDENTIAL_PROVIDER_FIELD_TYPE.SMALL_TEXT;
pub const CPFT_COMMAND_LINK = CREDENTIAL_PROVIDER_FIELD_TYPE.COMMAND_LINK;
pub const CPFT_EDIT_TEXT = CREDENTIAL_PROVIDER_FIELD_TYPE.EDIT_TEXT;
pub const CPFT_PASSWORD_TEXT = CREDENTIAL_PROVIDER_FIELD_TYPE.PASSWORD_TEXT;
pub const CPFT_TILE_IMAGE = CREDENTIAL_PROVIDER_FIELD_TYPE.TILE_IMAGE;
pub const CPFT_CHECKBOX = CREDENTIAL_PROVIDER_FIELD_TYPE.CHECKBOX;
pub const CPFT_COMBOBOX = CREDENTIAL_PROVIDER_FIELD_TYPE.COMBOBOX;
pub const CPFT_SUBMIT_BUTTON = CREDENTIAL_PROVIDER_FIELD_TYPE.SUBMIT_BUTTON;

pub const CREDENTIAL_PROVIDER_FIELD_STATE = enum(i32) {
    HIDDEN = 0,
    DISPLAY_IN_SELECTED_TILE = 1,
    DISPLAY_IN_DESELECTED_TILE = 2,
    DISPLAY_IN_BOTH = 3,
};
pub const CPFS_HIDDEN = CREDENTIAL_PROVIDER_FIELD_STATE.HIDDEN;
pub const CPFS_DISPLAY_IN_SELECTED_TILE = CREDENTIAL_PROVIDER_FIELD_STATE.DISPLAY_IN_SELECTED_TILE;
pub const CPFS_DISPLAY_IN_DESELECTED_TILE = CREDENTIAL_PROVIDER_FIELD_STATE.DISPLAY_IN_DESELECTED_TILE;
pub const CPFS_DISPLAY_IN_BOTH = CREDENTIAL_PROVIDER_FIELD_STATE.DISPLAY_IN_BOTH;

pub const CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE = enum(i32) {
    NONE = 0,
    READONLY = 1,
    DISABLED = 2,
    FOCUSED = 3,
};
pub const CPFIS_NONE = CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE.NONE;
pub const CPFIS_READONLY = CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE.READONLY;
pub const CPFIS_DISABLED = CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE.DISABLED;
pub const CPFIS_FOCUSED = CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE.FOCUSED;

pub const CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR = extern struct {
    dwFieldID: u32,
    cpft: CREDENTIAL_PROVIDER_FIELD_TYPE,
    pszLabel: ?PWSTR,
    guidFieldType: Guid,
};

pub const CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE = enum(i32) {
    NO_CREDENTIAL_NOT_FINISHED = 0,
    NO_CREDENTIAL_FINISHED = 1,
    RETURN_CREDENTIAL_FINISHED = 2,
    RETURN_NO_CREDENTIAL_FINISHED = 3,
};
pub const CPGSR_NO_CREDENTIAL_NOT_FINISHED = CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE.NO_CREDENTIAL_NOT_FINISHED;
pub const CPGSR_NO_CREDENTIAL_FINISHED = CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE.NO_CREDENTIAL_FINISHED;
pub const CPGSR_RETURN_CREDENTIAL_FINISHED = CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE.RETURN_CREDENTIAL_FINISHED;
pub const CPGSR_RETURN_NO_CREDENTIAL_FINISHED = CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE.RETURN_NO_CREDENTIAL_FINISHED;

pub const CREDENTIAL_PROVIDER_STATUS_ICON = enum(i32) {
    NONE = 0,
    ERROR = 1,
    WARNING = 2,
    SUCCESS = 3,
};
pub const CPSI_NONE = CREDENTIAL_PROVIDER_STATUS_ICON.NONE;
pub const CPSI_ERROR = CREDENTIAL_PROVIDER_STATUS_ICON.ERROR;
pub const CPSI_WARNING = CREDENTIAL_PROVIDER_STATUS_ICON.WARNING;
pub const CPSI_SUCCESS = CREDENTIAL_PROVIDER_STATUS_ICON.SUCCESS;

pub const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION = extern struct {
    ulAuthenticationPackage: u32,
    clsidCredentialProvider: Guid,
    cbSerialization: u32,
    rgbSerialization: ?*u8,
};

pub const CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS = enum(i32) {
    NONE = 0,
    EMPTY_LOCAL = 1,
    EMPTY_CONNECTED = 2,
};
pub const CPAO_NONE = CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS.NONE;
pub const CPAO_EMPTY_LOCAL = CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS.EMPTY_LOCAL;
pub const CPAO_EMPTY_CONNECTED = CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS.EMPTY_CONNECTED;

pub const CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS = enum(i32) {
    NONE = 0,
    ENABLE_PASSWORD_REVEAL = 1,
    IS_EMAIL_ADDRESS = 2,
    ENABLE_TOUCH_KEYBOARD_AUTO_INVOKE = 4,
    NUMBERS_ONLY = 8,
    SHOW_ENGLISH_KEYBOARD = 16,
};
pub const CPCFO_NONE = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.NONE;
pub const CPCFO_ENABLE_PASSWORD_REVEAL = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.ENABLE_PASSWORD_REVEAL;
pub const CPCFO_IS_EMAIL_ADDRESS = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.IS_EMAIL_ADDRESS;
pub const CPCFO_ENABLE_TOUCH_KEYBOARD_AUTO_INVOKE = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.ENABLE_TOUCH_KEYBOARD_AUTO_INVOKE;
pub const CPCFO_NUMBERS_ONLY = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.NUMBERS_ONLY;
pub const CPCFO_SHOW_ENGLISH_KEYBOARD = CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS.SHOW_ENGLISH_KEYBOARD;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProviderCredential_Value = @import("../zig.zig").Guid.initString("63913a93-40c1-481a-818d-4072ff8c70cc");
pub const IID_ICredentialProviderCredential = &IID_ICredentialProviderCredential_Value;
pub const ICredentialProviderCredential = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: fn(
            self: *const ICredentialProviderCredential,
            pcpce: ?*ICredentialProviderCredentialEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnAdvise: fn(
            self: *const ICredentialProviderCredential,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelected: fn(
            self: *const ICredentialProviderCredential,
            pbAutoLogon: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDeselected: fn(
            self: *const ICredentialProviderCredential,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldState: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            pcpfs: ?*CREDENTIAL_PROVIDER_FIELD_STATE,
            pcpfis: ?*CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringValue: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            ppsz: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBitmapValue: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            phbmp: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCheckboxValue: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            pbChecked: ?*BOOL,
            ppszLabel: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubmitButtonValue: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            pdwAdjacentTo: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComboBoxValueCount: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            pcItems: ?*u32,
            pdwSelectedItem: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComboBoxValueAt: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            dwItem: u32,
            ppszItem: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStringValue: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            psz: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCheckboxValue: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            bChecked: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetComboBoxSelectedValue: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
            dwSelectedItem: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommandLinkClicked: fn(
            self: *const ICredentialProviderCredential,
            dwFieldID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSerialization: fn(
            self: *const ICredentialProviderCredential,
            pcpgsr: ?*CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE,
            pcpcs: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
            ppszOptionalStatusText: ?*?PWSTR,
            pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportResult: fn(
            self: *const ICredentialProviderCredential,
            ntsStatus: NTSTATUS,
            ntsSubstatus: NTSTATUS,
            ppszOptionalStatusText: ?*?PWSTR,
            pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_Advise(self: *const T, pcpce: ?*ICredentialProviderCredentialEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).Advise(@ptrCast(*const ICredentialProviderCredential, self), pcpce);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_UnAdvise(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).UnAdvise(@ptrCast(*const ICredentialProviderCredential, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_SetSelected(self: *const T, pbAutoLogon: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).SetSelected(@ptrCast(*const ICredentialProviderCredential, self), pbAutoLogon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_SetDeselected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).SetDeselected(@ptrCast(*const ICredentialProviderCredential, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_GetFieldState(self: *const T, dwFieldID: u32, pcpfs: ?*CREDENTIAL_PROVIDER_FIELD_STATE, pcpfis: ?*CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).GetFieldState(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, pcpfs, pcpfis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_GetStringValue(self: *const T, dwFieldID: u32, ppsz: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).GetStringValue(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, ppsz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_GetBitmapValue(self: *const T, dwFieldID: u32, phbmp: ?*?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).GetBitmapValue(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, phbmp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_GetCheckboxValue(self: *const T, dwFieldID: u32, pbChecked: ?*BOOL, ppszLabel: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).GetCheckboxValue(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, pbChecked, ppszLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_GetSubmitButtonValue(self: *const T, dwFieldID: u32, pdwAdjacentTo: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).GetSubmitButtonValue(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, pdwAdjacentTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_GetComboBoxValueCount(self: *const T, dwFieldID: u32, pcItems: ?*u32, pdwSelectedItem: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).GetComboBoxValueCount(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, pcItems, pdwSelectedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_GetComboBoxValueAt(self: *const T, dwFieldID: u32, dwItem: u32, ppszItem: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).GetComboBoxValueAt(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, dwItem, ppszItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_SetStringValue(self: *const T, dwFieldID: u32, psz: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).SetStringValue(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_SetCheckboxValue(self: *const T, dwFieldID: u32, bChecked: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).SetCheckboxValue(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, bChecked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_SetComboBoxSelectedValue(self: *const T, dwFieldID: u32, dwSelectedItem: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).SetComboBoxSelectedValue(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID, dwSelectedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_CommandLinkClicked(self: *const T, dwFieldID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).CommandLinkClicked(@ptrCast(*const ICredentialProviderCredential, self), dwFieldID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_GetSerialization(self: *const T, pcpgsr: ?*CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE, pcpcs: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION, ppszOptionalStatusText: ?*?PWSTR, pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).GetSerialization(@ptrCast(*const ICredentialProviderCredential, self), pcpgsr, pcpcs, ppszOptionalStatusText, pcpsiOptionalStatusIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential_ReportResult(self: *const T, ntsStatus: NTSTATUS, ntsSubstatus: NTSTATUS, ppszOptionalStatusText: ?*?PWSTR, pcpsiOptionalStatusIcon: ?*CREDENTIAL_PROVIDER_STATUS_ICON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential.VTable, self.vtable).ReportResult(@ptrCast(*const ICredentialProviderCredential, self), ntsStatus, ntsSubstatus, ppszOptionalStatusText, pcpsiOptionalStatusIcon);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IQueryContinueWithStatus_Value = @import("../zig.zig").Guid.initString("9090be5b-502b-41fb-bccc-0049a6c7254b");
pub const IID_IQueryContinueWithStatus = &IID_IQueryContinueWithStatus_Value;
pub const IQueryContinueWithStatus = extern struct {
    pub const VTable = extern struct {
        base: IQueryContinue.VTable,
        SetStatusMessage: fn(
            self: *const IQueryContinueWithStatus,
            psz: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IQueryContinue.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryContinueWithStatus_SetStatusMessage(self: *const T, psz: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryContinueWithStatus.VTable, self.vtable).SetStatusMessage(@ptrCast(*const IQueryContinueWithStatus, self), psz);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConnectableCredentialProviderCredential_Value = @import("../zig.zig").Guid.initString("9387928b-ac75-4bf9-8ab2-2b93c4a55290");
pub const IID_IConnectableCredentialProviderCredential = &IID_IConnectableCredentialProviderCredential_Value;
pub const IConnectableCredentialProviderCredential = extern struct {
    pub const VTable = extern struct {
        base: ICredentialProviderCredential.VTable,
        Connect: fn(
            self: *const IConnectableCredentialProviderCredential,
            pqcws: ?*IQueryContinueWithStatus,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IConnectableCredentialProviderCredential,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICredentialProviderCredential.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectableCredentialProviderCredential_Connect(self: *const T, pqcws: ?*IQueryContinueWithStatus) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectableCredentialProviderCredential.VTable, self.vtable).Connect(@ptrCast(*const IConnectableCredentialProviderCredential, self), pqcws);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConnectableCredentialProviderCredential_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConnectableCredentialProviderCredential.VTable, self.vtable).Disconnect(@ptrCast(*const IConnectableCredentialProviderCredential, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProviderCredentialEvents_Value = @import("../zig.zig").Guid.initString("fa6fa76b-66b7-4b11-95f1-86171118e816");
pub const IID_ICredentialProviderCredentialEvents = &IID_ICredentialProviderCredentialEvents_Value;
pub const ICredentialProviderCredentialEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFieldState: fn(
            self: *const ICredentialProviderCredentialEvents,
            pcpc: ?*ICredentialProviderCredential,
            dwFieldID: u32,
            cpfs: CREDENTIAL_PROVIDER_FIELD_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFieldInteractiveState: fn(
            self: *const ICredentialProviderCredentialEvents,
            pcpc: ?*ICredentialProviderCredential,
            dwFieldID: u32,
            cpfis: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFieldString: fn(
            self: *const ICredentialProviderCredentialEvents,
            pcpc: ?*ICredentialProviderCredential,
            dwFieldID: u32,
            psz: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFieldCheckbox: fn(
            self: *const ICredentialProviderCredentialEvents,
            pcpc: ?*ICredentialProviderCredential,
            dwFieldID: u32,
            bChecked: BOOL,
            pszLabel: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFieldBitmap: fn(
            self: *const ICredentialProviderCredentialEvents,
            pcpc: ?*ICredentialProviderCredential,
            dwFieldID: u32,
            hbmp: ?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFieldComboBoxSelectedItem: fn(
            self: *const ICredentialProviderCredentialEvents,
            pcpc: ?*ICredentialProviderCredential,
            dwFieldID: u32,
            dwSelectedItem: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteFieldComboBoxItem: fn(
            self: *const ICredentialProviderCredentialEvents,
            pcpc: ?*ICredentialProviderCredential,
            dwFieldID: u32,
            dwItem: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendFieldComboBoxItem: fn(
            self: *const ICredentialProviderCredentialEvents,
            pcpc: ?*ICredentialProviderCredential,
            dwFieldID: u32,
            pszItem: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFieldSubmitButton: fn(
            self: *const ICredentialProviderCredentialEvents,
            pcpc: ?*ICredentialProviderCredential,
            dwFieldID: u32,
            dwAdjacentTo: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCreatingWindow: fn(
            self: *const ICredentialProviderCredentialEvents,
            phwndOwner: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_SetFieldState(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, cpfs: CREDENTIAL_PROVIDER_FIELD_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).SetFieldState(@ptrCast(*const ICredentialProviderCredentialEvents, self), pcpc, dwFieldID, cpfs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_SetFieldInteractiveState(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, cpfis: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).SetFieldInteractiveState(@ptrCast(*const ICredentialProviderCredentialEvents, self), pcpc, dwFieldID, cpfis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_SetFieldString(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, psz: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).SetFieldString(@ptrCast(*const ICredentialProviderCredentialEvents, self), pcpc, dwFieldID, psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_SetFieldCheckbox(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, bChecked: BOOL, pszLabel: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).SetFieldCheckbox(@ptrCast(*const ICredentialProviderCredentialEvents, self), pcpc, dwFieldID, bChecked, pszLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_SetFieldBitmap(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, hbmp: ?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).SetFieldBitmap(@ptrCast(*const ICredentialProviderCredentialEvents, self), pcpc, dwFieldID, hbmp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_SetFieldComboBoxSelectedItem(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, dwSelectedItem: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).SetFieldComboBoxSelectedItem(@ptrCast(*const ICredentialProviderCredentialEvents, self), pcpc, dwFieldID, dwSelectedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_DeleteFieldComboBoxItem(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, dwItem: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).DeleteFieldComboBoxItem(@ptrCast(*const ICredentialProviderCredentialEvents, self), pcpc, dwFieldID, dwItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_AppendFieldComboBoxItem(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, pszItem: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).AppendFieldComboBoxItem(@ptrCast(*const ICredentialProviderCredentialEvents, self), pcpc, dwFieldID, pszItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_SetFieldSubmitButton(self: *const T, pcpc: ?*ICredentialProviderCredential, dwFieldID: u32, dwAdjacentTo: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).SetFieldSubmitButton(@ptrCast(*const ICredentialProviderCredentialEvents, self), pcpc, dwFieldID, dwAdjacentTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents_OnCreatingWindow(self: *const T, phwndOwner: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents.VTable, self.vtable).OnCreatingWindow(@ptrCast(*const ICredentialProviderCredentialEvents, self), phwndOwner);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProvider_Value = @import("../zig.zig").Guid.initString("d27c3481-5a1c-45b2-8aaa-c20ebbe8229e");
pub const IID_ICredentialProvider = &IID_ICredentialProvider_Value;
pub const ICredentialProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUsageScenario: fn(
            self: *const ICredentialProvider,
            cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSerialization: fn(
            self: *const ICredentialProvider,
            pcpcs: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const ICredentialProvider,
            pcpe: ?*ICredentialProviderEvents,
            upAdviseContext: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnAdvise: fn(
            self: *const ICredentialProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldDescriptorCount: fn(
            self: *const ICredentialProvider,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldDescriptorAt: fn(
            self: *const ICredentialProvider,
            dwIndex: u32,
            ppcpfd: ?*?*CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCredentialCount: fn(
            self: *const ICredentialProvider,
            pdwCount: ?*u32,
            pdwDefault: ?*u32,
            pbAutoLogonWithDefault: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCredentialAt: fn(
            self: *const ICredentialProvider,
            dwIndex: u32,
            ppcpc: ?*?*ICredentialProviderCredential,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProvider_SetUsageScenario(self: *const T, cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProvider.VTable, self.vtable).SetUsageScenario(@ptrCast(*const ICredentialProvider, self), cpus, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProvider_SetSerialization(self: *const T, pcpcs: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProvider.VTable, self.vtable).SetSerialization(@ptrCast(*const ICredentialProvider, self), pcpcs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProvider_Advise(self: *const T, pcpe: ?*ICredentialProviderEvents, upAdviseContext: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProvider.VTable, self.vtable).Advise(@ptrCast(*const ICredentialProvider, self), pcpe, upAdviseContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProvider_UnAdvise(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProvider.VTable, self.vtable).UnAdvise(@ptrCast(*const ICredentialProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProvider_GetFieldDescriptorCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProvider.VTable, self.vtable).GetFieldDescriptorCount(@ptrCast(*const ICredentialProvider, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProvider_GetFieldDescriptorAt(self: *const T, dwIndex: u32, ppcpfd: ?*?*CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProvider.VTable, self.vtable).GetFieldDescriptorAt(@ptrCast(*const ICredentialProvider, self), dwIndex, ppcpfd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProvider_GetCredentialCount(self: *const T, pdwCount: ?*u32, pdwDefault: ?*u32, pbAutoLogonWithDefault: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProvider.VTable, self.vtable).GetCredentialCount(@ptrCast(*const ICredentialProvider, self), pdwCount, pdwDefault, pbAutoLogonWithDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProvider_GetCredentialAt(self: *const T, dwIndex: u32, ppcpc: ?*?*ICredentialProviderCredential) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProvider.VTable, self.vtable).GetCredentialAt(@ptrCast(*const ICredentialProvider, self), dwIndex, ppcpc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProviderEvents_Value = @import("../zig.zig").Guid.initString("34201e5a-a787-41a3-a5a4-bd6dcf2a854e");
pub const IID_ICredentialProviderEvents = &IID_ICredentialProviderEvents_Value;
pub const ICredentialProviderEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CredentialsChanged: fn(
            self: *const ICredentialProviderEvents,
            upAdviseContext: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderEvents_CredentialsChanged(self: *const T, upAdviseContext: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderEvents.VTable, self.vtable).CredentialsChanged(@ptrCast(*const ICredentialProviderEvents, self), upAdviseContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ICredentialProviderFilter_Value = @import("../zig.zig").Guid.initString("a5da53f9-d475-4080-a120-910c4a739880");
pub const IID_ICredentialProviderFilter = &IID_ICredentialProviderFilter_Value;
pub const ICredentialProviderFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Filter: fn(
            self: *const ICredentialProviderFilter,
            cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO,
            dwFlags: u32,
            rgclsidProviders: [*]Guid,
            rgbAllow: [*]BOOL,
            cProviders: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateRemoteCredential: fn(
            self: *const ICredentialProviderFilter,
            pcpcsIn: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
            pcpcsOut: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderFilter_Filter(self: *const T, cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO, dwFlags: u32, rgclsidProviders: [*]Guid, rgbAllow: [*]BOOL, cProviders: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderFilter.VTable, self.vtable).Filter(@ptrCast(*const ICredentialProviderFilter, self), cpus, dwFlags, rgclsidProviders, rgbAllow, cProviders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderFilter_UpdateRemoteCredential(self: *const T, pcpcsIn: ?*const CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION, pcpcsOut: ?*CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderFilter.VTable, self.vtable).UpdateRemoteCredential(@ptrCast(*const ICredentialProviderFilter, self), pcpcsIn, pcpcsOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderCredential2_Value = @import("../zig.zig").Guid.initString("fd672c54-40ea-4d6e-9b49-cfb1a7507bd7");
pub const IID_ICredentialProviderCredential2 = &IID_ICredentialProviderCredential2_Value;
pub const ICredentialProviderCredential2 = extern struct {
    pub const VTable = extern struct {
        base: ICredentialProviderCredential.VTable,
        GetUserSid: fn(
            self: *const ICredentialProviderCredential2,
            sid: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICredentialProviderCredential.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredential2_GetUserSid(self: *const T, sid: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredential2.VTable, self.vtable).GetUserSid(@ptrCast(*const ICredentialProviderCredential2, self), sid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderCredentialWithFieldOptions_Value = @import("../zig.zig").Guid.initString("dbc6fb30-c843-49e3-a645-573e6f39446a");
pub const IID_ICredentialProviderCredentialWithFieldOptions = &IID_ICredentialProviderCredentialWithFieldOptions_Value;
pub const ICredentialProviderCredentialWithFieldOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFieldOptions: fn(
            self: *const ICredentialProviderCredentialWithFieldOptions,
            fieldID: u32,
            options: ?*CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialWithFieldOptions_GetFieldOptions(self: *const T, fieldID: u32, options: ?*CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialWithFieldOptions.VTable, self.vtable).GetFieldOptions(@ptrCast(*const ICredentialProviderCredentialWithFieldOptions, self), fieldID, options);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderCredentialEvents2_Value = @import("../zig.zig").Guid.initString("b53c00b6-9922-4b78-b1f4-ddfe774dc39b");
pub const IID_ICredentialProviderCredentialEvents2 = &IID_ICredentialProviderCredentialEvents2_Value;
pub const ICredentialProviderCredentialEvents2 = extern struct {
    pub const VTable = extern struct {
        base: ICredentialProviderCredentialEvents.VTable,
        BeginFieldUpdates: fn(
            self: *const ICredentialProviderCredentialEvents2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndFieldUpdates: fn(
            self: *const ICredentialProviderCredentialEvents2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFieldOptions: fn(
            self: *const ICredentialProviderCredentialEvents2,
            credential: ?*ICredentialProviderCredential,
            fieldID: u32,
            options: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICredentialProviderCredentialEvents.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents2_BeginFieldUpdates(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents2.VTable, self.vtable).BeginFieldUpdates(@ptrCast(*const ICredentialProviderCredentialEvents2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents2_EndFieldUpdates(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents2.VTable, self.vtable).EndFieldUpdates(@ptrCast(*const ICredentialProviderCredentialEvents2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderCredentialEvents2_SetFieldOptions(self: *const T, credential: ?*ICredentialProviderCredential, fieldID: u32, options: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderCredentialEvents2.VTable, self.vtable).SetFieldOptions(@ptrCast(*const ICredentialProviderCredentialEvents2, self), credential, fieldID, options);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderUser_Value = @import("../zig.zig").Guid.initString("13793285-3ea6-40fd-b420-15f47da41fbb");
pub const IID_ICredentialProviderUser = &IID_ICredentialProviderUser_Value;
pub const ICredentialProviderUser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSid: fn(
            self: *const ICredentialProviderUser,
            sid: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderID: fn(
            self: *const ICredentialProviderUser,
            providerID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringValue: fn(
            self: *const ICredentialProviderUser,
            key: ?*const PROPERTYKEY,
            stringValue: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const ICredentialProviderUser,
            key: ?*const PROPERTYKEY,
            value: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderUser_GetSid(self: *const T, sid: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderUser.VTable, self.vtable).GetSid(@ptrCast(*const ICredentialProviderUser, self), sid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderUser_GetProviderID(self: *const T, providerID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderUser.VTable, self.vtable).GetProviderID(@ptrCast(*const ICredentialProviderUser, self), providerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderUser_GetStringValue(self: *const T, key: ?*const PROPERTYKEY, stringValue: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderUser.VTable, self.vtable).GetStringValue(@ptrCast(*const ICredentialProviderUser, self), key, stringValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderUser_GetValue(self: *const T, key: ?*const PROPERTYKEY, value: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderUser.VTable, self.vtable).GetValue(@ptrCast(*const ICredentialProviderUser, self), key, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderUserArray_Value = @import("../zig.zig").Guid.initString("90c119ae-0f18-4520-a1f1-114366a40fe8");
pub const IID_ICredentialProviderUserArray = &IID_ICredentialProviderUserArray_Value;
pub const ICredentialProviderUserArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProviderFilter: fn(
            self: *const ICredentialProviderUserArray,
            guidProviderToFilterTo: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAccountOptions: fn(
            self: *const ICredentialProviderUserArray,
            credentialProviderAccountOptions: ?*CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ICredentialProviderUserArray,
            userCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAt: fn(
            self: *const ICredentialProviderUserArray,
            userIndex: u32,
            user: ?*?*ICredentialProviderUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderUserArray_SetProviderFilter(self: *const T, guidProviderToFilterTo: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderUserArray.VTable, self.vtable).SetProviderFilter(@ptrCast(*const ICredentialProviderUserArray, self), guidProviderToFilterTo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderUserArray_GetAccountOptions(self: *const T, credentialProviderAccountOptions: ?*CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderUserArray.VTable, self.vtable).GetAccountOptions(@ptrCast(*const ICredentialProviderUserArray, self), credentialProviderAccountOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderUserArray_GetCount(self: *const T, userCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderUserArray.VTable, self.vtable).GetCount(@ptrCast(*const ICredentialProviderUserArray, self), userCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderUserArray_GetAt(self: *const T, userIndex: u32, user: ?*?*ICredentialProviderUser) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderUserArray.VTable, self.vtable).GetAt(@ptrCast(*const ICredentialProviderUserArray, self), userIndex, user);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICredentialProviderSetUserArray_Value = @import("../zig.zig").Guid.initString("095c1484-1c0c-4388-9c6d-500e61bf84bd");
pub const IID_ICredentialProviderSetUserArray = &IID_ICredentialProviderSetUserArray_Value;
pub const ICredentialProviderSetUserArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUserArray: fn(
            self: *const ICredentialProviderSetUserArray,
            users: ?*ICredentialProviderUserArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICredentialProviderSetUserArray_SetUserArray(self: *const T, users: ?*ICredentialProviderUserArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICredentialProviderSetUserArray.VTable, self.vtable).SetUserArray(@ptrCast(*const ICredentialProviderSetUserArray, self), users);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SyncMgrClient_Value = @import("../zig.zig").Guid.initString("1202db60-1dac-42c5-aed5-1abdd432248e");
pub const CLSID_SyncMgrClient = &CLSID_SyncMgrClient_Value;

const CLSID_SyncMgrControl_Value = @import("../zig.zig").Guid.initString("1a1f4206-0688-4e7f-be03-d82ec69df9a5");
pub const CLSID_SyncMgrControl = &CLSID_SyncMgrControl_Value;

const CLSID_SyncMgrScheduleWizard_Value = @import("../zig.zig").Guid.initString("8d8b8e30-c451-421b-8553-d2976afa648c");
pub const CLSID_SyncMgrScheduleWizard = &CLSID_SyncMgrScheduleWizard_Value;

const CLSID_SyncMgrFolder_Value = @import("../zig.zig").Guid.initString("9c73f5e5-7ae7-4e32-a8e8-8d23b85255bf");
pub const CLSID_SyncMgrFolder = &CLSID_SyncMgrFolder_Value;

const CLSID_SyncSetupFolder_Value = @import("../zig.zig").Guid.initString("2e9e59c0-b437-4981-a647-9c34b9b90891");
pub const CLSID_SyncSetupFolder = &CLSID_SyncSetupFolder_Value;

const CLSID_ConflictFolder_Value = @import("../zig.zig").Guid.initString("289978ac-a101-4341-a817-21eba7fd046d");
pub const CLSID_ConflictFolder = &CLSID_ConflictFolder_Value;

const CLSID_SyncResultsFolder_Value = @import("../zig.zig").Guid.initString("71d99464-3b6b-475c-b241-e15883207529");
pub const CLSID_SyncResultsFolder = &CLSID_SyncResultsFolder_Value;

const CLSID_SimpleConflictPresenter_Value = @import("../zig.zig").Guid.initString("7a0f6ab7-ed84-46b6-b47e-02aa159a152b");
pub const CLSID_SimpleConflictPresenter = &CLSID_SimpleConflictPresenter_Value;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrHandlerCollection_Value = @import("../zig.zig").Guid.initString("a7f337a3-d20b-45cb-9ed7-87d094ca5045");
pub const IID_ISyncMgrHandlerCollection = &IID_ISyncMgrHandlerCollection_Value;
pub const ISyncMgrHandlerCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHandlerEnumerator: fn(
            self: *const ISyncMgrHandlerCollection,
            ppenum: ?*?*IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToHandler: fn(
            self: *const ISyncMgrHandlerCollection,
            pszHandlerID: ?[*:0]const u16,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandlerCollection_GetHandlerEnumerator(self: *const T, ppenum: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandlerCollection.VTable, self.vtable).GetHandlerEnumerator(@ptrCast(*const ISyncMgrHandlerCollection, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandlerCollection_BindToHandler(self: *const T, pszHandlerID: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandlerCollection.VTable, self.vtable).BindToHandler(@ptrCast(*const ISyncMgrHandlerCollection, self), pszHandlerID, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_HANDLER_CAPABILITIES = enum(i32) {
    NONE = 0,
    PROVIDES_ICON = 1,
    EVENT_STORE = 2,
    CONFLICT_STORE = 4,
    SUPPORTS_CONCURRENT_SESSIONS = 16,
    CAN_BROWSE_CONTENT = 65536,
    CAN_SHOW_SCHEDULE = 131072,
    QUERY_BEFORE_ACTIVATE = 1048576,
    QUERY_BEFORE_DEACTIVATE = 2097152,
    QUERY_BEFORE_ENABLE = 4194304,
    QUERY_BEFORE_DISABLE = 8388608,
    VALID_MASK = 15925271,
};
pub const SYNCMGR_HCM_NONE = SYNCMGR_HANDLER_CAPABILITIES.NONE;
pub const SYNCMGR_HCM_PROVIDES_ICON = SYNCMGR_HANDLER_CAPABILITIES.PROVIDES_ICON;
pub const SYNCMGR_HCM_EVENT_STORE = SYNCMGR_HANDLER_CAPABILITIES.EVENT_STORE;
pub const SYNCMGR_HCM_CONFLICT_STORE = SYNCMGR_HANDLER_CAPABILITIES.CONFLICT_STORE;
pub const SYNCMGR_HCM_SUPPORTS_CONCURRENT_SESSIONS = SYNCMGR_HANDLER_CAPABILITIES.SUPPORTS_CONCURRENT_SESSIONS;
pub const SYNCMGR_HCM_CAN_BROWSE_CONTENT = SYNCMGR_HANDLER_CAPABILITIES.CAN_BROWSE_CONTENT;
pub const SYNCMGR_HCM_CAN_SHOW_SCHEDULE = SYNCMGR_HANDLER_CAPABILITIES.CAN_SHOW_SCHEDULE;
pub const SYNCMGR_HCM_QUERY_BEFORE_ACTIVATE = SYNCMGR_HANDLER_CAPABILITIES.QUERY_BEFORE_ACTIVATE;
pub const SYNCMGR_HCM_QUERY_BEFORE_DEACTIVATE = SYNCMGR_HANDLER_CAPABILITIES.QUERY_BEFORE_DEACTIVATE;
pub const SYNCMGR_HCM_QUERY_BEFORE_ENABLE = SYNCMGR_HANDLER_CAPABILITIES.QUERY_BEFORE_ENABLE;
pub const SYNCMGR_HCM_QUERY_BEFORE_DISABLE = SYNCMGR_HANDLER_CAPABILITIES.QUERY_BEFORE_DISABLE;
pub const SYNCMGR_HCM_VALID_MASK = SYNCMGR_HANDLER_CAPABILITIES.VALID_MASK;

pub const SYNCMGR_HANDLER_POLICIES = enum(i32) {
    NONE = 0,
    PREVENT_ACTIVATE = 1,
    PREVENT_DEACTIVATE = 2,
    PREVENT_ENABLE = 4,
    PREVENT_DISABLE = 8,
    PREVENT_START_SYNC = 16,
    PREVENT_STOP_SYNC = 32,
    DISABLE_ENABLE = 256,
    DISABLE_DISABLE = 512,
    DISABLE_START_SYNC = 1024,
    DISABLE_STOP_SYNC = 2048,
    DISABLE_BROWSE = 4096,
    DISABLE_SCHEDULE = 8192,
    HIDDEN_BY_DEFAULT = 65536,
    BACKGROUND_SYNC_ONLY = 48,
    VALID_MASK = 77631,
};
pub const SYNCMGR_HPM_NONE = SYNCMGR_HANDLER_POLICIES.NONE;
pub const SYNCMGR_HPM_PREVENT_ACTIVATE = SYNCMGR_HANDLER_POLICIES.PREVENT_ACTIVATE;
pub const SYNCMGR_HPM_PREVENT_DEACTIVATE = SYNCMGR_HANDLER_POLICIES.PREVENT_DEACTIVATE;
pub const SYNCMGR_HPM_PREVENT_ENABLE = SYNCMGR_HANDLER_POLICIES.PREVENT_ENABLE;
pub const SYNCMGR_HPM_PREVENT_DISABLE = SYNCMGR_HANDLER_POLICIES.PREVENT_DISABLE;
pub const SYNCMGR_HPM_PREVENT_START_SYNC = SYNCMGR_HANDLER_POLICIES.PREVENT_START_SYNC;
pub const SYNCMGR_HPM_PREVENT_STOP_SYNC = SYNCMGR_HANDLER_POLICIES.PREVENT_STOP_SYNC;
pub const SYNCMGR_HPM_DISABLE_ENABLE = SYNCMGR_HANDLER_POLICIES.DISABLE_ENABLE;
pub const SYNCMGR_HPM_DISABLE_DISABLE = SYNCMGR_HANDLER_POLICIES.DISABLE_DISABLE;
pub const SYNCMGR_HPM_DISABLE_START_SYNC = SYNCMGR_HANDLER_POLICIES.DISABLE_START_SYNC;
pub const SYNCMGR_HPM_DISABLE_STOP_SYNC = SYNCMGR_HANDLER_POLICIES.DISABLE_STOP_SYNC;
pub const SYNCMGR_HPM_DISABLE_BROWSE = SYNCMGR_HANDLER_POLICIES.DISABLE_BROWSE;
pub const SYNCMGR_HPM_DISABLE_SCHEDULE = SYNCMGR_HANDLER_POLICIES.DISABLE_SCHEDULE;
pub const SYNCMGR_HPM_HIDDEN_BY_DEFAULT = SYNCMGR_HANDLER_POLICIES.HIDDEN_BY_DEFAULT;
pub const SYNCMGR_HPM_BACKGROUND_SYNC_ONLY = SYNCMGR_HANDLER_POLICIES.BACKGROUND_SYNC_ONLY;
pub const SYNCMGR_HPM_VALID_MASK = SYNCMGR_HANDLER_POLICIES.VALID_MASK;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrHandler_Value = @import("../zig.zig").Guid.initString("04ec2e43-ac77-49f9-9b98-0307ef7a72a2");
pub const IID_ISyncMgrHandler = &IID_ISyncMgrHandler_Value;
pub const ISyncMgrHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const ISyncMgrHandler,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHandlerInfo: fn(
            self: *const ISyncMgrHandler,
            ppHandlerInfo: ?*?*ISyncMgrHandlerInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const ISyncMgrHandler,
            rguidObjectID: ?*const Guid,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCapabilities: fn(
            self: *const ISyncMgrHandler,
            pmCapabilities: ?*SYNCMGR_HANDLER_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPolicies: fn(
            self: *const ISyncMgrHandler,
            pmPolicies: ?*SYNCMGR_HANDLER_POLICIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: fn(
            self: *const ISyncMgrHandler,
            fActivate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const ISyncMgrHandler,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Synchronize: fn(
            self: *const ISyncMgrHandler,
            ppszItemIDs: [*]?PWSTR,
            cItems: u32,
            hwndOwner: ?HWND,
            pSessionCreator: ?*ISyncMgrSessionCreator,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandler_GetName(self: *const T, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandler.VTable, self.vtable).GetName(@ptrCast(*const ISyncMgrHandler, self), ppszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandler_GetHandlerInfo(self: *const T, ppHandlerInfo: ?*?*ISyncMgrHandlerInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandler.VTable, self.vtable).GetHandlerInfo(@ptrCast(*const ISyncMgrHandler, self), ppHandlerInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandler_GetObject(self: *const T, rguidObjectID: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandler.VTable, self.vtable).GetObject(@ptrCast(*const ISyncMgrHandler, self), rguidObjectID, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandler_GetCapabilities(self: *const T, pmCapabilities: ?*SYNCMGR_HANDLER_CAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandler.VTable, self.vtable).GetCapabilities(@ptrCast(*const ISyncMgrHandler, self), pmCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandler_GetPolicies(self: *const T, pmPolicies: ?*SYNCMGR_HANDLER_POLICIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandler.VTable, self.vtable).GetPolicies(@ptrCast(*const ISyncMgrHandler, self), pmPolicies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandler_Activate(self: *const T, fActivate: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandler.VTable, self.vtable).Activate(@ptrCast(*const ISyncMgrHandler, self), fActivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandler_Enable(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandler.VTable, self.vtable).Enable(@ptrCast(*const ISyncMgrHandler, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandler_Synchronize(self: *const T, ppszItemIDs: [*]?PWSTR, cItems: u32, hwndOwner: ?HWND, pSessionCreator: ?*ISyncMgrSessionCreator, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandler.VTable, self.vtable).Synchronize(@ptrCast(*const ISyncMgrHandler, self), ppszItemIDs, cItems, hwndOwner, pSessionCreator, punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_HANDLER_TYPE = enum(i32) {
    UNSPECIFIED = 0,
    APPLICATION = 1,
    DEVICE = 2,
    FOLDER = 3,
    SERVICE = 4,
    COMPUTER = 5,
    // MIN = 0, this enum value conflicts with UNSPECIFIED
    // MAX = 5, this enum value conflicts with COMPUTER
};
pub const SYNCMGR_HT_UNSPECIFIED = SYNCMGR_HANDLER_TYPE.UNSPECIFIED;
pub const SYNCMGR_HT_APPLICATION = SYNCMGR_HANDLER_TYPE.APPLICATION;
pub const SYNCMGR_HT_DEVICE = SYNCMGR_HANDLER_TYPE.DEVICE;
pub const SYNCMGR_HT_FOLDER = SYNCMGR_HANDLER_TYPE.FOLDER;
pub const SYNCMGR_HT_SERVICE = SYNCMGR_HANDLER_TYPE.SERVICE;
pub const SYNCMGR_HT_COMPUTER = SYNCMGR_HANDLER_TYPE.COMPUTER;
pub const SYNCMGR_HT_MIN = SYNCMGR_HANDLER_TYPE.UNSPECIFIED;
pub const SYNCMGR_HT_MAX = SYNCMGR_HANDLER_TYPE.COMPUTER;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrHandlerInfo_Value = @import("../zig.zig").Guid.initString("4ff1d798-ecf7-4524-aa81-1e362a0aef3a");
pub const IID_ISyncMgrHandlerInfo = &IID_ISyncMgrHandlerInfo_Value;
pub const ISyncMgrHandlerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: fn(
            self: *const ISyncMgrHandlerInfo,
            pnType: ?*SYNCMGR_HANDLER_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeLabel: fn(
            self: *const ISyncMgrHandlerInfo,
            ppszTypeLabel: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComment: fn(
            self: *const ISyncMgrHandlerInfo,
            ppszComment: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastSyncTime: fn(
            self: *const ISyncMgrHandlerInfo,
            pftLastSync: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsActive: fn(
            self: *const ISyncMgrHandlerInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEnabled: fn(
            self: *const ISyncMgrHandlerInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConnected: fn(
            self: *const ISyncMgrHandlerInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandlerInfo_GetType(self: *const T, pnType: ?*SYNCMGR_HANDLER_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandlerInfo.VTable, self.vtable).GetType(@ptrCast(*const ISyncMgrHandlerInfo, self), pnType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandlerInfo_GetTypeLabel(self: *const T, ppszTypeLabel: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandlerInfo.VTable, self.vtable).GetTypeLabel(@ptrCast(*const ISyncMgrHandlerInfo, self), ppszTypeLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandlerInfo_GetComment(self: *const T, ppszComment: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandlerInfo.VTable, self.vtable).GetComment(@ptrCast(*const ISyncMgrHandlerInfo, self), ppszComment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandlerInfo_GetLastSyncTime(self: *const T, pftLastSync: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandlerInfo.VTable, self.vtable).GetLastSyncTime(@ptrCast(*const ISyncMgrHandlerInfo, self), pftLastSync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandlerInfo_IsActive(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandlerInfo.VTable, self.vtable).IsActive(@ptrCast(*const ISyncMgrHandlerInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandlerInfo_IsEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandlerInfo.VTable, self.vtable).IsEnabled(@ptrCast(*const ISyncMgrHandlerInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrHandlerInfo_IsConnected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrHandlerInfo.VTable, self.vtable).IsConnected(@ptrCast(*const ISyncMgrHandlerInfo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncItemContainer_Value = @import("../zig.zig").Guid.initString("90701133-be32-4129-a65c-99e616cafff4");
pub const IID_ISyncMgrSyncItemContainer = &IID_ISyncMgrSyncItemContainer_Value;
pub const ISyncMgrSyncItemContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSyncItem: fn(
            self: *const ISyncMgrSyncItemContainer,
            pszItemID: ?[*:0]const u16,
            ppItem: ?*?*ISyncMgrSyncItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSyncItemEnumerator: fn(
            self: *const ISyncMgrSyncItemContainer,
            ppenum: ?*?*IEnumSyncMgrSyncItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSyncItemCount: fn(
            self: *const ISyncMgrSyncItemContainer,
            pcItems: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItemContainer_GetSyncItem(self: *const T, pszItemID: ?[*:0]const u16, ppItem: ?*?*ISyncMgrSyncItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItemContainer.VTable, self.vtable).GetSyncItem(@ptrCast(*const ISyncMgrSyncItemContainer, self), pszItemID, ppItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItemContainer_GetSyncItemEnumerator(self: *const T, ppenum: ?*?*IEnumSyncMgrSyncItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItemContainer.VTable, self.vtable).GetSyncItemEnumerator(@ptrCast(*const ISyncMgrSyncItemContainer, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItemContainer_GetSyncItemCount(self: *const T, pcItems: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItemContainer.VTable, self.vtable).GetSyncItemCount(@ptrCast(*const ISyncMgrSyncItemContainer, self), pcItems);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_ITEM_CAPABILITIES = enum(i32) {
    NONE = 0,
    PROVIDES_ICON = 1,
    EVENT_STORE = 2,
    CONFLICT_STORE = 4,
    CAN_DELETE = 16,
    CAN_BROWSE_CONTENT = 65536,
    QUERY_BEFORE_ENABLE = 1048576,
    QUERY_BEFORE_DISABLE = 2097152,
    QUERY_BEFORE_DELETE = 4194304,
    VALID_MASK = 7405591,
};
pub const SYNCMGR_ICM_NONE = SYNCMGR_ITEM_CAPABILITIES.NONE;
pub const SYNCMGR_ICM_PROVIDES_ICON = SYNCMGR_ITEM_CAPABILITIES.PROVIDES_ICON;
pub const SYNCMGR_ICM_EVENT_STORE = SYNCMGR_ITEM_CAPABILITIES.EVENT_STORE;
pub const SYNCMGR_ICM_CONFLICT_STORE = SYNCMGR_ITEM_CAPABILITIES.CONFLICT_STORE;
pub const SYNCMGR_ICM_CAN_DELETE = SYNCMGR_ITEM_CAPABILITIES.CAN_DELETE;
pub const SYNCMGR_ICM_CAN_BROWSE_CONTENT = SYNCMGR_ITEM_CAPABILITIES.CAN_BROWSE_CONTENT;
pub const SYNCMGR_ICM_QUERY_BEFORE_ENABLE = SYNCMGR_ITEM_CAPABILITIES.QUERY_BEFORE_ENABLE;
pub const SYNCMGR_ICM_QUERY_BEFORE_DISABLE = SYNCMGR_ITEM_CAPABILITIES.QUERY_BEFORE_DISABLE;
pub const SYNCMGR_ICM_QUERY_BEFORE_DELETE = SYNCMGR_ITEM_CAPABILITIES.QUERY_BEFORE_DELETE;
pub const SYNCMGR_ICM_VALID_MASK = SYNCMGR_ITEM_CAPABILITIES.VALID_MASK;

pub const SYNCMGR_ITEM_POLICIES = enum(i32) {
    NONE = 0,
    PREVENT_ENABLE = 1,
    PREVENT_DISABLE = 2,
    PREVENT_START_SYNC = 4,
    PREVENT_STOP_SYNC = 8,
    DISABLE_ENABLE = 16,
    DISABLE_DISABLE = 32,
    DISABLE_START_SYNC = 64,
    DISABLE_STOP_SYNC = 128,
    DISABLE_BROWSE = 256,
    DISABLE_DELETE = 512,
    HIDDEN_BY_DEFAULT = 65536,
    VALID_MASK = 66303,
};
pub const SYNCMGR_IPM_NONE = SYNCMGR_ITEM_POLICIES.NONE;
pub const SYNCMGR_IPM_PREVENT_ENABLE = SYNCMGR_ITEM_POLICIES.PREVENT_ENABLE;
pub const SYNCMGR_IPM_PREVENT_DISABLE = SYNCMGR_ITEM_POLICIES.PREVENT_DISABLE;
pub const SYNCMGR_IPM_PREVENT_START_SYNC = SYNCMGR_ITEM_POLICIES.PREVENT_START_SYNC;
pub const SYNCMGR_IPM_PREVENT_STOP_SYNC = SYNCMGR_ITEM_POLICIES.PREVENT_STOP_SYNC;
pub const SYNCMGR_IPM_DISABLE_ENABLE = SYNCMGR_ITEM_POLICIES.DISABLE_ENABLE;
pub const SYNCMGR_IPM_DISABLE_DISABLE = SYNCMGR_ITEM_POLICIES.DISABLE_DISABLE;
pub const SYNCMGR_IPM_DISABLE_START_SYNC = SYNCMGR_ITEM_POLICIES.DISABLE_START_SYNC;
pub const SYNCMGR_IPM_DISABLE_STOP_SYNC = SYNCMGR_ITEM_POLICIES.DISABLE_STOP_SYNC;
pub const SYNCMGR_IPM_DISABLE_BROWSE = SYNCMGR_ITEM_POLICIES.DISABLE_BROWSE;
pub const SYNCMGR_IPM_DISABLE_DELETE = SYNCMGR_ITEM_POLICIES.DISABLE_DELETE;
pub const SYNCMGR_IPM_HIDDEN_BY_DEFAULT = SYNCMGR_ITEM_POLICIES.HIDDEN_BY_DEFAULT;
pub const SYNCMGR_IPM_VALID_MASK = SYNCMGR_ITEM_POLICIES.VALID_MASK;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncItem_Value = @import("../zig.zig").Guid.initString("b20b24ce-2593-4f04-bd8b-7ad6c45051cd");
pub const IID_ISyncMgrSyncItem = &IID_ISyncMgrSyncItem_Value;
pub const ISyncMgrSyncItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemID: fn(
            self: *const ISyncMgrSyncItem,
            ppszItemID: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const ISyncMgrSyncItem,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemInfo: fn(
            self: *const ISyncMgrSyncItem,
            ppItemInfo: ?*?*ISyncMgrSyncItemInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const ISyncMgrSyncItem,
            rguidObjectID: ?*const Guid,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCapabilities: fn(
            self: *const ISyncMgrSyncItem,
            pmCapabilities: ?*SYNCMGR_ITEM_CAPABILITIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPolicies: fn(
            self: *const ISyncMgrSyncItem,
            pmPolicies: ?*SYNCMGR_ITEM_POLICIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enable: fn(
            self: *const ISyncMgrSyncItem,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const ISyncMgrSyncItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItem_GetItemID(self: *const T, ppszItemID: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItem.VTable, self.vtable).GetItemID(@ptrCast(*const ISyncMgrSyncItem, self), ppszItemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItem_GetName(self: *const T, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItem.VTable, self.vtable).GetName(@ptrCast(*const ISyncMgrSyncItem, self), ppszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItem_GetItemInfo(self: *const T, ppItemInfo: ?*?*ISyncMgrSyncItemInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItem.VTable, self.vtable).GetItemInfo(@ptrCast(*const ISyncMgrSyncItem, self), ppItemInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItem_GetObject(self: *const T, rguidObjectID: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItem.VTable, self.vtable).GetObject(@ptrCast(*const ISyncMgrSyncItem, self), rguidObjectID, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItem_GetCapabilities(self: *const T, pmCapabilities: ?*SYNCMGR_ITEM_CAPABILITIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItem.VTable, self.vtable).GetCapabilities(@ptrCast(*const ISyncMgrSyncItem, self), pmCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItem_GetPolicies(self: *const T, pmPolicies: ?*SYNCMGR_ITEM_POLICIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItem.VTable, self.vtable).GetPolicies(@ptrCast(*const ISyncMgrSyncItem, self), pmPolicies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItem_Enable(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItem.VTable, self.vtable).Enable(@ptrCast(*const ISyncMgrSyncItem, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItem_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItem.VTable, self.vtable).Delete(@ptrCast(*const ISyncMgrSyncItem, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncItemInfo_Value = @import("../zig.zig").Guid.initString("e7fd9502-be0c-4464-90a1-2b5277031232");
pub const IID_ISyncMgrSyncItemInfo = &IID_ISyncMgrSyncItemInfo_Value;
pub const ISyncMgrSyncItemInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeLabel: fn(
            self: *const ISyncMgrSyncItemInfo,
            ppszTypeLabel: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComment: fn(
            self: *const ISyncMgrSyncItemInfo,
            ppszComment: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastSyncTime: fn(
            self: *const ISyncMgrSyncItemInfo,
            pftLastSync: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEnabled: fn(
            self: *const ISyncMgrSyncItemInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsConnected: fn(
            self: *const ISyncMgrSyncItemInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItemInfo_GetTypeLabel(self: *const T, ppszTypeLabel: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItemInfo.VTable, self.vtable).GetTypeLabel(@ptrCast(*const ISyncMgrSyncItemInfo, self), ppszTypeLabel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItemInfo_GetComment(self: *const T, ppszComment: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItemInfo.VTable, self.vtable).GetComment(@ptrCast(*const ISyncMgrSyncItemInfo, self), ppszComment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItemInfo_GetLastSyncTime(self: *const T, pftLastSync: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItemInfo.VTable, self.vtable).GetLastSyncTime(@ptrCast(*const ISyncMgrSyncItemInfo, self), pftLastSync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItemInfo_IsEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItemInfo.VTable, self.vtable).IsEnabled(@ptrCast(*const ISyncMgrSyncItemInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncItemInfo_IsConnected(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncItemInfo.VTable, self.vtable).IsConnected(@ptrCast(*const ISyncMgrSyncItemInfo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumSyncMgrSyncItems_Value = @import("../zig.zig").Guid.initString("54b3abf3-f085-4181-b546-e29c403c726b");
pub const IID_IEnumSyncMgrSyncItems = &IID_IEnumSyncMgrSyncItems_Value;
pub const IEnumSyncMgrSyncItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSyncMgrSyncItems,
            celt: u32,
            rgelt: [*]?*ISyncMgrSyncItem,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSyncMgrSyncItems,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSyncMgrSyncItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSyncMgrSyncItems,
            ppenum: ?*?*IEnumSyncMgrSyncItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrSyncItems_Next(self: *const T, celt: u32, rgelt: [*]?*ISyncMgrSyncItem, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrSyncItems.VTable, self.vtable).Next(@ptrCast(*const IEnumSyncMgrSyncItems, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrSyncItems_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrSyncItems.VTable, self.vtable).Skip(@ptrCast(*const IEnumSyncMgrSyncItems, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrSyncItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrSyncItems.VTable, self.vtable).Reset(@ptrCast(*const IEnumSyncMgrSyncItems, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrSyncItems_Clone(self: *const T, ppenum: ?*?*IEnumSyncMgrSyncItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrSyncItems.VTable, self.vtable).Clone(@ptrCast(*const IEnumSyncMgrSyncItems, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_PROGRESS_STATUS = enum(i32) {
    UPDATING = 1,
    UPDATING_INDETERMINATE = 2,
    SUCCEEDED = 3,
    FAILED = 4,
    CANCELED = 5,
    DISCONNECTED = 6,
    // MAX = 6, this enum value conflicts with DISCONNECTED
};
pub const SYNCMGR_PS_UPDATING = SYNCMGR_PROGRESS_STATUS.UPDATING;
pub const SYNCMGR_PS_UPDATING_INDETERMINATE = SYNCMGR_PROGRESS_STATUS.UPDATING_INDETERMINATE;
pub const SYNCMGR_PS_SUCCEEDED = SYNCMGR_PROGRESS_STATUS.SUCCEEDED;
pub const SYNCMGR_PS_FAILED = SYNCMGR_PROGRESS_STATUS.FAILED;
pub const SYNCMGR_PS_CANCELED = SYNCMGR_PROGRESS_STATUS.CANCELED;
pub const SYNCMGR_PS_DISCONNECTED = SYNCMGR_PROGRESS_STATUS.DISCONNECTED;
pub const SYNCMGR_PS_MAX = SYNCMGR_PROGRESS_STATUS.DISCONNECTED;

pub const SYNCMGR_CANCEL_REQUEST = enum(i32) {
    NONE = 0,
    CANCEL_ITEM = 1,
    CANCEL_ALL = 2,
    // MAX = 2, this enum value conflicts with CANCEL_ALL
};
pub const SYNCMGR_CR_NONE = SYNCMGR_CANCEL_REQUEST.NONE;
pub const SYNCMGR_CR_CANCEL_ITEM = SYNCMGR_CANCEL_REQUEST.CANCEL_ITEM;
pub const SYNCMGR_CR_CANCEL_ALL = SYNCMGR_CANCEL_REQUEST.CANCEL_ALL;
pub const SYNCMGR_CR_MAX = SYNCMGR_CANCEL_REQUEST.CANCEL_ALL;

pub const SYNCMGR_EVENT_LEVEL = enum(i32) {
    INFORMATION = 1,
    WARNING = 2,
    ERROR = 3,
    // MAX = 3, this enum value conflicts with ERROR
};
pub const SYNCMGR_EL_INFORMATION = SYNCMGR_EVENT_LEVEL.INFORMATION;
pub const SYNCMGR_EL_WARNING = SYNCMGR_EVENT_LEVEL.WARNING;
pub const SYNCMGR_EL_ERROR = SYNCMGR_EVENT_LEVEL.ERROR;
pub const SYNCMGR_EL_MAX = SYNCMGR_EVENT_LEVEL.ERROR;

pub const SYNCMGR_EVENT_FLAGS = enum(i32) {
    NONE = 0,
    // VALID = 0, this enum value conflicts with NONE
};
pub const SYNCMGR_EF_NONE = SYNCMGR_EVENT_FLAGS.NONE;
pub const SYNCMGR_EF_VALID = SYNCMGR_EVENT_FLAGS.NONE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSessionCreator_Value = @import("../zig.zig").Guid.initString("17f48517-f305-4321-a08d-b25a834918fd");
pub const IID_ISyncMgrSessionCreator = &IID_ISyncMgrSessionCreator_Value;
pub const ISyncMgrSessionCreator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSession: fn(
            self: *const ISyncMgrSessionCreator,
            pszHandlerID: ?[*:0]const u16,
            ppszItemIDs: [*]?PWSTR,
            cItems: u32,
            ppCallback: ?*?*ISyncMgrSyncCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSessionCreator_CreateSession(self: *const T, pszHandlerID: ?[*:0]const u16, ppszItemIDs: [*]?PWSTR, cItems: u32, ppCallback: ?*?*ISyncMgrSyncCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSessionCreator.VTable, self.vtable).CreateSession(@ptrCast(*const ISyncMgrSessionCreator, self), pszHandlerID, ppszItemIDs, cItems, ppCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncCallback_Value = @import("../zig.zig").Guid.initString("884ccd87-b139-4937-a4ba-4f8e19513fbe");
pub const IID_ISyncMgrSyncCallback = &IID_ISyncMgrSyncCallback_Value;
pub const ISyncMgrSyncCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportProgress: fn(
            self: *const ISyncMgrSyncCallback,
            pszItemID: ?[*:0]const u16,
            pszProgressText: ?[*:0]const u16,
            nStatus: SYNCMGR_PROGRESS_STATUS,
            uCurrentStep: u32,
            uMaxStep: u32,
            pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHandlerProgressText: fn(
            self: *const ISyncMgrSyncCallback,
            pszProgressText: ?[*:0]const u16,
            pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportEvent: fn(
            self: *const ISyncMgrSyncCallback,
            pszItemID: ?[*:0]const u16,
            nLevel: SYNCMGR_EVENT_LEVEL,
            nFlags: SYNCMGR_EVENT_FLAGS,
            pszName: ?[*:0]const u16,
            pszDescription: ?[*:0]const u16,
            pszLinkText: ?[*:0]const u16,
            pszLinkReference: ?[*:0]const u16,
            pszContext: ?[*:0]const u16,
            pguidEventID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanContinue: fn(
            self: *const ISyncMgrSyncCallback,
            pszItemID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryForAdditionalItems: fn(
            self: *const ISyncMgrSyncCallback,
            ppenumItemIDs: ?*?*IEnumString,
            ppenumPunks: ?*?*IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddItemToSession: fn(
            self: *const ISyncMgrSyncCallback,
            pszItemID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddIUnknownToSession: fn(
            self: *const ISyncMgrSyncCallback,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProposeItem: fn(
            self: *const ISyncMgrSyncCallback,
            pNewItem: ?*ISyncMgrSyncItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitItem: fn(
            self: *const ISyncMgrSyncCallback,
            pszItemID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportManualSync: fn(
            self: *const ISyncMgrSyncCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_ReportProgress(self: *const T, pszItemID: ?[*:0]const u16, pszProgressText: ?[*:0]const u16, nStatus: SYNCMGR_PROGRESS_STATUS, uCurrentStep: u32, uMaxStep: u32, pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).ReportProgress(@ptrCast(*const ISyncMgrSyncCallback, self), pszItemID, pszProgressText, nStatus, uCurrentStep, uMaxStep, pnCancelRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_SetHandlerProgressText(self: *const T, pszProgressText: ?[*:0]const u16, pnCancelRequest: ?*SYNCMGR_CANCEL_REQUEST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).SetHandlerProgressText(@ptrCast(*const ISyncMgrSyncCallback, self), pszProgressText, pnCancelRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_ReportEvent(self: *const T, pszItemID: ?[*:0]const u16, nLevel: SYNCMGR_EVENT_LEVEL, nFlags: SYNCMGR_EVENT_FLAGS, pszName: ?[*:0]const u16, pszDescription: ?[*:0]const u16, pszLinkText: ?[*:0]const u16, pszLinkReference: ?[*:0]const u16, pszContext: ?[*:0]const u16, pguidEventID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).ReportEvent(@ptrCast(*const ISyncMgrSyncCallback, self), pszItemID, nLevel, nFlags, pszName, pszDescription, pszLinkText, pszLinkReference, pszContext, pguidEventID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_CanContinue(self: *const T, pszItemID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).CanContinue(@ptrCast(*const ISyncMgrSyncCallback, self), pszItemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_QueryForAdditionalItems(self: *const T, ppenumItemIDs: ?*?*IEnumString, ppenumPunks: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).QueryForAdditionalItems(@ptrCast(*const ISyncMgrSyncCallback, self), ppenumItemIDs, ppenumPunks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_AddItemToSession(self: *const T, pszItemID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).AddItemToSession(@ptrCast(*const ISyncMgrSyncCallback, self), pszItemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_AddIUnknownToSession(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).AddIUnknownToSession(@ptrCast(*const ISyncMgrSyncCallback, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_ProposeItem(self: *const T, pNewItem: ?*ISyncMgrSyncItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).ProposeItem(@ptrCast(*const ISyncMgrSyncCallback, self), pNewItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_CommitItem(self: *const T, pszItemID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).CommitItem(@ptrCast(*const ISyncMgrSyncCallback, self), pszItemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncCallback_ReportManualSync(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncCallback.VTable, self.vtable).ReportManualSync(@ptrCast(*const ISyncMgrSyncCallback, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrUIOperation_Value = @import("../zig.zig").Guid.initString("fc7cfa47-dfe1-45b5-a049-8cfd82bec271");
pub const IID_ISyncMgrUIOperation = &IID_ISyncMgrUIOperation_Value;
pub const ISyncMgrUIOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Run: fn(
            self: *const ISyncMgrUIOperation,
            hwndOwner: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrUIOperation_Run(self: *const T, hwndOwner: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrUIOperation.VTable, self.vtable).Run(@ptrCast(*const ISyncMgrUIOperation, self), hwndOwner);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrEventLinkUIOperation_Value = @import("../zig.zig").Guid.initString("64522e52-848b-4015-89ce-5a36f00b94ff");
pub const IID_ISyncMgrEventLinkUIOperation = &IID_ISyncMgrEventLinkUIOperation_Value;
pub const ISyncMgrEventLinkUIOperation = extern struct {
    pub const VTable = extern struct {
        base: ISyncMgrUIOperation.VTable,
        Init: fn(
            self: *const ISyncMgrEventLinkUIOperation,
            rguidEventID: ?*const Guid,
            pEvent: ?*ISyncMgrEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncMgrUIOperation.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEventLinkUIOperation_Init(self: *const T, rguidEventID: ?*const Guid, pEvent: ?*ISyncMgrEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEventLinkUIOperation.VTable, self.vtable).Init(@ptrCast(*const ISyncMgrEventLinkUIOperation, self), rguidEventID, pEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrScheduleWizardUIOperation_Value = @import("../zig.zig").Guid.initString("459a6c84-21d2-4ddc-8a53-f023a46066f2");
pub const IID_ISyncMgrScheduleWizardUIOperation = &IID_ISyncMgrScheduleWizardUIOperation_Value;
pub const ISyncMgrScheduleWizardUIOperation = extern struct {
    pub const VTable = extern struct {
        base: ISyncMgrUIOperation.VTable,
        InitWizard: fn(
            self: *const ISyncMgrScheduleWizardUIOperation,
            pszHandlerID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISyncMgrUIOperation.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrScheduleWizardUIOperation_InitWizard(self: *const T, pszHandlerID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrScheduleWizardUIOperation.VTable, self.vtable).InitWizard(@ptrCast(*const ISyncMgrScheduleWizardUIOperation, self), pszHandlerID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrSyncResult_Value = @import("../zig.zig").Guid.initString("2b90f17e-5a3e-4b33-bb7f-1bc48056b94d");
pub const IID_ISyncMgrSyncResult = &IID_ISyncMgrSyncResult_Value;
pub const ISyncMgrSyncResult = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Result: fn(
            self: *const ISyncMgrSyncResult,
            nStatus: SYNCMGR_PROGRESS_STATUS,
            cError: u32,
            cConflicts: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSyncResult_Result(self: *const T, nStatus: SYNCMGR_PROGRESS_STATUS, cError: u32, cConflicts: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSyncResult.VTable, self.vtable).Result(@ptrCast(*const ISyncMgrSyncResult, self), nStatus, cError, cConflicts);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_CONTROL_FLAGS = enum(i32) {
    NONE = 0,
    // NOWAIT = 0, this enum value conflicts with NONE
    WAIT = 1,
    NOUI = 2,
    VALID = 3,
};
pub const SYNCMGR_CF_NONE = SYNCMGR_CONTROL_FLAGS.NONE;
pub const SYNCMGR_CF_NOWAIT = SYNCMGR_CONTROL_FLAGS.NONE;
pub const SYNCMGR_CF_WAIT = SYNCMGR_CONTROL_FLAGS.WAIT;
pub const SYNCMGR_CF_NOUI = SYNCMGR_CONTROL_FLAGS.NOUI;
pub const SYNCMGR_CF_VALID = SYNCMGR_CONTROL_FLAGS.VALID;

pub const SYNCMGR_SYNC_CONTROL_FLAGS = enum(i32) {
    NONE = 0,
    IGNORE_IF_ALREADY_SYNCING = 1,
    // VALID = 1, this enum value conflicts with IGNORE_IF_ALREADY_SYNCING
};
pub const SYNCMGR_SCF_NONE = SYNCMGR_SYNC_CONTROL_FLAGS.NONE;
pub const SYNCMGR_SCF_IGNORE_IF_ALREADY_SYNCING = SYNCMGR_SYNC_CONTROL_FLAGS.IGNORE_IF_ALREADY_SYNCING;
pub const SYNCMGR_SCF_VALID = SYNCMGR_SYNC_CONTROL_FLAGS.IGNORE_IF_ALREADY_SYNCING;

pub const SYNCMGR_UPDATE_REASON = enum(i32) {
    ADDED = 0,
    CHANGED = 1,
    REMOVED = 2,
    // MAX = 2, this enum value conflicts with REMOVED
};
pub const SYNCMGR_UR_ADDED = SYNCMGR_UPDATE_REASON.ADDED;
pub const SYNCMGR_UR_CHANGED = SYNCMGR_UPDATE_REASON.CHANGED;
pub const SYNCMGR_UR_REMOVED = SYNCMGR_UPDATE_REASON.REMOVED;
pub const SYNCMGR_UR_MAX = SYNCMGR_UPDATE_REASON.REMOVED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrControl_Value = @import("../zig.zig").Guid.initString("9b63616c-36b2-46bc-959f-c1593952d19b");
pub const IID_ISyncMgrControl = &IID_ISyncMgrControl_Value;
pub const ISyncMgrControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartHandlerSync: fn(
            self: *const ISyncMgrControl,
            pszHandlerID: ?[*:0]const u16,
            hwndOwner: ?HWND,
            punk: ?*IUnknown,
            nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS,
            pResult: ?*ISyncMgrSyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartItemSync: fn(
            self: *const ISyncMgrControl,
            pszHandlerID: ?[*:0]const u16,
            ppszItemIDs: [*]?PWSTR,
            cItems: u32,
            hwndOwner: ?HWND,
            punk: ?*IUnknown,
            nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS,
            pResult: ?*ISyncMgrSyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSyncAll: fn(
            self: *const ISyncMgrControl,
            hwndOwner: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopHandlerSync: fn(
            self: *const ISyncMgrControl,
            pszHandlerID: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopItemSync: fn(
            self: *const ISyncMgrControl,
            pszHandlerID: ?[*:0]const u16,
            ppszItemIDs: [*]?PWSTR,
            cItems: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopSyncAll: fn(
            self: *const ISyncMgrControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateHandlerCollection: fn(
            self: *const ISyncMgrControl,
            rclsidCollectionID: ?*const Guid,
            nControlFlags: SYNCMGR_CONTROL_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateHandler: fn(
            self: *const ISyncMgrControl,
            pszHandlerID: ?[*:0]const u16,
            nControlFlags: SYNCMGR_CONTROL_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateItem: fn(
            self: *const ISyncMgrControl,
            pszHandlerID: ?[*:0]const u16,
            pszItemID: ?[*:0]const u16,
            nControlFlags: SYNCMGR_CONTROL_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateEvents: fn(
            self: *const ISyncMgrControl,
            pszHandlerID: ?[*:0]const u16,
            pszItemID: ?[*:0]const u16,
            nControlFlags: SYNCMGR_CONTROL_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateConflict: fn(
            self: *const ISyncMgrControl,
            pszHandlerID: ?[*:0]const u16,
            pszItemID: ?[*:0]const u16,
            pConflict: ?*ISyncMgrConflict,
            nReason: SYNCMGR_UPDATE_REASON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateConflicts: fn(
            self: *const ISyncMgrControl,
            pszHandlerID: ?[*:0]const u16,
            pszItemID: ?[*:0]const u16,
            nControlFlags: SYNCMGR_CONTROL_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateHandler: fn(
            self: *const ISyncMgrControl,
            fActivate: BOOL,
            pszHandlerID: ?[*:0]const u16,
            hwndOwner: ?HWND,
            nControlFlags: SYNCMGR_CONTROL_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableHandler: fn(
            self: *const ISyncMgrControl,
            fEnable: BOOL,
            pszHandlerID: ?[*:0]const u16,
            hwndOwner: ?HWND,
            nControlFlags: SYNCMGR_CONTROL_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableItem: fn(
            self: *const ISyncMgrControl,
            fEnable: BOOL,
            pszHandlerID: ?[*:0]const u16,
            pszItemID: ?[*:0]const u16,
            hwndOwner: ?HWND,
            nControlFlags: SYNCMGR_CONTROL_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_StartHandlerSync(self: *const T, pszHandlerID: ?[*:0]const u16, hwndOwner: ?HWND, punk: ?*IUnknown, nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS, pResult: ?*ISyncMgrSyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).StartHandlerSync(@ptrCast(*const ISyncMgrControl, self), pszHandlerID, hwndOwner, punk, nSyncControlFlags, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_StartItemSync(self: *const T, pszHandlerID: ?[*:0]const u16, ppszItemIDs: [*]?PWSTR, cItems: u32, hwndOwner: ?HWND, punk: ?*IUnknown, nSyncControlFlags: SYNCMGR_SYNC_CONTROL_FLAGS, pResult: ?*ISyncMgrSyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).StartItemSync(@ptrCast(*const ISyncMgrControl, self), pszHandlerID, ppszItemIDs, cItems, hwndOwner, punk, nSyncControlFlags, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_StartSyncAll(self: *const T, hwndOwner: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).StartSyncAll(@ptrCast(*const ISyncMgrControl, self), hwndOwner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_StopHandlerSync(self: *const T, pszHandlerID: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).StopHandlerSync(@ptrCast(*const ISyncMgrControl, self), pszHandlerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_StopItemSync(self: *const T, pszHandlerID: ?[*:0]const u16, ppszItemIDs: [*]?PWSTR, cItems: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).StopItemSync(@ptrCast(*const ISyncMgrControl, self), pszHandlerID, ppszItemIDs, cItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_StopSyncAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).StopSyncAll(@ptrCast(*const ISyncMgrControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_UpdateHandlerCollection(self: *const T, rclsidCollectionID: ?*const Guid, nControlFlags: SYNCMGR_CONTROL_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).UpdateHandlerCollection(@ptrCast(*const ISyncMgrControl, self), rclsidCollectionID, nControlFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_UpdateHandler(self: *const T, pszHandlerID: ?[*:0]const u16, nControlFlags: SYNCMGR_CONTROL_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).UpdateHandler(@ptrCast(*const ISyncMgrControl, self), pszHandlerID, nControlFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_UpdateItem(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, nControlFlags: SYNCMGR_CONTROL_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).UpdateItem(@ptrCast(*const ISyncMgrControl, self), pszHandlerID, pszItemID, nControlFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_UpdateEvents(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, nControlFlags: SYNCMGR_CONTROL_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).UpdateEvents(@ptrCast(*const ISyncMgrControl, self), pszHandlerID, pszItemID, nControlFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_UpdateConflict(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, pConflict: ?*ISyncMgrConflict, nReason: SYNCMGR_UPDATE_REASON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).UpdateConflict(@ptrCast(*const ISyncMgrControl, self), pszHandlerID, pszItemID, pConflict, nReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_UpdateConflicts(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, nControlFlags: SYNCMGR_CONTROL_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).UpdateConflicts(@ptrCast(*const ISyncMgrControl, self), pszHandlerID, pszItemID, nControlFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_ActivateHandler(self: *const T, fActivate: BOOL, pszHandlerID: ?[*:0]const u16, hwndOwner: ?HWND, nControlFlags: SYNCMGR_CONTROL_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).ActivateHandler(@ptrCast(*const ISyncMgrControl, self), fActivate, pszHandlerID, hwndOwner, nControlFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_EnableHandler(self: *const T, fEnable: BOOL, pszHandlerID: ?[*:0]const u16, hwndOwner: ?HWND, nControlFlags: SYNCMGR_CONTROL_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).EnableHandler(@ptrCast(*const ISyncMgrControl, self), fEnable, pszHandlerID, hwndOwner, nControlFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrControl_EnableItem(self: *const T, fEnable: BOOL, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, hwndOwner: ?HWND, nControlFlags: SYNCMGR_CONTROL_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrControl.VTable, self.vtable).EnableItem(@ptrCast(*const ISyncMgrControl, self), fEnable, pszHandlerID, pszItemID, hwndOwner, nControlFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrEventStore_Value = @import("../zig.zig").Guid.initString("37e412f9-016e-44c2-81ff-db3add774266");
pub const IID_ISyncMgrEventStore = &IID_ISyncMgrEventStore_Value;
pub const ISyncMgrEventStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventEnumerator: fn(
            self: *const ISyncMgrEventStore,
            ppenum: ?*?*IEnumSyncMgrEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCount: fn(
            self: *const ISyncMgrEventStore,
            pcEvents: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEvent: fn(
            self: *const ISyncMgrEventStore,
            rguidEventID: ?*const Guid,
            ppEvent: ?*?*ISyncMgrEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEvent: fn(
            self: *const ISyncMgrEventStore,
            pguidEventIDs: [*]Guid,
            cEvents: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEventStore_GetEventEnumerator(self: *const T, ppenum: ?*?*IEnumSyncMgrEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEventStore.VTable, self.vtable).GetEventEnumerator(@ptrCast(*const ISyncMgrEventStore, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEventStore_GetEventCount(self: *const T, pcEvents: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEventStore.VTable, self.vtable).GetEventCount(@ptrCast(*const ISyncMgrEventStore, self), pcEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEventStore_GetEvent(self: *const T, rguidEventID: ?*const Guid, ppEvent: ?*?*ISyncMgrEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEventStore.VTable, self.vtable).GetEvent(@ptrCast(*const ISyncMgrEventStore, self), rguidEventID, ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEventStore_RemoveEvent(self: *const T, pguidEventIDs: [*]Guid, cEvents: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEventStore.VTable, self.vtable).RemoveEvent(@ptrCast(*const ISyncMgrEventStore, self), pguidEventIDs, cEvents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrEvent_Value = @import("../zig.zig").Guid.initString("fee0ef8b-46bd-4db4-b7e6-ff2c687313bc");
pub const IID_ISyncMgrEvent = &IID_ISyncMgrEvent_Value;
pub const ISyncMgrEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventID: fn(
            self: *const ISyncMgrEvent,
            pguidEventID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHandlerID: fn(
            self: *const ISyncMgrEvent,
            ppszHandlerID: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemID: fn(
            self: *const ISyncMgrEvent,
            ppszItemID: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLevel: fn(
            self: *const ISyncMgrEvent,
            pnLevel: ?*SYNCMGR_EVENT_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const ISyncMgrEvent,
            pnFlags: ?*SYNCMGR_EVENT_FLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTime: fn(
            self: *const ISyncMgrEvent,
            pfCreationTime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const ISyncMgrEvent,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const ISyncMgrEvent,
            ppszDescription: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkText: fn(
            self: *const ISyncMgrEvent,
            ppszLinkText: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkReference: fn(
            self: *const ISyncMgrEvent,
            ppszLinkReference: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const ISyncMgrEvent,
            ppszContext: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetEventID(self: *const T, pguidEventID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetEventID(@ptrCast(*const ISyncMgrEvent, self), pguidEventID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetHandlerID(self: *const T, ppszHandlerID: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetHandlerID(@ptrCast(*const ISyncMgrEvent, self), ppszHandlerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetItemID(self: *const T, ppszItemID: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetItemID(@ptrCast(*const ISyncMgrEvent, self), ppszItemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetLevel(self: *const T, pnLevel: ?*SYNCMGR_EVENT_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetLevel(@ptrCast(*const ISyncMgrEvent, self), pnLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetFlags(self: *const T, pnFlags: ?*SYNCMGR_EVENT_FLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetFlags(@ptrCast(*const ISyncMgrEvent, self), pnFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetTime(self: *const T, pfCreationTime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetTime(@ptrCast(*const ISyncMgrEvent, self), pfCreationTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetName(self: *const T, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetName(@ptrCast(*const ISyncMgrEvent, self), ppszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetDescription(self: *const T, ppszDescription: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetDescription(@ptrCast(*const ISyncMgrEvent, self), ppszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetLinkText(self: *const T, ppszLinkText: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetLinkText(@ptrCast(*const ISyncMgrEvent, self), ppszLinkText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetLinkReference(self: *const T, ppszLinkReference: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetLinkReference(@ptrCast(*const ISyncMgrEvent, self), ppszLinkReference);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEvent_GetContext(self: *const T, ppszContext: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEvent.VTable, self.vtable).GetContext(@ptrCast(*const ISyncMgrEvent, self), ppszContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumSyncMgrEvents_Value = @import("../zig.zig").Guid.initString("c81a1d4e-8cf7-4683-80e0-bcae88d677b6");
pub const IID_IEnumSyncMgrEvents = &IID_IEnumSyncMgrEvents_Value;
pub const IEnumSyncMgrEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSyncMgrEvents,
            celt: u32,
            rgelt: [*]?*ISyncMgrEvent,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSyncMgrEvents,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSyncMgrEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSyncMgrEvents,
            ppenum: ?*?*IEnumSyncMgrEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrEvents_Next(self: *const T, celt: u32, rgelt: [*]?*ISyncMgrEvent, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrEvents.VTable, self.vtable).Next(@ptrCast(*const IEnumSyncMgrEvents, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrEvents_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrEvents.VTable, self.vtable).Skip(@ptrCast(*const IEnumSyncMgrEvents, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrEvents_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrEvents.VTable, self.vtable).Reset(@ptrCast(*const IEnumSyncMgrEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrEvents_Clone(self: *const T, ppenum: ?*?*IEnumSyncMgrEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrEvents.VTable, self.vtable).Clone(@ptrCast(*const IEnumSyncMgrEvents, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_CONFLICT_ID_INFO = extern struct {
    pblobID: ?*BYTE_BLOB,
    pblobExtra: ?*BYTE_BLOB,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictStore_Value = @import("../zig.zig").Guid.initString("cf8fc579-c396-4774-85f1-d908a831156e");
pub const IID_ISyncMgrConflictStore = &IID_ISyncMgrConflictStore_Value;
pub const ISyncMgrConflictStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumConflicts: fn(
            self: *const ISyncMgrConflictStore,
            pszHandlerID: ?[*:0]const u16,
            pszItemID: ?[*:0]const u16,
            ppEnum: ?*?*IEnumSyncMgrConflict,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToConflict: fn(
            self: *const ISyncMgrConflictStore,
            pConflictIdInfo: ?*const SYNCMGR_CONFLICT_ID_INFO,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveConflicts: fn(
            self: *const ISyncMgrConflictStore,
            rgConflictIdInfo: [*]const SYNCMGR_CONFLICT_ID_INFO,
            cConflicts: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ISyncMgrConflictStore,
            pszHandlerID: ?[*:0]const u16,
            pszItemID: ?[*:0]const u16,
            pnConflicts: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictStore_EnumConflicts(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, ppEnum: ?*?*IEnumSyncMgrConflict) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictStore.VTable, self.vtable).EnumConflicts(@ptrCast(*const ISyncMgrConflictStore, self), pszHandlerID, pszItemID, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictStore_BindToConflict(self: *const T, pConflictIdInfo: ?*const SYNCMGR_CONFLICT_ID_INFO, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictStore.VTable, self.vtable).BindToConflict(@ptrCast(*const ISyncMgrConflictStore, self), pConflictIdInfo, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictStore_RemoveConflicts(self: *const T, rgConflictIdInfo: [*]const SYNCMGR_CONFLICT_ID_INFO, cConflicts: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictStore.VTable, self.vtable).RemoveConflicts(@ptrCast(*const ISyncMgrConflictStore, self), rgConflictIdInfo, cConflicts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictStore_GetCount(self: *const T, pszHandlerID: ?[*:0]const u16, pszItemID: ?[*:0]const u16, pnConflicts: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictStore.VTable, self.vtable).GetCount(@ptrCast(*const ISyncMgrConflictStore, self), pszHandlerID, pszItemID, pnConflicts);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumSyncMgrConflict_Value = @import("../zig.zig").Guid.initString("82705914-dda3-4893-ba99-49de6c8c8036");
pub const IID_IEnumSyncMgrConflict = &IID_IEnumSyncMgrConflict_Value;
pub const IEnumSyncMgrConflict = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSyncMgrConflict,
            celt: u32,
            rgelt: [*]?*ISyncMgrConflict,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSyncMgrConflict,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSyncMgrConflict,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSyncMgrConflict,
            ppenum: ?*?*IEnumSyncMgrConflict,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrConflict_Next(self: *const T, celt: u32, rgelt: [*]?*ISyncMgrConflict, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrConflict.VTable, self.vtable).Next(@ptrCast(*const IEnumSyncMgrConflict, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrConflict_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrConflict.VTable, self.vtable).Skip(@ptrCast(*const IEnumSyncMgrConflict, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrConflict_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrConflict.VTable, self.vtable).Reset(@ptrCast(*const IEnumSyncMgrConflict, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSyncMgrConflict_Clone(self: *const T, ppenum: ?*?*IEnumSyncMgrConflict) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSyncMgrConflict.VTable, self.vtable).Clone(@ptrCast(*const IEnumSyncMgrConflict, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_CONFLICT_ITEM_TYPE = enum(i32) {
    UPDATED = 1,
    DELETED = 2,
};
pub const SYNCMGR_CIT_UPDATED = SYNCMGR_CONFLICT_ITEM_TYPE.UPDATED;
pub const SYNCMGR_CIT_DELETED = SYNCMGR_CONFLICT_ITEM_TYPE.DELETED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflict_Value = @import("../zig.zig").Guid.initString("9c204249-c443-4ba4-85ed-c972681db137");
pub const IID_ISyncMgrConflict = &IID_ISyncMgrConflict_Value;
pub const ISyncMgrConflict = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: fn(
            self: *const ISyncMgrConflict,
            propkey: ?*const PROPERTYKEY,
            ppropvar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConflictIdInfo: fn(
            self: *const ISyncMgrConflict,
            pConflictIdInfo: ?*SYNCMGR_CONFLICT_ID_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemsArray: fn(
            self: *const ISyncMgrConflict,
            ppArray: ?*?*ISyncMgrConflictItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resolve: fn(
            self: *const ISyncMgrConflict,
            pResolveInfo: ?*ISyncMgrConflictResolveInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResolutionHandler: fn(
            self: *const ISyncMgrConflict,
            riid: ?*const Guid,
            ppvResolutionHandler: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflict_GetProperty(self: *const T, propkey: ?*const PROPERTYKEY, ppropvar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflict.VTable, self.vtable).GetProperty(@ptrCast(*const ISyncMgrConflict, self), propkey, ppropvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflict_GetConflictIdInfo(self: *const T, pConflictIdInfo: ?*SYNCMGR_CONFLICT_ID_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflict.VTable, self.vtable).GetConflictIdInfo(@ptrCast(*const ISyncMgrConflict, self), pConflictIdInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflict_GetItemsArray(self: *const T, ppArray: ?*?*ISyncMgrConflictItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflict.VTable, self.vtable).GetItemsArray(@ptrCast(*const ISyncMgrConflict, self), ppArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflict_Resolve(self: *const T, pResolveInfo: ?*ISyncMgrConflictResolveInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflict.VTable, self.vtable).Resolve(@ptrCast(*const ISyncMgrConflict, self), pResolveInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflict_GetResolutionHandler(self: *const T, riid: ?*const Guid, ppvResolutionHandler: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflict.VTable, self.vtable).GetResolutionHandler(@ptrCast(*const ISyncMgrConflict, self), riid, ppvResolutionHandler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_RESOLUTION_ABILITIES = enum(i32) {
    KEEPOTHER = 1,
    KEEPRECENT = 2,
    REMOVEFROMSYNCSET = 4,
    KEEP_SINGLE = 8,
    KEEP_MULTIPLE = 16,
    VALID = 31,
};
pub const SYNCMGR_RA_KEEPOTHER = SYNCMGR_RESOLUTION_ABILITIES.KEEPOTHER;
pub const SYNCMGR_RA_KEEPRECENT = SYNCMGR_RESOLUTION_ABILITIES.KEEPRECENT;
pub const SYNCMGR_RA_REMOVEFROMSYNCSET = SYNCMGR_RESOLUTION_ABILITIES.REMOVEFROMSYNCSET;
pub const SYNCMGR_RA_KEEP_SINGLE = SYNCMGR_RESOLUTION_ABILITIES.KEEP_SINGLE;
pub const SYNCMGR_RA_KEEP_MULTIPLE = SYNCMGR_RESOLUTION_ABILITIES.KEEP_MULTIPLE;
pub const SYNCMGR_RA_VALID = SYNCMGR_RESOLUTION_ABILITIES.VALID;

pub const SYNCMGR_RESOLUTION_FEEDBACK = enum(i32) {
    CONTINUE = 0,
    REFRESH = 1,
    CANCEL = 2,
};
pub const SYNCMGR_RF_CONTINUE = SYNCMGR_RESOLUTION_FEEDBACK.CONTINUE;
pub const SYNCMGR_RF_REFRESH = SYNCMGR_RESOLUTION_FEEDBACK.REFRESH;
pub const SYNCMGR_RF_CANCEL = SYNCMGR_RESOLUTION_FEEDBACK.CANCEL;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrResolutionHandler_Value = @import("../zig.zig").Guid.initString("40a3d052-8bff-4c4b-a338-d4a395700de9");
pub const IID_ISyncMgrResolutionHandler = &IID_ISyncMgrResolutionHandler_Value;
pub const ISyncMgrResolutionHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryAbilities: fn(
            self: *const ISyncMgrResolutionHandler,
            pdwAbilities: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeepOther: fn(
            self: *const ISyncMgrResolutionHandler,
            psiOther: ?*IShellItem,
            pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeepRecent: fn(
            self: *const ISyncMgrResolutionHandler,
            pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFromSyncSet: fn(
            self: *const ISyncMgrResolutionHandler,
            pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeepItems: fn(
            self: *const ISyncMgrResolutionHandler,
            pArray: ?*ISyncMgrConflictResolutionItems,
            pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrResolutionHandler_QueryAbilities(self: *const T, pdwAbilities: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrResolutionHandler.VTable, self.vtable).QueryAbilities(@ptrCast(*const ISyncMgrResolutionHandler, self), pdwAbilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrResolutionHandler_KeepOther(self: *const T, psiOther: ?*IShellItem, pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrResolutionHandler.VTable, self.vtable).KeepOther(@ptrCast(*const ISyncMgrResolutionHandler, self), psiOther, pFeedback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrResolutionHandler_KeepRecent(self: *const T, pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrResolutionHandler.VTable, self.vtable).KeepRecent(@ptrCast(*const ISyncMgrResolutionHandler, self), pFeedback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrResolutionHandler_RemoveFromSyncSet(self: *const T, pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrResolutionHandler.VTable, self.vtable).RemoveFromSyncSet(@ptrCast(*const ISyncMgrResolutionHandler, self), pFeedback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrResolutionHandler_KeepItems(self: *const T, pArray: ?*ISyncMgrConflictResolutionItems, pFeedback: ?*SYNCMGR_RESOLUTION_FEEDBACK) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrResolutionHandler.VTable, self.vtable).KeepItems(@ptrCast(*const ISyncMgrResolutionHandler, self), pArray, pFeedback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictPresenter_Value = @import("../zig.zig").Guid.initString("0b4f5353-fd2b-42cd-8763-4779f2d508a3");
pub const IID_ISyncMgrConflictPresenter = &IID_ISyncMgrConflictPresenter_Value;
pub const ISyncMgrConflictPresenter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PresentConflict: fn(
            self: *const ISyncMgrConflictPresenter,
            pConflict: ?*ISyncMgrConflict,
            pResolveInfo: ?*ISyncMgrConflictResolveInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictPresenter_PresentConflict(self: *const T, pConflict: ?*ISyncMgrConflict, pResolveInfo: ?*ISyncMgrConflictResolveInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictPresenter.VTable, self.vtable).PresentConflict(@ptrCast(*const ISyncMgrConflictPresenter, self), pConflict, pResolveInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGR_PRESENTER_NEXT_STEP = enum(i32) {
    CONTINUE = 0,
    DEFAULT = 1,
    CANCEL = 2,
};
pub const SYNCMGR_PNS_CONTINUE = SYNCMGR_PRESENTER_NEXT_STEP.CONTINUE;
pub const SYNCMGR_PNS_DEFAULT = SYNCMGR_PRESENTER_NEXT_STEP.DEFAULT;
pub const SYNCMGR_PNS_CANCEL = SYNCMGR_PRESENTER_NEXT_STEP.CANCEL;

pub const SYNCMGR_PRESENTER_CHOICE = enum(i32) {
    NO_CHOICE = 0,
    KEEP_ONE = 1,
    KEEP_MULTIPLE = 2,
    KEEP_RECENT = 3,
    REMOVE_FROM_SYNC_SET = 4,
    SKIP = 5,
};
pub const SYNCMGR_PC_NO_CHOICE = SYNCMGR_PRESENTER_CHOICE.NO_CHOICE;
pub const SYNCMGR_PC_KEEP_ONE = SYNCMGR_PRESENTER_CHOICE.KEEP_ONE;
pub const SYNCMGR_PC_KEEP_MULTIPLE = SYNCMGR_PRESENTER_CHOICE.KEEP_MULTIPLE;
pub const SYNCMGR_PC_KEEP_RECENT = SYNCMGR_PRESENTER_CHOICE.KEEP_RECENT;
pub const SYNCMGR_PC_REMOVE_FROM_SYNC_SET = SYNCMGR_PRESENTER_CHOICE.REMOVE_FROM_SYNC_SET;
pub const SYNCMGR_PC_SKIP = SYNCMGR_PRESENTER_CHOICE.SKIP;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictResolveInfo_Value = @import("../zig.zig").Guid.initString("c405a219-25a2-442e-8743-b845a2cee93f");
pub const IID_ISyncMgrConflictResolveInfo = &IID_ISyncMgrConflictResolveInfo_Value;
pub const ISyncMgrConflictResolveInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIterationInfo: fn(
            self: *const ISyncMgrConflictResolveInfo,
            pnCurrentConflict: ?*u32,
            pcConflicts: ?*u32,
            pcRemainingForApplyToAll: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPresenterNextStep: fn(
            self: *const ISyncMgrConflictResolveInfo,
            pnPresenterNextStep: ?*SYNCMGR_PRESENTER_NEXT_STEP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPresenterChoice: fn(
            self: *const ISyncMgrConflictResolveInfo,
            pnPresenterChoice: ?*SYNCMGR_PRESENTER_CHOICE,
            pfApplyToAll: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemChoiceCount: fn(
            self: *const ISyncMgrConflictResolveInfo,
            pcChoices: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemChoice: fn(
            self: *const ISyncMgrConflictResolveInfo,
            iChoice: u32,
            piChoiceIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPresenterNextStep: fn(
            self: *const ISyncMgrConflictResolveInfo,
            nPresenterNextStep: SYNCMGR_PRESENTER_NEXT_STEP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPresenterChoice: fn(
            self: *const ISyncMgrConflictResolveInfo,
            nPresenterChoice: SYNCMGR_PRESENTER_CHOICE,
            fApplyToAll: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItemChoices: fn(
            self: *const ISyncMgrConflictResolveInfo,
            prgiConflictItemIndexes: ?*u32,
            cChoices: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolveInfo_GetIterationInfo(self: *const T, pnCurrentConflict: ?*u32, pcConflicts: ?*u32, pcRemainingForApplyToAll: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolveInfo.VTable, self.vtable).GetIterationInfo(@ptrCast(*const ISyncMgrConflictResolveInfo, self), pnCurrentConflict, pcConflicts, pcRemainingForApplyToAll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolveInfo_GetPresenterNextStep(self: *const T, pnPresenterNextStep: ?*SYNCMGR_PRESENTER_NEXT_STEP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolveInfo.VTable, self.vtable).GetPresenterNextStep(@ptrCast(*const ISyncMgrConflictResolveInfo, self), pnPresenterNextStep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolveInfo_GetPresenterChoice(self: *const T, pnPresenterChoice: ?*SYNCMGR_PRESENTER_CHOICE, pfApplyToAll: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolveInfo.VTable, self.vtable).GetPresenterChoice(@ptrCast(*const ISyncMgrConflictResolveInfo, self), pnPresenterChoice, pfApplyToAll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolveInfo_GetItemChoiceCount(self: *const T, pcChoices: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolveInfo.VTable, self.vtable).GetItemChoiceCount(@ptrCast(*const ISyncMgrConflictResolveInfo, self), pcChoices);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolveInfo_GetItemChoice(self: *const T, iChoice: u32, piChoiceIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolveInfo.VTable, self.vtable).GetItemChoice(@ptrCast(*const ISyncMgrConflictResolveInfo, self), iChoice, piChoiceIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolveInfo_SetPresenterNextStep(self: *const T, nPresenterNextStep: SYNCMGR_PRESENTER_NEXT_STEP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolveInfo.VTable, self.vtable).SetPresenterNextStep(@ptrCast(*const ISyncMgrConflictResolveInfo, self), nPresenterNextStep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolveInfo_SetPresenterChoice(self: *const T, nPresenterChoice: SYNCMGR_PRESENTER_CHOICE, fApplyToAll: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolveInfo.VTable, self.vtable).SetPresenterChoice(@ptrCast(*const ISyncMgrConflictResolveInfo, self), nPresenterChoice, fApplyToAll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolveInfo_SetItemChoices(self: *const T, prgiConflictItemIndexes: ?*u32, cChoices: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolveInfo.VTable, self.vtable).SetItemChoices(@ptrCast(*const ISyncMgrConflictResolveInfo, self), prgiConflictItemIndexes, cChoices);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictFolder_Value = @import("../zig.zig").Guid.initString("59287f5e-bc81-4fca-a7f1-e5a8ecdb1d69");
pub const IID_ISyncMgrConflictFolder = &IID_ISyncMgrConflictFolder_Value;
pub const ISyncMgrConflictFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConflictIDList: fn(
            self: *const ISyncMgrConflictFolder,
            pConflict: ?*ISyncMgrConflict,
            ppidlConflict: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictFolder_GetConflictIDList(self: *const T, pConflict: ?*ISyncMgrConflict, ppidlConflict: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictFolder.VTable, self.vtable).GetConflictIDList(@ptrCast(*const ISyncMgrConflictFolder, self), pConflict, ppidlConflict);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CONFIRM_CONFLICT_ITEM = extern struct {
    pShellItem: ?*IShellItem2,
    pszOriginalName: ?PWSTR,
    pszAlternateName: ?PWSTR,
    pszLocationShort: ?PWSTR,
    pszLocationFull: ?PWSTR,
    nType: SYNCMGR_CONFLICT_ITEM_TYPE,
};

pub const CONFIRM_CONFLICT_RESULT_INFO = extern struct {
    pszNewName: ?PWSTR,
    iItemIndex: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictItems_Value = @import("../zig.zig").Guid.initString("9c7ead52-8023-4936-a4db-d2a9a99e436a");
pub const IID_ISyncMgrConflictItems = &IID_ISyncMgrConflictItems_Value;
pub const ISyncMgrConflictItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const ISyncMgrConflictItems,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const ISyncMgrConflictItems,
            iIndex: u32,
            pItemInfo: ?*CONFIRM_CONFLICT_ITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictItems_GetCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictItems.VTable, self.vtable).GetCount(@ptrCast(*const ISyncMgrConflictItems, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictItems_GetItem(self: *const T, iIndex: u32, pItemInfo: ?*CONFIRM_CONFLICT_ITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictItems.VTable, self.vtable).GetItem(@ptrCast(*const ISyncMgrConflictItems, self), iIndex, pItemInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISyncMgrConflictResolutionItems_Value = @import("../zig.zig").Guid.initString("458725b9-129d-4135-a998-9ceafec27007");
pub const IID_ISyncMgrConflictResolutionItems = &IID_ISyncMgrConflictResolutionItems_Value;
pub const ISyncMgrConflictResolutionItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const ISyncMgrConflictResolutionItems,
            pCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const ISyncMgrConflictResolutionItems,
            iIndex: u32,
            pItemInfo: ?*CONFIRM_CONFLICT_RESULT_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolutionItems_GetCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolutionItems.VTable, self.vtable).GetCount(@ptrCast(*const ISyncMgrConflictResolutionItems, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrConflictResolutionItems_GetItem(self: *const T, iIndex: u32, pItemInfo: ?*CONFIRM_CONFLICT_RESULT_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrConflictResolutionItems.VTable, self.vtable).GetItem(@ptrCast(*const ISyncMgrConflictResolutionItems, self), iIndex, pItemInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_InputPanelConfiguration_Value = @import("../zig.zig").Guid.initString("2853add3-f096-4c63-a78f-7fa3ea837fb7");
pub const CLSID_InputPanelConfiguration = &CLSID_InputPanelConfiguration_Value;

// TODO: this type is limited to platform 'windows8.0'
const IID_IInputPanelConfiguration_Value = @import("../zig.zig").Guid.initString("41c81592-514c-48bd-a22e-e6af638521a6");
pub const IID_IInputPanelConfiguration = &IID_IInputPanelConfiguration_Value;
pub const IInputPanelConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableFocusTracking: fn(
            self: *const IInputPanelConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputPanelConfiguration_EnableFocusTracking(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputPanelConfiguration.VTable, self.vtable).EnableFocusTracking(@ptrCast(*const IInputPanelConfiguration, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IInputPanelInvocationConfiguration_Value = @import("../zig.zig").Guid.initString("a213f136-3b45-4362-a332-efb6547cd432");
pub const IID_IInputPanelInvocationConfiguration = &IID_IInputPanelInvocationConfiguration_Value;
pub const IInputPanelInvocationConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequireTouchInEditControl: fn(
            self: *const IInputPanelInvocationConfiguration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputPanelInvocationConfiguration_RequireTouchInEditControl(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputPanelInvocationConfiguration.VTable, self.vtable).RequireTouchInEditControl(@ptrCast(*const IInputPanelInvocationConfiguration, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_LocalThumbnailCache_Value = @import("../zig.zig").Guid.initString("50ef4544-ac9f-4a8e-b21b-8a26180db13f");
pub const CLSID_LocalThumbnailCache = &CLSID_LocalThumbnailCache_Value;

const CLSID_SharedBitmap_Value = @import("../zig.zig").Guid.initString("4db26476-6787-4046-b836-e8412a9e8a27");
pub const CLSID_SharedBitmap = &CLSID_SharedBitmap_Value;

pub const WTS_FLAGS = enum(i32) {
    NONE = 0,
    // EXTRACT = 0, this enum value conflicts with NONE
    INCACHEONLY = 1,
    FASTEXTRACT = 2,
    FORCEEXTRACTION = 4,
    SLOWRECLAIM = 8,
    EXTRACTDONOTCACHE = 32,
    SCALETOREQUESTEDSIZE = 64,
    SKIPFASTEXTRACT = 128,
    EXTRACTINPROC = 256,
    CROPTOSQUARE = 512,
    INSTANCESURROGATE = 1024,
    REQUIRESURROGATE = 2048,
    APPSTYLE = 8192,
    WIDETHUMBNAILS = 16384,
    IDEALCACHESIZEONLY = 32768,
    SCALEUP = 65536,
};
pub const WTS_NONE = WTS_FLAGS.NONE;
pub const WTS_EXTRACT = WTS_FLAGS.NONE;
pub const WTS_INCACHEONLY = WTS_FLAGS.INCACHEONLY;
pub const WTS_FASTEXTRACT = WTS_FLAGS.FASTEXTRACT;
pub const WTS_FORCEEXTRACTION = WTS_FLAGS.FORCEEXTRACTION;
pub const WTS_SLOWRECLAIM = WTS_FLAGS.SLOWRECLAIM;
pub const WTS_EXTRACTDONOTCACHE = WTS_FLAGS.EXTRACTDONOTCACHE;
pub const WTS_SCALETOREQUESTEDSIZE = WTS_FLAGS.SCALETOREQUESTEDSIZE;
pub const WTS_SKIPFASTEXTRACT = WTS_FLAGS.SKIPFASTEXTRACT;
pub const WTS_EXTRACTINPROC = WTS_FLAGS.EXTRACTINPROC;
pub const WTS_CROPTOSQUARE = WTS_FLAGS.CROPTOSQUARE;
pub const WTS_INSTANCESURROGATE = WTS_FLAGS.INSTANCESURROGATE;
pub const WTS_REQUIRESURROGATE = WTS_FLAGS.REQUIRESURROGATE;
pub const WTS_APPSTYLE = WTS_FLAGS.APPSTYLE;
pub const WTS_WIDETHUMBNAILS = WTS_FLAGS.WIDETHUMBNAILS;
pub const WTS_IDEALCACHESIZEONLY = WTS_FLAGS.IDEALCACHESIZEONLY;
pub const WTS_SCALEUP = WTS_FLAGS.SCALEUP;

pub const WTS_CACHEFLAGS = enum(i32) {
    DEFAULT = 0,
    LOWQUALITY = 1,
    CACHED = 2,
};
pub const WTS_DEFAULT = WTS_CACHEFLAGS.DEFAULT;
pub const WTS_LOWQUALITY = WTS_CACHEFLAGS.LOWQUALITY;
pub const WTS_CACHED = WTS_CACHEFLAGS.CACHED;

pub const WTS_CONTEXTFLAGS = enum(i32) {
    DEFAULT = 0,
    APPSTYLE = 1,
    SQUARE = 2,
    WIDE = 4,
    FAST = 8,
};
pub const WTSCF_DEFAULT = WTS_CONTEXTFLAGS.DEFAULT;
pub const WTSCF_APPSTYLE = WTS_CONTEXTFLAGS.APPSTYLE;
pub const WTSCF_SQUARE = WTS_CONTEXTFLAGS.SQUARE;
pub const WTSCF_WIDE = WTS_CONTEXTFLAGS.WIDE;
pub const WTSCF_FAST = WTS_CONTEXTFLAGS.FAST;

pub const WTS_ALPHATYPE = enum(i32) {
    UNKNOWN = 0,
    RGB = 1,
    ARGB = 2,
};
pub const WTSAT_UNKNOWN = WTS_ALPHATYPE.UNKNOWN;
pub const WTSAT_RGB = WTS_ALPHATYPE.RGB;
pub const WTSAT_ARGB = WTS_ALPHATYPE.ARGB;

pub const WTS_THUMBNAILID = extern struct {
    rgbKey: [16]u8,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISharedBitmap_Value = @import("../zig.zig").Guid.initString("091162a4-bc96-411f-aae8-c5122cd03363");
pub const IID_ISharedBitmap = &IID_ISharedBitmap_Value;
pub const ISharedBitmap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSharedBitmap: fn(
            self: *const ISharedBitmap,
            phbm: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const ISharedBitmap,
            pSize: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormat: fn(
            self: *const ISharedBitmap,
            pat: ?*WTS_ALPHATYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeBitmap: fn(
            self: *const ISharedBitmap,
            hbm: ?HBITMAP,
            wtsAT: WTS_ALPHATYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const ISharedBitmap,
            phbm: ?*?HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharedBitmap_GetSharedBitmap(self: *const T, phbm: ?*?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharedBitmap.VTable, self.vtable).GetSharedBitmap(@ptrCast(*const ISharedBitmap, self), phbm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharedBitmap_GetSize(self: *const T, pSize: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharedBitmap.VTable, self.vtable).GetSize(@ptrCast(*const ISharedBitmap, self), pSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharedBitmap_GetFormat(self: *const T, pat: ?*WTS_ALPHATYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharedBitmap.VTable, self.vtable).GetFormat(@ptrCast(*const ISharedBitmap, self), pat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharedBitmap_InitializeBitmap(self: *const T, hbm: ?HBITMAP, wtsAT: WTS_ALPHATYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharedBitmap.VTable, self.vtable).InitializeBitmap(@ptrCast(*const ISharedBitmap, self), hbm, wtsAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISharedBitmap_Detach(self: *const T, phbm: ?*?HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISharedBitmap.VTable, self.vtable).Detach(@ptrCast(*const ISharedBitmap, self), phbm);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IThumbnailCache_Value = @import("../zig.zig").Guid.initString("f676c15d-596a-4ce2-8234-33996f445db1");
pub const IID_IThumbnailCache = &IID_IThumbnailCache_Value;
pub const IThumbnailCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThumbnail: fn(
            self: *const IThumbnailCache,
            pShellItem: ?*IShellItem,
            cxyRequestedThumbSize: u32,
            flags: WTS_FLAGS,
            ppvThumb: ?*?*ISharedBitmap,
            pOutFlags: ?*WTS_CACHEFLAGS,
            pThumbnailID: ?*WTS_THUMBNAILID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThumbnailByID: fn(
            self: *const IThumbnailCache,
            thumbnailID: WTS_THUMBNAILID,
            cxyRequestedThumbSize: u32,
            ppvThumb: ?*?*ISharedBitmap,
            pOutFlags: ?*WTS_CACHEFLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailCache_GetThumbnail(self: *const T, pShellItem: ?*IShellItem, cxyRequestedThumbSize: u32, flags: WTS_FLAGS, ppvThumb: ?*?*ISharedBitmap, pOutFlags: ?*WTS_CACHEFLAGS, pThumbnailID: ?*WTS_THUMBNAILID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailCache.VTable, self.vtable).GetThumbnail(@ptrCast(*const IThumbnailCache, self), pShellItem, cxyRequestedThumbSize, flags, ppvThumb, pOutFlags, pThumbnailID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailCache_GetThumbnailByID(self: *const T, thumbnailID: WTS_THUMBNAILID, cxyRequestedThumbSize: u32, ppvThumb: ?*?*ISharedBitmap, pOutFlags: ?*WTS_CACHEFLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailCache.VTable, self.vtable).GetThumbnailByID(@ptrCast(*const IThumbnailCache, self), thumbnailID, cxyRequestedThumbSize, ppvThumb, pOutFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IThumbnailProvider_Value = @import("../zig.zig").Guid.initString("e357fccd-a995-4576-b01f-234630154e96");
pub const IID_IThumbnailProvider = &IID_IThumbnailProvider_Value;
pub const IThumbnailProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThumbnail: fn(
            self: *const IThumbnailProvider,
            cx: u32,
            phbmp: ?*?HBITMAP,
            pdwAlpha: ?*WTS_ALPHATYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailProvider_GetThumbnail(self: *const T, cx: u32, phbmp: ?*?HBITMAP, pdwAlpha: ?*WTS_ALPHATYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailProvider.VTable, self.vtable).GetThumbnail(@ptrCast(*const IThumbnailProvider, self), cx, phbmp, pdwAlpha);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IThumbnailSettings_Value = @import("../zig.zig").Guid.initString("f4376f00-bef5-4d45-80f3-1e023bbf1209");
pub const IID_IThumbnailSettings = &IID_IThumbnailSettings_Value;
pub const IThumbnailSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetContext: fn(
            self: *const IThumbnailSettings,
            dwContext: WTS_CONTEXTFLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailSettings_SetContext(self: *const T, dwContext: WTS_CONTEXTFLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailSettings.VTable, self.vtable).SetContext(@ptrCast(*const IThumbnailSettings, self), dwContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IThumbnailCachePrimer_Value = @import("../zig.zig").Guid.initString("0f03f8fe-2b26-46f0-965a-212aa8d66b76");
pub const IID_IThumbnailCachePrimer = &IID_IThumbnailCachePrimer_Value;
pub const IThumbnailCachePrimer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PageInThumbnail: fn(
            self: *const IThumbnailCachePrimer,
            psi: ?*IShellItem,
            wtsFlags: WTS_FLAGS,
            cxyRequestedThumbSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailCachePrimer_PageInThumbnail(self: *const T, psi: ?*IShellItem, wtsFlags: WTS_FLAGS, cxyRequestedThumbSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailCachePrimer.VTable, self.vtable).PageInThumbnail(@ptrCast(*const IThumbnailCachePrimer, self), psi, wtsFlags, cxyRequestedThumbSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ShellImageDataFactory_Value = @import("../zig.zig").Guid.initString("66e4e4fb-f385-4dd0-8d74-a2efd1bc6178");
pub const CLSID_ShellImageDataFactory = &CLSID_ShellImageDataFactory_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellImageDataFactory_Value = @import("../zig.zig").Guid.initString("9be8ed5c-edab-4d75-90f3-bd5bdbb21c82");
pub const IID_IShellImageDataFactory = &IID_IShellImageDataFactory_Value;
pub const IShellImageDataFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIShellImageData: fn(
            self: *const IShellImageDataFactory,
            ppshimg: ?*?*IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateImageFromFile: fn(
            self: *const IShellImageDataFactory,
            pszPath: ?[*:0]const u16,
            ppshimg: ?*?*IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateImageFromStream: fn(
            self: *const IShellImageDataFactory,
            pStream: ?*IStream,
            ppshimg: ?*?*IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataFormatFromPath: fn(
            self: *const IShellImageDataFactory,
            pszPath: ?[*:0]const u16,
            pDataFormat: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageDataFactory_CreateIShellImageData(self: *const T, ppshimg: ?*?*IShellImageData) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageDataFactory.VTable, self.vtable).CreateIShellImageData(@ptrCast(*const IShellImageDataFactory, self), ppshimg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageDataFactory_CreateImageFromFile(self: *const T, pszPath: ?[*:0]const u16, ppshimg: ?*?*IShellImageData) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageDataFactory.VTable, self.vtable).CreateImageFromFile(@ptrCast(*const IShellImageDataFactory, self), pszPath, ppshimg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageDataFactory_CreateImageFromStream(self: *const T, pStream: ?*IStream, ppshimg: ?*?*IShellImageData) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageDataFactory.VTable, self.vtable).CreateImageFromStream(@ptrCast(*const IShellImageDataFactory, self), pStream, ppshimg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageDataFactory_GetDataFormatFromPath(self: *const T, pszPath: ?[*:0]const u16, pDataFormat: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageDataFactory.VTable, self.vtable).GetDataFormatFromPath(@ptrCast(*const IShellImageDataFactory, self), pszPath, pDataFormat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellImageData_Value = @import("../zig.zig").Guid.initString("bfdeec12-8040-4403-a5ea-9e07dafcf530");
pub const IID_IShellImageData = &IID_IShellImageData_Value;
pub const IShellImageData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Decode: fn(
            self: *const IShellImageData,
            dwFlags: u32,
            cxDesired: u32,
            cyDesired: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Draw: fn(
            self: *const IShellImageData,
            hdc: ?HDC,
            prcDest: ?*RECT,
            prcSrc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextFrame: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NextPage: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrevPage: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsTransparent: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAnimated: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVector: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMultipage: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEditable: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPrintable: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDecoded: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPage: fn(
            self: *const IShellImageData,
            pnPage: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageCount: fn(
            self: *const IShellImageData,
            pcPages: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectPage: fn(
            self: *const IShellImageData,
            iPage: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IShellImageData,
            pSize: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawDataFormat: fn(
            self: *const IShellImageData,
            pDataFormat: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPixelFormat: fn(
            self: *const IShellImageData,
            pFormat: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDelay: fn(
            self: *const IShellImageData,
            pdwDelay: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const IShellImageData,
            dwMode: u32,
            ppPropSet: ?*?*IPropertySetStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Rotate: fn(
            self: *const IShellImageData,
            dwAngle: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Scale: fn(
            self: *const IShellImageData,
            cx: u32,
            cy: u32,
            hints: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiscardEdit: fn(
            self: *const IShellImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEncoderParams: fn(
            self: *const IShellImageData,
            pbagEnc: ?*IPropertyBag,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayName: fn(
            self: *const IShellImageData,
            wszName: ?PWSTR,
            cch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResolution: fn(
            self: *const IShellImageData,
            puResolutionX: ?*u32,
            puResolutionY: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEncoderParams: fn(
            self: *const IShellImageData,
            pguidFmt: ?*Guid,
            ppEncParams: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterAbort: fn(
            self: *const IShellImageData,
            pAbort: ?*IShellImageDataAbort,
            ppAbortPrev: ?*?*IShellImageDataAbort,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloneFrame: fn(
            self: *const IShellImageData,
            ppImg: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceFrame: fn(
            self: *const IShellImageData,
            pImg: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_Decode(self: *const T, dwFlags: u32, cxDesired: u32, cyDesired: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).Decode(@ptrCast(*const IShellImageData, self), dwFlags, cxDesired, cyDesired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_Draw(self: *const T, hdc: ?HDC, prcDest: ?*RECT, prcSrc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).Draw(@ptrCast(*const IShellImageData, self), hdc, prcDest, prcSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_NextFrame(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).NextFrame(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_NextPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).NextPage(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_PrevPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).PrevPage(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_IsTransparent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).IsTransparent(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_IsAnimated(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).IsAnimated(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_IsVector(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).IsVector(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_IsMultipage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).IsMultipage(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_IsEditable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).IsEditable(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_IsPrintable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).IsPrintable(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_IsDecoded(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).IsDecoded(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_GetCurrentPage(self: *const T, pnPage: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).GetCurrentPage(@ptrCast(*const IShellImageData, self), pnPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_GetPageCount(self: *const T, pcPages: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).GetPageCount(@ptrCast(*const IShellImageData, self), pcPages);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_SelectPage(self: *const T, iPage: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).SelectPage(@ptrCast(*const IShellImageData, self), iPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_GetSize(self: *const T, pSize: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).GetSize(@ptrCast(*const IShellImageData, self), pSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_GetRawDataFormat(self: *const T, pDataFormat: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).GetRawDataFormat(@ptrCast(*const IShellImageData, self), pDataFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_GetPixelFormat(self: *const T, pFormat: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).GetPixelFormat(@ptrCast(*const IShellImageData, self), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_GetDelay(self: *const T, pdwDelay: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).GetDelay(@ptrCast(*const IShellImageData, self), pdwDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_GetProperties(self: *const T, dwMode: u32, ppPropSet: ?*?*IPropertySetStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).GetProperties(@ptrCast(*const IShellImageData, self), dwMode, ppPropSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_Rotate(self: *const T, dwAngle: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).Rotate(@ptrCast(*const IShellImageData, self), dwAngle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_Scale(self: *const T, cx: u32, cy: u32, hints: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).Scale(@ptrCast(*const IShellImageData, self), cx, cy, hints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_DiscardEdit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).DiscardEdit(@ptrCast(*const IShellImageData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_SetEncoderParams(self: *const T, pbagEnc: ?*IPropertyBag) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).SetEncoderParams(@ptrCast(*const IShellImageData, self), pbagEnc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_DisplayName(self: *const T, wszName: ?PWSTR, cch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).DisplayName(@ptrCast(*const IShellImageData, self), wszName, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_GetResolution(self: *const T, puResolutionX: ?*u32, puResolutionY: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).GetResolution(@ptrCast(*const IShellImageData, self), puResolutionX, puResolutionY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_GetEncoderParams(self: *const T, pguidFmt: ?*Guid, ppEncParams: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).GetEncoderParams(@ptrCast(*const IShellImageData, self), pguidFmt, ppEncParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_RegisterAbort(self: *const T, pAbort: ?*IShellImageDataAbort, ppAbortPrev: ?*?*IShellImageDataAbort) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).RegisterAbort(@ptrCast(*const IShellImageData, self), pAbort, ppAbortPrev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_CloneFrame(self: *const T, ppImg: ?*?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).CloneFrame(@ptrCast(*const IShellImageData, self), ppImg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageData_ReplaceFrame(self: *const T, pImg: ?*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageData.VTable, self.vtable).ReplaceFrame(@ptrCast(*const IShellImageData, self), pImg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IShellImageDataAbort_Value = @import("../zig.zig").Guid.initString("53fb8e58-50c0-4003-b4aa-0c8df28e7f3a");
pub const IID_IShellImageDataAbort = &IID_IShellImageDataAbort_Value;
pub const IShellImageDataAbort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryAbort: fn(
            self: *const IShellImageDataAbort,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellImageDataAbort_QueryAbort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellImageDataAbort.VTable, self.vtable).QueryAbort(@ptrCast(*const IShellImageDataAbort, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStorageProviderPropertyHandler_Value = @import("../zig.zig").Guid.initString("301dfbe5-524c-4b0f-8b2d-21c40b3a2988");
pub const IID_IStorageProviderPropertyHandler = &IID_IStorageProviderPropertyHandler_Value;
pub const IStorageProviderPropertyHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RetrieveProperties: fn(
            self: *const IStorageProviderPropertyHandler,
            propertiesToRetrieve: [*]const PROPERTYKEY,
            propertiesToRetrieveCount: u32,
            retrievedProperties: ?*?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveProperties: fn(
            self: *const IStorageProviderPropertyHandler,
            propertiesToSave: ?*IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderPropertyHandler_RetrieveProperties(self: *const T, propertiesToRetrieve: [*]const PROPERTYKEY, propertiesToRetrieveCount: u32, retrievedProperties: ?*?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderPropertyHandler.VTable, self.vtable).RetrieveProperties(@ptrCast(*const IStorageProviderPropertyHandler, self), propertiesToRetrieve, propertiesToRetrieveCount, retrievedProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderPropertyHandler_SaveProperties(self: *const T, propertiesToSave: ?*IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderPropertyHandler.VTable, self.vtable).SaveProperties(@ptrCast(*const IStorageProviderPropertyHandler, self), propertiesToSave);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStorageProviderHandler_Value = @import("../zig.zig").Guid.initString("162c6fb5-44d3-435b-903d-e613fa093fb5");
pub const IID_IStorageProviderHandler = &IID_IStorageProviderHandler_Value;
pub const IStorageProviderHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyHandlerFromPath: fn(
            self: *const IStorageProviderHandler,
            path: ?[*:0]const u16,
            propertyHandler: ?*?*IStorageProviderPropertyHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyHandlerFromUri: fn(
            self: *const IStorageProviderHandler,
            uri: ?[*:0]const u16,
            propertyHandler: ?*?*IStorageProviderPropertyHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyHandlerFromFileId: fn(
            self: *const IStorageProviderHandler,
            fileId: ?[*:0]const u16,
            propertyHandler: ?*?*IStorageProviderPropertyHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderHandler_GetPropertyHandlerFromPath(self: *const T, path: ?[*:0]const u16, propertyHandler: ?*?*IStorageProviderPropertyHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderHandler.VTable, self.vtable).GetPropertyHandlerFromPath(@ptrCast(*const IStorageProviderHandler, self), path, propertyHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderHandler_GetPropertyHandlerFromUri(self: *const T, uri: ?[*:0]const u16, propertyHandler: ?*?*IStorageProviderPropertyHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderHandler.VTable, self.vtable).GetPropertyHandlerFromUri(@ptrCast(*const IStorageProviderHandler, self), uri, propertyHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorageProviderHandler_GetPropertyHandlerFromFileId(self: *const T, fileId: ?[*:0]const u16, propertyHandler: ?*?*IStorageProviderPropertyHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStorageProviderHandler.VTable, self.vtable).GetPropertyHandlerFromFileId(@ptrCast(*const IStorageProviderHandler, self), fileId, propertyHandler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SyncMgr_Value = @import("../zig.zig").Guid.initString("6295df27-35ee-11d1-8707-00c04fd93327");
pub const CLSID_SyncMgr = &CLSID_SyncMgr_Value;

pub const SYNCMGRSTATUS = enum(i32) {
    STOPPED = 0,
    SKIPPED = 1,
    PENDING = 2,
    UPDATING = 3,
    SUCCEEDED = 4,
    FAILED = 5,
    PAUSED = 6,
    RESUMING = 7,
    UPDATING_INDETERMINATE = 8,
    DELETED = 256,
};
pub const SYNCMGRSTATUS_STOPPED = SYNCMGRSTATUS.STOPPED;
pub const SYNCMGRSTATUS_SKIPPED = SYNCMGRSTATUS.SKIPPED;
pub const SYNCMGRSTATUS_PENDING = SYNCMGRSTATUS.PENDING;
pub const SYNCMGRSTATUS_UPDATING = SYNCMGRSTATUS.UPDATING;
pub const SYNCMGRSTATUS_SUCCEEDED = SYNCMGRSTATUS.SUCCEEDED;
pub const SYNCMGRSTATUS_FAILED = SYNCMGRSTATUS.FAILED;
pub const SYNCMGRSTATUS_PAUSED = SYNCMGRSTATUS.PAUSED;
pub const SYNCMGRSTATUS_RESUMING = SYNCMGRSTATUS.RESUMING;
pub const SYNCMGRSTATUS_UPDATING_INDETERMINATE = SYNCMGRSTATUS.UPDATING_INDETERMINATE;
pub const SYNCMGRSTATUS_DELETED = SYNCMGRSTATUS.DELETED;

pub const SYNCMGRPROGRESSITEM = extern struct {
    cbSize: u32,
    mask: u32,
    lpcStatusText: ?[*:0]const u16,
    dwStatusType: u32,
    iProgValue: i32,
    iMaxValue: i32,
};

pub const SYNCMGRLOGLEVEL = enum(i32) {
    INFORMATION = 1,
    WARNING = 2,
    ERROR = 3,
    // LOGLEVELMAX = 3, this enum value conflicts with ERROR
};
pub const SYNCMGRLOGLEVEL_INFORMATION = SYNCMGRLOGLEVEL.INFORMATION;
pub const SYNCMGRLOGLEVEL_WARNING = SYNCMGRLOGLEVEL.WARNING;
pub const SYNCMGRLOGLEVEL_ERROR = SYNCMGRLOGLEVEL.ERROR;
pub const SYNCMGRLOGLEVEL_LOGLEVELMAX = SYNCMGRLOGLEVEL.ERROR;

pub const SYNCMGRERRORFLAGS = enum(i32) {
    T = 1,
};
pub const SYNCMGRERRORFLAG_ENABLEJUMPTEXT = SYNCMGRERRORFLAGS.T;

pub const SYNCMGRLOGERRORINFO = extern struct {
    cbSize: u32,
    mask: u32,
    dwSyncMgrErrorFlags: u32,
    ErrorID: Guid,
    ItemID: Guid,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrSynchronizeCallback_Value = @import("../zig.zig").Guid.initString("6295df41-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrSynchronizeCallback = &IID_ISyncMgrSynchronizeCallback_Value;
pub const ISyncMgrSynchronizeCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowPropertiesCompleted: fn(
            self: *const ISyncMgrSynchronizeCallback,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrepareForSyncCompleted: fn(
            self: *const ISyncMgrSynchronizeCallback,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SynchronizeCompleted: fn(
            self: *const ISyncMgrSynchronizeCallback,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowErrorCompleted: fn(
            self: *const ISyncMgrSynchronizeCallback,
            hr: HRESULT,
            cItems: u32,
            pItemIDs: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableModeless: fn(
            self: *const ISyncMgrSynchronizeCallback,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Progress: fn(
            self: *const ISyncMgrSynchronizeCallback,
            ItemID: ?*const Guid,
            pSyncProgressItem: ?*const SYNCMGRPROGRESSITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LogError: fn(
            self: *const ISyncMgrSynchronizeCallback,
            dwErrorLevel: u32,
            pszErrorText: ?[*:0]const u16,
            pSyncLogError: ?*const SYNCMGRLOGERRORINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteLogError: fn(
            self: *const ISyncMgrSynchronizeCallback,
            ErrorID: ?*const Guid,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EstablishConnection: fn(
            self: *const ISyncMgrSynchronizeCallback,
            pwszConnection: ?[*:0]const u16,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeCallback_ShowPropertiesCompleted(self: *const T, hr: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeCallback.VTable, self.vtable).ShowPropertiesCompleted(@ptrCast(*const ISyncMgrSynchronizeCallback, self), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeCallback_PrepareForSyncCompleted(self: *const T, hr: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeCallback.VTable, self.vtable).PrepareForSyncCompleted(@ptrCast(*const ISyncMgrSynchronizeCallback, self), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeCallback_SynchronizeCompleted(self: *const T, hr: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeCallback.VTable, self.vtable).SynchronizeCompleted(@ptrCast(*const ISyncMgrSynchronizeCallback, self), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeCallback_ShowErrorCompleted(self: *const T, hr: HRESULT, cItems: u32, pItemIDs: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeCallback.VTable, self.vtable).ShowErrorCompleted(@ptrCast(*const ISyncMgrSynchronizeCallback, self), hr, cItems, pItemIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeCallback_EnableModeless(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeCallback.VTable, self.vtable).EnableModeless(@ptrCast(*const ISyncMgrSynchronizeCallback, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeCallback_Progress(self: *const T, ItemID: ?*const Guid, pSyncProgressItem: ?*const SYNCMGRPROGRESSITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeCallback.VTable, self.vtable).Progress(@ptrCast(*const ISyncMgrSynchronizeCallback, self), ItemID, pSyncProgressItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeCallback_LogError(self: *const T, dwErrorLevel: u32, pszErrorText: ?[*:0]const u16, pSyncLogError: ?*const SYNCMGRLOGERRORINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeCallback.VTable, self.vtable).LogError(@ptrCast(*const ISyncMgrSynchronizeCallback, self), dwErrorLevel, pszErrorText, pSyncLogError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeCallback_DeleteLogError(self: *const T, ErrorID: ?*const Guid, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeCallback.VTable, self.vtable).DeleteLogError(@ptrCast(*const ISyncMgrSynchronizeCallback, self), ErrorID, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeCallback_EstablishConnection(self: *const T, pwszConnection: ?[*:0]const u16, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeCallback.VTable, self.vtable).EstablishConnection(@ptrCast(*const ISyncMgrSynchronizeCallback, self), pwszConnection, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGRITEMFLAGS = enum(i32) {
    HASPROPERTIES = 1,
    TEMPORARY = 2,
    ROAMINGUSER = 4,
    LASTUPDATETIME = 8,
    MAYDELETEITEM = 16,
    HIDDEN = 32,
};
pub const SYNCMGRITEM_HASPROPERTIES = SYNCMGRITEMFLAGS.HASPROPERTIES;
pub const SYNCMGRITEM_TEMPORARY = SYNCMGRITEMFLAGS.TEMPORARY;
pub const SYNCMGRITEM_ROAMINGUSER = SYNCMGRITEMFLAGS.ROAMINGUSER;
pub const SYNCMGRITEM_LASTUPDATETIME = SYNCMGRITEMFLAGS.LASTUPDATETIME;
pub const SYNCMGRITEM_MAYDELETEITEM = SYNCMGRITEMFLAGS.MAYDELETEITEM;
pub const SYNCMGRITEM_HIDDEN = SYNCMGRITEMFLAGS.HIDDEN;

pub const SYNCMGRITEM = extern struct {
    cbSize: u32,
    dwFlags: u32,
    ItemID: Guid,
    dwItemState: u32,
    hIcon: ?HICON,
    wszItemName: [128]u16,
    ftLastUpdate: FILETIME,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrEnumItems_Value = @import("../zig.zig").Guid.initString("6295df2a-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrEnumItems = &IID_ISyncMgrEnumItems_Value;
pub const ISyncMgrEnumItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const ISyncMgrEnumItems,
            celt: u32,
            rgelt: [*]SYNCMGRITEM,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const ISyncMgrEnumItems,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ISyncMgrEnumItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const ISyncMgrEnumItems,
            ppenum: ?*?*ISyncMgrEnumItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEnumItems_Next(self: *const T, celt: u32, rgelt: [*]SYNCMGRITEM, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEnumItems.VTable, self.vtable).Next(@ptrCast(*const ISyncMgrEnumItems, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEnumItems_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEnumItems.VTable, self.vtable).Skip(@ptrCast(*const ISyncMgrEnumItems, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEnumItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEnumItems.VTable, self.vtable).Reset(@ptrCast(*const ISyncMgrEnumItems, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrEnumItems_Clone(self: *const T, ppenum: ?*?*ISyncMgrEnumItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrEnumItems.VTable, self.vtable).Clone(@ptrCast(*const ISyncMgrEnumItems, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGRFLAG = enum(i32) {
    CONNECT = 1,
    PENDINGDISCONNECT = 2,
    MANUAL = 3,
    IDLE = 4,
    INVOKE = 5,
    SCHEDULED = 6,
    EVENTMASK = 255,
    SETTINGS = 256,
    MAYBOTHERUSER = 512,
};
pub const SYNCMGRFLAG_CONNECT = SYNCMGRFLAG.CONNECT;
pub const SYNCMGRFLAG_PENDINGDISCONNECT = SYNCMGRFLAG.PENDINGDISCONNECT;
pub const SYNCMGRFLAG_MANUAL = SYNCMGRFLAG.MANUAL;
pub const SYNCMGRFLAG_IDLE = SYNCMGRFLAG.IDLE;
pub const SYNCMGRFLAG_INVOKE = SYNCMGRFLAG.INVOKE;
pub const SYNCMGRFLAG_SCHEDULED = SYNCMGRFLAG.SCHEDULED;
pub const SYNCMGRFLAG_EVENTMASK = SYNCMGRFLAG.EVENTMASK;
pub const SYNCMGRFLAG_SETTINGS = SYNCMGRFLAG.SETTINGS;
pub const SYNCMGRFLAG_MAYBOTHERUSER = SYNCMGRFLAG.MAYBOTHERUSER;

pub const SYNCMGRHANDLERFLAGS = enum(i32) {
    HASPROPERTIES = 1,
    MAYESTABLISHCONNECTION = 2,
    ALWAYSLISTHANDLER = 4,
    HIDDEN = 8,
};
pub const SYNCMGRHANDLER_HASPROPERTIES = SYNCMGRHANDLERFLAGS.HASPROPERTIES;
pub const SYNCMGRHANDLER_MAYESTABLISHCONNECTION = SYNCMGRHANDLERFLAGS.MAYESTABLISHCONNECTION;
pub const SYNCMGRHANDLER_ALWAYSLISTHANDLER = SYNCMGRHANDLERFLAGS.ALWAYSLISTHANDLER;
pub const SYNCMGRHANDLER_HIDDEN = SYNCMGRHANDLERFLAGS.HIDDEN;

pub const SYNCMGRHANDLERINFO = extern struct {
    cbSize: u32,
    hIcon: ?HICON,
    SyncMgrHandlerFlags: u32,
    wszHandlerName: [32]u16,
};

pub const SYNCMGRITEMSTATE = enum(i32) {
    UNCHECKED = 0,
    CHECKED = 1,
};
pub const SYNCMGRITEMSTATE_UNCHECKED = SYNCMGRITEMSTATE.UNCHECKED;
pub const SYNCMGRITEMSTATE_CHECKED = SYNCMGRITEMSTATE.CHECKED;

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrSynchronize_Value = @import("../zig.zig").Guid.initString("6295df40-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrSynchronize = &IID_ISyncMgrSynchronize_Value;
pub const ISyncMgrSynchronize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const ISyncMgrSynchronize,
            dwReserved: u32,
            dwSyncMgrFlags: u32,
            cbCookie: u32,
            lpCookie: [*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHandlerInfo: fn(
            self: *const ISyncMgrSynchronize,
            ppSyncMgrHandlerInfo: ?*?*SYNCMGRHANDLERINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumSyncMgrItems: fn(
            self: *const ISyncMgrSynchronize,
            ppSyncMgrEnumItems: ?*?*ISyncMgrEnumItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemObject: fn(
            self: *const ISyncMgrSynchronize,
            ItemID: ?*const Guid,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowProperties: fn(
            self: *const ISyncMgrSynchronize,
            hWndParent: ?HWND,
            ItemID: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProgressCallback: fn(
            self: *const ISyncMgrSynchronize,
            lpCallBack: ?*ISyncMgrSynchronizeCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrepareForSync: fn(
            self: *const ISyncMgrSynchronize,
            cbNumItems: u32,
            pItemIDs: [*]Guid,
            hWndParent: ?HWND,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Synchronize: fn(
            self: *const ISyncMgrSynchronize,
            hWndParent: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItemStatus: fn(
            self: *const ISyncMgrSynchronize,
            pItemID: ?*const Guid,
            dwSyncMgrStatus: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowError: fn(
            self: *const ISyncMgrSynchronize,
            hWndParent: ?HWND,
            ErrorID: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_Initialize(self: *const T, dwReserved: u32, dwSyncMgrFlags: u32, cbCookie: u32, lpCookie: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).Initialize(@ptrCast(*const ISyncMgrSynchronize, self), dwReserved, dwSyncMgrFlags, cbCookie, lpCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_GetHandlerInfo(self: *const T, ppSyncMgrHandlerInfo: ?*?*SYNCMGRHANDLERINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).GetHandlerInfo(@ptrCast(*const ISyncMgrSynchronize, self), ppSyncMgrHandlerInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_EnumSyncMgrItems(self: *const T, ppSyncMgrEnumItems: ?*?*ISyncMgrEnumItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).EnumSyncMgrItems(@ptrCast(*const ISyncMgrSynchronize, self), ppSyncMgrEnumItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_GetItemObject(self: *const T, ItemID: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).GetItemObject(@ptrCast(*const ISyncMgrSynchronize, self), ItemID, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_ShowProperties(self: *const T, hWndParent: ?HWND, ItemID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).ShowProperties(@ptrCast(*const ISyncMgrSynchronize, self), hWndParent, ItemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_SetProgressCallback(self: *const T, lpCallBack: ?*ISyncMgrSynchronizeCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).SetProgressCallback(@ptrCast(*const ISyncMgrSynchronize, self), lpCallBack);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_PrepareForSync(self: *const T, cbNumItems: u32, pItemIDs: [*]Guid, hWndParent: ?HWND, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).PrepareForSync(@ptrCast(*const ISyncMgrSynchronize, self), cbNumItems, pItemIDs, hWndParent, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_Synchronize(self: *const T, hWndParent: ?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).Synchronize(@ptrCast(*const ISyncMgrSynchronize, self), hWndParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_SetItemStatus(self: *const T, pItemID: ?*const Guid, dwSyncMgrStatus: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).SetItemStatus(@ptrCast(*const ISyncMgrSynchronize, self), pItemID, dwSyncMgrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronize_ShowError(self: *const T, hWndParent: ?HWND, ErrorID: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronize.VTable, self.vtable).ShowError(@ptrCast(*const ISyncMgrSynchronize, self), hWndParent, ErrorID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGRINVOKEFLAGS = enum(i32) {
    STARTSYNC = 2,
    MINIMIZED = 4,
};
pub const SYNCMGRINVOKE_STARTSYNC = SYNCMGRINVOKEFLAGS.STARTSYNC;
pub const SYNCMGRINVOKE_MINIMIZED = SYNCMGRINVOKEFLAGS.MINIMIZED;

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrSynchronizeInvoke_Value = @import("../zig.zig").Guid.initString("6295df2c-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrSynchronizeInvoke = &IID_ISyncMgrSynchronizeInvoke_Value;
pub const ISyncMgrSynchronizeInvoke = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateItems: fn(
            self: *const ISyncMgrSynchronizeInvoke,
            dwInvokeFlags: u32,
            clsid: ?*const Guid,
            cbCookie: u32,
            pCookie: [*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAll: fn(
            self: *const ISyncMgrSynchronizeInvoke,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeInvoke_UpdateItems(self: *const T, dwInvokeFlags: u32, clsid: ?*const Guid, cbCookie: u32, pCookie: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeInvoke.VTable, self.vtable).UpdateItems(@ptrCast(*const ISyncMgrSynchronizeInvoke, self), dwInvokeFlags, clsid, cbCookie, pCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrSynchronizeInvoke_UpdateAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrSynchronizeInvoke.VTable, self.vtable).UpdateAll(@ptrCast(*const ISyncMgrSynchronizeInvoke, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYNCMGRREGISTERFLAGS = enum(i32) {
    CONNECT = 1,
    PENDINGDISCONNECT = 2,
    IDLE = 4,
};
pub const SYNCMGRREGISTERFLAG_CONNECT = SYNCMGRREGISTERFLAGS.CONNECT;
pub const SYNCMGRREGISTERFLAG_PENDINGDISCONNECT = SYNCMGRREGISTERFLAGS.PENDINGDISCONNECT;
pub const SYNCMGRREGISTERFLAG_IDLE = SYNCMGRREGISTERFLAGS.IDLE;

// TODO: this type is limited to platform 'windows5.0'
const IID_ISyncMgrRegister_Value = @import("../zig.zig").Guid.initString("6295df42-35ee-11d1-8707-00c04fd93327");
pub const IID_ISyncMgrRegister = &IID_ISyncMgrRegister_Value;
pub const ISyncMgrRegister = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterSyncMgrHandler: fn(
            self: *const ISyncMgrRegister,
            clsidHandler: ?*const Guid,
            pwszDescription: ?[*:0]const u16,
            dwSyncMgrRegisterFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterSyncMgrHandler: fn(
            self: *const ISyncMgrRegister,
            clsidHandler: ?*const Guid,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHandlerRegistrationInfo: fn(
            self: *const ISyncMgrRegister,
            clsidHandler: ?*const Guid,
            pdwSyncMgrRegisterFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrRegister_RegisterSyncMgrHandler(self: *const T, clsidHandler: ?*const Guid, pwszDescription: ?[*:0]const u16, dwSyncMgrRegisterFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrRegister.VTable, self.vtable).RegisterSyncMgrHandler(@ptrCast(*const ISyncMgrRegister, self), clsidHandler, pwszDescription, dwSyncMgrRegisterFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrRegister_UnregisterSyncMgrHandler(self: *const T, clsidHandler: ?*const Guid, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrRegister.VTable, self.vtable).UnregisterSyncMgrHandler(@ptrCast(*const ISyncMgrRegister, self), clsidHandler, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISyncMgrRegister_GetHandlerRegistrationInfo(self: *const T, clsidHandler: ?*const Guid, pdwSyncMgrRegisterFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISyncMgrRegister.VTable, self.vtable).GetHandlerRegistrationInfo(@ptrCast(*const ISyncMgrRegister, self), clsidHandler, pdwSyncMgrRegisterFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ThumbnailStreamCache_Value = @import("../zig.zig").Guid.initString("cbe0fed3-4b91-4e90-8354-8a8c84ec6872");
pub const CLSID_ThumbnailStreamCache = &CLSID_ThumbnailStreamCache_Value;

pub const ThumbnailStreamCacheOptions = enum(i32) {
    ExtractIfNotCached = 0,
    ReturnOnlyIfCached = 1,
    ResizeThumbnail = 2,
    AllowSmallerSize = 4,
};
pub const ExtractIfNotCached = ThumbnailStreamCacheOptions.ExtractIfNotCached;
pub const ReturnOnlyIfCached = ThumbnailStreamCacheOptions.ReturnOnlyIfCached;
pub const ResizeThumbnail = ThumbnailStreamCacheOptions.ResizeThumbnail;
pub const AllowSmallerSize = ThumbnailStreamCacheOptions.AllowSmallerSize;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IThumbnailStreamCache_Value = @import("../zig.zig").Guid.initString("90e11430-9569-41d8-ae75-6d4d2ae7cca0");
pub const IID_IThumbnailStreamCache = &IID_IThumbnailStreamCache_Value;
pub const IThumbnailStreamCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThumbnailStream: fn(
            self: *const IThumbnailStreamCache,
            path: ?[*:0]const u16,
            cacheId: u64,
            options: ThumbnailStreamCacheOptions,
            requestedThumbnailSize: u32,
            thumbnailSize: ?*SIZE,
            thumbnailStream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetThumbnailStream: fn(
            self: *const IThumbnailStreamCache,
            path: ?[*:0]const u16,
            cacheId: u64,
            thumbnailSize: SIZE,
            thumbnailStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailStreamCache_GetThumbnailStream(self: *const T, path: ?[*:0]const u16, cacheId: u64, options: ThumbnailStreamCacheOptions, requestedThumbnailSize: u32, thumbnailSize: ?*SIZE, thumbnailStream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailStreamCache.VTable, self.vtable).GetThumbnailStream(@ptrCast(*const IThumbnailStreamCache, self), path, cacheId, options, requestedThumbnailSize, thumbnailSize, thumbnailStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IThumbnailStreamCache_SetThumbnailStream(self: *const T, path: ?[*:0]const u16, cacheId: u64, thumbnailSize: SIZE, thumbnailStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IThumbnailStreamCache.VTable, self.vtable).SetThumbnailStream(@ptrCast(*const IThumbnailStreamCache, self), path, cacheId, thumbnailSize, thumbnailStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_TrackShellMenu_Value = @import("../zig.zig").Guid.initString("8278f931-2a3e-11d2-838f-00c04fd918d0");
pub const CLSID_TrackShellMenu = &CLSID_TrackShellMenu_Value;

pub const WINDOWDATA = extern struct {
    dwWindowID: u32,
    uiCP: u32,
    pidl: ?*ITEMIDLIST,
    lpszUrl: ?PWSTR,
    lpszUrlLocation: ?PWSTR,
    lpszTitle: ?PWSTR,
};

const IID_ITravelLogEntry_Value = @import("../zig.zig").Guid.initString("7ebfdd87-ad18-11d3-a4c5-00c04f72d6b8");
pub const IID_ITravelLogEntry = &IID_ITravelLogEntry_Value;
pub const ITravelLogEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTitle: fn(
            self: *const ITravelLogEntry,
            ppszTitle: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: fn(
            self: *const ITravelLogEntry,
            ppszURL: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogEntry_GetTitle(self: *const T, ppszTitle: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogEntry.VTable, self.vtable).GetTitle(@ptrCast(*const ITravelLogEntry, self), ppszTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogEntry_GetURL(self: *const T, ppszURL: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogEntry.VTable, self.vtable).GetURL(@ptrCast(*const ITravelLogEntry, self), ppszURL);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITravelLogClient_Value = @import("../zig.zig").Guid.initString("241c033e-e659-43da-aa4d-4086dbc4758d");
pub const IID_ITravelLogClient = &IID_ITravelLogClient_Value;
pub const ITravelLogClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindWindowByIndex: fn(
            self: *const ITravelLogClient,
            dwID: u32,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindowData: fn(
            self: *const ITravelLogClient,
            pStream: ?*IStream,
            pWinData: ?*WINDOWDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadHistoryPosition: fn(
            self: *const ITravelLogClient,
            pszUrlLocation: ?PWSTR,
            dwPosition: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogClient_FindWindowByIndex(self: *const T, dwID: u32, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogClient.VTable, self.vtable).FindWindowByIndex(@ptrCast(*const ITravelLogClient, self), dwID, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogClient_GetWindowData(self: *const T, pStream: ?*IStream, pWinData: ?*WINDOWDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogClient.VTable, self.vtable).GetWindowData(@ptrCast(*const ITravelLogClient, self), pStream, pWinData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogClient_LoadHistoryPosition(self: *const T, pszUrlLocation: ?PWSTR, dwPosition: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogClient.VTable, self.vtable).LoadHistoryPosition(@ptrCast(*const ITravelLogClient, self), pszUrlLocation, dwPosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTravelLogEntry_Value = @import("../zig.zig").Guid.initString("7ebfdd85-ad18-11d3-a4c5-00c04f72d6b8");
pub const IID_IEnumTravelLogEntry = &IID_IEnumTravelLogEntry_Value;
pub const IEnumTravelLogEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumTravelLogEntry,
            cElt: u32,
            rgElt: [*]?*ITravelLogEntry,
            pcEltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumTravelLogEntry,
            cElt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumTravelLogEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumTravelLogEntry,
            ppEnum: ?*?*IEnumTravelLogEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTravelLogEntry_Next(self: *const T, cElt: u32, rgElt: [*]?*ITravelLogEntry, pcEltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTravelLogEntry.VTable, self.vtable).Next(@ptrCast(*const IEnumTravelLogEntry, self), cElt, rgElt, pcEltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTravelLogEntry_Skip(self: *const T, cElt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTravelLogEntry.VTable, self.vtable).Skip(@ptrCast(*const IEnumTravelLogEntry, self), cElt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTravelLogEntry_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTravelLogEntry.VTable, self.vtable).Reset(@ptrCast(*const IEnumTravelLogEntry, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTravelLogEntry_Clone(self: *const T, ppEnum: ?*?*IEnumTravelLogEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTravelLogEntry.VTable, self.vtable).Clone(@ptrCast(*const IEnumTravelLogEntry, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TLENUMF = enum(i32) {
    RELATIVE_INCLUDE_CURRENT = 1,
    RELATIVE_BACK = 16,
    RELATIVE_FORE = 32,
    INCLUDE_UNINVOKEABLE = 64,
    ABSOLUTE = 49,
    EXCLUDE_SUBFRAME_ENTRIES = 128,
    EXCLUDE_ABOUT_PAGES = 256,
};
pub const TLEF_RELATIVE_INCLUDE_CURRENT = TLENUMF.RELATIVE_INCLUDE_CURRENT;
pub const TLEF_RELATIVE_BACK = TLENUMF.RELATIVE_BACK;
pub const TLEF_RELATIVE_FORE = TLENUMF.RELATIVE_FORE;
pub const TLEF_INCLUDE_UNINVOKEABLE = TLENUMF.INCLUDE_UNINVOKEABLE;
pub const TLEF_ABSOLUTE = TLENUMF.ABSOLUTE;
pub const TLEF_EXCLUDE_SUBFRAME_ENTRIES = TLENUMF.EXCLUDE_SUBFRAME_ENTRIES;
pub const TLEF_EXCLUDE_ABOUT_PAGES = TLENUMF.EXCLUDE_ABOUT_PAGES;

const IID_ITravelLogStg_Value = @import("../zig.zig").Guid.initString("7ebfdd80-ad18-11d3-a4c5-00c04f72d6b8");
pub const IID_ITravelLogStg = &IID_ITravelLogStg_Value;
pub const ITravelLogStg = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateEntry: fn(
            self: *const ITravelLogStg,
            pszUrl: ?[*:0]const u16,
            pszTitle: ?[*:0]const u16,
            ptleRelativeTo: ?*ITravelLogEntry,
            fPrepend: BOOL,
            pptle: ?*?*ITravelLogEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TravelTo: fn(
            self: *const ITravelLogStg,
            ptle: ?*ITravelLogEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumEntries: fn(
            self: *const ITravelLogStg,
            flags: TLENUMF,
            ppenum: ?*?*IEnumTravelLogEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindEntries: fn(
            self: *const ITravelLogStg,
            flags: TLENUMF,
            pszUrl: ?[*:0]const u16,
            ppenum: ?*?*IEnumTravelLogEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITravelLogStg,
            flags: TLENUMF,
            pcEntries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEntry: fn(
            self: *const ITravelLogStg,
            ptle: ?*ITravelLogEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelativeEntry: fn(
            self: *const ITravelLogStg,
            iOffset: i32,
            ptle: ?*?*ITravelLogEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogStg_CreateEntry(self: *const T, pszUrl: ?[*:0]const u16, pszTitle: ?[*:0]const u16, ptleRelativeTo: ?*ITravelLogEntry, fPrepend: BOOL, pptle: ?*?*ITravelLogEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogStg.VTable, self.vtable).CreateEntry(@ptrCast(*const ITravelLogStg, self), pszUrl, pszTitle, ptleRelativeTo, fPrepend, pptle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogStg_TravelTo(self: *const T, ptle: ?*ITravelLogEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogStg.VTable, self.vtable).TravelTo(@ptrCast(*const ITravelLogStg, self), ptle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogStg_EnumEntries(self: *const T, flags: TLENUMF, ppenum: ?*?*IEnumTravelLogEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogStg.VTable, self.vtable).EnumEntries(@ptrCast(*const ITravelLogStg, self), flags, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogStg_FindEntries(self: *const T, flags: TLENUMF, pszUrl: ?[*:0]const u16, ppenum: ?*?*IEnumTravelLogEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogStg.VTable, self.vtable).FindEntries(@ptrCast(*const ITravelLogStg, self), flags, pszUrl, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogStg_GetCount(self: *const T, flags: TLENUMF, pcEntries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogStg.VTable, self.vtable).GetCount(@ptrCast(*const ITravelLogStg, self), flags, pcEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogStg_RemoveEntry(self: *const T, ptle: ?*ITravelLogEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogStg.VTable, self.vtable).RemoveEntry(@ptrCast(*const ITravelLogStg, self), ptle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLogStg_GetRelativeEntry(self: *const T, iOffset: i32, ptle: ?*?*ITravelLogEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLogStg.VTable, self.vtable).GetRelativeEntry(@ptrCast(*const ITravelLogStg, self), iOffset, ptle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _HLSR_NOREDEF10 = enum(i32) {
    HOME = 0,
    SEARCHPAGE = 1,
    HISTORYFOLDER = 2,
};
pub const HLSR_HOME = _HLSR_NOREDEF10.HOME;
pub const HLSR_SEARCHPAGE = _HLSR_NOREDEF10.SEARCHPAGE;
pub const HLSR_HISTORYFOLDER = _HLSR_NOREDEF10.HISTORYFOLDER;

pub const _HLSHORTCUTF__NOREDEF10 = enum(i32) {
    DEFAULT = 0,
    DONTACTUALLYCREATE = 1,
    USEFILENAMEFROMFRIENDLYNAME = 2,
    USEUNIQUEFILENAME = 4,
    MAYUSEEXISTINGSHORTCUT = 8,
};
pub const HLSHORTCUTF_DEFAULT = _HLSHORTCUTF__NOREDEF10.DEFAULT;
pub const HLSHORTCUTF_DONTACTUALLYCREATE = _HLSHORTCUTF__NOREDEF10.DONTACTUALLYCREATE;
pub const HLSHORTCUTF_USEFILENAMEFROMFRIENDLYNAME = _HLSHORTCUTF__NOREDEF10.USEFILENAMEFROMFRIENDLYNAME;
pub const HLSHORTCUTF_USEUNIQUEFILENAME = _HLSHORTCUTF__NOREDEF10.USEUNIQUEFILENAME;
pub const HLSHORTCUTF_MAYUSEEXISTINGSHORTCUT = _HLSHORTCUTF__NOREDEF10.MAYUSEEXISTINGSHORTCUT;

pub const _HLTRANSLATEF_NOREDEF10 = enum(i32) {
    EFAULT = 0,
    ONTAPPLYDEFAULTPREFIX = 1,
};
pub const HLTRANSLATEF_DEFAULT = _HLTRANSLATEF_NOREDEF10.EFAULT;
pub const HLTRANSLATEF_DONTAPPLYDEFAULTPREFIX = _HLTRANSLATEF_NOREDEF10.ONTAPPLYDEFAULTPREFIX;

pub const HLNF = enum(u32) {
    INTERNALJUMP = 1,
    OPENINNEWWINDOW = 2,
    NAVIGATINGBACK = 4,
    NAVIGATINGFORWARD = 8,
    NAVIGATINGTOSTACKITEM = 16,
    CREATENOHISTORY = 32,
    _,
    pub fn initFlags(o: struct {
        INTERNALJUMP: u1 = 0,
        OPENINNEWWINDOW: u1 = 0,
        NAVIGATINGBACK: u1 = 0,
        NAVIGATINGFORWARD: u1 = 0,
        NAVIGATINGTOSTACKITEM: u1 = 0,
        CREATENOHISTORY: u1 = 0,
    }) HLNF {
        return @intToEnum(HLNF,
              (if (o.INTERNALJUMP == 1) @enumToInt(HLNF.INTERNALJUMP) else 0)
            | (if (o.OPENINNEWWINDOW == 1) @enumToInt(HLNF.OPENINNEWWINDOW) else 0)
            | (if (o.NAVIGATINGBACK == 1) @enumToInt(HLNF.NAVIGATINGBACK) else 0)
            | (if (o.NAVIGATINGFORWARD == 1) @enumToInt(HLNF.NAVIGATINGFORWARD) else 0)
            | (if (o.NAVIGATINGTOSTACKITEM == 1) @enumToInt(HLNF.NAVIGATINGTOSTACKITEM) else 0)
            | (if (o.CREATENOHISTORY == 1) @enumToInt(HLNF.CREATENOHISTORY) else 0)
        );
    }
};
pub const HLNF_INTERNALJUMP = HLNF.INTERNALJUMP;
pub const HLNF_OPENINNEWWINDOW = HLNF.OPENINNEWWINDOW;
pub const HLNF_NAVIGATINGBACK = HLNF.NAVIGATINGBACK;
pub const HLNF_NAVIGATINGFORWARD = HLNF.NAVIGATINGFORWARD;
pub const HLNF_NAVIGATINGTOSTACKITEM = HLNF.NAVIGATINGTOSTACKITEM;
pub const HLNF_CREATENOHISTORY = HLNF.CREATENOHISTORY;

pub const HLINKGETREF = enum(i32) {
    DEFAULT = 0,
    ABSOLUTE = 1,
    RELATIVE = 2,
};
pub const HLINKGETREF_DEFAULT = HLINKGETREF.DEFAULT;
pub const HLINKGETREF_ABSOLUTE = HLINKGETREF.ABSOLUTE;
pub const HLINKGETREF_RELATIVE = HLINKGETREF.RELATIVE;

pub const HLFNAMEF = enum(u32) {
    DEFAULT = 0,
    TRYCACHE = 1,
    TRYPRETTYTARGET = 2,
    TRYFULLTARGET = 4,
    TRYWIN95SHORTCUT = 8,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        TRYCACHE: u1 = 0,
        TRYPRETTYTARGET: u1 = 0,
        TRYFULLTARGET: u1 = 0,
        TRYWIN95SHORTCUT: u1 = 0,
    }) HLFNAMEF {
        return @intToEnum(HLFNAMEF,
              (if (o.DEFAULT == 1) @enumToInt(HLFNAMEF.DEFAULT) else 0)
            | (if (o.TRYCACHE == 1) @enumToInt(HLFNAMEF.TRYCACHE) else 0)
            | (if (o.TRYPRETTYTARGET == 1) @enumToInt(HLFNAMEF.TRYPRETTYTARGET) else 0)
            | (if (o.TRYFULLTARGET == 1) @enumToInt(HLFNAMEF.TRYFULLTARGET) else 0)
            | (if (o.TRYWIN95SHORTCUT == 1) @enumToInt(HLFNAMEF.TRYWIN95SHORTCUT) else 0)
        );
    }
};
pub const HLFNAMEF_DEFAULT = HLFNAMEF.DEFAULT;
pub const HLFNAMEF_TRYCACHE = HLFNAMEF.TRYCACHE;
pub const HLFNAMEF_TRYPRETTYTARGET = HLFNAMEF.TRYPRETTYTARGET;
pub const HLFNAMEF_TRYFULLTARGET = HLFNAMEF.TRYFULLTARGET;
pub const HLFNAMEF_TRYWIN95SHORTCUT = HLFNAMEF.TRYWIN95SHORTCUT;

pub const HLINKMISC = enum(i32) {
    E = 1,
};
pub const HLINKMISC_RELATIVE = HLINKMISC.E;

pub const HLINKSETF = enum(i32) {
    TARGET = 1,
    LOCATION = 2,
};
pub const HLINKSETF_TARGET = HLINKSETF.TARGET;
pub const HLINKSETF_LOCATION = HLINKSETF.LOCATION;

const IID_IHlink_Value = @import("../zig.zig").Guid.initString("79eac9c3-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlink = &IID_IHlink_Value;
pub const IHlink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHlinkSite: fn(
            self: *const IHlink,
            pihlSite: ?*IHlinkSite,
            dwSiteData: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHlinkSite: fn(
            self: *const IHlink,
            ppihlSite: ?*?*IHlinkSite,
            pdwSiteData: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMonikerReference: fn(
            self: *const IHlink,
            grfHLSETF: u32,
            pimkTarget: ?*IMoniker,
            pwzLocation: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMonikerReference: fn(
            self: *const IHlink,
            dwWhichRef: u32,
            ppimkTarget: ?*?*IMoniker,
            ppwzLocation: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStringReference: fn(
            self: *const IHlink,
            grfHLSETF: u32,
            pwzTarget: ?[*:0]const u16,
            pwzLocation: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringReference: fn(
            self: *const IHlink,
            dwWhichRef: u32,
            ppwzTarget: ?*?PWSTR,
            ppwzLocation: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFriendlyName: fn(
            self: *const IHlink,
            pwzFriendlyName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFriendlyName: fn(
            self: *const IHlink,
            grfHLFNAMEF: u32,
            ppwzFriendlyName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTargetFrameName: fn(
            self: *const IHlink,
            pwzTargetFrameName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetFrameName: fn(
            self: *const IHlink,
            ppwzTargetFrameName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMiscStatus: fn(
            self: *const IHlink,
            pdwStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Navigate: fn(
            self: *const IHlink,
            grfHLNF: u32,
            pibc: ?*IBindCtx,
            pibsc: ?*IBindStatusCallback,
            pihlbc: ?*IHlinkBrowseContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAdditionalParams: fn(
            self: *const IHlink,
            pwzAdditionalParams: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdditionalParams: fn(
            self: *const IHlink,
            ppwzAdditionalParams: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_SetHlinkSite(self: *const T, pihlSite: ?*IHlinkSite, dwSiteData: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).SetHlinkSite(@ptrCast(*const IHlink, self), pihlSite, dwSiteData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_GetHlinkSite(self: *const T, ppihlSite: ?*?*IHlinkSite, pdwSiteData: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).GetHlinkSite(@ptrCast(*const IHlink, self), ppihlSite, pdwSiteData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_SetMonikerReference(self: *const T, grfHLSETF: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).SetMonikerReference(@ptrCast(*const IHlink, self), grfHLSETF, pimkTarget, pwzLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_GetMonikerReference(self: *const T, dwWhichRef: u32, ppimkTarget: ?*?*IMoniker, ppwzLocation: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).GetMonikerReference(@ptrCast(*const IHlink, self), dwWhichRef, ppimkTarget, ppwzLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_SetStringReference(self: *const T, grfHLSETF: u32, pwzTarget: ?[*:0]const u16, pwzLocation: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).SetStringReference(@ptrCast(*const IHlink, self), grfHLSETF, pwzTarget, pwzLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_GetStringReference(self: *const T, dwWhichRef: u32, ppwzTarget: ?*?PWSTR, ppwzLocation: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).GetStringReference(@ptrCast(*const IHlink, self), dwWhichRef, ppwzTarget, ppwzLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_SetFriendlyName(self: *const T, pwzFriendlyName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).SetFriendlyName(@ptrCast(*const IHlink, self), pwzFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_GetFriendlyName(self: *const T, grfHLFNAMEF: u32, ppwzFriendlyName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).GetFriendlyName(@ptrCast(*const IHlink, self), grfHLFNAMEF, ppwzFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_SetTargetFrameName(self: *const T, pwzTargetFrameName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).SetTargetFrameName(@ptrCast(*const IHlink, self), pwzTargetFrameName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_GetTargetFrameName(self: *const T, ppwzTargetFrameName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).GetTargetFrameName(@ptrCast(*const IHlink, self), ppwzTargetFrameName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_GetMiscStatus(self: *const T, pdwStatus: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).GetMiscStatus(@ptrCast(*const IHlink, self), pdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_Navigate(self: *const T, grfHLNF: u32, pibc: ?*IBindCtx, pibsc: ?*IBindStatusCallback, pihlbc: ?*IHlinkBrowseContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).Navigate(@ptrCast(*const IHlink, self), grfHLNF, pibc, pibsc, pihlbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_SetAdditionalParams(self: *const T, pwzAdditionalParams: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).SetAdditionalParams(@ptrCast(*const IHlink, self), pwzAdditionalParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlink_GetAdditionalParams(self: *const T, ppwzAdditionalParams: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlink.VTable, self.vtable).GetAdditionalParams(@ptrCast(*const IHlink, self), ppwzAdditionalParams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HLINKWHICHMK = enum(i32) {
    CONTAINER = 1,
    BASE = 2,
};
pub const HLINKWHICHMK_CONTAINER = HLINKWHICHMK.CONTAINER;
pub const HLINKWHICHMK_BASE = HLINKWHICHMK.BASE;

const IID_IHlinkSite_Value = @import("../zig.zig").Guid.initString("79eac9c2-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlinkSite = &IID_IHlinkSite_Value;
pub const IHlinkSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryService: fn(
            self: *const IHlinkSite,
            dwSiteData: u32,
            guidService: ?*const Guid,
            riid: ?*const Guid,
            ppiunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMoniker: fn(
            self: *const IHlinkSite,
            dwSiteData: u32,
            dwAssign: u32,
            dwWhich: u32,
            ppimk: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadyToNavigate: fn(
            self: *const IHlinkSite,
            dwSiteData: u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnNavigationComplete: fn(
            self: *const IHlinkSite,
            dwSiteData: u32,
            dwreserved: u32,
            hrError: HRESULT,
            pwzError: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkSite_QueryService(self: *const T, dwSiteData: u32, guidService: ?*const Guid, riid: ?*const Guid, ppiunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkSite.VTable, self.vtable).QueryService(@ptrCast(*const IHlinkSite, self), dwSiteData, guidService, riid, ppiunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkSite_GetMoniker(self: *const T, dwSiteData: u32, dwAssign: u32, dwWhich: u32, ppimk: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkSite.VTable, self.vtable).GetMoniker(@ptrCast(*const IHlinkSite, self), dwSiteData, dwAssign, dwWhich, ppimk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkSite_ReadyToNavigate(self: *const T, dwSiteData: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkSite.VTable, self.vtable).ReadyToNavigate(@ptrCast(*const IHlinkSite, self), dwSiteData, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkSite_OnNavigationComplete(self: *const T, dwSiteData: u32, dwreserved: u32, hrError: HRESULT, pwzError: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkSite.VTable, self.vtable).OnNavigationComplete(@ptrCast(*const IHlinkSite, self), dwSiteData, dwreserved, hrError, pwzError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHlinkTarget_Value = @import("../zig.zig").Guid.initString("79eac9c4-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlinkTarget = &IID_IHlinkTarget_Value;
pub const IHlinkTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBrowseContext: fn(
            self: *const IHlinkTarget,
            pihlbc: ?*IHlinkBrowseContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBrowseContext: fn(
            self: *const IHlinkTarget,
            ppihlbc: ?*?*IHlinkBrowseContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Navigate: fn(
            self: *const IHlinkTarget,
            grfHLNF: u32,
            pwzJumpLocation: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMoniker: fn(
            self: *const IHlinkTarget,
            pwzLocation: ?[*:0]const u16,
            dwAssign: u32,
            ppimkLocation: ?*?*IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFriendlyName: fn(
            self: *const IHlinkTarget,
            pwzLocation: ?[*:0]const u16,
            ppwzFriendlyName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkTarget_SetBrowseContext(self: *const T, pihlbc: ?*IHlinkBrowseContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkTarget.VTable, self.vtable).SetBrowseContext(@ptrCast(*const IHlinkTarget, self), pihlbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkTarget_GetBrowseContext(self: *const T, ppihlbc: ?*?*IHlinkBrowseContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkTarget.VTable, self.vtable).GetBrowseContext(@ptrCast(*const IHlinkTarget, self), ppihlbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkTarget_Navigate(self: *const T, grfHLNF: u32, pwzJumpLocation: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkTarget.VTable, self.vtable).Navigate(@ptrCast(*const IHlinkTarget, self), grfHLNF, pwzJumpLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkTarget_GetMoniker(self: *const T, pwzLocation: ?[*:0]const u16, dwAssign: u32, ppimkLocation: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkTarget.VTable, self.vtable).GetMoniker(@ptrCast(*const IHlinkTarget, self), pwzLocation, dwAssign, ppimkLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkTarget_GetFriendlyName(self: *const T, pwzLocation: ?[*:0]const u16, ppwzFriendlyName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkTarget.VTable, self.vtable).GetFriendlyName(@ptrCast(*const IHlinkTarget, self), pwzLocation, ppwzFriendlyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHlinkFrame_Value = @import("../zig.zig").Guid.initString("79eac9c5-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlinkFrame = &IID_IHlinkFrame_Value;
pub const IHlinkFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBrowseContext: fn(
            self: *const IHlinkFrame,
            pihlbc: ?*IHlinkBrowseContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBrowseContext: fn(
            self: *const IHlinkFrame,
            ppihlbc: ?*?*IHlinkBrowseContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Navigate: fn(
            self: *const IHlinkFrame,
            grfHLNF: u32,
            pbc: ?*IBindCtx,
            pibsc: ?*IBindStatusCallback,
            pihlNavigate: ?*IHlink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnNavigate: fn(
            self: *const IHlinkFrame,
            grfHLNF: u32,
            pimkTarget: ?*IMoniker,
            pwzLocation: ?[*:0]const u16,
            pwzFriendlyName: ?[*:0]const u16,
            dwreserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateHlink: fn(
            self: *const IHlinkFrame,
            uHLID: u32,
            pimkTarget: ?*IMoniker,
            pwzLocation: ?[*:0]const u16,
            pwzFriendlyName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkFrame_SetBrowseContext(self: *const T, pihlbc: ?*IHlinkBrowseContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkFrame.VTable, self.vtable).SetBrowseContext(@ptrCast(*const IHlinkFrame, self), pihlbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkFrame_GetBrowseContext(self: *const T, ppihlbc: ?*?*IHlinkBrowseContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkFrame.VTable, self.vtable).GetBrowseContext(@ptrCast(*const IHlinkFrame, self), ppihlbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkFrame_Navigate(self: *const T, grfHLNF: u32, pbc: ?*IBindCtx, pibsc: ?*IBindStatusCallback, pihlNavigate: ?*IHlink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkFrame.VTable, self.vtable).Navigate(@ptrCast(*const IHlinkFrame, self), grfHLNF, pbc, pibsc, pihlNavigate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkFrame_OnNavigate(self: *const T, grfHLNF: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16, dwreserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkFrame.VTable, self.vtable).OnNavigate(@ptrCast(*const IHlinkFrame, self), grfHLNF, pimkTarget, pwzLocation, pwzFriendlyName, dwreserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkFrame_UpdateHlink(self: *const T, uHLID: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkFrame.VTable, self.vtable).UpdateHlink(@ptrCast(*const IHlinkFrame, self), uHLID, pimkTarget, pwzLocation, pwzFriendlyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HLITEM = extern struct {
    uHLID: u32,
    pwzFriendlyName: ?PWSTR,
};

const IID_IEnumHLITEM_Value = @import("../zig.zig").Guid.initString("79eac9c6-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IEnumHLITEM = &IID_IEnumHLITEM_Value;
pub const IEnumHLITEM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumHLITEM,
            celt: u32,
            rgelt: ?*HLITEM,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumHLITEM,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumHLITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumHLITEM,
            ppienumhlitem: ?*?*IEnumHLITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumHLITEM_Next(self: *const T, celt: u32, rgelt: ?*HLITEM, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumHLITEM.VTable, self.vtable).Next(@ptrCast(*const IEnumHLITEM, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumHLITEM_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumHLITEM.VTable, self.vtable).Skip(@ptrCast(*const IEnumHLITEM, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumHLITEM_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumHLITEM.VTable, self.vtable).Reset(@ptrCast(*const IEnumHLITEM, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumHLITEM_Clone(self: *const T, ppienumhlitem: ?*?*IEnumHLITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumHLITEM.VTable, self.vtable).Clone(@ptrCast(*const IEnumHLITEM, self), ppienumhlitem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HLTB_INFO = enum(i32) {
    DOCKEDLEFT = 0,
    DOCKEDTOP = 1,
    DOCKEDRIGHT = 2,
    DOCKEDBOTTOM = 3,
    FLOATING = 4,
};
pub const HLTB_DOCKEDLEFT = HLTB_INFO.DOCKEDLEFT;
pub const HLTB_DOCKEDTOP = HLTB_INFO.DOCKEDTOP;
pub const HLTB_DOCKEDRIGHT = HLTB_INFO.DOCKEDRIGHT;
pub const HLTB_DOCKEDBOTTOM = HLTB_INFO.DOCKEDBOTTOM;
pub const HLTB_FLOATING = HLTB_INFO.FLOATING;

pub const HLTBINFO = extern struct {
    uDockType: u32,
    rcTbPos: RECT,
};

pub const HLBWIF_FLAGS = enum(u32) {
    HASFRAMEWNDINFO = 1,
    HASDOCWNDINFO = 2,
    FRAMEWNDMAXIMIZED = 4,
    DOCWNDMAXIMIZED = 8,
    HASWEBTOOLBARINFO = 16,
    WEBTOOLBARHIDDEN = 32,
    _,
    pub fn initFlags(o: struct {
        HASFRAMEWNDINFO: u1 = 0,
        HASDOCWNDINFO: u1 = 0,
        FRAMEWNDMAXIMIZED: u1 = 0,
        DOCWNDMAXIMIZED: u1 = 0,
        HASWEBTOOLBARINFO: u1 = 0,
        WEBTOOLBARHIDDEN: u1 = 0,
    }) HLBWIF_FLAGS {
        return @intToEnum(HLBWIF_FLAGS,
              (if (o.HASFRAMEWNDINFO == 1) @enumToInt(HLBWIF_FLAGS.HASFRAMEWNDINFO) else 0)
            | (if (o.HASDOCWNDINFO == 1) @enumToInt(HLBWIF_FLAGS.HASDOCWNDINFO) else 0)
            | (if (o.FRAMEWNDMAXIMIZED == 1) @enumToInt(HLBWIF_FLAGS.FRAMEWNDMAXIMIZED) else 0)
            | (if (o.DOCWNDMAXIMIZED == 1) @enumToInt(HLBWIF_FLAGS.DOCWNDMAXIMIZED) else 0)
            | (if (o.HASWEBTOOLBARINFO == 1) @enumToInt(HLBWIF_FLAGS.HASWEBTOOLBARINFO) else 0)
            | (if (o.WEBTOOLBARHIDDEN == 1) @enumToInt(HLBWIF_FLAGS.WEBTOOLBARHIDDEN) else 0)
        );
    }
};
pub const HLBWIF_HASFRAMEWNDINFO = HLBWIF_FLAGS.HASFRAMEWNDINFO;
pub const HLBWIF_HASDOCWNDINFO = HLBWIF_FLAGS.HASDOCWNDINFO;
pub const HLBWIF_FRAMEWNDMAXIMIZED = HLBWIF_FLAGS.FRAMEWNDMAXIMIZED;
pub const HLBWIF_DOCWNDMAXIMIZED = HLBWIF_FLAGS.DOCWNDMAXIMIZED;
pub const HLBWIF_HASWEBTOOLBARINFO = HLBWIF_FLAGS.HASWEBTOOLBARINFO;
pub const HLBWIF_WEBTOOLBARHIDDEN = HLBWIF_FLAGS.WEBTOOLBARHIDDEN;

pub const HLBWINFO = extern struct {
    cbSize: u32,
    grfHLBWIF: u32,
    rcFramePos: RECT,
    rcDocPos: RECT,
    hltbinfo: HLTBINFO,
};

pub const HLID_INFO = enum(u32) {
    INVALID = 0,
    PREVIOUS = 4294967295,
    NEXT = 4294967294,
    CURRENT = 4294967293,
    STACKBOTTOM = 4294967292,
    STACKTOP = 4294967291,
};
pub const HLID_INVALID = HLID_INFO.INVALID;
pub const HLID_PREVIOUS = HLID_INFO.PREVIOUS;
pub const HLID_NEXT = HLID_INFO.NEXT;
pub const HLID_CURRENT = HLID_INFO.CURRENT;
pub const HLID_STACKBOTTOM = HLID_INFO.STACKBOTTOM;
pub const HLID_STACKTOP = HLID_INFO.STACKTOP;

pub const HLQF_INFO = enum(i32) {
    VALID = 1,
    CURRENT = 2,
};
pub const HLQF_ISVALID = HLQF_INFO.VALID;
pub const HLQF_ISCURRENT = HLQF_INFO.CURRENT;

const IID_IHlinkBrowseContext_Value = @import("../zig.zig").Guid.initString("79eac9c7-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHlinkBrowseContext = &IID_IHlinkBrowseContext_Value;
pub const IHlinkBrowseContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: fn(
            self: *const IHlinkBrowseContext,
            reserved: u32,
            piunk: ?*IUnknown,
            pimk: ?*IMoniker,
            pdwRegister: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const IHlinkBrowseContext,
            pimk: ?*IMoniker,
            fBindIfRootRegistered: BOOL,
            ppiunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Revoke: fn(
            self: *const IHlinkBrowseContext,
            dwRegister: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBrowseWindowInfo: fn(
            self: *const IHlinkBrowseContext,
            phlbwi: ?*HLBWINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBrowseWindowInfo: fn(
            self: *const IHlinkBrowseContext,
            phlbwi: ?*HLBWINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInitialHlink: fn(
            self: *const IHlinkBrowseContext,
            pimkTarget: ?*IMoniker,
            pwzLocation: ?[*:0]const u16,
            pwzFriendlyName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnNavigateHlink: fn(
            self: *const IHlinkBrowseContext,
            grfHLNF: u32,
            pimkTarget: ?*IMoniker,
            pwzLocation: ?[*:0]const u16,
            pwzFriendlyName: ?[*:0]const u16,
            puHLID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateHlink: fn(
            self: *const IHlinkBrowseContext,
            uHLID: u32,
            pimkTarget: ?*IMoniker,
            pwzLocation: ?[*:0]const u16,
            pwzFriendlyName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumNavigationStack: fn(
            self: *const IHlinkBrowseContext,
            dwReserved: u32,
            grfHLFNAMEF: u32,
            ppienumhlitem: ?*?*IEnumHLITEM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHlink: fn(
            self: *const IHlinkBrowseContext,
            grfHLQF: u32,
            uHLID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHlink: fn(
            self: *const IHlinkBrowseContext,
            uHLID: u32,
            ppihl: ?*?*IHlink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentHlink: fn(
            self: *const IHlinkBrowseContext,
            uHLID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IHlinkBrowseContext,
            piunkOuter: ?*IUnknown,
            riid: ?*const Guid,
            ppiunkObj: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IHlinkBrowseContext,
            reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_Register(self: *const T, reserved: u32, piunk: ?*IUnknown, pimk: ?*IMoniker, pdwRegister: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).Register(@ptrCast(*const IHlinkBrowseContext, self), reserved, piunk, pimk, pdwRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_GetObject(self: *const T, pimk: ?*IMoniker, fBindIfRootRegistered: BOOL, ppiunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).GetObject(@ptrCast(*const IHlinkBrowseContext, self), pimk, fBindIfRootRegistered, ppiunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_Revoke(self: *const T, dwRegister: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).Revoke(@ptrCast(*const IHlinkBrowseContext, self), dwRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_SetBrowseWindowInfo(self: *const T, phlbwi: ?*HLBWINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).SetBrowseWindowInfo(@ptrCast(*const IHlinkBrowseContext, self), phlbwi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_GetBrowseWindowInfo(self: *const T, phlbwi: ?*HLBWINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).GetBrowseWindowInfo(@ptrCast(*const IHlinkBrowseContext, self), phlbwi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_SetInitialHlink(self: *const T, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).SetInitialHlink(@ptrCast(*const IHlinkBrowseContext, self), pimkTarget, pwzLocation, pwzFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_OnNavigateHlink(self: *const T, grfHLNF: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16, puHLID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).OnNavigateHlink(@ptrCast(*const IHlinkBrowseContext, self), grfHLNF, pimkTarget, pwzLocation, pwzFriendlyName, puHLID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_UpdateHlink(self: *const T, uHLID: u32, pimkTarget: ?*IMoniker, pwzLocation: ?[*:0]const u16, pwzFriendlyName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).UpdateHlink(@ptrCast(*const IHlinkBrowseContext, self), uHLID, pimkTarget, pwzLocation, pwzFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_EnumNavigationStack(self: *const T, dwReserved: u32, grfHLFNAMEF: u32, ppienumhlitem: ?*?*IEnumHLITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).EnumNavigationStack(@ptrCast(*const IHlinkBrowseContext, self), dwReserved, grfHLFNAMEF, ppienumhlitem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_QueryHlink(self: *const T, grfHLQF: u32, uHLID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).QueryHlink(@ptrCast(*const IHlinkBrowseContext, self), grfHLQF, uHLID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_GetHlink(self: *const T, uHLID: u32, ppihl: ?*?*IHlink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).GetHlink(@ptrCast(*const IHlinkBrowseContext, self), uHLID, ppihl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_SetCurrentHlink(self: *const T, uHLID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).SetCurrentHlink(@ptrCast(*const IHlinkBrowseContext, self), uHLID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_Clone(self: *const T, piunkOuter: ?*IUnknown, riid: ?*const Guid, ppiunkObj: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).Clone(@ptrCast(*const IHlinkBrowseContext, self), piunkOuter, riid, ppiunkObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHlinkBrowseContext_Close(self: *const T, reserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHlinkBrowseContext.VTable, self.vtable).Close(@ptrCast(*const IHlinkBrowseContext, self), reserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IExtensionServices_Value = @import("../zig.zig").Guid.initString("79eac9cb-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IExtensionServices = &IID_IExtensionServices_Value;
pub const IExtensionServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAdditionalHeaders: fn(
            self: *const IExtensionServices,
            pwzAdditionalHeaders: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAuthenticateData: fn(
            self: *const IExtensionServices,
            phwnd: ?HWND,
            pwzUsername: ?[*:0]const u16,
            pwzPassword: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtensionServices_SetAdditionalHeaders(self: *const T, pwzAdditionalHeaders: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtensionServices.VTable, self.vtable).SetAdditionalHeaders(@ptrCast(*const IExtensionServices, self), pwzAdditionalHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtensionServices_SetAuthenticateData(self: *const T, phwnd: ?HWND, pwzUsername: ?[*:0]const u16, pwzPassword: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtensionServices.VTable, self.vtable).SetAuthenticateData(@ptrCast(*const IExtensionServices, self), phwnd, pwzUsername, pwzPassword);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITravelEntry_Value = @import("../zig.zig").Guid.initString("f46edb3b-bc2f-11d0-9412-00aa00a3ebd3");
pub const IID_ITravelEntry = &IID_ITravelEntry_Value;
pub const ITravelEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: fn(
            self: *const ITravelEntry,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const ITravelEntry,
            punk: ?*IUnknown,
            fIsLocalAnchor: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPidl: fn(
            self: *const ITravelEntry,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelEntry_Invoke(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelEntry.VTable, self.vtable).Invoke(@ptrCast(*const ITravelEntry, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelEntry_Update(self: *const T, punk: ?*IUnknown, fIsLocalAnchor: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelEntry.VTable, self.vtable).Update(@ptrCast(*const ITravelEntry, self), punk, fIsLocalAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelEntry_GetPidl(self: *const T, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelEntry.VTable, self.vtable).GetPidl(@ptrCast(*const ITravelEntry, self), ppidl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITravelLog_Value = @import("../zig.zig").Guid.initString("66a9cb08-4802-11d2-a561-00a0c92dbfe8");
pub const IID_ITravelLog = &IID_ITravelLog_Value;
pub const ITravelLog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddEntry: fn(
            self: *const ITravelLog,
            punk: ?*IUnknown,
            fIsLocalAnchor: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateEntry: fn(
            self: *const ITravelLog,
            punk: ?*IUnknown,
            fIsLocalAnchor: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateExternal: fn(
            self: *const ITravelLog,
            punk: ?*IUnknown,
            punkHLBrowseContext: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Travel: fn(
            self: *const ITravelLog,
            punk: ?*IUnknown,
            iOffset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTravelEntry: fn(
            self: *const ITravelLog,
            punk: ?*IUnknown,
            iOffset: i32,
            ppte: ?*?*ITravelEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTravelEntry: fn(
            self: *const ITravelLog,
            punk: ?*IUnknown,
            pidl: ?*ITEMIDLIST,
            ppte: ?*?*ITravelEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetToolTipText: fn(
            self: *const ITravelLog,
            punk: ?*IUnknown,
            iOffset: i32,
            idsTemplate: i32,
            pwzText: [*:0]u16,
            cchText: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertMenuEntries: fn(
            self: *const ITravelLog,
            punk: ?*IUnknown,
            hmenu: ?HMENU,
            nPos: i32,
            idFirst: i32,
            idLast: i32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const ITravelLog,
            pptl: ?*?*ITravelLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CountEntries: fn(
            self: *const ITravelLog,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Revert: fn(
            self: *const ITravelLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_AddEntry(self: *const T, punk: ?*IUnknown, fIsLocalAnchor: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).AddEntry(@ptrCast(*const ITravelLog, self), punk, fIsLocalAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_UpdateEntry(self: *const T, punk: ?*IUnknown, fIsLocalAnchor: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).UpdateEntry(@ptrCast(*const ITravelLog, self), punk, fIsLocalAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_UpdateExternal(self: *const T, punk: ?*IUnknown, punkHLBrowseContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).UpdateExternal(@ptrCast(*const ITravelLog, self), punk, punkHLBrowseContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_Travel(self: *const T, punk: ?*IUnknown, iOffset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).Travel(@ptrCast(*const ITravelLog, self), punk, iOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_GetTravelEntry(self: *const T, punk: ?*IUnknown, iOffset: i32, ppte: ?*?*ITravelEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).GetTravelEntry(@ptrCast(*const ITravelLog, self), punk, iOffset, ppte);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_FindTravelEntry(self: *const T, punk: ?*IUnknown, pidl: ?*ITEMIDLIST, ppte: ?*?*ITravelEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).FindTravelEntry(@ptrCast(*const ITravelLog, self), punk, pidl, ppte);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_GetToolTipText(self: *const T, punk: ?*IUnknown, iOffset: i32, idsTemplate: i32, pwzText: [*:0]u16, cchText: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).GetToolTipText(@ptrCast(*const ITravelLog, self), punk, iOffset, idsTemplate, pwzText, cchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_InsertMenuEntries(self: *const T, punk: ?*IUnknown, hmenu: ?HMENU, nPos: i32, idFirst: i32, idLast: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).InsertMenuEntries(@ptrCast(*const ITravelLog, self), punk, hmenu, nPos, idFirst, idLast, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_Clone(self: *const T, pptl: ?*?*ITravelLog) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).Clone(@ptrCast(*const ITravelLog, self), pptl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_CountEntries(self: *const T, punk: ?*IUnknown) callconv(.Inline) u32 {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).CountEntries(@ptrCast(*const ITravelLog, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITravelLog_Revert(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITravelLog.VTable, self.vtable).Revert(@ptrCast(*const ITravelLog, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CIE4ConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IConnectionPoint.VTable,
        DoInvokeIE4: fn(
            self: *const CIE4ConnectionPoint,
            pf: ?*BOOL,
            ppv: ?*?*anyopaque,
            dispid: i32,
            pdispparams: ?*DISPPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoInvokePIDLIE4: fn(
            self: *const CIE4ConnectionPoint,
            dispid: i32,
            pidl: ?*ITEMIDLIST,
            fCanCancel: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConnectionPoint.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn CIE4ConnectionPoint_DoInvokeIE4(self: *const T, pf: ?*BOOL, ppv: ?*?*anyopaque, dispid: i32, pdispparams: ?*DISPPARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const CIE4ConnectionPoint.VTable, self.vtable).DoInvokeIE4(@ptrCast(*const CIE4ConnectionPoint, self), pf, ppv, dispid, pdispparams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn CIE4ConnectionPoint_DoInvokePIDLIE4(self: *const T, dispid: i32, pidl: ?*ITEMIDLIST, fCanCancel: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const CIE4ConnectionPoint.VTable, self.vtable).DoInvokePIDLIE4(@ptrCast(*const CIE4ConnectionPoint, self), dispid, pidl, fCanCancel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExpDispSupportXP_Value = @import("../zig.zig").Guid.initString("2f0dd58c-f789-4f14-99fb-9293b3c9c212");
pub const IID_IExpDispSupportXP = &IID_IExpDispSupportXP_Value;
pub const IExpDispSupportXP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindCIE4ConnectionPoint: fn(
            self: *const IExpDispSupportXP,
            riid: ?*const Guid,
            ppccp: ?*?*CIE4ConnectionPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTranslateAccelerator: fn(
            self: *const IExpDispSupportXP,
            pMsg: ?*MSG,
            grfModifiers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnInvoke: fn(
            self: *const IExpDispSupportXP,
            dispidMember: i32,
            iid: ?*const Guid,
            lcid: u32,
            wFlags: u16,
            pdispparams: ?*DISPPARAMS,
            pVarResult: ?*VARIANT,
            pexcepinfo: ?*EXCEPINFO,
            puArgErr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpDispSupportXP_FindCIE4ConnectionPoint(self: *const T, riid: ?*const Guid, ppccp: ?*?*CIE4ConnectionPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpDispSupportXP.VTable, self.vtable).FindCIE4ConnectionPoint(@ptrCast(*const IExpDispSupportXP, self), riid, ppccp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpDispSupportXP_OnTranslateAccelerator(self: *const T, pMsg: ?*MSG, grfModifiers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpDispSupportXP.VTable, self.vtable).OnTranslateAccelerator(@ptrCast(*const IExpDispSupportXP, self), pMsg, grfModifiers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpDispSupportXP_OnInvoke(self: *const T, dispidMember: i32, iid: ?*const Guid, lcid: u32, wFlags: u16, pdispparams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO, puArgErr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpDispSupportXP.VTable, self.vtable).OnInvoke(@ptrCast(*const IExpDispSupportXP, self), dispidMember, iid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IExpDispSupport_Value = @import("../zig.zig").Guid.initString("0d7d1d00-6fc0-11d0-a974-00c04fd705a2");
pub const IID_IExpDispSupport = &IID_IExpDispSupport_Value;
pub const IExpDispSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindConnectionPoint: fn(
            self: *const IExpDispSupport,
            riid: ?*const Guid,
            ppccp: ?*?*IConnectionPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTranslateAccelerator: fn(
            self: *const IExpDispSupport,
            pMsg: ?*MSG,
            grfModifiers: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnInvoke: fn(
            self: *const IExpDispSupport,
            dispidMember: i32,
            iid: ?*const Guid,
            lcid: u32,
            wFlags: u16,
            pdispparams: ?*DISPPARAMS,
            pVarResult: ?*VARIANT,
            pexcepinfo: ?*EXCEPINFO,
            puArgErr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpDispSupport_FindConnectionPoint(self: *const T, riid: ?*const Guid, ppccp: ?*?*IConnectionPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpDispSupport.VTable, self.vtable).FindConnectionPoint(@ptrCast(*const IExpDispSupport, self), riid, ppccp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpDispSupport_OnTranslateAccelerator(self: *const T, pMsg: ?*MSG, grfModifiers: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpDispSupport.VTable, self.vtable).OnTranslateAccelerator(@ptrCast(*const IExpDispSupport, self), pMsg, grfModifiers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpDispSupport_OnInvoke(self: *const T, dispidMember: i32, iid: ?*const Guid, lcid: u32, wFlags: u16, pdispparams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO, puArgErr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpDispSupport.VTable, self.vtable).OnInvoke(@ptrCast(*const IExpDispSupport, self), dispidMember, iid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BNSTATE = enum(i32) {
    NORMAL = 0,
    BEGIN_NAVIGATE = 1,
    NAVIGATE = 2,
};
pub const BNS_NORMAL = BNSTATE.NORMAL;
pub const BNS_BEGIN_NAVIGATE = BNSTATE.BEGIN_NAVIGATE;
pub const BNS_NAVIGATE = BNSTATE.NAVIGATE;

pub const SHELLBROWSERSHOWCONTROL = enum(i32) {
    HIDE = 0,
    SHOW = 1,
    TOGGLE = 2,
    QUERY = 3,
};
pub const SBSC_HIDE = SHELLBROWSERSHOWCONTROL.HIDE;
pub const SBSC_SHOW = SHELLBROWSERSHOWCONTROL.SHOW;
pub const SBSC_TOGGLE = SHELLBROWSERSHOWCONTROL.TOGGLE;
pub const SBSC_QUERY = SHELLBROWSERSHOWCONTROL.QUERY;

const IID_IBrowserService_Value = @import("../zig.zig").Guid.initString("02ba3b52-0547-11d1-b833-00c04fc9b31f");
pub const IID_IBrowserService = &IID_IBrowserService_Value;
pub const IBrowserService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParentSite: fn(
            self: *const IBrowserService,
            ppipsite: ?*?*IOleInPlaceSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTitle: fn(
            self: *const IBrowserService,
            psv: ?*IShellView,
            pszName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitle: fn(
            self: *const IBrowserService,
            psv: ?*IShellView,
            pszName: [*:0]u16,
            cchName: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOleObject: fn(
            self: *const IBrowserService,
            ppobjv: ?*?*IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTravelLog: fn(
            self: *const IBrowserService,
            pptl: ?*?*ITravelLog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowControlWindow: fn(
            self: *const IBrowserService,
            id: u32,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsControlWindowShown: fn(
            self: *const IBrowserService,
            id: u32,
            pfShown: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IEGetDisplayName: fn(
            self: *const IBrowserService,
            pidl: ?*ITEMIDLIST,
            pwszName: ?PWSTR,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IEParseDisplayName: fn(
            self: *const IBrowserService,
            uiCP: u32,
            pwszPath: ?[*:0]const u16,
            ppidlOut: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayParseError: fn(
            self: *const IBrowserService,
            hres: HRESULT,
            pwszPath: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateToPidl: fn(
            self: *const IBrowserService,
            pidl: ?*ITEMIDLIST,
            grfHLNF: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNavigateState: fn(
            self: *const IBrowserService,
            bnstate: BNSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNavigateState: fn(
            self: *const IBrowserService,
            pbnstate: ?*BNSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyRedirect: fn(
            self: *const IBrowserService,
            psv: ?*IShellView,
            pidl: ?*ITEMIDLIST,
            pfDidBrowse: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindowList: fn(
            self: *const IBrowserService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateBackForwardState: fn(
            self: *const IBrowserService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IBrowserService,
            dwFlags: u32,
            dwFlagMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IBrowserService,
            pdwFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanNavigateNow: fn(
            self: *const IBrowserService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPidl: fn(
            self: *const IBrowserService,
            ppidl: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReferrer: fn(
            self: *const IBrowserService,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBrowserIndex: fn(
            self: *const IBrowserService,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetBrowserByIndex: fn(
            self: *const IBrowserService,
            dwID: u32,
            ppunk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHistoryObject: fn(
            self: *const IBrowserService,
            ppole: ?*?*IOleObject,
            pstm: ?*?*IStream,
            ppbc: ?*?*IBindCtx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHistoryObject: fn(
            self: *const IBrowserService,
            pole: ?*IOleObject,
            fIsLocalAnchor: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CacheOLEServer: fn(
            self: *const IBrowserService,
            pole: ?*IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSetCodePage: fn(
            self: *const IBrowserService,
            pvarIn: ?*VARIANT,
            pvarOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnHttpEquiv: fn(
            self: *const IBrowserService,
            psv: ?*IShellView,
            fDone: BOOL,
            pvarargIn: ?*VARIANT,
            pvarargOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPalette: fn(
            self: *const IBrowserService,
            hpal: ?*?HPALETTE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterWindow: fn(
            self: *const IBrowserService,
            fForceRegister: BOOL,
            swc: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetParentSite(self: *const T, ppipsite: ?*?*IOleInPlaceSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetParentSite(@ptrCast(*const IBrowserService, self), ppipsite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_SetTitle(self: *const T, psv: ?*IShellView, pszName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).SetTitle(@ptrCast(*const IBrowserService, self), psv, pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetTitle(self: *const T, psv: ?*IShellView, pszName: [*:0]u16, cchName: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetTitle(@ptrCast(*const IBrowserService, self), psv, pszName, cchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetOleObject(self: *const T, ppobjv: ?*?*IOleObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetOleObject(@ptrCast(*const IBrowserService, self), ppobjv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetTravelLog(self: *const T, pptl: ?*?*ITravelLog) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetTravelLog(@ptrCast(*const IBrowserService, self), pptl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_ShowControlWindow(self: *const T, id: u32, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).ShowControlWindow(@ptrCast(*const IBrowserService, self), id, fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_IsControlWindowShown(self: *const T, id: u32, pfShown: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).IsControlWindowShown(@ptrCast(*const IBrowserService, self), id, pfShown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_IEGetDisplayName(self: *const T, pidl: ?*ITEMIDLIST, pwszName: ?PWSTR, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).IEGetDisplayName(@ptrCast(*const IBrowserService, self), pidl, pwszName, uFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_IEParseDisplayName(self: *const T, uiCP: u32, pwszPath: ?[*:0]const u16, ppidlOut: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).IEParseDisplayName(@ptrCast(*const IBrowserService, self), uiCP, pwszPath, ppidlOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_DisplayParseError(self: *const T, hres: HRESULT, pwszPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).DisplayParseError(@ptrCast(*const IBrowserService, self), hres, pwszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_NavigateToPidl(self: *const T, pidl: ?*ITEMIDLIST, grfHLNF: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).NavigateToPidl(@ptrCast(*const IBrowserService, self), pidl, grfHLNF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_SetNavigateState(self: *const T, bnstate: BNSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).SetNavigateState(@ptrCast(*const IBrowserService, self), bnstate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetNavigateState(self: *const T, pbnstate: ?*BNSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetNavigateState(@ptrCast(*const IBrowserService, self), pbnstate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_NotifyRedirect(self: *const T, psv: ?*IShellView, pidl: ?*ITEMIDLIST, pfDidBrowse: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).NotifyRedirect(@ptrCast(*const IBrowserService, self), psv, pidl, pfDidBrowse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_UpdateWindowList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).UpdateWindowList(@ptrCast(*const IBrowserService, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_UpdateBackForwardState(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).UpdateBackForwardState(@ptrCast(*const IBrowserService, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_SetFlags(self: *const T, dwFlags: u32, dwFlagMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).SetFlags(@ptrCast(*const IBrowserService, self), dwFlags, dwFlagMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetFlags(@ptrCast(*const IBrowserService, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_CanNavigateNow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).CanNavigateNow(@ptrCast(*const IBrowserService, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetPidl(self: *const T, ppidl: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetPidl(@ptrCast(*const IBrowserService, self), ppidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_SetReferrer(self: *const T, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).SetReferrer(@ptrCast(*const IBrowserService, self), pidl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetBrowserIndex(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetBrowserIndex(@ptrCast(*const IBrowserService, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetBrowserByIndex(self: *const T, dwID: u32, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetBrowserByIndex(@ptrCast(*const IBrowserService, self), dwID, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetHistoryObject(self: *const T, ppole: ?*?*IOleObject, pstm: ?*?*IStream, ppbc: ?*?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetHistoryObject(@ptrCast(*const IBrowserService, self), ppole, pstm, ppbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_SetHistoryObject(self: *const T, pole: ?*IOleObject, fIsLocalAnchor: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).SetHistoryObject(@ptrCast(*const IBrowserService, self), pole, fIsLocalAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_CacheOLEServer(self: *const T, pole: ?*IOleObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).CacheOLEServer(@ptrCast(*const IBrowserService, self), pole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetSetCodePage(self: *const T, pvarIn: ?*VARIANT, pvarOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetSetCodePage(@ptrCast(*const IBrowserService, self), pvarIn, pvarOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_OnHttpEquiv(self: *const T, psv: ?*IShellView, fDone: BOOL, pvarargIn: ?*VARIANT, pvarargOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).OnHttpEquiv(@ptrCast(*const IBrowserService, self), psv, fDone, pvarargIn, pvarargOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_GetPalette(self: *const T, hpal: ?*?HPALETTE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).GetPalette(@ptrCast(*const IBrowserService, self), hpal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService_RegisterWindow(self: *const T, fForceRegister: BOOL, swc: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService.VTable, self.vtable).RegisterWindow(@ptrCast(*const IBrowserService, self), fForceRegister, swc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellService_Value = @import("../zig.zig").Guid.initString("5836fb00-8187-11cf-a12b-00aa004ae837");
pub const IID_IShellService = &IID_IShellService_Value;
pub const IShellService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetOwner: fn(
            self: *const IShellService,
            punkOwner: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellService_SetOwner(self: *const T, punkOwner: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellService.VTable, self.vtable).SetOwner(@ptrCast(*const IShellService, self), punkOwner);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SECURELOCKCODE = enum(i32) {
    NOCHANGE = -1,
    SET_UNSECURE = 0,
    SET_MIXED = 1,
    SET_SECUREUNKNOWNBIT = 2,
    SET_SECURE40BIT = 3,
    SET_SECURE56BIT = 4,
    SET_FORTEZZA = 5,
    SET_SECURE128BIT = 6,
    FIRSTSUGGEST = 7,
    // SUGGEST_UNSECURE = 7, this enum value conflicts with FIRSTSUGGEST
    SUGGEST_MIXED = 8,
    SUGGEST_SECUREUNKNOWNBIT = 9,
    SUGGEST_SECURE40BIT = 10,
    SUGGEST_SECURE56BIT = 11,
    SUGGEST_FORTEZZA = 12,
    SUGGEST_SECURE128BIT = 13,
};
pub const SECURELOCK_NOCHANGE = SECURELOCKCODE.NOCHANGE;
pub const SECURELOCK_SET_UNSECURE = SECURELOCKCODE.SET_UNSECURE;
pub const SECURELOCK_SET_MIXED = SECURELOCKCODE.SET_MIXED;
pub const SECURELOCK_SET_SECUREUNKNOWNBIT = SECURELOCKCODE.SET_SECUREUNKNOWNBIT;
pub const SECURELOCK_SET_SECURE40BIT = SECURELOCKCODE.SET_SECURE40BIT;
pub const SECURELOCK_SET_SECURE56BIT = SECURELOCKCODE.SET_SECURE56BIT;
pub const SECURELOCK_SET_FORTEZZA = SECURELOCKCODE.SET_FORTEZZA;
pub const SECURELOCK_SET_SECURE128BIT = SECURELOCKCODE.SET_SECURE128BIT;
pub const SECURELOCK_FIRSTSUGGEST = SECURELOCKCODE.FIRSTSUGGEST;
pub const SECURELOCK_SUGGEST_UNSECURE = SECURELOCKCODE.FIRSTSUGGEST;
pub const SECURELOCK_SUGGEST_MIXED = SECURELOCKCODE.SUGGEST_MIXED;
pub const SECURELOCK_SUGGEST_SECUREUNKNOWNBIT = SECURELOCKCODE.SUGGEST_SECUREUNKNOWNBIT;
pub const SECURELOCK_SUGGEST_SECURE40BIT = SECURELOCKCODE.SUGGEST_SECURE40BIT;
pub const SECURELOCK_SUGGEST_SECURE56BIT = SECURELOCKCODE.SUGGEST_SECURE56BIT;
pub const SECURELOCK_SUGGEST_FORTEZZA = SECURELOCKCODE.SUGGEST_FORTEZZA;
pub const SECURELOCK_SUGGEST_SECURE128BIT = SECURELOCKCODE.SUGGEST_SECURE128BIT;

pub const BASEBROWSERDATAXP = extern struct {
    _hwnd: ?HWND,
    _ptl: ?*ITravelLog,
    _phlf: ?*IHlinkFrame,
    _pautoWB2: ?*IWebBrowser2,
    _pautoEDS: ?*IExpDispSupportXP,
    _pautoSS: ?*IShellService,
    _eSecureLockIcon: i32,
    _bitfield: u32,
    _uActivateState: u32,
    _pidlViewState: ?*ITEMIDLIST,
    _pctView: ?*IOleCommandTarget,
    _pidlCur: ?*ITEMIDLIST,
    _psv: ?*IShellView,
    _psf: ?*IShellFolder,
    _hwndView: ?HWND,
    _pszTitleCur: ?PWSTR,
    _pidlPending: ?*ITEMIDLIST,
    _psvPending: ?*IShellView,
    _psfPending: ?*IShellFolder,
    _hwndViewPending: ?HWND,
    _pszTitlePending: ?PWSTR,
    _fIsViewMSHTML: BOOL,
    _fPrivacyImpacted: BOOL,
    _clsidView: Guid,
    _clsidViewPending: Guid,
    _hwndFrame: ?HWND,
};

pub const BASEBROWSERDATALH = extern struct {
    _hwnd: ?HWND,
    _ptl: ?*ITravelLog,
    _phlf: ?*IHlinkFrame,
    _pautoWB2: ?*IWebBrowser2,
    _pautoEDS: ?*IExpDispSupport,
    _pautoSS: ?*IShellService,
    _eSecureLockIcon: i32,
    _bitfield: u32,
    _uActivateState: u32,
    _pidlViewState: ?*ITEMIDLIST,
    _pctView: ?*IOleCommandTarget,
    _pidlCur: ?*ITEMIDLIST,
    _psv: ?*IShellView,
    _psf: ?*IShellFolder,
    _hwndView: ?HWND,
    _pszTitleCur: ?PWSTR,
    _pidlPending: ?*ITEMIDLIST,
    _psvPending: ?*IShellView,
    _psfPending: ?*IShellFolder,
    _hwndViewPending: ?HWND,
    _pszTitlePending: ?PWSTR,
    _fIsViewMSHTML: BOOL,
    _fPrivacyImpacted: BOOL,
    _clsidView: Guid,
    _clsidViewPending: Guid,
    _hwndFrame: ?HWND,
    _lPhishingFilterStatus: i32,
};

pub const FOLDERSETDATA = extern struct {
    _fs: FOLDERSETTINGS,
    _vidRestore: Guid,
    _dwViewPriority: u32,
};

pub const TOOLBARITEM = extern struct {
    ptbar: ?*IDockingWindow,
    rcBorderTool: RECT,
    pwszItem: ?PWSTR,
    fShow: BOOL,
    hMon: ?HMONITOR,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBrowserService2_Value = @import("../zig.zig").Guid.initString("68bd21cc-438b-11d2-a560-00a0c92dbfe8");
pub const IID_IBrowserService2 = &IID_IBrowserService2_Value;
pub const IBrowserService2 = extern struct {
    pub const VTable = extern struct {
        base: IBrowserService.VTable,
        WndProcBS: fn(
            self: *const IBrowserService2,
            hwnd: ?HWND,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) LRESULT,
        SetAsDefFolderSettings: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewRect: fn(
            self: *const IBrowserService2,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSize: fn(
            self: *const IBrowserService2,
            wParam: WPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCreate: fn(
            self: *const IBrowserService2,
            pcs: ?*CREATESTRUCTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCommand: fn(
            self: *const IBrowserService2,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) LRESULT,
        OnDestroy: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnNotify: fn(
            self: *const IBrowserService2,
            pnm: ?*NMHDR,
        ) callconv(@import("std").os.windows.WINAPI) LRESULT,
        OnSetFocus: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFrameWindowActivateBS: fn(
            self: *const IBrowserService2,
            fActive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseShellView: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivatePendingView: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateViewWindow: fn(
            self: *const IBrowserService2,
            psvNew: ?*IShellView,
            psvOld: ?*IShellView,
            prcView: ?*RECT,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBrowserPropSheetExt: fn(
            self: *const IBrowserService2,
            riid: ?*const Guid,
            ppv: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetViewWindow: fn(
            self: *const IBrowserService2,
            phwndView: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBaseBrowserData: fn(
            self: *const IBrowserService2,
            pbbd: ?*?*BASEBROWSERDATALH,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutBaseBrowserData: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) ?*BASEBROWSERDATALH,
        InitializeTravelLog: fn(
            self: *const IBrowserService2,
            ptl: ?*ITravelLog,
            dw: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTopBrowser: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Offline: fn(
            self: *const IBrowserService2,
            iCmd: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllowViewResize: fn(
            self: *const IBrowserService2,
            f: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActivateState: fn(
            self: *const IBrowserService2,
            u: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateSecureLockIcon: fn(
            self: *const IBrowserService2,
            eSecureLock: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDownloadManager: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeTransitionSite: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _Initialize: fn(
            self: *const IBrowserService2,
            hwnd: ?HWND,
            pauto: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _CancelPendingNavigationAsync: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _CancelPendingView: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _MaySaveChanges: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _PauseOrResumeView: fn(
            self: *const IBrowserService2,
            fPaused: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _DisableModeless: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _NavigateToPidl2: fn(
            self: *const IBrowserService2,
            pidl: ?*ITEMIDLIST,
            grfHLNF: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _TryShell2Rename: fn(
            self: *const IBrowserService2,
            psv: ?*IShellView,
            pidlNew: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _SwitchActivationNow: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _ExecChildren: fn(
            self: *const IBrowserService2,
            punkBar: ?*IUnknown,
            fBroadcast: BOOL,
            pguidCmdGroup: ?*const Guid,
            nCmdID: u32,
            nCmdexecopt: u32,
            pvarargIn: ?*VARIANT,
            pvarargOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _SendChildren: fn(
            self: *const IBrowserService2,
            hwndBar: ?HWND,
            fBroadcast: BOOL,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFolderSetData: fn(
            self: *const IBrowserService2,
            pfsd: ?*FOLDERSETDATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _OnFocusChange: fn(
            self: *const IBrowserService2,
            itb: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        v_ShowHideChildWindows: fn(
            self: *const IBrowserService2,
            fChildOnly: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _get_itbLastFocus: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        _put_itbLastFocus: fn(
            self: *const IBrowserService2,
            itbLastFocus: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _UIActivateView: fn(
            self: *const IBrowserService2,
            uState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _GetViewBorderRect: fn(
            self: *const IBrowserService2,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _UpdateViewRectSize: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _ResizeNextBorder: fn(
            self: *const IBrowserService2,
            itb: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _ResizeView: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _GetEffectiveClientArea: fn(
            self: *const IBrowserService2,
            lprectBorder: ?*RECT,
            hmon: ?HMONITOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        v_GetViewStream: fn(
            self: *const IBrowserService2,
            pidl: ?*ITEMIDLIST,
            grfMode: u32,
            pwszName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) ?*IStream,
        ForwardViewMsg: fn(
            self: *const IBrowserService2,
            uMsg: u32,
            wParam: WPARAM,
            lParam: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) LRESULT,
        SetAcceleratorMenu: fn(
            self: *const IBrowserService2,
            hacc: ?HACCEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _GetToolbarCount: fn(
            self: *const IBrowserService2,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        _GetToolbarItem: fn(
            self: *const IBrowserService2,
            itb: i32,
        ) callconv(@import("std").os.windows.WINAPI) ?*TOOLBARITEM,
        _SaveToolbars: fn(
            self: *const IBrowserService2,
            pstm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _LoadToolbars: fn(
            self: *const IBrowserService2,
            pstm: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _CloseAndReleaseToolbars: fn(
            self: *const IBrowserService2,
            fClose: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        v_MayGetNextToolbarFocus: fn(
            self: *const IBrowserService2,
            lpMsg: ?*MSG,
            itbNext: u32,
            citb: i32,
            pptbi: ?*?*TOOLBARITEM,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _ResizeNextBorderHelper: fn(
            self: *const IBrowserService2,
            itb: u32,
            bUseHmonitor: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _FindTBar: fn(
            self: *const IBrowserService2,
            punkSrc: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        _SetFocus: fn(
            self: *const IBrowserService2,
            ptbi: ?*TOOLBARITEM,
            hwnd: ?HWND,
            lpMsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        v_MayTranslateAccelerator: fn(
            self: *const IBrowserService2,
            pmsg: ?*MSG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _GetBorderDWHelper: fn(
            self: *const IBrowserService2,
            punkSrc: ?*IUnknown,
            lprectBorder: ?*RECT,
            bUseHmonitor: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        v_CheckZoneCrossing: fn(
            self: *const IBrowserService2,
            pidl: ?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBrowserService.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_WndProcBS(self: *const T, hwnd: ?HWND, uMsg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) LRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).WndProcBS(@ptrCast(*const IBrowserService2, self), hwnd, uMsg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_SetAsDefFolderSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).SetAsDefFolderSettings(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_GetViewRect(self: *const T, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).GetViewRect(@ptrCast(*const IBrowserService2, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_OnSize(self: *const T, wParam: WPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).OnSize(@ptrCast(*const IBrowserService2, self), wParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_OnCreate(self: *const T, pcs: ?*CREATESTRUCTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).OnCreate(@ptrCast(*const IBrowserService2, self), pcs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_OnCommand(self: *const T, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) LRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).OnCommand(@ptrCast(*const IBrowserService2, self), wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_OnDestroy(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).OnDestroy(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_OnNotify(self: *const T, pnm: ?*NMHDR) callconv(.Inline) LRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).OnNotify(@ptrCast(*const IBrowserService2, self), pnm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_OnSetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).OnSetFocus(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_OnFrameWindowActivateBS(self: *const T, fActive: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).OnFrameWindowActivateBS(@ptrCast(*const IBrowserService2, self), fActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_ReleaseShellView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).ReleaseShellView(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_ActivatePendingView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).ActivatePendingView(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_CreateViewWindow(self: *const T, psvNew: ?*IShellView, psvOld: ?*IShellView, prcView: ?*RECT, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).CreateViewWindow(@ptrCast(*const IBrowserService2, self), psvNew, psvOld, prcView, phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_CreateBrowserPropSheetExt(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).CreateBrowserPropSheetExt(@ptrCast(*const IBrowserService2, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_GetViewWindow(self: *const T, phwndView: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).GetViewWindow(@ptrCast(*const IBrowserService2, self), phwndView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_GetBaseBrowserData(self: *const T, pbbd: ?*?*BASEBROWSERDATALH) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).GetBaseBrowserData(@ptrCast(*const IBrowserService2, self), pbbd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_PutBaseBrowserData(self: *const T) callconv(.Inline) ?*BASEBROWSERDATALH {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).PutBaseBrowserData(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_InitializeTravelLog(self: *const T, ptl: ?*ITravelLog, dw: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).InitializeTravelLog(@ptrCast(*const IBrowserService2, self), ptl, dw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_SetTopBrowser(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).SetTopBrowser(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_Offline(self: *const T, iCmd: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).Offline(@ptrCast(*const IBrowserService2, self), iCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_AllowViewResize(self: *const T, f: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).AllowViewResize(@ptrCast(*const IBrowserService2, self), f);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_SetActivateState(self: *const T, u: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).SetActivateState(@ptrCast(*const IBrowserService2, self), u);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_UpdateSecureLockIcon(self: *const T, eSecureLock: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).UpdateSecureLockIcon(@ptrCast(*const IBrowserService2, self), eSecureLock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_InitializeDownloadManager(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).InitializeDownloadManager(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_InitializeTransitionSite(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).InitializeTransitionSite(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__Initialize(self: *const T, hwnd: ?HWND, pauto: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._Initialize(@ptrCast(*const IBrowserService2, self), hwnd, pauto);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__CancelPendingNavigationAsync(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._CancelPendingNavigationAsync(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__CancelPendingView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._CancelPendingView(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__MaySaveChanges(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._MaySaveChanges(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__PauseOrResumeView(self: *const T, fPaused: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._PauseOrResumeView(@ptrCast(*const IBrowserService2, self), fPaused);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__DisableModeless(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._DisableModeless(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__NavigateToPidl2(self: *const T, pidl: ?*ITEMIDLIST, grfHLNF: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._NavigateToPidl2(@ptrCast(*const IBrowserService2, self), pidl, grfHLNF, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__TryShell2Rename(self: *const T, psv: ?*IShellView, pidlNew: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._TryShell2Rename(@ptrCast(*const IBrowserService2, self), psv, pidlNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__SwitchActivationNow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._SwitchActivationNow(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__ExecChildren(self: *const T, punkBar: ?*IUnknown, fBroadcast: BOOL, pguidCmdGroup: ?*const Guid, nCmdID: u32, nCmdexecopt: u32, pvarargIn: ?*VARIANT, pvarargOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._ExecChildren(@ptrCast(*const IBrowserService2, self), punkBar, fBroadcast, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__SendChildren(self: *const T, hwndBar: ?HWND, fBroadcast: BOOL, uMsg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._SendChildren(@ptrCast(*const IBrowserService2, self), hwndBar, fBroadcast, uMsg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_GetFolderSetData(self: *const T, pfsd: ?*FOLDERSETDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).GetFolderSetData(@ptrCast(*const IBrowserService2, self), pfsd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__OnFocusChange(self: *const T, itb: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._OnFocusChange(@ptrCast(*const IBrowserService2, self), itb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_v_ShowHideChildWindows(self: *const T, fChildOnly: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).v_ShowHideChildWindows(@ptrCast(*const IBrowserService2, self), fChildOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__get_itbLastFocus(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._get_itbLastFocus(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__put_itbLastFocus(self: *const T, itbLastFocus: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._put_itbLastFocus(@ptrCast(*const IBrowserService2, self), itbLastFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__UIActivateView(self: *const T, uState: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._UIActivateView(@ptrCast(*const IBrowserService2, self), uState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__GetViewBorderRect(self: *const T, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._GetViewBorderRect(@ptrCast(*const IBrowserService2, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__UpdateViewRectSize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._UpdateViewRectSize(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__ResizeNextBorder(self: *const T, itb: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._ResizeNextBorder(@ptrCast(*const IBrowserService2, self), itb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__ResizeView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._ResizeView(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__GetEffectiveClientArea(self: *const T, lprectBorder: ?*RECT, hmon: ?HMONITOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._GetEffectiveClientArea(@ptrCast(*const IBrowserService2, self), lprectBorder, hmon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_v_GetViewStream(self: *const T, pidl: ?*ITEMIDLIST, grfMode: u32, pwszName: ?[*:0]const u16) callconv(.Inline) ?*IStream {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).v_GetViewStream(@ptrCast(*const IBrowserService2, self), pidl, grfMode, pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_ForwardViewMsg(self: *const T, uMsg: u32, wParam: WPARAM, lParam: LPARAM) callconv(.Inline) LRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).ForwardViewMsg(@ptrCast(*const IBrowserService2, self), uMsg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_SetAcceleratorMenu(self: *const T, hacc: ?HACCEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).SetAcceleratorMenu(@ptrCast(*const IBrowserService2, self), hacc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__GetToolbarCount(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._GetToolbarCount(@ptrCast(*const IBrowserService2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__GetToolbarItem(self: *const T, itb: i32) callconv(.Inline) ?*TOOLBARITEM {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._GetToolbarItem(@ptrCast(*const IBrowserService2, self), itb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__SaveToolbars(self: *const T, pstm: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._SaveToolbars(@ptrCast(*const IBrowserService2, self), pstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__LoadToolbars(self: *const T, pstm: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._LoadToolbars(@ptrCast(*const IBrowserService2, self), pstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__CloseAndReleaseToolbars(self: *const T, fClose: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._CloseAndReleaseToolbars(@ptrCast(*const IBrowserService2, self), fClose);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_v_MayGetNextToolbarFocus(self: *const T, lpMsg: ?*MSG, itbNext: u32, citb: i32, pptbi: ?*?*TOOLBARITEM, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).v_MayGetNextToolbarFocus(@ptrCast(*const IBrowserService2, self), lpMsg, itbNext, citb, pptbi, phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__ResizeNextBorderHelper(self: *const T, itb: u32, bUseHmonitor: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._ResizeNextBorderHelper(@ptrCast(*const IBrowserService2, self), itb, bUseHmonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__FindTBar(self: *const T, punkSrc: ?*IUnknown) callconv(.Inline) u32 {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._FindTBar(@ptrCast(*const IBrowserService2, self), punkSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__SetFocus(self: *const T, ptbi: ?*TOOLBARITEM, hwnd: ?HWND, lpMsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._SetFocus(@ptrCast(*const IBrowserService2, self), ptbi, hwnd, lpMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_v_MayTranslateAccelerator(self: *const T, pmsg: ?*MSG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).v_MayTranslateAccelerator(@ptrCast(*const IBrowserService2, self), pmsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2__GetBorderDWHelper(self: *const T, punkSrc: ?*IUnknown, lprectBorder: ?*RECT, bUseHmonitor: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable)._GetBorderDWHelper(@ptrCast(*const IBrowserService2, self), punkSrc, lprectBorder, bUseHmonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService2_v_CheckZoneCrossing(self: *const T, pidl: ?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService2.VTable, self.vtable).v_CheckZoneCrossing(@ptrCast(*const IBrowserService2, self), pidl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IEPDNFLAGS = enum(i32) {
    I = 1,
};
pub const IEPDN_BINDINGUI = IEPDNFLAGS.I;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBrowserService3_Value = @import("../zig.zig").Guid.initString("27d7ce21-762d-48f3-86f3-40e2fd3749c4");
pub const IID_IBrowserService3 = &IID_IBrowserService3_Value;
pub const IBrowserService3 = extern struct {
    pub const VTable = extern struct {
        base: IBrowserService2.VTable,
        _PositionViewWindow: fn(
            self: *const IBrowserService3,
            hwnd: ?HWND,
            prc: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IEParseDisplayNameEx: fn(
            self: *const IBrowserService3,
            uiCP: u32,
            pwszPath: ?[*:0]const u16,
            dwFlags: u32,
            ppidlOut: ?*?*ITEMIDLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBrowserService2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService3__PositionViewWindow(self: *const T, hwnd: ?HWND, prc: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService3.VTable, self.vtable)._PositionViewWindow(@ptrCast(*const IBrowserService3, self), hwnd, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService3_IEParseDisplayNameEx(self: *const T, uiCP: u32, pwszPath: ?[*:0]const u16, dwFlags: u32, ppidlOut: ?*?*ITEMIDLIST) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService3.VTable, self.vtable).IEParseDisplayNameEx(@ptrCast(*const IBrowserService3, self), uiCP, pwszPath, dwFlags, ppidlOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBrowserService4_Value = @import("../zig.zig").Guid.initString("639f1bff-e135-4096-abd8-e0f504d649a4");
pub const IID_IBrowserService4 = &IID_IBrowserService4_Value;
pub const IBrowserService4 = extern struct {
    pub const VTable = extern struct {
        base: IBrowserService3.VTable,
        ActivateView: fn(
            self: *const IBrowserService4,
            fPendingView: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveViewState: fn(
            self: *const IBrowserService4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        _ResizeAllBorders: fn(
            self: *const IBrowserService4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBrowserService3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService4_ActivateView(self: *const T, fPendingView: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService4.VTable, self.vtable).ActivateView(@ptrCast(*const IBrowserService4, self), fPendingView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService4_SaveViewState(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService4.VTable, self.vtable).SaveViewState(@ptrCast(*const IBrowserService4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBrowserService4__ResizeAllBorders(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBrowserService4.VTable, self.vtable)._ResizeAllBorders(@ptrCast(*const IBrowserService4, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITrackShellMenu_Value = @import("../zig.zig").Guid.initString("8278f932-2a3e-11d2-838f-00c04fd918d0");
pub const IID_ITrackShellMenu = &IID_ITrackShellMenu_Value;
pub const ITrackShellMenu = extern struct {
    pub const VTable = extern struct {
        base: IShellMenu.VTable,
        SetObscured: fn(
            self: *const ITrackShellMenu,
            hwndTB: ?HWND,
            punkBand: ?*IUnknown,
            dwSMSetFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Popup: fn(
            self: *const ITrackShellMenu,
            hwnd: ?HWND,
            ppt: ?*POINTL,
            prcExclude: ?*RECTL,
            dwFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellMenu.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackShellMenu_SetObscured(self: *const T, hwndTB: ?HWND, punkBand: ?*IUnknown, dwSMSetFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrackShellMenu.VTable, self.vtable).SetObscured(@ptrCast(*const ITrackShellMenu, self), hwndTB, punkBand, dwSMSetFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackShellMenu_Popup(self: *const T, hwnd: ?HWND, ppt: ?*POINTL, prcExclude: ?*RECTL, dwFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrackShellMenu.VTable, self.vtable).Popup(@ptrCast(*const ITrackShellMenu, self), hwnd, ppt, prcExclude, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ImageTranscode_Value = @import("../zig.zig").Guid.initString("17b75166-928f-417d-9685-64aa135565c1");
pub const CLSID_ImageTranscode = &CLSID_ImageTranscode_Value;

pub const TI_FLAGS = enum(i32) {
    BITMAP = 1,
    JPEG = 2,
};
pub const TI_BITMAP = TI_FLAGS.BITMAP;
pub const TI_JPEG = TI_FLAGS.JPEG;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITranscodeImage_Value = @import("../zig.zig").Guid.initString("bae86ddd-dc11-421c-b7ab-cc55d1d65c44");
pub const IID_ITranscodeImage = &IID_ITranscodeImage_Value;
pub const ITranscodeImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TranscodeImage: fn(
            self: *const ITranscodeImage,
            pShellItem: ?*IShellItem,
            uiMaxWidth: u32,
            uiMaxHeight: u32,
            flags: u32,
            pvImage: ?*IStream,
            puiWidth: ?*u32,
            puiHeight: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITranscodeImage_TranscodeImage(self: *const T, pShellItem: ?*IShellItem, uiMaxWidth: u32, uiMaxHeight: u32, flags: u32, pvImage: ?*IStream, puiWidth: ?*u32, puiHeight: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITranscodeImage.VTable, self.vtable).TranscodeImage(@ptrCast(*const ITranscodeImage, self), pShellItem, uiMaxWidth, uiMaxHeight, flags, pvImage, puiWidth, puiHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PATHCCH_OPTIONS = enum(i32) {
    NONE = 0,
    ALLOW_LONG_PATHS = 1,
    FORCE_ENABLE_LONG_NAME_PROCESS = 2,
    FORCE_DISABLE_LONG_NAME_PROCESS = 4,
    DO_NOT_NORMALIZE_SEGMENTS = 8,
    ENSURE_IS_EXTENDED_LENGTH_PATH = 16,
    ENSURE_TRAILING_SLASH = 32,
    CANONICALIZE_SLASHES = 64,
};
pub const PATHCCH_NONE = PATHCCH_OPTIONS.NONE;
pub const PATHCCH_ALLOW_LONG_PATHS = PATHCCH_OPTIONS.ALLOW_LONG_PATHS;
pub const PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS = PATHCCH_OPTIONS.FORCE_ENABLE_LONG_NAME_PROCESS;
pub const PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS = PATHCCH_OPTIONS.FORCE_DISABLE_LONG_NAME_PROCESS;
pub const PATHCCH_DO_NOT_NORMALIZE_SEGMENTS = PATHCCH_OPTIONS.DO_NOT_NORMALIZE_SEGMENTS;
pub const PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH = PATHCCH_OPTIONS.ENSURE_IS_EXTENDED_LENGTH_PATH;
pub const PATHCCH_ENSURE_TRAILING_SLASH = PATHCCH_OPTIONS.ENSURE_TRAILING_SLASH;
pub const PATHCCH_CANONICALIZE_SLASHES = PATHCCH_OPTIONS.CANONICALIZE_SLASHES;

pub const APPLET_PROC = fn(
    hwndCpl: ?HWND,
    msg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CPLINFO = packed struct {
    idIcon: i32,
    idName: i32,
    idInfo: i32,
    lData: isize,
};

pub const NEWCPLINFOA = packed struct {
    dwSize: u32,
    dwFlags: u32,
    dwHelpContext: u32,
    lData: isize,
    hIcon: ?HICON,
    szName: [32]CHAR,
    szInfo: [64]CHAR,
    szHelpFile: [128]CHAR,
};

pub const NEWCPLINFOW = packed struct {
    dwSize: u32,
    dwFlags: u32,
    dwHelpContext: u32,
    lData: isize,
    hIcon: ?HICON,
    szName: [32]u16,
    szInfo: [64]u16,
    szHelpFile: [128]u16,
};

pub const PROFILEINFOA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    lpUserName: ?PSTR,
    lpProfilePath: ?PSTR,
    lpDefaultPath: ?PSTR,
    lpServerName: ?PSTR,
    lpPolicyPath: ?PSTR,
    hProfile: ?HANDLE,
};

pub const PROFILEINFOW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    lpUserName: ?PWSTR,
    lpProfilePath: ?PWSTR,
    lpDefaultPath: ?PWSTR,
    lpServerName: ?PWSTR,
    lpPolicyPath: ?PWSTR,
    hProfile: ?HANDLE,
};

pub const iurl_seturl_flags = enum(i32) {
    GUESS_PROTOCOL = 1,
    USE_DEFAULT_PROTOCOL = 2,
};
pub const IURL_SETURL_FL_GUESS_PROTOCOL = iurl_seturl_flags.GUESS_PROTOCOL;
pub const IURL_SETURL_FL_USE_DEFAULT_PROTOCOL = iurl_seturl_flags.USE_DEFAULT_PROTOCOL;

pub const iurl_invokecommand_flags = enum(i32) {
    ALLOW_UI = 1,
    USE_DEFAULT_VERB = 2,
    DDEWAIT = 4,
    ASYNCOK = 8,
    LOG_USAGE = 16,
};
pub const IURL_INVOKECOMMAND_FL_ALLOW_UI = iurl_invokecommand_flags.ALLOW_UI;
pub const IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB = iurl_invokecommand_flags.USE_DEFAULT_VERB;
pub const IURL_INVOKECOMMAND_FL_DDEWAIT = iurl_invokecommand_flags.DDEWAIT;
pub const IURL_INVOKECOMMAND_FL_ASYNCOK = iurl_invokecommand_flags.ASYNCOK;
pub const IURL_INVOKECOMMAND_FL_LOG_USAGE = iurl_invokecommand_flags.LOG_USAGE;

pub const urlinvokecommandinfoA = extern struct {
    dwcbSize: u32,
    dwFlags: u32,
    hwndParent: ?HWND,
    pcszVerb: ?[*:0]const u8,
};

pub const urlinvokecommandinfoW = extern struct {
    dwcbSize: u32,
    dwFlags: u32,
    hwndParent: ?HWND,
    pcszVerb: ?[*:0]const u16,
};

const IID_IUniformResourceLocatorA_Value = @import("../zig.zig").Guid.initString("fbf23b80-e3f0-101b-8488-00aa003e56f8");
pub const IID_IUniformResourceLocatorA = &IID_IUniformResourceLocatorA_Value;
pub const IUniformResourceLocatorA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetURL: fn(
            self: *const IUniformResourceLocatorA,
            pcszURL: ?[*:0]const u8,
            dwInFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: fn(
            self: *const IUniformResourceLocatorA,
            ppszURL: ?*?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeCommand: fn(
            self: *const IUniformResourceLocatorA,
            purlici: ?*urlinvokecommandinfoA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUniformResourceLocatorA_SetURL(self: *const T, pcszURL: ?[*:0]const u8, dwInFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUniformResourceLocatorA.VTable, self.vtable).SetURL(@ptrCast(*const IUniformResourceLocatorA, self), pcszURL, dwInFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUniformResourceLocatorA_GetURL(self: *const T, ppszURL: ?*?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUniformResourceLocatorA.VTable, self.vtable).GetURL(@ptrCast(*const IUniformResourceLocatorA, self), ppszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUniformResourceLocatorA_InvokeCommand(self: *const T, purlici: ?*urlinvokecommandinfoA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUniformResourceLocatorA.VTable, self.vtable).InvokeCommand(@ptrCast(*const IUniformResourceLocatorA, self), purlici);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUniformResourceLocatorW_Value = @import("../zig.zig").Guid.initString("cabb0da0-da57-11cf-9974-0020afd79762");
pub const IID_IUniformResourceLocatorW = &IID_IUniformResourceLocatorW_Value;
pub const IUniformResourceLocatorW = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetURL: fn(
            self: *const IUniformResourceLocatorW,
            pcszURL: ?[*:0]const u16,
            dwInFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: fn(
            self: *const IUniformResourceLocatorW,
            ppszURL: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeCommand: fn(
            self: *const IUniformResourceLocatorW,
            purlici: ?*urlinvokecommandinfoW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUniformResourceLocatorW_SetURL(self: *const T, pcszURL: ?[*:0]const u16, dwInFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUniformResourceLocatorW.VTable, self.vtable).SetURL(@ptrCast(*const IUniformResourceLocatorW, self), pcszURL, dwInFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUniformResourceLocatorW_GetURL(self: *const T, ppszURL: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUniformResourceLocatorW.VTable, self.vtable).GetURL(@ptrCast(*const IUniformResourceLocatorW, self), ppszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUniformResourceLocatorW_InvokeCommand(self: *const T, purlici: ?*urlinvokecommandinfoW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUniformResourceLocatorW.VTable, self.vtable).InvokeCommand(@ptrCast(*const IUniformResourceLocatorW, self), purlici);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const translateurl_in_flags = enum(i32) {
    GUESS_PROTOCOL = 1,
    USE_DEFAULT_PROTOCOL = 2,
};
pub const TRANSLATEURL_FL_GUESS_PROTOCOL = translateurl_in_flags.GUESS_PROTOCOL;
pub const TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL = translateurl_in_flags.USE_DEFAULT_PROTOCOL;

pub const urlassociationdialog_in_flags = enum(i32) {
    USE_DEFAULT_NAME = 1,
    REGISTER_ASSOC = 2,
};
pub const URLASSOCDLG_FL_USE_DEFAULT_NAME = urlassociationdialog_in_flags.USE_DEFAULT_NAME;
pub const URLASSOCDLG_FL_REGISTER_ASSOC = urlassociationdialog_in_flags.REGISTER_ASSOC;

pub const mimeassociationdialog_in_flags = enum(i32) {
    C = 1,
};
pub const MIMEASSOCDLG_FL_REGISTER_ASSOC = mimeassociationdialog_in_flags.C;

pub const PAPPSTATE_CHANGE_ROUTINE = fn(
    Quiesced: BOOLEAN,
    Context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PAPPCONSTRAIN_CHANGE_ROUTINE = fn(
    Constrained: BOOLEAN,
    Context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_ShowInputPaneAnimationCoordinator_Value = @import("../zig.zig").Guid.initString("1f046abf-3202-4dc1-8cb5-3c67617ce1fa");
pub const CLSID_ShowInputPaneAnimationCoordinator = &CLSID_ShowInputPaneAnimationCoordinator_Value;

const CLSID_HideInputPaneAnimationCoordinator_Value = @import("../zig.zig").Guid.initString("384742b1-2a77-4cb3-8cf8-1136f5e17e59");
pub const CLSID_HideInputPaneAnimationCoordinator = &CLSID_HideInputPaneAnimationCoordinator_Value;

const IID_IInputPaneAnimationCoordinator_Value = @import("../zig.zig").Guid.initString("2af16ba9-2de5-4b75-82d9-01372afbffb4");
pub const IID_IInputPaneAnimationCoordinator = &IID_IInputPaneAnimationCoordinator_Value;
pub const IInputPaneAnimationCoordinator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddAnimation: fn(
            self: *const IInputPaneAnimationCoordinator,
            device: ?*IUnknown,
            animation: ?*IDCompositionAnimation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInputPaneAnimationCoordinator_AddAnimation(self: *const T, device: ?*IUnknown, animation: ?*IDCompositionAnimation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInputPaneAnimationCoordinator.VTable, self.vtable).AddAnimation(@ptrCast(*const IInputPaneAnimationCoordinator, self), device, animation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};





















pub const DRAGINFOA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        uSize: u32,
        pt: POINT,
        fNC: BOOL,
        lpFileList: ?[*]u8,
        grfKeyState: u32,
    },
    .X86 => packed struct {
        uSize: u32,
        pt: POINT,
        fNC: BOOL,
        lpFileList: ?[*]u8,
        grfKeyState: u32,
    },
};
pub const DRAGINFOW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        uSize: u32,
        pt: POINT,
        fNC: BOOL,
        lpFileList: ?[*]u16,
        grfKeyState: u32,
    },
    .X86 => packed struct {
        uSize: u32,
        pt: POINT,
        fNC: BOOL,
        lpFileList: ?[*]u16,
        grfKeyState: u32,
    },
};
pub const APPBARDATA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hWnd: ?HWND,
        uCallbackMessage: u32,
        uEdge: u32,
        rc: RECT,
        lParam: LPARAM,
    },
    .X86 => packed struct {
        cbSize: u32,
        hWnd: ?HWND,
        uCallbackMessage: u32,
        uEdge: u32,
        rc: RECT,
        lParam: LPARAM,
    },
};
pub const SHFILEOPSTRUCTA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hwnd: ?HWND,
        wFunc: u32,
        pFrom: ?*i8,
        pTo: ?*i8,
        fFlags: u16,
        fAnyOperationsAborted: BOOL,
        hNameMappings: ?*anyopaque,
        lpszProgressTitle: ?[*:0]const u8,
    },
    .X86 => packed struct {
        hwnd: ?HWND,
        wFunc: u32,
        pFrom: ?*i8,
        pTo: ?*i8,
        fFlags: u16,
        fAnyOperationsAborted: BOOL,
        hNameMappings: ?*anyopaque,
        lpszProgressTitle: ?[*:0]const u8,
    },
};
pub const SHFILEOPSTRUCTW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hwnd: ?HWND,
        wFunc: u32,
        pFrom: ?[*]const u16,
        pTo: ?[*]const u16,
        fFlags: u16,
        fAnyOperationsAborted: BOOL,
        hNameMappings: ?*anyopaque,
        lpszProgressTitle: ?[*:0]const u16,
    },
    .X86 => packed struct {
        hwnd: ?HWND,
        wFunc: u32,
        pFrom: ?[*]const u16,
        pTo: ?[*]const u16,
        fFlags: u16,
        fAnyOperationsAborted: BOOL,
        hNameMappings: ?*anyopaque,
        lpszProgressTitle: ?[*:0]const u16,
    },
};
pub const SHNAMEMAPPINGA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pszOldPath: ?PSTR,
        pszNewPath: ?PSTR,
        cchOldPath: i32,
        cchNewPath: i32,
    },
    .X86 => packed struct {
        pszOldPath: ?PSTR,
        pszNewPath: ?PSTR,
        cchOldPath: i32,
        cchNewPath: i32,
    },
};
pub const SHNAMEMAPPINGW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        pszOldPath: ?PWSTR,
        pszNewPath: ?PWSTR,
        cchOldPath: i32,
        cchNewPath: i32,
    },
    .X86 => packed struct {
        pszOldPath: ?PWSTR,
        pszNewPath: ?PWSTR,
        cchOldPath: i32,
        cchNewPath: i32,
    },
};
pub const SHELLEXECUTEINFOA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        fMask: u32,
        hwnd: ?HWND,
        lpVerb: ?[*:0]const u8,
        lpFile: ?[*:0]const u8,
        lpParameters: ?[*:0]const u8,
        lpDirectory: ?[*:0]const u8,
        nShow: i32,
        hInstApp: ?HINSTANCE,
        lpIDList: ?*anyopaque,
        lpClass: ?[*:0]const u8,
        hkeyClass: ?HKEY,
        dwHotKey: u32,
        Anonymous: extern union {
            hIcon: ?HANDLE,
            hMonitor: ?HANDLE,
        },
        hProcess: ?HANDLE,
    },
    .X86 => packed struct {
        cbSize: u32,
        fMask: u32,
        hwnd: ?HWND,
        lpVerb: ?[*:0]const u8,
        lpFile: ?[*:0]const u8,
        lpParameters: ?[*:0]const u8,
        lpDirectory: ?[*:0]const u8,
        nShow: i32,
        hInstApp: ?HINSTANCE,
        lpIDList: ?*anyopaque,
        lpClass: ?[*:0]const u8,
        hkeyClass: ?HKEY,
        dwHotKey: u32,
        Anonymous: packed union {
            hIcon: ?HANDLE,
            hMonitor: ?HANDLE,
        },
        hProcess: ?HANDLE,
    },
};
pub const SHELLEXECUTEINFOW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        fMask: u32,
        hwnd: ?HWND,
        lpVerb: ?[*:0]const u16,
        lpFile: ?[*:0]const u16,
        lpParameters: ?[*:0]const u16,
        lpDirectory: ?[*:0]const u16,
        nShow: i32,
        hInstApp: ?HINSTANCE,
        lpIDList: ?*anyopaque,
        lpClass: ?[*:0]const u16,
        hkeyClass: ?HKEY,
        dwHotKey: u32,
        Anonymous: extern union {
            hIcon: ?HANDLE,
            hMonitor: ?HANDLE,
        },
        hProcess: ?HANDLE,
    },
    .X86 => packed struct {
        cbSize: u32,
        fMask: u32,
        hwnd: ?HWND,
        lpVerb: ?[*:0]const u16,
        lpFile: ?[*:0]const u16,
        lpParameters: ?[*:0]const u16,
        lpDirectory: ?[*:0]const u16,
        nShow: i32,
        hInstApp: ?HINSTANCE,
        lpIDList: ?*anyopaque,
        lpClass: ?[*:0]const u16,
        hkeyClass: ?HKEY,
        dwHotKey: u32,
        Anonymous: packed union {
            hIcon: ?HANDLE,
            hMonitor: ?HANDLE,
        },
        hProcess: ?HANDLE,
    },
};
pub const SHCREATEPROCESSINFOW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        fMask: u32,
        hwnd: ?HWND,
        pszFile: ?[*:0]const u16,
        pszParameters: ?[*:0]const u16,
        pszCurrentDirectory: ?[*:0]const u16,
        hUserToken: ?HANDLE,
        lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
        lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
        bInheritHandles: BOOL,
        dwCreationFlags: u32,
        lpStartupInfo: ?*STARTUPINFOW,
        lpProcessInformation: ?*PROCESS_INFORMATION,
    },
    .X86 => packed struct {
        cbSize: u32,
        fMask: u32,
        hwnd: ?HWND,
        pszFile: ?[*:0]const u16,
        pszParameters: ?[*:0]const u16,
        pszCurrentDirectory: ?[*:0]const u16,
        hUserToken: ?HANDLE,
        lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
        lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
        bInheritHandles: BOOL,
        dwCreationFlags: u32,
        lpStartupInfo: ?*STARTUPINFOW,
        lpProcessInformation: ?*PROCESS_INFORMATION,
    },
};
pub const ASSOCIATIONELEMENT = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        ac: ASSOCCLASS,
        hkClass: ?HKEY,
        pszClass: ?[*:0]const u16,
    },
    .X86 => packed struct {
        ac: ASSOCCLASS,
        hkClass: ?HKEY,
        pszClass: ?[*:0]const u16,
    },
};
pub const SHQUERYRBINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        i64Size: i64,
        i64NumItems: i64,
    },
    .X86 => packed struct {
        cbSize: u32,
        i64Size: i64,
        i64NumItems: i64,
    },
};
pub const NOTIFYICONDATAA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hWnd: ?HWND,
        uID: u32,
        uFlags: NOTIFY_ICON_DATA_FLAGS,
        uCallbackMessage: u32,
        hIcon: ?HICON,
        szTip: [128]CHAR,
        dwState: u32,
        dwStateMask: u32,
        szInfo: [256]CHAR,
        Anonymous: extern union {
            uTimeout: u32,
            uVersion: u32,
        },
        szInfoTitle: [64]CHAR,
        dwInfoFlags: u32,
        guidItem: Guid,
        hBalloonIcon: ?HICON,
    },
    .X86 => packed struct {
        cbSize: u32,
        hWnd: ?HWND,
        uID: u32,
        uFlags: NOTIFY_ICON_DATA_FLAGS,
        uCallbackMessage: u32,
        hIcon: ?HICON,
        szTip: [128]CHAR,
        dwState: u32,
        dwStateMask: u32,
        szInfo: [256]CHAR,
        Anonymous: packed union {
            uTimeout: u32,
            uVersion: u32,
        },
        szInfoTitle: [64]CHAR,
        dwInfoFlags: u32,
        guidItem: Guid,
        hBalloonIcon: ?HICON,
    },
};
pub const NOTIFYICONDATAW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hWnd: ?HWND,
        uID: u32,
        uFlags: NOTIFY_ICON_DATA_FLAGS,
        uCallbackMessage: u32,
        hIcon: ?HICON,
        szTip: [128]u16,
        dwState: u32,
        dwStateMask: u32,
        szInfo: [256]u16,
        Anonymous: extern union {
            uTimeout: u32,
            uVersion: u32,
        },
        szInfoTitle: [64]u16,
        dwInfoFlags: u32,
        guidItem: Guid,
        hBalloonIcon: ?HICON,
    },
    .X86 => packed struct {
        cbSize: u32,
        hWnd: ?HWND,
        uID: u32,
        uFlags: NOTIFY_ICON_DATA_FLAGS,
        uCallbackMessage: u32,
        hIcon: ?HICON,
        szTip: [128]u16,
        dwState: u32,
        dwStateMask: u32,
        szInfo: [256]u16,
        Anonymous: packed union {
            uTimeout: u32,
            uVersion: u32,
        },
        szInfoTitle: [64]u16,
        dwInfoFlags: u32,
        guidItem: Guid,
        hBalloonIcon: ?HICON,
    },
};
pub const NOTIFYICONIDENTIFIER = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hWnd: ?HWND,
        uID: u32,
        guidItem: Guid,
    },
    .X86 => packed struct {
        cbSize: u32,
        hWnd: ?HWND,
        uID: u32,
        guidItem: Guid,
    },
};
pub const SHFILEINFOA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hIcon: ?HICON,
        iIcon: i32,
        dwAttributes: u32,
        szDisplayName: [260]CHAR,
        szTypeName: [80]CHAR,
    },
    .X86 => packed struct {
        hIcon: ?HICON,
        iIcon: i32,
        dwAttributes: u32,
        szDisplayName: [260]CHAR,
        szTypeName: [80]CHAR,
    },
};
pub const SHFILEINFOW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        hIcon: ?HICON,
        iIcon: i32,
        dwAttributes: u32,
        szDisplayName: [260]u16,
        szTypeName: [80]u16,
    },
    .X86 => packed struct {
        hIcon: ?HICON,
        iIcon: i32,
        dwAttributes: u32,
        szDisplayName: [260]u16,
        szTypeName: [80]u16,
    },
};
pub const SHSTOCKICONINFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbSize: u32,
        hIcon: ?HICON,
        iSysImageIndex: i32,
        iIcon: i32,
        szPath: [260]u16,
    },
    .X86 => packed struct {
        cbSize: u32,
        hIcon: ?HICON,
        iSysImageIndex: i32,
        iIcon: i32,
        szPath: [260]u16,
    },
};
pub const OPEN_PRINTER_PROPS_INFOA = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwSize: u32,
        pszSheetName: ?PSTR,
        uSheetIndex: u32,
        dwFlags: u32,
        bModal: BOOL,
    },
    .X86 => packed struct {
        dwSize: u32,
        pszSheetName: ?PSTR,
        uSheetIndex: u32,
        dwFlags: u32,
        bModal: BOOL,
    },
};
pub const OPEN_PRINTER_PROPS_INFOW = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        dwSize: u32,
        pszSheetName: ?PWSTR,
        uSheetIndex: u32,
        dwFlags: u32,
        bModal: BOOL,
    },
    .X86 => packed struct {
        dwSize: u32,
        pszSheetName: ?PWSTR,
        uSheetIndex: u32,
        dwFlags: u32,
        bModal: BOOL,
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (688)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn LoadUserProfileA(
    hToken: ?HANDLE,
    lpProfileInfo: ?*PROFILEINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn LoadUserProfileW(
    hToken: ?HANDLE,
    lpProfileInfo: ?*PROFILEINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn UnloadUserProfile(
    hToken: ?HANDLE,
    hProfile: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn GetProfilesDirectoryA(
    lpProfileDir: ?[*:0]u8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn GetProfilesDirectoryW(
    lpProfileDir: ?[*:0]u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn GetProfileType(
    dwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn DeleteProfileA(
    lpSidString: ?[*:0]const u8,
    lpProfilePath: ?[*:0]const u8,
    lpComputerName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn DeleteProfileW(
    lpSidString: ?[*:0]const u16,
    lpProfilePath: ?[*:0]const u16,
    lpComputerName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "USERENV" fn CreateProfile(
    pszUserSid: ?[*:0]const u16,
    pszUserName: ?[*:0]const u16,
    pszProfilePath: [*:0]u16,
    cchProfilePath: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn GetDefaultUserProfileDirectoryA(
    lpProfileDir: ?[*:0]u8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn GetDefaultUserProfileDirectoryW(
    lpProfileDir: ?[*:0]u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn GetAllUsersProfileDirectoryA(
    lpProfileDir: ?[*:0]u8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn GetAllUsersProfileDirectoryW(
    lpProfileDir: ?[*:0]u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn GetUserProfileDirectoryA(
    hToken: ?HANDLE,
    lpProfileDir: ?[*:0]u8,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "USERENV" fn GetUserProfileDirectoryW(
    hToken: ?HANDLE,
    lpProfileDir: ?[*:0]u16,
    lpcchSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "COMCTL32" fn SetWindowSubclass(
    hWnd: ?HWND,
    pfnSubclass: ?SUBCLASSPROC,
    uIdSubclass: usize,
    dwRefData: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "COMCTL32" fn GetWindowSubclass(
    hWnd: ?HWND,
    pfnSubclass: ?SUBCLASSPROC,
    uIdSubclass: usize,
    pdwRefData: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "COMCTL32" fn RemoveWindowSubclass(
    hWnd: ?HWND,
    pfnSubclass: ?SUBCLASSPROC,
    uIdSubclass: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "COMCTL32" fn DefSubclassProc(
    hWnd: ?HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn SetWindowContextHelpId(
    param0: ?HWND,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn GetWindowContextHelpId(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn SetMenuContextHelpId(
    param0: ?HMENU,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn GetMenuContextHelpId(
    param0: ?HMENU,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn WinHelpA(
    hWndMain: ?HWND,
    lpszHelp: ?[*:0]const u8,
    uCommand: u32,
    dwData: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn WinHelpW(
    hWndMain: ?HWND,
    lpszHelp: ?[*:0]const u16,
    uCommand: u32,
    dwData: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHSimpleIDListFromPath(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateItemFromIDList(
    pidl: ?*ITEMIDLIST,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateItemFromParsingName(
    pszPath: ?[*:0]const u16,
    pbc: ?*IBindCtx,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateItemWithParent(
    pidlParent: ?*ITEMIDLIST,
    psfParent: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    riid: ?*const Guid,
    ppvItem: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateItemFromRelativeName(
    psiParent: ?*IShellItem,
    pszName: ?[*:0]const u16,
    pbc: ?*IBindCtx,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateItemInKnownFolder(
    kfid: ?*const Guid,
    dwKFFlags: u32,
    pszItem: ?[*:0]const u16,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHGetIDListFromObject(
    punk: ?*IUnknown,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn SHGetItemFromObject(
    punk: ?*IUnknown,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHGetNameFromIDList(
    pidl: ?*ITEMIDLIST,
    sigdnName: SIGDN,
    ppszName: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn SHGetItemFromDataObject(
    pdtobj: ?*IDataObject,
    dwFlags: DATAOBJ_GET_ITEM_FLAGS,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateShellItemArray(
    pidlParent: ?*ITEMIDLIST,
    psf: ?*IShellFolder,
    cidl: u32,
    ppidl: ?[*]?*ITEMIDLIST,
    ppsiItemArray: ?*?*IShellItemArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateShellItemArrayFromDataObject(
    pdo: ?*IDataObject,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateShellItemArrayFromIDLists(
    cidl: u32,
    rgpidl: [*]?*ITEMIDLIST,
    ppsiItemArray: ?*?*IShellItemArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateShellItemArrayFromShellItem(
    psi: ?*IShellItem,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateAssociationRegistration(
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateDefaultExtractIcon(
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn SetCurrentProcessExplicitAppUserModelID(
    AppID: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn GetCurrentProcessExplicitAppUserModelID(
    AppID: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHGetTemporaryPropertyForItem(
    psi: ?*IShellItem,
    propkey: ?*const PROPERTYKEY,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHSetTemporaryPropertyForItem(
    psi: ?*IShellItem,
    propkey: ?*const PROPERTYKEY,
    propvar: ?*const PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn SHShowManageLibraryUI(
    psiLibrary: ?*IShellItem,
    hwndOwner: ?HWND,
    pszTitle: ?[*:0]const u16,
    pszInstruction: ?[*:0]const u16,
    lmdOptions: LIBRARYMANAGEDIALOGOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn SHResolveLibrary(
    psiLibrary: ?*IShellItem,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHAssocEnumHandlers(
    pszExtra: ?[*:0]const u16,
    afFilter: ASSOC_FILTER,
    ppEnumHandler: ?*?*IEnumAssocHandlers,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn SHAssocEnumHandlersForProtocolByApplication(
    protocol: ?[*:0]const u16,
    riid: ?*const Guid,
    enumHandlers: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLE32" fn HMONITOR_UserSize(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HMONITOR_UserMarshal(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HMONITOR_UserUnmarshal(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HMONITOR_UserFree(
    param0: ?*u32,
    param1: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLE32" fn HMONITOR_UserSize64(
    param0: ?*u32,
    param1: u32,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLE32" fn HMONITOR_UserMarshal64(
    param0: ?*u32,
    param1: ?*u8,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HMONITOR_UserUnmarshal64(
    param0: ?*u32,
    param1: [*:0]u8,
    param2: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

pub extern "OLE32" fn HMONITOR_UserFree64(
    param0: ?*u32,
    param1: ?*?HMONITOR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateDefaultPropertiesOp(
    psi: ?*IShellItem,
    ppFileOp: ?*?*IFileOperation,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHSetDefaultProperties(
    hwnd: ?HWND,
    psi: ?*IShellItem,
    dwFileOpFlags: u32,
    pfops: ?*IFileOperationProgressSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetMalloc(
    ppMalloc: ?*?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHAlloc(
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHFree(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetIconOverlayIndexA(
    pszIconPath: ?[*:0]const u8,
    iIconIndex: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetIconOverlayIndexW(
    pszIconPath: ?[*:0]const u16,
    iIconIndex: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILClone(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILCloneFirst(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILCombine(
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILFree(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILGetNext(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILGetSize(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILFindChild(
    pidlParent: ?*ITEMIDLIST,
    pidlChild: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILFindLastID(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILRemoveLastID(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILIsEqual(
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILIsParent(
    pidl1: ?*ITEMIDLIST,
    pidl2: ?*ITEMIDLIST,
    fImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILSaveToStream(
    pstm: ?*IStream,
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn ILLoadFromStreamEx(
    pstm: ?*IStream,
    pidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILCreateFromPathA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILCreateFromPathW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHILCreateFromPath(
    pszPath: ?[*:0]const u16,
    ppidl: ?*?*ITEMIDLIST,
    rgfInOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ILAppendID(
    pidl: ?*ITEMIDLIST,
    pmkid: ?*SHITEMID,
    fAppend: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHGetPathFromIDListEx(
    pidl: ?*ITEMIDLIST,
    pszPath: [*:0]u16,
    cchPath: u32,
    uOpts: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetPathFromIDListA(
    pidl: ?*ITEMIDLIST,
    pszPath: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetPathFromIDListW(
    pidl: ?*ITEMIDLIST,
    pszPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHCreateDirectory(
    hwnd: ?HWND,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHCreateDirectoryExA(
    hwnd: ?HWND,
    pszPath: ?[*:0]const u8,
    psa: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHCreateDirectoryExW(
    hwnd: ?HWND,
    pszPath: ?[*:0]const u16,
    psa: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHOpenFolderAndSelectItems(
    pidlFolder: ?*ITEMIDLIST,
    cidl: u32,
    apidl: ?[*]?*ITEMIDLIST,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHCreateShellItem(
    pidlParent: ?*ITEMIDLIST,
    psfParent: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    ppsi: ?*?*IShellItem,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetSpecialFolderLocation(
    hwnd: ?HWND,
    csidl: i32,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHCloneSpecialIDList(
    hwnd: ?HWND,
    csidl: i32,
    fCreate: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetSpecialFolderPathA(
    hwnd: ?HWND,
    pszPath: *[260]u8,
    csidl: i32,
    fCreate: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetSpecialFolderPathW(
    hwnd: ?HWND,
    pszPath: *[260]u16,
    csidl: i32,
    fCreate: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHFlushSFCache(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetFolderPathA(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszPath: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetFolderPathW(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetFolderLocation(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHSetFolderPathA(
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHSetFolderPathW(
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetFolderPathAndSubDirA(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszSubDir: ?[*:0]const u8,
    pszPath: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetFolderPathAndSubDirW(
    hwnd: ?HWND,
    csidl: i32,
    hToken: ?HANDLE,
    dwFlags: u32,
    pszSubDir: ?[*:0]const u16,
    pszPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHGetKnownFolderIDList(
    rfid: ?*const Guid,
    dwFlags: u32,
    hToken: ?HANDLE,
    ppidl: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHSetKnownFolderPath(
    rfid: ?*const Guid,
    dwFlags: u32,
    hToken: ?HANDLE,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHGetKnownFolderPath(
    rfid: ?*const Guid,
    dwFlags: u32,
    hToken: ?HANDLE,
    ppszPath: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn SHGetKnownFolderItem(
    rfid: ?*const Guid,
    flags: KNOWN_FOLDER_FLAG,
    hToken: ?HANDLE,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetSetFolderCustomSettings(
    pfcs: ?*SHFOLDERCUSTOMSETTINGS,
    pszPath: ?[*:0]const u16,
    dwReadWrite: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHBrowseForFolderA(
    lpbi: ?*BROWSEINFOA,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHBrowseForFolderW(
    lpbi: ?*BROWSEINFOW,
) callconv(@import("std").os.windows.WINAPI) ?*ITEMIDLIST;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHLoadInProc(
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetDesktopFolder(
    ppshf: ?*?*IShellFolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHChangeNotify(
    wEventId: SHCNE_ID,
    uFlags: SHCNF_FLAGS,
    dwItem1: ?*const anyopaque,
    dwItem2: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHAddToRecentDocs(
    uFlags: u32,
    pv: ?*const anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHHandleUpdateImage(
    pidlExtra: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHUpdateImageA(
    pszHashItem: ?[*:0]const u8,
    iIndex: i32,
    uFlags: u32,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHUpdateImageW(
    pszHashItem: ?[*:0]const u16,
    iIndex: i32,
    uFlags: u32,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHChangeNotifyRegister(
    hwnd: ?HWND,
    fSources: SHCNRF_SOURCE,
    fEvents: i32,
    wMsg: u32,
    cEntries: i32,
    pshcne: ?*const SHChangeNotifyEntry,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHChangeNotifyDeregister(
    ulID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHChangeNotification_Lock(
    hChange: ?HANDLE,
    dwProcId: u32,
    pppidl: ?*?*?*ITEMIDLIST,
    plEvent: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ShFindChangeNotificationHandle;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHChangeNotification_Unlock(
    hLock: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetRealIDL(
    psf: ?*IShellFolder,
    pidlSimple: ?*ITEMIDLIST,
    ppidlReal: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetInstanceExplorer(
    ppunk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetDataFromIDListA(
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    nFormat: SHGDFIL_FORMAT,
    // TODO: what to do with BytesParamIndex 4?
    pv: ?*anyopaque,
    cb: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetDataFromIDListW(
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    nFormat: SHGDFIL_FORMAT,
    // TODO: what to do with BytesParamIndex 4?
    pv: ?*anyopaque,
    cb: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn RestartDialog(
    hwnd: ?HWND,
    pszPrompt: ?[*:0]const u16,
    dwReturn: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn RestartDialogEx(
    hwnd: ?HWND,
    pszPrompt: ?[*:0]const u16,
    dwReturn: u32,
    dwReasonCode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHCoCreateInstance(
    pszCLSID: ?[*:0]const u16,
    pclsid: ?*const Guid,
    pUnkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateDataObject(
    pidlFolder: ?*ITEMIDLIST,
    cidl: u32,
    apidl: ?[*]?*ITEMIDLIST,
    pdtInner: ?*IDataObject,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn CIDLData_CreateFromIDArray(
    pidlFolder: ?*ITEMIDLIST,
    cidl: u32,
    apidl: ?[*]?*ITEMIDLIST,
    ppdtobj: ?*?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHCreateStdEnumFmtEtc(
    cfmt: u32,
    afmt: [*]const FORMATETC,
    ppenumFormatEtc: ?*?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHDoDragDrop(
    hwnd: ?HWND,
    pdata: ?*IDataObject,
    pdsrc: ?*IDropSource,
    dwEffect: u32,
    pdwEffect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn DAD_SetDragImage(
    him: ?HIMAGELIST,
    pptOffset: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn DAD_DragEnterEx(
    hwndTarget: ?HWND,
    ptStart: POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn DAD_DragEnterEx2(
    hwndTarget: ?HWND,
    ptStart: POINT,
    pdtObject: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn DAD_ShowDragImage(
    fShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn DAD_DragMove(
    pt: POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn DAD_DragLeave(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn DAD_AutoScroll(
    hwnd: ?HWND,
    pad: ?*AUTO_SCROLL_DATA,
    pptNow: ?*const POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ReadCabinetState(
    // TODO: what to do with BytesParamIndex 1?
    pcs: ?*CABINETSTATE,
    cLength: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn WriteCabinetState(
    pcs: ?*CABINETSTATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn PathMakeUniqueName(
    pszUniqueName: [*:0]u16,
    cchMax: u32,
    pszTemplate: ?[*:0]const u16,
    pszLongPlate: ?[*:0]const u16,
    pszDir: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn PathIsExe(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn PathCleanupSpec(
    pszDir: ?[*:0]const u16,
    pszSpec: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) PCS_RET;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn PathResolve(
    pszPath: *[260]u16,
    dirs: ?*?*u16,
    fFlags: PRF_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn GetFileNameFromBrowse(
    hwnd: ?HWND,
    pszFilePath: [*:0]u16,
    cchFilePath: u32,
    pszWorkingDir: ?[*:0]const u16,
    pszDefExt: ?[*:0]const u16,
    pszFilters: ?[*:0]const u16,
    pszTitle: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn DriveType(
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn RealDriveType(
    iDrive: i32,
    fOKToHitNet: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn IsNetDrive(
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn Shell_MergeMenus(
    hmDst: ?HMENU,
    hmSrc: ?HMENU,
    uInsert: u32,
    uIDAdjust: u32,
    uIDAdjustMax: u32,
    uFlags: MM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHObjectProperties(
    hwnd: ?HWND,
    shopObjectType: SHOP_TYPE,
    pszObjectName: ?[*:0]const u16,
    pszPropertyPage: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHFormatDrive(
    hwnd: ?HWND,
    drive: u32,
    fmtID: SHFMT_ID,
    options: SHFMT_OPT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHDestroyPropSheetExtArray(
    hpsxa: ?HPSXA,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHAddFromPropSheetExtArray(
    hpsxa: ?HPSXA,
    lpfnAddPage: ?LPFNSVADDPROPSHEETPAGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHReplaceFromPropSheetExtArray(
    hpsxa: ?HPSXA,
    uPageID: u32,
    lpfnReplaceWith: ?LPFNSVADDPROPSHEETPAGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn OpenRegStream(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHFindFiles(
    pidlFolder: ?*ITEMIDLIST,
    pidlSaveFile: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn PathGetShortPath(
    pszLongPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn PathYetAnotherMakeUniqueName(
    pszUniqueName: *[260]u16,
    pszPath: ?[*:0]const u16,
    pszShort: ?[*:0]const u16,
    pszFileSpec: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn Win32DeleteFile(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHRestricted(
    rest: RESTRICTIONS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SignalFileOpen(
    pidl: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn AssocGetDetailsOfPropKey(
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    pkey: ?*const PROPERTYKEY,
    pv: ?*VARIANT,
    pfFoundPropKey: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHStartNetConnectionDialogW(
    hwnd: ?HWND,
    pszRemoteName: ?[*:0]const u16,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHDefExtractIconA(
    pszIconFile: ?[*:0]const u8,
    iIndex: i32,
    uFlags: u32,
    phiconLarge: ?*?HICON,
    phiconSmall: ?*?HICON,
    nIconSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHDefExtractIconW(
    pszIconFile: ?[*:0]const u16,
    iIndex: i32,
    uFlags: u32,
    phiconLarge: ?*?HICON,
    phiconSmall: ?*?HICON,
    nIconSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHOpenWithDialog(
    hwndParent: ?HWND,
    poainfo: ?*const OPENASINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn Shell_GetImageLists(
    phiml: ?*?HIMAGELIST,
    phimlSmall: ?*?HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn Shell_GetCachedImageIndex(
    pwszIconPath: ?[*:0]const u16,
    iIconIndex: i32,
    uIconFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn Shell_GetCachedImageIndexA(
    pszIconPath: ?[*:0]const u8,
    iIconIndex: i32,
    uIconFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn Shell_GetCachedImageIndexW(
    pszIconPath: ?[*:0]const u16,
    iIconIndex: i32,
    uIconFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHValidateUNC(
    hwndOwner: ?HWND,
    pszFile: ?PWSTR,
    fConnect: VALIDATEUNC_OPTION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHSetInstanceExplorer(
    punk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn IsUserAnAdmin(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHShellFolderView_Message(
    hwndMain: ?HWND,
    uMsg: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHCreateShellFolderView(
    pcsfv: ?*const SFV_CREATE,
    ppsv: ?*?*IShellView,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn CDefFolderMenu_Create2(
    pidlFolder: ?*ITEMIDLIST,
    hwnd: ?HWND,
    cidl: u32,
    apidl: ?[*]?*ITEMIDLIST,
    psf: ?*IShellFolder,
    pfn: ?LPFNDFMCALLBACK,
    nKeys: u32,
    ahkeys: ?[*]const ?HKEY,
    ppcm: ?*?*IContextMenu,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHCreateDefaultContextMenu(
    pdcm: ?*const DEFCONTEXTMENU,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHFind_InitMenuPopup(
    hmenu: ?HMENU,
    hwndOwner: ?HWND,
    idCmdFirst: u32,
    idCmdLast: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IContextMenu;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHCreateShellFolderViewEx(
    pcsfv: ?*CSFV,
    ppsv: ?*?*IShellView,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetSetSettings(
    lpss: ?*SHELLSTATEA,
    dwMask: SSF_MASK,
    bSet: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetSettings(
    psfs: ?*SHELLFLAGSTATE,
    dwMask: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHBindToParent(
    pidl: ?*ITEMIDLIST,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
    ppidlLast: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHBindToFolderIDListParent(
    psfRoot: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
    ppidlLast: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHBindToFolderIDListParentEx(
    psfRoot: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    ppbc: ?*IBindCtx,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
    ppidlLast: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHBindToObject(
    psf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    pbc: ?*IBindCtx,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHParseDisplayName(
    pszName: ?[*:0]const u16,
    pbc: ?*IBindCtx,
    ppidl: ?*?*ITEMIDLIST,
    sfgaoIn: u32,
    psfgaoOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHPathPrepareForWriteA(
    hwnd: ?HWND,
    punkEnableModless: ?*IUnknown,
    pszPath: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHPathPrepareForWriteW(
    hwnd: ?HWND,
    punkEnableModless: ?*IUnknown,
    pszPath: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHCreateFileExtractIconW(
    pszFile: ?[*:0]const u16,
    dwFileAttributes: u32,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHLimitInputEdit(
    hwndEdit: ?HWND,
    psf: ?*IShellFolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetAttributesFromDataObject(
    pdo: ?*IDataObject,
    dwAttributeMask: u32,
    pdwAttributes: ?*u32,
    pcItems: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHMapPIDLToSystemImageListIndex(
    pshf: ?*IShellFolder,
    pidl: ?*ITEMIDLIST,
    piIndexSel: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHCLSIDFromString(
    psz: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn PickIconDlg(
    hwnd: ?HWND,
    pszIconPath: [*:0]u16,
    cchIconPath: u32,
    piIconIndex: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn StgMakeUniqueName(
    pstgParent: ?*IStorage,
    pszFileSpec: ?[*:0]const u16,
    grfMode: u32,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHChangeNotifyRegisterThread(
    status: SCNRT_STATUS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "SHELL32" fn PathQualify(
    psz: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn PathIsSlowA(
    pszFile: ?[*:0]const u8,
    dwAttr: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn PathIsSlowW(
    pszFile: ?[*:0]const u16,
    dwAttr: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHCreatePropSheetExtArray(
    hKey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    max_iface: u32,
) callconv(@import("std").os.windows.WINAPI) ?HPSXA;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHOpenPropSheetW(
    pszCaption: ?[*:0]const u16,
    ahkeys: ?[*]?HKEY,
    ckeys: u32,
    pclsidDefault: ?*const Guid,
    pdtobj: ?*IDataObject,
    psb: ?*IShellBrowser,
    pStartPage: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHDOCVW" fn SoftwareUpdateMessageBox(
    hWnd: ?HWND,
    pszDistUnit: ?[*:0]const u16,
    dwFlags: u32,
    psdi: ?*SOFTDISTINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHMultiFileProperties(
    pdtobj: ?*IDataObject,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHCreateQueryCancelAutoPlayMoniker(
    ppmoniker: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "SHDOCVW" fn ImportPrivacySettings(
    pszFilename: ?[*:0]const u16,
    pfParsePrivacyPreferences: ?*BOOL,
    pfParsePerSiteRules: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-scaling-l1-1-0" fn GetScaleFactorForDevice(
    deviceType: DISPLAY_DEVICE_TYPE,
) callconv(@import("std").os.windows.WINAPI) DEVICE_SCALE_FACTOR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-scaling-l1-1-0" fn RegisterScaleChangeNotifications(
    displayDevice: DISPLAY_DEVICE_TYPE,
    hwndNotify: ?HWND,
    uMsgNotify: u32,
    pdwCookie: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-shcore-scaling-l1-1-0" fn RevokeScaleChangeNotifications(
    displayDevice: DISPLAY_DEVICE_TYPE,
    dwCookie: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-shcore-scaling-l1-1-1" fn GetScaleFactorForMonitor(
    hMon: ?HMONITOR,
    pScale: ?*DEVICE_SCALE_FACTOR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-shcore-scaling-l1-1-1" fn RegisterScaleChangeEvent(
    hEvent: ?HANDLE,
    pdwCookie: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-shcore-scaling-l1-1-1" fn UnregisterScaleChangeEvent(
    dwCookie: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "api-ms-win-shcore-scaling-l1-1-2" fn GetDpiForShellUIComponent(
    param0: SHELL_UI_COMPONENT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn CommandLineToArgvW(
    lpCmdLine: ?[*:0]const u16,
    pNumArgs: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*?PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn DragQueryFileA(
    hDrop: ?HDROP,
    iFile: u32,
    lpszFile: ?[*:0]u8,
    cch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn DragQueryFileW(
    hDrop: ?HDROP,
    iFile: u32,
    lpszFile: ?[*:0]u16,
    cch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn DragQueryPoint(
    hDrop: ?HDROP,
    ppt: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn DragFinish(
    hDrop: ?HDROP,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn DragAcceptFiles(
    hWnd: ?HWND,
    fAccept: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ShellExecuteA(
    hwnd: ?HWND,
    lpOperation: ?[*:0]const u8,
    lpFile: ?[*:0]const u8,
    lpParameters: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    nShowCmd: i32,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ShellExecuteW(
    hwnd: ?HWND,
    lpOperation: ?[*:0]const u16,
    lpFile: ?[*:0]const u16,
    lpParameters: ?[*:0]const u16,
    lpDirectory: ?[*:0]const u16,
    nShowCmd: i32,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn FindExecutableA(
    lpFile: ?[*:0]const u8,
    lpDirectory: ?[*:0]const u8,
    lpResult: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn FindExecutableW(
    lpFile: ?[*:0]const u16,
    lpDirectory: ?[*:0]const u16,
    lpResult: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ShellAboutA(
    hWnd: ?HWND,
    szApp: ?[*:0]const u8,
    szOtherStuff: ?[*:0]const u8,
    hIcon: ?HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ShellAboutW(
    hWnd: ?HWND,
    szApp: ?[*:0]const u16,
    szOtherStuff: ?[*:0]const u16,
    hIcon: ?HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn DuplicateIcon(
    hInst: ?HINSTANCE,
    hIcon: ?HICON,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ExtractAssociatedIconA(
    hInst: ?HINSTANCE,
    pszIconPath: *[128]u8,
    piIcon: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ExtractAssociatedIconW(
    hInst: ?HINSTANCE,
    pszIconPath: *[128]u16,
    piIcon: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ExtractAssociatedIconExA(
    hInst: ?HINSTANCE,
    pszIconPath: *[128]u8,
    piIconIndex: ?*u16,
    piIconId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ExtractAssociatedIconExW(
    hInst: ?HINSTANCE,
    pszIconPath: *[128]u16,
    piIconIndex: ?*u16,
    piIconId: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ExtractIconA(
    hInst: ?HINSTANCE,
    pszExeFileName: ?[*:0]const u8,
    nIconIndex: u32,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ExtractIconW(
    hInst: ?HINSTANCE,
    pszExeFileName: ?[*:0]const u16,
    nIconIndex: u32,
) callconv(@import("std").os.windows.WINAPI) ?HICON;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHAppBarMessage(
    dwMessage: u32,
    pData: ?*APPBARDATA,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn DoEnvironmentSubstA(
    pszSrc: [*:0]u8,
    cchSrc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn DoEnvironmentSubstW(
    pszSrc: [*:0]u16,
    cchSrc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ExtractIconExA(
    lpszFile: ?[*:0]const u8,
    nIconIndex: i32,
    phiconLarge: ?[*]?HICON,
    phiconSmall: ?[*]?HICON,
    nIcons: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ExtractIconExW(
    lpszFile: ?[*:0]const u16,
    nIconIndex: i32,
    phiconLarge: ?[*]?HICON,
    phiconSmall: ?[*]?HICON,
    nIcons: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHFileOperationA(
    lpFileOp: ?*SHFILEOPSTRUCTA,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHFileOperationW(
    lpFileOp: ?*SHFILEOPSTRUCTW,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHFreeNameMappings(
    hNameMappings: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ShellExecuteExA(
    pExecInfo: ?*SHELLEXECUTEINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn ShellExecuteExW(
    pExecInfo: ?*SHELLEXECUTEINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHCreateProcessAsUserW(
    pscpi: ?*SHCREATEPROCESSINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHEvaluateSystemCommandTemplate(
    pszCmdTemplate: ?[*:0]const u16,
    ppszApplication: ?*?PWSTR,
    ppszCommandLine: ?*?PWSTR,
    ppszParameters: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn AssocCreateForClasses(
    rgClasses: [*]const ASSOCIATIONELEMENT,
    cClasses: u32,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHQueryRecycleBinA(
    pszRootPath: ?[*:0]const u8,
    pSHQueryRBInfo: ?*SHQUERYRBINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHQueryRecycleBinW(
    pszRootPath: ?[*:0]const u16,
    pSHQueryRBInfo: ?*SHQUERYRBINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHEmptyRecycleBinA(
    hwnd: ?HWND,
    pszRootPath: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHEmptyRecycleBinW(
    hwnd: ?HWND,
    pszRootPath: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHQueryUserNotificationState(
    pquns: ?*QUERY_USER_NOTIFICATION_STATE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn Shell_NotifyIconA(
    dwMessage: NOTIFY_ICON_MESSAGE,
    lpData: ?*NOTIFYICONDATAA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn Shell_NotifyIconW(
    dwMessage: NOTIFY_ICON_MESSAGE,
    lpData: ?*NOTIFYICONDATAW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHELL32" fn Shell_NotifyIconGetRect(
    identifier: ?*const NOTIFYICONIDENTIFIER,
    iconLocation: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetFileInfoA(
    pszPath: ?[*:0]const u8,
    dwFileAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    // TODO: what to do with BytesParamIndex 3?
    psfi: ?*SHFILEINFOA,
    cbFileInfo: u32,
    uFlags: SHGFI_FLAGS,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetFileInfoW(
    pszPath: ?[*:0]const u16,
    dwFileAttributes: FILE_FLAGS_AND_ATTRIBUTES,
    // TODO: what to do with BytesParamIndex 3?
    psfi: ?*SHFILEINFOW,
    cbFileInfo: u32,
    uFlags: SHGFI_FLAGS,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHGetStockIconInfo(
    siid: SHSTOCKICONID,
    uFlags: u32,
    psii: ?*SHSTOCKICONINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetDiskFreeSpaceExA(
    pszDirectoryName: ?[*:0]const u8,
    pulFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    pulTotalNumberOfBytes: ?*ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetDiskFreeSpaceExW(
    pszDirectoryName: ?[*:0]const u16,
    pulFreeBytesAvailableToCaller: ?*ULARGE_INTEGER,
    pulTotalNumberOfBytes: ?*ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetNewLinkInfoA(
    pszLinkTo: ?[*:0]const u8,
    pszDir: ?[*:0]const u8,
    pszName: *[260]u8,
    pfMustCopy: ?*BOOL,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHGetNewLinkInfoW(
    pszLinkTo: ?[*:0]const u16,
    pszDir: ?[*:0]const u16,
    pszName: *[260]u16,
    pfMustCopy: ?*BOOL,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHInvokePrinterCommandA(
    hwnd: ?HWND,
    uAction: u32,
    lpBuf1: ?[*:0]const u8,
    lpBuf2: ?[*:0]const u8,
    fModal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHInvokePrinterCommandW(
    hwnd: ?HWND,
    uAction: u32,
    lpBuf1: ?[*:0]const u16,
    lpBuf2: ?[*:0]const u16,
    fModal: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHLoadNonloadedIconOverlayIdentifiers(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHELL32" fn SHIsFileAvailableOffline(
    pwszPath: ?[*:0]const u16,
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHSetLocalizedName(
    pszPath: ?[*:0]const u16,
    pszResModule: ?[*:0]const u16,
    idsRes: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHRemoveLocalizedName(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHGetLocalizedName(
    pszPath: ?[*:0]const u16,
    pszResModule: [*:0]u16,
    cch: u32,
    pidsRes: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn ShellMessageBoxA(
    hAppInst: ?HINSTANCE,
    hWnd: ?HWND,
    lpcText: ?[*:0]const u8,
    lpcTitle: ?[*:0]const u8,
    fuStyle: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn ShellMessageBoxW(
    hAppInst: ?HINSTANCE,
    hWnd: ?HWND,
    lpcText: ?[*:0]const u16,
    lpcTitle: ?[*:0]const u16,
    fuStyle: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "SHELL32" fn IsLFNDriveA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SHELL32" fn IsLFNDriveW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHEnumerateUnreadMailAccountsW(
    hKeyUser: ?HKEY,
    dwIndex: u32,
    pszMailAddress: [*:0]u16,
    cchMailAddress: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetUnreadMailCountW(
    hKeyUser: ?HKEY,
    pszMailAddress: ?[*:0]const u16,
    pdwCount: ?*u32,
    pFileTime: ?*FILETIME,
    pszShellExecuteCommand: ?[*:0]u16,
    cchShellExecuteCommand: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHSetUnreadMailCountW(
    pszMailAddress: ?[*:0]const u16,
    dwCount: u32,
    pszShellExecuteCommand: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHTestTokenMembership(
    hToken: ?HANDLE,
    ulRID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHELL32" fn SHGetImageList(
    iImageList: i32,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn InitNetworkAddressControl(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHELL32" fn SHGetDriveMedia(
    pszDrive: ?[*:0]const u16,
    pdwMediaContent: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrChrA(
    pszStart: ?[*:0]const u8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrChrW(
    pszStart: ?[*:0]const u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrChrIA(
    pszStart: ?[*:0]const u8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrChrIW(
    pszStart: ?[*:0]const u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn StrChrNW(
    pszStart: ?[*:0]const u16,
    wMatch: u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn StrChrNIW(
    pszStart: ?[*:0]const u16,
    wMatch: u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpNA(
    psz1: ?[*:0]const u8,
    psz2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpNW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpNIA(
    psz1: ?[*:0]const u8,
    psz2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpNIW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCSpnA(
    pszStr: ?[*:0]const u8,
    pszSet: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCSpnW(
    pszStr: ?[*:0]const u16,
    pszSet: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCSpnIA(
    pszStr: ?[*:0]const u8,
    pszSet: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCSpnIW(
    pszStr: ?[*:0]const u16,
    pszSet: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrDupA(
    pszSrch: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrDupW(
    pszSrch: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn StrFormatByteSizeEx(
    ull: u64,
    flags: SFBS_FLAGS,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrFormatByteSizeA(
    dw: u32,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrFormatByteSize64A(
    qdw: i64,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrFormatByteSizeW(
    qdw: i64,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrFormatKBSizeW(
    qdw: i64,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrFormatKBSizeA(
    qdw: i64,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrFromTimeIntervalA(
    pszOut: [*:0]u8,
    cchMax: u32,
    dwTimeMS: u32,
    digits: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrFromTimeIntervalW(
    pszOut: [*:0]u16,
    cchMax: u32,
    dwTimeMS: u32,
    digits: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrIsIntlEqualA(
    fCaseSens: BOOL,
    pszString1: ?[*:0]const u8,
    pszString2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrIsIntlEqualW(
    fCaseSens: BOOL,
    pszString1: ?[*:0]const u16,
    pszString2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrNCatA(
    psz1: [*:0]u8,
    psz2: ?[*:0]const u8,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrNCatW(
    psz1: [*:0]u16,
    psz2: ?[*:0]const u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrPBrkA(
    psz: ?[*:0]const u8,
    pszSet: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrPBrkW(
    psz: ?[*:0]const u16,
    pszSet: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRChrA(
    pszStart: ?[*:0]const u8,
    pszEnd: ?[*:0]const u8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRChrW(
    pszStart: ?[*:0]const u16,
    pszEnd: ?[*:0]const u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRChrIA(
    pszStart: ?[*:0]const u8,
    pszEnd: ?[*:0]const u8,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRChrIW(
    pszStart: ?[*:0]const u16,
    pszEnd: ?[*:0]const u16,
    wMatch: u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRStrIA(
    pszSource: ?[*:0]const u8,
    pszLast: ?[*:0]const u8,
    pszSrch: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRStrIW(
    pszSource: ?[*:0]const u16,
    pszLast: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrSpnA(
    psz: ?[*:0]const u8,
    pszSet: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrSpnW(
    psz: ?[*:0]const u16,
    pszSet: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrStrA(
    pszFirst: ?[*:0]const u8,
    pszSrch: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrStrW(
    pszFirst: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrStrIA(
    pszFirst: ?[*:0]const u8,
    pszSrch: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrStrIW(
    pszFirst: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn StrStrNW(
    pszFirst: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn StrStrNIW(
    pszFirst: ?[*:0]const u16,
    pszSrch: ?[*:0]const u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrToIntA(
    pszSrc: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrToIntW(
    pszSrc: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrToIntExA(
    pszString: ?[*:0]const u8,
    dwFlags: i32,
    piRet: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrToIntExW(
    pszString: ?[*:0]const u16,
    dwFlags: i32,
    piRet: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrToInt64ExA(
    pszString: ?[*:0]const u8,
    dwFlags: i32,
    pllRet: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrToInt64ExW(
    pszString: ?[*:0]const u16,
    dwFlags: i32,
    pllRet: ?*i64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrTrimA(
    psz: ?PSTR,
    pszTrimChars: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrTrimW(
    psz: ?PWSTR,
    pszTrimChars: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCatW(
    psz1: ?PWSTR,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpIW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCpyW(
    psz1: ?PWSTR,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCpyNW(
    pszDst: [*:0]u16,
    pszSrc: ?[*:0]const u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCatBuffW(
    pszDest: [*:0]u16,
    pszSrc: ?[*:0]const u16,
    cchDestBuffSize: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCatBuffA(
    pszDest: [*:0]u8,
    pszSrc: ?[*:0]const u8,
    cchDestBuffSize: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn ChrCmpIA(
    w1: u16,
    w2: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn ChrCmpIW(
    w1: u16,
    w2: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn wvnsprintfA(
    pszDest: [*:0]u8,
    cchDest: i32,
    pszFmt: ?[*:0]const u8,
    arglist: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn wvnsprintfW(
    pszDest: [*:0]u16,
    cchDest: i32,
    pszFmt: ?[*:0]const u16,
    arglist: ?*i8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn wnsprintfA(
    pszDest: [*:0]u8,
    cchDest: i32,
    pszFmt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn wnsprintfW(
    pszDest: [*:0]u16,
    cchDest: i32,
    pszFmt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRetToStrA(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    ppsz: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRetToStrW(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    ppsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRetToBufA(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrRetToBufW(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHStrDupA(
    psz: ?[*:0]const u8,
    ppwsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHStrDupW(
    psz: ?[*:0]const u16,
    ppwsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn StrCmpLogicalW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn StrCatChainW(
    pszDst: [*:0]u16,
    cchDst: u32,
    ichAt: u32,
    pszSrc: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn StrRetToBSTR(
    pstr: ?*STRRET,
    pidl: ?*ITEMIDLIST,
    pbstr: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHLoadIndirectString(
    pszSource: ?[*:0]const u16,
    pszOutBuf: [*:0]u16,
    cchOutBuf: u32,
    ppvReserved: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IsCharSpaceA(
    wch: CHAR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IsCharSpaceW(
    wch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpCA(
    pszStr1: ?[*:0]const u8,
    pszStr2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpCW(
    pszStr1: ?[*:0]const u16,
    pszStr2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpICA(
    pszStr1: ?[*:0]const u8,
    pszStr2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpICW(
    pszStr1: ?[*:0]const u16,
    pszStr2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpNCA(
    pszStr1: ?[*:0]const u8,
    pszStr2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpNCW(
    pszStr1: ?[*:0]const u16,
    pszStr2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpNICA(
    pszStr1: ?[*:0]const u8,
    pszStr2: ?[*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn StrCmpNICW(
    pszStr1: ?[*:0]const u16,
    pszStr2: ?[*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IntlStrEqWorkerA(
    fCaseSens: BOOL,
    lpString1: [*:0]const u8,
    lpString2: [*:0]const u8,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IntlStrEqWorkerW(
    fCaseSens: BOOL,
    lpString1: [*:0]const u16,
    lpString2: [*:0]const u16,
    nChar: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathAddBackslashA(
    pszPath: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathAddBackslashW(
    pszPath: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathAddExtensionA(
    pszPath: *[260]u8,
    pszExt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathAddExtensionW(
    pszPath: *[260]u16,
    pszExt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathAppendA(
    pszPath: *[260]u8,
    pszMore: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathAppendW(
    pszPath: *[260]u16,
    pszMore: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathBuildRootA(
    pszRoot: *[4]u8,
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathBuildRootW(
    pszRoot: *[4]u16,
    iDrive: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCanonicalizeA(
    pszBuf: *[260]u8,
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCanonicalizeW(
    pszBuf: *[260]u16,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCombineA(
    pszDest: *[260]u8,
    pszDir: ?[*:0]const u8,
    pszFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCombineW(
    pszDest: *[260]u16,
    pszDir: ?[*:0]const u16,
    pszFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCompactPathA(
    hDC: ?HDC,
    pszPath: *[260]u8,
    dx: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCompactPathW(
    hDC: ?HDC,
    pszPath: *[260]u16,
    dx: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCompactPathExA(
    pszOut: [*:0]u8,
    pszSrc: ?[*:0]const u8,
    cchMax: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCompactPathExW(
    pszOut: [*:0]u16,
    pszSrc: ?[*:0]const u16,
    cchMax: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCommonPrefixA(
    pszFile1: ?[*:0]const u8,
    pszFile2: ?[*:0]const u8,
    achPath: ?*[260]u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCommonPrefixW(
    pszFile1: ?[*:0]const u16,
    pszFile2: ?[*:0]const u16,
    achPath: ?*[260]u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFileExistsA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFileExistsW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindExtensionA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindExtensionW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindFileNameA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindFileNameW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindNextComponentA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindNextComponentW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindOnPathA(
    pszPath: *[260]u8,
    ppszOtherDirs: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindOnPathW(
    pszPath: *[260]u16,
    ppszOtherDirs: ?*?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindSuffixArrayA(
    pszPath: ?[*:0]const u8,
    apszSuffix: [*]const ?[*:0]const u8,
    iArraySize: i32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathFindSuffixArrayW(
    pszPath: ?[*:0]const u16,
    apszSuffix: [*]const ?[*:0]const u16,
    iArraySize: i32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathGetArgsA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathGetArgsW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsLFNFileSpecA(
    pszName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsLFNFileSpecW(
    pszName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathGetCharTypeA(
    ch: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathGetCharTypeW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathGetDriveNumberA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathGetDriveNumberW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsDirectoryA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsDirectoryW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsDirectoryEmptyA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsDirectoryEmptyW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsFileSpecA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsFileSpecW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsPrefixA(
    pszPrefix: ?[*:0]const u8,
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsPrefixW(
    pszPrefix: ?[*:0]const u16,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsRelativeA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsRelativeW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsRootA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsRootW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsSameRootA(
    pszPath1: ?[*:0]const u8,
    pszPath2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsSameRootW(
    pszPath1: ?[*:0]const u16,
    pszPath2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsUNCA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsUNCW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsNetworkPathA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsNetworkPathW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsUNCServerA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsUNCServerW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsUNCServerShareA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsUNCServerShareW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsContentTypeA(
    pszPath: ?[*:0]const u8,
    pszContentType: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsContentTypeW(
    pszPath: ?[*:0]const u16,
    pszContentType: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsURLA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsURLW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathMakePrettyA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathMakePrettyW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathMatchSpecA(
    pszFile: ?[*:0]const u8,
    pszSpec: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathMatchSpecW(
    pszFile: ?[*:0]const u16,
    pszSpec: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn PathMatchSpecExA(
    pszFile: ?[*:0]const u8,
    pszSpec: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn PathMatchSpecExW(
    pszFile: ?[*:0]const u16,
    pszSpec: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathParseIconLocationA(
    pszIconFile: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathParseIconLocationW(
    pszIconFile: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathQuoteSpacesA(
    lpsz: *[260]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathQuoteSpacesW(
    lpsz: *[260]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRelativePathToA(
    pszPath: *[260]u8,
    pszFrom: ?[*:0]const u8,
    dwAttrFrom: u32,
    pszTo: ?[*:0]const u8,
    dwAttrTo: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRelativePathToW(
    pszPath: *[260]u16,
    pszFrom: ?[*:0]const u16,
    dwAttrFrom: u32,
    pszTo: ?[*:0]const u16,
    dwAttrTo: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveArgsA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveArgsW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveBackslashA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveBackslashW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveBlanksA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveBlanksW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveExtensionA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveExtensionW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveFileSpecA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRemoveFileSpecW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRenameExtensionA(
    pszPath: *[260]u8,
    pszExt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathRenameExtensionW(
    pszPath: *[260]u16,
    pszExt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathSearchAndQualifyA(
    pszPath: ?[*:0]const u8,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathSearchAndQualifyW(
    pszPath: ?[*:0]const u16,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathSetDlgItemPathA(
    hDlg: ?HWND,
    id: i32,
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathSetDlgItemPathW(
    hDlg: ?HWND,
    id: i32,
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathSkipRootA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathSkipRootW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathStripPathA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathStripPathW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathStripToRootA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathStripToRootW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathUnquoteSpacesA(
    lpsz: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathUnquoteSpacesW(
    lpsz: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathMakeSystemFolderA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathMakeSystemFolderW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathUnmakeSystemFolderA(
    pszPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathUnmakeSystemFolderW(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsSystemFolderA(
    pszPath: ?[*:0]const u8,
    dwAttrb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathIsSystemFolderW(
    pszPath: ?[*:0]const u16,
    dwAttrb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathUndecorateA(
    pszPath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathUndecorateW(
    pszPath: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathUnExpandEnvStringsA(
    pszPath: ?[*:0]const u8,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathUnExpandEnvStringsW(
    pszPath: ?[*:0]const u16,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlCompareA(
    psz1: ?[*:0]const u8,
    psz2: ?[*:0]const u8,
    fIgnoreSlash: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlCompareW(
    psz1: ?[*:0]const u16,
    psz2: ?[*:0]const u16,
    fIgnoreSlash: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlCombineA(
    pszBase: ?[*:0]const u8,
    pszRelative: ?[*:0]const u8,
    pszCombined: ?[*:0]u8,
    pcchCombined: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlCombineW(
    pszBase: ?[*:0]const u16,
    pszRelative: ?[*:0]const u16,
    pszCombined: ?[*:0]u16,
    pcchCombined: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlCanonicalizeA(
    pszUrl: ?[*:0]const u8,
    pszCanonicalized: [*:0]u8,
    pcchCanonicalized: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlCanonicalizeW(
    pszUrl: ?[*:0]const u16,
    pszCanonicalized: [*:0]u16,
    pcchCanonicalized: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlIsOpaqueA(
    pszURL: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlIsOpaqueW(
    pszURL: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlIsNoHistoryA(
    pszURL: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlIsNoHistoryW(
    pszURL: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlIsA(
    pszUrl: ?[*:0]const u8,
    UrlIs: URLIS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlIsW(
    pszUrl: ?[*:0]const u16,
    UrlIs: URLIS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlGetLocationA(
    pszURL: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlGetLocationW(
    pszURL: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlUnescapeA(
    pszUrl: ?PSTR,
    pszUnescaped: ?[*:0]u8,
    pcchUnescaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlUnescapeW(
    pszUrl: ?PWSTR,
    pszUnescaped: ?[*:0]u16,
    pcchUnescaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlEscapeA(
    pszUrl: ?[*:0]const u8,
    pszEscaped: [*:0]u8,
    pcchEscaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlEscapeW(
    pszUrl: ?[*:0]const u16,
    pszEscaped: [*:0]u16,
    pcchEscaped: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlCreateFromPathA(
    pszPath: ?[*:0]const u8,
    pszUrl: [*:0]u8,
    pcchUrl: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlCreateFromPathW(
    pszPath: ?[*:0]const u16,
    pszUrl: [*:0]u16,
    pcchUrl: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCreateFromUrlA(
    pszUrl: ?[*:0]const u8,
    pszPath: [*:0]u8,
    pcchPath: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn PathCreateFromUrlW(
    pszUrl: ?[*:0]const u16,
    pszPath: [*:0]u16,
    pcchPath: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn PathCreateFromUrlAlloc(
    pszIn: ?[*:0]const u16,
    ppszOut: ?*?PWSTR,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlHashA(
    pszUrl: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 2?
    pbHash: ?*u8,
    cbHash: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlHashW(
    pszUrl: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 2?
    pbHash: ?*u8,
    cbHash: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlGetPartW(
    pszIn: ?[*:0]const u16,
    pszOut: [*:0]u16,
    pcchOut: ?*u32,
    dwPart: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlGetPartA(
    pszIn: ?[*:0]const u8,
    pszOut: [*:0]u8,
    pcchOut: ?*u32,
    dwPart: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlApplySchemeA(
    pszIn: ?[*:0]const u8,
    pszOut: [*:0]u8,
    pcchOut: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn UrlApplySchemeW(
    pszIn: ?[*:0]const u16,
    pszOut: [*:0]u16,
    pcchOut: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn HashData(
    // TODO: what to do with BytesParamIndex 1?
    pbData: ?*u8,
    cbData: u32,
    // TODO: what to do with BytesParamIndex 3?
    pbHash: ?*u8,
    cbHash: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn UrlFixupW(
    pcszUrl: ?[*:0]const u16,
    pszTranslatedUrl: [*:0]u16,
    cchMax: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn ParseURLA(
    pcszURL: ?[*:0]const u8,
    ppu: ?*PARSEDURLA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn ParseURLW(
    pcszURL: ?[*:0]const u16,
    ppu: ?*PARSEDURLW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHDeleteEmptyKeyA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHDeleteEmptyKeyW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHDeleteKeyA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHDeleteKeyW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegDuplicateHKey(
    hkey: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) ?HKEY;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHDeleteValueA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHDeleteValueW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHGetValueA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHGetValueW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHSetValueA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*const anyopaque,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHSetValueW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*const anyopaque,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHRegGetValueA(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    srrfFlags: i32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHRegGetValueW(
    hkey: ?HKEY,
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    srrfFlags: i32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn SHRegGetValueFromHKCUHKLM(
    pwszKey: ?[*:0]const u16,
    pwszValue: ?[*:0]const u16,
    srrfFlags: i32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHQueryValueExA(
    hkey: ?HKEY,
    pszValue: ?[*:0]const u8,
    pdwReserved: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHQueryValueExW(
    hkey: ?HKEY,
    pszValue: ?[*:0]const u16,
    pdwReserved: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 5?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHEnumKeyExA(
    hkey: ?HKEY,
    dwIndex: u32,
    pszName: [*:0]u8,
    pcchName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHEnumKeyExW(
    hkey: ?HKEY,
    dwIndex: u32,
    pszName: [*:0]u16,
    pcchName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHEnumValueA(
    hkey: ?HKEY,
    dwIndex: u32,
    pszValueName: ?[*:0]u8,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHEnumValueW(
    hkey: ?HKEY,
    dwIndex: u32,
    pszValueName: ?[*:0]u16,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHQueryInfoKeyA(
    hkey: ?HKEY,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHQueryInfoKeyW(
    hkey: ?HKEY,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHCopyKeyA(
    hkeySrc: ?HKEY,
    pszSrcSubKey: ?[*:0]const u8,
    hkeyDest: ?HKEY,
    fReserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHCopyKeyW(
    hkeySrc: ?HKEY,
    pszSrcSubKey: ?[*:0]const u16,
    hkeyDest: ?HKEY,
    fReserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegGetPathA(
    hKey: ?HKEY,
    pcszSubKey: ?[*:0]const u8,
    pcszValue: ?[*:0]const u8,
    pszPath: *[260]u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegGetPathW(
    hKey: ?HKEY,
    pcszSubKey: ?[*:0]const u16,
    pcszValue: ?[*:0]const u16,
    pszPath: *[260]u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegSetPathA(
    hKey: ?HKEY,
    pcszSubKey: ?[*:0]const u8,
    pcszValue: ?[*:0]const u8,
    pcszPath: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegSetPathW(
    hKey: ?HKEY,
    pcszSubKey: ?[*:0]const u16,
    pcszValue: ?[*:0]const u16,
    pcszPath: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegCreateUSKeyA(
    pszPath: ?[*:0]const u8,
    samDesired: u32,
    hRelativeUSKey: isize,
    phNewUSKey: ?*isize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegCreateUSKeyW(
    pwzPath: ?[*:0]const u16,
    samDesired: u32,
    hRelativeUSKey: isize,
    phNewUSKey: ?*isize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegOpenUSKeyA(
    pszPath: ?[*:0]const u8,
    samDesired: u32,
    hRelativeUSKey: isize,
    phNewUSKey: ?*isize,
    fIgnoreHKCU: BOOL,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegOpenUSKeyW(
    pwzPath: ?[*:0]const u16,
    samDesired: u32,
    hRelativeUSKey: isize,
    phNewUSKey: ?*isize,
    fIgnoreHKCU: BOOL,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegQueryUSValueA(
    hUSKey: isize,
    pszValue: ?[*:0]const u8,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    // TODO: what to do with BytesParamIndex 7?
    pvDefaultData: ?*anyopaque,
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegQueryUSValueW(
    hUSKey: isize,
    pszValue: ?[*:0]const u16,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    // TODO: what to do with BytesParamIndex 7?
    pvDefaultData: ?*anyopaque,
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegWriteUSValueA(
    hUSKey: isize,
    pszValue: ?[*:0]const u8,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*const anyopaque,
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegWriteUSValueW(
    hUSKey: isize,
    pwzValue: ?[*:0]const u16,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*const anyopaque,
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegDeleteUSValueA(
    hUSKey: isize,
    pszValue: ?[*:0]const u8,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegDeleteUSValueW(
    hUSKey: isize,
    pwzValue: ?[*:0]const u16,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegDeleteEmptyUSKeyW(
    hUSKey: isize,
    pwzSubKey: ?[*:0]const u16,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegDeleteEmptyUSKeyA(
    hUSKey: isize,
    pszSubKey: ?[*:0]const u8,
    delRegFlags: SHREGDEL_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegEnumUSKeyA(
    hUSKey: isize,
    dwIndex: u32,
    pszName: [*:0]u8,
    pcchName: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegEnumUSKeyW(
    hUSKey: isize,
    dwIndex: u32,
    pwzName: [*:0]u16,
    pcchName: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegEnumUSValueA(
    hUSkey: isize,
    dwIndex: u32,
    pszValueName: [*:0]u8,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegEnumUSValueW(
    hUSkey: isize,
    dwIndex: u32,
    pszValueName: [*:0]u16,
    pcchValueName: ?*u32,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegQueryInfoUSKeyA(
    hUSKey: isize,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegQueryInfoUSKeyW(
    hUSKey: isize,
    pcSubKeys: ?*u32,
    pcchMaxSubKeyLen: ?*u32,
    pcValues: ?*u32,
    pcchMaxValueNameLen: ?*u32,
    enumRegFlags: SHREGENUM_FLAGS,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegCloseUSKey(
    hUSKey: isize,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegGetUSValueA(
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    // TODO: what to do with BytesParamIndex 7?
    pvDefaultData: ?*anyopaque,
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegGetUSValueW(
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    pdwType: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*anyopaque,
    pcbData: ?*u32,
    fIgnoreHKCU: BOOL,
    // TODO: what to do with BytesParamIndex 7?
    pvDefaultData: ?*anyopaque,
    dwDefaultDataSize: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegSetUSValueA(
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*const anyopaque,
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegSetUSValueW(
    pwzSubKey: ?[*:0]const u16,
    pwzValue: ?[*:0]const u16,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvData: ?*const anyopaque,
    cbData: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegGetIntW(
    hk: ?HKEY,
    pwzKey: ?[*:0]const u16,
    iDefault: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegGetBoolUSValueA(
    pszSubKey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    fIgnoreHKCU: BOOL,
    fDefault: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHRegGetBoolUSValueW(
    pszSubKey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    fIgnoreHKCU: BOOL,
    fDefault: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn AssocCreate(
    clsid: Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn AssocQueryStringA(
    flags: u32,
    str: ASSOCSTR,
    pszAssoc: ?[*:0]const u8,
    pszExtra: ?[*:0]const u8,
    pszOut: ?[*:0]u8,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn AssocQueryStringW(
    flags: u32,
    str: ASSOCSTR,
    pszAssoc: ?[*:0]const u16,
    pszExtra: ?[*:0]const u16,
    pszOut: ?[*:0]u16,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn AssocQueryStringByKeyA(
    flags: u32,
    str: ASSOCSTR,
    hkAssoc: ?HKEY,
    pszExtra: ?[*:0]const u8,
    pszOut: ?[*:0]u8,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn AssocQueryStringByKeyW(
    flags: u32,
    str: ASSOCSTR,
    hkAssoc: ?HKEY,
    pszExtra: ?[*:0]const u16,
    pszOut: ?[*:0]u16,
    pcchOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn AssocQueryKeyA(
    flags: u32,
    key: ASSOCKEY,
    pszAssoc: ?[*:0]const u8,
    pszExtra: ?[*:0]const u8,
    phkeyOut: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn AssocQueryKeyW(
    flags: u32,
    key: ASSOCKEY,
    pszAssoc: ?[*:0]const u16,
    pszExtra: ?[*:0]const u16,
    phkeyOut: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn AssocIsDangerous(
    pszAssoc: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn AssocGetPerceivedType(
    pszExt: ?[*:0]const u16,
    ptype: ?*PERCEIVED,
    pflag: ?*u32,
    ppszType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHOpenRegStreamA(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHOpenRegStreamW(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHOpenRegStream2A(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u8,
    pszValue: ?[*:0]const u8,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHOpenRegStream2W(
    hkey: ?HKEY,
    pszSubkey: ?[*:0]const u16,
    pszValue: ?[*:0]const u16,
    grfMode: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHCreateStreamOnFileA(
    pszFile: ?[*:0]const u8,
    grfMode: u32,
    ppstm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHCreateStreamOnFileW(
    pszFile: ?[*:0]const u16,
    grfMode: u32,
    ppstm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHCreateStreamOnFileEx(
    pszFile: ?[*:0]const u16,
    grfMode: u32,
    dwAttributes: u32,
    fCreate: BOOL,
    pstmTemplate: ?*IStream,
    ppstm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHCreateMemStream(
    // TODO: what to do with BytesParamIndex 1?
    pInit: ?*const u8,
    cbInit: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IStream;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn GetAcceptLanguagesA(
    pszLanguages: [*:0]u8,
    pcchLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn GetAcceptLanguagesW(
    pszLanguages: [*:0]u16,
    pcchLanguages: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IUnknown_Set(
    ppunk: ?*?*IUnknown,
    punk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IUnknown_AtomicRelease(
    ppunk: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IUnknown_GetWindow(
    punk: ?*IUnknown,
    phwnd: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IUnknown_SetSite(
    punk: ?*IUnknown,
    punkSite: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IUnknown_GetSite(
    punk: ?*IUnknown,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IUnknown_QueryService(
    punk: ?*IUnknown,
    guidService: ?*const Guid,
    riid: ?*const Guid,
    ppvOut: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IStream_Read(
    pstm: ?*IStream,
    pv: ?*anyopaque,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn IStream_Write(
    pstm: ?*IStream,
    // TODO: what to do with BytesParamIndex 2?
    pv: ?*const anyopaque,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IStream_Reset(
    pstm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IStream_Size(
    pstm: ?*IStream,
    pui: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn ConnectToConnectionPoint(
    punk: ?*IUnknown,
    riidEvent: ?*const Guid,
    fConnect: BOOL,
    punkTarget: ?*IUnknown,
    pdwCookie: ?*u32,
    ppcpOut: ?*?*IConnectionPoint,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn IStream_ReadPidl(
    pstm: ?*IStream,
    ppidlOut: ?*?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn IStream_WritePidl(
    pstm: ?*IStream,
    pidlWrite: ?*ITEMIDLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn IStream_ReadStr(
    pstm: ?*IStream,
    ppsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn IStream_WriteStr(
    pstm: ?*IStream,
    psz: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn IStream_Copy(
    pstmFrom: ?*IStream,
    pstmTo: ?*IStream,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHGetViewStatePropertyBag(
    pidl: ?*ITEMIDLIST,
    pszBagName: ?[*:0]const u16,
    dwFlags: u32,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHFormatDateTimeA(
    pft: ?*const FILETIME,
    pdwFlags: ?*u32,
    pszBuf: [*:0]u8,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHFormatDateTimeW(
    pft: ?*const FILETIME,
    pdwFlags: ?*u32,
    pszBuf: [*:0]u16,
    cchBuf: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHAnsiToUnicode(
    pszSrc: ?[*:0]const u8,
    pwszDst: [*:0]u16,
    cwchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHAnsiToAnsi(
    pszSrc: ?[*:0]const u8,
    pszDst: [*:0]u8,
    cchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHUnicodeToAnsi(
    pwszSrc: ?[*:0]const u16,
    pszDst: [*:0]u8,
    cchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHUnicodeToUnicode(
    pwzSrc: ?[*:0]const u16,
    pwzDst: [*:0]u16,
    cwchBuf: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHMessageBoxCheckA(
    hwnd: ?HWND,
    pszText: ?[*:0]const u8,
    pszCaption: ?[*:0]const u8,
    uType: u32,
    iDefault: i32,
    pszRegVal: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHMessageBoxCheckW(
    hwnd: ?HWND,
    pszText: ?[*:0]const u16,
    pszCaption: ?[*:0]const u16,
    uType: u32,
    iDefault: i32,
    pszRegVal: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHSendMessageBroadcastA(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHSendMessageBroadcastW(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHStripMneumonicA(
    pszMenu: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) CHAR;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHStripMneumonicW(
    pszMenu: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn IsOS(
    dwOS: OS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHLWAPI" fn SHGlobalCounterGetValue(
    id: SHGLOBALCOUNTER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHLWAPI" fn SHGlobalCounterIncrement(
    id: SHGLOBALCOUNTER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "SHLWAPI" fn SHGlobalCounterDecrement(
    id: SHGLOBALCOUNTER,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHAllocShared(
    // TODO: what to do with BytesParamIndex 1?
    pvData: ?*const anyopaque,
    dwSize: u32,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHFreeShared(
    hData: ?HANDLE,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHLockShared(
    hData: ?HANDLE,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHUnlockShared(
    pvData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn WhichPlatform(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn QISearch(
    that: ?*anyopaque,
    pqit: ?*QITAB,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHIsLowMemoryMachine(
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn GetMenuPosFromID(
    hmenu: ?HMENU,
    id: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHGetInverseCMAP(
    // TODO: what to do with BytesParamIndex 1?
    pbMap: ?*u8,
    cbMap: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHAutoComplete(
    hwndEdit: ?HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHCreateThreadRef(
    pcRef: ?*i32,
    ppunk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHSetThreadRef(
    punk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHGetThreadRef(
    ppunk: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHSkipJunction(
    pbc: ?*IBindCtx,
    pclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHCreateThread(
    pfnThreadProc: ?LPTHREAD_START_ROUTINE,
    pData: ?*anyopaque,
    flags: u32,
    pfnCallback: ?LPTHREAD_START_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "SHLWAPI" fn SHCreateThreadWithHandle(
    pfnThreadProc: ?LPTHREAD_START_ROUTINE,
    pData: ?*anyopaque,
    flags: u32,
    pfnCallback: ?LPTHREAD_START_ROUTINE,
    pHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn SHReleaseThreadRef(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn SHCreateShellPalette(
    hdc: ?HDC,
) callconv(@import("std").os.windows.WINAPI) ?HPALETTE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn ColorRGBToHLS(
    clrRGB: u32,
    pwHue: ?*u16,
    pwLuminance: ?*u16,
    pwSaturation: ?*u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn ColorHLSToRGB(
    wHue: u16,
    wLuminance: u16,
    wSaturation: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "SHLWAPI" fn ColorAdjustLuma(
    clrRGB: u32,
    n: i32,
    fScale: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "SHLWAPI" fn IsInternetESCEnabled(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "hlink" fn HlinkCreateFromMoniker(
    pimkTrgt: ?*IMoniker,
    pwzLocation: ?[*:0]const u16,
    pwzFriendlyName: ?[*:0]const u16,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateFromString(
    pwzTarget: ?[*:0]const u16,
    pwzLocation: ?[*:0]const u16,
    pwzFriendlyName: ?[*:0]const u16,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateFromData(
    piDataObj: ?*IDataObject,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkQueryCreateFromData(
    piDataObj: ?*IDataObject,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkClone(
    pihl: ?*IHlink,
    riid: ?*const Guid,
    pihlsiteForClone: ?*IHlinkSite,
    dwSiteData: u32,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateBrowseContext(
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkNavigateToStringReference(
    pwzTarget: ?[*:0]const u16,
    pwzLocation: ?[*:0]const u16,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    pihlframe: ?*IHlinkFrame,
    grfHLNF: u32,
    pibc: ?*IBindCtx,
    pibsc: ?*IBindStatusCallback,
    pihlbc: ?*IHlinkBrowseContext,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkNavigate(
    pihl: ?*IHlink,
    pihlframe: ?*IHlinkFrame,
    grfHLNF: u32,
    pbc: ?*IBindCtx,
    pibsc: ?*IBindStatusCallback,
    pihlbc: ?*IHlinkBrowseContext,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkOnNavigate(
    pihlframe: ?*IHlinkFrame,
    pihlbc: ?*IHlinkBrowseContext,
    grfHLNF: u32,
    pimkTarget: ?*IMoniker,
    pwzLocation: ?[*:0]const u16,
    pwzFriendlyName: ?[*:0]const u16,
    puHLID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkUpdateStackItem(
    pihlframe: ?*IHlinkFrame,
    pihlbc: ?*IHlinkBrowseContext,
    uHLID: u32,
    pimkTrgt: ?*IMoniker,
    pwzLocation: ?[*:0]const u16,
    pwzFriendlyName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkOnRenameDocument(
    dwReserved: u32,
    pihlbc: ?*IHlinkBrowseContext,
    pimkOld: ?*IMoniker,
    pimkNew: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveMonikerForData(
    pimkReference: ?*IMoniker,
    reserved: u32,
    pibc: ?*IBindCtx,
    cFmtetc: u32,
    rgFmtetc: ?*FORMATETC,
    pibsc: ?*IBindStatusCallback,
    pimkBase: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveStringForData(
    pwzReference: ?[*:0]const u16,
    reserved: u32,
    pibc: ?*IBindCtx,
    cFmtetc: u32,
    rgFmtetc: ?*FORMATETC,
    pibsc: ?*IBindStatusCallback,
    pimkBase: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkParseDisplayName(
    pibc: ?*IBindCtx,
    pwzDisplayName: ?[*:0]const u16,
    fNoForceAbs: BOOL,
    pcchEaten: ?*u32,
    ppimk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateExtensionServices(
    pwzAdditionalHeaders: ?[*:0]const u16,
    phwnd: ?HWND,
    pszUsername: ?[*:0]const u16,
    pszPassword: ?[*:0]const u16,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkPreprocessMoniker(
    pibc: ?*IBindCtx,
    pimkIn: ?*IMoniker,
    ppimkOut: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn OleSaveToStreamEx(
    piunk: ?*IUnknown,
    pistm: ?*IStream,
    fClearDirty: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkSetSpecialReference(
    uReference: u32,
    pwzReference: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkGetSpecialReference(
    uReference: u32,
    ppwzReference: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateShortcut(
    grfHLSHORTCUTF: u32,
    pihl: ?*IHlink,
    pwzDir: ?[*:0]const u16,
    pwzFileName: ?[*:0]const u16,
    ppwzShortcutFile: ?*?PWSTR,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateShortcutFromMoniker(
    grfHLSHORTCUTF: u32,
    pimkTarget: ?*IMoniker,
    pwzLocation: ?[*:0]const u16,
    pwzDir: ?[*:0]const u16,
    pwzFileName: ?[*:0]const u16,
    ppwzShortcutFile: ?*?PWSTR,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkCreateShortcutFromString(
    grfHLSHORTCUTF: u32,
    pwzTarget: ?[*:0]const u16,
    pwzLocation: ?[*:0]const u16,
    pwzDir: ?[*:0]const u16,
    pwzFileName: ?[*:0]const u16,
    ppwzShortcutFile: ?*?PWSTR,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveShortcut(
    pwzShortcutFileName: ?[*:0]const u16,
    pihlsite: ?*IHlinkSite,
    dwSiteData: u32,
    piunkOuter: ?*IUnknown,
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveShortcutToMoniker(
    pwzShortcutFileName: ?[*:0]const u16,
    ppimkTarget: ?*?*IMoniker,
    ppwzLocation: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkResolveShortcutToString(
    pwzShortcutFileName: ?[*:0]const u16,
    ppwzTarget: ?*?PWSTR,
    ppwzLocation: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkIsShortcut(
    pwzFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkGetValueFromParams(
    pwzParams: ?[*:0]const u16,
    pwzName: ?[*:0]const u16,
    ppwzValue: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "hlink" fn HlinkTranslateURL(
    pwzURL: ?[*:0]const u16,
    grfFlags: u32,
    ppwzTranslatedURL: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathIsUNCEx(
    pszPath: ?[*:0]const u16,
    ppszServer: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchIsRoot(
    pszPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAddBackslashEx(
    pszPath: [*:0]u16,
    cchPath: usize,
    ppszEnd: ?*?PWSTR,
    pcchRemaining: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAddBackslash(
    pszPath: [*:0]u16,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveBackslashEx(
    pszPath: ?PWSTR,
    cchPath: usize,
    ppszEnd: ?*?PWSTR,
    pcchRemaining: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveBackslash(
    pszPath: [*:0]u16,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchSkipRoot(
    pszPath: ?[*:0]const u16,
    ppszRootEnd: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchStripToRoot(
    pszPath: ?PWSTR,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveFileSpec(
    pszPath: ?PWSTR,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchFindExtension(
    pszPath: ?[*:0]const u16,
    cchPath: usize,
    ppszExt: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAddExtension(
    pszPath: [*:0]u16,
    cchPath: usize,
    pszExt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRenameExtension(
    pszPath: [*:0]u16,
    cchPath: usize,
    pszExt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchRemoveExtension(
    pszPath: ?PWSTR,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCanonicalizeEx(
    pszPathOut: [*:0]u16,
    cchPathOut: usize,
    pszPathIn: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCanonicalize(
    pszPathOut: [*:0]u16,
    cchPathOut: usize,
    pszPathIn: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCombineEx(
    pszPathOut: [*:0]u16,
    cchPathOut: usize,
    pszPathIn: ?[*:0]const u16,
    pszMore: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchCombine(
    pszPathOut: [*:0]u16,
    cchPathOut: usize,
    pszPathIn: ?[*:0]const u16,
    pszMore: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAppendEx(
    pszPath: [*:0]u16,
    cchPath: usize,
    pszMore: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchAppend(
    pszPath: [*:0]u16,
    cchPath: usize,
    pszMore: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathCchStripPrefix(
    pszPath: [*:0]u16,
    cchPath: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathAllocCombine(
    pszPathIn: ?[*:0]const u16,
    pszMore: ?[*:0]const u16,
    dwFlags: u32,
    ppszPathOut: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-path-l1-1-0" fn PathAllocCanonicalize(
    pszPathIn: ?[*:0]const u16,
    dwFlags: u32,
    ppszPathOut: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-psm-appnotify-l1-1-0" fn RegisterAppStateChangeNotification(
    Routine: ?PAPPSTATE_CHANGE_ROUTINE,
    Context: ?*anyopaque,
    Registration: ?*?*_APPSTATE_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-psm-appnotify-l1-1-0" fn UnregisterAppStateChangeNotification(
    Registration: ?*_APPSTATE_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-psm-appnotify-l1-1-1" fn RegisterAppConstrainedChangeNotification(
    Routine: ?PAPPCONSTRAIN_CHANGE_ROUTINE,
    Context: ?*anyopaque,
    Registration: ?*?*_APPCONSTRAIN_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-psm-appnotify-l1-1-1" fn UnregisterAppConstrainedChangeNotification(
    Registration: ?*_APPCONSTRAIN_REGISTRATION,
) callconv(@import("std").os.windows.WINAPI) void;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (205)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const MULTIKEYHELP = thismodule.MULTIKEYHELPA;
        pub const HELPWININFO = thismodule.HELPWININFOA;
        pub const IShellLink = thismodule.IShellLinkA;
        pub const IExtractIcon = thismodule.IExtractIconA;
        pub const BROWSEINFO = thismodule.BROWSEINFOA;
        pub const FILEDESCRIPTOR = thismodule.FILEDESCRIPTORA;
        pub const FILEGROUPDESCRIPTOR = thismodule.FILEGROUPDESCRIPTORA;
        pub const SHELLSTATE = thismodule.SHELLSTATEA;
        pub const INewShortcutHook = thismodule.INewShortcutHookA;
        pub const ICopyHook = thismodule.ICopyHookA;
        pub const DRAGINFO = thismodule.DRAGINFOA;
        pub const SHFILEOPSTRUCT = thismodule.SHFILEOPSTRUCTA;
        pub const SHNAMEMAPPING = thismodule.SHNAMEMAPPINGA;
        pub const SHELLEXECUTEINFO = thismodule.SHELLEXECUTEINFOA;
        pub const NOTIFYICONDATA = thismodule.NOTIFYICONDATAA;
        pub const SHFILEINFO = thismodule.SHFILEINFOA;
        pub const OPEN_PRINTER_PROPS_INFO = thismodule.OPEN_PRINTER_PROPS_INFOA;
        pub const PARSEDURL = thismodule.PARSEDURLA;
        pub const NEWCPLINFO = thismodule.NEWCPLINFOA;
        pub const PROFILEINFO = thismodule.PROFILEINFOA;
        pub const urlinvokecommandinfo = thismodule.urlinvokecommandinfoA;
        pub const IUniformResourceLocator = thismodule.IUniformResourceLocatorA;
        pub const LoadUserProfile = thismodule.LoadUserProfileA;
        pub const GetProfilesDirectory = thismodule.GetProfilesDirectoryA;
        pub const DeleteProfile = thismodule.DeleteProfileA;
        pub const GetDefaultUserProfileDirectory = thismodule.GetDefaultUserProfileDirectoryA;
        pub const GetAllUsersProfileDirectory = thismodule.GetAllUsersProfileDirectoryA;
        pub const GetUserProfileDirectory = thismodule.GetUserProfileDirectoryA;
        pub const WinHelp = thismodule.WinHelpA;
        pub const SHGetIconOverlayIndex = thismodule.SHGetIconOverlayIndexA;
        pub const ILCreateFromPath = thismodule.ILCreateFromPathA;
        pub const SHGetPathFromIDList = thismodule.SHGetPathFromIDListA;
        pub const SHCreateDirectoryEx = thismodule.SHCreateDirectoryExA;
        pub const SHGetSpecialFolderPath = thismodule.SHGetSpecialFolderPathA;
        pub const SHGetFolderPath = thismodule.SHGetFolderPathA;
        pub const SHSetFolderPath = thismodule.SHSetFolderPathA;
        pub const SHGetFolderPathAndSubDir = thismodule.SHGetFolderPathAndSubDirA;
        pub const SHBrowseForFolder = thismodule.SHBrowseForFolderA;
        pub const SHUpdateImage = thismodule.SHUpdateImageA;
        pub const SHGetDataFromIDList = thismodule.SHGetDataFromIDListA;
        pub const SHDefExtractIcon = thismodule.SHDefExtractIconA;
        pub const SHPathPrepareForWrite = thismodule.SHPathPrepareForWriteA;
        pub const PathIsSlow = thismodule.PathIsSlowA;
        pub const DragQueryFile = thismodule.DragQueryFileA;
        pub const ShellExecute = thismodule.ShellExecuteA;
        pub const FindExecutable = thismodule.FindExecutableA;
        pub const ShellAbout = thismodule.ShellAboutA;
        pub const ExtractAssociatedIcon = thismodule.ExtractAssociatedIconA;
        pub const ExtractAssociatedIconEx = thismodule.ExtractAssociatedIconExA;
        pub const ExtractIcon = thismodule.ExtractIconA;
        pub const DoEnvironmentSubst = thismodule.DoEnvironmentSubstA;
        pub const ExtractIconEx = thismodule.ExtractIconExA;
        pub const SHFileOperation = thismodule.SHFileOperationA;
        pub const ShellExecuteEx = thismodule.ShellExecuteExA;
        pub const SHQueryRecycleBin = thismodule.SHQueryRecycleBinA;
        pub const SHEmptyRecycleBin = thismodule.SHEmptyRecycleBinA;
        pub const Shell_NotifyIcon = thismodule.Shell_NotifyIconA;
        pub const SHGetFileInfo = thismodule.SHGetFileInfoA;
        pub const SHGetDiskFreeSpaceEx = thismodule.SHGetDiskFreeSpaceExA;
        pub const SHGetNewLinkInfo = thismodule.SHGetNewLinkInfoA;
        pub const SHInvokePrinterCommand = thismodule.SHInvokePrinterCommandA;
        pub const ShellMessageBox = thismodule.ShellMessageBoxA;
        pub const IsLFNDrive = thismodule.IsLFNDriveA;
        pub const StrChr = thismodule.StrChrA;
        pub const StrChrI = thismodule.StrChrIA;
        pub const StrCmpN = thismodule.StrCmpNA;
        pub const StrCmpNI = thismodule.StrCmpNIA;
        pub const StrCSpn = thismodule.StrCSpnA;
        pub const StrCSpnI = thismodule.StrCSpnIA;
        pub const StrDup = thismodule.StrDupA;
        pub const StrFormatByteSize = thismodule.StrFormatByteSizeA;
        pub const StrFormatKBSize = thismodule.StrFormatKBSizeA;
        pub const StrFromTimeInterval = thismodule.StrFromTimeIntervalA;
        pub const StrIsIntlEqual = thismodule.StrIsIntlEqualA;
        pub const StrNCat = thismodule.StrNCatA;
        pub const StrPBrk = thismodule.StrPBrkA;
        pub const StrRChr = thismodule.StrRChrA;
        pub const StrRChrI = thismodule.StrRChrIA;
        pub const StrRStrI = thismodule.StrRStrIA;
        pub const StrSpn = thismodule.StrSpnA;
        pub const StrStr = thismodule.StrStrA;
        pub const StrStrI = thismodule.StrStrIA;
        pub const StrToInt = thismodule.StrToIntA;
        pub const StrToIntEx = thismodule.StrToIntExA;
        pub const StrToInt64Ex = thismodule.StrToInt64ExA;
        pub const StrTrim = thismodule.StrTrimA;
        pub const StrCatBuff = thismodule.StrCatBuffA;
        pub const ChrCmpI = thismodule.ChrCmpIA;
        pub const wvnsprintf = thismodule.wvnsprintfA;
        pub const wnsprintf = thismodule.wnsprintfA;
        pub const StrRetToStr = thismodule.StrRetToStrA;
        pub const StrRetToBuf = thismodule.StrRetToBufA;
        pub const SHStrDup = thismodule.SHStrDupA;
        pub const IsCharSpace = thismodule.IsCharSpaceA;
        pub const StrCmpC = thismodule.StrCmpCA;
        pub const StrCmpIC = thismodule.StrCmpICA;
        pub const StrCmpNC = thismodule.StrCmpNCA;
        pub const StrCmpNIC = thismodule.StrCmpNICA;
        pub const IntlStrEqWorker = thismodule.IntlStrEqWorkerA;
        pub const PathAddBackslash = thismodule.PathAddBackslashA;
        pub const PathAddExtension = thismodule.PathAddExtensionA;
        pub const PathAppend = thismodule.PathAppendA;
        pub const PathBuildRoot = thismodule.PathBuildRootA;
        pub const PathCanonicalize = thismodule.PathCanonicalizeA;
        pub const PathCombine = thismodule.PathCombineA;
        pub const PathCompactPath = thismodule.PathCompactPathA;
        pub const PathCompactPathEx = thismodule.PathCompactPathExA;
        pub const PathCommonPrefix = thismodule.PathCommonPrefixA;
        pub const PathFileExists = thismodule.PathFileExistsA;
        pub const PathFindExtension = thismodule.PathFindExtensionA;
        pub const PathFindFileName = thismodule.PathFindFileNameA;
        pub const PathFindNextComponent = thismodule.PathFindNextComponentA;
        pub const PathFindOnPath = thismodule.PathFindOnPathA;
        pub const PathFindSuffixArray = thismodule.PathFindSuffixArrayA;
        pub const PathGetArgs = thismodule.PathGetArgsA;
        pub const PathIsLFNFileSpec = thismodule.PathIsLFNFileSpecA;
        pub const PathGetCharType = thismodule.PathGetCharTypeA;
        pub const PathGetDriveNumber = thismodule.PathGetDriveNumberA;
        pub const PathIsDirectory = thismodule.PathIsDirectoryA;
        pub const PathIsDirectoryEmpty = thismodule.PathIsDirectoryEmptyA;
        pub const PathIsFileSpec = thismodule.PathIsFileSpecA;
        pub const PathIsPrefix = thismodule.PathIsPrefixA;
        pub const PathIsRelative = thismodule.PathIsRelativeA;
        pub const PathIsRoot = thismodule.PathIsRootA;
        pub const PathIsSameRoot = thismodule.PathIsSameRootA;
        pub const PathIsUNC = thismodule.PathIsUNCA;
        pub const PathIsNetworkPath = thismodule.PathIsNetworkPathA;
        pub const PathIsUNCServer = thismodule.PathIsUNCServerA;
        pub const PathIsUNCServerShare = thismodule.PathIsUNCServerShareA;
        pub const PathIsContentType = thismodule.PathIsContentTypeA;
        pub const PathIsURL = thismodule.PathIsURLA;
        pub const PathMakePretty = thismodule.PathMakePrettyA;
        pub const PathMatchSpec = thismodule.PathMatchSpecA;
        pub const PathMatchSpecEx = thismodule.PathMatchSpecExA;
        pub const PathParseIconLocation = thismodule.PathParseIconLocationA;
        pub const PathQuoteSpaces = thismodule.PathQuoteSpacesA;
        pub const PathRelativePathTo = thismodule.PathRelativePathToA;
        pub const PathRemoveArgs = thismodule.PathRemoveArgsA;
        pub const PathRemoveBackslash = thismodule.PathRemoveBackslashA;
        pub const PathRemoveBlanks = thismodule.PathRemoveBlanksA;
        pub const PathRemoveExtension = thismodule.PathRemoveExtensionA;
        pub const PathRemoveFileSpec = thismodule.PathRemoveFileSpecA;
        pub const PathRenameExtension = thismodule.PathRenameExtensionA;
        pub const PathSearchAndQualify = thismodule.PathSearchAndQualifyA;
        pub const PathSetDlgItemPath = thismodule.PathSetDlgItemPathA;
        pub const PathSkipRoot = thismodule.PathSkipRootA;
        pub const PathStripPath = thismodule.PathStripPathA;
        pub const PathStripToRoot = thismodule.PathStripToRootA;
        pub const PathUnquoteSpaces = thismodule.PathUnquoteSpacesA;
        pub const PathMakeSystemFolder = thismodule.PathMakeSystemFolderA;
        pub const PathUnmakeSystemFolder = thismodule.PathUnmakeSystemFolderA;
        pub const PathIsSystemFolder = thismodule.PathIsSystemFolderA;
        pub const PathUndecorate = thismodule.PathUndecorateA;
        pub const PathUnExpandEnvStrings = thismodule.PathUnExpandEnvStringsA;
        pub const UrlCompare = thismodule.UrlCompareA;
        pub const UrlCombine = thismodule.UrlCombineA;
        pub const UrlCanonicalize = thismodule.UrlCanonicalizeA;
        pub const UrlIsOpaque = thismodule.UrlIsOpaqueA;
        pub const UrlIsNoHistory = thismodule.UrlIsNoHistoryA;
        pub const UrlIs = thismodule.UrlIsA;
        pub const UrlGetLocation = thismodule.UrlGetLocationA;
        pub const UrlUnescape = thismodule.UrlUnescapeA;
        pub const UrlEscape = thismodule.UrlEscapeA;
        pub const UrlCreateFromPath = thismodule.UrlCreateFromPathA;
        pub const PathCreateFromUrl = thismodule.PathCreateFromUrlA;
        pub const UrlHash = thismodule.UrlHashA;
        pub const UrlGetPart = thismodule.UrlGetPartA;
        pub const UrlApplyScheme = thismodule.UrlApplySchemeA;
        pub const ParseURL = thismodule.ParseURLA;
        pub const SHDeleteEmptyKey = thismodule.SHDeleteEmptyKeyA;
        pub const SHDeleteKey = thismodule.SHDeleteKeyA;
        pub const SHDeleteValue = thismodule.SHDeleteValueA;
        pub const SHGetValue = thismodule.SHGetValueA;
        pub const SHSetValue = thismodule.SHSetValueA;
        pub const SHRegGetValue = thismodule.SHRegGetValueA;
        pub const SHQueryValueEx = thismodule.SHQueryValueExA;
        pub const SHEnumKeyEx = thismodule.SHEnumKeyExA;
        pub const SHEnumValue = thismodule.SHEnumValueA;
        pub const SHQueryInfoKey = thismodule.SHQueryInfoKeyA;
        pub const SHCopyKey = thismodule.SHCopyKeyA;
        pub const SHRegGetPath = thismodule.SHRegGetPathA;
        pub const SHRegSetPath = thismodule.SHRegSetPathA;
        pub const SHRegCreateUSKey = thismodule.SHRegCreateUSKeyA;
        pub const SHRegOpenUSKey = thismodule.SHRegOpenUSKeyA;
        pub const SHRegQueryUSValue = thismodule.SHRegQueryUSValueA;
        pub const SHRegWriteUSValue = thismodule.SHRegWriteUSValueA;
        pub const SHRegDeleteUSValue = thismodule.SHRegDeleteUSValueA;
        pub const SHRegDeleteEmptyUSKey = thismodule.SHRegDeleteEmptyUSKeyA;
        pub const SHRegEnumUSKey = thismodule.SHRegEnumUSKeyA;
        pub const SHRegEnumUSValue = thismodule.SHRegEnumUSValueA;
        pub const SHRegQueryInfoUSKey = thismodule.SHRegQueryInfoUSKeyA;
        pub const SHRegGetUSValue = thismodule.SHRegGetUSValueA;
        pub const SHRegSetUSValue = thismodule.SHRegSetUSValueA;
        pub const SHRegGetBoolUSValue = thismodule.SHRegGetBoolUSValueA;
        pub const AssocQueryString = thismodule.AssocQueryStringA;
        pub const AssocQueryStringByKey = thismodule.AssocQueryStringByKeyA;
        pub const AssocQueryKey = thismodule.AssocQueryKeyA;
        pub const SHOpenRegStream = thismodule.SHOpenRegStreamA;
        pub const SHOpenRegStream2 = thismodule.SHOpenRegStream2A;
        pub const SHCreateStreamOnFile = thismodule.SHCreateStreamOnFileA;
        pub const GetAcceptLanguages = thismodule.GetAcceptLanguagesA;
        pub const SHFormatDateTime = thismodule.SHFormatDateTimeA;
        pub const SHMessageBoxCheck = thismodule.SHMessageBoxCheckA;
        pub const SHSendMessageBroadcast = thismodule.SHSendMessageBroadcastA;
        pub const SHStripMneumonic = thismodule.SHStripMneumonicA;
    },
    .wide => struct {
        pub const MULTIKEYHELP = thismodule.MULTIKEYHELPW;
        pub const HELPWININFO = thismodule.HELPWININFOW;
        pub const IShellLink = thismodule.IShellLinkW;
        pub const IExtractIcon = thismodule.IExtractIconW;
        pub const BROWSEINFO = thismodule.BROWSEINFOW;
        pub const FILEDESCRIPTOR = thismodule.FILEDESCRIPTORW;
        pub const FILEGROUPDESCRIPTOR = thismodule.FILEGROUPDESCRIPTORW;
        pub const SHELLSTATE = thismodule.SHELLSTATEW;
        pub const INewShortcutHook = thismodule.INewShortcutHookW;
        pub const ICopyHook = thismodule.ICopyHookW;
        pub const DRAGINFO = thismodule.DRAGINFOW;
        pub const SHFILEOPSTRUCT = thismodule.SHFILEOPSTRUCTW;
        pub const SHNAMEMAPPING = thismodule.SHNAMEMAPPINGW;
        pub const SHELLEXECUTEINFO = thismodule.SHELLEXECUTEINFOW;
        pub const NOTIFYICONDATA = thismodule.NOTIFYICONDATAW;
        pub const SHFILEINFO = thismodule.SHFILEINFOW;
        pub const OPEN_PRINTER_PROPS_INFO = thismodule.OPEN_PRINTER_PROPS_INFOW;
        pub const PARSEDURL = thismodule.PARSEDURLW;
        pub const NEWCPLINFO = thismodule.NEWCPLINFOW;
        pub const PROFILEINFO = thismodule.PROFILEINFOW;
        pub const urlinvokecommandinfo = thismodule.urlinvokecommandinfoW;
        pub const IUniformResourceLocator = thismodule.IUniformResourceLocatorW;
        pub const LoadUserProfile = thismodule.LoadUserProfileW;
        pub const GetProfilesDirectory = thismodule.GetProfilesDirectoryW;
        pub const DeleteProfile = thismodule.DeleteProfileW;
        pub const GetDefaultUserProfileDirectory = thismodule.GetDefaultUserProfileDirectoryW;
        pub const GetAllUsersProfileDirectory = thismodule.GetAllUsersProfileDirectoryW;
        pub const GetUserProfileDirectory = thismodule.GetUserProfileDirectoryW;
        pub const WinHelp = thismodule.WinHelpW;
        pub const SHGetIconOverlayIndex = thismodule.SHGetIconOverlayIndexW;
        pub const ILCreateFromPath = thismodule.ILCreateFromPathW;
        pub const SHGetPathFromIDList = thismodule.SHGetPathFromIDListW;
        pub const SHCreateDirectoryEx = thismodule.SHCreateDirectoryExW;
        pub const SHGetSpecialFolderPath = thismodule.SHGetSpecialFolderPathW;
        pub const SHGetFolderPath = thismodule.SHGetFolderPathW;
        pub const SHSetFolderPath = thismodule.SHSetFolderPathW;
        pub const SHGetFolderPathAndSubDir = thismodule.SHGetFolderPathAndSubDirW;
        pub const SHBrowseForFolder = thismodule.SHBrowseForFolderW;
        pub const SHUpdateImage = thismodule.SHUpdateImageW;
        pub const SHGetDataFromIDList = thismodule.SHGetDataFromIDListW;
        pub const SHDefExtractIcon = thismodule.SHDefExtractIconW;
        pub const SHPathPrepareForWrite = thismodule.SHPathPrepareForWriteW;
        pub const PathIsSlow = thismodule.PathIsSlowW;
        pub const DragQueryFile = thismodule.DragQueryFileW;
        pub const ShellExecute = thismodule.ShellExecuteW;
        pub const FindExecutable = thismodule.FindExecutableW;
        pub const ShellAbout = thismodule.ShellAboutW;
        pub const ExtractAssociatedIcon = thismodule.ExtractAssociatedIconW;
        pub const ExtractAssociatedIconEx = thismodule.ExtractAssociatedIconExW;
        pub const ExtractIcon = thismodule.ExtractIconW;
        pub const DoEnvironmentSubst = thismodule.DoEnvironmentSubstW;
        pub const ExtractIconEx = thismodule.ExtractIconExW;
        pub const SHFileOperation = thismodule.SHFileOperationW;
        pub const ShellExecuteEx = thismodule.ShellExecuteExW;
        pub const SHQueryRecycleBin = thismodule.SHQueryRecycleBinW;
        pub const SHEmptyRecycleBin = thismodule.SHEmptyRecycleBinW;
        pub const Shell_NotifyIcon = thismodule.Shell_NotifyIconW;
        pub const SHGetFileInfo = thismodule.SHGetFileInfoW;
        pub const SHGetDiskFreeSpaceEx = thismodule.SHGetDiskFreeSpaceExW;
        pub const SHGetNewLinkInfo = thismodule.SHGetNewLinkInfoW;
        pub const SHInvokePrinterCommand = thismodule.SHInvokePrinterCommandW;
        pub const ShellMessageBox = thismodule.ShellMessageBoxW;
        pub const IsLFNDrive = thismodule.IsLFNDriveW;
        pub const StrChr = thismodule.StrChrW;
        pub const StrChrI = thismodule.StrChrIW;
        pub const StrCmpN = thismodule.StrCmpNW;
        pub const StrCmpNI = thismodule.StrCmpNIW;
        pub const StrCSpn = thismodule.StrCSpnW;
        pub const StrCSpnI = thismodule.StrCSpnIW;
        pub const StrDup = thismodule.StrDupW;
        pub const StrFormatByteSize = thismodule.StrFormatByteSizeW;
        pub const StrFormatKBSize = thismodule.StrFormatKBSizeW;
        pub const StrFromTimeInterval = thismodule.StrFromTimeIntervalW;
        pub const StrIsIntlEqual = thismodule.StrIsIntlEqualW;
        pub const StrNCat = thismodule.StrNCatW;
        pub const StrPBrk = thismodule.StrPBrkW;
        pub const StrRChr = thismodule.StrRChrW;
        pub const StrRChrI = thismodule.StrRChrIW;
        pub const StrRStrI = thismodule.StrRStrIW;
        pub const StrSpn = thismodule.StrSpnW;
        pub const StrStr = thismodule.StrStrW;
        pub const StrStrI = thismodule.StrStrIW;
        pub const StrToInt = thismodule.StrToIntW;
        pub const StrToIntEx = thismodule.StrToIntExW;
        pub const StrToInt64Ex = thismodule.StrToInt64ExW;
        pub const StrTrim = thismodule.StrTrimW;
        pub const StrCatBuff = thismodule.StrCatBuffW;
        pub const ChrCmpI = thismodule.ChrCmpIW;
        pub const wvnsprintf = thismodule.wvnsprintfW;
        pub const wnsprintf = thismodule.wnsprintfW;
        pub const StrRetToStr = thismodule.StrRetToStrW;
        pub const StrRetToBuf = thismodule.StrRetToBufW;
        pub const SHStrDup = thismodule.SHStrDupW;
        pub const IsCharSpace = thismodule.IsCharSpaceW;
        pub const StrCmpC = thismodule.StrCmpCW;
        pub const StrCmpIC = thismodule.StrCmpICW;
        pub const StrCmpNC = thismodule.StrCmpNCW;
        pub const StrCmpNIC = thismodule.StrCmpNICW;
        pub const IntlStrEqWorker = thismodule.IntlStrEqWorkerW;
        pub const PathAddBackslash = thismodule.PathAddBackslashW;
        pub const PathAddExtension = thismodule.PathAddExtensionW;
        pub const PathAppend = thismodule.PathAppendW;
        pub const PathBuildRoot = thismodule.PathBuildRootW;
        pub const PathCanonicalize = thismodule.PathCanonicalizeW;
        pub const PathCombine = thismodule.PathCombineW;
        pub const PathCompactPath = thismodule.PathCompactPathW;
        pub const PathCompactPathEx = thismodule.PathCompactPathExW;
        pub const PathCommonPrefix = thismodule.PathCommonPrefixW;
        pub const PathFileExists = thismodule.PathFileExistsW;
        pub const PathFindExtension = thismodule.PathFindExtensionW;
        pub const PathFindFileName = thismodule.PathFindFileNameW;
        pub const PathFindNextComponent = thismodule.PathFindNextComponentW;
        pub const PathFindOnPath = thismodule.PathFindOnPathW;
        pub const PathFindSuffixArray = thismodule.PathFindSuffixArrayW;
        pub const PathGetArgs = thismodule.PathGetArgsW;
        pub const PathIsLFNFileSpec = thismodule.PathIsLFNFileSpecW;
        pub const PathGetCharType = thismodule.PathGetCharTypeW;
        pub const PathGetDriveNumber = thismodule.PathGetDriveNumberW;
        pub const PathIsDirectory = thismodule.PathIsDirectoryW;
        pub const PathIsDirectoryEmpty = thismodule.PathIsDirectoryEmptyW;
        pub const PathIsFileSpec = thismodule.PathIsFileSpecW;
        pub const PathIsPrefix = thismodule.PathIsPrefixW;
        pub const PathIsRelative = thismodule.PathIsRelativeW;
        pub const PathIsRoot = thismodule.PathIsRootW;
        pub const PathIsSameRoot = thismodule.PathIsSameRootW;
        pub const PathIsUNC = thismodule.PathIsUNCW;
        pub const PathIsNetworkPath = thismodule.PathIsNetworkPathW;
        pub const PathIsUNCServer = thismodule.PathIsUNCServerW;
        pub const PathIsUNCServerShare = thismodule.PathIsUNCServerShareW;
        pub const PathIsContentType = thismodule.PathIsContentTypeW;
        pub const PathIsURL = thismodule.PathIsURLW;
        pub const PathMakePretty = thismodule.PathMakePrettyW;
        pub const PathMatchSpec = thismodule.PathMatchSpecW;
        pub const PathMatchSpecEx = thismodule.PathMatchSpecExW;
        pub const PathParseIconLocation = thismodule.PathParseIconLocationW;
        pub const PathQuoteSpaces = thismodule.PathQuoteSpacesW;
        pub const PathRelativePathTo = thismodule.PathRelativePathToW;
        pub const PathRemoveArgs = thismodule.PathRemoveArgsW;
        pub const PathRemoveBackslash = thismodule.PathRemoveBackslashW;
        pub const PathRemoveBlanks = thismodule.PathRemoveBlanksW;
        pub const PathRemoveExtension = thismodule.PathRemoveExtensionW;
        pub const PathRemoveFileSpec = thismodule.PathRemoveFileSpecW;
        pub const PathRenameExtension = thismodule.PathRenameExtensionW;
        pub const PathSearchAndQualify = thismodule.PathSearchAndQualifyW;
        pub const PathSetDlgItemPath = thismodule.PathSetDlgItemPathW;
        pub const PathSkipRoot = thismodule.PathSkipRootW;
        pub const PathStripPath = thismodule.PathStripPathW;
        pub const PathStripToRoot = thismodule.PathStripToRootW;
        pub const PathUnquoteSpaces = thismodule.PathUnquoteSpacesW;
        pub const PathMakeSystemFolder = thismodule.PathMakeSystemFolderW;
        pub const PathUnmakeSystemFolder = thismodule.PathUnmakeSystemFolderW;
        pub const PathIsSystemFolder = thismodule.PathIsSystemFolderW;
        pub const PathUndecorate = thismodule.PathUndecorateW;
        pub const PathUnExpandEnvStrings = thismodule.PathUnExpandEnvStringsW;
        pub const UrlCompare = thismodule.UrlCompareW;
        pub const UrlCombine = thismodule.UrlCombineW;
        pub const UrlCanonicalize = thismodule.UrlCanonicalizeW;
        pub const UrlIsOpaque = thismodule.UrlIsOpaqueW;
        pub const UrlIsNoHistory = thismodule.UrlIsNoHistoryW;
        pub const UrlIs = thismodule.UrlIsW;
        pub const UrlGetLocation = thismodule.UrlGetLocationW;
        pub const UrlUnescape = thismodule.UrlUnescapeW;
        pub const UrlEscape = thismodule.UrlEscapeW;
        pub const UrlCreateFromPath = thismodule.UrlCreateFromPathW;
        pub const PathCreateFromUrl = thismodule.PathCreateFromUrlW;
        pub const UrlHash = thismodule.UrlHashW;
        pub const UrlGetPart = thismodule.UrlGetPartW;
        pub const UrlApplyScheme = thismodule.UrlApplySchemeW;
        pub const ParseURL = thismodule.ParseURLW;
        pub const SHDeleteEmptyKey = thismodule.SHDeleteEmptyKeyW;
        pub const SHDeleteKey = thismodule.SHDeleteKeyW;
        pub const SHDeleteValue = thismodule.SHDeleteValueW;
        pub const SHGetValue = thismodule.SHGetValueW;
        pub const SHSetValue = thismodule.SHSetValueW;
        pub const SHRegGetValue = thismodule.SHRegGetValueW;
        pub const SHQueryValueEx = thismodule.SHQueryValueExW;
        pub const SHEnumKeyEx = thismodule.SHEnumKeyExW;
        pub const SHEnumValue = thismodule.SHEnumValueW;
        pub const SHQueryInfoKey = thismodule.SHQueryInfoKeyW;
        pub const SHCopyKey = thismodule.SHCopyKeyW;
        pub const SHRegGetPath = thismodule.SHRegGetPathW;
        pub const SHRegSetPath = thismodule.SHRegSetPathW;
        pub const SHRegCreateUSKey = thismodule.SHRegCreateUSKeyW;
        pub const SHRegOpenUSKey = thismodule.SHRegOpenUSKeyW;
        pub const SHRegQueryUSValue = thismodule.SHRegQueryUSValueW;
        pub const SHRegWriteUSValue = thismodule.SHRegWriteUSValueW;
        pub const SHRegDeleteUSValue = thismodule.SHRegDeleteUSValueW;
        pub const SHRegDeleteEmptyUSKey = thismodule.SHRegDeleteEmptyUSKeyW;
        pub const SHRegEnumUSKey = thismodule.SHRegEnumUSKeyW;
        pub const SHRegEnumUSValue = thismodule.SHRegEnumUSValueW;
        pub const SHRegQueryInfoUSKey = thismodule.SHRegQueryInfoUSKeyW;
        pub const SHRegGetUSValue = thismodule.SHRegGetUSValueW;
        pub const SHRegSetUSValue = thismodule.SHRegSetUSValueW;
        pub const SHRegGetBoolUSValue = thismodule.SHRegGetBoolUSValueW;
        pub const AssocQueryString = thismodule.AssocQueryStringW;
        pub const AssocQueryStringByKey = thismodule.AssocQueryStringByKeyW;
        pub const AssocQueryKey = thismodule.AssocQueryKeyW;
        pub const SHOpenRegStream = thismodule.SHOpenRegStreamW;
        pub const SHOpenRegStream2 = thismodule.SHOpenRegStream2W;
        pub const SHCreateStreamOnFile = thismodule.SHCreateStreamOnFileW;
        pub const GetAcceptLanguages = thismodule.GetAcceptLanguagesW;
        pub const SHFormatDateTime = thismodule.SHFormatDateTimeW;
        pub const SHMessageBoxCheck = thismodule.SHMessageBoxCheckW;
        pub const SHSendMessageBroadcast = thismodule.SHSendMessageBroadcastW;
        pub const SHStripMneumonic = thismodule.SHStripMneumonicW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const MULTIKEYHELP = *opaque{};
        pub const HELPWININFO = *opaque{};
        pub const IShellLink = *opaque{};
        pub const IExtractIcon = *opaque{};
        pub const BROWSEINFO = *opaque{};
        pub const FILEDESCRIPTOR = *opaque{};
        pub const FILEGROUPDESCRIPTOR = *opaque{};
        pub const SHELLSTATE = *opaque{};
        pub const INewShortcutHook = *opaque{};
        pub const ICopyHook = *opaque{};
        pub const DRAGINFO = *opaque{};
        pub const SHFILEOPSTRUCT = *opaque{};
        pub const SHNAMEMAPPING = *opaque{};
        pub const SHELLEXECUTEINFO = *opaque{};
        pub const NOTIFYICONDATA = *opaque{};
        pub const SHFILEINFO = *opaque{};
        pub const OPEN_PRINTER_PROPS_INFO = *opaque{};
        pub const PARSEDURL = *opaque{};
        pub const NEWCPLINFO = *opaque{};
        pub const PROFILEINFO = *opaque{};
        pub const urlinvokecommandinfo = *opaque{};
        pub const IUniformResourceLocator = *opaque{};
        pub const LoadUserProfile = *opaque{};
        pub const GetProfilesDirectory = *opaque{};
        pub const DeleteProfile = *opaque{};
        pub const GetDefaultUserProfileDirectory = *opaque{};
        pub const GetAllUsersProfileDirectory = *opaque{};
        pub const GetUserProfileDirectory = *opaque{};
        pub const WinHelp = *opaque{};
        pub const SHGetIconOverlayIndex = *opaque{};
        pub const ILCreateFromPath = *opaque{};
        pub const SHGetPathFromIDList = *opaque{};
        pub const SHCreateDirectoryEx = *opaque{};
        pub const SHGetSpecialFolderPath = *opaque{};
        pub const SHGetFolderPath = *opaque{};
        pub const SHSetFolderPath = *opaque{};
        pub const SHGetFolderPathAndSubDir = *opaque{};
        pub const SHBrowseForFolder = *opaque{};
        pub const SHUpdateImage = *opaque{};
        pub const SHGetDataFromIDList = *opaque{};
        pub const SHDefExtractIcon = *opaque{};
        pub const SHPathPrepareForWrite = *opaque{};
        pub const PathIsSlow = *opaque{};
        pub const DragQueryFile = *opaque{};
        pub const ShellExecute = *opaque{};
        pub const FindExecutable = *opaque{};
        pub const ShellAbout = *opaque{};
        pub const ExtractAssociatedIcon = *opaque{};
        pub const ExtractAssociatedIconEx = *opaque{};
        pub const ExtractIcon = *opaque{};
        pub const DoEnvironmentSubst = *opaque{};
        pub const ExtractIconEx = *opaque{};
        pub const SHFileOperation = *opaque{};
        pub const ShellExecuteEx = *opaque{};
        pub const SHQueryRecycleBin = *opaque{};
        pub const SHEmptyRecycleBin = *opaque{};
        pub const Shell_NotifyIcon = *opaque{};
        pub const SHGetFileInfo = *opaque{};
        pub const SHGetDiskFreeSpaceEx = *opaque{};
        pub const SHGetNewLinkInfo = *opaque{};
        pub const SHInvokePrinterCommand = *opaque{};
        pub const ShellMessageBox = *opaque{};
        pub const IsLFNDrive = *opaque{};
        pub const StrChr = *opaque{};
        pub const StrChrI = *opaque{};
        pub const StrCmpN = *opaque{};
        pub const StrCmpNI = *opaque{};
        pub const StrCSpn = *opaque{};
        pub const StrCSpnI = *opaque{};
        pub const StrDup = *opaque{};
        pub const StrFormatByteSize = *opaque{};
        pub const StrFormatKBSize = *opaque{};
        pub const StrFromTimeInterval = *opaque{};
        pub const StrIsIntlEqual = *opaque{};
        pub const StrNCat = *opaque{};
        pub const StrPBrk = *opaque{};
        pub const StrRChr = *opaque{};
        pub const StrRChrI = *opaque{};
        pub const StrRStrI = *opaque{};
        pub const StrSpn = *opaque{};
        pub const StrStr = *opaque{};
        pub const StrStrI = *opaque{};
        pub const StrToInt = *opaque{};
        pub const StrToIntEx = *opaque{};
        pub const StrToInt64Ex = *opaque{};
        pub const StrTrim = *opaque{};
        pub const StrCatBuff = *opaque{};
        pub const ChrCmpI = *opaque{};
        pub const wvnsprintf = *opaque{};
        pub const wnsprintf = *opaque{};
        pub const StrRetToStr = *opaque{};
        pub const StrRetToBuf = *opaque{};
        pub const SHStrDup = *opaque{};
        pub const IsCharSpace = *opaque{};
        pub const StrCmpC = *opaque{};
        pub const StrCmpIC = *opaque{};
        pub const StrCmpNC = *opaque{};
        pub const StrCmpNIC = *opaque{};
        pub const IntlStrEqWorker = *opaque{};
        pub const PathAddBackslash = *opaque{};
        pub const PathAddExtension = *opaque{};
        pub const PathAppend = *opaque{};
        pub const PathBuildRoot = *opaque{};
        pub const PathCanonicalize = *opaque{};
        pub const PathCombine = *opaque{};
        pub const PathCompactPath = *opaque{};
        pub const PathCompactPathEx = *opaque{};
        pub const PathCommonPrefix = *opaque{};
        pub const PathFileExists = *opaque{};
        pub const PathFindExtension = *opaque{};
        pub const PathFindFileName = *opaque{};
        pub const PathFindNextComponent = *opaque{};
        pub const PathFindOnPath = *opaque{};
        pub const PathFindSuffixArray = *opaque{};
        pub const PathGetArgs = *opaque{};
        pub const PathIsLFNFileSpec = *opaque{};
        pub const PathGetCharType = *opaque{};
        pub const PathGetDriveNumber = *opaque{};
        pub const PathIsDirectory = *opaque{};
        pub const PathIsDirectoryEmpty = *opaque{};
        pub const PathIsFileSpec = *opaque{};
        pub const PathIsPrefix = *opaque{};
        pub const PathIsRelative = *opaque{};
        pub const PathIsRoot = *opaque{};
        pub const PathIsSameRoot = *opaque{};
        pub const PathIsUNC = *opaque{};
        pub const PathIsNetworkPath = *opaque{};
        pub const PathIsUNCServer = *opaque{};
        pub const PathIsUNCServerShare = *opaque{};
        pub const PathIsContentType = *opaque{};
        pub const PathIsURL = *opaque{};
        pub const PathMakePretty = *opaque{};
        pub const PathMatchSpec = *opaque{};
        pub const PathMatchSpecEx = *opaque{};
        pub const PathParseIconLocation = *opaque{};
        pub const PathQuoteSpaces = *opaque{};
        pub const PathRelativePathTo = *opaque{};
        pub const PathRemoveArgs = *opaque{};
        pub const PathRemoveBackslash = *opaque{};
        pub const PathRemoveBlanks = *opaque{};
        pub const PathRemoveExtension = *opaque{};
        pub const PathRemoveFileSpec = *opaque{};
        pub const PathRenameExtension = *opaque{};
        pub const PathSearchAndQualify = *opaque{};
        pub const PathSetDlgItemPath = *opaque{};
        pub const PathSkipRoot = *opaque{};
        pub const PathStripPath = *opaque{};
        pub const PathStripToRoot = *opaque{};
        pub const PathUnquoteSpaces = *opaque{};
        pub const PathMakeSystemFolder = *opaque{};
        pub const PathUnmakeSystemFolder = *opaque{};
        pub const PathIsSystemFolder = *opaque{};
        pub const PathUndecorate = *opaque{};
        pub const PathUnExpandEnvStrings = *opaque{};
        pub const UrlCompare = *opaque{};
        pub const UrlCombine = *opaque{};
        pub const UrlCanonicalize = *opaque{};
        pub const UrlIsOpaque = *opaque{};
        pub const UrlIsNoHistory = *opaque{};
        pub const UrlIs = *opaque{};
        pub const UrlGetLocation = *opaque{};
        pub const UrlUnescape = *opaque{};
        pub const UrlEscape = *opaque{};
        pub const UrlCreateFromPath = *opaque{};
        pub const PathCreateFromUrl = *opaque{};
        pub const UrlHash = *opaque{};
        pub const UrlGetPart = *opaque{};
        pub const UrlApplyScheme = *opaque{};
        pub const ParseURL = *opaque{};
        pub const SHDeleteEmptyKey = *opaque{};
        pub const SHDeleteKey = *opaque{};
        pub const SHDeleteValue = *opaque{};
        pub const SHGetValue = *opaque{};
        pub const SHSetValue = *opaque{};
        pub const SHRegGetValue = *opaque{};
        pub const SHQueryValueEx = *opaque{};
        pub const SHEnumKeyEx = *opaque{};
        pub const SHEnumValue = *opaque{};
        pub const SHQueryInfoKey = *opaque{};
        pub const SHCopyKey = *opaque{};
        pub const SHRegGetPath = *opaque{};
        pub const SHRegSetPath = *opaque{};
        pub const SHRegCreateUSKey = *opaque{};
        pub const SHRegOpenUSKey = *opaque{};
        pub const SHRegQueryUSValue = *opaque{};
        pub const SHRegWriteUSValue = *opaque{};
        pub const SHRegDeleteUSValue = *opaque{};
        pub const SHRegDeleteEmptyUSKey = *opaque{};
        pub const SHRegEnumUSKey = *opaque{};
        pub const SHRegEnumUSValue = *opaque{};
        pub const SHRegQueryInfoUSKey = *opaque{};
        pub const SHRegGetUSValue = *opaque{};
        pub const SHRegSetUSValue = *opaque{};
        pub const SHRegGetBoolUSValue = *opaque{};
        pub const AssocQueryString = *opaque{};
        pub const AssocQueryStringByKey = *opaque{};
        pub const AssocQueryKey = *opaque{};
        pub const SHOpenRegStream = *opaque{};
        pub const SHOpenRegStream2 = *opaque{};
        pub const SHCreateStreamOnFile = *opaque{};
        pub const GetAcceptLanguages = *opaque{};
        pub const SHFormatDateTime = *opaque{};
        pub const SHMessageBoxCheck = *opaque{};
        pub const SHSendMessageBroadcast = *opaque{};
        pub const SHStripMneumonic = *opaque{};
    } else struct {
        pub const MULTIKEYHELP = @compileError("'MULTIKEYHELP' requires that UNICODE be set to true or false in the root module");
        pub const HELPWININFO = @compileError("'HELPWININFO' requires that UNICODE be set to true or false in the root module");
        pub const IShellLink = @compileError("'IShellLink' requires that UNICODE be set to true or false in the root module");
        pub const IExtractIcon = @compileError("'IExtractIcon' requires that UNICODE be set to true or false in the root module");
        pub const BROWSEINFO = @compileError("'BROWSEINFO' requires that UNICODE be set to true or false in the root module");
        pub const FILEDESCRIPTOR = @compileError("'FILEDESCRIPTOR' requires that UNICODE be set to true or false in the root module");
        pub const FILEGROUPDESCRIPTOR = @compileError("'FILEGROUPDESCRIPTOR' requires that UNICODE be set to true or false in the root module");
        pub const SHELLSTATE = @compileError("'SHELLSTATE' requires that UNICODE be set to true or false in the root module");
        pub const INewShortcutHook = @compileError("'INewShortcutHook' requires that UNICODE be set to true or false in the root module");
        pub const ICopyHook = @compileError("'ICopyHook' requires that UNICODE be set to true or false in the root module");
        pub const DRAGINFO = @compileError("'DRAGINFO' requires that UNICODE be set to true or false in the root module");
        pub const SHFILEOPSTRUCT = @compileError("'SHFILEOPSTRUCT' requires that UNICODE be set to true or false in the root module");
        pub const SHNAMEMAPPING = @compileError("'SHNAMEMAPPING' requires that UNICODE be set to true or false in the root module");
        pub const SHELLEXECUTEINFO = @compileError("'SHELLEXECUTEINFO' requires that UNICODE be set to true or false in the root module");
        pub const NOTIFYICONDATA = @compileError("'NOTIFYICONDATA' requires that UNICODE be set to true or false in the root module");
        pub const SHFILEINFO = @compileError("'SHFILEINFO' requires that UNICODE be set to true or false in the root module");
        pub const OPEN_PRINTER_PROPS_INFO = @compileError("'OPEN_PRINTER_PROPS_INFO' requires that UNICODE be set to true or false in the root module");
        pub const PARSEDURL = @compileError("'PARSEDURL' requires that UNICODE be set to true or false in the root module");
        pub const NEWCPLINFO = @compileError("'NEWCPLINFO' requires that UNICODE be set to true or false in the root module");
        pub const PROFILEINFO = @compileError("'PROFILEINFO' requires that UNICODE be set to true or false in the root module");
        pub const urlinvokecommandinfo = @compileError("'urlinvokecommandinfo' requires that UNICODE be set to true or false in the root module");
        pub const IUniformResourceLocator = @compileError("'IUniformResourceLocator' requires that UNICODE be set to true or false in the root module");
        pub const LoadUserProfile = @compileError("'LoadUserProfile' requires that UNICODE be set to true or false in the root module");
        pub const GetProfilesDirectory = @compileError("'GetProfilesDirectory' requires that UNICODE be set to true or false in the root module");
        pub const DeleteProfile = @compileError("'DeleteProfile' requires that UNICODE be set to true or false in the root module");
        pub const GetDefaultUserProfileDirectory = @compileError("'GetDefaultUserProfileDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetAllUsersProfileDirectory = @compileError("'GetAllUsersProfileDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetUserProfileDirectory = @compileError("'GetUserProfileDirectory' requires that UNICODE be set to true or false in the root module");
        pub const WinHelp = @compileError("'WinHelp' requires that UNICODE be set to true or false in the root module");
        pub const SHGetIconOverlayIndex = @compileError("'SHGetIconOverlayIndex' requires that UNICODE be set to true or false in the root module");
        pub const ILCreateFromPath = @compileError("'ILCreateFromPath' requires that UNICODE be set to true or false in the root module");
        pub const SHGetPathFromIDList = @compileError("'SHGetPathFromIDList' requires that UNICODE be set to true or false in the root module");
        pub const SHCreateDirectoryEx = @compileError("'SHCreateDirectoryEx' requires that UNICODE be set to true or false in the root module");
        pub const SHGetSpecialFolderPath = @compileError("'SHGetSpecialFolderPath' requires that UNICODE be set to true or false in the root module");
        pub const SHGetFolderPath = @compileError("'SHGetFolderPath' requires that UNICODE be set to true or false in the root module");
        pub const SHSetFolderPath = @compileError("'SHSetFolderPath' requires that UNICODE be set to true or false in the root module");
        pub const SHGetFolderPathAndSubDir = @compileError("'SHGetFolderPathAndSubDir' requires that UNICODE be set to true or false in the root module");
        pub const SHBrowseForFolder = @compileError("'SHBrowseForFolder' requires that UNICODE be set to true or false in the root module");
        pub const SHUpdateImage = @compileError("'SHUpdateImage' requires that UNICODE be set to true or false in the root module");
        pub const SHGetDataFromIDList = @compileError("'SHGetDataFromIDList' requires that UNICODE be set to true or false in the root module");
        pub const SHDefExtractIcon = @compileError("'SHDefExtractIcon' requires that UNICODE be set to true or false in the root module");
        pub const SHPathPrepareForWrite = @compileError("'SHPathPrepareForWrite' requires that UNICODE be set to true or false in the root module");
        pub const PathIsSlow = @compileError("'PathIsSlow' requires that UNICODE be set to true or false in the root module");
        pub const DragQueryFile = @compileError("'DragQueryFile' requires that UNICODE be set to true or false in the root module");
        pub const ShellExecute = @compileError("'ShellExecute' requires that UNICODE be set to true or false in the root module");
        pub const FindExecutable = @compileError("'FindExecutable' requires that UNICODE be set to true or false in the root module");
        pub const ShellAbout = @compileError("'ShellAbout' requires that UNICODE be set to true or false in the root module");
        pub const ExtractAssociatedIcon = @compileError("'ExtractAssociatedIcon' requires that UNICODE be set to true or false in the root module");
        pub const ExtractAssociatedIconEx = @compileError("'ExtractAssociatedIconEx' requires that UNICODE be set to true or false in the root module");
        pub const ExtractIcon = @compileError("'ExtractIcon' requires that UNICODE be set to true or false in the root module");
        pub const DoEnvironmentSubst = @compileError("'DoEnvironmentSubst' requires that UNICODE be set to true or false in the root module");
        pub const ExtractIconEx = @compileError("'ExtractIconEx' requires that UNICODE be set to true or false in the root module");
        pub const SHFileOperation = @compileError("'SHFileOperation' requires that UNICODE be set to true or false in the root module");
        pub const ShellExecuteEx = @compileError("'ShellExecuteEx' requires that UNICODE be set to true or false in the root module");
        pub const SHQueryRecycleBin = @compileError("'SHQueryRecycleBin' requires that UNICODE be set to true or false in the root module");
        pub const SHEmptyRecycleBin = @compileError("'SHEmptyRecycleBin' requires that UNICODE be set to true or false in the root module");
        pub const Shell_NotifyIcon = @compileError("'Shell_NotifyIcon' requires that UNICODE be set to true or false in the root module");
        pub const SHGetFileInfo = @compileError("'SHGetFileInfo' requires that UNICODE be set to true or false in the root module");
        pub const SHGetDiskFreeSpaceEx = @compileError("'SHGetDiskFreeSpaceEx' requires that UNICODE be set to true or false in the root module");
        pub const SHGetNewLinkInfo = @compileError("'SHGetNewLinkInfo' requires that UNICODE be set to true or false in the root module");
        pub const SHInvokePrinterCommand = @compileError("'SHInvokePrinterCommand' requires that UNICODE be set to true or false in the root module");
        pub const ShellMessageBox = @compileError("'ShellMessageBox' requires that UNICODE be set to true or false in the root module");
        pub const IsLFNDrive = @compileError("'IsLFNDrive' requires that UNICODE be set to true or false in the root module");
        pub const StrChr = @compileError("'StrChr' requires that UNICODE be set to true or false in the root module");
        pub const StrChrI = @compileError("'StrChrI' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpN = @compileError("'StrCmpN' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpNI = @compileError("'StrCmpNI' requires that UNICODE be set to true or false in the root module");
        pub const StrCSpn = @compileError("'StrCSpn' requires that UNICODE be set to true or false in the root module");
        pub const StrCSpnI = @compileError("'StrCSpnI' requires that UNICODE be set to true or false in the root module");
        pub const StrDup = @compileError("'StrDup' requires that UNICODE be set to true or false in the root module");
        pub const StrFormatByteSize = @compileError("'StrFormatByteSize' requires that UNICODE be set to true or false in the root module");
        pub const StrFormatKBSize = @compileError("'StrFormatKBSize' requires that UNICODE be set to true or false in the root module");
        pub const StrFromTimeInterval = @compileError("'StrFromTimeInterval' requires that UNICODE be set to true or false in the root module");
        pub const StrIsIntlEqual = @compileError("'StrIsIntlEqual' requires that UNICODE be set to true or false in the root module");
        pub const StrNCat = @compileError("'StrNCat' requires that UNICODE be set to true or false in the root module");
        pub const StrPBrk = @compileError("'StrPBrk' requires that UNICODE be set to true or false in the root module");
        pub const StrRChr = @compileError("'StrRChr' requires that UNICODE be set to true or false in the root module");
        pub const StrRChrI = @compileError("'StrRChrI' requires that UNICODE be set to true or false in the root module");
        pub const StrRStrI = @compileError("'StrRStrI' requires that UNICODE be set to true or false in the root module");
        pub const StrSpn = @compileError("'StrSpn' requires that UNICODE be set to true or false in the root module");
        pub const StrStr = @compileError("'StrStr' requires that UNICODE be set to true or false in the root module");
        pub const StrStrI = @compileError("'StrStrI' requires that UNICODE be set to true or false in the root module");
        pub const StrToInt = @compileError("'StrToInt' requires that UNICODE be set to true or false in the root module");
        pub const StrToIntEx = @compileError("'StrToIntEx' requires that UNICODE be set to true or false in the root module");
        pub const StrToInt64Ex = @compileError("'StrToInt64Ex' requires that UNICODE be set to true or false in the root module");
        pub const StrTrim = @compileError("'StrTrim' requires that UNICODE be set to true or false in the root module");
        pub const StrCatBuff = @compileError("'StrCatBuff' requires that UNICODE be set to true or false in the root module");
        pub const ChrCmpI = @compileError("'ChrCmpI' requires that UNICODE be set to true or false in the root module");
        pub const wvnsprintf = @compileError("'wvnsprintf' requires that UNICODE be set to true or false in the root module");
        pub const wnsprintf = @compileError("'wnsprintf' requires that UNICODE be set to true or false in the root module");
        pub const StrRetToStr = @compileError("'StrRetToStr' requires that UNICODE be set to true or false in the root module");
        pub const StrRetToBuf = @compileError("'StrRetToBuf' requires that UNICODE be set to true or false in the root module");
        pub const SHStrDup = @compileError("'SHStrDup' requires that UNICODE be set to true or false in the root module");
        pub const IsCharSpace = @compileError("'IsCharSpace' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpC = @compileError("'StrCmpC' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpIC = @compileError("'StrCmpIC' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpNC = @compileError("'StrCmpNC' requires that UNICODE be set to true or false in the root module");
        pub const StrCmpNIC = @compileError("'StrCmpNIC' requires that UNICODE be set to true or false in the root module");
        pub const IntlStrEqWorker = @compileError("'IntlStrEqWorker' requires that UNICODE be set to true or false in the root module");
        pub const PathAddBackslash = @compileError("'PathAddBackslash' requires that UNICODE be set to true or false in the root module");
        pub const PathAddExtension = @compileError("'PathAddExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathAppend = @compileError("'PathAppend' requires that UNICODE be set to true or false in the root module");
        pub const PathBuildRoot = @compileError("'PathBuildRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathCanonicalize = @compileError("'PathCanonicalize' requires that UNICODE be set to true or false in the root module");
        pub const PathCombine = @compileError("'PathCombine' requires that UNICODE be set to true or false in the root module");
        pub const PathCompactPath = @compileError("'PathCompactPath' requires that UNICODE be set to true or false in the root module");
        pub const PathCompactPathEx = @compileError("'PathCompactPathEx' requires that UNICODE be set to true or false in the root module");
        pub const PathCommonPrefix = @compileError("'PathCommonPrefix' requires that UNICODE be set to true or false in the root module");
        pub const PathFileExists = @compileError("'PathFileExists' requires that UNICODE be set to true or false in the root module");
        pub const PathFindExtension = @compileError("'PathFindExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathFindFileName = @compileError("'PathFindFileName' requires that UNICODE be set to true or false in the root module");
        pub const PathFindNextComponent = @compileError("'PathFindNextComponent' requires that UNICODE be set to true or false in the root module");
        pub const PathFindOnPath = @compileError("'PathFindOnPath' requires that UNICODE be set to true or false in the root module");
        pub const PathFindSuffixArray = @compileError("'PathFindSuffixArray' requires that UNICODE be set to true or false in the root module");
        pub const PathGetArgs = @compileError("'PathGetArgs' requires that UNICODE be set to true or false in the root module");
        pub const PathIsLFNFileSpec = @compileError("'PathIsLFNFileSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathGetCharType = @compileError("'PathGetCharType' requires that UNICODE be set to true or false in the root module");
        pub const PathGetDriveNumber = @compileError("'PathGetDriveNumber' requires that UNICODE be set to true or false in the root module");
        pub const PathIsDirectory = @compileError("'PathIsDirectory' requires that UNICODE be set to true or false in the root module");
        pub const PathIsDirectoryEmpty = @compileError("'PathIsDirectoryEmpty' requires that UNICODE be set to true or false in the root module");
        pub const PathIsFileSpec = @compileError("'PathIsFileSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathIsPrefix = @compileError("'PathIsPrefix' requires that UNICODE be set to true or false in the root module");
        pub const PathIsRelative = @compileError("'PathIsRelative' requires that UNICODE be set to true or false in the root module");
        pub const PathIsRoot = @compileError("'PathIsRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathIsSameRoot = @compileError("'PathIsSameRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathIsUNC = @compileError("'PathIsUNC' requires that UNICODE be set to true or false in the root module");
        pub const PathIsNetworkPath = @compileError("'PathIsNetworkPath' requires that UNICODE be set to true or false in the root module");
        pub const PathIsUNCServer = @compileError("'PathIsUNCServer' requires that UNICODE be set to true or false in the root module");
        pub const PathIsUNCServerShare = @compileError("'PathIsUNCServerShare' requires that UNICODE be set to true or false in the root module");
        pub const PathIsContentType = @compileError("'PathIsContentType' requires that UNICODE be set to true or false in the root module");
        pub const PathIsURL = @compileError("'PathIsURL' requires that UNICODE be set to true or false in the root module");
        pub const PathMakePretty = @compileError("'PathMakePretty' requires that UNICODE be set to true or false in the root module");
        pub const PathMatchSpec = @compileError("'PathMatchSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathMatchSpecEx = @compileError("'PathMatchSpecEx' requires that UNICODE be set to true or false in the root module");
        pub const PathParseIconLocation = @compileError("'PathParseIconLocation' requires that UNICODE be set to true or false in the root module");
        pub const PathQuoteSpaces = @compileError("'PathQuoteSpaces' requires that UNICODE be set to true or false in the root module");
        pub const PathRelativePathTo = @compileError("'PathRelativePathTo' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveArgs = @compileError("'PathRemoveArgs' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveBackslash = @compileError("'PathRemoveBackslash' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveBlanks = @compileError("'PathRemoveBlanks' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveExtension = @compileError("'PathRemoveExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathRemoveFileSpec = @compileError("'PathRemoveFileSpec' requires that UNICODE be set to true or false in the root module");
        pub const PathRenameExtension = @compileError("'PathRenameExtension' requires that UNICODE be set to true or false in the root module");
        pub const PathSearchAndQualify = @compileError("'PathSearchAndQualify' requires that UNICODE be set to true or false in the root module");
        pub const PathSetDlgItemPath = @compileError("'PathSetDlgItemPath' requires that UNICODE be set to true or false in the root module");
        pub const PathSkipRoot = @compileError("'PathSkipRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathStripPath = @compileError("'PathStripPath' requires that UNICODE be set to true or false in the root module");
        pub const PathStripToRoot = @compileError("'PathStripToRoot' requires that UNICODE be set to true or false in the root module");
        pub const PathUnquoteSpaces = @compileError("'PathUnquoteSpaces' requires that UNICODE be set to true or false in the root module");
        pub const PathMakeSystemFolder = @compileError("'PathMakeSystemFolder' requires that UNICODE be set to true or false in the root module");
        pub const PathUnmakeSystemFolder = @compileError("'PathUnmakeSystemFolder' requires that UNICODE be set to true or false in the root module");
        pub const PathIsSystemFolder = @compileError("'PathIsSystemFolder' requires that UNICODE be set to true or false in the root module");
        pub const PathUndecorate = @compileError("'PathUndecorate' requires that UNICODE be set to true or false in the root module");
        pub const PathUnExpandEnvStrings = @compileError("'PathUnExpandEnvStrings' requires that UNICODE be set to true or false in the root module");
        pub const UrlCompare = @compileError("'UrlCompare' requires that UNICODE be set to true or false in the root module");
        pub const UrlCombine = @compileError("'UrlCombine' requires that UNICODE be set to true or false in the root module");
        pub const UrlCanonicalize = @compileError("'UrlCanonicalize' requires that UNICODE be set to true or false in the root module");
        pub const UrlIsOpaque = @compileError("'UrlIsOpaque' requires that UNICODE be set to true or false in the root module");
        pub const UrlIsNoHistory = @compileError("'UrlIsNoHistory' requires that UNICODE be set to true or false in the root module");
        pub const UrlIs = @compileError("'UrlIs' requires that UNICODE be set to true or false in the root module");
        pub const UrlGetLocation = @compileError("'UrlGetLocation' requires that UNICODE be set to true or false in the root module");
        pub const UrlUnescape = @compileError("'UrlUnescape' requires that UNICODE be set to true or false in the root module");
        pub const UrlEscape = @compileError("'UrlEscape' requires that UNICODE be set to true or false in the root module");
        pub const UrlCreateFromPath = @compileError("'UrlCreateFromPath' requires that UNICODE be set to true or false in the root module");
        pub const PathCreateFromUrl = @compileError("'PathCreateFromUrl' requires that UNICODE be set to true or false in the root module");
        pub const UrlHash = @compileError("'UrlHash' requires that UNICODE be set to true or false in the root module");
        pub const UrlGetPart = @compileError("'UrlGetPart' requires that UNICODE be set to true or false in the root module");
        pub const UrlApplyScheme = @compileError("'UrlApplyScheme' requires that UNICODE be set to true or false in the root module");
        pub const ParseURL = @compileError("'ParseURL' requires that UNICODE be set to true or false in the root module");
        pub const SHDeleteEmptyKey = @compileError("'SHDeleteEmptyKey' requires that UNICODE be set to true or false in the root module");
        pub const SHDeleteKey = @compileError("'SHDeleteKey' requires that UNICODE be set to true or false in the root module");
        pub const SHDeleteValue = @compileError("'SHDeleteValue' requires that UNICODE be set to true or false in the root module");
        pub const SHGetValue = @compileError("'SHGetValue' requires that UNICODE be set to true or false in the root module");
        pub const SHSetValue = @compileError("'SHSetValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetValue = @compileError("'SHRegGetValue' requires that UNICODE be set to true or false in the root module");
        pub const SHQueryValueEx = @compileError("'SHQueryValueEx' requires that UNICODE be set to true or false in the root module");
        pub const SHEnumKeyEx = @compileError("'SHEnumKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const SHEnumValue = @compileError("'SHEnumValue' requires that UNICODE be set to true or false in the root module");
        pub const SHQueryInfoKey = @compileError("'SHQueryInfoKey' requires that UNICODE be set to true or false in the root module");
        pub const SHCopyKey = @compileError("'SHCopyKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetPath = @compileError("'SHRegGetPath' requires that UNICODE be set to true or false in the root module");
        pub const SHRegSetPath = @compileError("'SHRegSetPath' requires that UNICODE be set to true or false in the root module");
        pub const SHRegCreateUSKey = @compileError("'SHRegCreateUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegOpenUSKey = @compileError("'SHRegOpenUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegQueryUSValue = @compileError("'SHRegQueryUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegWriteUSValue = @compileError("'SHRegWriteUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegDeleteUSValue = @compileError("'SHRegDeleteUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegDeleteEmptyUSKey = @compileError("'SHRegDeleteEmptyUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegEnumUSKey = @compileError("'SHRegEnumUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegEnumUSValue = @compileError("'SHRegEnumUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegQueryInfoUSKey = @compileError("'SHRegQueryInfoUSKey' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetUSValue = @compileError("'SHRegGetUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegSetUSValue = @compileError("'SHRegSetUSValue' requires that UNICODE be set to true or false in the root module");
        pub const SHRegGetBoolUSValue = @compileError("'SHRegGetBoolUSValue' requires that UNICODE be set to true or false in the root module");
        pub const AssocQueryString = @compileError("'AssocQueryString' requires that UNICODE be set to true or false in the root module");
        pub const AssocQueryStringByKey = @compileError("'AssocQueryStringByKey' requires that UNICODE be set to true or false in the root module");
        pub const AssocQueryKey = @compileError("'AssocQueryKey' requires that UNICODE be set to true or false in the root module");
        pub const SHOpenRegStream = @compileError("'SHOpenRegStream' requires that UNICODE be set to true or false in the root module");
        pub const SHOpenRegStream2 = @compileError("'SHOpenRegStream2' requires that UNICODE be set to true or false in the root module");
        pub const SHCreateStreamOnFile = @compileError("'SHCreateStreamOnFile' requires that UNICODE be set to true or false in the root module");
        pub const GetAcceptLanguages = @compileError("'GetAcceptLanguages' requires that UNICODE be set to true or false in the root module");
        pub const SHFormatDateTime = @compileError("'SHFormatDateTime' requires that UNICODE be set to true or false in the root module");
        pub const SHMessageBoxCheck = @compileError("'SHMessageBoxCheck' requires that UNICODE be set to true or false in the root module");
        pub const SHSendMessageBroadcast = @compileError("'SHSendMessageBroadcast' requires that UNICODE be set to true or false in the root module");
        pub const SHStripMneumonic = @compileError("'SHStripMneumonic' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (105)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const BYTE_BLOB = @import("../system/com.zig").BYTE_BLOB;
const CHAR = @import("../foundation.zig").CHAR;
const COMDLG_FILTERSPEC = @import("../ui/shell/common.zig").COMDLG_FILTERSPEC;
const COORD = @import("../system/console.zig").COORD;
const CREATESTRUCTW = @import("../ui/windows_and_messaging.zig").CREATESTRUCTW;
const DEVICE_SCALE_FACTOR = @import("../ui/shell/common.zig").DEVICE_SCALE_FACTOR;
const DISPPARAMS = @import("../system/com.zig").DISPPARAMS;
const EXCEPINFO = @import("../system/com.zig").EXCEPINFO;
const FILE_FLAGS_AND_ATTRIBUTES = @import("../storage/file_system.zig").FILE_FLAGS_AND_ATTRIBUTES;
const FILETIME = @import("../foundation.zig").FILETIME;
const FORMATETC = @import("../system/com.zig").FORMATETC;
const GETPROPERTYSTOREFLAGS = @import("../ui/shell/properties_system.zig").GETPROPERTYSTOREFLAGS;
const HACCEL = @import("../ui/windows_and_messaging.zig").HACCEL;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HDC = @import("../graphics/gdi.zig").HDC;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HIMAGELIST = @import("../ui/controls.zig").HIMAGELIST;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HMENU = @import("../ui/windows_and_messaging.zig").HMENU;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HPALETTE = @import("../graphics/gdi.zig").HPALETTE;
const HPROPSHEETPAGE = @import("../ui/controls.zig").HPROPSHEETPAGE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IBindCtx = @import("../system/com.zig").IBindCtx;
const IBindStatusCallback = @import("../system/com.zig").IBindStatusCallback;
const ICondition = @import("../system/search.zig").ICondition;
const IConnectionPoint = @import("../system/com.zig").IConnectionPoint;
const IDataObject = @import("../system/com.zig").IDataObject;
const IDCompositionAnimation = @import("../graphics/direct_composition.zig").IDCompositionAnimation;
const IDispatch = @import("../system/com.zig").IDispatch;
const IDropSource = @import("../system/ole.zig").IDropSource;
const IDropTarget = @import("../system/ole.zig").IDropTarget;
const IEnumFORMATETC = @import("../system/com.zig").IEnumFORMATETC;
const IEnumGUID = @import("../system/com.zig").IEnumGUID;
const IEnumString = @import("../system/com.zig").IEnumString;
const IEnumUnknown = @import("../system/com.zig").IEnumUnknown;
const IMalloc = @import("../system/com.zig").IMalloc;
const IMoniker = @import("../system/com.zig").IMoniker;
const IObjectArray = @import("../ui/shell/common.zig").IObjectArray;
const IOleCommandTarget = @import("../system/ole.zig").IOleCommandTarget;
const IOleInPlaceSite = @import("../system/ole.zig").IOleInPlaceSite;
const IOleObject = @import("../system/ole.zig").IOleObject;
const IOleWindow = @import("../system/ole.zig").IOleWindow;
const IPersist = @import("../system/com.zig").IPersist;
const IPropertyBag = @import("../system/com/structured_storage.zig").IPropertyBag;
const IPropertyChangeArray = @import("../ui/shell/properties_system.zig").IPropertyChangeArray;
const IPropertyDescriptionList = @import("../ui/shell/properties_system.zig").IPropertyDescriptionList;
const IPropertySetStorage = @import("../system/com/structured_storage.zig").IPropertySetStorage;
const IPropertyStore = @import("../ui/shell/properties_system.zig").IPropertyStore;
const IServiceProvider = @import("../system/com.zig").IServiceProvider;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const ITEMIDLIST = @import("../ui/shell/common.zig").ITEMIDLIST;
const IUnknown = @import("../system/com.zig").IUnknown;
const IXMLDOMDocument = @import("../data/xml/ms_xml.zig").IXMLDOMDocument;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const LOGFONTW = @import("../graphics/gdi.zig").LOGFONTW;
const LPARAM = @import("../foundation.zig").LPARAM;
const LPFNSVADDPROPSHEETPAGE = @import("../ui/controls.zig").LPFNSVADDPROPSHEETPAGE;
const LPTHREAD_START_ROUTINE = @import("../system/threading.zig").LPTHREAD_START_ROUTINE;
const LRESULT = @import("../foundation.zig").LRESULT;
const LSTATUS = @import("../foundation.zig").LSTATUS;
const MSG = @import("../ui/windows_and_messaging.zig").MSG;
const NETRESOURCEA = @import("../network_management/wnet.zig").NETRESOURCEA;
const NMHDR = @import("../ui/controls.zig").NMHDR;
const NTSTATUS = @import("../foundation.zig").NTSTATUS;
const OLECMDEXECOPT = @import("../system/ole.zig").OLECMDEXECOPT;
const OLECMDF = @import("../system/ole.zig").OLECMDF;
const OLECMDID = @import("../system/ole.zig").OLECMDID;
const OleMenuGroupWidths = @import("../system/ole.zig").OleMenuGroupWidths;
const OVERLAPPED = @import("../system/io.zig").OVERLAPPED;
const PDOPSTATUS = @import("../ui/shell/properties_system.zig").PDOPSTATUS;
const PERCEIVED = @import("../ui/shell/common.zig").PERCEIVED;
const POINT = @import("../foundation.zig").POINT;
const POINTL = @import("../foundation.zig").POINTL;
const PROCESS_INFORMATION = @import("../system/threading.zig").PROCESS_INFORMATION;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const READYSTATE = @import("../system/ole.zig").READYSTATE;
const RECT = @import("../foundation.zig").RECT;
const RECTL = @import("../foundation.zig").RECTL;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;
const SHANDLE_PTR = @import("../foundation.zig").SHANDLE_PTR;
const SHELLDETAILS = @import("../ui/shell/common.zig").SHELLDETAILS;
const SHITEMID = @import("../ui/shell/common.zig").SHITEMID;
const SIZE = @import("../foundation.zig").SIZE;
const SOFTDISTINFO = @import("../system/com/urlmon.zig").SOFTDISTINFO;
const STARTUPINFOW = @import("../system/threading.zig").STARTUPINFOW;
const STRRET = @import("../ui/shell/common.zig").STRRET;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const TBBUTTON = @import("../ui/controls.zig").TBBUTTON;
const ULARGE_INTEGER = @import("../foundation.zig").ULARGE_INTEGER;
const VARIANT = @import("../system/com.zig").VARIANT;
const WIN32_FIND_DATAA = @import("../storage/file_system.zig").WIN32_FIND_DATAA;
const WIN32_FIND_DATAW = @import("../storage/file_system.zig").WIN32_FIND_DATAW;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "SUBCLASSPROC")) { _ = SUBCLASSPROC; }
    if (@hasDecl(@This(), "BFFCALLBACK")) { _ = BFFCALLBACK; }
    if (@hasDecl(@This(), "LPFNDFMCALLBACK")) { _ = LPFNDFMCALLBACK; }
    if (@hasDecl(@This(), "LPFNVIEWCALLBACK")) { _ = LPFNVIEWCALLBACK; }
    if (@hasDecl(@This(), "PFNCANSHAREFOLDERW")) { _ = PFNCANSHAREFOLDERW; }
    if (@hasDecl(@This(), "PFNSHOWSHAREFOLDERUIW")) { _ = PFNSHOWSHAREFOLDERUIW; }
    if (@hasDecl(@This(), "DLLGETVERSIONPROC")) { _ = DLLGETVERSIONPROC; }
    if (@hasDecl(@This(), "APPLET_PROC")) { _ = APPLET_PROC; }
    if (@hasDecl(@This(), "PAPPSTATE_CHANGE_ROUTINE")) { _ = PAPPSTATE_CHANGE_ROUTINE; }
    if (@hasDecl(@This(), "PAPPCONSTRAIN_CHANGE_ROUTINE")) { _ = PAPPCONSTRAIN_CHANGE_ROUTINE; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (2)
//--------------------------------------------------------------------------------
pub const common = @import("shell/common.zig");
pub const properties_system = @import("shell/properties_system.zig");
